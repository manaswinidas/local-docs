<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Web on Reactive Stack</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



</head><body id="spring-web-reactive" class="book toc2 toc-left" ><div id="header">
<h1>Web on Reactive Stack</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#webflux">1。春季WebFlux</a>
<ul class="sectlevel2">
<li><a href="#webflux-new-framework">1.1。总览</a>
<ul class="sectlevel3">
<li><a href="#webflux-why-reactive">1.1.1。定义“反应式”</a></li>
<li><a href="#webflux-reactive-api">1.1.2。反应性API</a></li>
<li><a href="#webflux-programming-models">1.1.3。编程模型</a></li>
<li><a href="#webflux-framework-choice">1.1.4。适用性</a></li>
<li><a href="#webflux-server-choice">1.1.5。伺服器</a></li>
<li><a href="#webflux-performance">1.1.6。性能</a></li>
<li><a href="#webflux-concurrency-model">1.1.7。并发模型</a></li>
</ul>
</li>
<li><a href="#webflux-reactive-spring-web">1.2。反应堆芯</a>
<ul class="sectlevel3">
<li><a href="#webflux-httphandler">1.2.1。<code>HttpHandler</code></a></li>
<li><a href="#webflux-web-handler-api">1.2.2。 <code>WebHandler</code> API</a>
<ul class="sectlevel4">
<li><a href="#webflux-web-handler-api-special-beans">Special bean types</a></li>
<li><a href="#webflux-form-data">表格数据</a></li>
<li><a href="#webflux-multipart">多部分数据</a></li>
<li><a href="#webflux-forwarded-headers">转发的标题</a></li>
</ul>
</li>
<li><a href="#webflux-filters">1.2.3。筛选器</a>
<ul class="sectlevel4">
<li><a href="#webflux-filters-cors">CORS</a></li>
</ul>
</li>
<li><a href="#webflux-exception-handler">1.2.4。例外情况</a></li>
<li><a href="#webflux-codecs">1.2.5。编解码器</a>
<ul class="sectlevel4">
<li><a href="#webflux-codecs-jackson">杰克逊JSON</a></li>
<li><a href="#webflux-codecs-forms">表格数据</a></li>
<li><a href="#webflux-codecs-multipart">多部分</a></li>
<li><a href="#webflux-codecs-limits">限度</a></li>
<li><a href="#webflux-codecs-streaming">流媒体</a></li>
<li><a href="#webflux-codecs-buffers"><code>DataBuffer</code></a></li>
</ul>
</li>
<li><a href="#webflux-logging">1.2.6。记录中</a>
<ul class="sectlevel4">
<li><a href="#webflux-logging-id">记录编号</a></li>
<li><a href="#webflux-logging-sensitive-data">敏感数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-dispatcher-handler">1.3。<code>DispatcherHandler</code></a>
<ul class="sectlevel3">
<li><a href="#webflux-special-bean-types">1.3.1。Special bean types</a></li>
<li><a href="#webflux-framework-config">1.3.2。WebFlux配置</a></li>
<li><a href="#webflux-dispatcher-handler-sequence">1.3.3。处理中</a></li>
<li><a href="#webflux-resulthandling">1.3.4。结果处理</a></li>
<li><a href="#webflux-dispatcher-exceptions">1.3.5。例外情况</a></li>
<li><a href="#webflux-viewresolution">1.3.6。查看分辨率</a>
<ul class="sectlevel4">
<li><a href="#webflux-viewresolution-handling">处理方式</a></li>
<li><a href="#webflux-redirecting-redirect-prefix">重新导向</a></li>
<li><a href="#webflux-multiple-representations">内容协商</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-controller">1.4。带注释的控制器</a>
<ul class="sectlevel3">
<li><a href="#webflux-ann-controller">1.4.1。<code>@Controller</code></a></li>
<li><a href="#webflux-ann-requestmapping">1.4.2。请求映射</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-requestmapping-uri-templates">URI模式</a></li>
<li><a href="#webflux-ann-requestmapping-pattern-comparison">模式比较</a></li>
<li><a href="#webflux-ann-requestmapping-consumes">消耗媒体类型</a></li>
<li><a href="#webflux-ann-requestmapping-produces">可生产的媒体类型</a></li>
<li><a href="#webflux-ann-requestmapping-params-and-headers">参数和标题</a></li>
<li><a href="#webflux-ann-requestmapping-head-options">HTTP HEAD，选项</a></li>
<li><a href="#webflux-ann-requestmapping-composed">自定义注释</a></li>
<li><a href="#webflux-ann-requestmapping-registration">明确注册</a></li>
</ul>
</li>
<li><a href="#webflux-ann-methods">1.4.3。处理程序方法</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-arguments">方法参数</a></li>
<li><a href="#webflux-ann-return-types">返回值</a></li>
<li><a href="#webflux-ann-typeconversion">类型转换</a></li>
<li><a href="#webflux-ann-matrix-variables">矩阵变量</a></li>
<li><a href="#webflux-ann-requestparam"><code>@RequestParam</code></a></li>
<li><a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a></li>
<li><a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a></li>
<li><a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a></li>
<li><a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a></li>
<li><a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a></li>
<li><a href="#webflux-ann-requestattrib"><code>@RequestAttribute</code></a></li>
<li><a href="#webflux-multipart-forms">多部分内容</a></li>
<li><a href="#webflux-ann-requestbody"><code>@RequestBody</code></a></li>
<li><a href="#webflux-ann-httpentity"><code>HttpEntity</code></a></li>
<li><a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a></li>
<li><a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a></li>
<li><a href="#webflux-ann-jackson">杰克逊JSON</a></li>
</ul>
</li>
<li><a href="#webflux-ann-modelattrib-methods">1.4.4。<code>Model</code></a></li>
<li><a href="#webflux-ann-initbinder">1.4.5。<code>DataBinder</code></a></li>
<li><a href="#webflux-ann-controller-exceptions">1.4.6。管理异常</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-rest-exceptions">REST API例外</a></li>
</ul>
</li>
<li><a href="#webflux-ann-controller-advice">1.4.7。控制器建议</a></li>
</ul>
</li>
<li><a href="#webflux-fn">1.5。功能端点</a>
<ul class="sectlevel3">
<li><a href="#webflux-fn-overview">1.5.1。总览</a></li>
<li><a href="#webflux-fn-handler-functions">1.5.2。处理函数</a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-request"><code>ServerRequest</code></a></li>
<li><a href="#webflux-fn-response"><code>ServerResponse</code></a></li>
<li><a href="#webflux-fn-handler-classes">处理程序类</a></li>
<li><a href="#webflux-fn-handler-validation">验证方式</a></li>
</ul>
</li>
<li><a href="#webflux-fn-router-functions">1.5.3。<code>RouterFunction</code></a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-predicates">谓词</a></li>
<li><a href="#webflux-fn-routes">路线</a></li>
<li><a href="#nested-routes">嵌套路线</a></li>
</ul>
</li>
<li><a href="#webflux-fn-running">1.5.4。运行服务器</a></li>
<li><a href="#webflux-fn-handler-filter-function">1.5.5。过滤处理程序功能</a></li>
</ul>
</li>
<li><a href="#webflux-uri-building">1.6。URI链接</a>
<ul class="sectlevel3">
<li><a href="#web-uricomponents">1.6.1。UriComponents</a></li>
<li><a href="#web-uribuilder">1.6.2。UriBuilder</a></li>
<li><a href="#web-uri-encoding">1.6.3。URI编码</a></li>
</ul>
</li>
<li><a href="#webflux-cors">1.7。CORS</a>
<ul class="sectlevel3">
<li><a href="#webflux-cors-intro">1.7.1。介绍</a></li>
<li><a href="#webflux-cors-processing">1.7.2。处理中</a></li>
<li><a href="#webflux-cors-controller">1.7.3。<code>@CrossOrigin</code></a></li>
<li><a href="#webflux-cors-global">1.7.4。全局配置</a></li>
<li><a href="#webflux-cors-webfilter">1.7.5。CORS<code>WebFilter</code></a></li>
</ul>
</li>
<li><a href="#webflux-web-security">1.8。网络安全</a></li>
<li><a href="#webflux-view">1.9。查看技术</a>
<ul class="sectlevel3">
<li><a href="#webflux-view-thymeleaf">1.9.1。胸腺</a></li>
<li><a href="#webflux-view-freemarker">1.9.2。FreeMarker</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-freemarker-contextconfig">查看配置</a></li>
<li><a href="#webflux-views-freemarker">FreeMarker配置</a></li>
<li><a href="#webflux-view-freemarker-forms">表格处理</a></li>
</ul>
</li>
<li><a href="#webflux-view-script">1.9.3。脚本视图</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-script-dependencies">要求</a></li>
<li><a href="#webflux-view-script-integrate">脚本模板</a></li>
</ul>
</li>
<li><a href="#webflux-view-httpmessagewriter">1.9.4。JSON和XML</a></li>
</ul>
</li>
<li><a href="#webflux-caching">1.10。HTTP缓存</a>
<ul class="sectlevel3">
<li><a href="#webflux-caching-cachecontrol">1.10.1。<code>CacheControl</code></a></li>
<li><a href="#webflux-caching-etag-lastmodified">1.10.2。控制器</a></li>
<li><a href="#webflux-caching-static-resources">1.10.3。静态资源</a></li>
</ul>
</li>
<li><a href="#webflux-config">1.11。WebFlux配置</a>
<ul class="sectlevel3">
<li><a href="#webflux-config-enable">1.11.1。启用WebFlux配置</a></li>
<li><a href="#webflux-config-customize">1.11.2。WebFlux配置API</a></li>
<li><a href="#webflux-config-conversion">1.11.3。转换，格式化</a></li>
<li><a href="#webflux-config-validation">1.11.4。验证方式</a></li>
<li><a href="#webflux-config-content-negotiation">1.11.5。内容类型解析器</a></li>
<li><a href="#webflux-config-message-codecs">1.11.6。HTTP消息编解码器</a></li>
<li><a href="#webflux-config-view-resolvers">1.11.7。查看解析器</a></li>
<li><a href="#webflux-config-static-resources">1.11.8。静态资源</a></li>
<li><a href="#webflux-config-path-matching">1.11.9。路径匹配</a></li>
<li><a href="#webflux-config-advanced-java">1.11.10。高级配置模式</a></li>
</ul>
</li>
<li><a href="#webflux-http2">1.12。HTTP / 2</a></li>
</ul>
</li>
<li><a href="#webflux-client">2。网络客户端</a>
<ul class="sectlevel2">
<li><a href="#webflux-client-builder">2.1。组态</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-builder-reactor">2.1.1。反应堆净值</a>
<ul class="sectlevel4">
<li><a href="#webflux-client-builder-reactor-resources">资源资源</a></li>
<li><a href="#webflux-client-builder-reactor-timeout">超时时间</a></li>
</ul>
</li>
<li><a href="#webflux-client-builder-jetty">2.1.2。码头</a></li>
</ul>
</li>
<li><a href="#webflux-client-retrieve">2.2。<code>retrieve()</code></a></li>
<li><a href="#webflux-client-exchange">2.3。<code>exchange()</code></a></li>
<li><a href="#webflux-client-body">2.4。请求正文</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-body-form">2.4.1。表格数据</a></li>
<li><a href="#webflux-client-body-multipart">2.4.2。多部分数据</a></li>
</ul>
</li>
<li><a href="#webflux-client-filter">2.5。客户端过滤器</a></li>
<li><a href="#webflux-client-synchronous">2.6。同步使用</a></li>
<li><a href="#webflux-client-testing">2.7。测试中</a></li>
</ul>
</li>
<li><a href="#webflux-websocket">3。Web套接字</a>
<ul class="sectlevel2">
<li><a href="#websocket-intro">3.1。WebSocket简介</a>
<ul class="sectlevel3">
<li><a href="#websocket-intro-architecture">3.1.1。HTTP与WebSocket</a></li>
<li><a href="#websocket-intro-when-to-use">3.1.2。何时使用WebSockets</a></li>
</ul>
</li>
<li><a href="#webflux-websocket-server">3.2。WebSocket API</a>
<ul class="sectlevel3">
<li><a href="#webflux-websocket-server-handler">3.2.1。服务器</a></li>
<li><a href="#webflux-websockethandler">3.2.2。<code>WebSocketHandler</code></a></li>
<li><a href="#webflux-websocket-databuffer">3.2.3。<code>DataBuffer</code></a></li>
<li><a href="#webflux-websocket-server-handshake">3.2.4。握手</a></li>
<li><a href="#webflux-websocket-server-config">3.2.5。服务器配置</a></li>
<li><a href="#webflux-websocket-server-cors">3.2.6。CORS</a></li>
<li><a href="#webflux-websocket-client">3.2.7。客户</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-test">4。测试中</a></li>
<li><a href="#rsocket">5，插座</a>
<ul class="sectlevel2">
<li><a href="#rsocket-overview">5.1。总览</a>
<ul class="sectlevel3">
<li><a href="#rsocket-protocol">5.1.1。协议书</a></li>
<li><a href="#rsocket-java">5.1.2。Java实现</a></li>
<li><a href="#rsocket-spring">5.1.3。Spring 支持</a></li>
</ul>
</li>
<li><a href="#rsocket-requester">5.2。RSocketRequester</a>
<ul class="sectlevel3">
<li><a href="#rsocket-requester-client">5.2.1。客户要求者</a>
<ul class="sectlevel4">
<li><a href="#rsocket-requester-client-setup">连接设置</a></li>
<li><a href="#rsocket-requester-client-strategies">策略</a></li>
<li><a href="#rsocket-requester-client-responder">客户回应者</a></li>
<li><a href="#rsocket-requester-client-advanced">高级</a></li>
</ul>
</li>
<li><a href="#rsocket-requester-server">5.2.2。服务器请求者</a></li>
<li><a href="#rsocket-requester-requests">5.2.3。要求</a></li>
</ul>
</li>
<li><a href="#rsocket-annot-responders">5.3。带注释的响应者</a>
<ul class="sectlevel3">
<li><a href="#rsocket-annot-responders-server">5.3.1。服务器响应者</a></li>
<li><a href="#rsocket-annot-responders-client">5.3.2。客户回应者</a></li>
<li><a href="#rsocket-annot-messagemapping">5.3.3。@MessageMapping</a></li>
<li><a href="#rsocket-annot-connectmapping">5.3.4。@ConnectMapping</a></li>
</ul>
</li>
<li><a href="#rsocket-metadata-extractor">5.4。元数据提取器</a></li>
</ul>
</li>
<li><a href="#webflux-reactive-libraries">6。反应性图书馆</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>文档的此部分涵盖对基于<a href="https://www.reactive-streams.org/">Reactive Streams</a> API构建的<a href="https://www.reactive-streams.org/">反应堆</a> Web应用程序的支持，该应用程序可在非阻塞服务器（例如Netty，Undertow和Servlet 3.1+容器）上运行。各章介绍了<a href="#webflux">Spring WebFlux</a>框架， <a href="#webflux-client"><code>WebClient</code></a> ，支持<a href="#webflux-test">测试</a>和<a href="#webflux-reactive-libraries">反应库</a> 。对于Servlet堆栈Web应用程序，请参阅<a href="web.html#spring-web">Servlet Stack上的Web</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux"><a class="anchor" href="#webflux"></a> 1。春季WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework 中包含的原始Web框架Spring Web MVC是专门为Servlet API和Servlet容器而构建的。反应性堆栈Web框架Spring WebFlux在更高版本5.0中添加。它是完全非阻塞的，支持<a href="https://www.reactive-streams.org/">Reactive Streams</a>背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。</p>
</div>
<div class="paragraph">
<p>这两个Web框架都反映了其源模块的名称（ <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a> ），并在Spring Framework中并存。每个模块都是可选的。应用程序可以使用一个或另一个模块，或者在某些情况下可以使用两个模块，例如，带有响应式的Spring MVC控制器<code>WebClient</code> 。</p>
</div>
<div class="sect2">
<h3 id="webflux-new-framework"><a class="anchor" href="#webflux-new-framework"></a> 1.1。总览</h3>
<div class="paragraph">
<p>为什么创建Spring WebFlux？</p>
</div>
<div class="paragraph">
<p>答案的一部分是需要一个非阻塞式的Web堆栈来处理少量线程的并发并使用更少的硬件资源进行扩展。Servlet 3.1确实提供了用于非阻塞I / O的API。但是，使用它会导致Servlet API的其余部分与合同同步（ <code>Filter</code> ， <code>Servlet</code> ）或阻止（ <code>getParameter</code> ， <code>getPart</code> ）。这是促使新的通用API成为所有非阻塞运行时的基础的动机。这很重要，因为服务器（例如Netty）已在异步，非阻塞空间中建立良好。</p>
</div>
<div class="paragraph">
<p>答案的另一部分是函数式编程。就像在Java 5中添加注释会创造机会（例如带注释的REST控制器或单元测试）一样，在Java 8中添加lambda表达式也会为Java中的功能API创造机会。这对于非阻塞应用程序和延续样式的API（如<code>CompletableFuture</code>和<a href="http://reactivex.io/">ReactiveX</a> ），以实现异步逻辑的声明式组合。在编程模型级别，Java 8使Spring WebFlux能够与带注释的控制器一起提供功能性的Web端点。</p>
</div>
<div class="sect3">
<h4 id="webflux-why-reactive"><a class="anchor" href="#webflux-why-reactive"></a> 1.1.1。定义“反应式”</h4>
<div class="paragraph">
<p>我们谈到了“无障碍”和“功能性”，但是反应式意味着什么？</p>
</div>
<div class="paragraph">
<p>术语“反应性”是指围绕响应变化而构建的编程模型-网络组件响应I / O事件，UI控制器响应鼠标事件等。从这个意义上说，非阻塞是反应性的，因为随着操作完成或数据可用，我们现在处于响应通知的模式，而不是被阻塞。</p>
</div>
<div class="paragraph">
<p>我们Spring团队还有另一个重要机制与“反应性”相关联，这是不阻碍背压的机制。在同步命令式代码中，阻塞调用是强制调用者等待的一种自然的背压形式。在非阻塞代码中，控制事件的速率非常重要，这样快速的生产者就不会淹没其目的地。</p>
</div>
<div class="paragraph">
<p>Reactive Streams是一个<a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification">小的规范</a> （在Java 9中也<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">采用</a>了），它定义了带有反压力的异步组件之间的交互。例如，数据存储库（充当<a href="https://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">Publisher</a> ）可以生成HTTP服务器（充当<a href="https://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">Subscriber</a> ）然后可以写入响应的数据。Reactive Streams的主要目的是让订阅者控制发布者生成数据的速度或速度。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<strong>常见问题：如果出版商不能放慢脚步怎么办？</strong><br>反应流的目的仅仅是建立机制和边界。如果发布者无法放慢速度，则必须决定是缓冲，删除还是失败。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-reactive-api"><a class="anchor" href="#webflux-reactive-api"></a> 1.1.2。反应性API</h4>
<div class="paragraph">
<p>反应流对于互操作性起着重要作用。库和基础结构组件对此很感兴趣，但由于它太底层了，它作为应用程序API的用处不大。应用程序需要更高级别且功能更丰富的API来组成异步逻辑-与Java 8类似<code>Stream</code> API，但不仅适用于集合。这就是反应式库的作用。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor">Reactor</a>是Spring WebFlux的首选反应库。它提供了<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html"><code>Mono</code></a>和<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html"><code>Flux</code></a>适用于0..1数据序列的API类型（ <code>Mono</code> ）和0 ..N（ <code>Flux</code> ）通过与ReactiveX <a href="http://reactivex.io/documentation/operators.html">运算符词汇</a>保持一致的丰富运算<a href="http://reactivex.io/documentation/operators.html">符集</a> 。Reactor是Reactive Streams库，因此，它的所有运算符都支持无阻塞背压。Reactor非常注重服务器端Java。它是与Spring紧密合作开发的。</p>
</div>
<div class="paragraph">
<p>WebFlux需要Reactor作为核心依赖项，但是它可以通过Reactive Streams与其他React库进行互操作。通常，WebFlux API接受纯<code>Publisher</code>作为输入，将其内部调整为Reactor类型，使用该类型，然后返回<code>Flux</code>或一个<code>Mono</code>作为输出。所以，你可以通过任何<code>Publisher</code>作为输入，您可以对输出应用操作，但是您需要调整输出以与另一个反应式库一起使用。只要可行（例如，带注释的控制器），WebFlux就会透明地适应RxJava或其他反应式库的使用。有关更多详细信息，请参见<a href="#webflux-reactive-libraries">反应式库</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">除了响应式API外，WebFlux还可以与Kotlin中的<a href="languages.html#coroutines">Coroutines</a> API一起使用，从而提供了更强制的编程风格。以下Kotlin代码示例将随Coroutines API一起提供。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-programming-models"><a class="anchor" href="#webflux-programming-models"></a> 1.1.3。编程模型</h4>
<div class="paragraph">
<p>的<code>spring-web</code>模块包含Spring WebFlux基础的反应式基础，包括HTTP抽象，用于支持的服务器的Reactive Streams <a href="#webflux-httphandler">适配器</a> ， <a href="#webflux-codecs">编解码器</a>和核心<a href="#webflux-web-handler-api"><code>WebHandler</code></a>与Servlet <a href="#webflux-web-handler-api">API</a>相当的API，但具有非阻塞合同。</p>
</div>
<div class="paragraph">
<p>在此基础上，Spring WebFlux提供了两种编程模型的选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-controller">带注释的控制器</a> ：与Spring MVC一致，并基于与<code>spring-web</code>模块。Spring MVC和WebFlux控制器都支持反应式（Reactor和RxJava）返回类型，因此，区分它们并不容易。一个显着的区别是WebFlux还支持响应式<code>@RequestBody</code>论点。</p>
</li>
<li>
<p><a href="#webflux-fn">功能端点</a> ：基于Lambda的轻量级功能编程模型。您可以将其视为一个小型库或一组实用程序，应用程序可以使用它们来路由和处理请求。带注释的控制器的最大区别在于，应用程序负责从头到尾的请求处理，而不是通过注释声明意图并被回调。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-framework-choice"><a class="anchor" href="#webflux-framework-choice"></a> 1.1.4。适用性</h4>
<div class="paragraph">
<p>Spring MVC还是WebFlux？</p>
</div>
<div class="paragraph">
<p>一个自然的问题要问，但建立了一个不合理的二分法。实际上，两者共同努力扩大了可用选项的范围。两者的设计旨在实现彼此的连续性和一致性，它们可以并行使用，并且双方的反馈对双方都有利。下图显示了两者之间的关系，它们的共同点以及各自的独特支持：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-mvc-and-webflux-venn.png" alt="Spring MVC和Webflux Venn">
</div>
</div>
<div class="paragraph">
<p>我们建议您考虑以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您有运行正常的Spring MVC应用程序，则无需更改。命令式编程是编写，理解和调试代码的最简单方法。您有最大的库选择空间，因为从历史上看，大多数库都处于阻塞状态。</p>
</li>
<li>
<p>如果您已经在购买无阻塞Web堆栈，那么Spring WebFlux在此空间中提供的执行模型优势与其他模型相同，并且还提供服务器选择（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），选择编程模型（带注释的控制器和功能性Web端点），以及选择反应式库（Reactor，RxJava或其他）。</p>
</li>
<li>
<p>如果您对与Java 8 lambda或Kotlin一起使用的轻量级功能性Web框架感兴趣，可以使用Spring WebFlux功能性Web端点。对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>
</li>
<li>
<p>在微服务架构中，您可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux功能端点的应用程序。在两个框架中都支持相同的基于注释的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>
</li>
<li>
<p>评估应用程序的一种简单方法是检查其依赖关系。如果您要使用阻塞性持久性API（JPA，JDBC）或网络API，则Spring MVC至少是常见体系结构的最佳选择。在Reactor和RxJava上在单独的线程上执行阻塞调用在技术上都是可行的，但是您不会充分利用非阻塞Web堆栈。</p>
</li>
<li>
<p>如果您的Spring MVC应用程序具有对远程服务的调用，请尝试响应式<code>WebClient</code> 。您可以直接从Spring MVC控制器方法返回反应类型（Reactor，RxJava <a href="#webflux-reactive-libraries">或其他</a> ）。每个呼叫的等待时间或呼叫之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他反应式组件。</p>
</li>
<li>
<p>如果您有庞大的团队，请牢记向无阻塞，功能性和声明性编程的过渡过程中的学习曲线陡峭。在没有完全切换的情况下启动的实际方法是使用无功<code>WebClient</code> 。除此之外，从小处着手并衡量收益。我们希望，对于广泛的应用程序，这种转变是不必要的。如果不确定要寻找什么好处，请先了解无阻塞I / O的工作原理（例如，单线程Node.js上的并发性）及其影响。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-server-choice"><a class="anchor" href="#webflux-server-choice"></a> 1.1.5。伺服器</h4>
<div class="paragraph">
<p>Tomcat，Jetty，Servlet 3.1+容器以及Netty和Undertow等非Servlet运行时都支持Spring WebFlux。所有服务器都适应于低级<a href="#webflux-httphandler">通用API，</a>因此可以跨服务器支持更高级别的<a href="#webflux-programming-models">编程模型</a> 。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux不具有内置支持来启动或停止服务器。但是，从Spring配置和<a href="#webflux-config">WebFlux基础</a>结构<a href="#webflux-web-handler-api">组装</a>应用程序并用几行代码<a href="#webflux-httphandler">运行它</a>很容易。</p>
</div>
<div class="paragraph">
<p>Spring Boot具有一个WebFlux启动器，可以自动执行这些步骤。默认情况下，启动程序使用Netty，但是通过更改Maven或Gradle依赖关系，可以轻松切换到Tomcat，Jetty或Undertow。Spring Boot默认为Netty，因为它在异步，非阻塞空间中得到更广泛的使用，并允许客户端和服务器共享资源。</p>
</div>
<div class="paragraph">
<p>Tomcat和Jetty可以与Spring MVC和WebFlux一起使用。但是请记住，它们的使用方式非常不同。Spring MVC依靠Servlet阻塞I / O，并允许应用程序在需要时直接使用Servlet API。Spring WebFlux依赖于Servlet 3.1非阻塞I / O，并在低级适配器后面使用Servlet API，并且不公开供直接使用。</p>
</div>
<div class="paragraph">
<p>对于Undertow，Spring WebFlux直接使用Undertow API，而无需使用Servlet API。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-performance"><a class="anchor" href="#webflux-performance"></a> 1.1.6。性能</h4>
<div class="paragraph">
<p>表演具有许多特征和意义。反应和非阻塞通常不会使应用程序运行得更快。在某些情况下，它们可以（例如，如果使用<code>WebClient</code>并行执行远程调用）。总体而言，以非阻塞方式进行操作需要更多的工作，这可能会稍微增加所需的处理时间。</p>
</div>
<div class="paragraph">
<p>反应性和非阻塞性的主要预期好处是能够以较少的固定数量的线程和较少的内存进行扩展。这使应用程序在负载下更具弹性，因为它们以更可预测的方式扩展。但是，为了观察这些好处，您需要有一些延迟（包括缓慢的和不可预测的网络I / O）。这就是反应堆开始显示其优势的地方，差异可能很大。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-concurrency-model"><a class="anchor" href="#webflux-concurrency-model"></a> 1.1.7。并发模型</h4>
<div class="paragraph">
<p>Spring MVC和Spring WebFlux都支持带注释的控制器，但是并发模型以及阻塞和线程的默认假设存在关键差异。</p>
</div>
<div class="paragraph">
<p>在Spring MVC（通常是Servlet应用程序）中，假定应用程序可以阻塞当前线程（例如，用于远程调用），因此，servlet容器使用大线程池来吸收请求期间的潜在阻塞。处理。</p>
</div>
<div class="paragraph">
<p>在Spring WebFlux（通常是非阻塞服务器）中，假定应用程序未阻塞，因此，非阻塞服务器使用固定大小的小型线程池（事件循环工作器）来处理请求。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">“按比例缩放”和“少量线程”听起来似乎是矛盾的，但是从不阻塞当前线程（而是依靠回调）意味着您不需要额外的线程，因为没有阻塞调用可以吸收。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<div class="title">调用阻止API</div>
<p>如果确实需要使用阻止库怎么办？Reactor和RxJava都提供了<code>publishOn</code>操作员继续在其他线程上进行处理。这意味着容易逃生。但是请记住，阻塞式API不适用于此并发模型。</p>
</div>
<div class="paragraph">
<div class="title">可变状态</div>
<p>在Reactor和RxJava中，您可以通过运算符声明逻辑，然后在运行时形成反应性管道，在该阶段中，数据在不同的阶段被顺序处理。这样做的主要好处是，它使应用程序不必保护可变状态，因为该管道中的应用程序代码永远不会被同时调用。</p>
</div>
<div class="paragraph">
<div class="title">线程模型</div>
<p>您期望在运行Spring WebFlux的服务器上看到哪些线程？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在“原始” Spring WebFlux服务器上（例如，没有数据访问权限或其他可选依赖项），您可以期望该服务器有一个线程，而其他几个线程则可以进行请求处理（通常与CPU核心数量一样多）。但是，Servlet容器可能以更多线程开始（例如，Tomcat上为10），以支持Servlet（阻塞）I / O和Servlet 3.1（非阻塞）I / O使用。</p>
</li>
<li>
<p>反应式<code>WebClient</code>以事件循环风格进行操作。因此，您可以看到与之相关的固定数量的处理线程（例如， <code>reactor-http-nio-</code>和Reactor Netty连接器）。但是，如果客户端和服务器都使用Reactor Netty，则默认情况下，两者共享事件循环资源。</p>
</li>
<li>
<p>Reactor和RxJava提供了称为调度程序的线程池抽象，以与<code>publishOn</code>运算符，用于将处理切换到其他线程池。调度程序具有建议特定并发策略的名称，例如，“并行”（用于具有有限数量的线程的CPU绑定工作）或“弹性”（用于具有大量线程的I / O绑定）。如果看到这样的线程，则意味着某些代码正在使用特定的线程池<code>Scheduler</code>战略。</p>
</li>
<li>
<p>数据访问库和其他第三方依赖性也可以创建和使用自己的线程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">配置中</div>
<p>Spring Framework 不提供启动和停止<a href="#webflux-server-choice">服务器的</a>支持。要为服务器配置线程模型，您需要使用服务器特定的配置API，或者，如果您使用的是Spring Boot，请检查每台服务器的Spring Boot配置选项。您可以<a href="#webflux-client-builder">配置</a> <code>WebClient</code>直。对于所有其他库，请参阅其各自的文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-reactive-spring-web"><a class="anchor" href="#webflux-reactive-spring-web"></a> 1.2。反应堆芯</h3>
<div class="paragraph">
<p>的<code>spring-web</code>模块包含对反应式Web应用程序的以下基础支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于服务器请求处理，有两个级别的支持。</p>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-httphandler">HttpHandler</a> ：HTTP请求处理的基本协议，具有无阻塞I / O和Reactive Streams背压，以及Reactor Netty，Undertow，Tomcat，Jetty和任何Servlet 3.1+容器的适配器。</p>
</li>
<li>
<p><a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> ：稍高级别的通用Web API，用于处理请求，在此之上构建了具体的编程模型，例如带注释的控制器和功能端点。</p>
</li>
</ul>
</div>
</li>
<li>
<p>对于客户端，有一个基本的<code>ClientHttpConnector</code>签订合同以执行具有非阻塞I / O和响应流反压力的HTTP请求，以及<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>和响应式<a href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HttpClient的</a>适配器。应用程序中使用的更高级别的<a href="#webflux-client">WebClient</a>基于此基本协定。</p>
</li>
<li>
<p>对于客户端和服务器， <a href="#webflux-codecs">编解码器</a>用于序列化和反序列化HTTP请求和响应内容。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="webflux-httphandler"><a class="anchor" href="#webflux-httphandler"></a> 1.2.1。<code>HttpHandler</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>是具有单个方法的简单协定，用于处理请求和响应。它是故意最小的，其主要也是唯一的目的是成为对不同HTTP服务器API的最小抽象。</p>
</div>
<div class="paragraph">
<p>下表描述了受支持的服务器API：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:20%">
<col style="width:40%">
<col style="width:40%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">使用的服务器API</th>
<th class="tableblock halign-left valign-top">反应式流支持</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">净额</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/reactor/reactor-netty">反应堆净值</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">底拖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Undertow到Reactive Streams桥</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">雄猫</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1非阻塞I / O； Tomcat API读写ByteBuffers与byte []</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Servlet 3.1非阻塞I / O到响应流桥</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">码头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1非阻塞I / O； Jetty API编写ByteBuffers与byte []</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Servlet 3.1非阻塞I / O到响应流桥</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1容器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1非阻塞I / O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web：Servlet 3.1非阻塞I / O到响应流桥</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下表描述了服务器依赖性（另请参阅<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework">受支持的版本</a> ）：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">群组编号</th>
<th class="tableblock halign-left valign-top">工件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">反应堆净值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.projectreactor.netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">反应堆净额</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">底拖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.toow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">底核</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">雄猫</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.tomcat.embed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat嵌入式核心</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">码头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.eclipse.jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">码头服务器，码头服务器</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面的代码段显示了使用<code>HttpHandler</code>每个服务器API的适配器：</p>
</div>
<div class="paragraph">
<p><strong>反应堆净值</strong></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val handler: HttpHandler = ...
val adapter = ReactorHttpHandlerAdapter(handler)
HttpServer.create().host(host).port(port).handle(adapter).bind().block()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>底拖</strong></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val handler: HttpHandler = ...
val adapter = UndertowHttpHandlerAdapter(handler)
val server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build()
server.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>雄猫</strong></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty("java.io.tmpdir"));
Context rootContext = server.addContext("", base.getAbsolutePath());
Tomcat.addServlet(rootContext, "main", servlet);
rootContext.addServletMappingDecoded("/", "main");
server.setHost(host);
server.setPort(port);
server.start();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val handler: HttpHandler = ...
val servlet = TomcatHttpHandlerAdapter(handler)

val server = Tomcat()
val base = File(System.getProperty("java.io.tmpdir"))
val rootContext = server.addContext("", base.absolutePath)
Tomcat.addServlet(rootContext, "main", servlet)
rootContext.addServletMappingDecoded("/", "main")
server.host = host
server.setPort(port)
server.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>码头</strong></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
Servlet servlet = new JettyHttpHandlerAdapter(handler);

Server server = new Server();
ServletContextHandler contextHandler = new ServletContextHandler(server, "");
contextHandler.addServlet(new ServletHolder(servlet), "/");
contextHandler.start();

ServerConnector connector = new ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val handler: HttpHandler = ...
val servlet = JettyHttpHandlerAdapter(handler)

val server = Server()
val contextHandler = ServletContextHandler(server, "")
contextHandler.addServlet(ServletHolder(servlet), "/")
contextHandler.start();

val connector = ServerConnector(server)
connector.host = host
connector.port = port
server.addConnector(connector)
server.start()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Servlet 3.1+容器</strong></p>
</div>
<div class="paragraph">
<p>要将其作为WAR部署到任何Servlet 3.1+容器，您可以扩展并包括<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html"><code>AbstractReactiveWebInitializer</code></a>在战争中。该课程包装了<code>HttpHandler</code>与<code>ServletHttpHandlerAdapter</code>并将其注册为<code>Servlet</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-web-handler-api"><a class="anchor" href="#webflux-web-handler-api"></a> 1.2.2。 <code>WebHandler</code> API</h4>
<div class="paragraph">
<p>的<code>org.springframework.web.server</code>包建立在<a href="#webflux-httphandler"><code>HttpHandler</code></a>合同提供通用Web API，以通过多个链接处理请求<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html"><code>WebExceptionHandler</code></a> ， 多<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html"><code>WebFilter</code></a>和一个<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html"><code>WebHandler</code></a>零件。链条可以与<code>WebHttpHandlerBuilder</code>通过简单地指向春天<code>ApplicationContext</code> <a href="#webflux-web-handler-api-special-beans">自动检测</a>组件的位置，和/或通过向构建器注册组件的位置。</p>
</div>
<div class="paragraph">
<p>而<code>HttpHandler</code>一个简单的目标是抽象化不同HTTP服务器的使用， <code>WebHandler</code> API旨在提供Web应用程序中通常使用的更广泛的功能集，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有属性的用户会话。</p>
</li>
<li>
<p>请求属性。</p>
</li>
<li>
<p>解决<code>Locale</code>要么<code>Principal</code>的要求。</p>
</li>
<li>
<p>访问已解析和缓存的表单数据。</p>
</li>
<li>
<p>多部分数据的抽象。</p>
</li>
<li>
<p>和更多..</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-web-handler-api-special-beans"><a class="anchor" href="#webflux-web-handler-api-special-beans"></a>Special bean types</h5>
<div class="paragraph">
<p>下表列出了<code>WebHttpHandlerBuilder</code>可以在Spring ApplicationContext中自动检测，也可以直接向其注册：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:12.5%">
<col style="width:37.5%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean name</th>
<th class="tableblock halign-left valign-top">豆类</th>
<th class="tableblock halign-left valign-top">计数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><any></any></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 ..ñ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供处理链中的异常的方法<code>WebFilter</code>实例和目标<code>WebHandler</code> 。有关更多详细信息，请参见<a href="#webflux-exception-handler">Exceptions</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><any></any></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 ..ñ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将拦截样式逻辑应用于其余过滤器链和目标之前和之后<code>WebHandler</code> 。有关更多详细信息，请参见过<a href="#webflux-filters">滤器</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的处理程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">经理<code>WebSession</code>通过方法公开的实例<code>ServerWebExchange</code> 。
  <code>DefaultWebSessionManager</code>默认。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serverCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问<code>HttpMessageReader</code>实例，用于解析表单数据和多部分数据，然后通过以下方法公开<code>ServerWebExchange</code> 。 <code>ServerCodecConfigurer.create()</code>默认。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localeContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的解析器<code>LocaleContext</code>通过以下方法暴露<code>ServerWebExchange</code> 。
  <code>AcceptHeaderLocaleContextResolver</code>默认。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ForwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于处理转发的类型标头，可以通过提取和删除它们或仅通过删除它们来进行。默认情况下不使用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-form-data"><a class="anchor" href="#webflux-form-data"></a>表格数据</h5>
<div class="paragraph">
<p><code>ServerWebExchange</code>公开以下访问表单数据的方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin" data-lang="Kotlin">suspend fun getFormData(): MultiValueMap&lt;String, String&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader</code>解析表单数据（ <code>application/x-www-form-urlencoded</code> ）成<code>MultiValueMap</code> 。默认， <code>FormHttpMessageReader</code>配置为供<code>ServerCodecConfigurer</code> bean（请参阅<a href="#webflux-web-handler-api">Web Handler API</a> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart"><a class="anchor" href="#webflux-multipart"></a>多部分数据</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multipart">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerWebExchange</code>公开以下访问多部分数据的方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-Kotlin" data-lang="Kotlin">suspend fun getMultipartData(): MultiValueMap&lt;String, Part&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader<MultiValueMap<String, Part>></code>解析<code>multipart/form-data</code>内容成<code>MultiValueMap</code> 。目前， <a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>是唯一受支持的第三方库，也是我们知道的用于非阻塞解析多部分请求的唯一库。通过以下方式启用<code>ServerCodecConfigurer</code> bean（请参阅<a href="#webflux-web-handler-api">Web Handler API</a> ）。</p>
</div>
<div class="paragraph">
<p>要以流式方式解析多部分数据，可以使用<code>Flux<Part></code>从返回<code>HttpMessageReader<Part></code>代替。例如，在带注释的控制器中，使用<code>@RequestPart</code>暗示<code>Map</code>类的名称访问，因此需要完整地分析多部分数据。相比之下，您可以使用<code>@RequestBody</code>解码内容到<code>Flux<Part></code>没有收集到<code>MultiValueMap</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-forwarded-headers"><a class="anchor" href="#webflux-forwarded-headers"></a>转发的标题</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters-forwarded-headers">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>当请求通过代理（例如负载平衡器）进行处理时，主机，端口和方案可能会更改，从客户端的角度来看，要创建指向正确的主机，端口和方案的链接是一个挑战。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了<code>Forwarded</code>代理可以用来提供有关原始请求的信息的HTTP标头。还有其他非标准标头，包括<code>X-Forwarded-Host</code> ， <code>X-Forwarded-Port</code> ， <code>X-Forwarded-Proto</code> ， <code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code> 。</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderTransformer</code>是一个组件，可根据转发的标头修改请求的主机，端口和方案，然后删除这些标头。您可以将其声明为名称为的Bean <code>forwardedHeaderTransformer</code> ，并且可以<a href="#webflux-web-handler-api-special-beans">检测到</a>并使用它。</p>
</div>
<div class="paragraph">
<p>对于转发的标头，有一些安全方面的考虑，因为应用程序无法知道标头是由代理添加的，还是由恶意客户端添加的。这就是为什么应配置信任边界处的代理以删除来自外部的不受信任的转发流量的原因。您还可以配置<code>ForwardedHeaderTransformer</code>与<code>removeOnly=true</code> ，在这种情况下，它将删除但不使用标题。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在5.1中<code>ForwardedHeaderFilter</code>已被弃用并被<code>ForwardedHeaderTransformer</code>因此，可以在创建交换之前更早地处理转发的标头。如果仍然配置了过滤器，则将其从过滤器列表中删除，并且<code>ForwardedHeaderTransformer</code>改为使用。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-filters"><a class="anchor" href="#webflux-filters"></a> 1.2.3。筛选器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在里面<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> ，您可以使用<code>WebFilter</code>在过滤器和目标的其余处理链之前和之后应用拦截式逻辑<code>WebHandler</code> 。使用<a href="#webflux-config">WebFlux Config时</a> ，注册一个<code>WebFilter</code>就像声明它像Spring bean一样简单，并且（可选）通过使用来表达优先级<code>@Order</code>在bean声明上或通过实现<code>Ordered</code> 。</p>
</div>
<div class="sect4">
<h5 id="webflux-filters-cors"><a class="anchor" href="#webflux-filters-cors"></a> CORS</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#filters-cors">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux通过控制器上的注释为CORS配置提供了细粒度的支持。但是，当您将其与Spring Security结合使用时，我们建议您依赖内置<code>CorsFilter</code> ，必须在Spring Security的过滤器链之前订购。</p>
</div>
<div class="paragraph">
<p>请参阅有关<a href="#webflux-cors">CORS</a>和<a href="#webflux-cors-webfilter">CORS的部分<code>WebFilter</code></a>更多细节。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-exception-handler"><a class="anchor" href="#webflux-exception-handler"></a> 1.2.4。例外情况</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-customer-servlet-container-error-page">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在里面<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> ，您可以使用<code>WebExceptionHandler</code>处理链中的异常<code>WebFilter</code>实例和目标<code>WebHandler</code> 。使用<a href="#webflux-config">WebFlux Config时</a> ，注册一个<code>WebExceptionHandler</code>就像声明它像Spring bean一样简单，并且（可选）通过使用来表达优先级<code>@Order</code>在bean声明上或通过实现<code>Ordered</code> 。</p>
</div>
<div class="paragraph">
<p>下表介绍了可用的<code>WebExceptionHandler</code>实现：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">异常处理程序</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供对类型异常的处理<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html"><code>ResponseStatusException</code></a>通过将响应设置为异常的HTTP状态代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFluxResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的扩展<code>ResponseStatusExceptionHandler</code>也可以确定<code>@ResponseStatus</code>注释上的任何异常。
</p><p class="tableblock">该处理程序在<a href="#webflux-config">WebFlux Config中</a>声明。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-codecs"><a class="anchor" href="#webflux-codecs"></a> 1.2.5。编解码器</h4>
<div class="paragraph">
<p><span class="small"><a href="integration.html#rest-message-conversion">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>spring-web</code>和<code>spring-core</code>模块提供了对通过非阻塞I / O（带有响应流反压）在高层对象之间来回串行化和反序列化字节内容的支持。以下介绍了此支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html"><code>Encoder</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html"><code>Decoder</code></a>是用于独立于HTTP编码和解码内容的低级合同。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html"><code>HttpMessageReader</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html"><code>HttpMessageWriter</code></a>是对HTTP消息内容进行编码和解码的合同。</p>
</li>
<li>
<p>一个<code>Encoder</code>可以用<code>EncoderHttpMessageWriter</code>使其适合在Web应用程序中使用，而<code>Decoder</code>可以用<code>DecoderHttpMessageReader</code> 。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html"><code>DataBuffer</code></a>抽象不同的字节缓冲区表示形式（例如Netty <code>ByteBuf</code> ， <code>java.nio.ByteBuffer</code> ，等等），这就是所有编解码器的工作方式。有关此主题的更多信息，请参见“ Spring核心”部分中的<a href="core.html#databuffers">数据缓冲区和编解码器</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>spring-core</code>模块提供<code>byte[]</code> ， <code>ByteBuffer</code> ， <code>DataBuffer</code> ， <code>Resource</code>和<code>String</code>编码器和解码器的实现。的<code>spring-web</code>该模块提供了Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers和其他编码器和解码器，以及用于表单数据，多部分内容，服务器发送的事件等的纯Web HTTP消息读取器和写入器实现。</p>
</div>
<div class="paragraph">
<p><code>ClientCodecConfigurer</code>和<code>ServerCodecConfigurer</code>通常用于配置和定制要在应用程序中使用的编解码器。请参阅有关配置<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>的部分。</p>
</div>
<div class="sect4">
<h5 id="webflux-codecs-jackson"><a class="anchor" href="#webflux-codecs-jackson"></a>杰克逊JSON</h5>
<div class="paragraph">
<p>存在Jackson库时，都支持JSON和二进制JSON（ <a href="https://github.com/FasterXML/smile-format-specification">Smile</a> ）。</p>
</div>
<div class="paragraph">
<p>的<code>Jackson2Decoder</code>工作原理如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jackson的异步，非阻塞解析器用于将字节块流聚合为<code>TokenBuffer</code>各自代表一个JSON对象。</p>
</li>
<li>
<p>每<code>TokenBuffer</code>被传递给杰克逊的<code>ObjectMapper</code>创建更高级别的对象。</p>
</li>
<li>
<p>解码为单值发布者时（例如， <code>Mono</code> ）， 有一个<code>TokenBuffer</code> 。</p>
</li>
<li>
<p>解码给多价值发布者（例如<code>Flux</code> ），每个<code>TokenBuffer</code>被传递给<code>ObjectMapper</code>一旦接收到足够的字节以形成完整的对象。输入内容可以是JSON数组，如果内容类型为“ application / stream + json”，则可以是<a href="https://en.wikipedia.org/wiki/JSON_streaming">行分隔的JSON</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>Jackson2Encoder</code>工作原理如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于单个价值发布者（例如， <code>Mono</code> ），只需通过<code>ObjectMapper</code> 。</p>
</li>
<li>
<p>对于具有“ application / json”的多值发布者，默认情况下，使用<code>Flux#collectToList()</code>然后序列化结果集合。</p>
</li>
<li>
<p>对于具有流媒体类型（例如， <code>application/stream+json</code>要么<code>application/stream+x-jackson-smile</code> ，使用<a href="https://en.wikipedia.org/wiki/JSON_streaming">行定界的JSON</a>格式分别编码，写入和刷新每个值。</p>
</li>
<li>
<p>对于上证所<code>Jackson2Encoder</code>将为每个事件调用，并刷新输出以确保立即交付。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下两者<code>Jackson2Encoder</code>和<code>Jackson2Decoder</code>不支持类型的元素<code>String</code> 。相反，默认假设是字符串或字符串序列代表序列化的JSON内容，由JSON呈现。 <code>CharSequenceEncoder</code> 。如果您需要的是从中渲染JSON数组<code>Flux<String></code> ， 使用<code>Flux#collectToList()</code>并编码一个<code>Mono<List<String>></code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-forms"><a class="anchor" href="#webflux-codecs-forms"></a>表格数据</h5>
<div class="paragraph">
<p><code>FormHttpMessageReader</code>和<code>FormHttpMessageWriter</code>支持解码和编码“应用程序/ x-www-form-urlencoded”内容。</p>
</div>
<div class="paragraph">
<p>在服务器端，经常需要从多个位置访问表单内容， <code>ServerWebExchange</code>提供专门的<code>getFormData()</code>通过解析内容的方法<code>FormHttpMessageReader</code>然后缓存结果以便重复访问。见<a href="#webflux-form-data">表格数据</a>中<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>部分。</p>
</div>
<div class="paragraph">
<p>一旦<code>getFormData()</code>如果使用，则原始原始内容将无法再从请求正文中读取。因此，应用程序有望通过<code>ServerWebExchange</code>一致地访问缓存的表单数据，而不是从原始请求主体读取数据。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-multipart"><a class="anchor" href="#webflux-codecs-multipart"></a>多部分</h5>
<div class="paragraph">
<p><code>MultipartHttpMessageReader</code>和<code>MultipartHttpMessageWriter</code>支持解码和编码“多部分/表单数据”内容。反过来<code>MultipartHttpMessageReader</code>委托给另一个<code>HttpMessageReader</code>实际解析为<code>Flux<Part></code>然后简单地将零件收集到<code>MultiValueMap</code> 。目前， <a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>用于实际解析。</p>
</div>
<div class="paragraph">
<p>在服务器端，可能需要从多个位置访问多部分表单内容， <code>ServerWebExchange</code>提供专门的<code>getMultipartData()</code>通过解析内容的方法<code>MultipartHttpMessageReader</code>然后缓存结果以便重复访问。见<a href="#webflux-multipart">多部分数据</a>在<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>部分。</p>
</div>
<div class="paragraph">
<p>一旦<code>getMultipartData()</code>如果使用，则原始原始内容将无法再从请求正文中读取。因此，应用程序必须始终使用<code>getMultipartData()</code>以便重复地，类似地图地访问零件，或者依靠<code>SynchronossPartHttpMessageReader</code>一次访问<code>Flux<Part></code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-limits"><a class="anchor" href="#webflux-codecs-limits"></a>限度</h5>
<div class="paragraph">
<p><code>Decoder</code>和<code>HttpMessageReader</code>可以对部分或全部输入流进行缓冲的实现可以配置为对要在内存中缓冲的最大字节数有所限制。在某些情况下，由于输入被汇总并表示为单个对象，因此会发生缓冲，例如带有<code>@RequestBody byte[]</code> ， <code>x-www-form-urlencoded</code>数据等等。在分割输入流（例如，定界文本，JSON对象流等）时，流处理也会发生缓冲。对于这些流情况，该限制适用于与流中一个对象相关联的字节数。</p>
</div>
<div class="paragraph">
<p>要配置缓冲区大小，您可以检查是否给定<code>Decoder</code>要么<code>HttpMessageReader</code>暴露一个<code>maxInMemorySize</code>属性，如果是，则Javadoc将包含有关默认值的详细信息。在WebFlux中， <code>ServerCodecConfigurer</code>提供了<a href="#webflux-config-message-codecs">一个</a>从何处设置所有编解码器的位置， <code>maxInMemorySize</code>默认编解码器的属性。</p>
</div>
<div class="paragraph">
<p>对于<a href="#webflux-codecs-multipart">多部分解析</a> <code>maxInMemorySize</code>属性限制非文件部分的大小。对于文件部件，它确定将部件写入磁盘的阈值。对于写入磁盘的文件部分，还有一个附加功能<code>maxDiskUsagePerPart</code>属性以限制每个部分的磁盘空间量。还有一个<code>maxParts</code>属性以限制多部分请求中的部分总数。要在WebFlux中配置所有3个，您需要提供一个预先配置的<code>MultipartHttpMessageReader</code>至<code>ServerCodecConfigurer</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-streaming"><a class="anchor" href="#webflux-codecs-streaming"></a>流媒体</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-async-http-streaming">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>流式传输到HTTP响应时（例如， <code>text/event-stream</code> ， <code>application/stream+json</code> ），定期发送数据很重要，这样才能尽快（而不是稍后）可靠地检测到断开连接的客户端。这样的发送可以是仅注释的空SSE事件，也可以是有效用作心跳的任何其他“无操作”数据。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-buffers"><a class="anchor" href="#webflux-codecs-buffers"></a><code>DataBuffer</code></h5>
<div class="paragraph">
<p><code>DataBuffer</code>是WebFlux中字节缓冲区的表示形式。参考资料的Spring Core部分在“ <a href="core.html#databuffers">数据缓冲区和编解码器</a> ”部分中有更多介绍。要理解的关键点是，在诸如Netty之类的某些服务器上，字节缓冲被池化并计数引用，并且在使用时必须将其释放以避免内存泄漏。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序通常不需要关心此类问题，除非它们直接消耗或产生数据缓冲区，而不是依赖于编解码器与更高级别的对象进行转换。或者，除非他们选择创建自定义编解码器。对于这种情况，请查看<a href="core.html#databuffers">数据缓冲区和编解码器中</a>的信息，尤其是有关<a href="core.html#databuffers-using">使用</a> <a href="core.html#databuffers">数据缓冲区</a>的部分。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-logging"><a class="anchor" href="#webflux-logging"></a> 1.2.6。记录中</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-logging">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中的DEBUG级别日志记录被设计为紧凑，最小化和人性化。它侧重于一遍又一遍有用的高价值信息，而其他信息则仅在调试特定问题时才有用。</p>
</div>
<div class="paragraph">
<p>TRACE级别的日志记录通常遵循与DEBUG相同的原则（例如，也不应成为firehose），但可用于调试任何问题。另外，某些日志消息在TRACE vs DEBUG上可能显示不同级别的详细信息。</p>
</div>
<div class="paragraph">
<p>良好的日志记录来自使用日志的经验。如果您发现任何不符合既定目标的东西，请告诉我们。</p>
</div>
<div class="sect4">
<h5 id="webflux-logging-id"><a class="anchor" href="#webflux-logging-id"></a>记录编号</h5>
<div class="paragraph">
<p>在WebFlux中，单个请求可以在多个线程上执行，并且线程ID对于关联属于特定请求的日志消息没有用。这就是为什么WebFlux日志消息默认情况下带有特定于请求的ID的原因。</p>
</div>
<div class="paragraph">
<p>在服务器端，日志ID存储在<code>ServerWebExchange</code>属性（ <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a> ），而基于ID的全格式前缀可从<code>ServerWebExchange#getLogPrefix()</code> 。在<code>WebClient</code>方面，日志ID存储在<code>ClientRequest</code>属性（ <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a> ），而完整格式的前缀可从<code>ClientRequest#logPrefix()</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-logging-sensitive-data"><a class="anchor" href="#webflux-logging-sensitive-data"></a>敏感数据</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-logging-sensitive-data">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DEBUG</code>和<code>TRACE</code>日志记录可以记录敏感信息。这就是默认情况下屏蔽表单参数和标题的原因，并且必须显式启用它们的完整日志记录。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何对服务器端请求执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class MyConfig : WebFluxConfigurer {

    override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何针对客户端请求执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt;
        configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val consumer: (ClientCodecConfigurer) -&gt; Unit  = { configurer -&gt; configurer.defaultCodecs().enableLoggingRequestDetails(true) }

val webClient = WebClient.builder()
        .exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())
        .build()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-handler"><a class="anchor" href="#webflux-dispatcher-handler"></a> 1.3。<code>DispatcherHandler</code></h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux与Spring MVC类似，是围绕前端控制器模式设计的，其中中央<code>WebHandler</code> ， <code>DispatcherHandler</code>提供了一种用于请求处理的共享算法，而实际工作是由可配置的委托组件执行的。该模型非常灵活，并支持多种工作流程。</p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code>从Spring配置中发现所需的委托组件。它还被设计为Spring bean本身并实现<code>ApplicationContextAware</code>用于访问其运行的上下文。如果<code>DispatcherHandler</code>以Bean名称声明为<code>webHandler</code> ，这反过来是由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html"><code>WebHttpHandlerBuilder</code></a> ，它构成了一个请求处理链，如中所述<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a> 。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序中的Spring配置通常包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DispatcherHandler</code>用beans的名字<code>webHandler</code></p>
</li>
<li>
<p><code>WebFilter</code>和<code>WebExceptionHandler</code>beans</p>
</li>
<li>
<p><a href="#webflux-special-bean-types"><code>DispatcherHandler</code>特殊豆</a></p>
</li>
<li>
<p>其他</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>配置给<code>WebHttpHandlerBuilder</code>构建处理链，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context: ApplicationContext = ...
val handler = WebHttpHandlerBuilder.applicationContext(context)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所结果的<code>HttpHandler</code>准备与<a href="#webflux-httphandler">服务器适配器一起使用</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-special-bean-types"><a class="anchor" href="#webflux-special-bean-types"></a> 1.3.1。Special bean types</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-special-bean-types">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>DispatcherHandler</code>委托特殊bean处理请求并提供适当的响应。所谓“特殊豆”，是指春季管理<code>Object</code>实现WebFlux框架合同的实例。这些通常带有内置合同，但是您可以自定义它们的属性，扩展它们或替换它们。</p>
</div>
<div class="paragraph">
<p>下表列出了由<code>DispatcherHandler</code> 。请注意，在较低级别还检测到其他一些bean（请参阅Web Handler API中的<a href="#webflux-web-handler-api-special-beans">特殊bean类型</a> ）。</p>
</div>
<table id="webflux-special-beans-table" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">豆类</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将请求映射到处理程序。映射基于某些条件，其细节因<code>HandlerMapping</code>实现—带注释的控制器，简单的URL模式映射等。
</p><p class="tableblock">主要的<code>HandlerMapping</code>实现是<code>RequestMappingHandlerMapping</code>对于<code>@RequestMapping</code>带注释的方法<code>RouterFunctionMapping</code>用于功能性端点路由，以及<code>SimpleUrlHandlerMapping</code>用于URI路径模式的显式注册，以及<code>WebHandler</code>实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">帮助<code>DispatcherHandler</code>调用映射到请求的处理程序，而不管实际如何调用该处理程序。例如，调用带注释的控制器需要解析注释。一个的主要目的<code>HandlerAdapter</code>是为了屏蔽<code>DispatcherHandler</code>从这样的细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理来自处理程序调用的结果，并最终确定响应。请参阅<a href="#webflux-resulthandling">结果处理</a> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-framework-config"><a class="anchor" href="#webflux-framework-config"></a> 1.3.2。WebFlux配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-config">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>应用程序可以声明基础结构Bean（在<a href="#webflux-web-handler-api-special-beans">Web Handler API</a>和<a href="#webflux-special-bean-types"><code>DispatcherHandler</code></a> ）来处理请求。但是，在大多数情况下， <a href="#webflux-config">WebFlux Config</a>是最佳起点。它声明了所需的bean，并提供了更高级别的配置回调API来对其进行自定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot依靠WebFlux配置来配置Spring WebFlux，并且还提供了许多额外的方便选项。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-handler-sequence"><a class="anchor" href="#webflux-dispatcher-handler-sequence"></a> 1.3.3。处理中</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-servlet-sequence">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code>处理请求如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每<code>HandlerMapping</code>要求找到匹配的处理程序，并使用第一个匹配项。</p>
</li>
<li>
<p>如果找到处理程序，则通过适当的执行程序<code>HandlerAdapter</code> ，它将执行的返回值公开为<code>HandlerResult</code> 。</p>
</li>
<li>
<p>的<code>HandlerResult</code>被给予适当的<code>HandlerResultHandler</code>通过直接写入响应或使用视图进行渲染来完成处理。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-resulthandling"><a class="anchor" href="#webflux-resulthandling"></a> 1.3.4。结果处理</h4>
<div class="paragraph">
<p>通过调用处理程序返回的值<code>HandlerAdapter</code> ，包装为<code>HandlerResult</code> ，以及其他一些上下文，并传递给第一个<code>HandlerResultHandler</code>声称对此表示支持。下表显示了可用的<code>HandlerResultHandler</code>实现，所有这些都在<a href="#webflux-config">WebFlux Config</a>中声明：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:25%">
<col style="width:50%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">结果处理程序类型</th>
<th class="tableblock halign-left valign-top">返回值</th>
<th class="tableblock halign-left valign-top">默认订单</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntityResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntity</code> ，通常来自<code>@Controller</code>实例。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponseResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponse</code> ，通常来自功能端点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理来自的返回值<code>@ResponseBody</code>方法或<code>@RestController</code>类。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolutionResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CharSequence</code> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/View.html"><code>View</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/ui/Model.html">型号</a> <code>Map</code> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a>或任何其他<code>Object</code>被视为模型属性。
</p><p class="tableblock">另请参阅<a href="#webflux-viewresolution">查看分辨率</a> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Integer.MAX_VALUE</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-exceptions"><a class="anchor" href="#webflux-dispatcher-exceptions"></a> 1.3.5。例外情况</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-exceptionhandlers">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>HandlerResult</code>从一个返回<code>HandlerAdapter</code>可以基于某些处理程序特定的机制公开用于错误处理的函数。在以下情况下将调用此错误函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理程序（例如， <code>@Controller</code> ）调用失败。</p>
</li>
<li>
<p>处理程序通过以下方式返回值： <code>HandlerResultHandler</code>失败。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只要在从处理程序返回的反应类型产生任何数据项之前发生错误信号，错误函数就可以更改响应（例如，更改为错误状态）。</p>
</div>
<div class="paragraph">
<p>这就是<code>@ExceptionHandler</code>方法中<code>@Controller</code>支持类。相比之下，Spring MVC中对相同功能的支持建立在<code>HandlerExceptionResolver</code> 。这通常不重要。但是，请记住，在WebFlux中，您不能使用<code>@ControllerAdvice</code>处理在选择处理程序之前发生的异常。</p>
</div>
<div class="paragraph">
<p>另见<a href="#webflux-ann-controller-exceptions">管理异常</a>的“注释控制器”部分或<a href="#webflux-exception-handler">异常</a>的WebHandler API部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-viewresolution"><a class="anchor" href="#webflux-viewresolution"></a> 1.3.6。查看分辨率</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-viewresolver">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>视图分辨率使您可以使用HTML模板和模型渲染到浏览器，而无需将您与特定的视图技术联系在一起。在Spring WebFlux中，通过使用以下内容的专用<a href="#webflux-resulthandling">HandlerResultHandler</a>支持视图分辨率<code>ViewResolver</code>实例以将String（代表逻辑视图名称）映射到<code>View</code>实例。的<code>View</code>然后用于呈现响应。</p>
</div>
<div class="sect4">
<h5 id="webflux-viewresolution-handling"><a class="anchor" href="#webflux-viewresolution-handling"></a>处理方式</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-handling">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>HandlerResult</code>传入<code>ViewResolutionResultHandler</code>包含处理程序的返回值和包含请求处理过程中添加的属性的模型。返回值将作为以下值之一进行处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code> ， <code>CharSequence</code> ：要解析为一个逻辑视图名称<code>View</code>通过配置列表<code>ViewResolver</code>实现。</p>
</li>
<li>
<p><code>void</code> ：根据请求路径选择默认视图名称，然后减去前斜杠和后斜杠，然后将其解析为<code>View</code> 。当未提供视图名称（例如，返回模型属性）或异步返回值（例如， <code>Mono</code>完成为空）。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a> ：用于视图分辨率方案的API。通过代码完成探索IDE中的选项。</p>
</li>
<li>
<p><code>Model</code> ， <code>Map</code> ：要添加到请求模型的额外模型属性。</p>
</li>
<li>
<p>其他任何其他值：任何其他返回值（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定的简单类型除外）都将被视为要添加到模型的模型属性。属性名称是通过使用<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/Conventions.html">约定</a>从类名称派生的，除非使用处理程序方法<code>@ModelAttribute</code>注释存在。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该模型可以包含异步，反应式类型（例如，来自Reactor或RxJava）。在渲染之前， <code>AbstractView</code>将此类模型属性解析为具体值并更新模型。单值反应式类型解析为单个值或无值（如果为空），而多值反应式类型（例如， <code>Flux<T></code> ）收集并解析为<code>List<T></code> 。</p>
</div>
<div class="paragraph">
<p>配置视图分辨率就像添加一个<code>ViewResolutionResultHandler</code> bean到您的Spring配置。<a href="#webflux-config-view-resolvers">WebFlux Config</a>提供了专用于视图分辨率的配置API。</p>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参见<a href="#webflux-view">View Technologies</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-redirecting-redirect-prefix"><a class="anchor" href="#webflux-redirecting-redirect-prefix"></a>重新导向</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-redirecting-redirect-prefix">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>特别的<code>redirect:</code>视图名称中的前缀可让您执行重定向。的<code>UrlBasedViewResolver</code> （和子类）将其识别为需要重定向的指令。视图名称的其余部分是重定向URL。</p>
</div>
<div class="paragraph">
<p>最终效果与控制器已返回<code>RedirectView</code>要么<code>Rendering.redirectTo("abc").build()</code> ，但现在控制器本身可以根据逻辑视图名称进行操作。视图名称，例如<code>redirect:/some/resource</code>是相对于当前应用程序的，而视图名称如<code>redirect:https://example.com/arbitrary/path</code>重定向到绝对URL。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multiple-representations"><a class="anchor" href="#webflux-multiple-representations"></a>内容协商</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multiple-representations">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ViewResolutionResultHandler</code>支持内容协商。它将请求媒体类型与每个选定媒体支持的媒体类型进行比较<code>View</code> 。首先<code>View</code>使用支持请求的媒体类型的媒体。</p>
</div>
<div class="paragraph">
<p>为了支持JSON和XML等媒体类型，Spring WebFlux提供了<code>HttpMessageWriterView</code> ，这是一个特殊的<code>View</code>通过<a href="#webflux-codecs">HttpMessageWriter</a>呈现。通常，您可以通过<a href="#webflux-config-view-resolvers">WebFlux Configuration</a>将它们配置为默认视图。如果默认视图与请求的媒体类型匹配，则始终会选择和使用它们。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-controller"><a class="anchor" href="#webflux-controller"></a> 1.4。带注释的控制器</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-controller">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux提供了一个基于注释的编程模型，其中<code>@Controller</code>和<code>@RestController</code>组件使用批注来表达请求映射，请求输入，处理异常等。带注释的控制器具有灵活的方法签名，无需扩展基类或实现特定的接口。</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个基本示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class HelloController {

    @GetMapping("/hello")
    public String handle() {
        return "Hello WebFlux";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class HelloController {

    @GetMapping("/hello")
    fun handle() = "Hello WebFlux"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，该方法返回一个<code>String</code>写入响应主体。</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller"><a class="anchor" href="#webflux-ann-controller"></a> 1.4.1。<code>@Controller</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用标准的Spring bean定义来定义控制器bean。的<code>@Controller</code>原型可以进行自动检测，并且与Spring常规检测支持一致<code>@Component</code>类路径中的类，并为其自动注册Bean定义。它还充当带注释类的构造型，表明其作为Web组件的作用。</p>
</div>
<div class="paragraph">
<p>启用此类自动检测<code>@Controller</code> Bean，您可以将组件扫描添加到Java配置中，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan("org.example.web") <i class="conum" data-value="1"></i><b>(1)</b>
public class WebConfig {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扫描<code>org.example.web</code>包。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan("org.example.web") <i class="conum" data-value="1"></i><b>(1)</b>
class WebConfig {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>扫描<code>org.example.web</code>包。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>@RestController</code>是一个<a href="core.html#beans-meta-annotations">组合注释</a> ，其本身使用元注释<code>@Controller</code>和<code>@ResponseBody</code> ，指示其每个方法都继承类型级别的控制器<code>@ResponseBody</code>注释，因此直接将其写入响应主体，而不是视图分辨率和使用HTML模板进行渲染。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping"><a class="anchor" href="#webflux-ann-requestmapping"></a> 1.4.2。请求映射</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>@RequestMapping</code>批注用于将请求映射到控制器方法。它具有各种属性，可以通过URL，HTTP方法，请求参数，标头和媒体类型进行匹配。您可以在类级别使用它来表示共享的映射，也可以在方法级别使用它来缩小到特定的端点映射。</p>
</div>
<div class="paragraph">
<p>也有HTTP方法特定的快捷方式变体<code>@RequestMapping</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的注释是提供的“ <a href="#webflux-ann-requestmapping-composed">自定义注释”</a> ，因为可以说，大多数控制器方法应映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。同时， <code>@RequestMapping</code>在类级别仍需要表达共享映射。</p>
</div>
<div class="paragraph">
<p>以下示例使用类型和方法级别的映射：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    fun getPerson(@PathVariable id: Long): Person {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    fun add(@RequestBody person: Person) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-uri-templates"><a class="anchor" href="#webflux-ann-requestmapping-uri-templates"></a> URI模式</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-uri-templates">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用全局模式和通配符来映射请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code>匹配一个字符</p>
</li>
<li>
<p><code>*</code>匹配路径段中的零个或多个字符</p>
</li>
<li>
<p><code>**</code>匹配零个或多个路径段</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以声明URI变量并使用以下命令访问它们的值<code>@PathVariable</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在类和方法级别声明URI变量，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/owners/{ownerId}") <i class="conum" data-value="1"></i><b>(1)</b>
public class OwnerController {

    @GetMapping("/pets/{petId}") <i class="conum" data-value="2"></i><b>(2)</b>
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类级URI映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>方法级URI映射。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@RequestMapping("/owners/{ownerId}") <i class="conum" data-value="1"></i><b>(1)</b>
class OwnerController {

    @GetMapping("/pets/{petId}") <i class="conum" data-value="2"></i><b>(2)</b>
    fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>类级URI映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>方法级URI映射。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>URI变量会自动转换为适当的类型或<code>TypeMismatchException</code>被提出。简单类型（ <code>int</code> ， <code>long</code> ， <code>Date</code> ，等等）默认情况下受支持，您可以注册对任何其他数据类型的支持。请参阅<a href="#webflux-ann-typeconversion">类型转换</a>和<a href="#webflux-ann-initbinder"><code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>可以明确命名URI变量（例如， <code>@PathVariable("customId")</code> ），但如果名称相同，则可以使用调试信息或使用<code>-parameters</code> Java 8上的编译器标志。</p>
</div>
<div class="paragraph">
<p>语法<code>{*varName}</code>声明一个与零个或多个剩余路径段匹配的URI变量。例如<code>/resources/{*path}</code>匹配所有文件<code>/resources/</code>和<code>"path"</code>变量捕获完整的相对路径。</p>
</div>
<div class="paragraph">
<p>语法<code>{varName:regex}</code>使用具有以下语法的正则表达式声明URI变量： <code>{varName:regex}</code> 。例如，给定URL为<code>/spring-web-3.0.5 .jar</code> ，以下方法提取名称，版本和文件扩展名：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
fun handle(@PathVariable version: String, @PathVariable ext: String) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI路径模式也可以嵌入<code>${…​}</code>在启动时通过解析的占位符<code>PropertyPlaceHolderConfigurer</code>针对本地，系统，环境和其他财产来源。您可以使用它来例如基于某些外部配置参数化基本URL。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring WebFlux的用途<code>PathPattern</code>和<code>PathPatternParser</code>用于URI路径匹配支持。这两个类都位于<code>spring-web</code>并且明确设计用于Web应用程序中的HTTP URL路径，在Web应用程序中，在运行时会匹配大量URI路径模式。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring WebFlux不支持后缀模式匹配-与Spring MVC不同，Spring MVC中的映射例如<code>/person</code>也匹配到<code>/person.*</code> 。对于基于URL的内容协商，如果需要，我们建议使用查询参数，该参数更简单，更明确，并且不易受到基于URL路径的攻击。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-pattern-comparison"><a class="anchor" href="#webflux-ann-requestmapping-pattern-comparison"></a>模式比较</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-pattern-comparison">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>当多个模式与URL匹配时，必须将它们进行比较以找到最佳匹配。这是用<code>PathPattern.SPECIFICITY_COMPARATOR</code> ，查找更具体的模式。</p>
</div>
<div class="paragraph">
<p>对于每个模式，都会根据URI变量和通配符的数量计算得分，其中URI变量的得分低于通配符。总得分较低的模式将获胜。如果两个模式的分数相同，则选择更长的时间。</p>
</div>
<div class="paragraph">
<p>捕获所有模式（例如， <code>**</code> ， <code>{*varName}</code> ）从得分中排除，而是始终排在最后。如果两种模式都适用，则选择更长的时间。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-consumes"><a class="anchor" href="#webflux-ann-requestmapping-consumes"></a>消耗媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-consumes">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据<code>Content-Type</code>如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping(path = "/pets", consumes = "application/json")
public void addPet(@RequestBody Pet pet) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/pets", consumes = ["application/json"])
fun addPet(@RequestBody pet: Pet) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>消耗属性还支持否定表达式，例如， <code>!text/plain</code>表示除以下内容以外的任何内容类型<code>text/plain</code> 。</p>
</div>
<div class="paragraph">
<p>您可以声明共享<code>consumes</code>类级别的属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>consumes</code>属性覆盖而不是扩展类级别的声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>提供常用媒体类型的常量-例如， <code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-produces"><a class="anchor" href="#webflux-ann-requestmapping-produces"></a>可生产的媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-produces">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", produces = "application/json")
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/pets/{petId}", produces = ["application/json"])
@ResponseBody
fun getPet(@PathVariable String petId): Pet {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>媒体类型可以指定字符集。支持否定表达式-例如， <code>!text/plain</code>表示除以下内容以外的任何内容类型<code>text/plain</code> 。</p>
</div>
<div class="paragraph">
<p>您可以声明共享<code>produces</code>类级别的属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>produces</code>属性覆盖而不是扩展类级别的声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>提供常用媒体类型的常量-例如<code>APPLICATION_JSON_VALUE</code> ， <code>APPLICATION_XML_VALUE</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-params-and-headers"><a class="anchor" href="#webflux-ann-requestmapping-params-and-headers"></a>参数和标题</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-params-and-headers">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据查询参数条件来缩小请求映射。您可以测试是否存在查询参数（ <code>myParam</code> ），因为它不存在（ <code>!myParam</code> ）或特定值（ <code>myParam=myValue</code> ）。以下示例测试具有值的参数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检查一下<code>myParam</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun findPet(@PathVariable petId: String) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检查一下<code>myParam</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以将其与请求标头条件一起使用，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets", headers = "myHeader=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检查一下<code>myHeader</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/pets", headers = ["myHeader=myValue"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun findPet(@PathVariable petId: String) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检查一下<code>myHeader</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-head-options"><a class="anchor" href="#webflux-ann-requestmapping-head-options"></a> HTTP HEAD，选项</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-head-options">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>和<code>@RequestMapping(method=HttpMethod.GET)</code>为请求映射目的透明地支持HTTP HEAD。控制器方法无需更改。响应包装，应用于<code>HttpHandler</code>服务器适配器，确保<code>Content-Length</code>标头设置为实际未写入响应的写入字节数。</p>
</div>
<div class="paragraph">
<p>默认情况下，HTTP OPTIONS通过设置<code>Allow</code>对所有列出的HTTP方法列表的响应标头<code>@RequestMapping</code>具有匹配网址格式的方法。</p>
</div>
<div class="paragraph">
<p>为一个<code>@RequestMapping</code>如果没有HTTP方法声明， <code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code> 。控制器方法应始终声明支持的HTTP方法（例如，通过使用HTTP方法特定的变体- <code>@GetMapping</code> ， <code>@PostMapping</code> ， 和别的）。</p>
</div>
<div class="paragraph">
<p>您可以显式映射一个<code>@RequestMapping</code> HTTP HEAD和HTTP OPTIONS的方法，但在通常情况下不必要。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-composed"><a class="anchor" href="#webflux-ann-requestmapping-composed"></a>自定义注释</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-composed">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux支持将<a href="core.html#beans-meta-annotations">组合注释</a>用于请求映射。这些是本身带有元注释的注释<code>@RequestMapping</code>并组成为重新声明以下内容的子集（或全部） <code>@RequestMapping</code>具有更窄，更具体目的的属性。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> ， <code>@PostMapping</code> ， <code>@PutMapping</code> ， <code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。之所以提供它们，是因为大多数控制器方法应该映射为特定的HTTP方法，而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。如果需要组合注释的示例，请查看如何声明它们。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要子类化<code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并返回自己的属性<code>RequestCondition</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-registration"><a class="anchor" href="#webflux-ann-requestmapping-registration"></a>明确注册</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestmapping-registration">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以以编程方式注册Handler方法，这些方法可用于动态注册或高级案例，例如，不同URL下同一处理程序的不同实例。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) <i class="conum" data-value="1"></i><b>(1)</b>
            throws NoSuchMethodException {

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); <i class="conum" data-value="2"></i><b>(2)</b>

        Method method = UserHandler.class.getMethod("getUser", Long.class); <i class="conum" data-value="3"></i><b>(3)</b>

        mapping.registerMapping(info, handler, method); <i class="conum" data-value="4"></i><b>(4)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加注册。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class MyConfig {

    @Autowired
    fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { <i class="conum" data-value="1"></i><b>(1)</b>

        val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() <i class="conum" data-value="2"></i><b>(2)</b>

        val method = UserHandler::class.java.getMethod("getUser", Long::class.java) <i class="conum" data-value="3"></i><b>(3)</b>

        mapping.registerMapping(info, handler, method) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加注册。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-methods"><a class="anchor" href="#webflux-ann-methods"></a> 1.4.3。处理程序方法</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-methods">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从支持的控制器方法参数和返回值的范围中进行选择。</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-arguments"><a class="anchor" href="#webflux-ann-arguments"></a>方法参数</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-arguments">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>下表显示了受支持的控制器方法参数。</p>
</div>
<div class="paragraph">
<p>需要解析I / O（例如，读取请求正文）的自变量支持反应性类型（Reactor，RxJava <a href="#webflux-reactive-libraries">或other</a> ）。这在“描述”列中进行了标记。不需要阻塞的参数不应使用反应性类型。</p>
</div>
<div class="paragraph">
<p>JDK 1.8的<code>java.util.Optional</code>支持作为方法参数，并与具有<code>required</code>属性（例如， <code>@RequestParam</code> ， <code>@RequestHeader</code>和其他），并且等效于<code>required=false</code> 。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerWebExchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查阅全部<code>ServerWebExchange</code> — HTTP请求和响应，请求和会话属性的容器， <code>checkNotModified</code>方法和其他。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpRequest</code> ，<code>ServerHttpResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问HTTP请求或响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问会话。除非添加了属性，否则这不会强制开始新的会话。支持反应类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前经过身份验证的用户-可能是特定用户<code>Principal</code>实现类（如果已知）。支持反应类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.http.HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前请求的语言环境，由最具体的语言确定<code>LocaleResolver</code>可用-实际上，已配置<code>LocaleResolver</code> / <code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> +<code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与当前请求关联的时区，由<code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI模板变量。请参阅<a href="#webflux-ann-requestmapping-uri-templates">URI模式</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI路径段中的名称/值对。请参阅<a href="#webflux-ann-matrix-variables">矩阵变量</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet请求参数。参数值将转换为声明的方法参数类型。看到<a href="#webflux-ann-requestparam"><code>@RequestParam</code></a> 。
</p><p class="tableblock">注意使用<code>@RequestParam</code>是可选的-例如，设置其属性。请参阅此表后面的“其他任何参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头。标头值将转换为声明的方法参数类型。看到<a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问cookie。Cookie值将转换为声明的方法参数类型。看到<a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTTP请求正文。正文内容通过使用转换为声明的方法参数类型<code>HttpMessageReader</code>实例。支持反应类型。看到<a href="#webflux-ann-requestbody"><code>@RequestBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity<B></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头和正文。身体被转化为<code>HttpMessageReader</code>实例。支持反应类型。看到<a href="#webflux-ann-httpentity"><code>HttpEntity</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问零件<code>multipart/form-data</code>请求。支持反应类型。请参见<a href="#webflux-multipart-forms">多部分内容</a>和<a href="#webflux-multipart">多部分数据</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code> ， <code>org.springframework.ui.Model</code>和<code>org.springframework.ui.ModelMap</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTML控制器中使用的模型，并作为视图渲染的一部分公开给模板。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问模型中的现有属性（如果不存在，则进行实例化），并应用数据绑定和验证。看到<a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a>以及<a href="#webflux-ann-modelattrib-methods"><code>Model</code></a>和<a href="#webflux-ann-initbinder"><code>DataBinder</code></a> 。
</p><p class="tableblock">注意使用<code>@ModelAttribute</code>是可选的-例如，设置其属性。请参阅此表后面的“其他任何参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code> ，<code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问验证和命令对象数据绑定中的错误（即<code>@ModelAttribute</code>参数）或验证的错误<code>@RequestBody</code>要么<code>@RequestPart</code>论点。一个<code>Errors</code> ， 要么<code>BindingResult</code>必须在经过验证的方法参数之后立即声明参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> +班级<code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为了标记表单处理完成，将触发清除通过类级别声明的会话属性<code>@SessionAttributes</code>注解。看到<a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于准备相对于当前请求的主机，端口，方案和路径的URL。请参阅<a href="#webflux-uri-building">URI链接</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问任何会话属性-与由于类级别而存储在会话中的模型属性相反<code>@SessionAttributes</code>宣言。看到<a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求属性。看到<a href="#webflux-ann-requestattrib"><code>@RequestAttribute</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他论点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果方法参数与以上任何参数都不匹配，则默认情况下将其解析为<code>@RequestParam</code>如果是<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定的简单类型， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">则为</a> <code>@ModelAttribute</code> ， 除此以外。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-return-types"><a class="anchor" href="#webflux-ann-return-types"></a>返回值</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-return-types">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>下表显示了受支持的控制器方法返回值。注意从库，比如反应堆，RxJava，是反应型<a href="#webflux-reactive-libraries">或其他</a>一般都支持所有的返回值。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法返回值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值通过以下方式编码<code>HttpMessageWriter</code>实例并写入响应。看到<a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity<B></code> ，<code>ResponseEntity<B></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值指定完整的响应，包括HTTP标头，并且正文通过<code>HttpMessageWriter</code>实例并写入响应。看到<a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于返回带有标头且没有正文的响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要解析的视图名称<code>ViewResolver</code>实例，并与隐式模型一起使用-通过命令对象和<code>@ModelAttribute</code>方法。处理程序方法还可以通过声明以下内容以编程方式丰富模型： <code>Model</code>参数（ <a href="#webflux-viewresolution-handling">如前所述</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种<code>View</code>用于与隐式模型一起呈现的实例（通过命令对象和<code>@ModelAttribute</code>方法。处理程序方法还可以通过声明以下内容以编程方式丰富模型： <code>Model</code>参数（ <a href="#webflux-viewresolution-handling">如前所述</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code> ，<code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到隐式模型的属性，其中视图名称根据请求路径隐式确定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到模型的属性，视图名称根据请求路径隐式确定。
</p><p class="tableblock">注意<code>@ModelAttribute</code>是可选的。请参阅此表后面的“其他任何返回值”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Rendering</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于模型和视图渲染方案的API。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种带有<code>void</code> ，可能是异步的（例如， <code>Mono<Void></code> ），返回类型（或<code>null</code>返回值），如果它还具有一个<code>ServerHttpResponse</code> ， 一种<code>ServerWebExchange</code>参数，或<code>@ResponseStatus</code>注解。如果控制器的ETag为正或<code>lastModified</code>时间戳检查。// TODO：有关详细信息，请参见<a href="#webflux-caching-etag-lastmodified">控制器</a> 。
</p><p class="tableblock">如果以上条件都不成立，则<code>void</code>对于REST控制器，返回类型还可以指示“无响应正文”；对于HTML控制器，返回类型也可以指示默认视图名称选择。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux<ServerSentEvent></code> ， <code>Observable<ServerSentEvent></code>或其他反应型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发出服务器发送的事件。的<code>ServerSentEvent</code>仅需要写入数据时，可以省略包装器（但是， <code>text/event-stream</code>必须通过以下方式在映射中请求或声明<code>produces</code>属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果返回值与上述任何一个都不匹配，则默认情况下将其视为视图名称。 <code>String</code>要么<code>void</code> （应用默认视图名称），或作为要添加到模型的模型属性，除非它是由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定的简单类型，在这种情况下，它仍然无法解析。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-typeconversion"><a class="anchor" href="#webflux-ann-typeconversion"></a>类型转换</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-typeconversion">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>某些带注释的控制器方法参数代表基于字符串的请求输入（例如， <code>@RequestParam</code> ， <code>@RequestHeader</code> ， <code>@PathVariable</code> ， <code>@MatrixVariable</code>和<code>@CookieValue</code> ）如果参数被声明为非<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>在这种情况下，将根据配置的转换器自动应用类型转换。默认情况下，简单类型（例如<code>int</code> ， <code>long</code> ， <code>Date</code> ，以及其他）。可以通过以下方式自定义类型转换<code>WebDataBinder</code> （请参阅<a href="#mvc-ann-initbinder">[mvc-ann-initbinder]</a> ）或通过注册<code>Formatters</code>与<code>FormattingConversionService</code> （请参阅<a href="core.html#format">Spring字段格式</a> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-matrix-variables"><a class="anchor" href="#webflux-ann-matrix-variables"></a>矩阵变量</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-matrix-variables">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a>讨论了路径段中的名称/值对。在Spring WebFlux中，我们将它们称为基于Tim Berners-Lee的<a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“旧帖子”</a>的“矩阵变量”，但它们也可以称为URI路径参数。</p>
</div>
<div class="paragraph">
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔，例如， <code>"/cars;color=red,green;year=2012"</code> 。也可以通过重复的变量名称来指定多个值，例如， <code>"color=red;color=green;color=blue"</code> 。</p>
</div>
<div class="paragraph">
<p>与Spring MVC不同，在WebFlux中，URL中是否存在矩阵变量不会影响请求映射。换句话说，不需要使用URI变量来屏蔽变量内容。就是说，如果要从控制器方法访问矩阵变量，则需要将URI变量添加到期望矩阵变量的路径段中。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

    // petId == 42
    // q == 11
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>鉴于所有路径段都可以包含矩阵变量，因此有时可能需要消除矩阵变量应位于哪个路径变量的歧义，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable(name="q", pathVar="ownerId") int q1,
        @MatrixVariable(name="q", pathVar="petId") int q2) {

    // q1 == 11
    // q2 == 22
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(
        @MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
        @MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

    // q1 == 11
    // q2 == 22
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以定义一个矩阵变量，可以将其定义为可选变量并指定一个默认值，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

    // q == 1
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /pets/42

@GetMapping("/pets/{petId}")
fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

    // q == 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要获取所有矩阵变量，请使用<code>MultiValueMap</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar="petId") MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(
        @MatrixVariable matrixVars: MultiValueMap&lt;String, String&gt;,
        @MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap&lt;String, String&gt;) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestparam"><a class="anchor" href="#webflux-ann-requestparam"></a><code>@RequestParam</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestparam">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestParam</code>注释，用于将查询参数绑定到控制器中的方法参数。以下代码段显示了用法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/pets")
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam("petId") int petId, Model model) { <i class="conum" data-value="1"></i><b>(1)</b>
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestParam</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.ui.set

@Controller
@RequestMapping("/pets")
class EditPetForm {

    // ...

    @GetMapping
    fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { <i class="conum" data-value="1"></i><b>(1)</b>
        val pet = clinic.loadPet(petId)
        model["pet"] = pet
        return "petForm"
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestParam</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Servlet API的“请求参数”概念将查询参数，表单数据和多部分合并为一个。但是，在WebFlux中，通过<code>ServerWebExchange</code> 。而<code>@RequestParam</code>仅绑定到查询参数，您可以使用数据绑定将查询参数，表单数据和多部分应用于<a href="#webflux-ann-modelattrib-method-args">命令对象</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用<code>@RequestParam</code>默认情况下，注释是必需的，但是您可以通过设置a的required标志来指定method参数是可选的<code>@RequestParam</code>至<code>false</code>或使用<code>java.util.Optional</code>包装纸。</p>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是，则类型转换将自动应用<code>String</code> 。参见<a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a> 。</p>
</div>
<div class="paragraph">
<p>当一个<code>@RequestParam</code>注释在上声明<code>Map<String, String></code>要么<code>MultiValueMap<String, String></code>参数，该地图将填充所有查询参数。</p>
</div>
<div class="paragraph">
<p>注意使用<code>@RequestParam</code>是可选的-例如，设置其属性。默认情况下，任何简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）都没有被任何其他参数解析器解析，就如同使用注释<code>@RequestParam</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestheader"><a class="anchor" href="#webflux-ann-requestheader"></a><code>@RequestHeader</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestheader">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestHeader</code>注释，用于将请求标头绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了带有标头的请求：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code>标头：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(
        @RequestHeader("Accept-Encoding") String encoding, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestHeader("Keep-Alive") long keepAlive) { <i class="conum" data-value="2"></i><b>(2)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>Accept-Encoging</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获得价值<code>Keep-Alive</code>标头。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/demo")
fun handle(
        @RequestHeader("Accept-Encoding") encoding: String, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestHeader("Keep-Alive") keepAlive: Long) { <i class="conum" data-value="2"></i><b>(2)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>Accept-Encoging</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获得价值<code>Keep-Alive</code>标头。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是，则类型转换将自动应用<code>String</code> 。参见<a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a> 。</p>
</div>
<div class="paragraph">
<p>当一个<code>@RequestHeader</code>注释用于<code>Map<String, String></code> ， <code>MultiValueMap<String, String></code> ， 要么<code>HttpHeaders</code>参数，该映射将填充所有标头值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">内置支持可用于将逗号分隔的字符串转换为数组或字符串集合或类型转换系统已知的其他类型。例如，用注释的方法参数<code>@RequestHeader("Accept")</code>可能是类型<code>String</code>而且<code>String[]</code>要么<code>List<String></code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-cookievalue"><a class="anchor" href="#webflux-ann-cookievalue"></a><code>@CookieValue</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-cookievalue">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@CookieValue</code>注释，用于将HTTP cookie的值绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个带有cookie的请求：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
<div class="paragraph">
<p>下面的代码示例演示如何获取cookie值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { <i class="conum" data-value="1"></i><b>(1)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获取cookie值。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/demo")
fun handle(@CookieValue("JSESSIONID") cookie: String) { <i class="conum" data-value="1"></i><b>(1)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获取cookie值。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是，则类型转换将自动应用<code>String</code> 。参见<a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-modelattrib-method-args"><a class="anchor" href="#webflux-ann-modelattrib-method-args"></a><code>@ModelAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-modelattrib-method-args">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ModelAttribute</code>方法参数上的注释，以从模型访问属性或将其实例化（如果不存在）。model属性还覆盖了名称与字段名称匹配的查询参数和表单字段的值。这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段的工作。以下示例绑定了一个实例<code>Pet</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>绑定一个实例<code>Pet</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute pet: Pet): String { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>绑定一个实例<code>Pet</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>Pet</code>上例中的实例解析如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从模型（如果已经通过添加） <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a> 。</p>
</li>
<li>
<p>从HTTP会话开始<a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a> 。</p>
</li>
<li>
<p>从默认构造函数的调用开始。</p>
</li>
<li>
<p>从带有匹配查询参数或表单字段的参数的“主要构造函数”的调用开始。参数名称是通过JavaBeans确定的<code>@ConstructorProperties</code>或通过字节码中运行时保留的参数名称。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>获取模型属性实例后，将应用数据绑定。的<code>WebExchangeDataBinder</code>类将查询参数和表单字段的名称与目标上的字段名称匹配<code>Object</code> 。在必要时应用类型转换后，将填充匹配字段。有关数据绑定（和验证）的更多信息，请参见<a href="core.html#validation">验证</a> 。有关自定义数据绑定的更多信息，请参见<a href="#webflux-ann-initbinder"><code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>数据绑定可能导致错误。默认情况下， <code>WebExchangeBindException</code>引发，但是，要检查控制器方法中的此类错误，可以添加一个<code>BindingResult</code>紧挨着的论点<code>@ModelAttribute</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加一个<code>BindingResult</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm"
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加一个<code>BindingResult</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以在数据绑定后自动添加验证，方法是添加<code>javax.validation.Valid</code>注解或Spring的<code>@Validated</code>批注（另请参见<a href="core.html#validation-beanvalidation">Bean验证</a>和<a href="core.html#validation">Spring验证</a> ）。以下示例使用<code>@Valid</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@Valid</code>在模型属性参数上。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm"
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@Valid</code>在模型属性参数上。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与Spring MVC不同，Spring WebFlux支持模型中的反应类型-例如， <code>Mono<Account></code>要么<code>io.reactivex.Single<Account></code> 。您可以声明一个<code>@ModelAttribute</code>带有或不带有反应性类型包装器的参数，并将在必要时将其解析为实际值。但是请注意，要使用<code>BindingResult</code>参数，您必须声明<code>@ModelAttribute</code>参数之前没有反应式类型包装器，如前所述。另外，您可以通过反应式处理任何错误，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public Mono&lt;String&gt; processSubmit(@Valid @ModelAttribute("pet") Mono&lt;Pet&gt; petMono) {
    return petMono
        .flatMap(pet -&gt; {
            // ...
        })
        .onErrorResume(ex -&gt; {
            // ...
        });
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@Valid @ModelAttribute("pet") petMono: Mono&lt;Pet&gt;): Mono&lt;String&gt; {
    return petMono
            .flatMap { pet -&gt;
                // ...
            }
            .onErrorResume{ ex -&gt;
                // ...
            }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意使用<code>@ModelAttribute</code>是可选的-例如，设置其属性。默认情况下，任何不是简单值类型（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）且未被其他任何参数解析器解析的参数都将被视为带有<code>@ModelAttribute</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattributes"><a class="anchor" href="#webflux-ann-sessionattributes"></a><code>@SessionAttributes</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-sessionattributes">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code>用于将模型属性存储在<code>WebSession</code>请求之间。它是类型级别的注释，用于声明特定控制器使用的会话属性。这通常列出应透明地存储在会话中以供后续访问请求的模型属性名称或模型属性类型。</p>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttributes</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
class EditPetForm {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttributes</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在第一个请求中，当模型名称为name时， <code>pet</code> ，会被添加到模型中，并自动提升并保存到模型中<code>WebSession</code> 。它会保留在那里，直到另一种控制器方法使用<code>SessionStatus</code>方法参数清除存储，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) { <i class="conum" data-value="2"></i><b>(2)</b>
        if (errors.hasErrors()) {
            // ...
        }
            status.setComplete();
            // ...
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttributes</code>注解。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>用一个<code>SessionStatus</code>变量。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String { <i class="conum" data-value="2"></i><b>(2)</b>
        if (errors.hasErrors()) {
            // ...
        }
        status.setComplete()
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttributes</code>注解。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>用一个<code>SessionStatus</code>变量。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattribute"><a class="anchor" href="#webflux-ann-sessionattribute"></a><code>@SessionAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-sessionattribute">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>如果您需要访问全局存在（即在控制器外部（例如，通过过滤器）管理）并且可能存在或可能不存在的预先存在的会话属性，则可以使用<code>@SessionAttribute</code>方法参数的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@SessionAttribute User user) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttribute</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/")
fun handle(@SessionAttribute user: User): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttribute</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于需要添加或删除会话属性的用例，请考虑注入<code>WebSession</code>进入控制器方法。</p>
</div>
<div class="paragraph">
<p>要将模型属性临时存储在会话中作为控制器工作流的一部分，请考虑使用<code>SessionAttributes</code> ，如中所述<a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestattrib"><a class="anchor" href="#webflux-ann-requestattrib"></a><code>@RequestAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestattrib">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>类似于<code>@SessionAttribute</code> ，您可以使用<code>@RequestAttribute</code>注释以访问先前创建的预先存在的请求属性（例如，通过<code>WebFilter</code> ），如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@RequestAttribute Client client) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestAttribute</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/")
fun handle(@RequestAttribute client: Client): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestAttribute</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart-forms"><a class="anchor" href="#webflux-multipart-forms"></a>多部分内容</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-multipart-forms">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>如<a href="#webflux-multipart">多部分数据中所述</a> ， <code>ServerWebExchange</code>提供对多部分内容的访问。在控制器中处理文件上传表单（例如，从浏览器）的最佳方法是通过将数据绑定到<a href="#webflux-ann-modelattrib-method-args">命令对象</a> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class MyForm {

    private String name;

    private MultipartFile file;

    // ...

}

@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(MyForm form, BindingResult errors) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyForm(
        val name: String,
        val file: MultipartFile)

@Controller
class FileUploadController {

    @PostMapping("/form")
    fun handleFormUpload(form: MyForm, errors: BindingResult): String {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以在RESTful服务方案中从非浏览器客户端提交多部分请求。以下示例将文件与JSON一起使用：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestPart</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") Part metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestPart("file-data") FilePart file) { <i class="conum" data-value="2"></i><b>(2)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>@RequestPart</code>获取文件。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@RequestPart("meta-data") Part metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestPart("file-data") FilePart file): String { <i class="conum" data-value="2"></i><b>(2)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>@RequestPart</code>获取文件。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>反序列化原始零件的内容（例如，转换为JSON，类似于<code>@RequestBody</code> ），您可以声明一个具体目标<code>Object</code> ， 代替<code>Part</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@RequestPart("meta-data") metadata: MetaData): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestPart</code>与<code>javax.validation.Valid</code>或春天的<code>@Validated</code>注释，这将导致应用标准Bean验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code> ，它变成了400（ <code>BAD_REQUEST</code> ）响应。或者，您可以通过以下方式在控制器内本地处理验证错误： <code>Errors</code>要么<code>BindingResult</code>参数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        BindingResult result) { <i class="conum" data-value="2"></i><b>(2)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>@Valid</code>注解。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>用一个<code>BindingResult</code>论点。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@Valid @RequestPart("meta-data") metadata: MetaData, <i class="conum" data-value="1"></i><b>(1)</b>
        result: BindingResult): String { <i class="conum" data-value="2"></i><b>(2)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>@Valid</code>注解。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>用一个<code>BindingResult</code>论点。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>将所有多部分数据作为<code>MultiValueMap</code> ， 您可以使用<code>@RequestBody</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestBody Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestBody</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@RequestBody parts: MultiValueMap&lt;String, Part&gt;): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestBody</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要以流方式顺序访问多部分数据，可以使用<code>@RequestBody</code>与<code>Flux<Part></code> （要么<code>Flow<Part></code>如下面的示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestBody Flux&lt;Part&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestBody</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@RequestBody parts: Flow&lt;Part&gt;): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestBody</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestbody"><a class="anchor" href="#webflux-ann-requestbody"></a><code>@RequestBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-requestbody">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestBody</code>注释，以将请求正文读取并反序列化为<code>Object</code>通过<a href="#webflux-codecs">HttpMessageReader</a> 。以下示例使用<code>@RequestBody</code>参数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@RequestBody account: Account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与Spring MVC不同，在WebFlux中， <code>@RequestBody</code>方法参数支持响应类型以及完全无阻塞的读取和（客户端到服务器）流传输。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Mono&lt;Account&gt; account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@RequestBody accounts: Flow&lt;Account&gt;) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<a href="#webflux-config">WebFlux Config</a>的<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>选项来配置或自定义消息阅读器。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestBody</code>与...结合<code>javax.validation.Valid</code>或春天的<code>@Validated</code>注释，这将导致应用标准Bean验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code> ，它变成了400（ <code>BAD_REQUEST</code> ）响应。或者，您可以通过以下方式在控制器内本地处理验证错误： <code>Errors</code>或一个<code>BindingResult</code>论点。以下示例使用<code>BindingResult</code>参数`：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@Valid @RequestBody account: Account, result: BindingResult) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-httpentity"><a class="anchor" href="#webflux-ann-httpentity"></a><code>HttpEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-httpentity">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code>与使用大致相同<a href="#webflux-ann-requestbody"><code>@RequestBody</code></a>但基于公开请求标头和正文的容器对象。以下示例使用<code>HttpEntity</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(HttpEntity&lt;Account&gt; entity) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(entity: HttpEntity&lt;Account&gt;) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responsebody"><a class="anchor" href="#webflux-ann-responsebody"></a><code>@ResponseBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-responsebody">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ResponseBody</code>方法上的批注，以使返回值通过<a href="#webflux-codecs">HttpMessageWriter</a>序列化为响应主体。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/accounts/{id}")
@ResponseBody
fun handle(): Account {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code>在类级别也受支持，在这种情况下，它由所有控制器方法继承。这是效果<code>@RestController</code> ，无非就是标有的元注释<code>@Controller</code>和<code>@ResponseBody</code> 。</p>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code>支持反应类型，这意味着您可以返回Reactor或RxJava类型，并将它们产生的异步值呈现给响应。有关更多详细信息，请参见<a href="#webflux-codecs-streaming">流</a>和<a href="#webflux-codecs-jackson">JSON呈现</a> 。</p>
</div>
<div class="paragraph">
<p>你可以结合<code>@ResponseBody</code> JSON序列化视图的方法。有关详细信息，请参见<a href="#webflux-ann-jackson">Jackson JSON</a> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="#webflux-config">WebFlux Config</a>的<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>选项来配置或自定义消息编写。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responseentity"><a class="anchor" href="#webflux-ann-responseentity"></a><code>ResponseEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-responseentity">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code>就好像<a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a>但是带有状态和标题。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/something")
public ResponseEntity&lt;String&gt; handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/something")
fun handle(): ResponseEntity&lt;String&gt; {
    val body: String = ...
    val etag: String = ...
    return ResponseEntity.ok().eTag(etag).build(body)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux支持使用单值<a href="#webflux-reactive-libraries">反应类型</a>来生成<code>ResponseEntity</code>和/或主体的单值和多值反应类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-jackson"><a class="anchor" href="#webflux-ann-jackson"></a>杰克逊JSON</h5>
<div class="paragraph">
<p>Spring提供了对Jackson JSON库的支持。</p>
</div>
<div class="sect5">
<h6 id="webflux-ann-jsonview"><a class="anchor" href="#webflux-ann-jsonview"></a> JSON视图</h6>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-jackson">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux为<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson的序列化视图</a>提供了内置支持，该<a href="https://www.baeldung.com/jackson-json-view-annotation">视图</a>仅可呈现<a href="https://www.baeldung.com/jackson-json-view-annotation">杰克逊序列化视图</a>中所有字段的一部分。 <code>Object</code> 。搭配使用<code>@ResponseBody</code>要么<code>ResponseEntity</code>控制器方法，可以使用杰克逊的<code>@JsonView</code>注释以激活序列化视图类，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView::class)
    fun getUser(): User {
        return User("eric", "7!jd#h23")
    }
}

class User(
        @JsonView(WithoutPasswordView::class) val username: String,
        @JsonView(WithPasswordView::class) val password: String
) {
    interface WithoutPasswordView
    interface WithPasswordView : WithoutPasswordView
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@JsonView</code>允许一组视图类，但每个控制器方法只能指定一个。如果需要激活多个视图，请使用复合界面。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-modelattrib-methods"><a class="anchor" href="#webflux-ann-modelattrib-methods"></a> 1.4.4。<code>Model</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-modelattrib-methods">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ModelAttribute</code>注解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在<a href="#webflux-ann-modelattrib-method-args">方法自变量</a>中<code>@RequestMapping</code>从模型创建或访问对象并将其绑定到请求的方法<code>WebDataBinder</code> 。</p>
</li>
<li>
<p>作为方法级别的注释<code>@Controller</code>要么<code>@ControllerAdvice</code>类，有助于在任何之前初始化模型<code>@RequestMapping</code>方法调用。</p>
</li>
<li>
<p>在<code>@RequestMapping</code>方法，以将其返回值标记为模型属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节讨论<code>@ModelAttribute</code>方法，或前面列表中的第二项。控制器可以具有任意数量的<code>@ModelAttribute</code>方法。所有此类方法均在调用之前<code>@RequestMapping</code>同一控制器中的方法。一种<code>@ModelAttribute</code>也可以通过以下方式在控制器之间共享方法<code>@ControllerAdvice</code> 。有关更多详细信息，请参见“ <a href="#webflux-ann-controller-advice">控制器建议</a> ”部分。</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。他们支持许多与<code>@RequestMapping</code>方法（除<code>@ModelAttribute</code>本身以及与请求正文相关的任何内容）。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@ModelAttribute</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ModelAttribute
fun populateModel(@RequestParam number: String, model: Model) {
    model.addAttribute(accountRepository.findAccount(number))
    // add more ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例仅添加一个属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ModelAttribute
fun addAccount(@RequestParam number: String): Account {
    return accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未明确指定名称，则根据类型选择默认名称，如Javadoc中针对<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a> 。您始终可以通过使用重载来分配显式名称<code>addAttribute</code>方法或通过name属性<code>@ModelAttribute</code> （用于返回值）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与Spring MVC不同，Spring WebFlux明确支持模型中的反应类型（例如， <code>Mono<Account></code>要么<code>io.reactivex.Single<Account></code> ）。这样的异步模型属性可以透明地解析（并更新模型）为它们的实际值。 <code>@RequestMapping</code>调用，提供了<code>@ModelAttribute</code>声明的参数没有包装，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void addAccount(@RequestParam String number) {
    Mono&lt;Account&gt; accountMono = accountRepository.findAccount(number);
    model.addAttribute("account", accountMono);
}

@PostMapping("/accounts")
public String handle(@ModelAttribute Account account, BindingResult errors) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.ui.set

@ModelAttribute
fun addAccount(@RequestParam number: String) {
    val accountMono: Mono&lt;Account&gt; = accountRepository.findAccount(number)
    model["account"] = accountMono
}

@PostMapping("/accounts")
fun handle(@ModelAttribute account: Account, errors: BindingResult): String {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，任何具有反应性类型包装器的模型属性都将在视图渲染之前解析为其实际值（并更新了模型）。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>@ModelAttribute</code>作为方法级别的注释<code>@RequestMapping</code>方法，在这种情况下， <code>@RequestMapping</code>方法被解释为模型属性。通常不需要这样做，因为这是HTML控制器的默认行为，除非返回值是<code>String</code>否则将被解释为视图名称。 <code>@ModelAttribute</code>还可以帮助自定义模型属性名称，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
    // ...
    return account;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
fun handle(): Account {
    // ...
    return account
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-initbinder"><a class="anchor" href="#webflux-ann-initbinder"></a> 1.4.5。<code>DataBinder</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-initbinder">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>要么<code>@ControllerAdvice</code>类可以有<code>@InitBinder</code>方法，以初始化的实例<code>WebDataBinder</code> 。这些依次用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将请求参数（即表单数据或查询）绑定到模型对象。</p>
</li>
<li>
<p>兑换<code>String</code>控制器方法参数的目标类型的基于请求的值（例如请求参数，路径变量，标头，Cookie等）。</p>
</li>
<li>
<p>将模型对象值格式化为<code>String</code>呈现HTML表单时的值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法可以注册特定于控制器的方法<code>java.bean.PropertyEditor</code>或春天<code>Converter</code>和<code>Formatter</code>组件。另外，您可以使用<a href="#webflux-config-conversion">WebFlux Java配置</a>进行注册<code>Converter</code>和<code>Formatter</code>输入全球共享<code>FormattingConversionService</code> 。</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法支持许多相同的参数<code>@RequestMapping</code>方法可以，除了<code>@ModelAttribute</code> （命令对象）参数。通常，它们以<code>WebDataBinder</code>参数，用于注册，以及<code>void</code>返回值。以下示例使用<code>@InitBinder</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@InitBinder</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    fun initBinder(binder: WebDataBinder) {
        val dateFormat = SimpleDateFormat("yyyy-MM-dd")
        dateFormat.isLenient = false
        binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，当使用<code>Formatter</code>基于共享的设置<code>FormattingConversionService</code> ，您可以重复使用相同的方法并注册特定于控制器的<code>Formatter</code>实例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加自定义格式器（ <code>DateFormatter</code> ， 在这种情况下）。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class FormController {

    @InitBinder
    fun initBinder(binder: WebDataBinder) {
        binder.addCustomFormatter(DateFormatter("yyyy-MM-dd")) <i class="conum" data-value="1"></i><b>(1)</b>
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加自定义格式器（ <code>DateFormatter</code> ， 在这种情况下）。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-exceptions"><a class="anchor" href="#webflux-ann-controller-exceptions"></a> 1.4.6。管理异常</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-exceptionhandler">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>和<a href="#mvc-ann-controller-advice">@ControllerAdvice</a>类可以具有<code>@ExceptionHandler</code>处理控制器方法异常的方法。下面的示例包括这样的处理程序方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class SimpleController {

    // ...

    @ExceptionHandler <i class="conum" data-value="1"></i><b>(1)</b>
    public ResponseEntity&lt;String&gt; handle(IOException ex) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>宣告<code>@ExceptionHandler</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class SimpleController {

    // ...

    @ExceptionHandler <i class="conum" data-value="1"></i><b>(1)</b>
    fun handle(ex: IOException): ResponseEntity&lt;String&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>宣告<code>@ExceptionHandler</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该异常可以与正在传播的顶级异常匹配（即，直接<code>IOException</code>或针对顶级包装程序异常中的直接原因（例如， <code>IOException</code>包裹在里面<code>IllegalStateException</code> ）。</p>
</div>
<div class="paragraph">
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。或者，注释声明可以缩小异常类型以使其匹配。我们通常建议在参数签名中尽可能具体，并在<code>@ControllerAdvice</code>按相应的顺序排列优先级。有关详细信息，请参见<a href="web.html#mvc-ann-exceptionhandler">MVC部分</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">一个<code>@ExceptionHandler</code> WebFlux中的方法支持与方法相同的方法参数和返回值<code>@RequestMapping</code>方法，但请求正文和<code>@ModelAttribute</code>相关的方法参数。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>支持<code>@ExceptionHandler</code> Spring WebFlux中的方法由<code>HandlerAdapter</code>对于<code>@RequestMapping</code>方法。看到<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>有关更多详细信息。</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-rest-exceptions"><a class="anchor" href="#webflux-ann-rest-exceptions"></a> REST API例外</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-rest-exceptions">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>REST服务的常见要求是在响应正文中包含错误详细信息。Spring Framework 不会自动这样做，因为响应主体中错误详细信息的表示是特定于应用程序的。但是， <code>@RestController</code>可以使用<code>@ExceptionHandler</code>方法与<code>ResponseEntity</code>返回值以设置响应的状态和主体。这样的方法也可以在<code>@ControllerAdvice</code>类以将其全局应用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，Spring WebFlux与Spring MVC没有等效项<code>ResponseEntityExceptionHandler</code> ，因为WebFlux仅筹集资金<code>ResponseStatusException</code> （或其子类），而无需将其转换为HTTP状态代码。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-advice"><a class="anchor" href="#webflux-ann-controller-advice"></a> 1.4.7。控制器建议</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-ann-controller-advice">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>通常， <code>@ExceptionHandler</code> ， <code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于<code>@Controller</code>声明它们的类（或类层次结构）。如果您希望此类方法更全局地应用（跨控制器），则可以在带有以下注释的类中声明它们： <code>@ControllerAdvice</code>要么<code>@RestControllerAdvice</code> 。</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code>带有注释<code>@Component</code> ，这意味着可以通过<a href="core.html#beans-java-instantiating-container-scan">组件扫描</a>将此类注册为Spring Bean。 <code>@RestControllerAdvice</code>是一个组合注释，同时用<code>@ControllerAdvice</code>和<code>@ResponseBody</code> ，这实质上意味着<code>@ExceptionHandler</code>方法通过消息转换（与视图分辨率或模板渲染相比）呈现给响应主体。</p>
</div>
<div class="paragraph">
<p>启动时，用于<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法检测带有注释的Spring bean <code>@ControllerAdvice</code>然后在运行时应用其方法。全球<code>@ExceptionHandler</code>方法（从<code>@ControllerAdvice</code> ） <em>在</em>本地（从<code>@Controller</code> ）。相比之下，全球<code>@ModelAttribute</code>和<code>@InitBinder</code>方法<em>先于</em>本地方法。</p>
</div>
<div class="paragraph">
<p>默认， <code>@ControllerAdvice</code>方法适用于每个请求（即所有控制器），但是您可以通过使用注释上的属性将其范围缩小到控制器的子集，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = [RestController::class])
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
public class ExampleAdvice3 {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a>有关更多详细信息，请参见javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-fn"><a class="anchor" href="#webflux-fn"></a> 1.5。功能端点</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#webmvc-fn">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux包含WebFlux.fn，这是一个轻量级的函数编程模型，其中的函数用于路由和处理请求，而契约则是为不变性而设计的。它是基于注释的编程模型的替代方案，但可以在相同的<a href="#webflux-reactive-spring-web">Reactive Core</a>基础上运行。</p>
</div>
<div class="sect3">
<h4 id="webflux-fn-overview"><a class="anchor" href="#webflux-fn-overview"></a> 1.5.1。总览</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#webmvc-fn-overview">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在WebFlux.fn中，HTTP请求使用<code>HandlerFunction</code> ：需要的功能<code>ServerRequest</code>并返回延迟<code>ServerResponse</code> （即<code>Mono<ServerResponse></code> ）。作为请求对象的请求都具有不可变的协定，这些协定为JDK 8提供了对HTTP请求和响应的友好访问。
<code>HandlerFunction</code>等于一个物体的主体<code>@RequestMapping</code>基于注释的编程模型中的方法。</p>
</div>
<div class="paragraph">
<p>传入的请求被路由到带有<code>RouterFunction</code> ：需要的功能<code>ServerRequest</code>并返回延迟<code>HandlerFunction</code> （即<code>Mono<HandlerFunction></code> ）。当路由器功能匹配时，返回处理程序功能。否则为空Mono。
<code>RouterFunction</code>等于一个<code>@RequestMapping</code>注释，但主要区别在于路由器功能不仅提供数据，还提供行为。</p>
</div>
<div class="paragraph">
<p><code>RouterFunctions.route()</code>提供了一个有助于构建路由器的路由器构建器，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople)
    .POST("/person", handler::createPerson)
    .build();


public class PersonHandler {

    // ...

    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val repository: PersonRepository = ...
val handler = PersonHandler(repository)

val route = coRouter { <i class="conum" data-value="1"></i><b>(1)</b>
    accept(APPLICATION_JSON).nest {
        GET("/person/{id}", handler::getPerson)
        GET("/person", handler::listPeople)
    }
    POST("/person", handler::createPerson)
}


class PersonHandler(private val repository: PersonRepository) {

    // ...

    suspend fun listPeople(request: ServerRequest): ServerResponse {
        // ...
    }

    suspend fun createPerson(request: ServerRequest): ServerResponse {
        // ...
    }

    suspend fun getPerson(request: ServerRequest): ServerResponse {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用Coroutines路由器DSL创建路由器，也可以通过<code>router { }</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一种运行方式<code>RouterFunction</code>是把它变成一个<code>HttpHandler</code>并通过内置<a href="#webflux-httphandler">服务器适配器</a>之一安装它：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大多数应用程序可以通过WebFlux Java配置<a href="#webflux-fn-running">运行</a> ，请参阅“ <a href="#webflux-fn-running">运行服务器”</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-functions"><a class="anchor" href="#webflux-fn-handler-functions"></a> 1.5.2。处理函数</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#webmvc-fn-handler-functions">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerRequest</code>和<code>ServerResponse</code>是不可变的接口，它们提供JDK 8友好的HTTP请求和响应访问。请求和响应都为<a href="https://www.reactive-streams.org">反应流</a>提供了对体流的反压力。请求主体用Reactor表示<code>Flux</code>要么<code>Mono</code> 。响应主体由任何反应流表示<code>Publisher</code> ， 包含<code>Flux</code>和<code>Mono</code> 。有关更多信息，请参见<a href="#webflux-reactive-libraries">反应式库</a> 。</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-request"><a class="anchor" href="#webflux-fn-request"></a><code>ServerRequest</code></h5>
<div class="paragraph">
<p><code>ServerRequest</code>提供对HTTP方法，URI，标头和查询参数的访问，而对正文的访问则通过<code>body</code>方法。</p>
</div>
<div class="paragraph">
<p>以下示例将请求正文提取到<code>Mono<String></code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; string = request.bodyToMono(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val string = request.awaitBody&lt;String&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例将主体提取到<code>Flux<Person></code> （或<code>Flow<Person></code>在Kotlin）， <code>Person</code>对象从某种序列化形式（例如JSON或XML）解码：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Person&gt; people = request.bodyToFlux(Person.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val people = request.bodyToFlow&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例是使用更通用的快捷方式<code>ServerRequest.body(BodyExtractor)</code> ，它接受<code>BodyExtractor</code>功能策略界面。实用类<code>BodyExtractors</code>提供对许多实例的访问。例如，前面的示例也可以编写如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; string = request.body(BodyExtractors.toMono(String.class));
Flux&lt;Person&gt; people = request.body(BodyExtractors.toFlux(Person.class));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">    val string = request.body(BodyExtractors.toMono(String::class.java)).awaitFirst()
    val people = request.body(BodyExtractors.toFlux(Person::class.java)).asFlow()</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示如何访问表单数据：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, String&gt; map = request.formData();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val map = request.awaitFormData()</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何以地图的形式访问多部分数据：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, Part&gt; map = request.multipartData();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val map = request.awaitMultipartData()</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何以流方式一次访问多个部分：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Part&gt; parts = request.body(BodyExtractors.toParts());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parts = request.body(BodyExtractors.toParts()).asFlow()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-response"><a class="anchor" href="#webflux-fn-response"></a><code>ServerResponse</code></h5>
<div class="paragraph">
<p><code>ServerResponse</code>提供对HTTP响应的访问，并且由于它是不可变的，因此您可以使用<code>build</code>创建它的方法。您可以使用构建器来设置响应状态，添加响应标题或提供正文。以下示例使用JSON内容创建200（确定）响应：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val person: Person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyValue(person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用来构建201（已创建）响应<code>Location</code>标头，无正文：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI location = ...
ServerResponse.created(location).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val location: URI = ...
ServerResponse.created(location).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据所使用的编解码器，可以传递提示参数以自定义主体的序列化或反序列化方式。例如，要指定一个<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson JSON视图</a> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ServerResponse.ok().hint(Jackson2CodecSupport.JSON_VIEW_HINT, MyJacksonView.class).body(...);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">ServerResponse.ok().hint(Jackson2CodecSupport.JSON_VIEW_HINT, MyJacksonView::class.java).body(...)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-classes"><a class="anchor" href="#webflux-fn-handler-classes"></a>处理程序类</h5>
<div class="paragraph">
<p>我们可以将处理程序函数编写为lambda，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().bodyValue("Hello World");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val helloWorld = HandlerFunction&lt;ServerResponse&gt; { ServerResponse.ok().bodyValue("Hello World") }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很方便，但是在应用程序中我们需要多个功能，并且多个内联lambda可能会变得凌乱。因此，将相关的处理程序功能分组到一个处理程序类中很有用，该类的作用与<code>@Controller</code>在基于注释的应用程序中。例如，以下类公开了一个反应式<code>Person</code>资料库：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

public class PersonHandler {

    private final PersonRepository repository;

    public PersonHandler(PersonRepository repository) {
        this.repository = repository;
    }

    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) { <i class="conum" data-value="1"></i><b>(1)</b>
        Flux&lt;Person&gt; people = repository.allPeople();
        return ok().contentType(APPLICATION_JSON).body(people, Person.class);
    }

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) { <i class="conum" data-value="2"></i><b>(2)</b>
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class);
        return ok().build(repository.savePerson(person));
    }

    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) { <i class="conum" data-value="3"></i><b>(3)</b>
        int personId = Integer.valueOf(request.pathVariable("id"));
        return repository.getPerson(personId)
            .flatMap(person -&gt; ok().contentType(APPLICATION_JSON).bodyValue(person))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>listPeople</code>是一个返回所有<code>Person</code>在存储库中以JSON形式找到的对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>createPerson</code>是一个存储新<code>Person</code>包含在请求正文中。注意<code>PersonRepository.savePerson(Person)</code>退货<code>Mono<Void></code> ：空<code>Mono</code>从请求中读取并存储此人后，它将发出完成信号。所以我们用<code>build(Publisher<Void>)</code>当收到完成信号时（即，当<code>Person</code>已保存）。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>getPerson</code>是一个返回单个人的处理函数，由<code>id</code>路径变量。我们检索到<code>Person</code>从存储库中创建一个JSON响应（如果找到）。如果找不到，我们使用<code>switchIfEmpty(Mono<T>)</code>返回404 Not Found响应。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonHandler(private val repository: PersonRepository) {

    suspend fun listPeople(request: ServerRequest): ServerResponse { <i class="conum" data-value="1"></i><b>(1)</b>
        val people: Flow&lt;Person&gt; = repository.allPeople()
        return ok().contentType(APPLICATION_JSON).bodyAndAwait(people);
    }

    suspend fun createPerson(request: ServerRequest): ServerResponse { <i class="conum" data-value="2"></i><b>(2)</b>
        val person = request.awaitBody&lt;Person&gt;()
        repository.savePerson(person)
        return ok().buildAndAwait()
    }

    suspend fun getPerson(request: ServerRequest): ServerResponse { <i class="conum" data-value="3"></i><b>(3)</b>
        val personId = request.pathVariable("id").toInt()
        return repository.getPerson(personId)?.let { ok().contentType(APPLICATION_JSON).bodyValueAndAwait(it) }
                ?: ServerResponse.notFound().buildAndAwait()

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>listPeople</code>是一个返回所有<code>Person</code>在存储库中以JSON形式找到的对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>createPerson</code>是一个存储新<code>Person</code>包含在请求正文中。注意<code>PersonRepository.savePerson(Person)</code>是没有返回类型的挂起函数。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>getPerson</code>是一个返回单个人的处理函数，由<code>id</code>路径变量。我们检索到<code>Person</code>从存储库中创建一个JSON响应（如果找到）。如果找不到，我们将返回404 Not Found响应。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-validation"><a class="anchor" href="#webflux-fn-handler-validation"></a>验证方式</h5>
<div class="paragraph">
<p>功能端点可以使用Spring的<a href="core.html#validation">验证工具</a>将验证应用于请求主体。例如，给定一个自定义的Spring <a href="core.html#validation">Validator</a>实现， <code>Person</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonHandler {

    private final Validator validator = new PersonValidator(); <i class="conum" data-value="1"></i><b>(1)</b>

    // ...

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class).doOnNext(this::validate); <i class="conum" data-value="2"></i><b>(2)</b>
        return ok().build(repository.savePerson(person));
    }

    private void validate(Person person) {
        Errors errors = new BeanPropertyBindingResult(person, "person");
        validator.validate(person, errors);
        if (errors.hasErrors()) {
            throw new ServerWebInputException(errors.toString()); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建<code>Validator</code>实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>应用验证。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>引发400响应的异常。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonHandler(private val repository: PersonRepository) {

    private val validator = PersonValidator() <i class="conum" data-value="1"></i><b>(1)</b>

    // ...

    suspend fun createPerson(request: ServerRequest): ServerResponse {
        val person = request.awaitBody&lt;Person&gt;()
        validate(person) <i class="conum" data-value="2"></i><b>(2)</b>
        repository.savePerson(person)
        return ok().buildAndAwait()
    }

    private fun validate(person: Person) {
        val errors: Errors = BeanPropertyBindingResult(person, "person");
        validator.validate(person, errors);
        if (errors.hasErrors()) {
            throw ServerWebInputException(errors.toString()) <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建<code>Validator</code>实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>应用验证。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>引发400响应的异常。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>处理程序还可以通过创建和注入全局bean来使用标准bean验证API（JSR-303）。 <code>Validator</code>实例基于<code>LocalValidatorFactoryBean</code> 。请参阅<a href="core.html#validation-beanvalidation">Spring Validation</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-router-functions"><a class="anchor" href="#webflux-fn-router-functions"></a> 1.5.3。<code>RouterFunction</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#webmvc-fn-router-functions">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>路由器功能用于将请求路由到相应的<code>HandlerFunction</code> 。通常，您不必自己编写路由器功能，而应在<code>RouterFunctions</code>实用程序类创建一个。
<code>RouterFunctions.route()</code> （无参数）为您提供了流畅的生成器来创建路由器功能，而<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code>提供了创建路由器的直接方法。</p>
</div>
<div class="paragraph">
<p>通常，建议使用<code>route()</code>构建器，因为它为典型的映射方案提供了便捷的捷径，而无需发现静态导入。例如，路由器功能构建器提供了方法<code>GET(String, HandlerFunction)</code>为GET请求创建映射；和<code>POST(String, HandlerFunction)</code>用于POST。</p>
</div>
<div class="paragraph">
<p>除了基于HTTP方法的映射外，路由构建器还提供了一种在映射到请求时引入其他谓词的方法。对于每个HTTP方法，都有一个重载的变体，它需要一个<code>RequestPredicate</code>作为参数，但可以表达其他约束。</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-predicates"><a class="anchor" href="#webflux-fn-predicates"></a>谓词</h5>
<div class="paragraph">
<p>你可以自己写<code>RequestPredicate</code> ，但<code>RequestPredicates</code>实用程序类基于请求路径，HTTP方法，内容类型等提供常用的实现。以下示例使用请求谓词基于以下内容创建约束： <code>Accept</code>标头：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
    .GET("/hello-world", accept(MediaType.TEXT_PLAIN),
        request -&gt; ServerResponse.ok().bodyValue("Hello World"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val route = coRouter {
    GET("/hello-world", accept(TEXT_PLAIN)) {
        ServerResponse.ok().bodyValueAndAwait("Hello World")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下命令组合多个请求谓词：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestPredicate.and(RequestPredicate)</code> -两者必须匹配。</p>
</li>
<li>
<p><code>RequestPredicate.or(RequestPredicate)</code> -两者都可以匹配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>许多谓词来自<code>RequestPredicates</code>组成。例如， <code>RequestPredicates.GET(String)</code>由...组成<code>RequestPredicates.method(HttpMethod)</code>和<code>RequestPredicates.path(String)</code> 。上面显示的示例还使用了两个请求谓词，因为构建器使用<code>RequestPredicates.GET</code>在内部，并与<code>accept</code>谓语。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-routes"><a class="anchor" href="#webflux-fn-routes"></a>路线</h5>
<div class="paragraph">
<p>路由器功能按顺序评估：如果第一个路由不匹配，则评估第二个路由，依此类推。因此，在通用路由之前声明更具体的路由是有意义的。请注意，此行为不同于基于注释的编程模型，在该模型中，将自动选择“最特定”的控制器方法。</p>
</div>
<div class="paragraph">
<p>使用路由器功能生成器时，所有定义的路由都被组合为一个<code>RouterFunction</code>从返回<code>build()</code> 。还有其他方法可以将多个路由器功能组合在一起：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>add(RouterFunction)</code>在<code>RouterFunctions.route()</code>建造者</p>
</li>
<li>
<p><code>RouterFunction.and(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> —的快捷方式<code>RouterFunction.and()</code>与嵌套<code>RouterFunctions.route()</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了四种路线的组成：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
    .POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
    .add(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>GET /person/{id}</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>GET /person</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>POST /person</code>没有其他谓词的映射到<code>PersonHandler.createPerson</code>和</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>otherRoute</code>是在其他地方创建并添加到所建立路由的路由器功能。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.http.MediaType.APPLICATION_JSON

val repository: PersonRepository = ...
val handler = PersonHandler(repository);

val otherRoute: RouterFunction&lt;ServerResponse&gt; = coRouter {  }

val route = coRouter {
    GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
    GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
    POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
}.and(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>GET /person/{id}</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>GET /person</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>POST /person</code>没有其他谓词的映射到<code>PersonHandler.createPerson</code>和</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>otherRoute</code>是在其他地方创建并添加到所建立路由的路由器功能。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="nested-routes"><a class="anchor" href="#nested-routes"></a>嵌套路线</h5>
<div class="paragraph">
<p>一组路由器功能通常具有共享谓词，例如共享路径。在上面的示例中，共享谓词将是与之匹配的路径谓词<code>/person</code> ，其中三条路线都使用了。使用注释时，您将使用类型级别来删除此重复项<code>@RequestMapping</code>映射到的注释<code>/person</code> 。在WebFlux.fn中，路径谓词可以通过以下方式共享<code>path</code>路由器功能构建器上的方法。例如，以上示例的最后几行可以通过使用嵌套路由以以下方式进行改进：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", builder -&gt; builder <i class="conum" data-value="1"></i><b>(1)</b>
        .GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        .GET("", accept(APPLICATION_JSON), handler::listPeople)
        .POST("/person", handler::createPerson))
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>请注意， <code>path</code>是使用路由器制造商的消费者。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val route = coRouter {
    "/person".nest {
        GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        GET("", accept(APPLICATION_JSON), handler::listPeople)
        POST("/person", handler::createPerson)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管基于路径的嵌套是最常见的，但是您可以通过使用<code>nest</code>生成器上的方法。上面仍然包含一些重复形式的共享<code>Accept</code> -header谓词。我们可以通过使用<code>nest</code>方法与<code>accept</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val route = coRouter {
    "/person".nest {
        accept(APPLICATION_JSON).nest {
            GET("/{id}", handler::getPerson)
            GET("", handler::listPeople)
            POST("/person", handler::createPerson)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-running"><a class="anchor" href="#webflux-fn-running"></a> 1.5.4。运行服务器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#webmvc-fn-running">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>如何在HTTP服务器中运行路由器功能？一个简单的选项是将路由器功能转换为<code>HttpHandler</code>通过使用以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，您可以使用返回的<code>HttpHandler</code>遵循<a href="#webflux-httphandler">HttpHandler</a>获取有关服务器特定的说明，从而使用许多服务器适配器。</p>
</div>
<div class="paragraph">
<p>Spring Boot也使用了一个更典型的选项，即使用<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>通过<a href="#webflux-config">WebFlux Config进行</a>基于设置的<a href="#webflux-config">设置</a> ，该配置使用Spring配置来声明处理请求所需的组件。WebFlux Java配置声明以下基础结构组件以支持功能端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctionMapping</code> ：检测一个或多个<code>RouterFunction<?></code> Spring配置中的bean，通过组合它们<code>RouterFunction.andOther</code> ，并将请求路由到生成的结果<code>RouterFunction</code> 。</p>
</li>
<li>
<p><code>HandlerFunctionAdapter</code> ：简单的适配器，让<code>DispatcherHandler</code>调用<code>HandlerFunction</code>映射到请求。</p>
</li>
<li>
<p><code>ServerResponseResultHandler</code> ：处理调用a的结果<code>HandlerFunction</code>通过调用<code>writeTo</code>的方法<code>ServerResponse</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的组件使功能端点适合<code>DispatcherHandler</code>请求处理生命周期，并（可能）与带注释的控制器（如果已声明）并排运行。这也是Spring Boot WebFlux启动器启用功能端点的方式。</p>
</div>
<div class="paragraph">
<p>以下示例显示了WebFlux Java配置（有关如何运行它，请参见<a href="#webflux-dispatcher-handler">DispatcherHandler</a> ）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionA() {
        // ...
    }

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionB() {
        // ...
    }

    // ...

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        // configure message conversion...
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // configure CORS...
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // configure view resolution for HTML rendering...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    @Bean
    fun routerFunctionA(): RouterFunction&lt;*&gt; {
        // ...
    }

    @Bean
    fun routerFunctionB(): RouterFunction&lt;*&gt; {
        // ...
    }

    // ...

    override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
        // configure message conversion...
    }

    override fun addCorsMappings(registry: CorsRegistry) {
        // configure CORS...
    }

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        // configure view resolution for HTML rendering...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-filter-function"><a class="anchor" href="#webflux-fn-handler-filter-function"></a> 1.5.5。过滤处理程序功能</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#webmvc-fn-handler-filter-function">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>before</code> ， <code>after</code> ， 要么<code>filter</code>路由功能构建器上的方法。使用注释，您可以通过使用<code>@ControllerAdvice</code> ， 一种<code>ServletFilter</code> ， 或两者。该过滤器将应用于构建器构建的所有路由。这意味着在嵌套路由中定义的过滤器不适用于“顶级”路由。例如，考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople)
            .before(request -&gt; ServerRequest.from(request) <i class="conum" data-value="1"></i><b>(1)</b>
                .header("X-RequestHeader", "Value")
                .build()))
        .POST("/person", handler::createPerson))
    .after((request, response) -&gt; logResponse(response)) <i class="conum" data-value="2"></i><b>(2)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>before</code>添加自定义请求标头的过滤器仅应用于两个GET路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>after</code>记录响应的过滤器将应用于所有路由，包括嵌套路由。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val route = router {
    "/person".nest {
        GET("/{id}", handler::getPerson)
        GET("", handler::listPeople)
        before { <i class="conum" data-value="1"></i><b>(1)</b>
            ServerRequest.from(it)
                    .header("X-RequestHeader", "Value").build()
        }
        POST("/person", handler::createPerson)
        after { _, response -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            logResponse(response)
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>before</code>添加自定义请求标头的过滤器仅应用于两个GET路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>after</code>记录响应的过滤器将应用于所有路由，包括嵌套路由。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>filter</code>路由器构建器上的方法需要一个<code>HandlerFilterFunction</code> ：需要一个<code>ServerRequest</code>和<code>HandlerFunction</code>并返回一个<code>ServerResponse</code> 。handler函数参数代表链中的下一个元素。这通常是路由到的处理程序，但是如果应用了多个，它也可以是另一个过滤器。</p>
</div>
<div class="paragraph">
<p>现在，假设我们有一个<code>SecurityManager</code>可以确定是否允许特定路径。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">SecurityManager securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .filter((request, next) -&gt; {
        if (securityManager.allowAccessTo(request.path())) {
            return next.handle(request);
        }
        else {
            return ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val securityManager: SecurityManager = ...

val route = router {
        ("/person" and accept(APPLICATION_JSON)).nest {
            GET("/{id}", handler::getPerson)
            GET("", handler::listPeople)
            POST("/person", handler::createPerson)
            filter { request, next -&gt;
                if (securityManager.allowAccessTo(request.path())) {
                    next(request)
                }
                else {
                    status(UNAUTHORIZED).build();
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例说明了调用<code>next.handle(ServerRequest)</code>是可选的。当允许访问时，我们仅允许执行处理函数。</p>
</div>
<div class="paragraph">
<p>除了使用<code>filter</code>路由器功能构建器上的方法，可以通过以下方法将过滤器应用于现有路由器功能<code>RouterFunction.filter(HandlerFilterFunction)</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过专用的CORS支持功能端点<a href="#webflux-cors-webfilter"><code>CorsWebFilter</code></a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-uri-building"><a class="anchor" href="#webflux-uri-building"></a> 1.6。URI链接</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-uri-building">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>本节描述了Spring Framework 中用于准备URI的各种选项。</p>
</div>
<div class="sect3">
<h4 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a> 1.6.1。UriComponents</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>有助于从带有变量的URI模板构建URI，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
        .queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
        .encode() <i class="conum" data-value="3"></i><b>(3)</b>
        .build(); <i class="conum" data-value="4"></i><b>(4)</b>

URI uri = uriComponents.expand("Westin", "123").toUri();  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>请求对URI模板和URI变量进行编码。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>建个<code>UriComponents</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>展开变量并获得<code>URI</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uriComponents = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
        .queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
        .encode() <i class="conum" data-value="3"></i><b>(3)</b>
        .build() <i class="conum" data-value="4"></i><b>(4)</b>

val uri = uriComponents.expand("Westin", "123").toUri()  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>请求对URI模板和URI变量进行编码。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>建个<code>UriComponents</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>展开变量并获得<code>URI</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的示例可以合并为一个链，并且可以通过以下方式缩短<code>buildAndExpand</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("Westin", "123")
        .toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("Westin", "123")
        .toUri()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}?q={q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}?q={q}")
        .build("Westin", "123")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a> 1.6.2。UriBuilder</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a>贯彻<code>UriBuilder</code> 。您可以创建一个<code>UriBuilder</code> ，反过来， <code>UriBuilderFactory</code> 。一起， <code>UriBuilderFactory</code>和<code>UriBuilder</code>提供一种可插入的机制，以基于共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p>
</div>
<div class="paragraph">
<p>您可以配置<code>RestTemplate</code>和<code>WebClient</code>与一个<code>UriBuilderFactory</code>自定义URI的准备。 <code>DefaultUriBuilderFactory</code>是的默认实现<code>UriBuilderFactory</code>使用<code>UriComponentsBuilder</code>内部并公开共享的配置选项。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置<code>RestTemplate</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode

val baseUrl = "https://example.org"
val factory = DefaultUriBuilderFactory(baseUrl)
factory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES

val restTemplate = RestTemplate()
restTemplate.uriTemplateHandler = factory</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例配置了一个<code>WebClient</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode

val baseUrl = "https://example.org"
val factory = DefaultUriBuilderFactory(baseUrl)
factory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES

val client = WebClient.builder().uriBuilderFactory(factory).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，您还可以使用<code>DefaultUriBuilderFactory</code>直。类似于使用<code>UriComponentsBuilder</code>但是，它是一个实际的实例，其中包含配置和首选项，而不是静态的工厂方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String baseUrl = "https://example.com";
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val baseUrl = "https://example.com"
val uriBuilderFactory = DefaultUriBuilderFactory(baseUrl)

val uri = uriBuilderFactory.uriString("/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a> 1.6.3。URI编码</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder＃encode（）</a> ：首先对URI模板进行预编码，然后在扩展时严格对URI变量进行编码。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents＃encode（）</a> ：扩展URI变量<em>后，</em> <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">对</a> URI组件<em>进行</em>编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个选项都用转义的八位字节替换非ASCII和非法字符。但是，第一个选项还会替换出现在URI变量中的具有保留含义的字符。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">考虑“;”，这在路径上是合法的，但具有保留的含义。第一个选项代替“;” URI变量中带有“％3B”，但URI模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在大多数情况下，第一个选项可能会产生预期的结果，因为它将URI变量视为要完全编码的不透明数据，而选项2仅在URI变量有意包含保留字符的情况下才有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用第一个选项：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("New York", "foo+bar")
        .toUri();

// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("New York", "foo+bar")
        .toUri()

// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}?q={q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}?q={q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>WebClient</code>和<code>RestTemplate</code>通过内部扩展和编码URI模板<code>UriBuilderFactory</code>战略。两者都可以使用自定义策略进行配置。如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String baseUrl = "https://example.com";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

// Customize the RestTemplate..
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);

// Customize the WebClient..
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val baseUrl = "https://example.com"
val factory = DefaultUriBuilderFactory(baseUrl).apply {
    encodingMode = EncodingMode.TEMPLATE_AND_VALUES
}

// Customize the RestTemplate..
val restTemplate = RestTemplate().apply {
    uriTemplateHandler = factory
}

// Customize the WebClient..
val client = WebClient.builder().uriBuilderFactory(factory).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>DefaultUriBuilderFactory</code>实施用途<code>UriComponentsBuilder</code>在内部扩展和编码URI模板。作为工厂，它提供了一个位置，可以根据以下一种编码模式来配置编码方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code> ：用途<code>UriComponentsBuilder#encode()</code> ，对应于较早列表中的第一个选项，以对URI模板进行预编码，并在扩展时严格编码URI变量。</p>
</li>
<li>
<p><code>VALUES_ONLY</code> ：不对URI模板进行编码，而是通过以下方式对URI变量进行严格编码<code>UriUtils#encodeUriUriVariables</code>在将它们扩展到模板之前。</p>
</li>
<li>
<p><code>URI_COMPONENTS</code> ：用途<code>UriComponents#encode()</code> ，与先前列表中的第二个选项相对应，以在扩展URI变量<em>后</em>对URI组件值进行编码。</p>
</li>
<li>
<p><code>NONE</code> ：未应用编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>RestTemplate</code>被设定为<code>EncodingMode.URI_COMPONENTS</code>由于历史原因和向后兼容性。的<code>WebClient</code>依赖于中的默认值<code>DefaultUriBuilderFactory</code> ，从更改为<code>EncodingMode.URI_COMPONENTS</code>在5.0.x中<code>EncodingMode.TEMPLATE_AND_VALUES</code>在5.1中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a> 1.7。CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux使您可以处理CORS（跨源资源共享）。本节介绍如何执行此操作。</p>
</div>
<div class="sect3">
<h4 id="webflux-cors-intro"><a class="anchor" href="#webflux-cors-intro"></a> 1.7.1。介绍</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-intro">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>出于安全原因，浏览器禁止AJAX调用当前来源以外的资源。例如，您可以将您的银行帐户放在一个标签中，将evil.com放在另一个标签中。来自evil.com的脚本不能使用您的凭据向您的银行API发出AJAX请求，例如，从您的帐户中提取资金！</p>
</div>
<div class="paragraph">
<p>跨域资源共享（CORS）是<a href="https://caniuse.com/#feat=cors">大多数浏览器</a>实现的<a href="https://www.w3.org/TR/cors/">W3C规范</a> ，可让您指定授权哪种类型的跨域请求，而不是使用基于IFRAME或JSONP的安全性较低且功能较弱的变通办法。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-processing"><a class="anchor" href="#webflux-cors-processing"></a> 1.7.2。处理中</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-processing">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>CORS规范区分飞行前，简单和实际请求。要了解CORS的工作原理，您可以阅读<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>以及其他内容，或者参阅规范以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>春季WebFlux <code>HandlerMapping</code>实现提供对CORS的内置支持。成功将请求映射到处理程序后， <code>HandlerMapping</code>检查给定请求和处理程序的CORS配置，并采取进一步的措施。飞行前请求直接处理，而简单和实际的CORS请求被拦截，验证并设置了所需的CORS响应标头。</p>
</div>
<div class="paragraph">
<p>为了启用跨域请求（即<code>Origin</code>标头存在并且与请求的主机不同），您需要具有一些显式声明的CORS配置。如果找不到匹配的CORS配置，则预检请求将被拒绝。没有将CORS标头添加到简单和实际CORS请求的响应中，因此，浏览器拒绝了它们。</p>
</div>
<div class="paragraph">
<p>每<code>HandlerMapping</code>可以使用基于URL模式的单独<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a> <code>CorsConfiguration</code>映射。在大多数情况下，应用程序使用WebFlux Java配置声明此类映射，从而导致将单个全局映射传递给所有<code>HadlerMappping</code>实现。</p>
</div>
<div class="paragraph">
<p>您可以在以下位置组合全局CORS配置： <code>HandlerMapping</code>级别，以及更细粒度的处理程序级别的CORS配置。例如，带注释的控制器可以使用类或方法级别<code>@CrossOrigin</code>注释（其他处理程序可以实现<code>CorsConfigurationSource</code> ）。</p>
</div>
<div class="paragraph">
<p>组合全局和本地配置的规则通常是相加的，例如，所有全局和所有本地来源。对于只能接受单个值的属性，例如<code>allowCredentials</code>和<code>maxAge</code> ，则本地值会覆盖全局值。看到<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a>更多细节。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要从源中了解更多信息或进行高级自定义，请参阅：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code>和<code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-controller"><a class="anchor" href="#webflux-cors-controller"></a> 1.7.3。<code>@CrossOrigin</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-controller">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>注释启用带注释的控制器方法上的跨域请求，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono&lt;Void&gt; remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
@RequestMapping("/account")
class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    suspend fun retrieve(@PathVariable id: Long): Account {
        // ...
    }

    @DeleteMapping("/{id}")
    suspend fun remove(@PathVariable id: Long) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>@CrossOrigin</code>允许：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p>控制器方法映射到的所有HTTP方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowedCredentials</code>默认情况下未启用），因为它建立了一个信任级别，该级别公开了敏感的用户特定信息（例如cookie和CSRF令牌），并且仅在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code>在类级别也受支持，并且由所有方法继承。以下示例指定了某个域并进行了设置<code>maxAge</code>到一个小时：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @GetMapping("/{id}")
    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono&lt;Void&gt; remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@CrossOrigin("https://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
class AccountController {

    @GetMapping("/{id}")
    suspend fun retrieve(@PathVariable id: Long): Account {
        // ...
    }

    @DeleteMapping("/{id}")
    suspend fun remove(@PathVariable id: Long) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@CrossOrigin</code>在类和方法级别上，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CrossOrigin(maxAge = 3600) <i class="conum" data-value="1"></i><b>(1)</b>
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin("https://domain2.com") <i class="conum" data-value="2"></i><b>(2)</b>
    @GetMapping("/{id}")
    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono&lt;Void&gt; remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@CrossOrigin</code>在课堂上。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>@CrossOrigin</code>在方法级别。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@CrossOrigin(maxAge = 3600) <i class="conum" data-value="1"></i><b>(1)</b>
@RestController
@RequestMapping("/account")
class AccountController {

    @CrossOrigin("https://domain2.com") <i class="conum" data-value="2"></i><b>(2)</b>
    @GetMapping("/{id}")
    suspend fun retrieve(@PathVariable id: Long): Account {
        // ...
    }

    @DeleteMapping("/{id}")
    suspend fun remove(@PathVariable id: Long) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@CrossOrigin</code>在课堂上。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>@CrossOrigin</code>在方法级别。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-global"><a class="anchor" href="#webflux-cors-global"></a> 1.7.4。全局配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-global">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>除了细粒度的控制器方法级配置之外，您可能还想定义一些全局CORS配置。您可以设置基于URL <code>CorsConfiguration</code>分别映射到任何<code>HandlerMapping</code> 。但是，大多数应用程序都使用WebFlux Java配置来执行此操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，全局配置启用以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p><code>GET</code> ， <code>HEAD</code>和<code>POST</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowedCredentials</code>默认情况下不会启用，因为这会建立一个信任级别，该级别公开敏感的用户特定信息（例如cookie和CSRF令牌），并且仅在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="paragraph">
<p>要在WebFlux Java配置中启用CORS，您可以使用<code>CorsRegistry</code>回调，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {

        registry.addMapping("/api/**")
            .allowedOrigins("https://domain2.com")
            .allowedMethods("PUT", "DELETE")
            .allowedHeaders("header1", "header2", "header3")
            .exposedHeaders("header1", "header2")
            .allowCredentials(true).maxAge(3600);

        // Add more mappings...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun addCorsMappings(registry: CorsRegistry) {

        registry.addMapping("/api/**")
                .allowedOrigins("https://domain2.com")
                .allowedMethods("PUT", "DELETE")
                .allowedHeaders("header1", "header2", "header3")
                .exposedHeaders("header1", "header2")
                .allowCredentials(true).maxAge(3600)

        // Add more mappings...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-webfilter"><a class="anchor" href="#webflux-cors-webfilter"></a> 1.7.5。CORS<code>WebFilter</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-cors-filter">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过内置的方式应用CORS支持<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html"><code>CorsWebFilter</code></a> ，非常适合<a href="#webflux-fn">功能性端点</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您尝试使用<code>CorsFilter</code>使用Spring Security时，请记住Spring Security <a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">内置了</a>对CORS的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">支持</a> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要配置过滤器，您可以声明一个<code>CorsWebFilter</code>豆并通过<code>CorsConfigurationSource</code>到其构造函数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
CorsWebFilter corsFilter() {

    CorsConfiguration config = new CorsConfiguration();

    // Possibly...
    // config.applyPermitDefaultValues()

    config.setAllowCredentials(true);
    config.addAllowedOrigin("https://domain1.com");
    config.addAllowedHeader("*");
    config.addAllowedMethod("*");

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);

    return new CorsWebFilter(source);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun corsFilter(): CorsWebFilter {

    val config = CorsConfiguration()

    // Possibly...
    // config.applyPermitDefaultValues()

    config.allowCredentials = true
    config.addAllowedOrigin("https://domain1.com")
    config.addAllowedHeader("*")
    config.addAllowedMethod("*")

    val source = UrlBasedCorsConfigurationSource().apply {
        registerCorsConfiguration("/**", config)
    }
    return CorsWebFilter(source)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-web-security"><a class="anchor" href="#webflux-web-security"></a> 1.8。网络安全</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-web-security">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://projects.spring.io/spring-security/">Spring Security</a>项目提供了保护Web应用程序免受恶意利用的支持。请参阅Spring Security参考文档，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#jc-webflux">WebFlux安全</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-webflux">WebFlux测试支持</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF保护</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">安全响应标题</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-view"><a class="anchor" href="#webflux-view"></a> 1.9。查看技术</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中视图技术的使用是可插入的。是否决定使用Thymeleaf，FreeMarker或其他某种视图技术，主要取决于配置更改。本章介绍与Spring WebFlux集成的视图技术。我们假设您已经熟悉<a href="#webflux-viewresolution">View Resolution</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-view-thymeleaf"><a class="anchor" href="#webflux-view-thymeleaf"></a> 1.9.1。胸腺</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-thymeleaf">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf是一种现代的服务器端Java模板引擎，它强调可以通过双击在浏览器中预览的自然HTML模板，这对于独立处理UI模板（例如，由设计人员）而无需进行非常有用的操作正在运行的服务器。Thymeleaf提供了广泛的功能集，并且正在积极地开发和维护。有关更完整的介绍，请参见<a href="https://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
</div>
<div class="paragraph">
<p>Thymeleaf与Spring WebFlux的集成由Thymeleaf项目管理。该配置涉及一些bean声明，例如<code>SpringResourceTemplateResolver</code> ， <code>SpringWebFluxTemplateEngine</code>和<code>ThymeleafReactiveViewResolver</code> 。有关更多详细信息，请参见<a href="https://www.thymeleaf.org/documentation.html">Thymeleaf + Spring</a>和WebFlux集成<a href="http://forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html">公告</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-freemarker"><a class="anchor" href="#webflux-view-freemarker"></a> 1.9.2。FreeMarker</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://freemarker.apache.org/">Apache FreeMarker</a>是一个模板引擎，用于生成从HTML到电子邮件等的任何类型的文本输出。Spring Framework 具有内置的集成，可以将Spring WebFlux与FreeMarker模板一起使用。</p>
</div>
<div class="sect4">
<h5 id="webflux-view-freemarker-contextconfig"><a class="anchor" href="#webflux-view-freemarker-contextconfig"></a>查看配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker-contextconfig">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何将FreeMarker配置为一种视图技术：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    // Configure FreeMarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates/freemarker");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.freeMarker()
    }

    // Configure FreeMarker...

    @Bean
    fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
        setTemplateLoaderPath("classpath:/templates/freemarker")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的模板需要存储在由<code>FreeMarkerConfigurer</code> ，如上例所示。根据上述配置，如果您的控制器返回了视图名称， <code>welcome</code> ，解析器会寻找<code>classpath:/templates/freemarker/welcome.ftl</code>模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-views-freemarker"><a class="anchor" href="#webflux-views-freemarker"></a> FreeMarker配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-views-freemarker">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以将FreeMarker的“设置”和“ SharedVariables”直接传递给FreeMarker <code>Configuration</code>对象（由Spring管理），方法是在<code>FreeMarkerConfigurer</code>豆。的<code>freemarkerSettings</code>财产需要<code>java.util.Properties</code>对象，以及<code>freemarkerVariables</code>财产需要<code>java.util.Map</code> 。以下示例显示了如何使用<code>FreeMarkerConfigurer</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    // ...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;();
        variables.put("xml_escape", new XmlEscape());

        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        configurer.setFreemarkerVariables(variables);
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    // ...

    @Bean
    fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
        setTemplateLoaderPath("classpath:/templates")
        setFreemarkerVariables(mapOf("xml_escape" to XmlEscape()))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅FreeMarker文档，以获取适用于设置和变量的详细信息。 <code>Configuration</code>宾语。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-view-freemarker-forms"><a class="anchor" href="#webflux-view-freemarker-forms"></a>表格处理</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-freemarker-forms">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring提供了一个供JSP使用的标签库，其中包含一个<code><spring:bind/></code>元件。该元素主要允许表单显示来自表单支持对象的值，并显示来自表单验证失败的结果。 <code>Validator</code>在网络或业务层。Spring还支持FreeMarker中的相同功能，并带有用于生成表单输入元素本身的附加便利宏。</p>
</div>
<div class="sect5">
<h6 id="webflux-view-bind-macros"><a class="anchor" href="#webflux-view-bind-macros"></a>绑定宏</h6>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-bind-macros">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>标准宏集在<code>spring-webflux.jar</code> FreeMarker的文件，因此它们始终可用于经过适当配置的应用程序。</p>
</div>
<div class="paragraph">
<p>Spring模板库中定义的一些宏被视为内部（私有）宏，但是在宏定义中不存在这种范围，使所有宏对调用代码和用户模板可见。以下各节仅关注您需要在模板中直接调用的宏。如果您想直接查看宏代码，则调用该文件<code>spring.ftl</code>并且在<code>org.springframework.web.reactive.result.view.freemarker</code>包。</p>
</div>
<div class="paragraph">
<p>有关绑定支持的更多详细信息，请参见Spring MVC的<a href="web.html#mvc-view-simple-binding">简单绑定</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-views-form-macros"><a class="anchor" href="#webflux-views-form-macros"></a>表格巨集</h6>
<div class="paragraph">
<p>有关Spring对FreeMarker模板的表单宏支持的详细信息，请查阅Spring MVC文档的以下部分。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="web.html#mvc-views-form-macros">输入宏</a></p>
</li>
<li>
<p><a href="web.html#mvc-views-form-macros-input">输入栏位</a></p>
</li>
<li>
<p><a href="web.html#mvc-views-form-macros-select">选择字段</a></p>
</li>
<li>
<p><a href="web.html#mvc-views-form-macros-html-escaping">HTML转义</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-script"><a class="anchor" href="#webflux-view-script"></a> 1.9.3。脚本视图</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework 具有内置的集成，可以将Spring WebFlux与可以在<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java脚本引擎之上运行的任何模板库一起使用。下表显示了我们在不同脚本引擎上测试过的模板库：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">脚本库</th>
<th class="tableblock halign-left valign-top">脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://handlebarsjs.com/">车把</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">胡子</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://facebook.github.io/react/">反应</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.stuartellis.name/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.jruby.org">红宝石</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">字符串模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.jython.org/">吉顿</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin脚本模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://kotlinlang.org/">Kotlin</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">集成任何其他脚本引擎的基本规则是，它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="webflux-view-script-dependencies"><a class="anchor" href="#webflux-view-script-dependencies"></a>要求</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script-dependencies">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您需要在类路径上具有脚本引擎，其细节因脚本引擎而异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 8+随附了<a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript引擎。强烈建议使用可用的最新更新版本。</p>
</li>
<li>
<p>应该将<a href="https://www.jruby.org">JRuby</a>添加为对Ruby支持的依赖。</p>
</li>
<li>
<p>应该将<a href="https://www.jython.org">Jython</a>添加为对Python支持的依赖项。</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code>依赖和<code>META-INF/services/javax.script.ScriptEngineFactory</code>包含<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>行应添加以支持Kotlin脚本。有关更多详细信息，请参<a href="https://github.com/sdeleuze/kotlin-script-templating">见此示例</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要具有脚本模板库。针对Javascript的一种方法是通过<a href="https://www.webjars.org/">WebJars</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-view-script-integrate"><a class="anchor" href="#webflux-view-script-integrate"></a>脚本模板</h5>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-script-integrate">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以声明一个<code>ScriptTemplateConfigurer</code> bean来指定要使用的脚本引擎，要加载的脚本文件，调用呈现模板所需的函数等等。以下示例使用Mustache模板和Nashorn JavaScript引擎：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("mustache.js");
        configurer.setRenderObject("Mustache");
        configurer.setRenderFunction("render");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.scriptTemplate()
    }

    @Bean
    fun configurer() = ScriptTemplateConfigurer().apply {
        engineName = "nashorn"
        setScripts("mustache.js")
        renderObject = "Mustache"
        renderFunction = "render"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>render</code>使用以下参数调用该函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code> ：模板内容</p>
</li>
<li>
<p><code>Map model</code> ：视图模型</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code> ： <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a>允许访问应用程序上下文，语言环境，模板加载器和URL（自5.0起）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code>与该签名本地兼容，因此您可以直接调用它。</p>
</div>
<div class="paragraph">
<p>如果您的模板技术需要一些自定义，则可以提供一个实现自定义渲染功能的脚本。例如， <a href="https://handlebarsjs.com">Handlerbars</a>需要使用它们之前编译模板和需要<a href="https://en.wikipedia.org/wiki/Polyfill">填充工具</a>以模拟在服务器端脚本引擎无法使用浏览器的一些设施。下面的示例演示如何设置自定义渲染功能：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");
        configurer.setRenderFunction("render");
        configurer.setSharedEngine(false);
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.scriptTemplate()
    }

    @Bean
    fun configurer() = ScriptTemplateConfigurer().apply {
        engineName = "nashorn"
        setScripts("polyfill.js", "handlebars.js", "render.js")
        renderFunction = "render"
        isSharedEngine = false
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置<code>sharedEngine</code>财产<code>false</code>当使用非线程安全的脚本引擎和不是为并发设计的模板库时，例如在Nashorn上运行的Handlebars或React，则需要使用。在这种情况下，由于<a href="https://bugs.openjdk.java.net/browse/JDK-8076099">此bug</a> ，需要Java SE 8 update 60，但通常建议在任何情况下都使用最新的Java SE修补程序版本。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code>仅定义<code>window</code> Handlebars正常运行所需的对象，如以下代码片段所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var window = {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个基本<code>render.js</code>实现在使用模板之前先对其进行编译。生产就绪的实现还应该存储和重用缓存的模板或预编译的模板。这可以在脚本端以及您需要的任何自定义（例如，管理模板引擎配置）上完成。以下示例显示了如何编译模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">function render(template, model) {
    var compiledTemplate = Handlebars.compile(template);
    return compiledTemplate(model);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看Spring Framework单元测试， <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script">Java</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script">资源</a> ，以获取更多配置示例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-httpmessagewriter"><a class="anchor" href="#webflux-view-httpmessagewriter"></a> 1.9.4。JSON和XML</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-view-jackson">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>出于<a href="#webflux-multiple-representations">内容协商的</a>目的，根据客户端请求的内容类型，能够在使用HTML模板呈现模型或以其他格式（例如JSON或XML）呈现模型之间进行切换非常有用。为此，Spring WebFlux提供了<code>HttpMessageWriterView</code> ，您可以使用该插件从中插入任何可用的<a href="#webflux-codecs">编解码器</a> <code>spring-web</code> ， 如<code>Jackson2JsonEncoder</code> ， <code>Jackson2SmileEncoder</code> ， 要么<code>Jaxb2XmlEncoder</code> 。</p>
</div>
<div class="paragraph">
<p>与其他视图技术不同， <code>HttpMessageWriterView</code>不需要<code>ViewResolver</code>但<a href="#webflux-config-view-resolvers">配置</a>为默认视图。您可以配置一个或多个此类默认视图，并包装不同的视图<code>HttpMessageWriter</code>实例或<code>Encoder</code>实例。在运行时使用与请求的内容类型匹配的内容。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，模型包含多个属性。要确定要序列化的序列号，可以配置<code>HttpMessageWriterView</code>带有用于渲染的模型属性的名称。如果模型仅包含一个属性，则使用该属性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-caching"><a class="anchor" href="#webflux-caching"></a> 1.10。HTTP缓存</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕<code>Cache-Control</code>响应标头和后续条件请求标头，例如<code>Last-Modified</code>和<code>ETag</code> 。 <code>Cache-Control</code>建议私有（例如，浏览器）和公共（例如，代理）缓存如何缓存和重用响应。一个<code>ETag</code>标头用于发出条件请求，如果内容未更改，则可能导致没有主体的304（NOT_MODIFIED）。 <code>ETag</code>可以看成是<code>Last-Modified</code>标头。</p>
</div>
<div class="paragraph">
<p>本节介绍了Spring WebFlux中与HTTP缓存相关的选项。</p>
</div>
<div class="sect3">
<h4 id="webflux-caching-cachecontrol"><a class="anchor" href="#webflux-caching-cachecontrol"></a> 1.10.1。<code>CacheControl</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-cachecontrol">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>提供配置相关的设置支持<code>Cache-Control</code>标头，并在许多地方被接受为参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-caching-etag-lastmodified">控制器</a></p>
</li>
<li>
<p><a href="#webflux-caching-static-resources">静态资源</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了所有可能的指令<code>Cache-Control</code>响应标头<code>CacheControl</code>类型采用面向用例的方法，重点关注常见方案，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Cache for an hour - "Cache-Control: max-age=3600"
CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

// Prevent caching - "Cache-Control: no-store"
CacheControl ccNoStore = CacheControl.noStore();

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Cache for an hour - "Cache-Control: max-age=3600"
val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

// Prevent caching - "Cache-Control: no-store"
val ccNoStore = CacheControl.noStore()

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-etag-lastmodified"><a class="anchor" href="#webflux-caching-etag-lastmodified"></a> 1.10.2。控制器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-etag-lastmodified">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以添加对HTTP缓存的显式支持。我们建议您这样做，因为<code>lastModified</code>要么<code>ETag</code>必须先计算资源的值，然后才能将其与条件请求标头进行比较。控制器可以添加一个<code>ETag</code>和<code>Cache-Control</code>设置为<code>ResponseEntity</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/book/{id}")
public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) {

    Book book = findBook(id);
    String version = book.getVersion();

    return ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
            .eTag(version) // lastModified is also available
            .body(book);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/book/{id}")
fun showBook(@PathVariable id: Long): ResponseEntity&lt;Book&gt; {

    val book = findBook(id)
    val version = book.getVersion()

    return ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
            .eTag(version) // lastModified is also available
            .body(book)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与条件请求标头的比较表明内容未更改，则前面的示例发送带有空主体的304（NOT_MODIFIED）响应。否则， <code>ETag</code>和<code>Cache-Control</code>标头添加到响应中。</p>
</div>
<div class="paragraph">
<p>您还可以在控制器中针对条件请求标头进行检查，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping
public String myHandleMethod(ServerWebExchange exchange, Model model) {

    long eTag = ... <i class="conum" data-value="1"></i><b>(1)</b>

    if (exchange.checkNotModified(eTag)) {
        return null; <i class="conum" data-value="2"></i><b>(2)</b>
    }

    model.addAttribute(...); <i class="conum" data-value="3"></i><b>(3)</b>
    return "myViewName";
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特定于应用程序的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）。无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>继续进行请求处理。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RequestMapping
fun myHandleMethod(exchange: ServerWebExchange, model: Model): String? {

    val eTag: Long = ... <i class="conum" data-value="1"></i><b>(1)</b>

    if (exchange.checkNotModified(eTag)) {
        return null<i class="conum" data-value="2"></i><b>(2)</b>
    }

    model.addAttribute(...) <i class="conum" data-value="3"></i><b>(3)</b>
    return "myViewName"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特定于应用程序的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）。无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>继续进行请求处理。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用三种变体检查条件请求<code>eTag</code>价值观<code>lastModified</code>值，或两者兼而有之。有条件的<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为304（NOT_MODIFIED）。有条件的<code>POST</code> ， <code>PUT</code>和<code>DELETE</code> ，您可以改为将响应设置为409（PRECONDITION_FAILED）以防止并发修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-static-resources"><a class="anchor" href="#webflux-caching-static-resources"></a> 1.10.3。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-caching-static-resources">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您应该使用<code>Cache-Control</code>和条件响应标头以获得最佳性能。请参阅“配置<a href="#webflux-config-static-resources">静态资源</a> ”部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config"><a class="anchor" href="#webflux-config"></a> 1.11。WebFlux配置</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>WebFlux Java配置声明使用带注释的控制器或功能端点来声明处理请求所必需的组件，并且它提供了用于自定义配置的API。这意味着您不需要了解Java配置创建的基础bean。但是，如果您想了解它们，可以在<code>WebFluxConfigurationSupport</code>或阅读有关它们在<a href="#webflux-special-bean-types">特殊Bean类型中的</a>更多信息。</p>
</div>
<div class="paragraph">
<p>要获得配置API中没有的更高级的自定义设置，您可以通过<a href="#webflux-config-advanced-java">高级配置模式</a>来完全控制<a href="#webflux-config-advanced-java">配置</a> 。</p>
</div>
<div class="sect3">
<h4 id="webflux-config-enable"><a class="anchor" href="#webflux-config-enable"></a> 1.11.1。启用WebFlux配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-enable">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@EnableWebFlux</code> Java配置中的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例注册了许多Spring WebFlux <a href="#mvc-webflux-special-bean-types">基础结构Bean，</a>并适应了类路径上可用的依赖关系-JSON，XML等。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-customize"><a class="anchor" href="#webflux-config-customize"></a> 1.11.2。WebFlux配置API</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-customize">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以实现<code>WebFluxConfigurer</code>界面，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    // Implement configuration methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    // Implement configuration methods...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-conversion"><a class="anchor" href="#webflux-config-conversion"></a> 1.11.3。转换，格式化</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-conversion">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，格式化程序用于<code>Number</code>和<code>Date</code>类型的安装，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code>注释。如果类路径中存在Joda-Time，则还将安装对Joda-Time格式库的完全支持。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何注册自定义格式器和转换器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun addFormatters(registry: FormatterRegistry) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">看到<a href="core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>和<code>FormattingConversionServiceFactoryBean</code>有关何时使用的更多信息<code>FormatterRegistrar</code>实现。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-validation"><a class="anchor" href="#webflux-config-validation"></a> 1.11.4。验证方式</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-validation">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，如果<a href="core.html#validation-beanvalidation-overview">Bean验证</a>存在于类路径中（例如，Hibernate Validator），则<code>LocalValidatorFactoryBean</code>已注册为全局<a href="core.html#validator">验证器</a>以用于<code>@Valid</code>和<code>Validated</code>上<code>@Controller</code>方法参数。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以自定义全局<code>Validator</code>实例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public Validator getValidator(); {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun getValidator(): Validator {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您也可以注册<code>Validator</code>本地实现，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addValidators(new FooValidator());
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class MyController {

    @InitBinder
    protected fun initBinder(binder: WebDataBinder) {
        binder.addValidators(FooValidator())
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您需要<code>LocalValidatorFactoryBean</code>注入某处，创建一个bean并标记为<code>@Primary</code>为了避免与MVC配置中声明的冲突。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-content-negotiation"><a class="anchor" href="#webflux-config-content-negotiation"></a> 1.11.5。内容类型解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-content-negotiation">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以配置Spring WebFlux如何确定所需的媒体类型<code>@Controller</code>请求中的实例。默认情况下，仅<code>Accept</code>标头已选中，但您也可以启用基于查询参数的策略。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义请求的内容类型解析：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureContentTypeResolver(builder: RequestedContentTypeResolverBuilder) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-message-codecs"><a class="anchor" href="#webflux-config-message-codecs"></a> 1.11.6。HTTP消息编解码器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-message-converters">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义如何读取和写入请求和响应正文：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ServerCodecConfigurer</code>提供一组默认的读取器和写入器。您可以使用它来添加更多读取器和写入器，自定义默认读取器或完全替换默认读取器。</p>
</div>
<div class="paragraph">
<p>对于Jackson JSON和XML，请考虑使用<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a> ，它使用以下属性自定义Jackson的默认属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a>被禁用。</p>
</li>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a>被禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在类路径中检测到以下知名模块，它还将自动注册以下知名模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7"><code>jackson-datatype-jdk7</code></a> ：支持Java 7类型，例如<code>java.nio.file.Path</code> 。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda"><code>jackson-datatype-joda</code></a> ：支持Joda-Time类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310"><code>jackson-datatype-jsr310</code></a> ：支持Java 8日期和时间API类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8"><code>jackson-datatype-jdk8</code></a> ：支持其他Java 8类型，例如<code>Optional</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-view-resolvers"><a class="anchor" href="#webflux-config-view-resolvers"></a> 1.11.7。查看解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-view-resolvers">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>下面的示例显示如何配置视图分辨率：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>ViewResolverRegistry</code>具有与Spring Framework集成的视图技术的快捷方式。以下示例使用FreeMarker（这也需要配置基础FreeMarker视图技术）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    // Configure Freemarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.freeMarker()
    }

    // Configure Freemarker...

    @Bean
    fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
        setTemplateLoaderPath("classpath:/templates")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以插入任何<code>ViewResolver</code>实现，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        ViewResolver resolver = ... ;
        registry.viewResolver(resolver);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        val resolver: ViewResolver = ...
        registry.viewResolver(resolver
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要支持<a href="#webflux-multiple-representations">内容协商</a>并通过视图分辨率（除HTML之外）呈现其他格式，您可以基于以下选项配置一个或多个默认视图： <code>HttpMessageWriterView</code>实现，它接受来自的任何可用<a href="#webflux-codecs">编解码器</a> <code>spring-web</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();

        Jackson2JsonEncoder encoder = new Jackson2JsonEncoder();
        registry.defaultViews(new HttpMessageWriterView(encoder));
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {


    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.freeMarker()

        val encoder = Jackson2JsonEncoder()
        registry.defaultViews(HttpMessageWriterView(encoder))
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参见<a href="#webflux-view">View Technologies</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-static-resources"><a class="anchor" href="#webflux-config-static-resources"></a> 1.11.8。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-static-resources">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>此选项提供了一种方便的方法来从以下列表中提供静态资源<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a>的位置。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，给定一个以<code>/resources</code> ，相对路径用于查找和服务相对于<code>/static</code>在类路径上。资源的有效期为一年，以确保最大程度地利用浏览器缓存并减少浏览器发出的HTTP请求。的<code>Last-Modified</code>标头也会被评估，如果存在的话， <code>304</code>状态码被返回。以下列表显示了示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
            .addResourceLocations("/public", "classpath:/static/")
            .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public", "classpath:/static/")
                .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>资源处理程序还支持<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html"><code>ResourceResolver</code></a>实现和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a>实现，可用于创建用于优化资源的工具链。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>VersionResourceResolver</code>基于从内容，固定应用程序版本或其他信息计算出的MD5哈希值的版本化资源URL。一种<code>ContentVersionStrategy</code> （MD5哈希）是一个不错的选择，但有一些明显的例外（例如，与模块加载器一起使用的JavaScript资源）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>VersionResourceResolver</code>在您的Java配置中：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public/")
                .resourceChain(true)
                .addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public/")
                .resourceChain(true)
                .addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>ResourceUrlProvider</code>重写URL并应用完整的解析器和转换器链（例如，插入版本）。WebFlux配置提供了一个<code>ResourceUrlProvider</code>以便可以将其注入他人。</p>
</div>
<div class="paragraph">
<p>与Spring MVC不同，目前，在WebFlux中，由于没有视图技术可以利用解析器和转换器的无阻塞链，因此无法透明地重写静态资源URL。仅提供本地资源时，解决方法是使用<code>ResourceUrlProvider</code>直接（例如，通过自定义元素）并进行阻止。</p>
</div>
<div class="paragraph">
<p>请注意，同时使用<code>EncodedResourceResolver</code> （例如，Gzip，Brotli编码）和<code>VersionedResourceResolver</code> ，它们必须按该顺序注册，以确保始终基于未编码文件可靠地计算基于内容的版本。</p>
</div>
<div class="paragraph">
<p><a href="https://www.webjars.org/documentation">WebJars</a>还通过以下方式支持<code>WebJarsResourceResolver</code>当<code>org.webjars:webjars-locator-core</code>库存在于类路径中。解析程序可以重写URL以包括jar的版本，并且还可以与没有版本的传入URL进行匹配-例如，从<code>/jquery/jquery.min.js</code>至<code>/jquery/1.2.0/jquery.min.js</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-path-matching"><a class="anchor" href="#webflux-config-path-matching"></a> 1.11.9。路径匹配</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-path-matching">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以自定义与路径匹配有关的选项。有关各个选项的详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/config/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc。以下示例显示了如何使用<code>PathMatchConfigurer</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseCaseSensitiveMatch(true)
            .setUseTrailingSlashMatch(false)
            .addPathPrefix("/api",
                    HandlerTypePredicate.forAnnotation(RestController.class));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

    @Override
    fun configurePathMatch(configurer: PathMatchConfigurer) {
        configurer
            .setUseCaseSensitiveMatch(true)
            .setUseTrailingSlashMatch(false)
            .addPathPrefix("/api",
                    HandlerTypePredicate.forAnnotation(RestController::class.java))
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring WebFlux依赖于请求路径的解析表示形式<code>RequestPath</code>用于访问已解码的路径段值，并删除了分号内容（即路径或矩阵变量）。这意味着，与Spring MVC不同，您无需指示是否解码请求路径，也无需指示是否出于路径匹配目的而删除分号内容。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux也不支持后缀模式匹配，这与Spring MVC不同，在Spring MVC中，我们也<a href="web.html#mvc-ann-requestmapping-suffix-pattern-match">建议</a>不要依赖它。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-advanced-java"><a class="anchor" href="#webflux-config-advanced-java"></a> 1.11.10。高级配置模式</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-config-advanced-java">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebFlux</code>进口<code>DelegatingWebFluxConfiguration</code>那：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为WebFlux应用程序提供默认的Spring配置</p>
</li>
<li>
<p>检测并委托给<code>WebFluxConfigurer</code>实现以自定义该配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级模式，您可以删除<code>@EnableWebFlux</code>并直接从<code>DelegatingWebFluxConfiguration</code>而不是执行<code>WebFluxConfigurer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebConfig extends DelegatingWebFluxConfiguration {

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class WebConfig : DelegatingWebFluxConfiguration {

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以保留现有方法<code>WebConfig</code> ，但现在您还可以覆盖基类中的bean声明，并且仍然可以有任意数量的其他声明<code>WebMvcConfigurer</code>类路径上的实现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http2"><a class="anchor" href="#webflux-http2"></a> 1.12。HTTP / 2</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#mvc-http2">与Spring MVC中的相同</a></span></p>
</div>
<div class="paragraph">
<p>需要Servlet 4容器来支持HTTP / 2，并且Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要做任何特定的事情。但是，有一些与服务器配置有关的注意事项。有关更多详细信息，请参见<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP / 2 Wiki页面</a> 。</p>
</div>
<div class="paragraph">
<p>当前，Spring WebFlux不支持Netty的HTTP / 2。还不支持以编程方式将资源推送到客户端。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-client"><a class="anchor" href="#webflux-client"></a> 2。网络客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring WebFlux包括反应式，非阻塞式<code>WebClient</code>用于HTTP请求。客户端具有功能性，流利的API，具有用于声明式组合的反应式类型，请参见“ <a href="#webflux-reactive-libraries">反应式库”</a> 。WebFlux客户端和服务器依靠相同的非阻塞<a href="#webflux-codecs">编解码器</a>对请求和响应内容进行编码和解码。</p>
</div>
<div class="paragraph">
<p>内部地<code>WebClient</code>委托给HTTP客户端库。默认情况下，它使用<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a> ，内置了对Jetty <a href="https://github.com/jetty-project/jetty-reactive-httpclient">反应式HttpClient的</a>支持，其他的可以通过以下方式插入<code>ClientHttpConnector</code> 。</p>
</div>
<div class="sect2">
<h3 id="webflux-client-builder"><a class="anchor" href="#webflux-client-builder"></a> 2.1。组态</h3>
<div class="paragraph">
<p>创建一个最简单的方法<code>WebClient</code>通过静态工厂方法之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WebClient.create()</code></p>
</li>
<li>
<p><code>WebClient.create(String baseUrl)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上方法使用Reactor Netty <code>HttpClient</code>使用默认设置并期望<code>io.projectreactor.netty:reactor-netty</code>在类路径上。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>WebClient.builder()</code>有更多选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>uriBuilderFactory</code> ：定制<code>UriBuilderFactory</code>用作基本URL。</p>
</li>
<li>
<p><code>defaultHeader</code> ：每个请求的标题。</p>
</li>
<li>
<p><code>defaultCookie</code> ：针对每个请求的Cookie。</p>
</li>
<li>
<p><code>defaultRequest</code> ： <code>Consumer</code>自定义每个请求。</p>
</li>
<li>
<p><code>filter</code> ：针对每个请求的客户端过滤器。</p>
</li>
<li>
<p><code>exchangeStrategies</code> ：HTTP消息读取器/写入器定制。</p>
</li>
<li>
<p><code>clientConnector</code> ：HTTP客户端库设置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例配置<a href="#webflux-codecs">HTTP编解码器</a> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExchangeStrategies strategies = ExchangeStrategies.builder()
        .codecs(configurer -&gt; {
            // ...
        })
        .build();

WebClient client = WebClient.builder()
        .exchangeStrategies(strategies)
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val strategies = ExchangeStrategies.builder()
        .codecs {
            // ...
        }
        .build()

val client = WebClient.builder()
        .exchangeStrategies(strategies)
        .build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>建成后， <code>WebClient</code>实例是不可变的。但是，您可以克隆它并构建修改后的副本，而不会影响原始实例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient client1 = WebClient.builder()
        .filter(filterA).filter(filterB).build();

WebClient client2 = client1.mutate()
        .filter(filterC).filter(filterD).build();

// client1 has filterA, filterB

// client2 has filterA, filterB, filterC, filterD</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val client1 = WebClient.builder()
        .filter(filterA).filter(filterB).build()

val client2 = client1.mutate()
        .filter(filterC).filter(filterD).build()

// client1 has filterA, filterB

// client2 has filterA, filterB, filterC, filterD</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-reactor"><a class="anchor" href="#webflux-client-builder-reactor"></a> 2.1.1。反应堆净值</h4>
<div class="paragraph">
<p>要自定义Reactor Netty设置，只需提供一个预先配置的<code>HttpClient</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpClient httpClient = HttpClient.create().secure(sslSpec -&gt; ...);

WebClient webClient = WebClient.builder()
        .clientConnector(new ReactorClientHttpConnector(httpClient))
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val httpClient = HttpClient.create().secure { ... }

val webClient = WebClient.builder()
    .clientConnector(ReactorClientHttpConnector(httpClient))
    .build()</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-resources"><a class="anchor" href="#webflux-client-builder-reactor-resources"></a>资源资源</h5>
<div class="paragraph">
<p>默认， <code>HttpClient</code>参与在全球举办的全球Reactor Netty资源<code>reactor.netty.http.HttpResources</code> ，包括事件循环线程和连接池。这是推荐的模式，因为固定的共享资源是事件循环并发的首选。在这种模式下，全局资源将保持活动状态，直到进程退出。</p>
</div>
<div class="paragraph">
<p>如果服务器为该进程计时，则通常无需显式关闭。但是，如果服务器可以启动或停止进程内（例如，部署为WAR的Spring MVC应用程序），则可以声明类型为Spring托管的bean <code>ReactorResourceFactory</code>与<code>globalResources=true</code> （默认）以确保在Spring时关闭Reactor Netty全局资源<code>ApplicationContext</code>关闭，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ReactorResourceFactory reactorResourceFactory() {
    return new ReactorResourceFactory();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun reactorResourceFactory() = ReactorResourceFactory()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以选择不参与全局Reactor Netty资源。但是，在这种模式下，确保所有Reactor Netty客户端和服务器实例使用共享资源是您的重担，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ReactorResourceFactory resourceFactory() {
    ReactorResourceFactory factory = new ReactorResourceFactory();
    factory.setUseGlobalResources(false); <i class="conum" data-value="1"></i><b>(1)</b>
    return factory;
}

@Bean
public WebClient webClient() {

    Function&lt;HttpClient, HttpClient&gt; mapper = client -&gt; {
        // Further customizations...
    };

    ClientHttpConnector connector =
            new ReactorClientHttpConnector(resourceFactory(), mapper); <i class="conum" data-value="2"></i><b>(2)</b>

    return WebClient.builder().clientConnector(connector).build(); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建独立于全局资源的资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>ReactorClientHttpConnector</code>资源工厂的构造函数。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将连接器插入<code>WebClient.Builder</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun resourceFactory() = ReactorResourceFactory().apply {
    isUseGlobalResources = false <i class="conum" data-value="1"></i><b>(1)</b>
}

@Bean
fun webClient(): WebClient {

    val mapper: (HttpClient) -&gt; HttpClient = {
        // Further customizations...
    }

    val connector = ReactorClientHttpConnector(resourceFactory(), mapper) <i class="conum" data-value="2"></i><b>(2)</b>

    return WebClient.builder().clientConnector(connector).build() <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建独立于全局资源的资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>ReactorClientHttpConnector</code>资源工厂的构造函数。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>将连接器插入<code>WebClient.Builder</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-timeout"><a class="anchor" href="#webflux-client-builder-reactor-timeout"></a>超时时间</h5>
<div class="paragraph">
<p>要配置连接超时：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import io.netty.channel.ChannelOption;

HttpClient httpClient = HttpClient.create()
        .tcpConfiguration(client -&gt;
                client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import io.netty.channel.ChannelOption

val httpClient = HttpClient.create()
        .tcpConfiguration { it.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要配置读取和/或写入超时值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;

HttpClient httpClient = HttpClient.create()
        .tcpConfiguration(client -&gt;
                client.doOnConnected(conn -&gt; conn
                        .addHandlerLast(new ReadTimeoutHandler(10))
                        .addHandlerLast(new WriteTimeoutHandler(10))));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import io.netty.handler.timeout.ReadTimeoutHandler
import io.netty.handler.timeout.WriteTimeoutHandler

val httpClient = HttpClient.create().tcpConfiguration {
    it.doOnConnected { conn -&gt; conn
            .addHandlerLast(ReadTimeoutHandler(10))
            .addHandlerLast(WriteTimeoutHandler(10))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-jetty"><a class="anchor" href="#webflux-client-builder-jetty"></a> 2.1.2。码头</h4>
<div class="paragraph">
<p>以下示例显示了如何自定义Jetty <code>HttpClient</code>设置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpClient httpClient = new HttpClient();
httpClient.setCookieStore(...);
ClientHttpConnector connector = new JettyClientHttpConnector(httpClient);

WebClient webClient = WebClient.builder().clientConnector(connector).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val httpClient = HttpClient()
httpClient.cookieStore = ...
val connector = JettyClientHttpConnector(httpClient)

val webClient = WebClient.builder().clientConnector(connector).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>HttpClient</code>创建自己的资源（ <code>Executor</code> ， <code>ByteBufferPool</code> ， <code>Scheduler</code> ），直到该过程退出或<code>stop()</code>叫做。</p>
</div>
<div class="paragraph">
<p>您可以在Jetty客户端（和服务器）的多个实例之间共享资源，并确保在Spring时关闭资源。 <code>ApplicationContext</code>通过声明类型为Spring的Bean关闭<code>JettyResourceFactory</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public JettyResourceFactory resourceFactory() {
    return new JettyResourceFactory();
}

@Bean
public WebClient webClient() {

    HttpClient httpClient = new HttpClient();
    // Further customizations...

    ClientHttpConnector connector =
            new JettyClientHttpConnector(httpClient, resourceFactory()); <i class="conum" data-value="1"></i><b>(1)</b>

    return WebClient.builder().clientConnector(connector).build(); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>JettyClientHttpConnector</code>资源工厂的构造函数。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将连接器插入<code>WebClient.Builder</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun resourceFactory() = JettyResourceFactory()

@Bean
fun webClient(): WebClient {

    val httpClient = HttpClient()
    // Further customizations...

    val connector = JettyClientHttpConnector(httpClient, resourceFactory()) <i class="conum" data-value="1"></i><b>(1)</b>

    return WebClient.builder().clientConnector(connector).build() <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>JettyClientHttpConnector</code>资源工厂的构造函数。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将连接器插入<code>WebClient.Builder</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-retrieve"><a class="anchor" href="#webflux-client-retrieve"></a> 2.2。<code>retrieve()</code></h3>
<div class="paragraph">
<p>的<code>retrieve()</code>方法是获取响应主体并对其进行解码的最简单方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient client = WebClient.create("https://example.org");

Mono&lt;Person&gt; result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .retrieve()
        .bodyToMono(Person.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val client = WebClient.create("https://example.org")

val result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .retrieve()
        .awaitBody&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以从响应中解码出一个对象流，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Quote&gt; result = client.get()
        .uri("/quotes").accept(MediaType.TEXT_EVENT_STREAM)
        .retrieve()
        .bodyToFlux(Quote.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val result = client.get()
        .uri("/quotes").accept(MediaType.TEXT_EVENT_STREAM)
        .retrieve()
        .bodyToFlow&lt;Quote&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，状态代码为4xx或5xx的响应会导致<code>WebClientResponseException</code>或其特定于HTTP状态的子类之一，例如<code>WebClientResponseException.BadRequest</code> ， <code>WebClientResponseException.NotFound</code> ， 和别的。您也可以使用<code>onStatus</code>定制结果异常的方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .retrieve()
        .onStatus(HttpStatus::is4xxClientError, response -&gt; ...)
        .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)
        .bodyToMono(Person.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .retrieve()
        .onStatus(HttpStatus::is4xxClientError) { ... }
        .onStatus(HttpStatus::is5xxServerError) { ... }
        .awaitBody&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么时候<code>onStatus</code>使用，如果期望响应包含内容，则<code>onStatus</code>回调应该消耗它。否则，内容将自动耗尽以确保释放资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-exchange"><a class="anchor" href="#webflux-client-exchange"></a> 2.3。<code>exchange()</code></h3>
<div class="paragraph">
<p>的<code>exchange()</code>该方法提供了比<code>retrieve</code>方法。以下示例等效于<code>retrieve()</code>而且还提供对<code>ClientResponse</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .exchange()
        .flatMap(response -&gt; response.bodyToMono(Person.class));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .awaitExchange()
        .awaitBody&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此级别，您还可以创建一个完整的<code>ResponseEntity</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .exchange()
        .flatMap(response -&gt; response.toEntity(Person.class));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val result = client.get()
        .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
        .awaitExchange()
        .toEntity&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意（与<code>retrieve()</code> ）， <code>exchange()</code> ，则4xx和5xx响应没有自动错误信号。您必须检查状态码并决定如何进行。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用时<code>exchange()</code> ，即使在发生异常时，也必须确保主体始终被消耗或释放（请参阅<a href="core.html#databuffers-using">使用DataBuffer</a> ）。通常，您可以通过调用<code>bodyTo*</code>要么<code>toEntity*</code>上<code>ClientResponse</code>将主体转换为所需类型的对象，但是您也可以调用<code>releaseBody()</code>丢弃体内的东西而不消耗它，或者<code>toBodilessEntity()</code>以获得状态和标头（而丢弃正文）。</p>
</div>
<div class="paragraph">
<p>最后，有<code>bodyToMono(Void.class)</code> ，仅应在不需要响应内容的情况下使用。如果响应中确实包含内容，则该连接将关闭并且不会放回池中，因为该连接不会处于可重用状态。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-body"><a class="anchor" href="#webflux-client-body"></a> 2.4。请求正文</h3>
<div class="paragraph">
<p>可以从以下任何异步类型对请求主体进行编码： <code>ReactiveAdapterRegistry</code> ， 喜欢<code>Mono</code>或Kotlin协程<code>Deferred</code>如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; personMono = ... ;

Mono&lt;Void&gt; result = client.post()
        .uri("/persons/{id}", id)
        .contentType(MediaType.APPLICATION_JSON)
        .body(personMono, Person.class)
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val personDeferred: Deferred&lt;Person&gt; = ...

client.post()
        .uri("/persons/{id}", id)
        .contentType(MediaType.APPLICATION_JSON)
        .body&lt;Person&gt;(personDeferred)
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以对对象流进行编码，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Person&gt; personFlux = ... ;

Mono&lt;Void&gt; result = client.post()
        .uri("/persons/{id}", id)
        .contentType(MediaType.APPLICATION_STREAM_JSON)
        .body(personFlux, Person.class)
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val people: Flow&lt;Person&gt; = ...

client.post()
        .uri("/persons/{id}", id)
        .contentType(MediaType.APPLICATION_JSON)
        .body(people)
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果您具有实际值，则可以使用<code>bodyValue</code>快捷方式，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Person person = ... ;

Mono&lt;Void&gt; result = client.post()
        .uri("/persons/{id}", id)
        .contentType(MediaType.APPLICATION_JSON)
        .bodyValue(person)
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val person: Person = ...

client.post()
        .uri("/persons/{id}", id)
        .contentType(MediaType.APPLICATION_JSON)
        .bodyValue(person)
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-form"><a class="anchor" href="#webflux-client-body-form"></a> 2.4.1。表格数据</h4>
<div class="paragraph">
<p>要发送表单数据，您可以提供<code>MultiValueMap<String, String></code>作为身体。请注意，内容自动设置为<code>application/x-www-form-urlencoded</code>由<code>FormHttpMessageWriter</code> 。以下示例显示了如何使用<code>MultiValueMap<String, String></code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MultiValueMap&lt;String, String&gt; formData = ... ;

Mono&lt;Void&gt; result = client.post()
        .uri("/path", id)
        .bodyValue(formData)
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val formData: MultiValueMap&lt;String, String&gt; = ...

client.post()
        .uri("/path", id)
        .bodyValue(formData)
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过以下方式在线提供表单数据<code>BodyInserters</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.web.reactive.function.BodyInserters.*;

Mono&lt;Void&gt; result = client.post()
        .uri("/path", id)
        .body(fromFormData("k1", "v1").with("k2", "v2"))
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.reactive.function.BodyInserters.*

client.post()
        .uri("/path", id)
        .body(fromFormData("k1", "v1").with("k2", "v2"))
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-multipart"><a class="anchor" href="#webflux-client-body-multipart"></a> 2.4.2。多部分数据</h4>
<div class="paragraph">
<p>要发送多部分数据，您需要提供一个<code>MultiValueMap<String, ?></code>其值为<code>Object</code>代表零件内容的实例或<code>HttpEntity</code>表示零件内容和标题的实例。 <code>MultipartBodyBuilder</code>提供了方便的API来准备多部分请求。以下示例显示了如何创建<code>MultiValueMap<String, ?></code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MultipartBodyBuilder builder = new MultipartBodyBuilder();
builder.part("fieldPart", "fieldValue");
builder.part("filePart1", new FileSystemResource("...logo.png"));
builder.part("jsonPart", new Person("Jason"));
builder.part("myPart", part); // Part from a server request

MultiValueMap&lt;String, HttpEntity&lt;?&gt;&gt; parts = builder.build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val builder = MultipartBodyBuilder().apply {
    part("fieldPart", "fieldValue")
    part("filePart1", new FileSystemResource("...logo.png"))
    part("jsonPart", new Person("Jason"))
    part("myPart", part) // Part from a server request
}

val parts = builder.build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下，您不必指定<code>Content-Type</code>每个部分。内容类型是根据<code>HttpMessageWriter</code>选择序列化它，或者如果是<code>Resource</code> ，基于文件扩展名。如有必要，您可以明确提供<code>MediaType</code>通过其中一个重载的生成器用于每个零件<code>part</code>方法。</p>
</div>
<div class="paragraph">
<p>一旦<code>MultiValueMap</code>准备好了，将其传递给<code>WebClient</code>通过<code>body</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MultipartBodyBuilder builder = ...;

Mono&lt;Void&gt; result = client.post()
        .uri("/path", id)
        .body(builder.build())
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val builder: MultipartBodyBuilder = ...

client.post()
        .uri("/path", id)
        .body(builder.build())
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>MultiValueMap</code>包含至少一个非<code>String</code>值，它也可以代表常规表单数据（即， <code>application/x-www-form-urlencoded</code> ），则无需设置<code>Content-Type</code>至<code>multipart/form-data</code> 。使用时总是如此<code>MultipartBodyBuilder</code> ，以确保<code>HttpEntity</code>包装纸。</p>
</div>
<div class="paragraph">
<p>作为替代<code>MultipartBodyBuilder</code> ，您还可以通过内置的内联样式提供多部分内容<code>BodyInserters</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.web.reactive.function.BodyInserters.*;

Mono&lt;Void&gt; result = client.post()
        .uri("/path", id)
        .body(fromMultipartData("fieldPart", "value").with("filePart", resource))
        .retrieve()
        .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.reactive.function.BodyInserters.*

client.post()
        .uri("/path", id)
        .body(fromMultipartData("fieldPart", "value").with("filePart", resource))
        .retrieve()
        .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-filter"><a class="anchor" href="#webflux-client-filter"></a> 2.5。客户端过滤器</h3>
<div class="paragraph">
<p>您可以注册客户端过滤器（ <code>ExchangeFilterFunction</code> ）通过<code>WebClient.Builder</code>为了拦截和修改请求，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient client = WebClient.builder()
        .filter((request, next) -&gt; {

            ClientRequest filtered = ClientRequest.from(request)
                    .header("foo", "bar")
                    .build();

            return next.exchange(filtered);
        })
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val client = WebClient.builder()
        .filter { request, next -&gt;

            val filtered = ClientRequest.from(request)
                    .header("foo", "bar")
                    .build()

            next.exchange(filtered)
        }
        .build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以用于跨领域的关注，例如身份验证。以下示例使用过滤器通过静态工厂方法进行基本身份验证：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;

WebClient client = WebClient.builder()
        .filter(basicAuthentication("user", "password"))
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication

val client = WebClient.builder()
        .filter(basicAuthentication("user", "password"))
        .build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>过滤器全局应用于每个请求。要更改特定请求的过滤器行为，您可以将请求属性添加到<code>ClientRequest</code>然后，链中的所有过滤器都可以访问该对象，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient client = WebClient.builder()
        .filter((request, next) -&gt; {
            Optional&lt;Object&gt; usr = request.attribute("myAttribute");
            // ...
        })
        .build();

client.get().uri("https://example.org/")
        .attribute("myAttribute", "...")
        .retrieve()
        .bodyToMono(Void.class);

    }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val client = WebClient.builder()
            .filter { request, _ -&gt;
        val usr = request.attributes()["myAttribute"];
        // ...
    }.build()

    client.get().uri("https://example.org/")
            .attribute("myAttribute", "...")
            .retrieve()
            .awaitBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以复制现有的<code>WebClient</code> ，插入新的过滤器或删除已注册的过滤器。以下示例在索引0处插入一个基本身份验证过滤器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;

WebClient client = webClient.mutate()
        .filters(filterList -&gt; {
            filterList.add(0, basicAuthentication("user", "password"));
        })
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val client = webClient.mutate()
        .filters { it.add(0, basicAuthentication("user", "password")) }
        .build()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-synchronous"><a class="anchor" href="#webflux-client-synchronous"></a> 2.6。同步使用</h3>
<div class="paragraph">
<p><code>WebClient</code>可以通过在末尾进行阻塞来以同步方式使用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Person person = client.get().uri("/person/{id}", i).retrieve()
    .bodyToMono(Person.class)
    .block();

List&lt;Person&gt; persons = client.get().uri("/persons").retrieve()
    .bodyToFlux(Person.class)
    .collectList()
    .block();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val person = runBlocking {
    client.get().uri("/person/{id}", i).retrieve()
            .awaitBody&lt;Person&gt;()
}

val persons = runBlocking {
    client.get().uri("/persons").retrieve()
            .bodyToFlow&lt;Person&gt;()
            .toList()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果需要进行多个调用，则避免单独阻塞每个响应而等待合并的结果会更有效：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; personMono = client.get().uri("/person/{id}", personId)
        .retrieve().bodyToMono(Person.class);

Mono&lt;List&lt;Hobby&gt;&gt; hobbiesMono = client.get().uri("/person/{id}/hobbies", personId)
        .retrieve().bodyToFlux(Hobby.class).collectList();

Map&lt;String, Object&gt; data = Mono.zip(personMono, hobbiesMono, (person, hobbies) -&gt; {
            Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
            map.put("person", person);
            map.put("hobbies", hobbies);
            return map;
        })
        .block();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val data = runBlocking {
        val personDeferred = async {
            client.get().uri("/person/{id}", personId)
                    .retrieve().awaitBody&lt;Person&gt;()
        }

        val hobbiesDeferred = async {
            client.get().uri("/person/{id}/hobbies", personId)
                    .retrieve().bodyToFlow&lt;Hobby&gt;().toList()
        }

        mapOf("person" to personDeferred.await(), "hobbies" to hobbiesDeferred.await())
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上仅是一个示例。还有许多其他模式和运算符可用于构建反应式管道，该管道可进行许多远程调用，可能是嵌套的，相互依赖的，而不会阻塞到最后。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>用<code>Flux</code>要么<code>Mono</code> ，您永远不必阻塞Spring MVC或Spring WebFlux控制器。只需从controller方法返回返回的反应类型。相同的原则适用于Kotlin Coroutines和Spring WebFlux，仅使用暂停功能或返回<code>Flow</code>在您的控制器方法中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-testing"><a class="anchor" href="#webflux-client-testing"></a> 2.7。测试中</h3>
<div class="paragraph">
<p>要测试使用<code>WebClient</code> ，您可以使用模拟Web服务器，例如<a href="https://github.com/square/okhttp#mockwebserver">OkHttp MockWebServer</a> 。要查看其用法示例，请查看<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java"><code>WebClientIntegrationTests</code></a>在Spring Framework测试套件或<a href="https://github.com/square/okhttp/tree/master/samples/static-server"><code>static-server</code></a> OkHttp存储库中的示例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-websocket"><a class="anchor" href="#webflux-websocket"></a> 3。Web套接字</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>参考文档的此部分涵盖对反应式堆栈WebSocket消息传递的支持。</p>
</div>
<div class="sect2">
<h3 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a> 3.1。WebSocket简介</h3>
<div class="paragraph">
<p>WebSocket协议<a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准化方法，可通过单个TCP连接在客户端和服务器之间建立全双工双向通信通道。它是与HTTP不同的TCP协议，但旨在通过端口80和443在HTTP上工作，并允许重复使用现有的防火墙规则。</p>
</div>
<div class="paragraph">
<p>WebSocket交互始于使用HTTP的HTTP请求<code>Upgrade</code>标头，以进行升级，或者在这种情况下，切换到WebSocket协议。以下示例显示了这种交互：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket <i class="conum" data-value="1"></i><b>(1)</b>
Connection: Upgrade <i class="conum" data-value="2"></i><b>(2)</b>
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Upgrade</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>具有WebSocket支持的服务器代替通常的200状态代码，返回的输出类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">HTTP/1.1 101 Switching Protocols <i class="conum" data-value="1"></i><b>(1)</b>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>协议切换</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>握手成功后，HTTP升级请求的基础TCP套接字将保持打开状态，客户端和服务器均可继续发送和接收消息。</p>
</div>
<div class="paragraph">
<p>WebSockets的工作原理的完整介绍超出了本文档的范围。请参阅RFC 6455，HTML5的WebSocket章节或Web上的许多简介和教程中的任何一个。</p>
</div>
<div class="paragraph">
<p>请注意，如果WebSocket服务器在Web服务器（例如nginx）后面运行，则可能需要对其进行配置，以将WebSocket升级请求传递到WebSocket服务器。同样，如果应用程序在云环境中运行，请检查与WebSocket支持相关的云提供商的说明。</p>
</div>
<div class="sect3">
<h4 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a> 3.1.1。HTTP与WebSocket</h4>
<div class="paragraph">
<p>尽管WebSocket被设计为与HTTP兼容并以HTTP请求开头，但重要的是要了解这两个协议导致了截然不同的体系结构和应用程序编程模型。</p>
</div>
<div class="paragraph">
<p>在HTTP和REST中，应用程序被建模为许多URL。为了与应用程序交互，客户端访问那些URL，即请求-响应样式。服务器根据HTTP URL，方法和标头将请求路由到适当的处理程序。</p>
</div>
<div class="paragraph">
<p>相反，在WebSockets中，通常只有一个URL用于初始连接。随后，所有应用程序消息在同一TCP连接上流动。这指向了一个完全不同的异步，事件驱动的消息传递体系结构。</p>
</div>
<div class="paragraph">
<p>WebSocket也是一种低级传输协议，与HTTP不同，它不对消息的内容规定任何语义。这意味着除非客户端和服务器就消息语义达成一致，否则就无法路由或处理消息。</p>
</div>
<div class="paragraph">
<p>WebSocket客户端和服务器可以通过以下方式协商使用更高级别的消息传递协议（例如STOMP）： <code>Sec-WebSocket-Protocol</code> HTTP握手请求上的标头。在这种情况下，他们需要提出自己的约定。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a> 3.1.2。何时使用WebSockets</h4>
<div class="paragraph">
<p>WebSockets可以使网页具有动态性和交互性。但是，在许多情况下，结合使用Ajax和HTTP流或长轮询可以提供一种简单有效的解决方案。</p>
</div>
<div class="paragraph">
<p>例如，新闻，邮件和社交订阅源需要动态更新，但是每几分钟进行一次更新可能是完全可以的。另一方面，协作，游戏和金融应用程序需要更接近实时。</p>
</div>
<div class="paragraph">
<p>仅延迟并不是决定因素。如果消息量相对较少（例如，监视网络故障），则HTTP流或轮询可以提供有效的解决方案。低延迟，高频率和高音量的结合才是使用WebSocket的最佳案例。</p>
</div>
<div class="paragraph">
<p>还要记住，在Internet上，不受控制的代理可能会阻止WebSocket交互，因为它们没有配置为传递给WebSocket。 <code>Upgrade</code>标头或因为它们关闭了看起来很空闲的长期连接。这意味着与面向公众的应用程序相比，将WebSocket用于防火墙内部的应用程序是一个更直接的决定。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-websocket-server"><a class="anchor" href="#webflux-websocket-server"></a> 3.2。WebSocket API</h3>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework 提供了一个WebSocket API，可用于编写处理WebSocket消息的客户端和服务器端应用程序。</p>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handler"><a class="anchor" href="#webflux-websocket-server-handler"></a> 3.2.1。服务器</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handler">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>要创建WebSocket服务器，您可以首先创建一个<code>WebSocketHandler</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.web.reactive.socket.WebSocketHandler;
import org.springframework.web.reactive.socket.WebSocketSession;

public class MyWebSocketHandler implements WebSocketHandler {

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.reactive.socket.WebSocketHandler
import org.springframework.web.reactive.socket.WebSocketSession

class MyWebSocketHandler : WebSocketHandler {

    override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将其映射到URL并添加一个<code>WebSocketHandlerAdapter</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
class WebConfig {

    @Bean
    public HandlerMapping handlerMapping() {
        Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;&gt;();
        map.put("/path", new MyWebSocketHandler());
        int order = -1; // before annotated controllers

        return new SimpleUrlHandlerMapping(map, order);
    }

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class WebConfig {

    @Bean
    fun handlerMapping(): HandlerMapping {
        val map = mapOf("/path" to MyWebSocketHandler())
        val order = -1 // before annotated controllers

        return SimpleUrlHandlerMapping(map, order)
    }

    @Bean
    fun handlerAdapter() =  WebSocketHandlerAdapter()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websockethandler"><a class="anchor" href="#webflux-websockethandler"></a> 3.2.2。<code>WebSocketHandler</code></h4>
<div class="paragraph">
<p>的<code>handle</code>的方法<code>WebSocketHandler</code>需要<code>WebSocketSession</code>并返回<code>Mono<Void></code>指示会话的应用程序处理何时完成。通过两个流处理会话，一个流用于入站消息，一个流用于出站消息。下表描述了两种处理流的方法：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>WebSocketSession</code>方法</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux<WebSocketMessage> receive()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供对入站消息流的访问，并在关闭连接时完成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono<Void> send(Publisher<WebSocketMessage>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取传出消息的来源，编写消息，然后返回<code>Mono<Void></code>当源代码完成并且编写完成时，该操作完成。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>一种<code>WebSocketHandler</code>必须将入站和出站流组成一个统一流，并返回<code>Mono<Void></code>反映了流程的完成。根据应用程序要求，统一流程在以下情况下完成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>入站或出站消息流都已完成。</p>
</li>
<li>
<p>入站流完成（即，连接已关闭），而出站流是无限的。</p>
</li>
<li>
<p>在选定的时间，通过<code>close</code>的方法<code>WebSocketSession</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将入站和出站消息流组合在一起时，无需检查连接是否打开，因为响应式流信号会终止活动。入站流接收完成或错误信号，而出站流接收取消信号。</p>
</div>
<div class="paragraph">
<p>处理程序最基本的实现是处理入站流的实现。以下示例显示了这样的实现：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {
        return session.receive()            <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext(message -&gt; {
                    // ...                  <i class="conum" data-value="2"></i><b>(2)</b>
                })
                .concatMap(message -&gt; {
                    // ...                  <i class="conum" data-value="3"></i><b>(3)</b>
                })
                .then();                    <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>访问入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对每条消息进行处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行使用消息内容的嵌套异步操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>返回一个<code>Mono<Void></code>接收完成后即完成。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleHandler : WebSocketHandler {

    override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {
        return session.receive()            <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext {
                    // ...                  <i class="conum" data-value="2"></i><b>(2)</b>
                }
                .concatMap {
                    // ...                  <i class="conum" data-value="3"></i><b>(3)</b>
                }
                .then()                     <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>访问入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对每条消息进行处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>执行使用消息内容的嵌套异步操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>返回一个<code>Mono<Void></code>接收完成后即完成。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">对于嵌套的异步操作，您可能需要调用<code>message.retain()</code>在使用池化数据缓冲区的基础服务器上（例如Netty）。否则，在您有机会读取数据之前，可能会释放数据缓冲区。有关更多背景信息，请参见<a href="core.html#databuffers">数据缓冲区和编解码器</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下实现将入站和出站流组合在一起：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {

        Flux&lt;WebSocketMessage&gt; output = session.receive()               <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext(message -&gt; {
                    // ...
                })
                .concatMap(message -&gt; {
                    // ...
                })
                .map(value -&gt; session.textMessage("Echo " + value));    <i class="conum" data-value="2"></i><b>(2)</b>

        return session.send(output);                                    <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建出站消息，产生合并流。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>返回一个<code>Mono<Void></code>在我们继续接收时还没有完成。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleHandler : WebSocketHandler {

    override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {

        val output = session.receive()                      <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext {
                    // ...
                }
                .concatMap {
                    // ...
                }
                .map { session.textMessage("Echo $it") }    <i class="conum" data-value="2"></i><b>(2)</b>

        return session.send(output)                         <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建出站消息，产生合并流。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>返回一个<code>Mono<Void></code>在我们继续接收时还没有完成。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>入站和出站流可以独立，并且仅为了完成而加入，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class ExampleHandler implements WebSocketHandler {

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {

        Mono&lt;Void&gt; input = session.receive()                                <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext(message -&gt; {
                    // ...
                })
                .concatMap(message -&gt; {
                    // ...
                })
                .then();

        Flux&lt;String&gt; source = ... ;
        Mono&lt;Void&gt; output = session.send(source.map(session::textMessage)); <i class="conum" data-value="2"></i><b>(2)</b>

        return Mono.zip(input, output).then();                              <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>发送外发消息。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>加入流并返回一个<code>Mono<Void></code>当任何一个流结束时完成。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleHandler : WebSocketHandler {

    override fun handle(session: WebSocketSession): Mono&lt;Void&gt; {

        val input = session.receive()                                   <i class="conum" data-value="1"></i><b>(1)</b>
                .doOnNext {
                    // ...
                }
                .concatMap {
                    // ...
                }
                .then()

        val source: Flux&lt;String&gt; = ...
        val output = session.send(source.map(session::textMessage))     <i class="conum" data-value="2"></i><b>(2)</b>

        return Mono.zip(input, output).then()                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>发送外发消息。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>加入流并返回一个<code>Mono<Void></code>当任何一个流结束时完成。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-databuffer"><a class="anchor" href="#webflux-websocket-databuffer"></a> 3.2.3。<code>DataBuffer</code></h4>
<div class="paragraph">
<p><code>DataBuffer</code>是WebFlux中字节缓冲区的表示形式。参考资料的Spring Core部分在“ <a href="core.html#databuffers">数据缓冲区和编解码器</a> ”部分中有更多介绍。要理解的关键点是，在诸如Netty之类的某些服务器上，字节缓冲被池化并计数引用，并且在使用时必须将其释放以避免内存泄漏。</p>
</div>
<div class="paragraph">
<p>在Netty上运行时，应用程序必须使用<code>DataBufferUtils.retain(dataBuffer)</code>如果他们希望保留输入数据缓冲区以确保不释放它们，并随后使用<code>DataBufferUtils.release(dataBuffer)</code>当缓冲区被消耗时。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-handshake"><a class="anchor" href="#webflux-websocket-server-handshake"></a> 3.2.4。握手</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-handshake">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>WebSocketHandlerAdapter</code>代表参加<code>WebSocketService</code> 。默认情况下，这是<code>HandshakeWebSocketService</code> ，它对WebSocket请求执行基本检查，然后使用<code>RequestUpgradeStrategy</code>适用于使用中的服务器。当前，内置了对Reactor Netty，Tomcat，Jetty和Undertow的支持。</p>
</div>
<div class="paragraph">
<p><code>HandshakeWebSocketService</code>暴露一个<code>sessionAttributePredicate</code>该属性允许设置<code>Predicate<String></code>从中提取属性<code>WebSession</code>并将它们插入到<code>WebSocketSession</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-config"><a class="anchor" href="#webflux-websocket-server-config"></a> 3.2.5。服务器配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-runtime-configuration">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>RequestUpgradeStrategy</code>对于每个服务器，公开了可用于基础WebSocket引擎的WebSocket相关配置选项。以下示例在Tomcat上运行时设置WebSocket选项：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
class WebConfig {

    @Bean
    public WebSocketHandlerAdapter handlerAdapter() {
        return new WebSocketHandlerAdapter(webSocketService());
    }

    @Bean
    public WebSocketService webSocketService() {
        TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(0L);
        return new HandshakeWebSocketService(strategy);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class WebConfig {

    @Bean
    fun handlerAdapter() =
            WebSocketHandlerAdapter(webSocketService())

    @Bean
    fun webSocketService(): WebSocketService {
        val strategy = TomcatRequestUpgradeStrategy().apply {
            setMaxSessionIdleTimeout(0L)
        }
        return HandshakeWebSocketService(strategy)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查服务器的升级策略，以查看可用的选项。当前，只有Tomcat和Jetty公开了此类选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-server-cors"><a class="anchor" href="#webflux-websocket-server-cors"></a> 3.2.6。CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="web.html#websocket-server-allowed-origins">与Servlet堆栈中的相同</a></span></p>
</div>
<div class="paragraph">
<p>配置CORS并限制对WebSocket端点的访问的最简单方法是让您的<code>WebSocketHandler</code>实行<code>CorsConfigurationSource</code>然后返回一个<code>CorsConfiguraiton</code>带有允许的来源，标头和其他详细信息。如果您不能这样做，也可以设置<code>corsConfigurations</code>财产<code>SimpleUrlHandler</code>通过URL模式指定CORS设置。如果同时指定了两者，则使用<code>combine</code>方法开启<code>CorsConfiguration</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-websocket-client"><a class="anchor" href="#webflux-websocket-client"></a> 3.2.7。客户</h4>
<div class="paragraph">
<p>Spring WebFlux提供了一个<code>WebSocketClient</code>对Reactor Netty，Tomcat，Jetty，Undertow和标准Java（即JSR-356）的实现进行抽象。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Tomcat客户端实际上是对标准Java的扩展，在其中具有一些额外的功能。 <code>WebSocketSession</code>处理，以利用特定于Tomcat的API暂停接收消息以产生反压力。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要启动WebSocket会话，您可以创建客户端的实例并使用其实例<code>execute</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebSocketClient client = new ReactorNettyWebSocketClient();

URI url = new URI("ws://localhost:8080/path");
client.execute(url, session -&gt;
        session.receive()
                .doOnNext(System.out::println)
                .then());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val client = ReactorNettyWebSocketClient()

        val url = URI("ws://localhost:8080/path")
        client.execute(url) { session -&gt;
            session.receive()
                    .doOnNext(::println)
            .then()
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些客户（例如Jetty）实现了<code>Lifecycle</code>并且需要先停止然后再启动，然后才能使用它们。所有客户端都具有与基础WebSocket客户端的配置有关的构造器选项。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-test"><a class="anchor" href="#webflux-test"></a> 4。测试中</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web.html#testing">在Spring MVC中相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>spring-test</code>模块提供的模拟实现<code>ServerHttpRequest</code> ， <code>ServerHttpResponse</code>和<code>ServerWebExchange</code> 。有关模拟对象的讨论，请参见<a href="testing.html#mock-objects-web-reactive">Spring Web Reactive</a> 。</p>
</div>
<div class="paragraph">
<p><a href="testing.html#webtestclient"><code>WebTestClient</code></a>以这些模拟请求和响应对象为基础，为不使用HTTP服务器而测试WebFlux应用程序提供支持。您可以使用<code>WebTestClient</code>也用于端到端集成测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket"><a class="anchor" href="#rsocket"></a> 5，插座</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了Spring Framework对RSocket协议的支持。</p>
</div>
<div class="sect2">
<h3 id="rsocket-overview"><a class="anchor" href="#rsocket-overview"></a> 5.1。总览</h3>
<div class="paragraph">
<p>RSocket是一种应用协议，用于使用以下交互模型之一通过TCP，WebSocket和其他字节流传输进行多路复用，双工通信：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Request-Response</code> —发送一封邮件并收到一封邮件。</p>
</li>
<li>
<p><code>Request-Stream</code> —发送一条消息并接收回消息流。</p>
</li>
<li>
<p><code>Channel</code> —双向发送消息流。</p>
</li>
<li>
<p><code>Fire-and-Forget</code> —发送单向消息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一旦建立了初始连接，由于双方变得对称，并且每一方都可以发起上述交互之一，因此“客户端”与“服务器”的区别将消失。这就是为什么在协议中将参与方称为“请求者”和“响应者”，而将上述交互称为“请求流”或简称为“请求”的原因。</p>
</div>
<div class="paragraph">
<p>这些是RSocket协议的主要功能和优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跨网络边界的<a href="https://www.reactive-streams.org/">反应式流</a>语义-用于流式传输请求，例如<code>Request-Stream</code>和<code>Channel</code> ，背压信号在请求者和响应者之间传播，从而允许请求者从源头放慢响应者的速度，从而减少了对网络层拥塞控制的依赖，并减少了在网络级别或任何级别进行缓冲的需要。</p>
</li>
<li>
<p>请求限制-该功能在<code>LEASE</code>可以从两端发送的帧，以限制给定时间内另一端允许的请求总数。租约会定期更新。</p>
</li>
<li>
<p>会话恢复-这是为断开连接而设计的，需要维护一些状态。状态管理对于应用程序是透明的，并且可以与背压结合使用，从而可以在可能的情况下停止生产者并减少所需的状态量。</p>
</li>
<li>
<p>大邮件的碎片化和重组。</p>
</li>
<li>
<p>Keepalive（心跳）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>RSocket具有多种语言的<a href="https://github.com/rsocket">实现</a> 。<a href="https://github.com/rsocket/rsocket-java">Java库</a>基于<a href="https://projectreactor.io/">Project Reactor</a>和<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>进行传输。这意味着来自应用程序中的Reactive Streams Publishers的信号通过RSocket在网络上透明地传播。</p>
</div>
<div class="sect3">
<h4 id="rsocket-protocol"><a class="anchor" href="#rsocket-protocol"></a> 5.1.1。协议书</h4>
<div class="paragraph">
<p>RSocket的优点之一是它在线路上具有定义明确的行为，并且易于阅读的<a href="https://rsocket.io/docs/Protocol">规范</a>以及某些协议<a href="https://github.com/rsocket/rsocket/tree/master/Extensions">扩展</a> 。因此，独立于语言实现和更高级别的框架API，阅读规范是一个好主意。本节提供简要概述，以建立一些上下文。</p>
</div>
<div class="paragraph">
<p><strong>连接中</strong></p>
</div>
<div class="paragraph">
<p>最初，客户端通过一些低级流传输（例如TCP或WebSocket）连接到服务器，并发送<code>SETUP</code>框到服务器以设置连接参数。</p>
</div>
<div class="paragraph">
<p>服务器可能拒绝<code>SETUP</code>帧，但是通常在发送（对于客户端）和接收（对于服务器）之后，双方都可以开始发出请求，除非<code>SETUP</code>表示使用租赁语义来限制请求的数量，在这种情况下，双方都必须等待<code>LEASE</code>从另一端开始构架以允许发出请求。</p>
</div>
<div class="paragraph">
<p><strong>发出请求</strong></p>
</div>
<div class="paragraph">
<p>建立连接后，双方都可以通过其中一个框架发起请求<code>REQUEST_RESPONSE</code> ， <code>REQUEST_STREAM</code> ， <code>REQUEST_CHANNEL</code> ， 要么<code>REQUEST_FNF</code> 。这些帧中的每一个都将一条消息从请求者传送到响应者。</p>
</div>
<div class="paragraph">
<p>然后，响应者可以返回<code>PAYLOAD</code>带有响应消息的框架，对于<code>REQUEST_CHANNEL</code>请求者也可以发送<code>PAYLOAD</code>带有更多请求消息的框架。</p>
</div>
<div class="paragraph">
<p>当请求涉及消息流时，例如<code>Request-Stream</code>和<code>Channel</code> ，响应者必须尊重来自请求者的需求信号。需求表示为许多消息。初始需求在<code>REQUEST_STREAM</code>和<code>REQUEST_CHANNEL</code>框架。后续需求通过发出信号<code>REQUEST_N</code>框架。</p>
</div>
<div class="paragraph">
<p>双方还可以通过<code>METADATA_PUSH</code>框架，与任何单个请求无关，而与整个连接有关。</p>
</div>
<div class="paragraph">
<p><strong>讯息格式</strong></p>
</div>
<div class="paragraph">
<p>RSocket消息包含数据和元数据。元数据可用于发送路由，安全令牌等。数据和元数据的格式可以不同。每种类型的Mime类型都在<code>SETUP</code>框架并应用于给定连接上的所有请求。</p>
</div>
<div class="paragraph">
<p>尽管所有消息都可以具有元数据，但是通常每个请求都包含诸如路由之类的元数据，因此仅应请求包含在第一条消息中，即其中一个帧<code>REQUEST_RESPONSE</code> ， <code>REQUEST_STREAM</code> ， <code>REQUEST_CHANNEL</code> ， 要么<code>REQUEST_FNF</code> 。</p>
</div>
<div class="paragraph">
<p>协议扩展定义了用于应用程序的通用元数据格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a> -多个独立格式化的元数据条目。</p>
</li>
<li>
<p><a href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">路由</a> -请求的路由。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-java"><a class="anchor" href="#rsocket-java"></a> 5.1.2。Java实现</h4>
<div class="paragraph">
<p>RSocket的<a href="https://github.com/rsocket/rsocket-java">Java实现</a>基于<a href="https://projectreactor.io/">Project Reactor</a>构建。TCP和WebSocket的传输基于<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>构建。作为反应流库，Reactor简化了实现协议的工作。对于应用程序，它自然是适合使用的<code>Flux</code>和<code>Mono</code>具有声明式运算符和透明的背压支持。</p>
</div>
<div class="paragraph">
<p>RSocket Java中的API故意是最小且基本的。它专注于协议功能，而将应用程序编程模型（例如RPC代码生成与其他）作为一个更高级别的独立关注点。</p>
</div>
<div class="paragraph">
<p>主合同<a href="https://github.com/rsocket/rsocket-java/blob/master/rsocket-core/src/main/java/io/rsocket/RSocket.java">机票。RSocket</a>使用以下三种模型对四种请求交互类型进行建模<code>Mono</code>代表对一条消息的承诺， <code>Flux</code>一连串的消息，以及<code>io.rsocket.Payload</code>可以访问数据和元数据作为字节缓冲区的实际消息。的<code>RSocket</code>合同是对称使用的。对于请求，该应用程序具有<code>RSocket</code>执行请求。为了响应，该应用程序实现<code>RSocket</code>处理请求。</p>
</div>
<div class="paragraph">
<p>这并不意味着要进行全面介绍。在大多数情况下，Spring应用程序将不必直接使用其API。但是，独立于Spring查看或试验RSocket可能很重要。RSocket Java存储库包含许多<a href="https://github.com/rsocket/rsocket-java/tree/master/rsocket-examples">示例应用程序</a> ，以演示其API和协议功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-spring"><a class="anchor" href="#rsocket-spring"></a> 5.1.3。Spring 支持</h4>
<div class="paragraph">
<p>的<code>spring-messaging</code>模块包含以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rsocket-requester">RSocketRequester</a> —流利的API，可以通过<code>io.rsocket.RSocket</code>以及数据和元数据的编码/解码。</p>
</li>
<li>
<p><a href="#rsocket-annot-responders">带注释的响应者</a> — <code>@MessageMapping</code>带注释的处理程序方法进行响应。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>spring-web</code>模块包含<code>Encoder</code>和<code>Decoder</code> RSocket应用程序可能需要的实现，例如Jackson CBOR / JSON和Protobuf。它还包含<code>PathPatternParser</code>可以插入以进行有效的路由匹配。</p>
</div>
<div class="paragraph">
<p>Spring Boot 2.2支持通过TCP或WebSocket站立RSocket服务器，包括在WebFlux服务器中通过WebSocket公开RSocket的选项。还提供了客户端支持和自动配置<code>RSocketRequester.Builder</code>和<code>RSocketStrategies</code> 。有关更多详细信息，请参见Spring Boot参考中的<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-rsocket">RSocket部分</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Security 5.2提供了RSocket支持。</p>
</div>
<div class="paragraph">
<p>Spring Integration 5.2提供了入站和出站网关以与RSocket客户端和服务器进行交互。有关更多详细信息，请参见《 Spring Integration参考手册》。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway支持RSocket连接。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-requester"><a class="anchor" href="#rsocket-requester"></a> 5.2。RSocketRequester</h3>
<div class="paragraph">
<p><code>RSocketRequester</code>提供流利的API来执行RSocket请求，接受和返回数据和元数据的对象，而不是低级数据缓冲区。它可以对称地用于从客户端发出请求和从服务器发出请求。</p>
</div>
<div class="sect3">
<h4 id="rsocket-requester-client"><a class="anchor" href="#rsocket-requester-client"></a> 5.2.1。客户要求者</h4>
<div class="paragraph">
<p>获得一个<code>RSocketRequester</code>客户端上需要连接到服务器，同时准备并发送初始RSocket <code>SETUP</code>帧。 <code>RSocketRequester</code>为此提供了一个构建器。内部使用RSocket Java <code>RSocketFactory</code> 。</p>
</div>
<div class="paragraph">
<p>这是使用默认设置进行连接的最基本方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
    .connectTcp("localhost", 7000);

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
    .connectWebSocket(URI.create("https://example.org:8080/rsocket"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait
import org.springframework.messaging.rsocket.connectWebSocketAndAwait

val requester = RSocketRequester.builder()
        .connectTcpAndAwait("localhost", 7000)

val requester = RSocketRequester.builder()
        .connectWebSocketAndAwait(URI.create("https://example.org:8080/rsocket"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上是推迟的。实际连接和使用请求者：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Connect asynchronously
RSocketRequester.builder().connectTcp("localhost", 7000)
    .subscribe(requester -&gt; {
        // ...
    });

// Or block
RSocketRequester requester = RSocketRequester.builder()
    .connectTcp("localhost", 7000)
    .block(Duration.ofSeconds(5));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Connect asynchronously
import org.springframework.messaging.rsocket.connectTcpAndAwait

class MyService {

    private var requester: RSocketRequester? = null

    private suspend fun requester() = requester ?:
        RSocketRequester.builder().connectTcpAndAwait("localhost", 7000).also { requester = it }

    suspend fun doSomething() = requester().route(...)
}

// Or block
import org.springframework.messaging.rsocket.connectTcpAndAwait

class MyService {

    private val requester = runBlocking {
        RSocketRequester.builder().connectTcpAndAwait("localhost", 7000)
    }

    suspend fun doSomething() = requester.route(...)
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="rsocket-requester-client-setup"><a class="anchor" href="#rsocket-requester-client-setup"></a>连接设置</h5>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code>提供以下内容以自定义初始<code>SETUP</code>帧：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dataMimeType(MimeType)</code> —设置连接数据的mime类型。</p>
</li>
<li>
<p><code>metadataMimeType(MimeType)</code> —设置连接上元数据的mime类型。</p>
</li>
<li>
<p><code>setupData(Object)</code> —要包含在<code>SETUP</code> 。</p>
</li>
<li>
<p><code>setupRoute(String, Object…​)</code> —路由元数据以包含在<code>SETUP</code> 。</p>
</li>
<li>
<p><code>setupMetadata(Object, MimeType)</code> —要包含在其他元数据中<code>SETUP</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于数据，默认的mime类型是从第一个配置的<code>Decoder</code> 。对于元数据，默认的mime类型是<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a> ，它允许每个请求有多个元数据值和mime类型对。通常，两者都不需要更改。</p>
</div>
<div class="paragraph">
<p>数据和元数据<code>SETUP</code>框架是可选的。在服务器端，@ <a href="#rsocket-annot-connectmapping">ConnectMapping</a>方法可用于处理连接的开始以及连接的内容。 <code>SETUP</code>帧。元数据可用于连接级别的安全性。</p>
</div>
</div>
<div class="sect4">
<h5 id="rsocket-requester-client-strategies"><a class="anchor" href="#rsocket-requester-client-strategies"></a>策略</h5>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code>接受<code>RSocketStrategies</code>配置请求者。您将需要使用它为数据和元数据值的（反）序列化提供编码器和解码器。默认情况下，仅来自<code>spring-core</code>对于<code>String</code> ， <code>byte[]</code>和<code>ByteBuffer</code>已注册。新增中<code>spring-web</code>提供对可以注册的更多内容的访问，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RSocketStrategies strategies = RSocketStrategies.builder()
    .encoders(encoders -&gt; encoders.add(new Jackson2CborEncoder))
    .decoders(decoders -&gt; decoders.add(new Jackson2CborDecoder))
    .build();

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
    .rsocketStrategies(strategies)
    .connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait

val strategies = RSocketStrategies.builder()
        .encoders { it.add(Jackson2CborEncoder()) }
        .decoders { it.add(Jackson2CborDecoder()) }
        .build()

val requester = RSocketRequester.builder()
        .rsocketStrategies(strategies)
        .connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RSocketStrategies</code>设计为可重复使用。在某些情况下，例如同一应用程序中的客户端和服务器，最好在Spring配置中声明它。</p>
</div>
</div>
<div class="sect4">
<h5 id="rsocket-requester-client-responder"><a class="anchor" href="#rsocket-requester-client-responder"></a>客户回应者</h5>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code>可用于将响应者配置为来自服务器的请求。</p>
</div>
<div class="paragraph">
<p>您可以基于服务器上使用的相同基础结构，使用带注释的处理程序进行客户端响应，但是通过编程方式进行了以下注册：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RSocketStrategies strategies = RSocketStrategies.builder()
    .routeMatcher(new PathPatternRouteMatcher())  <i class="conum" data-value="1"></i><b>(1)</b>
    .build();

ClientHandler handler = new ClientHandler(); <i class="conum" data-value="2"></i><b>(2)</b>

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
    .rsocketFactory(RSocketMessageHandler.clientResponder(strategies, handler)) <i class="conum" data-value="3"></i><b>(3)</b>
    .connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>PathPatternRouteMatcher</code>如果<code>spring-web</code>存在，用于有效的路线匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建包含以下内容的响应者<code>@MessageMaping</code>要么<code>@ConnectMapping</code>方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在中使用静态工厂方法<code>RSocketMessageHandler</code>注册一个或多个响应者。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait

val strategies = RSocketStrategies.builder()
        .routeMatcher(PathPatternRouteMatcher())  <i class="conum" data-value="1"></i><b>(1)</b>
        .build()

val handler = ClientHandler() <i class="conum" data-value="2"></i><b>(2)</b>

val requester = RSocketRequester.builder()
        .rsocketFactory(RSocketMessageHandler.clientResponder(strategies, handler)) <i class="conum" data-value="3"></i><b>(3)</b>
        .connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>PathPatternRouteMatcher</code>如果<code>spring-web</code>存在，用于有效的路线匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建包含以下内容的响应者<code>@MessageMaping</code>要么<code>@ConnectMapping</code>方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在中使用静态工厂方法<code>RSocketMessageHandler</code>注册一个或多个响应者。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，以上只是设计用于客户端响应程序的程序化注册的快捷方式。对于替代方案，其中客户端响应者处于Spring配置中，您仍然可以声明<code>RSocketMessageHandler</code>作为Spring bean，然后应用如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
    .rsocketFactory(factory -&gt; factory.acceptor(handler.responder()))
    .connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean
import org.springframework.messaging.rsocket.connectTcpAndAwait

val context: ApplicationContext = ...
val handler = context.getBean&lt;RSocketMessageHandler&gt;()

val requester = RSocketRequester.builder()
        .rsocketFactory { it.acceptor(handler.responder()) }
        .connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于上述情况，您可能还需要使用<code>setHandlerPredicate</code>在<code>RSocketMessageHandler</code>切换到其他检测客户响应者的策略，例如基于自定义注释，例如<code>@RSocketClientResponder</code>与默认<code>@Controller</code> 。在客户端和服务器或同一应用程序中有多个客户端的情况下，这是必需的。</p>
</div>
<div class="paragraph">
<p>有关编程模型的更多信息，请参见带<a href="#rsocket-annot-responders">注释的响应者</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rsocket-requester-client-advanced"><a class="anchor" href="#rsocket-requester-client-advanced"></a>高级</h5>
<div class="paragraph">
<p><code>RSocketRequesterBuilder</code>提供回调以暴露底层<code>ClientRSocketFactory</code>从RSocket Java获得更多关于keepalive间隔，会话恢复，拦截器等的配置选项。您可以按以下方式在该级别上配置选项：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
    .rsocketFactory(factory -&gt; {
        // ...
    })
    .connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait

val requester = RSocketRequester.builder()
        .rsocketFactory {
            //...
        }.connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-requester-server"><a class="anchor" href="#rsocket-requester-server"></a> 5.2.2。服务器请求者</h4>
<div class="paragraph">
<p>从服务器向连接的客户端发出请求是从服务器获取连接客户端的请求者的问题。</p>
</div>
<div class="paragraph">
<p>在带<a href="#rsocket-annot-responders">注释的响应者中</a> ， <code>@ConnectMapping</code>和<code>@MessageMapping</code>方法支持<code>RSocketRequester</code>论点。使用它来访问连接的请求者。请记住<code>@ConnectMapping</code>方法本质上是<code>SETUP</code>请求开始之前必须处理的框架。因此，必须从一开始就将请求与处理分离。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConnectMapping
Mono&lt;Void&gt; handle(RSocketRequester requester) {
    requester.route("status").data("5")
        .retrieveFlux(StatusReport.class)
        .subscribe(bar -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            // ...
        });
    return ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>独立于处理，异步启动请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行处理并完成退货<code>Mono<Void></code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ConnectMapping
suspend fun handle(requester: RSocketRequester) {
    GlobalScope.launch {
        requester.route("status").data("5").retrieveFlow&lt;StatusReport&gt;().collect { <i class="conum" data-value="1"></i><b>(1)</b>
            // ...
        }
    }
    /// ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>独立于处理，异步启动请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在挂起功能中执行处理。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-requester-requests"><a class="anchor" href="#rsocket-requester-requests"></a> 5.2.3。要求</h4>
<div class="paragraph">
<p>有了<a href="#rsocket-requester-client">客户端</a>或<a href="#rsocket-requester-server">服务器</a>请求者后，可以按以下方式发出请求：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ViewBox box = ... ;

Flux&lt;AirportLocation&gt; locations = requester.route("locate.radars.within") <i class="conum" data-value="1"></i><b>(1)</b>
        .data(viewBox) <i class="conum" data-value="2"></i><b>(2)</b>
        .retrieveFlux(AirportLocation.class); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定要包含在请求消息的元数据中的路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>提供请求消息的数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明预期的响应。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val box: ViewBox = ...

val locations = requester.route("locate.radars.within") <i class="conum" data-value="1"></i><b>(1)</b>
        .data(viewBox) <i class="conum" data-value="2"></i><b>(2)</b>
        .retrieveFlow&lt;AirportLocation&gt;() <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定要包含在请求消息的元数据中的路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>提供请求消息的数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明预期的响应。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>交互类型是根据输入和输出的基数隐式确定的。上面的例子是<code>Request-Stream</code>因为发送了一个值并接收了一个值流。在大多数情况下，只要输入和输出的选择与RSocket交互类型以及响应者期望的输入和输出的类型相匹配，就无需考虑这一点。无效组合的唯一示例是多对一。</p>
</div>
<div class="paragraph">
<p>的<code>data(Object)</code>方法也接受任何反应流<code>Publisher</code> ， 包含<code>Flux</code>和<code>Mono</code> ，以及在<code>ReactiveAdapterRegistry</code> 。对于多值<code>Publisher</code>如<code>Flux</code>产生相同类型的值，请考虑使用重载之一<code>data</code>避免进行类型检查的方法<code>Encoder</code>在每个元素上查找：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">data(Object producer, Class&lt;?&gt; elementClass);
data(Object producer, ParameterizedTypeReference&lt;?&gt; elementTypeRef);</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>data(Object)</code>步骤是可选的。跳过不发送数据的请求：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;AirportLocation&gt; location = requester.route("find.radar.EWR"))
    .retrieveMono(AirportLocation.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.retrieveAndAwait

val location = requester.route("find.radar.EWR")
    .retrieveAndAwait&lt;AirportLocation&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a> （默认设置）并且注册的用户支持这些值，则可以添加额外的元数据值<code>Encoder</code> 。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String securityToken = ... ;
ViewBox viewBox = ... ;
MimeType mimeType = MimeType.valueOf("message/x.rsocket.authentication.bearer.v0");

Flux&lt;AirportLocation&gt; locations = requester.route("locate.radars.within")
        .metadata(securityToken, mimeType)
        .data(viewBox)
        .retrieveFlux(AirportLocation.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.retrieveFlow

val requester: RSocketRequester = ...

val securityToken: String = ...
val viewBox: ViewBox = ...
val mimeType = MimeType.valueOf("message/x.rsocket.authentication.bearer.v0")

val locations = requester.route("locate.radars.within")
        .metadata(securityToken, mimeType)
        .data(viewBox)
        .retrieveFlow&lt;AirportLocation&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于<code>Fire-and-Forget</code>使用<code>send()</code>返回的方法<code>Mono<Void></code> 。请注意<code>Mono</code>仅指示消息已成功发送，而不指示已被处理。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-annot-responders"><a class="anchor" href="#rsocket-annot-responders"></a> 5.3。带注释的响应者</h3>
<div class="paragraph">
<p>RSocket响应器可以实现为<code>@MessageMapping</code>和<code>@ConnectMapping</code>方法。
<code>@MessageMapping</code>方法处理单个请求，并且<code>@ConnectMapping</code>方法处理连接级事件（设置和元数据推送）。对称地支持带注释的响应者，用于从服务器端响应和从客户端端响应。</p>
</div>
<div class="sect3">
<h4 id="rsocket-annot-responders-server"><a class="anchor" href="#rsocket-annot-responders-server"></a> 5.3.1。服务器响应者</h4>
<div class="paragraph">
<p>要在服务器端使用带注释的响应者，请添加<code>RSocketMessageHandler</code>到您的Spring配置以检测<code>@Controller</code>豆与<code>@MessageMapping</code>和<code>@ConnectMapping</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
static class ServerConfig {

    @Bean
    public RSocketMessageHandler rsocketMessageHandler() {
        RSocketMessageHandler handler = new RSocketMessageHandler();
        handler.routeMatcher(new PathPatternRouteMatcher());
        return handler;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class ServerConfig {

    @Bean
    fun rsocketMessageHandler() = RSocketMessageHandler().apply {
        routeMatcher = PathPatternRouteMatcher()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后通过Java RSocket API启动RSocket服务器并插入<code>RSocketMessageHandler</code>对于响应者，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

CloseableChannel server =
    RSocketFactory.receive()
        .acceptor(handler.responder())
        .transport(TcpServerTransport.create("localhost", 7000))
        .start()
        .block();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

val context: ApplicationContext = ...
val handler = context.getBean&lt;RSocketMessageHandler&gt;()

val server = RSocketFactory.receive()
        .acceptor(handler.responder())
        .transport(TcpServerTransport.create("localhost", 7000))
        .start().awaitFirst()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RSocketMessageHandler</code>默认情况下支持<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合</a>和<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">路由</a>元数据。如果需要切换到其他mime类型或注册其他元数据mime类型，则可以设置其<a href="#rsocket-metadata-extractor">MetadataExtractor</a> 。</p>
</div>
<div class="paragraph">
<p>您需要设置<code>Encoder</code>和<code>Decoder</code>要支持元数据和数据格式的实例。您可能需要<code>spring-web</code>编解码器实现的模块。</p>
</div>
<div class="paragraph">
<p>默认<code>SimpleRouteMatcher</code>用于通过匹配路线<code>AntPathMatcher</code> 。我们建议插入<code>PathPatternRouteMatcher</code>从<code>spring-web</code>进行有效的路线匹配。RSocket路由可以是分层的，但不是URL路径。两个路由匹配器都配置为使用“。”默认为分隔符，并且没有HTTP网址那样的URL解码。</p>
</div>
<div class="paragraph">
<p><code>RSocketMessageHandler</code>可以通过配置<code>RSocketStrategies</code>如果您需要在同一过程中在客户端和服务器之间共享配置，这可能会很有用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
static class ServerConfig {

    @Bean
    public RSocketMessageHandler rsocketMessageHandler() {
        RSocketMessageHandler handler = new RSocketMessageHandler();
        handler.setRSocketStrategies(rsocketStrategies());
        return handler;
    }

    @Bean
    public RSocketStrategies rsocketStrategies() {
        return RSocketStrategies.builder()
            .encoders(encoders -&gt; encoders.add(new Jackson2CborEncoder))
            .decoders(decoders -&gt; decoders.add(new Jackson2CborDecoder))
            .routeMatcher(new PathPatternRouteMatcher())
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class ServerConfig {

    @Bean
    fun rsocketMessageHandler() = RSocketMessageHandler().apply {
        rSocketStrategies = rsocketStrategies()
    }

    @Bean
    fun rsocketStrategies() = RSocketStrategies.builder()
            .encoders { it.add(Jackson2CborEncoder()) }
            .decoders { it.add(Jackson2CborDecoder()) }
            .routeMatcher(PathPatternRouteMatcher())
            .build()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-annot-responders-client"><a class="anchor" href="#rsocket-annot-responders-client"></a> 5.3.2。客户回应者</h4>
<div class="paragraph">
<p>客户端上的带注释的响应者需要在<code>RSocketRequester.Builder</code> 。有关详细信息，请参阅<a href="#rsocket-requester-client-responder">客户响应者</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-annot-messagemapping"><a class="anchor" href="#rsocket-annot-messagemapping"></a> 5.3.3。@MessageMapping</h4>
<div class="paragraph">
<p><a href="#rsocket-annot-responders-server">服务器</a>或<a href="#rsocket-annot-responders-client">客户端</a>响应程序配置到位后， <code>@MessageMapping</code>方法可以如下使用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class RadarsController {

    @MessageMapping("locate.radars.within")
    public Flux&lt;AirportLocation&gt; radars(MapRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class RadarsController {

    @MessageMapping("locate.radars.within")
    fun radars(request: MapRequest): Flow&lt;AirportLocation&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您无需显式指定RSocket交互类型。只需声明预期的输入和输出以及路由模式。支持基础架构将适应匹配的请求。</p>
</div>
<div class="paragraph">
<p>支持以下附加参数<code>@MessageMapping</code>方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RSocketRequester</code> —与请求关联的连接的请求者，以向远端提出请求。</p>
</li>
<li>
<p><code>@DestinationVariable</code> —模式中变量的值，例如<code>@MessageMapping("find.radar.{id}")</code> 。</p>
</li>
<li>
<p><code>@Header</code> —访问注册用于提取的元数据值，如<a href="#rsocket-metadata-extractor">MetadataExtractor中所述</a> 。</p>
</li>
<li>
<p><code>@Headers Map<String, Object></code> -访问所有注册用于提取的元数据值，如<a href="#rsocket-metadata-extractor">MetadataExtractor中所述</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-annot-connectmapping"><a class="anchor" href="#rsocket-annot-connectmapping"></a> 5.3.4。@ConnectMapping</h4>
<div class="paragraph">
<p><code>@ConnectMapping</code>处理<code>SETUP</code> RSocket连接开始时的第一个框架，以及随后通过<code>METADATA_PUSH</code>框架，即<code>metadataPush(Payload)</code>在<code>io.rsocket.RSocket</code> 。</p>
</div>
<div class="paragraph">
<p><code>@ConnectMapping</code>方法支持与<a href="#rsocket-annot-messagemapping">@MessageMapping</a>相同的参数，但是基于来自<code>SETUP</code>和<code>METADATA_PUSH</code>框架。 <code>@ConnectMapping</code>可以有一个模式来将处理范围缩小到在元数据中具有路由的特定连接，或者如果没有声明任何模式，则所有连接都匹配。</p>
</div>
<div class="paragraph">
<p><code>@ConnectMapping</code>方法不能返回数据，必须用声明<code>void</code>要么<code>Mono<Void></code>作为返回值。如果处理为新连接返回错误，则连接被拒绝。不得阻止处理以向<code>RSocketRequester</code>用于连接。有关详细信息，请参见<a href="#rsocket-requester-server">服务器请求</a>程序。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-metadata-extractor"><a class="anchor" href="#rsocket-metadata-extractor"></a> 5.4。元数据提取器</h3>
<div class="paragraph">
<p>响应者必须解释元数据。
<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a>允许独立格式化的元数据值（例如，用于路由，安全，跟踪），每个元数据值都具有自己的mime类型。应用程序需要一种配置要支持的元数据MIME类型的方法，以及一种访问提取值的方法。</p>
</div>
<div class="paragraph">
<p><code>MetadataExtractor</code>是获取序列化元数据并返回已解码名称/值对的合同，然后可以按名称像标题一样访问该名称/值对，例如，通过<code>@Header</code>在带注释的处理程序方法中。</p>
</div>
<div class="paragraph">
<p><code>DefaultMetadataExtractor</code>可以给<code>Decoder</code>实例以解码元数据。开箱即用，它具有对<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">“ message / x.rsocket.routing.v0”的</a>内置支持，并将其解码为<code>String</code>并保存在“路线”键下。对于其他任何哑剧类型，您需要提供一个<code>Decoder</code>并按如下所示注册mime类型：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);
extractor.metadataToExtract(fooMimeType, Foo.class, "foo");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.metadataToExtract

val extractor = DefaultMetadataExtractor(metadataDecoders)
extractor.metadataToExtract&lt;Foo&gt;(fooMimeType, "foo")</code></pre>
</div>
</div>
<div class="paragraph">
<p>复合元数据很好地结合了独立的元数据值。但是，请求者可能不支持复合元数据，或者可以选择不使用它。为了这， <code>DefaultMetadataExtractor</code>可能需要自定义逻辑才能将解码后的值映射到输出映射。这是将JSON用于元数据的示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);
extractor.metadataToExtract(
    MimeType.valueOf("application/vnd.myapp.metadata+json"),
    new ParameterizedTypeReference&lt;Map&lt;String,String&gt;&gt;() {},
    (jsonMap, outputMap) -&gt; {
        outputMap.putAll(jsonMap);
    });</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.metadataToExtract

val extractor = DefaultMetadataExtractor(metadataDecoders)
extractor.metadataToExtract&lt;Map&lt;String, String&gt;&gt;(MimeType.valueOf("application/vnd.myapp.metadata+json")) { jsonMap, outputMap -&gt;
    outputMap.putAll(jsonMap)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置时<code>MetadataExtractor</code>通过<code>RSocketStrategies</code> ，您可以让<code>RSocketStrategies.Builder</code>使用配置的解码器创建提取器，然后只需使用回调即可自定义注册，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RSocketStrategies strategies = RSocketStrategies.builder()
    .metadataExtractorRegistry(registry -&gt; {
        registry.metadataToExtract(fooMimeType, Foo.class, "foo");
        // ...
    })
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.metadataToExtract

val strategies = RSocketStrategies.builder()
        .metadataExtractorRegistry { registry: MetadataExtractorRegistry -&gt;
            registry.metadataToExtract&lt;Foo&gt;(fooMimeType, "foo")
            // ...
        }
        .build()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-reactive-libraries"><a class="anchor" href="#webflux-reactive-libraries"></a> 6。反应性图书馆</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>spring-webflux</code>依赖于取决于<code>reactor-core</code>并在内部使用它来构成异步逻辑并提供Reactive Streams支持。通常，WebFlux API返回<code>Flux</code>要么<code>Mono</code> （因为它们在内部使用）并且宽容地接受任何响应流<code>Publisher</code>实施作为输入。指某东西的用途<code>Flux</code>与<code>Mono</code>之所以重要，是因为它有助于表达基数，例如，期望单个或多个异步值，并且这对于决策（例如，在编码或解码HTTP消息时）至关重要。</p>
</div>
<div class="paragraph">
<p>对于带注释的控制器，WebFlux透明地适应应用程序选择的反应式库。这是借助<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a> ，它为反应式库和其他异步类型提供可插入的支持。该注册表具有对RxJava和<code>CompletableFuture</code> ，但是您也可以注册其他人。</p>
</div>
<div class="paragraph">
<p>对于功能性API（如<a href="#webflux-fn">功能性端点</a> ， <code>WebClient</code>和其他），则适用WebFlux API的一般规则- <code>Flux</code>和<code>Mono</code>作为返回值和反应流<code>Publisher</code>作为输入。当一个<code>Publisher</code> ，无论是提供自定义还是来自其他反应式库，都只能将其视为具有未知语义（0 ..N）。但是，如果语义是已知的，则可以将其包装为<code>Flux</code>要么<code>Mono.from(Publisher)</code>而不是通过原始<code>Publisher</code> 。</p>
</div>
<div class="paragraph">
<p>例如，给定一个<code>Publisher</code>那不是<code>Mono</code> ，Jackson JSON消息编写器需要多个值。如果媒体类型暗示无限流（例如， <code>application/json+stream</code> ），将分别写入和清除值。否则，值将缓冲到列表中并呈现为JSON数组。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:52 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>