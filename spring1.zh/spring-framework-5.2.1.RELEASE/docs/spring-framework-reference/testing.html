<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>测试中</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



</head><body id="testing" class="book toc2 toc-left" ><div id="header">
<h1>测试中</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#testing-introduction">1。Spring 测试简介</a></li>
<li><a href="#unit-testing">2。单元测试</a>
<ul class="sectlevel2">
<li><a href="#mock-objects">2.1。模拟对象</a>
<ul class="sectlevel3">
<li><a href="#mock-objects-env">2.1.1。环境</a></li>
<li><a href="#mock-objects-jndi">2.1.2。JNDI</a></li>
<li><a href="#mock-objects-servlet">2.1.3。Servlet API</a></li>
<li><a href="#mock-objects-web-reactive">2.1.4。Spring Web反应性</a></li>
</ul>
</li>
<li><a href="#unit-testing-support-classes">2.2。单元测试支持课程</a>
<ul class="sectlevel3">
<li><a href="#unit-testing-utilities">2.2.1。通用测试工具</a></li>
<li><a href="#unit-testing-spring-mvc">2.2.2。Spring MVC测试实用程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#integration-testing">3。整合测试</a>
<ul class="sectlevel2">
<li><a href="#integration-testing-overview">3.1。总览</a></li>
<li><a href="#integration-testing-goals">3.2。集成测试的目标</a>
<ul class="sectlevel3">
<li><a href="#testing-ctx-management">3.2.1。上下文管理和缓存</a></li>
<li><a href="#testing-fixture-di">3.2.2。测试夹具的依赖注入</a></li>
<li><a href="#testing-tx">3.2.3。交易管理</a></li>
<li><a href="#testing-support-classes">3.2.4。集成测试支持类</a></li>
</ul>
</li>
<li><a href="#integration-testing-support-jdbc">3.3。JDBC测试支持</a></li>
<li><a href="#integration-testing-annotations">3.4。注解</a>
<ul class="sectlevel3">
<li><a href="#integration-testing-annotations-spring">3.4.1。Spring 测试注释</a>
<ul class="sectlevel4">
<li><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></li>
<li><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></li>
<li><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></li>
<li><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></li>
<li><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></li>
<li><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></li>
<li><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></li>
<li><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></li>
<li><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></li>
<li><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></li>
<li><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></li>
<li><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></li>
<li><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></li>
<li><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></li>
<li><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-standard">3.4.2。标准注释支持</a></li>
<li><a href="#integration-testing-annotations-junit4">3.4.3。Spring JUnit 4测试注释</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></li>
<li><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></li>
<li><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></li>
<li><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-junit-jupiter">3.4.4。Spring JUnit Jupiter测试注释</a>
<ul class="sectlevel4">
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></li>
<li><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></li>
<li><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></li>
</ul>
</li>
<li><a href="#integration-testing-annotations-meta">3.4.5。测试的元注释支持</a></li>
</ul>
</li>
<li><a href="#testcontext-framework">3.5。Spring TestContext框架</a>
<ul class="sectlevel3">
<li><a href="#testcontext-key-abstractions">3.5.1。关键抽象</a>
<ul class="sectlevel4">
<li><a href="#code-testcontext-code"><code>TestContext</code></a></li>
<li><a href="#code-testcontextmanager-code"><code>TestContextManager</code></a></li>
<li><a href="#code-testexecutionlistener-code"><code>TestExecutionListener</code></a></li>
<li><a href="#context-loaders">上下文加载器</a></li>
</ul>
</li>
<li><a href="#testcontext-bootstrapping">3.5.2。引导TestContext框架</a></li>
<li><a href="#testcontext-tel-config">3.5.3。 <code>TestExecutionListener</code> 组态</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tel-config-registering-tels">注册<code>TestExecutionListener</code>实作</a></li>
<li><a href="#testcontext-tel-config-automatic-discovery">自动发现默认值<code>TestExecutionListener</code>实作</a></li>
<li><a href="#testcontext-tel-config-ordering">定购<code>TestExecutionListener</code>实作</a></li>
<li><a href="#testcontext-tel-config-merging">合并中<code>TestExecutionListener</code>实作</a></li>
</ul>
</li>
<li><a href="#testcontext-test-execution-events">3.5.4。测试执行事件</a>
<ul class="sectlevel4">
<li><a href="#testcontext-test-execution-events-exception-handling">异常处理</a></li>
<li><a href="#testcontext-test-execution-events-async">异步侦听器</a></li>
</ul>
</li>
<li><a href="#testcontext-ctx-management">3.5.5。上下文管理</a>
<ul class="sectlevel4">
<li><a href="#testcontext-ctx-management-xml">使用XML资源进行上下文配置</a></li>
<li><a href="#testcontext-ctx-management-groovy">使用Groovy脚本进行上下文配置</a></li>
<li><a href="#testcontext-ctx-management-javaconfig">使用组件类进行上下文配置</a></li>
<li><a href="#testcontext-ctx-management-mixed-config">混合XML，Groovy脚本和组件类</a></li>
<li><a href="#testcontext-ctx-management-initializers">使用上下文初始化器进行上下文配置</a></li>
<li><a href="#testcontext-ctx-management-inheritance">上下文配置继承</a></li>
<li><a href="#testcontext-ctx-management-env-profiles">使用环境配置文件进行上下文配置</a></li>
<li><a href="#testcontext-ctx-management-property-sources">具有测试属性源的上下文配置</a></li>
<li><a href="#testcontext-ctx-management-web">正在加载<code>WebApplicationContext</code></a></li>
<li><a href="#testcontext-ctx-management-caching">上下文缓存</a></li>
<li><a href="#testcontext-ctx-management-ctx-hierarchies">上下文层次结构</a></li>
</ul>
</li>
<li><a href="#testcontext-fixture-di">3.5.6。测试夹具的依赖注入</a></li>
<li><a href="#testcontext-web-scoped-beans">3.5.7。测试请求和会话范围的Bean</a></li>
<li><a href="#testcontext-tx">3.5.8。交易管理</a>
<ul class="sectlevel4">
<li><a href="#testcontext-tx-test-managed-transactions">测试管理的交易</a></li>
<li><a href="#testcontext-tx-enabling-transactions">启用和禁用事务</a></li>
<li><a href="#testcontext-tx-rollback-and-commit-behavior">事务回滚和提交行为</a></li>
<li><a href="#testcontext-tx-programmatic-tx-mgt">程序化交易管理</a></li>
<li><a href="#testcontext-tx-before-and-after-tx">在事务外运行代码</a></li>
<li><a href="#testcontext-tx-mgr-config">配置事务管理器</a></li>
<li><a href="#testcontext-tx-annotation-demo">演示所有与交易相关的注释</a></li>
</ul>
</li>
<li><a href="#testcontext-executing-sql">3.5.9。执行SQL脚本</a>
<ul class="sectlevel4">
<li><a href="#testcontext-executing-sql-programmatically">以编程方式执行SQL脚本</a></li>
<li><a href="#testcontext-executing-sql-declaratively">使用@Sql声明式执行SQL脚本</a></li>
</ul>
</li>
<li><a href="#testcontext-parallel-test-execution">3.5.10。并行测试执行</a></li>
<li><a href="#testcontext-support-classes">3.5.11。TestContext Framework支持类</a>
<ul class="sectlevel4">
<li><a href="#testcontext-junit4-runner">Spring JUnit 4运行器</a></li>
<li><a href="#testcontext-junit4-rules">Spring JUnit 4规则</a></li>
<li><a href="#testcontext-support-classes-junit4">JUnit 4支持类</a></li>
<li><a href="#testcontext-junit-jupiter-extension">JUnit Jupiter的SpringExtension</a></li>
<li><a href="#testcontext-junit-jupiter-di">依赖注入<code>SpringExtension</code></a></li>
<li><a href="#testcontext-support-classes-testng">TestNG支持类别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring-mvc-test-framework">3.6。Spring MVC测试框架</a>
<ul class="sectlevel3">
<li><a href="#spring-mvc-test-server">3.6.1。服务器端测试</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-static-imports">静态导入</a></li>
<li><a href="#spring-mvc-test-server-setup-options">设置选择</a></li>
<li><a href="#spring-mvc-test-server-setup-steps">设定功能</a></li>
<li><a href="#spring-mvc-test-server-performing-requests">执行请求</a></li>
<li><a href="#spring-mvc-test-server-defining-expectations">定义期望</a></li>
<li><a href="#spring-mvc-test-async-requests">异步请求</a></li>
<li><a href="#spring-mvc-test-vs-streaming-response">流式响应</a></li>
<li><a href="#spring-mvc-test-server-filters">筛选注册</a></li>
<li><a href="#spring-mvc-test-vs-end-to-end-integration-tests">Spring MVC测试与端到端测试</a></li>
<li><a href="#spring-mvc-test-server-resources">进一步的例子</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-server-htmlunit">3.6.2。HtmlUnit集成</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-server-htmlunit-why">为什么要进行HtmlUnit集成？</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc和HtmlUnit</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc和WebDriver</a></li>
<li><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc和Geb</a></li>
</ul>
</li>
<li><a href="#spring-mvc-test-client">3.6.3。客户端REST测试</a>
<ul class="sectlevel4">
<li><a href="#spring-mvc-test-client-static-imports">静态导入</a></li>
<li><a href="#spring-mvc-test-client-resources">客户端REST测试的更多示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webtestclient">3.7。WebTestClient</a>
<ul class="sectlevel3">
<li><a href="#webtestclient-setup">3.7.1。设定</a>
<ul class="sectlevel4">
<li><a href="#webtestclient-controller-config">绑定到控制器</a></li>
<li><a href="#webtestclient-fn-config">绑定到路由器功能</a></li>
<li><a href="#webtestclient-context-config">绑定到<code>ApplicationContext</code></a></li>
<li><a href="#webtestclient-server-config">绑定到服务器</a></li>
<li><a href="#webtestclient-client-config">客户建设者</a></li>
</ul>
</li>
<li><a href="#webtestclient-tests">3.7.2。写作测试</a>
<ul class="sectlevel4">
<li><a href="#webtestclient-no-content">无内容</a></li>
<li><a href="#webtestclient-json">JSON内容</a></li>
<li><a href="#webtestclient-stream">流式响应</a></li>
<li><a href="#webtestclient-request-body">请求正文</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#testing-resources">4。更多资源</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Spring对集成测试的支持以及单元测试的最佳实践。Spring团队提倡测试驱动开发（TDD）。Spring团队发现正确使用控制反转（IoC）确实确实使单元测试和集成测试更加容易（因为在类上存在setter方法和适当的构造函数，使得它们在测试中更容易连接在一起，而不必设置服务定位器注册表和类似结构）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-introduction"><a class="anchor" href="#testing-introduction"></a> 1。Spring 测试简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>测试是企业软件开发的组成部分。本章重点介绍IoC原则对<a href="#unit-testing">单元测试的</a>增值，以及Spring Framework 对<a href="#integration-testing">集成测试</a>的支持所带来的好处。（对企业中测试的彻底处理不在本参考手册的范围之内。）</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unit-testing"><a class="anchor" href="#unit-testing"></a> 2。单元测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与传统的Java EE开发相比，依赖注入应该使您的代码对容器的依赖程度降低。组成应用程序的POJO应该可以在JUnit或TestNG测试中进行测试，并且对象可以通过使用<code>new</code>没有Spring或任何其他容器的运算符。您可以使用<a href="#mock-objects">模拟对象</a> （结合其他有价值的测试技术）来单独测试代码。如果您遵循Spring的体系结构建议，那么代码库的最终分层和组件化将使单元测试更加容易。例如，您可以通过存根或模拟DAO或存储库接口来测试服务层对象，而无需在运行单元测试时访问持久性数据。</p>
</div>
<div class="paragraph">
<p>真正的单元测试通常运行非常快，因为没有可设置的运行时基础架构。将真正的单元测试作为开发方法的一部分可以提高生产率。您可能不需要测试章节的这一部分来帮助您为基于IoC的应用程序编写有效的单元测试。但是，对于某些单元测试方案，Spring Framework 提供了模拟对象和测试支持类，本章对此进行了介绍。</p>
</div>
<div class="sect2">
<h3 id="mock-objects"><a class="anchor" href="#mock-objects"></a> 2.1。模拟对象</h3>
<div class="paragraph">
<p>Spring包含许多专用于模拟的软件包：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mock-objects-env">环境</a></p>
</li>
<li>
<p><a href="#mock-objects-jndi">JNDI</a></p>
</li>
<li>
<p><a href="#mock-objects-servlet">Servlet API</a></p>
</li>
<li>
<p><a href="#mock-objects-web-reactive">Spring Web反应性</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mock-objects-env"><a class="anchor" href="#mock-objects-env"></a> 2.1.1。环境</h4>
<div class="paragraph">
<p>的<code>org.springframework.mock.env</code>程序包包含的模拟实现<code>Environment</code>和<code>PropertySource</code>抽象（请参见<a href="core.html#beans-definition-profiles">Bean定义配置文件</a>和<a href="core.html#beans-property-source-abstraction"><code>PropertySource</code>抽象</a> ）。
<code>MockEnvironment</code>和<code>MockPropertySource</code>对于开发依赖于特定于环境的属性的代码的容器外测试非常有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-jndi"><a class="anchor" href="#mock-objects-jndi"></a> 2.1.2。JNDI</h4>
<div class="paragraph">
<p>的<code>org.springframework.mock.jndi</code>软件包包含JNDI SPI的部分实现，可用于为测试套件或独立应用程序设置简单的JNDI环境。例如，如果是JDBC <code>DataSource</code>实例在测试代码中与在Java EE容器中绑定到相同的JNDI名称相同，因此您可以在测试场景中重用应用程序代码和配置，而无需进行修改。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">JNDI中的模拟支持<code>org.springframework.mock.jndi</code>从Spring Framework 5.2开始，正式弃用该软件包，而推荐使用第三方的完整解决方案，例如<a href="https://github.com/h-thurow/Simple-JNDI">Simple-JNDI</a> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-servlet"><a class="anchor" href="#mock-objects-servlet"></a> 2.1.3。Servlet API</h4>
<div class="paragraph">
<p>的<code>org.springframework.mock.web</code>软件包包含一组全面的Servlet API模拟对象，可用于测试Web上下文，控制器和过滤器。这些模拟对象针对Spring的Web MVC框架使用，并且通常比动态模拟对象（例如<a href="http://easymock.org/">EasyMock</a> ）或其他Servlet API模拟对象（例如<a href="http://www.mockobjects.com">MockObjects</a> ）更方便使用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring Framework 5.0开始， <code>org.springframework.mock.web</code>基于Servlet 4.0 API。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring MVC测试框架建立在模拟Servlet API对象的基础上，为Spring MVC提供了集成测试框架。参见<a href="#spring-mvc-test-framework">Spring MVC测试框架</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mock-objects-web-reactive"><a class="anchor" href="#mock-objects-web-reactive"></a> 2.1.4。Spring Web反应性</h4>
<div class="paragraph">
<p>的<code>org.springframework.mock.http.server.reactive</code>软件包包含的模拟实现<code>ServerHttpRequest</code>和<code>ServerHttpResponse</code>用于WebFlux应用程序。的<code>org.springframework.mock.web.server</code>软件包包含一个模拟<code>ServerWebExchange</code>这取决于那些模拟请求和响应对象。</p>
</div>
<div class="paragraph">
<p>都<code>MockServerHttpRequest</code>和<code>MockServerHttpResponse</code>从与服务器特定的实现相同的抽象基类扩展，并与它们共享行为。例如，模拟请求一旦创建便是不可变的，但是您可以使用<code>mutate()</code>来自的方法<code>ServerHttpRequest</code>创建修改后的实例。</p>
</div>
<div class="paragraph">
<p>为了使模拟响应正确实现写协定并返回写完成句柄（即， <code>Mono<Void></code> ），默认情况下使用<code>Flux</code>与<code>cache().then()</code> ，它缓冲数据并使数据可用于测试中的断言。应用程序可以设置自定义写入功能（例如，测试无限流）。</p>
</div>
<div class="paragraph">
<p><a href="#webtestclient">WebTestClient</a>建立在模拟请求和响应的基础上，以提供对不使用HTTP服务器的WebFlux应用程序测试的支持。客户端还可以用于正在运行的服务器的端到端测试。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unit-testing-support-classes"><a class="anchor" href="#unit-testing-support-classes"></a> 2.2。单元测试支持课程</h3>
<div class="paragraph">
<p>Spring包含许多可以帮助进行单元测试的类。它们分为两类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#unit-testing-utilities">通用测试工具</a></p>
</li>
<li>
<p><a href="#unit-testing-spring-mvc">Spring MVC测试实用程序</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="unit-testing-utilities"><a class="anchor" href="#unit-testing-utilities"></a> 2.2.1。通用测试工具</h4>
<div class="paragraph">
<p>的<code>org.springframework.test.util</code>软件包包含几个通用实用程序，可用于单元和集成测试。</p>
</div>
<div class="paragraph">
<p><code>ReflectionTestUtils</code>是基于反射的实用程序方法的集合。您可以在需要更改常量值，设置非常量值的测试方案中使用这些方法。 <code>public</code>字段，调用非<code>public</code> setter方法，或调用非<code>public</code>测试应用程序代码的用例（例如以下情况）时的配置或生命周期回调方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>纵容的ORM框架（例如JPA和Hibernate） <code>private</code>要么<code>protected</code>实地访问而不是<code>public</code>域实体中属性的设置方法。</p>
</li>
<li>
<p>Spring对注解的支持（例如<code>@Autowired</code> ， <code>@Inject</code>和<code>@Resource</code> ），为<code>private</code>要么<code>protected</code>字段，setter方法和配置方法。</p>
</li>
<li>
<p>使用注释，例如<code>@PostConstruct</code>和<code>@PreDestroy</code>用于生命周期回调方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/util/AopTestUtils.html"><code>AopTestUtils</code></a>是与AOP相关的实用程序方法的集合。您可以使用这些方法来获取对隐藏在一个或多个Spring代理后面的基础目标对象的引用。例如，如果您已通过使用诸如EasyMock或Mockito之类的库将bean配置为动态模拟，并且该模拟包装在Spring代理中，则可能需要直接访问基础模拟以配置对它的期望并执行验证。有关Spring的核心AOP实用程序，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/support/AopUtils.html"><code>AopUtils</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html"><code>AopProxyUtils</code></a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="unit-testing-spring-mvc"><a class="anchor" href="#unit-testing-spring-mvc"></a> 2.2.2。Spring MVC测试实用程序</h4>
<div class="paragraph">
<p>的<code>org.springframework.test.web</code>包装内含<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html"><code>ModelAndViewAssert</code></a> ，您可以将其与JUnit，TestNG或任何其他测试框架结合使用以进行处理Spring MVC的单元测试<code>ModelAndView</code>对象。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">单元测试Spring MVC控制器</div>单元测试您的Spring MVC <code>Controller</code>类作为POJO，使用<code>ModelAndViewAssert</code>结合<code>MockHttpServletRequest</code> ， <code>MockHttpSession</code> ，等等，来自Spring的<a href="#mock-objects-servlet">Servlet API模拟</a> 。用于对Spring MVC和REST进行全面的集成测试<code>Controller</code>与您的课程一起<code>WebApplicationContext</code>配置Spring MVC，请改用<a href="#spring-mvc-test-framework">Spring MVC测试框架</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integration-testing"><a class="anchor" href="#integration-testing"></a> 3。整合测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节（本章其余部分）涵盖了Spring应用程序的集成测试。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-overview">总览</a></p>
</li>
<li>
<p><a href="#integration-testing-goals">集成测试的目标</a></p>
</li>
<li>
<p><a href="#integration-testing-support-jdbc">JDBC测试支持</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations">注解</a></p>
</li>
<li>
<p><a href="#testcontext-framework">Spring TestContext框架</a></p>
</li>
<li>
<p><a href="#spring-mvc-test-framework">Spring MVC测试框架</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="integration-testing-overview"><a class="anchor" href="#integration-testing-overview"></a> 3.1。总览</h3>
<div class="paragraph">
<p>能够执行一些集成测试而无需部署到应用程序服务器或连接到其他企业基础结构，这一点很重要。这样可以测试以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring IoC容器上下文的正确接线。</p>
</li>
<li>
<p>使用JDBC或ORM工具进行数据访问。这可以包括诸如SQL语句的正确性，Hibernate查询，JPA实体映射之类的东西。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework 为集成测试提供了一流的支持。 <code>spring-test</code>模块。实际的JAR文件的名称可能包含发行版本，并且名称可能太长<code>org.springframework.test</code>表格，具体取决于您从哪里获得（请参阅“ <a href="core.html#dependency-management">依赖关系管理</a> ” <a href="core.html#dependency-management">部分以</a>获取解释）。该库包括<code>org.springframework.test</code>软件包，其中包含用于与Spring容器进行集成测试的有价值的类。此测试不依赖于应用程序服务器或其他部署环境。此类测试的运行速度比单元测试慢，但比依赖于部署到应用程序服务器的等效Selenium测试或远程测试快。</p>
</div>
<div class="paragraph">
<p>单元和集成测试支持以注释驱动的<a href="#testcontext-framework">Spring TestContext Framework</a>的形式提供。TestContext框架与实际使用的测试框架无关，该框架允许在各种环境（包括JUnit，TestNG和其他环境）中对测试进行检测。</p>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-goals"><a class="anchor" href="#integration-testing-goals"></a> 3.2。集成测试的目标</h3>
<div class="paragraph">
<p>Spring的集成测试支持具有以下主要目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在测试之间管理<a href="#testing-ctx-management">Spring IoC容器缓存</a> 。</p>
</li>
<li>
<p>提供<a href="#testing-fixture-di">测试夹具实例的依赖注入</a> 。</p>
</li>
<li>
<p>提供适合集成测试的<a href="#testing-tx">事务管理</a> 。</p>
</li>
<li>
<p>提供<a href="#testing-support-classes">特定</a>于<a href="#testing-support-classes">Spring的基类</a> ，以帮助开发人员编写集成测试。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来的几节描述了每个目标，并提供了有关实现和配置详细信息的链接。</p>
</div>
<div class="sect3">
<h4 id="testing-ctx-management"><a class="anchor" href="#testing-ctx-management"></a> 3.2.1。上下文管理和缓存</h4>
<div class="paragraph">
<p>Spring TestContext Framework提供一致的Spring加载<code>ApplicationContext</code>实例和<code>WebApplicationContext</code>实例以及这些上下文的缓存。对加载的上下文的缓存的支持很重要，因为启动时间可能会成为问题-并不是因为Spring本身的开销，而是因为Spring容器实例化的对象需要时间才能实例化。例如，一个包含50到100个Hibernate映射文件的项目可能需要10到20秒的时间来加载映射文件，并且在每个测试夹具中运行每个测试之前要承担该费用，这会导致整体测试运行速度变慢，从而降低了开发人员的工作效率。</p>
</div>
<div class="paragraph">
<p>测试类通常声明XML或Groovy配置元数据的资源位置数组（通常在类路径中）或用于配置应用程序的组件类数组。这些位置或类别与中指定的位置或类别相同或相似<code>web.xml</code>或用于生产部署的其他配置文件。</p>
</div>
<div class="paragraph">
<p>默认情况下，加载后， <code>ApplicationContext</code>可以在每次测试中重复使用。因此，每个测试套件仅产生一次安装成本，并且随后的测试执行要快得多。在这种情况下，术语“测试套件”是指所有测试均在同一JVM中运行-例如，所有测试均从给定项目或模块的Ant，Maven或Gradle构建中运行。在不太可能的情况下，测试破坏了应用程序上下文并需要重新加载（例如，通过修改bean定义或应用程序对象的状态），可以将TestContext框架配置为在执行下一个之前重新加载配置并重建应用程序上下文测试。</p>
</div>
<div class="paragraph">
<p>请参见使用TestContext框架进行<a href="#testcontext-ctx-management">上下文管理</a>和<a href="#testcontext-ctx-management-caching">上下文缓存</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-fixture-di"><a class="anchor" href="#testing-fixture-di"></a> 3.2.2。测试夹具的依赖注入</h4>
<div class="paragraph">
<p>当TestContext框架加载您的应用程序上下文时，可以选择使用依赖注入来配置测试类的实例。这提供了一种方便的机制，可以通过使用来自应用程序上下文的预配置bean来设置测试装置。这方面的一大优势是，您可以在各种测试场景中重用应用程序上下文（例如，用于配置Spring托管的对象图，事务代理， <code>DataSource</code>实例等），从而避免了针对单个测试用例重复复杂的测试夹具设置的需要。</p>
</div>
<div class="paragraph">
<p>举例来说，假设我们有一个班级（ <code>HibernateTitleRepository</code> ）实现了针对<code>Title</code>域实体。我们要编写集成测试来测试以下方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring配置：基本上，所有内容都与<code>HibernateTitleRepository</code> bean 正确并存在？</p>
</li>
<li>
<p>Hibernate映射文件配置：是否正确映射了所有内容，并且是否有正确的延迟加载设置？</p>
</li>
<li>
<p>的逻辑<code>HibernateTitleRepository</code> ：此类的配置实例是否按预期执行？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请参阅使用<a href="#testcontext-fixture-di">TestContext框架</a>对测试装置进行依赖注入。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-tx"><a class="anchor" href="#testing-tx"></a> 3.2.3。交易管理</h4>
<div class="paragraph">
<p>访问真实数据库的测试中的一个常见问题是它们对持久性存储状态的影响。即使使用开发数据库，对状态的更改也可能会影响以后的测试。同样，许多操作（例如插入或修改持久数据）无法在事务之外执行（或验证）。</p>
</div>
<div class="paragraph">
<p>TestContext框架解决了这个问题。默认情况下，框架为每个测试创建并回滚事务。您可以编写可以假定存在事务的代码。如果在测试中调用事务代理对象，则对象将根据其配置的事务语义正确运行。此外，如果测试方法在为测试管理的事务中运行时删除选定表的内容，则该事务将默认回滚，并且数据库将返回到执行测试之前的状态。使用以下命令为测试提供事务支持<code>PlatformTransactionManager</code>在测试的应用程序上下文中定义的bean。</p>
</div>
<div class="paragraph">
<p>如果您要提交事务（不常见，但是在希望特定测试填充或修改数据库时很有用），则可以使用以下命令告诉TestContext框架使事务提交而不是回滚。 <a href="#integration-testing-annotations"><code>@Commit</code></a>注解。</p>
</div>
<div class="paragraph">
<p>请参阅使用<a href="#testcontext-tx">TestContext框架进行</a>事务管理。</p>
</div>
</div>
<div class="sect3">
<h4 id="testing-support-classes"><a class="anchor" href="#testing-support-classes"></a> 3.2.4。集成测试支持类</h4>
<div class="paragraph">
<p>Spring TestContext Framework提供了几个<code>abstract</code>支持类，可简化集成测试的编写。这些基本测试类为测试框架提供了定义明确的钩子，以及方便的实例变量和方法，可用于访问以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>ApplicationContext</code> ，用于执行显式的bean查找或测试整个上下文的状态。</p>
</li>
<li>
<p>一种<code>JdbcTemplate</code> ，用于执行SQL语句来查询数据库。您可以在执行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，并且Spring确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具一起使用时，请确保避免<a href="#testcontext-tx-false-positives">误报</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，您可能想使用针对您项目的实例变量和方法创建自己的自定义，应用程序级超类。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="#testcontext-support-classes">TestContext框架的</a>支持类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-support-jdbc"><a class="anchor" href="#integration-testing-support-jdbc"></a> 3.3。JDBC测试支持</h3>
<div class="paragraph">
<p>的<code>org.springframework.test.jdbc</code>包装内含<code>JdbcTestUtils</code> ，它是JDBC相关实用程序功能的集合，旨在简化标准数据库测试方案。特别， <code>JdbcTestUtils</code>提供以下静态实用程序方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>countRowsInTable(..)</code> ：计算给定表中的行数。</p>
</li>
<li>
<p><code>countRowsInTableWhere(..)</code> ：通过使用提供的计数来计算给定表中的行数<code>WHERE</code>条款。</p>
</li>
<li>
<p><code>deleteFromTables(..)</code> ：删除指定表中的所有行。</p>
</li>
<li>
<p><code>deleteFromTableWhere(..)</code> ：使用提供的内容从给定表中删除行<code>WHERE</code>条款。</p>
</li>
<li>
<p><code>dropTables(..)</code> ：删除指定的表。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>和<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>提供委托给上述方法的便捷方法<code>JdbcTestUtils</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>spring-jdbc</code>模块提供对配置和启动嵌入式数据库的支持，您可以在与数据库进行交互的集成测试中使用它。有关详细信息，请参见<a href="data-access.html#jdbc-embedded-database-support">嵌入式数据库支持</a>和<a href="data-access.html#jdbc-embedded-database-dao-testing">使用嵌入式数据库测试数据访问逻辑</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="integration-testing-annotations"><a class="anchor" href="#integration-testing-annotations"></a> 3.4。注解</h3>
<div class="paragraph">
<p>本节介绍了在测试Spring应用程序时可以使用的注释。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-spring">Spring 测试注释</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-standard">标准注释支持</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4">Spring JUnit 4测试注释</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter测试注释</a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-meta">测试的元注释支持</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-spring"><a class="anchor" href="#integration-testing-annotations-spring"></a> 3.4.1。Spring 测试注释</h4>
<div class="paragraph">
<p>Spring Framework 提供了以下特定于Spring的注释集，您可以在单元测试和集成测试中将它们与TestContext框架结合使用。有关更多信息，请参见相应的javadoc，包括默认属性值，属性别名和其他详细信息。</p>
</div>
<div class="paragraph">
<p>Spring的测试注释包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-testing-annotation-bootstrapwith"><code>@BootstrapWith</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contextconfiguration"><code>@ContextConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-webappconfiguration"><code>@WebAppConfiguration</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-contexthierarchy"><code>@ContextHierarchy</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-activeprofiles"><code>@ActiveProfiles</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testpropertysource"><code>@TestPropertySource</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-testexecutionlisteners"><code>@TestExecutionListeners</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-commit"><code>@Commit</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-rollback"><code>@Rollback</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-beforetransaction"><code>@BeforeTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-aftertransaction"><code>@AfterTransaction</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sql"><code>@Sql</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlconfig"><code>@SqlConfig</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code></a></p>
</li>
<li>
<p><a href="#spring-testing-annotation-sqlgroup"><code>@SqlGroup</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-bootstrapwith"><a class="anchor" href="#spring-testing-annotation-bootstrapwith"></a><code>@BootstrapWith</code></h5>
<div class="paragraph">
<p><code>@BootstrapWith</code>是一个类级别的注释，您可以用来配置如何引导Spring TestContext Framework。具体来说，您可以使用<code>@BootstrapWith</code>指定一个自定义<code>TestContextBootstrapper</code> 。有关更多详细信息，请参见有关<a href="#testcontext-bootstrapping">引导TestContext框架</a>的部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contextconfiguration"><a class="anchor" href="#spring-testing-annotation-contextconfiguration"></a><code>@ContextConfiguration</code></h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code>定义用于确定如何加载和配置<code>ApplicationContext</code>用于集成测试。特别， <code>@ContextConfiguration</code>声明应用程序上下文资源<code>locations</code>或组件<code>classes</code>用于加载上下文。</p>
</div>
<div class="paragraph">
<p>资源位置通常是位于类路径中的XML配置文件或Groovy脚本，而组件类通常是<code>@Configuration</code>类。但是，资源位置也可以引用文件系统中的文件和脚本，并且组件类可以是<code>@Component</code>类， <code>@Service</code>类，等等。有关更多详细信息，请参见<a href="#testcontext-ctx-management-javaconfig-component-classes">组件类</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@ContextConfiguration</code>引用XML文件的注释：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>引用XML文件。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration("/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>引用XML文件。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@ContextConfiguration</code>引用一个类的注释：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration(classes = TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指一类。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration(classes = [TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigClassApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指一类。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了声明资源位置或组件类以外，还可以使用<code>@ContextConfiguration</code>声明<code>ApplicationContextInitializer</code>类。以下示例显示了这种情况：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration(initializers = CustomContextIntializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration(initializers = [CustomContextIntializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextInitializerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一个初始化器类。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以选择使用<code>@ContextConfiguration</code>宣布<code>ContextLoader</code>策略也是如此。但是请注意，由于默认加载程序支持，因此通常不需要显式配置加载程序<code>initializers</code>和任何资源<code>locations</code>或组件<code>classes</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例同时使用位置和装载程序：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>配置位置和自定义加载程序。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration("/test-context.xml", loader = CustomContextLoader::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomLoaderXmlApplicationContextTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>配置位置和自定义加载程序。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@ContextConfiguration</code>提供对继承资源位置或配置类以及超类声明的上下文初始化器的支持。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参阅<a href="#testcontext-ctx-management">上下文管理</a>和<code>@ContextConfiguration</code>有关更多详细信息，请参见javadocs。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-webappconfiguration"><a class="anchor" href="#spring-testing-annotation-webappconfiguration"></a><code>@WebAppConfiguration</code></h5>
<div class="paragraph">
<p><code>@WebAppConfiguration</code>是类级别的注释，您可以用来声明<code>ApplicationContext</code>为进行集成测试而加载的应为<code>WebApplicationContext</code> 。的存在<code>@WebAppConfiguration</code>在测试班上确保<code>WebApplicationContext</code>使用默认值加载用于测试<code>"file:src/main/webapp"</code>用于Web应用程序根目录的路径（即资源基础路径）。资源基础路径用于幕后创建<code>MockServletContext</code> ，用作<code>ServletContext</code>用于测试<code>WebApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@WebAppConfiguration</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@WebAppConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@WebAppConfiguration</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要覆盖默认值，可以使用隐式指定其他基础资源路径。 <code>value</code>属性。都<code>classpath:</code>和<code>file:</code>支持资源前缀。如果未提供资源前缀，则假定该路径是文件系统资源。以下示例显示如何指定类路径资源：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定类路径资源。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") <i class="conum" data-value="1"></i><b>(1)</b>
class WebAppTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定类路径资源。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注意<code>@WebAppConfiguration</code>必须与<code>@ContextConfiguration</code> ，可以在单个测试类中，也可以在测试类层次结构中。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a>有关详细信息，请参见javadoc。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-contexthierarchy"><a class="anchor" href="#spring-testing-annotation-contexthierarchy"></a><code>@ContextHierarchy</code></h5>
<div class="paragraph">
<p><code>@ContextHierarchy</code>是一个类级别的注释，用于定义以下内容的层次结构<code>ApplicationContext</code>集成测试的实例。 <code>@ContextHierarchy</code>应该声明一个或多个列表<code>@ContextConfiguration</code>实例，每个实例定义上下文层次结构中的一个级别。以下示例说明了<code>@ContextHierarchy</code>在一个测试类中（ <code>@ContextHierarchy</code>也可以在测试类层次结构中使用）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class ContextHierarchyTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
class ContextHierarchyTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@WebAppConfiguration
@ContextHierarchy(
        ContextConfiguration(classes = [AppConfig::class]),
        ContextConfiguration(classes = [WebConfig::class]))
class WebIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要合并或覆盖测试类层次结构中给定级别的上下文层次结构的配置，则必须通过向该类提供相同的值来显式命名该级别。 <code>name</code>归因于<code>@ContextConfiguration</code>在类层次结构中的每个相应级别。请参阅<a href="#testcontext-ctx-management-ctx-hierarchies">上下文层次结构</a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/ContextHierarchy.html"><code>@ContextHierarchy</code></a> javadoc以获得更多示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-activeprofiles"><a class="anchor" href="#spring-testing-annotation-activeprofiles"></a><code>@ActiveProfiles</code></h5>
<div class="paragraph">
<p><code>@ActiveProfiles</code>是一个类级别的注释，用于声明在加载一个bean定义配置文件时应处于活动状态<code>ApplicationContext</code>进行集成测试。</p>
</div>
<div class="paragraph">
<p>以下示例表明<code>dev</code>个人资料应处于活动状态：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>表示<code>dev</code>个人资料应处于活动状态。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@ActiveProfiles("dev") <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>表示<code>dev</code>个人资料应处于活动状态。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例表明， <code>dev</code>和<code>integration</code>配置文件应处于活动状态：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>表示<code>dev</code>和<code>integration</code>配置文件应处于活动状态。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@ActiveProfiles(["dev", "integration"]) <i class="conum" data-value="1"></i><b>(1)</b>
class DeveloperIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>表示<code>dev</code>和<code>integration</code>配置文件应处于活动状态。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@ActiveProfiles</code>提供对继承默认情况下超类声明的活动Bean定义配置文件的支持。您还可以通过实现自定义来以编程方式解析活动的bean定义配置文件<a href="#testcontext-ctx-management-env-profiles-ActiveProfilesResolver"><code>ActiveProfilesResolver</code></a>并使用<code>resolver</code>的属性<code>@ActiveProfiles</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参阅<a href="#testcontext-ctx-management-env-profiles">使用环境配置文件进行上下文配置</a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfiles.html"><code>@ActiveProfiles</code></a>有关示例和更多详细信息的javadoc。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testpropertysource"><a class="anchor" href="#spring-testing-annotation-testpropertysource"></a><code>@TestPropertySource</code></h5>
<div class="paragraph">
<p><code>@TestPropertySource</code>是类级别的注释，可用于配置属性文件的位置以及将内联属性添加到<code>PropertySources</code>在里面<code>Environment</code>为<code>ApplicationContext</code>进行集成测试。</p>
</div>
<div class="paragraph">
<p>测试属性源的优先级高于从操作系统环境或Java系统属性以及应用程序通过声明方式添加的属性源加载的优先级<code>@PropertySource</code>或以编程方式因此，测试属性源可用于选择性覆盖系统和应用程序属性源中定义的属性。此外，内联属性比从资源位置加载的属性具有更高的优先级。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何从类路径声明属性文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从获取属性<code>test.properties</code>在类路径的根目录中。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从获取属性<code>test.properties</code>在类路径的根目录中。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例演示如何声明内联属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>宣布<code>timezone</code>和<code>port</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>宣布<code>timezone</code>和<code>port</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关示例和更多详细信息，请参见<a href="#testcontext-ctx-management-property-sources">使用测试属性源</a>进行<a href="#testcontext-ctx-management-property-sources">上下文配置</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-dirtiescontext"><a class="anchor" href="#spring-testing-annotation-dirtiescontext"></a><code>@DirtiesContext</code></h5>
<div class="paragraph">
<p><code>@DirtiesContext</code>表示基础Spring <code>ApplicationContext</code>在执行测试期间已被弄脏（即测试以某种方式修改或破坏了它，例如，通过更改单例bean的状态），因此应将其关闭。当应用程序上下文标记为脏时，会将其从测试框架的缓存中删除并关闭。因此，将为需要上下文具有相同配置元数据的任何后续测试重建基础Spring容器。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@DirtiesContext</code>作为同一类或类层次结构中的类级和方法级注释。在这种情况下， <code>ApplicationContext</code>在任何带注释的方法之前或之后以及当前测试类之前或之后被标记为脏，具体取决于配置<code>methodMode</code>和<code>classMode</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例说明了在各种配置情况下何时弄脏上下文：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在当前测试类之前，在类模式设置为的类上声明时<code>BEFORE_CLASS</code> 。</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在当前测试类之前弄脏上下文。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@DirtiesContext(classMode = BEFORE_CLASS) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在当前测试类之前弄脏上下文。</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>在当前测试类之后，在类模式设置为的类上声明时<code>AFTER_CLASS</code> （即默认的班级模式）。</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>当前测试类后的上下文很脏。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>当前测试类后的上下文很脏。</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>在当前测试类中的每个测试方法之前，在类模式设置为的类上声明时<code>BEFORE_EACH_TEST_METHOD.</code></p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>每种测试方法前都要弄脏上下文。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class FreshContextTests {
    // some tests that require a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>每种测试方法前都要弄脏上下文。</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>在当前测试类中的每个测试方法之后，在类模式设置为的类上声明时<code>AFTER_EACH_TEST_METHOD.</code></p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>每种测试方法后都使上下文变脏。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>每种测试方法后都使上下文变脏。</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>在当前测试之前，在方法模式设置为的方法上声明时<code>BEFORE_METHOD</code> 。</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在当前测试方法之前弄脏上下文。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@DirtiesContext(methodMode = BEFORE_METHOD) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在当前测试方法之前弄脏上下文。</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>在当前测试之后，当在方法模式设置为的方法上声明时<code>AFTER_METHOD</code> （即默认方法模式）。</p>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>当前测试方法后，上下文变脏。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@DirtiesContext <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>当前测试方法后，上下文变脏。</td>
</tr>
</tbody></table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您使用<code>@DirtiesContext</code>在其上下文被配置为上下文层次结构的一部分的测试中<code>@ContextHierarchy</code> ，您可以使用<code>hierarchyMode</code>标志，用于控制如何清除上下文缓存。默认情况下，使用穷举算法清除上下文缓存，不仅包括当前级别，还包括共享当前测试共有的祖先上下文的所有其他上下文层次结构。所有<code>ApplicationContext</code>驻留在公共祖先上下文的子层次结构中的实例将从上下文缓存中删除并关闭。如果穷举算法对于特定用例而言过于矫kill过正，则可以指定更简单的当前级别算法，如以下示例所示。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class BaseTests {
    // class body...
}

class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    void test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用当前级别的算法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextHierarchy(
    ContextConfiguration("/parent-config.xml"),
    ContextConfiguration("/child-config.xml"))
open class BaseTests {
    // class body...
}

class ExtendedTests : BaseTests() {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) <i class="conum" data-value="1"></i><b>(1)</b>
    fun test() {
        // some logic that results in the child context being dirtied
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用当前级别的算法。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关的更多详细信息<code>EXHAUSTIVE</code>和<code>CURRENT_LEVEL</code>算法，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html"><code>DirtiesContext.HierarchyMode</code></a> javadoc。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-testexecutionlisteners"><a class="anchor" href="#spring-testing-annotation-testexecutionlisteners"></a><code>@TestExecutionListeners</code></h5>
<div class="paragraph">
<p><code>@TestExecutionListeners</code>定义用于配置<code>TestExecutionListener</code>应当向<code>TestContextManager</code> 。通常， <code>@TestExecutionListeners</code>与...结合使用<code>@ContextConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何注册两个<code>TestExecutionListener</code>实现：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注册两个<code>TestExecutionListener</code>实现。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomTestExecutionListenerTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注册两个<code>TestExecutionListener</code>实现。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认， <code>@TestExecutionListeners</code>支持继承的侦听器。有关示例和更多详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">javadoc</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-commit"><a class="anchor" href="#spring-testing-annotation-commit"></a><code>@Commit</code></h5>
<div class="paragraph">
<p><code>@Commit</code>表示应该在测试方法完成后提交用于事务测试方法的事务。您可以使用<code>@Commit</code>作为直接替代<code>@Rollback(false)</code>更明确地传达代码的意图。类似于<code>@Rollback</code> ， <code>@Commit</code>也可以声明为类级别或方法级别的注释。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@Commit</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将测试结果提交到数据库。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Commit <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将测试结果提交到数据库。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-rollback"><a class="anchor" href="#spring-testing-annotation-rollback"></a><code>@Rollback</code></h5>
<div class="paragraph">
<p><code>@Rollback</code>指示在测试方法完成后是否应回退事务测试方法的事务。如果<code>true</code> ，交易将回滚。否则，将提交事务（另请参见<a href="#spring-testing-annotation-commit"><code>@Commit</code></a> ）。Spring TestContext Framework中的集成测试回滚默认为<code>true</code>即使<code>@Rollback</code>没有明确声明。</p>
</div>
<div class="paragraph">
<p>当声明为类级注释时， <code>@Rollback</code>定义测试类层次结构中所有测试方法的默认回滚语义。当声明为方法级注释时， <code>@Rollback</code>为特定的测试方法定义回滚语义，可能会覆盖类级别<code>@Rollback</code>要么<code>@Commit</code>语义。</p>
</div>
<div class="paragraph">
<p>下面的示例使测试方法的结果不回滚（即，结果已提交到数据库）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
void testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>不要回滚结果。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Rollback(false) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWithoutRollback() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>不要回滚结果。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-beforetransaction"><a class="anchor" href="#spring-testing-annotation-beforetransaction"></a><code>@BeforeTransaction</code></h5>
<div class="paragraph">
<p><code>@BeforeTransaction</code>表示被注释的<code>void</code>方法应该在事务启动之前运行，对于已配置为使用Spring的事务在事务内运行的测试方法<code>@Transactional</code>注解。 <code>@BeforeTransaction</code>方法不是必须的<code>public</code>并且可以在基于Java 8的接口默认方法中声明。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@BeforeTransaction</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void beforeTransaction() {
    // logic to be executed before a transaction is started
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在事务之前运行此方法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@BeforeTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun beforeTransaction() {
    // logic to be executed before a transaction is started
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在事务之前运行此方法。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-aftertransaction"><a class="anchor" href="#spring-testing-annotation-aftertransaction"></a><code>@AfterTransaction</code></h5>
<div class="paragraph">
<p><code>@AfterTransaction</code>表示被注释的<code>void</code>方法应在事务结束后运行，对于已配置为通过使用Spring的事务在事务内运行的测试方法<code>@Transactional</code>注解。 <code>@AfterTransaction</code>方法不是必须的<code>public</code>并且可以在基于Java 8的接口默认方法中声明。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
void afterTransaction() {
    // logic to be executed after a transaction has ended
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>事务后运行此方法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@AfterTransaction <i class="conum" data-value="1"></i><b>(1)</b>
fun afterTransaction() {
    // logic to be executed after a transaction has ended
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>事务后运行此方法。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sql"><a class="anchor" href="#spring-testing-annotation-sql"></a><code>@Sql</code></h5>
<div class="paragraph">
<p><code>@Sql</code>用于注释测试类或测试方法，以配置在集成测试期间针对给定数据库运行的SQL脚本。以下示例显示了如何使用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) <i class="conum" data-value="1"></i><b>(1)</b>
void userTest() {
    // execute code that relies on the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>运行此测试的两个脚本。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
@Sql("/test-schema.sql", "/test-user-data.sql") <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // execute code that relies on the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>运行此测试的两个脚本。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="#testcontext-executing-sql-declaratively">使用@Sql声明式执行SQL脚本</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlconfig"><a class="anchor" href="#spring-testing-annotation-sqlconfig"></a><code>@SqlConfig</code></h5>
<div class="paragraph">
<p><code>@SqlConfig</code>定义用于确定如何解析和运行使用以下命令配置的SQL脚本的元数据<code>@Sql</code>注解。以下示例显示了如何使用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") <i class="conum" data-value="1"></i><b>(1)</b>
)
void userTest() {
    // execute code that relies on the test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在SQL脚本中设置注释前缀和分隔符。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
@Sql("/test-user-data.sql", config = SqlConfig(commentPrefix = "`", separator = "@@")) <i class="conum" data-value="1"></i><b>(1)</b>
fun userTest() {
    // execute code that relies on the test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在SQL脚本中设置注释前缀和分隔符。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlmergemode"><a class="anchor" href="#spring-testing-annotation-sqlmergemode"></a><code>@SqlMergeMode</code></h5>
<div class="paragraph">
<p><code>@SqlMergeMode</code>用于注释测试类或测试方法以配置方法级别<code>@Sql</code>声明与类级别合并<code>@Sql</code>声明。如果<code>@SqlMergeMode</code>没有在测试类或测试方法上声明， <code>OVERRIDE</code>默认情况下将使用合并模式。随着<code>OVERRIDE</code>模式，方法级别<code>@Sql</code>声明将有效覆盖类级别<code>@Sql</code>声明。</p>
</div>
<div class="paragraph">
<p>请注意，方法级别<code>@SqlMergeMode</code>声明会覆盖类级别的声明。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@SqlMergeMode</code>在课堂上。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>@Sql</code>合并模式为<code>MERGE</code>该类中的所有测试方法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    fun standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>@Sql</code>合并模式为<code>MERGE</code>该类中的所有测试方法。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@SqlMergeMode</code>在方法级别。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    void standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>@Sql</code>合并模式为<code>MERGE</code>用于特定的测试方法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) <i class="conum" data-value="1"></i><b>(1)</b>
    fun standardUserProfile() {
        // execute code that relies on test data set 001
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>@Sql</code>合并模式为<code>MERGE</code>用于特定的测试方法。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-testing-annotation-sqlgroup"><a class="anchor" href="#spring-testing-annotation-sqlgroup"></a><code>@SqlGroup</code></h5>
<div class="paragraph">
<p><code>@SqlGroup</code>是一个容器注释，它聚合了多个<code>@Sql</code>注释。您可以使用<code>@SqlGroup</code>在本地声明几个嵌套<code>@Sql</code>注释，或者您可以将其与Java 8对可重复注释的支持结合使用，其中<code>@Sql</code>可以在同一个类或方法上声明多次，从而隐式生成此容器注释。下面的示例显示如何声明一个SQL组：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@SqlGroup({ <i class="conum" data-value="1"></i><b>(1)</b>
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一组SQL脚本。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
@SqlGroup( <i class="conum" data-value="1"></i><b>(1)</b>
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明一组SQL脚本。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-standard"><a class="anchor" href="#integration-testing-annotations-standard"></a> 3.4.2。标准注释支持</h4>
<div class="paragraph">
<p>Spring TestContext Framework的所有配置的标准语义都支持以下注释。注意，这些注释不是特定于测试的，可以在Spring Framework中的任何地方使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Autowired</code></p>
</li>
<li>
<p><code>@Qualifier</code></p>
</li>
<li>
<p><code>@Value</code></p>
</li>
<li>
<p><code>@Resource</code> （javax.annotation）如果存在JSR-250</p>
</li>
<li>
<p><code>@ManagedBean</code> （javax.annotation）如果存在JSR-250</p>
</li>
<li>
<p><code>@Inject</code> （javax.inject）如果存在JSR-330</p>
</li>
<li>
<p><code>@Named</code> （javax.inject）如果存在JSR-330</p>
</li>
<li>
<p><code>@PersistenceContext</code> （javax.persistence）如果存在JPA</p>
</li>
<li>
<p><code>@PersistenceUnit</code> （javax.persistence）如果存在JPA</p>
</li>
<li>
<p><code>@Required</code></p>
</li>
<li>
<p><code>@Transactional</code> （org.springframework.transaction.annotation） <em>具有<a href="#testcontext-tx-attribute-support">有限的属性支持</a></em></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">JSR-250生命周期注释</div>
<div class="paragraph">
<p>在Spring TestContext Framework中，您可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code>具有标准语义的应用程序组件中配置的任何<code>ApplicationContext</code> 。但是，这些生命周期注释在实际测试类中的使用受到限制。</p>
</div>
<div class="paragraph">
<p>如果测试类中的方法用注释<code>@PostConstruct</code> ，该方法将在基础测试框架的所有before方法之前运行（例如，以JUnit Jupiter的方法注释的方法<code>@BeforeEach</code> ），并且适用于测试类中的每个测试方法。另一方面，如果测试类中的方法用注释<code>@PreDestroy</code> ，该方法永远不会运行。因此，在测试类中，建议您使用基础测试框架中的测试生命周期回调，而不是<code>@PostConstruct</code>和<code>@PreDestroy</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit4"><a class="anchor" href="#integration-testing-annotations-junit4"></a> 3.4.3。Spring JUnit 4测试注释</h4>
<div class="paragraph">
<p>以下注释仅在与<a href="#testcontext-junit4-runner">SpringRunner</a> ， <a href="#testcontext-junit4-rules">Spring的JUnit 4规则</a>或<a href="#testcontext-support-classes-junit4">Spring的JUnit 4支持类</a>结合使用<a href="#testcontext-junit4-runner">时才受</a> <a href="#testcontext-support-classes-junit4">支持</a> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit4-ifprofilevalue"><code>@IfProfileValue</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"><code>@ProfileValueSourceConfiguration</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-timed"><code>@Timed</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit4-repeat"><code>@Repeat</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-ifprofilevalue"><a class="anchor" href="#integration-testing-annotations-junit4-ifprofilevalue"></a><code>@IfProfileValue</code></h5>
<div class="paragraph">
<p><code>@IfProfileValue</code>表示已为特定测试环境启用带注释的测试。如果配置<code>ProfileValueSource</code>返回一个匹配<code>value</code>对于提供的<code>name</code> ，测试已启用。否则，测试将被禁用，并且实际上将被忽略。</p>
</div>
<div class="paragraph">
<p>你可以申请<code>@IfProfileValue</code>在类级别，方法级别或两者兼而有之。类级别的用法<code>@IfProfileValue</code>对于该类或其子类中的任何方法，优先于方法级使用。具体来说，如果在类级别和方法级别都启用了测试，则将启用该测试。的缺席<code>@IfProfileValue</code>表示测试已隐式启用。这类似于JUnit 4的语义<code>@Ignore</code>注释，除了存在<code>@Ignore</code>始终禁用测试。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个具有<code>@IfProfileValue</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>仅当Java供应商是“ Oracle Corporation”时才运行此测试。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@IfProfileValue(name="java.vendor", value="Oracle Corporation") <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>仅当Java供应商是“ Oracle Corporation”时才运行此测试。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>或者，您可以配置<code>@IfProfileValue</code>带有清单<code>values</code> （与<code>OR</code>语义）来实现对JUnit 4环境中的测试组的类似于TestNG的支持。考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"}) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>对单元测试和集成测试运行此测试。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@IfProfileValue(name="test-groups", values=["unit-tests", "integration-tests"]) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>对单元测试和集成测试运行此测试。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-profilevaluesourceconfiguration"><a class="anchor" href="#integration-testing-annotations-junit4-profilevaluesourceconfiguration"></a><code>@ProfileValueSourceConfiguration</code></h5>
<div class="paragraph">
<p><code>@ProfileValueSourceConfiguration</code>是类级别的注释，用于指定哪种类型的<code>ProfileValueSource</code>在通过以下方式检索配置文件值时使用<code>@IfProfileValue</code>注解。如果<code>@ProfileValueSourceConfiguration</code>没有宣布要进行测试， <code>SystemProfileValueSource</code>默认情况下使用。以下示例显示了如何使用<code>@ProfileValueSourceConfiguration</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ProfileValueSourceConfiguration(CustomProfileValueSource.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用自定义配置文件值源。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ProfileValueSourceConfiguration(CustomProfileValueSource::class) <i class="conum" data-value="1"></i><b>(1)</b>
class CustomProfileValueSourceTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用自定义配置文件值源。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-timed"><a class="anchor" href="#integration-testing-annotations-junit4-timed"></a><code>@Timed</code></h5>
<div class="paragraph">
<p><code>@Timed</code>表示带注释的测试方法必须在指定的时间段（以毫秒为单位）内完成执行。如果文本执行时间超过指定的时间段，则测试将失败。</p>
</div>
<div class="paragraph">
<p>该时间段包括运行测试方法本身，测试的任何重复（请参见<code>@Repeat</code> ），以及测试夹具的任何安装或拆卸。以下示例显示了如何使用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
public void testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to execute
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将测试时间设置为一秒。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Timed(millis = 1000) <i class="conum" data-value="1"></i><b>(1)</b>
fun testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to execute
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将测试时间设置为一秒。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p> Spring 的<code>@Timed</code>注释与JUnit 4的语义不同<code>@Test(timeout=…​)</code>支持。具体来说，由于JUnit 4处理测试执行超时的方式（即通过在单独的位置执行测试方法） <code>Thread</code> ）， <code>@Test(timeout=…​)</code>如果测试时间太长，则会抢先通过测试。 Spring 的<code>@Timed</code>另一方面，它不会抢先通过测试，而是在失败之前等待测试完成。</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit4-repeat"><a class="anchor" href="#integration-testing-annotations-junit4-repeat"></a><code>@Repeat</code></h5>
<div class="paragraph">
<p><code>@Repeat</code>表示带注释的测试方法必须重复运行。注释中指定了要执行测试方法的次数。</p>
</div>
<div class="paragraph">
<p>重复执行的范围包括测试方法本身的执行以及测试夹具的任何安装或拆除。以下示例显示了如何使用<code>@Repeat</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
public void testProcessRepeatedly() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>重复此测试十次。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repeat(10) <i class="conum" data-value="1"></i><b>(1)</b>
@Test
fun testProcessRepeatedly() {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>重复此测试十次。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-junit-jupiter"><a class="anchor" href="#integration-testing-annotations-junit-jupiter"></a> 3.4.4。Spring JUnit Jupiter测试注释</h4>
<div class="paragraph">
<p>仅当与以下注释结合使用时，才支持以下注释<a href="#testcontext-junit-jupiter-extension"><code>SpringExtension</code></a>和JUnit Jupiter（即JUnit 5中的编程模型）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitconfig"><code>@SpringJUnitConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"><code>@SpringJUnitWebConfig</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-enabledif"><code>@EnabledIf</code></a></p>
</li>
<li>
<p><a href="#integration-testing-annotations-junit-jupiter-disabledif"><code>@DisabledIf</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitconfig"></a><code>@SpringJUnitConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitConfig</code>是结合在一起的组合注释<code>@ExtendWith(SpringExtension.class)</code>来自JUnit Jupiter， <code>@ContextConfiguration</code>来自Spring TestContext Framework。它可以在课程级别用作替代<code>@ContextConfiguration</code> 。关于配置选项，唯一的区别是<code>@ContextConfiguration</code>和<code>@SpringJUnitConfig</code>是可以使用<code>value</code>归因于<code>@SpringJUnitConfig</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@SpringJUnitConfig</code>注释以指定配置类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置类。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置类。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@SpringJUnitConfig</code>注释以指定配置文件的位置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置文件的位置。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置文件的位置。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参阅<a href="#testcontext-ctx-management">上下文管理</a>以及有关的Javadoc。 <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html"><code>@SpringJUnitConfig</code></a>和<code>@ContextConfiguration</code>有关更多详细信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-springjunitwebconfig"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-springjunitwebconfig"></a><code>@SpringJUnitWebConfig</code></h5>
<div class="paragraph">
<p><code>@SpringJUnitWebConfig</code>是结合在一起的组合注释<code>@ExtendWith(SpringExtension.class)</code>来自JUnit Jupiter， <code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>来自Spring TestContext Framework。您可以在班级使用它作为的替代品<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code> 。关于配置选项，唯一的区别是<code>@ContextConfiguration</code>和<code>@SpringJUnitWebConfig</code>是您可以使用<code>value</code>归因于<code>@SpringJUnitWebConfig</code> 。此外，您可以覆盖<code>value</code>来自的属性<code>@WebAppConfiguration</code>仅通过使用<code>resourcePath</code>归因于<code>@SpringJUnitWebConfig</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@SpringJUnitWebConfig</code>注释以指定配置类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig(TestConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置类。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig(TestConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置类。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@SpringJUnitWebConfig</code>注释以指定配置文件的位置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig(locations = "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置文件的位置。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig(locations = ["/test-config.xml"]) <i class="conum" data-value="1"></i><b>(1)</b>
class XmlJUnitJupiterSpringWebTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定配置文件的位置。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参阅<a href="#testcontext-ctx-management">上下文管理</a>以及有关的Javadoc。 <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html"><code>@SpringJUnitWebConfig</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/ContextConfiguration.html"><code>@ContextConfiguration</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html"><code>@WebAppConfiguration</code></a>有关更多详细信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-testconstructor"><a class="anchor" href="#integration-testing-annotations-testconstructor"></a><code>@TestConstructor</code></h5>
<div class="paragraph">
<p><code>@TestConstructor</code>是类型级别的注释，用于配置如何从测试的组件中自动连接测试类构造函数的参数<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>如果<code>@TestConstructor</code>在测试类上不存在或不存在，则将使用默认的<em>测试构造函数自动装配模式</em> 。有关如何更改默认模式的详细信息，请参见下面的提示。但是请注意，本地声明<code>@Autowired</code>在构造函数上优先于两者<code>@TestConstructor</code>和默认模式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">更改默认的测试构造函数自动装配模式</div>
<div class="paragraph">
<p>可以通过设置默认的<em>测试构造函数自动装配模式</em>来更改<code>spring.test.constructor.autowire.mode</code> JVM系统属性<code>all</code> 。另外，默认模式可以通过<code>SpringProperties</code>机制。</p>
</div>
<div class="paragraph">
<p>如果<code>spring.test.constructor.autowire.mode</code>如果未设置属性，则测试类构造函数将不会自动进行自动装配。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring Framework 5.2开始， <code>@TestConstructor</code>仅与<code>SpringExtension</code>与JUnit Jupiter一起使用。请注意<code>SpringExtension</code>通常会自动为您注册-例如，在使用诸如<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>或Spring Boot Test中与测试相关的各种注释。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-enabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-enabledif"></a><code>@EnabledIf</code></h5>
<div class="paragraph">
<p><code>@EnabledIf</code>用于表示已注释的JUnit Jupiter测试类或测试方法已启用，如果提供了此代码，则应运行<code>expression</code>评估为<code>true</code> 。具体来说，如果表达式的计算结果为<code>Boolean.TRUE</code>或一个<code>String</code>等于<code>true</code> （忽略大小写），将启用测试。在类级别应用时，默认情况下也会自动启用该类中的所有测试方法。</p>
</div>
<div class="paragraph">
<p>表达式可以是以下任意一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring表达式语言</a> （SpEL）表达式。例如：<code>@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p> Spring 可用属性的占位符<a href="core.html#beans-environment"><code>Environment</code></a> 。例如：<code>@EnabledIf("${smoke.tests.enabled}")</code></p>
</li>
<li>
<p>文字文字。例如：<code>@EnabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是请注意，不是属性占位符的动态解析结果的文本文字的实际价值为零，因为<code>@EnabledIf("false")</code>相当于<code>@Disabled</code>和<code>@EnabledIf("true")</code>在逻辑上是没有意义的。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@EnabledIf</code>作为元注释，以创建自定义的组合注释。例如，您可以创建一个自定义<code>@EnabledOnMac</code>批注如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Enabled on Mac OS"
)
public @interface EnabledOnMac {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@EnabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Enabled on Mac OS"
)
annotation class EnabledOnMac {}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="integration-testing-annotations-junit-jupiter-disabledif"><a class="anchor" href="#integration-testing-annotations-junit-jupiter-disabledif"></a><code>@DisabledIf</code></h5>
<div class="paragraph">
<p><code>@DisabledIf</code>用于表示已注释的JUnit Jupiter测试类或测试方法已禁用，如果提供了此选项，则不应执行<code>expression</code>评估为<code>true</code> 。具体来说，如果表达式的计算结果为<code>Boolean.TRUE</code>或一个<code>String</code>等于<code>true</code> （忽略大小写），则测试被禁用。在类级别应用时，该类中的所有测试方法也会自动禁用。</p>
</div>
<div class="paragraph">
<p>表达式可以是以下任意一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="core.html#expressions">Spring表达式语言</a> （SpEL）表达式。例如：<code>@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")</code></p>
</li>
<li>
<p> Spring 可用属性的占位符<a href="core.html#beans-environment"><code>Environment</code></a> 。例如：<code>@DisabledIf("${smoke.tests.disabled}")</code></p>
</li>
<li>
<p>文字文字。例如：<code>@DisabledIf("true")</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是请注意，不是属性占位符的动态解析结果的文本文字的实际价值为零，因为<code>@DisabledIf("true")</code>相当于<code>@Disabled</code>和<code>@DisabledIf("false")</code>在逻辑上是没有意义的。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@DisabledIf</code>作为元注释，以创建自定义的组合注释。例如，您可以创建一个自定义<code>@DisabledOnMac</code>批注如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Disabled on Mac OS"
)
public @interface DisabledOnMac {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@DisabledIf(
        expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
        reason = "Disabled on Mac OS"
)
annotation class DisabledOnMac {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="integration-testing-annotations-meta"><a class="anchor" href="#integration-testing-annotations-meta"></a> 3.4.5。测试的元注释支持</h4>
<div class="paragraph">
<p>您可以将大多数与测试相关的注释用作<a href="core.html#beans-meta-annotations">元注释，</a>以创建自定义的组合注释，并减少整个测试套件中的配置重复。</p>
</div>
<div class="paragraph">
<p>您可以将以下各项用作与<a href="#testcontext-framework">TestContext框架</a>结合使用的元注释。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BootstrapWith</code></p>
</li>
<li>
<p><code>@ContextConfiguration</code></p>
</li>
<li>
<p><code>@ContextHierarchy</code></p>
</li>
<li>
<p><code>@ActiveProfiles</code></p>
</li>
<li>
<p><code>@TestPropertySource</code></p>
</li>
<li>
<p><code>@DirtiesContext</code></p>
</li>
<li>
<p><code>@WebAppConfiguration</code></p>
</li>
<li>
<p><code>@TestExecutionListeners</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
<li>
<p><code>@BeforeTransaction</code></p>
</li>
<li>
<p><code>@AfterTransaction</code></p>
</li>
<li>
<p><code>@Commit</code></p>
</li>
<li>
<p><code>@Rollback</code></p>
</li>
<li>
<p><code>@Sql</code></p>
</li>
<li>
<p><code>@SqlConfig</code></p>
</li>
<li>
<p><code>@SqlMergeMode</code></p>
</li>
<li>
<p><code>@SqlGroup</code></p>
</li>
<li>
<p><code>@Repeat</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@Timed</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@IfProfileValue</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@ProfileValueSourceConfiguration</code> <em>（仅在JUnit 4上受支持）</em></p>
</li>
<li>
<p><code>@SpringJUnitConfig</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@SpringJUnitWebConfig</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@TestConstructor</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@EnabledIf</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
<li>
<p><code>@DisabledIf</code> <em>（仅在JUnit Jupiter上受支持）</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@RunWith(SpringRunner::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果发现我们在基于JUnit 4的测试套件中重复了前面的配置，则可以通过引入一个自定义的组合注释来减少重复，该注释集中了Spring的通用测试配置，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以使用我们的自定义<code>@TransactionalDevTestConfig</code>注释，以简化基于单个JUnit 4的测试类的配置，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class OrderRepositoryTests

@RunWith(SpringRunner::class)
@TransactionalDevTestConfig
class UserRepositoryTests</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们编写使用JUnit Jupiter的测试，则可以进一步减少代码重复，因为JUnit 5中的注释也可以用作元注释。考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果发现要在基于JUnit Jupiter的测试套件中重复上述配置，则可以通过引入自定义组合注释来减少重复，该注释集中了Spring和JUnit Jupiter的通用测试配置，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-data-access-config.xml")
@ActiveProfiles("dev")
@Transactional
annotation class TransactionalDevTestConfig { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以使用我们的自定义<code>@TransactionalDevTestConfig</code>注释可简化基于单个JUnit Jupiter的测试类的配置，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于JUnit Jupiter支持使用<code>@Test</code> ， <code>@RepeatedTest</code> ， <code>ParameterizedTest</code>和其他元注释，您也可以在测试方法级别创建自定义的组合注释。例如，如果我们希望创建一个组合注释，将<code>@Test</code>和<code>@Tag</code>来自JUnit Jupiter的注释<code>@Transactional</code>来自Spring的注释，我们可以创建一个<code>@TransactionalIntegrationTest</code>注释，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
annotation class TransactionalIntegrationTest { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以使用我们的自定义<code>@TransactionalIntegrationTest</code>注释可简化基于JUnit Jupiter的各个测试方法的配置，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@TransactionalIntegrationTest
fun saveOrder() { }

@TransactionalIntegrationTest
fun deleteOrder() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation编程模型</a> Wiki页面。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testcontext-framework"><a class="anchor" href="#testcontext-framework"></a> 3.5。Spring TestContext框架</h3>
<div class="paragraph">
<p>Spring TestContext Framework（位于<code>org.springframework.test.context</code>软件包）提供了通用的，注释驱动的单元和集成测试支持，这些支持与所使用的测试框架无关。TestContext框架还非常重视约定优于配置，您可以通过基于注解的配置覆盖合理的默认值。</p>
</div>
<div class="paragraph">
<p>除了通用测试基础结构之外，TestContext框架还为JUnit 4，JUnit Jupiter（AKA JUnit 5）和TestNG提供了显式支持。对于JUnit 4和TestNG，Spring提供<code>abstract</code>支持课程。此外，Spring提供了一个自定义的JUnit <code>Runner</code>和自定义JUnit <code>Rules</code>用于JUnit 4和自定义<code>Extension</code> JUnit Jupiter的代码，它使您可以编写所谓的POJO测试类。不需要POJO测试类来扩展特定的类层次结构，例如<code>abstract</code>支持课程。</p>
</div>
<div class="paragraph">
<p>下一节概述了TestContext框架的内部。如果您仅对使用框架感兴趣，而对使用自己的自定义侦听器或自定义加载程序进行扩展不感兴趣，请直接转到配置（ <a href="#testcontext-ctx-management">上下文管理</a> ， <a href="#testcontext-fixture-di">依赖项注入</a> ， <a href="#testcontext-tx">事务管理</a> ）， <a href="#testcontext-support-classes">支持类</a>和<a href="#integration-testing-annotations">注释支持</a>部分。</p>
</div>
<div class="sect3">
<h4 id="testcontext-key-abstractions"><a class="anchor" href="#testcontext-key-abstractions"></a> 3.5.1。关键抽象</h4>
<div class="paragraph">
<p>该框架的核心包括<code>TestContextManager</code>类和<code>TestContext</code> ， <code>TestExecutionListener</code>和<code>SmartContextLoader</code>接口。一种<code>TestContextManager</code>为每个测试类创建一个（例如，用于在JUnit Jupiter中的单个测试类中执行所有测试方法）。的<code>TestContextManager</code> ，依次管理<code>TestContext</code>保留当前测试的上下文。的<code>TestContextManager</code>也会更新状态<code>TestContext</code>随着测试的进行，并委托<code>TestExecutionListener</code>实现，通过提供依赖项注入，管理事务等手段来检测实际的测试执行。一种<code>SmartContextLoader</code>负责加载<code>ApplicationContext</code>对于给定的测试课程。有关更多信息和各种实现的示例，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a>和Spring测试套件。</p>
</div>
<div class="sect4">
<h5 id="code-testcontext-code"><a class="anchor" href="#code-testcontext-code"></a><code>TestContext</code></h5>
<div class="paragraph">
<p><code>TestContext</code>封装在其中执行测试的上下文（与使用中的实际测试框架无关），并为其负责的测试实例提供上下文管理和缓存支持。的<code>TestContext</code>还委托给<code>SmartContextLoader</code>加载<code>ApplicationContext</code>如果要求。</p>
</div>
</div>
<div class="sect4">
<h5 id="code-testcontextmanager-code"><a class="anchor" href="#code-testcontextmanager-code"></a><code>TestContextManager</code></h5>
<div class="paragraph">
<p><code>TestContextManager</code>是Spring TestContext Framework的主要入口点，并负责管理单个<code>TestContext</code>并向每个注册的用户发送信号事件<code>TestExecutionListener</code>在明确定义的测试执行点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在特定测试框架的任何“上课之前”或“所有之前”方法之前。</p>
</li>
<li>
<p>测试实例后处理。</p>
</li>
<li>
<p>在特定测试框架的任何“之前”或“每个之前”方法之前。</p>
</li>
<li>
<p>在执行测试方法之前但在测试设置之后。</p>
</li>
<li>
<p>在执行测试方法之后但立即将测试拆解。</p>
</li>
<li>
<p>在特定测试框架的任何“之后”或“每个之后”方法之后。</p>
</li>
<li>
<p>在特定测试框架的任何“课后”或“毕竟”方法之后。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="code-testexecutionlistener-code"><a class="anchor" href="#code-testexecutionlistener-code"></a><code>TestExecutionListener</code></h5>
<div class="paragraph">
<p><code>TestExecutionListener</code>定义用于响应由API发布的测试执行事件的API <code>TestContextManager</code>向其注册侦听器。看到<a href="#testcontext-tel-config"><code>TestExecutionListener</code>配置</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="context-loaders"><a class="anchor" href="#context-loaders"></a>上下文加载器</h5>
<div class="paragraph">
<p><code>ContextLoader</code>是用于加载<code>ApplicationContext</code>用于由Spring TestContext Framework管理的集成测试。你应该实现<code>SmartContextLoader</code>而不是此接口来提供对组件类，活动bean定义配置文件，测试属性源，上下文层次结构和<code>WebApplicationContext</code>支持。</p>
</div>
<div class="paragraph">
<p><code>SmartContextLoader</code>是对<code>ContextLoader</code>取代原始最小值的界面<code>ContextLoader</code> SPI。具体来说， <code>SmartContextLoader</code>可以选择处理资源位置，组件类或上下文初始化器。此外， <code>SmartContextLoader</code>可以在其加载的上下文中设置活动的Bean定义配置文件并测试属性源。</p>
</div>
<div class="paragraph">
<p>Spring提供了以下实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DelegatingSmartContextLoader</code> ：两个默认加载程序之一，它在内部委托给<code>AnnotationConfigContextLoader</code> ， 一种<code>GenericXmlContextLoader</code>或<code>GenericGroovyXmlContextLoader</code> ，取决于为测试类声明的配置或默认位置或默认配置类的存在。仅当Groovy在类路径上时才启用Groovy支持。</p>
</li>
<li>
<p><code>WebDelegatingSmartContextLoader</code> ：两个默认加载程序之一，它在内部委托给<code>AnnotationConfigWebContextLoader</code> ， 一种<code>GenericXmlWebContextLoader</code>或<code>GenericGroovyXmlWebContextLoader</code> ，取决于为测试类声明的配置或默认位置或默认配置类的存在。网路<code>ContextLoader</code>仅在以下情况下使用<code>@WebAppConfiguration</code>出现在测试班上。仅当Groovy在类路径上时才启用Groovy支持。</p>
</li>
<li>
<p><code>AnnotationConfigContextLoader</code> ：加载标准<code>ApplicationContext</code>从组件类。</p>
</li>
<li>
<p><code>AnnotationConfigWebContextLoader</code> ：加载一个<code>WebApplicationContext</code>从组件类。</p>
</li>
<li>
<p><code>GenericGroovyXmlContextLoader</code> ：加载标准<code>ApplicationContext</code>从Groovy脚本或XML配置文件的资源位置。</p>
</li>
<li>
<p><code>GenericGroovyXmlWebContextLoader</code> ：加载一个<code>WebApplicationContext</code>从Groovy脚本或XML配置文件的资源位置。</p>
</li>
<li>
<p><code>GenericXmlContextLoader</code> ：加载标准<code>ApplicationContext</code>从XML资源位置。</p>
</li>
<li>
<p><code>GenericXmlWebContextLoader</code> ：加载一个<code>WebApplicationContext</code>从XML资源位置。</p>
</li>
<li>
<p><code>GenericPropertiesContextLoader</code> ：加载标准<code>ApplicationContext</code>从Java属性文件。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-bootstrapping"><a class="anchor" href="#testcontext-bootstrapping"></a> 3.5.2。引导TestContext框架</h4>
<div class="paragraph">
<p>Spring TestContext Framework内部的默认配置足以应付所有常见用例。但是，有时开发团队或第三方框架希望更改默认值。 <code>ContextLoader</code> ，实施自定义<code>TestContext</code>要么<code>ContextCache</code> ，扩展默认的<code>ContextCustomizerFactory</code>和<code>TestExecutionListener</code>实现等等。为了对TestContext框架的运行方式进行低级控制，Spring提供了一种引导策略。</p>
</div>
<div class="paragraph">
<p><code>TestContextBootstrapper</code>定义用于引导TestContext框架的SPI。一种<code>TestContextBootstrapper</code>由<code>TestContextManager</code>加载<code>TestExecutionListener</code>当前测试的实现，并建立<code>TestContext</code>它管理。您可以使用以下命令为测试类（或测试类层次结构）配置自定义引导策略： <code>@BootstrapWith</code> ，直接或作为元注释。如果没有通过使用来显式配置引导程序<code>@BootstrapWith</code> ，或者<code>DefaultTestContextBootstrapper</code>或者<code>WebTestContextBootstrapper</code>是否使用，取决于是否存在<code>@WebAppConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>自从<code>TestContextBootstrapper</code> SPI将来可能会发生变化（以适应新的要求），我们强烈建议实施者不要直接实现此接口，而应该扩展<code>AbstractTestContextBootstrapper</code>或其具体子类之一。</p>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tel-config"><a class="anchor" href="#testcontext-tel-config"></a> 3.5.3。 <code>TestExecutionListener</code> 组态</h4>
<div class="paragraph">
<p>Spring提供以下内容<code>TestExecutionListener</code>默认情况下按以下顺序注册的实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServletTestExecutionListener</code> ：配置Servlet API模拟<code>WebApplicationContext</code> 。</p>
</li>
<li>
<p><code>DirtiesContextBeforeModesTestExecutionListener</code> ：处理<code>@DirtiesContext</code> “之前”模式的注释。</p>
</li>
<li>
<p><code>DependencyInjectionTestExecutionListener</code> ：为测试实例提供依赖项注入。</p>
</li>
<li>
<p><code>DirtiesContextTestExecutionListener</code> ：处理<code>@DirtiesContext</code> “之后”模式的注释。</p>
</li>
<li>
<p><code>TransactionalTestExecutionListener</code> ：提供具有默认回滚语义的事务测试执行。</p>
</li>
<li>
<p><code>SqlScriptsTestExecutionListener</code> ：运行使用以下命令配置的SQL脚本<code>@Sql</code>注解。</p>
</li>
<li>
<p><code>EventPublishingTestExecutionListener</code> ：将测试执行事件发布到测试的<code>ApplicationContext</code> （请参阅<a href="#testcontext-test-execution-events">测试执行事件</a> ）。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-registering-tels"><a class="anchor" href="#testcontext-tel-config-registering-tels"></a>注册<code>TestExecutionListener</code>实作</h5>
<div class="paragraph">
<p>您可以注册<code>TestExecutionListener</code>测试类及其子类的实现，方法是使用<code>@TestExecutionListeners</code>注解。请参阅<a href="#integration-testing-annotations">注释支持</a>和有关的Javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html"><code>@TestExecutionListeners</code></a>有关详细信息和示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-automatic-discovery"><a class="anchor" href="#testcontext-tel-config-automatic-discovery"></a>自动发现默认值<code>TestExecutionListener</code>实作</h5>
<div class="paragraph">
<p>注册<code>TestExecutionListener</code>通过使用实现<code>@TestExecutionListeners</code>适用于有限测试场景中使用的自定义侦听器。但是，如果需要在整个测试套件中使用自定义侦听器，则可能会变得很麻烦。通过支持自动发现默认值解决了此问题<code>TestExecutionListener</code>通过实施<code>SpringFactoriesLoader</code>机制。</p>
</div>
<div class="paragraph">
<p>具体来说， <code>spring-test</code>模块声明所有核心默认<code>TestExecutionListener</code>下的实现<code>org.springframework.test.context.TestExecutionListener</code>关键在于<code>META-INF/spring.factories</code>属性文件。第三方框架和开发人员可以贡献自己的力量<code>TestExecutionListener</code>默认侦听器列表通过自己的方式以相同的方式实现<code>META-INF/spring.factories</code>属性文件。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-ordering"><a class="anchor" href="#testcontext-tel-config-ordering"></a>定购<code>TestExecutionListener</code>实作</h5>
<div class="paragraph">
<p>当TestContext框架发现默认值时<code>TestExecutionListener</code>通过<a href="#testcontext-tel-config-automatic-discovery">上述</a>实现<code>SpringFactoriesLoader</code>机制，实例化的侦听器通过使用Spring的<code>AnnotationAwareOrderComparator</code> ，以纪念Spring的<code>Ordered</code>接口和<code>@Order</code>用于订购的注释。 <code>AbstractTestExecutionListener</code>和所有默认<code>TestExecutionListener</code> Spring实现提供的实现<code>Ordered</code>具有适当的值。因此，第三方框架和开发人员应确保其默认设置<code>TestExecutionListener</code>通过实施以正确的顺序注册实施<code>Ordered</code>或宣布<code>@Order</code> 。请参阅javadoc <code>getOrder()</code>核心默认方法<code>TestExecutionListener</code>有关为每个核心侦听器分配什么值的详细信息的实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tel-config-merging"><a class="anchor" href="#testcontext-tel-config-merging"></a>合并中<code>TestExecutionListener</code>实作</h5>
<div class="paragraph">
<p>如果是风俗<code>TestExecutionListener</code>通过注册<code>@TestExecutionListeners</code> ，则未注册默认侦听器。在大多数常见的测试方案中，这有效地迫使开发人员手动声明除任何自定义侦听器之外的所有默认侦听器。下面的清单演示了这种配置样式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestExecutionListeners(
    MyCustomTestExecutionListener::class,
    ServletTestExecutionListener::class,
    DirtiesContextBeforeModesTestExecutionListener::class,
    DependencyInjectionTestExecutionListener::class,
    DirtiesContextTestExecutionListener::class,
    TransactionalTestExecutionListener::class,
    SqlScriptsTestExecutionListener::class
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法的挑战在于，它要求开发人员确切地知道默认情况下注册了哪些侦听器。此外，默认的侦听器集可以在各个发行版之间变化-例如， <code>SqlScriptsTestExecutionListener</code>是在Spring Framework 4.1中引入的，并且<code>DirtiesContextBeforeModesTestExecutionListener</code>在Spring Framework 4.2中引入。此外，Spring Boot和Spring Security等第三方框架也注册了自己的默认框架。 <code>TestExecutionListener</code>通过使用上述<a href="#testcontext-tel-config-automatic-discovery">自动发现机制的实现</a> 。</p>
</div>
<div class="paragraph">
<p>为避免必须知道并重新声明所有默认侦听器，可以设置<code>mergeMode</code>的属性<code>@TestExecutionListeners</code>至<code>MergeMode.MERGE_WITH_DEFAULTS</code> 。
<code>MERGE_WITH_DEFAULTS</code>指示应将本地声明的侦听器与默认侦听器合并。合并算法可确保从列表中删除重复项，并确保根据的语义对合并的侦听器集进行排序。 <code>AnnotationAwareOrderComparator</code> ，如<a href="#testcontext-tel-config-ordering">订购中所述<code>TestExecutionListener</code>实现</a> 。如果侦听器实现<code>Ordered</code>或带有注释<code>@Order</code> ，它会影响与默认值合并的位置。否则，合并时，本地声明的侦听器将追加到默认侦听器列表中。</p>
</div>
<div class="paragraph">
<p>例如，如果<code>MyCustomTestExecutionListener</code>上一个示例中的类配置其<code>order</code>值（例如， <code>500</code> ）小于<code>ServletTestExecutionListener</code> （恰好是<code>1000</code> ）， <code>MyCustomTestExecutionListener</code>然后可以自动与前面的默认列表合并<code>ServletTestExecutionListener</code> ，并且前面的示例可以替换为以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestExecutionListeners(
        listeners = [MyCustomTestExecutionListener::class],
        mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-test-execution-events"><a class="anchor" href="#testcontext-test-execution-events"></a> 3.5.4。测试执行事件</h4>
<div class="paragraph">
<p>的<code>EventPublishingTestExecutionListener</code> Spring Framework 5.2中引入的方法提供了一种实现自定义的替代方法<code>TestExecutionListener</code> 。测试中的组件<code>ApplicationContext</code>可以收听由<code>EventPublishingTestExecutionListener</code> ，每个对应于<code>TestExecutionListener</code> API。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeTestClassEvent</code></p>
</li>
<li>
<p><code>PrepareTestInstanceEvent</code></p>
</li>
<li>
<p><code>BeforeTestMethodEvent</code></p>
</li>
<li>
<p><code>BeforeTestExecutionEvent</code></p>
</li>
<li>
<p><code>AfterTestExecutionEvent</code></p>
</li>
<li>
<p><code>AfterTestMethodEvent</code></p>
</li>
<li>
<p><code>AfterTestClassEvent</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这些事件仅在以下情况下发布： <code>ApplicationContext</code>已经加载。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这些事件可能由于各种原因而被消耗，例如重置模拟bean或跟踪测试执行。使用测试执行事件而不是实现自定义的优点之一<code>TestExecutionListener</code>测试执行事件可能被测试中注册的任何Spring bean所消耗<code>ApplicationContext</code> ，这样的bean可能会直接受益于依赖项注入和<code>ApplicationContext</code> 。相比之下， <code>TestExecutionListener</code>不是beans里的<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>为了监听测试执行事件，Spring bean可以选择实现<code>org.springframework.context.ApplicationListener</code>接口。另外，侦听器方法可以用<code>@EventListener</code>并配置为侦听上面列出的特定事件类型之一（请参阅<a href="core.html#context-functionality-events-annotation">基于注释的事件侦听器</a> ）。由于这种方法的流行，Spring提供了以下专用方法<code>@EventListener</code>注释，以简化测试执行事件侦听器的注册。这些注释位于<code>org.springframework.test.context.event.annotation</code>包。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@BeforeTestClass</code></p>
</li>
<li>
<p><code>@PrepareTestInstance</code></p>
</li>
<li>
<p><code>@BeforeTestMethod</code></p>
</li>
<li>
<p><code>@BeforeTestExecution</code></p>
</li>
<li>
<p><code>@AfterTestExecution</code></p>
</li>
<li>
<p><code>@AfterTestMethod</code></p>
</li>
<li>
<p><code>@AfterTestClass</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-test-execution-events-exception-handling"><a class="anchor" href="#testcontext-test-execution-events-exception-handling"></a>异常处理</h5>
<div class="paragraph">
<p>默认情况下，如果测试执行事件侦听器在使用事件时抛出异常，则该异常将传播到使用中的基础测试框架（例如JUnit或TestNG）。例如，如果消耗了<code>BeforeTestMethodEvent</code>导致异常，则相应的测试方法将因异常而失败。相反，如果异步测试执行事件侦听器引发异常，则该异常不会传播到基础测试框架。有关异步异常处理的更多详细信息，请查阅类级的javadoc以获取相关信息。 <code>@EventListener</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-test-execution-events-async"><a class="anchor" href="#testcontext-test-execution-events-async"></a>异步侦听器</h5>
<div class="paragraph">
<p>如果希望特定的测试执行事件侦听器异步处理事件，则可以使用Spring的<a href="integration.html#scheduling-annotation-support-async">常规<code>@Async</code>支持</a> 。有关更多详细信息，请参阅类级别的Javadoc以获取更多信息。 <code>@EventListener</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-ctx-management"><a class="anchor" href="#testcontext-ctx-management"></a> 3.5.5。上下文管理</h4>
<div class="paragraph">
<p>每<code>TestContext</code>为它负责的测试实例提供上下文管理和缓存支持。测试实例不会自动获得对已配置实例的访问权限<code>ApplicationContext</code> 。但是，如果测试类实现了<code>ApplicationContextAware</code>界面，对<code>ApplicationContext</code>提供给测试实例。注意<code>AbstractJUnit4SpringContextTests</code>和<code>AbstractTestNGSpringContextTests</code>实行<code>ApplicationContextAware</code>因此，可以访问<code>ApplicationContext</code>自动。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">@Autowired ApplicationContext</div>
<div class="paragraph">
<p>作为实施<code>ApplicationContextAware</code>介面，您可以透过插入测试类别的应用程式内容<code>@Autowired</code>字段或设置器方法上的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    ApplicationContext applicationContext;

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注入<code>ApplicationContext</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig
class MyTest {

    @Autowired <i class="conum" data-value="1"></i><b>(1)</b>
    lateinit var applicationContext: ApplicationContext

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注入<code>ApplicationContext</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>同样，如果您的测试配置为加载<code>WebApplicationContext</code> ，您可以将Web应用程序上下文注入测试中，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    WebApplicationContext wac;

    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>配置<code>WebApplicationContext</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入<code>WebApplicationContext</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig <i class="conum" data-value="1"></i><b>(1)</b>
class MyWebAppTest {

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    lateinit var wac: WebApplicationContext
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>配置<code>WebApplicationContext</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入<code>WebApplicationContext</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过使用依赖注入<code>@Autowired</code>由<code>DependencyInjectionTestExecutionListener</code> ，它是默认配置的（请参见<a href="#testcontext-fixture-di">测试治具的依赖注入</a> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用TestContext框架的测试类不需要扩展任何特定的类或实现特定的接口来配置其应用程序上下文。而是通过声明<code>@ContextConfiguration</code>类级别的注释。如果您的测试类未明确声明应用程序上下文资源位置或组件类，则已配置<code>ContextLoader</code>确定如何从默认位置或默认配置类加载上下文。除了上下文资源位置和组件类之外，还可以通过应用程序上下文初始化程序配置应用程序上下文。</p>
</div>
<div class="paragraph">
<p>以下各节说明如何使用Spring的<code>@ContextConfiguration</code>注释以配置测试<code>ApplicationContext</code>通过使用XML配置文件，Groovy脚本，组件类（通常是<code>@Configuration</code>类）或上下文初始值设定项。或者，您可以实施和配置自己的自定义<code>SmartContextLoader</code>用于高级用例。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#testcontext-ctx-management-xml">使用XML资源进行上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-groovy">使用Groovy脚本进行上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-javaconfig">使用组件类进行上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-mixed-config">混合XML，Groovy脚本和组件类</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-initializers">使用上下文初始化器进行上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-inheritance">上下文配置继承</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-env-profiles">使用环境配置文件进行上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-property-sources">具有测试属性源的上下文配置</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-web">正在加载<code>WebApplicationContext</code></a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-caching">上下文缓存</a></p>
</li>
<li>
<p><a href="#testcontext-ctx-management-ctx-hierarchies">上下文层次结构</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-xml"><a class="anchor" href="#testcontext-ctx-management-xml"></a>使用XML资源进行上下文配置</h5>
<div class="paragraph">
<p>加载<code>ApplicationContext</code>使用XML配置文件进行测试时，请使用<code>@ContextConfiguration</code>并配置<code>locations</code>属性带有一个数组，该数组包含XML配置元数据的资源位置。普通或相对路径（例如， <code>context.xml</code> ）被视为与定义测试类的包相关的类路径资源。以斜杠开头的路径被视为绝对类路径位置（例如， <code>/org/example/config.xml</code> ）。代表资源URL的路径（即，以前缀的路径<code>classpath:</code> ， <code>file:</code> ， <code>http:</code>等） <em>原样</em>使用。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将locations属性设置为XML文件列表。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将locations属性设置为XML文件列表。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>@ContextConfiguration</code>支持的别名<code>locations</code>通过标准Java属性<code>value</code>属性。因此，如果您不需要在中声明其他属性<code>@ContextConfiguration</code> ，您可以省略<code>locations</code>属性名称并使用以下示例中演示的速记格式声明资源位置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定XML文件而不使用<code>location</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextConfiguration("/app-config.xml", "/test-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定XML文件而不使用<code>location</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您同时忽略了<code>locations</code>和<code>value</code>来自的属性<code>@ContextConfiguration</code>注释，TestContext框架尝试检测默认的XML资源位置。特别， <code>GenericXmlContextLoader</code>和<code>GenericXmlWebContextLoader</code>根据测试类的名称检测默认位置。如果您的班级命名<code>com.example.MyTest</code> ， <code>GenericXmlContextLoader</code>从加载您的应用程序上下文<code>"classpath:com/example/MyTest-context.xml"</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从默认位置加载配置。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从默认位置加载配置。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-groovy"><a class="anchor" href="#testcontext-ctx-management-groovy"></a>使用Groovy脚本进行上下文配置</h5>
<div class="paragraph">
<p>加载<code>ApplicationContext</code>通过使用使用<a href="core.html#groovy-bean-definition-dsl">Groovy Bean定义DSL的</a> Groovy脚本进行测试，您可以使用以下方法注释测试类： <code>@ContextConfiguration</code>并配置<code>locations</code>要么<code>value</code>属性，该数组包含Groovy脚本的资源位置。Groovy脚本的资源查找语义与针对<a href="#testcontext-ctx-management-xml">XML配置文件</a>描述的语义相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">启用Groovy脚本支持</div>支持使用Groovy脚本加载<code>ApplicationContext</code>如果Groovy在类路径上，则会自动启用Spring TestContext Framework中的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例显示如何指定Groovy配置文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration("/AppConfig.groovy", "/TestConfig.Groovy") <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定Groovy配置文件的位置。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您同时忽略了<code>locations</code>和<code>value</code>来自的属性<code>@ContextConfiguration</code>注释，TestContext框架尝试检测默认的Groovy脚本。特别， <code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>根据测试类的名称检测默认位置。如果您的班级命名<code>com.example.MyTest</code> ，Groovy上下文加载器从<code>"classpath:com/example/MyTestContext.groovy"</code> 。以下示例显示如何使用默认值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从默认位置加载配置。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从默认位置加载配置。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">同时声明XML配置和Groovy脚本</div>
<div class="paragraph">
<p>您可以使用来同时声明XML配置文件和Groovy脚本。 <code>locations</code>要么<code>value</code>的属性<code>@ContextConfiguration</code> 。如果到已配置资源位置的路径以<code>.xml</code> ，它是通过使用<code>XmlBeanDefinitionReader</code> 。否则，将使用<code>GroovyBeanDefinitionReader</code> 。</p>
</div>
<div class="paragraph">
<p>以下清单显示了如何在集成测试中将两者结合在一起：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration("/app-config.xml", "/TestConfig.groovy")
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-javaconfig"><a class="anchor" href="#testcontext-ctx-management-javaconfig"></a>使用组件类进行上下文配置</h5>
<div class="paragraph">
<p>加载<code>ApplicationContext</code>对于使用组件类的测试（请参阅<a href="core.html#beans-java">基于Java的容器配置</a> ），您可以使用<code>@ContextConfiguration</code>并配置<code>classes</code>属性，该数组包含对组件类的引用。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定组件类。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定组件类。</td>
</tr>
</tbody></table>
</div>
<div id="testcontext-ctx-management-javaconfig-component-classes" class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">组件类别</div>
<div class="paragraph">
<p>术语“组件类”可以指以下任何一种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>带有注释的类<code>@Configuration</code> 。</p>
</li>
<li>
<p>组件（即带有注释的类<code>@Component</code> ， <code>@Service</code> ， <code>@Repository</code>或其他构造型注释）。</p>
</li>
<li>
<p>与JSR-330兼容的类，带有注释<code>javax.inject</code>注释。</p>
</li>
<li>
<p>任何包含以下内容的类<code>@Bean</code> -方法。</p>
</li>
<li>
<p>打算注册为Spring组件的任何其他类（即， <code>ApplicationContext</code> ），可能会利用单个构造函数的自动自动装配功能，而无需使用Spring注释。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>见的javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>有关组件类的配置和语义的更多信息，请特别注意<code>@Bean</code>精简模式。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您省略<code>classes</code>来自的属性<code>@ContextConfiguration</code>注释，TestContext框架尝试检测默认配置类的存在。特别， <code>AnnotationConfigContextLoader</code>和<code>AnnotationConfigWebContextLoader</code>全部检测<code>static</code>符合配置类实现要求的测试类的嵌套类，如<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> javadoc。请注意，配置类的名称是任意的。此外，一个测试类可以包含多个<code>static</code>如果需要，则嵌套配置类。在以下示例中， <code>OrderServiceTest</code>类声明一个<code>static</code>嵌套的配置类名为<code>Config</code>自动用于加载<code>ApplicationContext</code>对于测试班：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从嵌套中加载配置信息<code>Config</code>类。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig <i class="conum" data-value="1"></i><b>(1)</b>
// ApplicationContext will be loaded from the nested Config class
class OrderServiceTest {

    @Autowired
    lateinit var orderService: OrderService

    @Configuration
    class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        fun orderService(): OrderService {
            // set properties, etc.
            return OrderServiceImpl()
        }
    }

    @Test
    fun testOrderService() {
        // test the orderService
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>从嵌套中加载配置信息<code>Config</code>类。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-mixed-config"><a class="anchor" href="#testcontext-ctx-management-mixed-config"></a>混合XML，Groovy脚本和组件类</h5>
<div class="paragraph">
<p>有时可能需要混合XML配置文件，Groovy脚本和组件类（通常是<code>@Configuration</code>类）来配置<code>ApplicationContext</code>为您的测试。例如，如果您在生产中使用XML配置，则可以决定要使用<code>@Configuration</code>类来为测试配置特定的Spring托管组件，反之亦然。</p>
</div>
<div class="paragraph">
<p>此外，某些第三方框架（例如Spring Boot）为加载程序提供了一流的支持。 <code>ApplicationContext</code>同时来自不同类型的资源（例如，XML配置文件，Groovy脚本和<code>@Configuration</code>类）。过去，Spring Framework 不支持此标准部署。因此，大多数<code>SmartContextLoader</code> Spring Framework 在<code>spring-test</code>每个测试上下文模块仅支持一种资源类型。但是，这并不意味着您不能同时使用两者。一般规则的一个例外是<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>同时支持XML配置文件和Groovy脚本。此外，第三方框架可以选择支持两者的声明<code>locations</code>和<code>classes</code>通过<code>@ContextConfiguration</code> ，并且借助TestContext框架中的标准测试支持，您可以选择以下选项。</p>
</div>
<div class="paragraph">
<p>如果要使用资源位置（例如XML或Groovy），请<code>@Configuration</code>这些类来配置测试，您必须选择一个作为入口点，并且其中一个必须包含或导入另一个。例如，在XML或Groovy脚本中，您可以包括<code>@Configuration</code>类，方法是使用组件扫描或将它们定义为普通的Spring Bean，而在<code>@Configuration</code>类，您可以使用<code>@ImportResource</code>导入XML配置文件或Groovy脚本。请注意，此行为在语义上等同于您在生产环境中配置应用程序的方式：在生产配置中，您可以定义一组XML或Groovy资源位置或一组<code>@Configuration</code>您制作的课程<code>ApplicationContext</code>已加载，但您仍然可以自由包含或导入其他类型的配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-initializers"><a class="anchor" href="#testcontext-ctx-management-initializers"></a>使用上下文初始化器进行上下文配置</h5>
<div class="paragraph">
<p>配置一个<code>ApplicationContext</code>通过使用上下文初始化器进行测试，请使用<code>@ContextConfiguration</code>并配置<code>initializers</code>具有数组的属性，该数组包含对实现类的引用<code>ApplicationContextInitializer</code> 。然后，使用声明的上下文初始值设定项来初始化<code>ConfigurableApplicationContext</code>已为您的测试加载。注意具体<code>ConfigurableApplicationContext</code>每个声明的初始值设定项支持的类型必须与的类型兼容<code>ApplicationContext</code>由创建<code>SmartContextLoader</code>使用中（通常是<code>GenericApplicationContext</code> ）。此外，初始化程序的调用顺序取决于它们是否实现Spring的<code>Ordered</code>介面或以Spring的注解<code>@Order</code>注释或标准<code>@Priority</code>注解。以下示例显示如何使用初始化程序：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用配置类和初始化程序指定配置。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
        classes = [TestConfig::class],
        initializers = [TestAppCtxInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用配置类和初始化程序指定配置。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您也可以在以下位置省略XML配置文件，Groovy脚本或组件类的声明。 <code>@ContextConfiguration</code>完全而不是只声明<code>ApplicationContextInitializer</code>类，然后负责在上下文中注册Bean，例如，通过编程方式从XML文件或配置类加载Bean定义。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = EntireAppInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>仅使用初始化程序来指定配置。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = [EntireAppInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>仅使用初始化程序来指定配置。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-inheritance"><a class="anchor" href="#testcontext-ctx-management-inheritance"></a>上下文配置继承</h5>
<div class="paragraph">
<p><code>@ContextConfiguration</code>支持布尔<code>inheritLocations</code>和<code>inheritInitializers</code>表示是否应继承资源位置或由超类声明的组件类和上下文初始化程序的属性。这两个标志的默认值为<code>true</code> 。这意味着测试类将继承资源位置或组件类以及任何超类声明的上下文初始化器。具体地说，将测试类的资源位置或组件类附加到由超类声明的资源位置或带注释的类的列表中。同样，将给定测试类的初始化程序添加到由测试超类定义的初始化程序集。因此，子类可以选择扩展资源位置，组件类或上下文初始化程序。</p>
</div>
<div class="paragraph">
<p>如果<code>inheritLocations</code>要么<code>inheritInitializers</code>归因于<code>@ContextConfiguration</code>被设定为<code>false</code> ，分别是测试类影子的资源位置或组件类以及上下文初始化器，并有效地替换了超类定义的配置。</p>
</div>
<div class="paragraph">
<p>在下一个使用XML资源位置的示例中， <code>ApplicationContext</code>对于<code>ExtendedTest</code>从加载<code>base-config.xml</code>和<code>extended-config.xml</code> ， 以该顺序。定义于<code>extended-config.xml</code>因此可以覆盖（即替换） <code>base-config.xml</code> 。以下示例显示一个类如何扩展另一个类并使用其自己的配置文件和超类的配置文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在超类中定义的配置文件。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>子类中定义的配置文件。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在超类中定义的配置文件。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>子类中定义的配置文件。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>同样，在下一个使用组件类的示例中， <code>ApplicationContext</code>对于<code>ExtendedTest</code>从加载<code>BaseConfig</code>和<code>ExtendedConfig</code>类，按此顺序。定义于<code>ExtendedConfig</code>因此可以覆盖（即替换） <code>BaseConfig</code> 。以下示例显示一个类如何扩展另一个类，并同时使用其自己的配置类和超类的配置类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在超类中定义的配置类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在子类中定义的配置类。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig::class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在超类中定义的配置类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在子类中定义的配置类。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在下一个使用上下文初始化程序的示例中， <code>ApplicationContext</code>对于<code>ExtendedTest</code>通过使用初始化<code>BaseInitializer</code>和<code>ExtendedInitializer</code> 。但是请注意，初始化程序的调用顺序取决于它们是否实现Spring的<code>Ordered</code>介面或以Spring的注解<code>@Order</code>注释或标准<code>@Priority</code>注解。下面的示例显示一个类如何扩展另一个类，并同时使用其自己的初始化程序和超类的初始化程序：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = BaseInitializer.class) <i class="conum" data-value="1"></i><b>(1)</b>
class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = ExtendedInitializer.class) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest extends BaseTest {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在超类中定义的初始化程序。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>子类中定义的初始化程序。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = [BaseInitializer::class]) <i class="conum" data-value="1"></i><b>(1)</b>
open class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = [ExtendedInitializer::class]) <i class="conum" data-value="2"></i><b>(2)</b>
class ExtendedTest : BaseTest() {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>在超类中定义的初始化程序。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>子类中定义的初始化程序。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-env-profiles"><a class="anchor" href="#testcontext-ctx-management-env-profiles"></a>使用环境配置文件进行上下文配置</h5>
<div class="paragraph">
<p>Spring Framework 对环境和配置文件（又称为“ bean定义配置文件”）的概念提供了一流的支持，并且可以配置集成测试以针对各种测试场景激活特定的bean定义配置文件。这可以通过使用<code>@ActiveProfiles</code>注释，并提供加载配置文件时应激活的配置文件列表<code>ApplicationContext</code>进行测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以使用<code>@ActiveProfiles</code>与任何实施<code>SmartContextLoader</code> SPI，但是<code>@ActiveProfiles</code>较早版本的实现不支持<code>ContextLoader</code> SPI。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑两个使用XML配置的示例， <code>@Configuration</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- app-config.xml --&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;bean id="transferService"
            class="com.bank.service.internal.DefaultTransferService"&gt;
        &lt;constructor-arg ref="accountRepository"/&gt;
        &lt;constructor-arg ref="feePolicy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="accountRepository"
            class="com.bank.repository.internal.JdbcAccountRepository"&gt;
        &lt;constructor-arg ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="feePolicy"
        class="com.bank.service.internal.ZeroFeePolicy"/&gt;

    &lt;beans profile="dev"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/test-data.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile="production"&gt;
        &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
    &lt;/beans&gt;

    &lt;beans profile="default"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么时候<code>TransferServiceTest</code>运行，其<code>ApplicationContext</code>从加载<code>app-config.xml</code>配置文件位于类路径的根目录中。如果您检查<code>app-config.xml</code> ，您可以看到<code>accountRepository</code> Bean依赖于<code>dataSource</code> bean 。然而， <code>dataSource</code>未定义为顶级bean。代替， <code>dataSource</code>被定义了三遍： <code>production</code>个人资料，在<code>dev</code>个人资料，然后在<code>default</code>轮廓。</p>
</div>
<div class="paragraph">
<p>通过注释<code>TransferServiceTest</code>与<code>@ActiveProfiles("dev")</code> ，我们指示Spring TestContext Framework加载<code>ApplicationContext</code>活动配置文件设置为<code>{"dev"}</code> 。结果，创建了一个嵌入式数据库，并在其中填充了测试数据，并且<code>accountRepository</code> bean与开发相关联<code>DataSource</code> 。这可能是我们在集成测试中想要的。</p>
</div>
<div class="paragraph">
<p>有时将bean分配给<code>default</code>轮廓。仅当没有专门激活其他配置文件时，才包含默认配置文件中的Bean。您可以使用它来定义在应用程序的默认状态下使用的“后备” bean。例如，您可以显式提供一个数据源<code>dev</code>和<code>production</code>配置文件，但当两者都不处于活动状态时，将内存中的数据源定义为默认数据源。</p>
</div>
<div class="paragraph">
<p>以下代码清单演示了如何通过以下方式实现相同的配置和集成测试<code>@Configuration</code>类而不是XML：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("dev")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@Profile("dev")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class TransferServiceConfig {

    @Autowired
    lateinit var dataSource: DataSource

    @Bean
    fun transferService(): TransferService {
        return DefaultTransferService(accountRepository(), feePolicy())
    }

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }

    @Bean
    fun feePolicy(): FeePolicy {
        return ZeroFeePolicy()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此变体中，我们将XML配置分为四个独立的<code>@Configuration</code>类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransferServiceConfig</code> ：获取一个<code>dataSource</code>通过使用依赖注入<code>@Autowired</code> 。</p>
</li>
<li>
<p><code>StandaloneDataConfig</code> ：定义一个<code>dataSource</code>适用于开发人员测试的嵌入式数据库。</p>
</li>
<li>
<p><code>JndiDataConfig</code> ：定义一个<code>dataSource</code>是在生产环境中从JNDI检索的。</p>
</li>
<li>
<p><code>DefaultDataConfig</code> ：定义一个<code>dataSource</code>对于默认的嵌入式数据库，如果没有配置文件处于活动状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与基于XML的配置示例一样，我们仍然注释<code>TransferServiceTest</code>与<code>@ActiveProfiles("dev")</code> ，但是这次我们使用来指定所有四个配置类<code>@ContextConfiguration</code>注解。测试类的主体本身保持完全不变。</p>
</div>
<div class="paragraph">
<p>通常，在给定项目中跨多个测试类使用一组概要文件。因此，为避免重复声明<code>@ActiveProfiles</code>注释，您可以声明<code>@ActiveProfiles</code>一旦在基类上，子类就会自动继承<code>@ActiveProfiles</code>从基类进行配置。在下面的示例中， <code>@ActiveProfiles</code> （以及其他注释）已移至抽象超类， <code>AbstractIntegrationTest</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(
        TransferServiceConfig::class,
        StandaloneDataConfig::class,
        JndiDataConfig::class,
        DefaultDataConfig::class)
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// "dev" profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// "dev" profile inherited from superclass
class TransferServiceTest : AbstractIntegrationTest() {

    @Autowired
    lateinit var transferService: TransferService

    @Test
    fun testTransferService() {
        // test the transferService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ActiveProfiles</code>还支持<code>inheritProfiles</code>可用于禁用活动配置文件继承的属性，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// "dev" profile overridden with "production"
@ActiveProfiles(profiles = "production", inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// "dev" profile overridden with "production"
@ActiveProfiles("production", inheritProfiles = false)
class ProductionTransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
</div>
</div>
<div id="testcontext-ctx-management-env-profiles-ActiveProfilesResolver" class="paragraph">
<p>此外，有时有必要以编程方式而不是以声明方式来解析测试的活动配置文件，例如，基于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当前的操作系统。</p>
</li>
<li>
<p>是否在持续集成构建服务器上执行测试。</p>
</li>
<li>
<p>存在某些环境变量。</p>
</li>
<li>
<p>自定义类级别注释的存在。</p>
</li>
<li>
<p>其他问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要以编程方式解析活动的Bean定义配置文件，您可以实施自定义<code>ActiveProfilesResolver</code>并使用注册<code>resolver</code>的属性<code>@ActiveProfiles</code> 。有关更多信息，请参见相应的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">javadoc</a> 。以下示例演示了如何实现和注册自定义<code>OperatingSystemActiveProfilesResolver</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver::class,
        inheritProfiles = false)
class TransferServiceTest : AbstractIntegrationTest() {
    // test body
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class&lt;?&gt; testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class OperatingSystemActiveProfilesResolver : ActiveProfilesResolver {

    override fun resolve(testClass: Class&lt;*&gt;): Array&lt;String&gt; {
        val profile: String = ...
        // determine the value of profile based on the operating system
        return arrayOf(profile)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-property-sources"><a class="anchor" href="#testcontext-ctx-management-property-sources"></a>具有测试属性源的上下文配置</h5>
<div class="paragraph">
<p>Spring Framework对具有属性源层次结构的环境的概念提供了一流的支持，您可以使用特定于测试的属性源配置集成测试。与之相反<code>@PropertySource</code>用于的注释<code>@Configuration</code>类，您可以声明<code>@TestPropertySource</code>测试类上的注释，以声明测试属性文件或内联属性的资源位置。这些测试属性源被添加到<code>PropertySources</code>在里面<code>Environment</code>为了<code>ApplicationContext</code>已加载以用于带注释的集成测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用<code>@TestPropertySource</code>与任何实施<code>SmartContextLoader</code> SPI，但是<code>@TestPropertySource</code>较早版本的实现不支持<code>ContextLoader</code> SPI。</p>
</div>
<div class="paragraph">
<p>的实现<code>SmartContextLoader</code>通过以下方式访问合并的测试属性源值： <code>getPropertySourceLocations()</code>和<code>getPropertySourceProperties()</code>方法中<code>MergedContextConfiguration</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="declaring-test-property-sources"><a class="anchor" href="#declaring-test-property-sources"></a>声明测试属性源</h6>
<div class="paragraph">
<p>您可以使用以下命令配置测试属性文件<code>locations</code>要么<code>value</code>的属性<code>@TestPropertySource</code> 。</p>
</div>
<div class="paragraph">
<p>支持传统属性文件格式和基于XML的属性文件格式，例如， <code>"classpath:/com/example/test.properties"</code>要么<code>"file:///path/to/file.xml"</code> 。</p>
</div>
<div class="paragraph">
<p>每个路径都被解释为一个Spring <code>Resource</code> 。一条普通路径（例如， <code>"test.properties"</code> ）被视为与定义测试类的包相关的类路径资源。以斜杠开头的路径被视为绝对类路径资源（例如： <code>"/org/example/test.xml"</code> ）。引用URL的路径（例如，前缀为的路径<code>classpath:</code> ， <code>file:</code> ， 要么<code>http:</code> ）是通过使用指定的资源协议加载的。资源位置通配符（例如<code><strong>*/</strong>.properties</code> ）是不允许的：每个位置的评估结果必须完全相同<code>.properties</code>要么<code>.xml</code>资源。</p>
</div>
<div class="paragraph">
<p>以下示例使用测试属性文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定具有绝对路径的属性文件。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestPropertySource("/test.properties") <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定具有绝对路径的属性文件。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用键值对的形式配置内联属性<code>properties</code>的属性<code>@TestPropertySource</code> ，如下面的示例所示。所有键值对均已添加到附件中<code>Environment</code>作为一次测试<code>PropertySource</code>具有最高的优先级。</p>
</div>
<div class="paragraph">
<p>键值对支持的语法与为Java属性文件中的条目定义的语法相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key=value</code></p>
</li>
<li>
<p><code>key:value</code></p>
</li>
<li>
<p><code>key value</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的示例设置两个内联属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>通过使用键值语法的两种变体来设置两个属性。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestPropertySource(properties = ["timezone = GMT", "port: 4242"]) <i class="conum" data-value="1"></i><b>(1)</b>
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>通过使用键值语法的两种变体来设置两个属性。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 5.2开始， <code>@TestPropertySource</code>可以用作<em>可重复注释</em> 。那意味着你可以有多个声明<code>@TestPropertySource</code>在一个测试班上， <code>locations</code>和<code>properties</code>从以后<code>@TestPropertySource</code>注释覆盖了以前的注释<code>@TestPropertySource</code>注释。</p>
</div>
<div class="paragraph">
<p>此外，您可以在一个测试类上声明多个组成的注释，每个注释都用meta注释<code>@TestPropertySource</code> ，以及所有这些<code>@TestPropertySource</code>声明将有助于您的测试属性来源。</p>
</div>
<div class="paragraph">
<p>直接存在<code>@TestPropertySource</code>注释总是优先于元存在<code>@TestPropertySource</code>注释。换一种说法， <code>locations</code>和<code>properties</code>来自直接存在<code>@TestPropertySource</code>注释将覆盖<code>locations</code>和<code>properties</code>从一个<code>@TestPropertySource</code>注释用作元注释。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="default-properties-file-detection"><a class="anchor" href="#default-properties-file-detection"></a>默认属性文件检测</h6>
<div class="paragraph">
<p>如果<code>@TestPropertySource</code>被声明为空注释（也就是说，对于<code>locations</code>要么<code>properties</code>属性），尝试检测相对于声明注释的类的默认属性文件。例如，如果带注释的测试类是<code>com.example.MyTest</code> ，相应的默认属性文件是<code>classpath:com/example/MyTest.properties</code> 。如果无法检测到默认值，则<code>IllegalStateException</code>被抛出。</p>
</div>
</div>
<div class="sect5">
<h6 id="precedence"><a class="anchor" href="#precedence"></a>优先顺序</h6>
<div class="paragraph">
<p>测试属性源的优先级高于从操作系统环境，Java系统属性或应用程序以声明方式添加的属性源加载的那些优先级<code>@PropertySource</code>或以编程方式因此，测试属性源可用于选择性覆盖系统和应用程序属性源中定义的属性。此外，内联属性比从资源位置加载的属性具有更高的优先级。</p>
</div>
<div class="paragraph">
<p>在下一个示例中， <code>timezone</code>和<code>port</code>属性以及在中定义的任何属性<code>"/test.properties"</code>覆盖在系统和应用程序属性源中定义的相同名称的所有属性。此外，如果<code>"/test.properties"</code>文件定义了<code>timezone</code>和<code>port</code>被使用声明的内联属性覆盖的属性<code>properties</code>属性。以下示例显示如何在文件和内联中指定属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration
@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration
@TestPropertySource("/test.properties",
        properties = ["timezone = GMT", "port: 4242"]
)
class MyIntegrationTests {
    // class body...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="inheriting-and-overriding-test-property-sources"><a class="anchor" href="#inheriting-and-overriding-test-property-sources"></a>继承和覆盖测试属性源</h6>
<div class="paragraph">
<p><code>@TestPropertySource</code>支持布尔<code>inheritLocations</code>和<code>inheritProperties</code>表示是否应继承属性文件和超类声明的内联属性的资源位置的属性。这两个标志的默认值为<code>true</code> 。这意味着测试类将继承任何超类声明的位置和内联属性。具体来说，将测试类的位置和内联属性附加到超类声明的位置和内联属性中。因此，子类可以选择扩展位置和内联属性。请注意，稍后出现的属性会阴影（即，覆盖）之前出现的相同名称的属性。此外，上述优先规则也适用于继承的测试属性源。</p>
</div>
<div class="paragraph">
<p>如果<code>inheritLocations</code>要么<code>inheritProperties</code>归因于<code>@TestPropertySource</code>被设定为<code>false</code> ，分别为测试类阴影的位置或内联属性，并有效替换超类定义的配置。</p>
</div>
<div class="paragraph">
<p>在下一个示例中， <code>ApplicationContext</code>对于<code>BaseTest</code>仅使用<code>base.properties</code>文件作为测试属性源。相反， <code>ApplicationContext</code>对于<code>ExtendedTest</code>通过使用加载<code>base.properties</code>和<code>extended.properties</code>文件作为测试属性源位置。下面的示例显示如何通过使用来定义子类及其父类中的属性<code>properties</code>文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@TestPropertySource("base.properties")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@TestPropertySource("base.properties")
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一个示例中， <code>ApplicationContext</code>对于<code>BaseTest</code>仅使用内联加载<code>key1</code>属性。相反， <code>ApplicationContext</code>对于<code>ExtendedTest</code>通过使用内联加载<code>key1</code>和<code>key2</code>属性。下面的示例演示如何通过使用内联属性在子类及其父类中定义属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@TestPropertySource(properties = "key1 = value1")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(properties = "key2 = value2")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@TestPropertySource(properties = ["key1 = value1"])
@ContextConfiguration
open class BaseTest {
    // ...
}

@TestPropertySource(properties = ["key2 = value2"])
@ContextConfiguration
class ExtendedTest : BaseTest() {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-web"><a class="anchor" href="#testcontext-ctx-management-web"></a>正在加载<code>WebApplicationContext</code></h5>
<div class="paragraph">
<p>指示TestContext框架加载一个<code>WebApplicationContext</code>代替标准<code>ApplicationContext</code> ，您可以使用注释相应的测试类<code>@WebAppConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>存在<code>@WebAppConfiguration</code>测试类上的代码指示TestContext框架（TCF） <code>WebApplicationContext</code> （WAC）应该被加载以进行集成测试。在后台，TCF确保<code>MockServletContext</code>创建并提供给测试的WAC。默认情况下，您的基本资源路径<code>MockServletContext</code>被设定为<code>src/main/webapp</code> 。这被解释为相对于JVM根目录的路径（通常是项目的路径）。如果您熟悉Maven项目中Web应用程序的目录结构，则知道<code>src/main/webapp</code>是WAR根目录的默认位置。如果您需要覆盖此默认设置，则可以提供替代路径<code>@WebAppConfiguration</code>注释（例如， <code>@WebAppConfiguration("src/test/webapp")</code> ）。如果您希望从类路径而不是文件系统中引用基本资源路径，则可以使用Spring的<code>classpath:</code>字首。</p>
</div>
<div class="paragraph">
<p>请注意，Spring的测试支持<code>WebApplicationContext</code>实现与其对标准的支持相当<code>ApplicationContext</code>实现。当用<code>WebApplicationContext</code> ，您可以自由声明XML配置文件，Groovy脚本或<code>@Configuration</code>通过使用类<code>@ContextConfiguration</code> 。您还可以自由使用任何其他测试注释，例如<code>@ActiveProfiles</code> ， <code>@TestExecutionListeners</code> ， <code>@Sql</code> ， <code>@Rollback</code> ， 和别的。</p>
</div>
<div class="paragraph">
<p>本节中的其余示例显示了一些用于加载文件的各种配置选项。 <code>WebApplicationContext</code> 。以下示例显示了TestContext框架对配置约定的支持：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您用注释测试班<code>@WebAppConfiguration</code>在不指定资源基本路径的情况下，资源路径实际上默认为<code>file:src/main/webapp</code> 。同样，如果您声明<code>@ContextConfiguration</code>没有指定资源<code>locations</code> ， 零件<code>classes</code>或上下文<code>initializers</code> ，Spring会尝试通过使用约定（即， <code>WacTests-context.xml</code>与<code>WacTests</code>类或静态嵌套<code>@Configuration</code>类）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用以下命令显式声明资源基础路径： <code>@WebAppConfiguration</code>和一个XML资源位置<code>@ContextConfiguration</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里要注意的重要一点是具有这两个注释的路径的语义不同。默认， <code>@WebAppConfiguration</code>资源路径基于文件系统，而<code>@ContextConfiguration</code>资源位置基于类路径。</p>
</div>
<div class="paragraph">
<p>下面的示例显示，我们可以通过指定Spring资源前缀来覆盖两个注释的默认资源语义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将本示例中的注释与上一个示例进行对比。</p>
</div>
<div class="openblock">
<div class="title"><a id="testcontext-ctx-management-web-mocks"></a>使用网络模拟</div>
<div class="content">
<div class="paragraph">
<p>为了提供全面的Web测试支持，TestContext框架提供了一个<code>ServletTestExecutionListener</code>默认情况下启用。当针对<code>WebApplicationContext</code> ， 这个<a href="#testcontext-key-abstractions"><code>TestExecutionListener</code></a>使用Spring Web设置默认的线程本地状态<code>RequestContextHolder</code>在每种测试方法之前创建一个<code>MockHttpServletRequest</code> ， 一种<code>MockHttpServletResponse</code>和<code>ServletWebRequest</code>基于配置的基本资源路径<code>@WebAppConfiguration</code> 。 <code>ServletTestExecutionListener</code>还可以确保<code>MockHttpServletResponse</code>和<code>ServletWebRequest</code>可以注入到测试实例中，一旦测试完成，它将清除线程本地状态。</p>
</div>
<div class="paragraph">
<p>一旦你有一个<code>WebApplicationContext</code>在为测试加载后，您可能会发现需要与Web模拟进行交互-例如，设置测试夹具或在调用Web组件后执行声明。以下示例显示可以将哪些模拟自动连接到您的测试实例。请注意<code>WebApplicationContext</code>和<code>MockServletContext</code>都缓存在测试套件中，而其他模拟则由测试方法按测试方法进行管理<code>ServletTestExecutionListener</code> 。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig
class WacTests {

    @Autowired
    lateinit var wac: WebApplicationContext // cached

    @Autowired
    lateinit var servletContext: MockServletContext // cached

    @Autowired
    lateinit var session: MockHttpSession

    @Autowired
    lateinit var request: MockHttpServletRequest

    @Autowired
    lateinit var response: MockHttpServletResponse

    @Autowired
    lateinit var webRequest: ServletWebRequest

    //...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-caching"><a class="anchor" href="#testcontext-ctx-management-caching"></a>上下文缓存</h5>
<div class="paragraph">
<p>一旦TestContext框架加载了<code>ApplicationContext</code> （要么<code>WebApplicationContext</code> ）进行测试时，该上下文将被缓存，并在所有随后的测试中重复使用，这些后续测试在同一测试套件中声明了相同的唯一上下文配置。要了解缓存的工作原理，重要的是要了解“唯一”和“测试套件”的含义。</p>
</div>
<div class="paragraph">
<p>一个<code>ApplicationContext</code>可以通过用于加载它的配置参数的组合来唯一标识。因此，配置参数的唯一组合用于生成一个密钥，在该密钥下缓存上下文。TestContext框架使用以下配置参数来构建上下文缓存键：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>locations</code> （从<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>classes</code> （从<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>contextInitializerClasses</code> （从<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>contextCustomizers</code> （从<code>ContextCustomizerFactory</code> ）</p>
</li>
<li>
<p><code>contextLoader</code> （从<code>@ContextConfiguration</code> ）</p>
</li>
<li>
<p><code>parent</code> （从<code>@ContextHierarchy</code> ）</p>
</li>
<li>
<p><code>activeProfiles</code> （从<code>@ActiveProfiles</code> ）</p>
</li>
<li>
<p><code>propertySourceLocations</code> （从<code>@TestPropertySource</code> ）</p>
</li>
<li>
<p><code>propertySourceProperties</code> （从<code>@TestPropertySource</code> ）</p>
</li>
<li>
<p><code>resourceBasePath</code> （从<code>@WebAppConfiguration</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，如果<code>TestClassA</code>指定<code>{"app-config.xml", "test-config.xml"}</code>为了<code>locations</code> （要么<code>value</code> ）的属性<code>@ContextConfiguration</code> ，TestContext框架会加载相应的<code>ApplicationContext</code>并将其存储在<code>static</code>仅基于那些位置的键下的上下文高速缓存。因此，如果<code>TestClassB</code>也定义<code>{"app-config.xml", "test-config.xml"}</code>其位置（通过继承显式或隐式），但未定义<code>@WebAppConfiguration</code> ， 不同的<code>ContextLoader</code> ，不同的活动配置文件，不同的上下文初始化器，不同的测试属性源或不同的父上下文，然后相同<code>ApplicationContext</code>由两个测试类共享。这意味着加载应用程序上下文的设置成本仅发生一次（每个测试套件），并且随后的测试执行要快得多。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">测试套件和分叉过程</div>
<div class="paragraph">
<p>Spring TestContext框架将应用程序上下文存储在静态缓存中。这意味着上下文实际上存储在<code>static</code>变量。换句话说，如果测试是在单独的进程中执行的，则在每次测试执行之间都会清除静态缓存，从而有效地禁用了缓存机制。</p>
</div>
<div class="paragraph">
<p>为了从缓存机制中受益，所有测试必须在同一进程或测试套件中运行。这可以通过在IDE中以组的形式执行所有测试来实现。同样，在使用诸如Ant，Maven或Gradle之类的构建框架执行测试时，务必确保该构建框架不会在测试之间分叉。例如，如果<a href="https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode"><code>forkMode</code></a>将Maven Surefire插件设置为<code>always</code>要么<code>pertest</code> ，TestContext框架无法在测试类之间缓存应用程序上下文，因此构建过程的运行速度明显降低。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>上下文缓存的大小以默认的最大大小32为界。只要达到最大大小，就会使用最近最少使用（LRU）驱逐策略来驱逐和关闭陈旧的上下文。您可以通过设置名为的JVM系统属性，从命令行或构建脚本中配置最大大小。 <code>spring.test.context.cache.maxSize</code> 。另外，您也可以使用<code>SpringProperties</code> API。</p>
</div>
<div class="paragraph">
<p>由于在给定的测试套件中加载大量的应用程序上下文会导致该套件花费不必要的长时间执行，因此准确地知道已加载和缓存了多少个上下文通常是有益的。要查看基础上下文缓存的统计信息，您可以设置<code>org.springframework.test.context.cache</code>记录类别到<code>DEBUG</code> 。</p>
</div>
<div class="paragraph">
<p>如果测试破坏了应用程序上下文并需要重新加载（例如，通过修改Bean定义或应用程序对象的状态），这种情况不太可能发生，则可以使用以下方法注释测试类或测试方法： <code>@DirtiesContext</code> （请参阅<code>@DirtiesContext</code>在<a href="#spring-testing-annotation-dirtiescontext"><code>@DirtiesContext</code></a> ）。这指示Spring在运行需要相同应用程序上下文的下一个测试之前，从缓存中删除上下文并重建应用程序上下文。请注意，对<code>@DirtiesContext</code>注释由提供<code>DirtiesContextBeforeModesTestExecutionListener</code>和<code>DirtiesContextTestExecutionListener</code> ，默认情况下启用。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-ctx-management-ctx-hierarchies"><a class="anchor" href="#testcontext-ctx-management-ctx-hierarchies"></a>上下文层次结构</h5>
<div class="paragraph">
<p>在编写依赖于已加载的Spring的集成测试时<code>ApplicationContext</code> ，通常只需针对单个上下文进行测试即可。但是，有时候根据一个层次结构进行测试是有益的甚至是必要的<code>ApplicationContext</code>实例。例如，如果您正在开发Spring MVC Web应用程序，则通常具有root用户<code>WebApplicationContext</code>由Spring的<code>ContextLoaderListener</code>和一个孩子<code>WebApplicationContext</code>由Spring的<code>DispatcherServlet</code> 。这将导致父子上下文层次结构，其中共享组件和基础结构配置在根上下文中声明，并在特定于Web的组件的子上下文中使用。在Spring Batch应用程序中可以找到另一个用例，在该应用程序中，您经常有一个父上下文为共享批处理基础结构提供配置，而子上下文为特定批处理作业进行配置。</p>
</div>
<div class="paragraph">
<p>您可以通过声明上下文配置来编写使用上下文层次结构的集成测试。 <code>@ContextHierarchy</code>在单个测试类上或在测试类层次结构中的注释。如果在测试类层次结构中的多个类上声明了上下文层次结构，则还可以合并或覆盖上下文层次结构中特定命名级别的上下文配置。合并层次结构中给定级别的配置时，配置资源类型（即XML配置文件或组件类）必须一致。否则，在使用不同资源类型配置的上下文层次结构中具有不同级别是完全可以接受的。</p>
</div>
<div class="paragraph">
<p>本节中其余的基于JUnit Jupiter的示例显示了需要使用上下文层次结构的集成测试的常见配置方案。</p>
</div>
<div class="openblock">
<div class="title">具有上下文层次结构的单个测试类</div>
<div class="content">
<div class="paragraph">
<p><code>ControllerIntegrationTests</code>通过声明一个包含两个级别的上下文层次结构，一个代表根，代表了Spring MVC Web应用程序的典型集成测试场景<code>WebApplicationContext</code> （通过使用<code>TestAppConfig</code><code>@Configuration</code>类），一个用于调度程序servlet <code>WebApplicationContext</code> （通过使用<code>WebConfig</code><code>@Configuration</code>类）。的<code>WebApplicationContext</code>自动链接到测试实例中的是子上下文（即层次结构中的最低上下文）。以下清单显示了此配置方案：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class ControllerIntegrationTests {

    @Autowired
    WebApplicationContext wac;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextHierarchy(
    ContextConfiguration(classes = [TestAppConfig::class]),
    ContextConfiguration(classes = [WebConfig::class]))
class ControllerIntegrationTests {

    @Autowired
    lateinit var wac: WebApplicationContext

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">具有隐式父上下文的类层次结构</div>
<div class="content">
<div class="paragraph">
<p>本示例中的测试类在测试类层次结构中定义了上下文层次结构。 <code>AbstractWebTests</code>声明根的配置<code>WebApplicationContext</code>在Spring驱动的Web应用程序中。但是请注意， <code>AbstractWebTests</code>没有声明<code>@ContextHierarchy</code> 。因此， <code>AbstractWebTests</code>可以选择参与上下文层次结构或遵循标准语义<code>@ContextConfiguration</code> 。 <code>SoapWebServiceTests</code>和<code>RestWebServiceTests</code>都延伸<code>AbstractWebTests</code>并通过使用定义上下文层次结构<code>@ContextHierarchy</code> 。结果是加载了三个应用程序上下文（对于每个声明，一个<code>@ContextConfiguration</code> ），并根据中的配置加载应用程序上下文<code>AbstractWebTests</code>设置为为具体子类加载的每个上下文的父上下文。以下清单显示了此配置方案：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml"))
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml"))
public class RestWebServiceTests extends AbstractWebTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
abstract class AbstractWebTests

@ContextHierarchy(ContextConfiguration("/spring/soap-ws-config.xml"))
class SoapWebServiceTests : AbstractWebTests()

@ContextHierarchy(ContextConfiguration("/spring/rest-ws-config.xml"))
class RestWebServiceTests : AbstractWebTests()</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">具有合并上下文层次结构配置的类层次结构</div>
<div class="content">
<div class="paragraph">
<p>此示例中的类显示了使用命名层次结构级别的目的，以便合并上下文层次结构中特定级别的配置。 <code>BaseTests</code>在层次结构中定义两个级别， <code>parent</code>和<code>child</code> 。 <code>ExtendedTests</code>延伸<code>BaseTests</code>并指示Spring TestContext Framework合并上下文配置<code>child</code>通过确保在<code>name</code>归因于<code>@ContextConfiguration</code>都是<code>child</code> 。结果是加载了三个应用程序上下文：一个用于<code>/app-config.xml</code> ，一个<code>/user-config.xml</code>和一个<code>{"/user-config.xml", "/order-config.xml"}</code> 。与前面的示例一样，应用程序上下文是从<code>/app-config.xml</code>设置为从中加载的上下文的父上下文<code>/user-config.xml</code>和<code>{"/user-config.xml", "/order-config.xml"}</code> 。以下清单显示了此配置方案：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)
class ExtendedTests extends BaseTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
    ContextConfiguration(name = "child", locations = ["/order-config.xml"])
)
class ExtendedTests : BaseTests() {}</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title">具有覆盖的上下文层次结构配置的类层次结构</div>
<div class="content">
<div class="paragraph">
<p>与前面的示例相反，此示例演示如何通过设置上下文层次结构中给定命名级别的配置来覆盖<code>inheritLocations</code>标记在<code>@ContextConfiguration</code>至<code>false</code> 。因此，应用程序上下文<code>ExtendedTests</code>仅从加载<code>/test-user-config.xml</code>并将其父级设置为从中加载的上下文<code>/app-config.xml</code> 。以下清单显示了此配置方案：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(
        name = "child",
        locations = "/test-user-config.xml",
        inheritLocations = false
))
class ExtendedTests extends BaseTests {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
@ContextHierarchy(
    ContextConfiguration(name = "parent", locations = ["/app-config.xml"]),
    ContextConfiguration(name = "child", locations = ["/user-config.xml"]))
open class BaseTests {}

@ContextHierarchy(
        ContextConfiguration(
                name = "child",
                locations = ["/test-user-config.xml"],
                inheritLocations = false
        ))
class ExtendedTests : BaseTests() {}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">污染上下文层次结构中的上下文</div>如果您使用<code>@DirtiesContext</code>在其上下文被配置为上下文层次结构一部分的测试中，您可以使用<code>hierarchyMode</code>标志，用于控制如何清除上下文缓存。有关更多详细信息，请参见<code>@DirtiesContext</code>在<a href="#spring-testing-annotation-dirtiescontext"> Spring 测试注释</a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.html"><code>@DirtiesContext</code></a> javadoc。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-fixture-di"><a class="anchor" href="#testcontext-fixture-di"></a> 3.5.6。测试夹具的依赖注入</h4>
<div class="paragraph">
<p>当您使用<code>DependencyInjectionTestExecutionListener</code> （默认情况下已配置），测试实例的依赖项是从配置了应用程序上下文的bean中注入的<code>@ContextConfiguration</code>或相关注释。您可以使用setter注入，字段注入或同时使用这两种方法，具体取决于您选择的注释以及是否将它们放置在setter方法或字段中。如果您使用的是JUnit Jupiter，则还可以选择使用构造函数注入（请参阅<a href="#testcontext-junit-jupiter-di">Dependency Injection with <code>SpringExtension</code></a> ）。为了与Spring的基于注释的注入支持保持一致，您还可以使用Spring的<code>@Autowired</code>注释或<code>@Inject</code> JSR-330的注解，用于现场和二传手注射。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">对于JUnit Jupiter以外的其他测试框架，TestContext框架不参与测试类的实例化。因此，使用<code>@Autowired</code>要么<code>@Inject</code>对于构造函数，对于测试类无效。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管在生产代码中不鼓励使用字段注入，但是在测试代码中字段注入实际上是很自然的。区别的理由是，您永远不会直接实例化测试类。因此，不需要能够调用<code>public</code>测试类上的构造方法或设置方法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因为<code>@Autowired</code>用于<a href="core.html#beans-factory-autowire">按类型</a>执行<a href="core.html#beans-factory-autowire">自动装配</a> ，如果您具有多个相同类型的Bean定义，则不能将这种方法用于那些特定的Bean。在这种情况下，您可以使用<code>@Autowired</code>和这个结合<code>@Qualifier</code> 。您也可以选择使用<code>@Inject</code>和这个结合<code>@Named</code> 。或者，如果您的测试班级可以访问其<code>ApplicationContext</code> ，您可以通过使用（例如）对的调用来执行显式查找<code>applicationContext.getBean("titleRepository", TitleRepository.class)</code> 。</p>
</div>
<div class="paragraph">
<p>如果您不希望将依赖项注入应用于测试实例，请不要使用以下注释字段或设置方法<code>@Autowired</code>要么<code>@Inject</code> 。另外，您可以通过显式配置类来完全禁用依赖项注入<code>@TestExecutionListeners</code>并省略<code>DependencyInjectionTestExecutionListener.class</code>从听众列表中。</p>
</div>
<div class="paragraph">
<p>考虑一下测试<code>HibernateTitleRepository</code>类，如“ <a href="#integration-testing-goals">目标”</a>部分所述。接下来的两个代码清单演示了<code>@Autowired</code>在字段和setter方法上。在所有示例代码清单之后显示了应用程序上下文配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下代码清单中的依赖项注入行为并非特定于JUnit Jupiter。相同的DI技术可以与任何受支持的测试框架结合使用。</p>
</div>
<div class="paragraph">
<p>以下示例调用了静态断言方法，例如<code>assertNotNull()</code> ，但不使用<code>Assertions</code> 。在这种情况下，假设该方法是通过<code>import static</code>该示例中未显示的声明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第一个代码清单显示了基于JUnit Jupiter的测试类的实现，该实现使用<code>@Autowired</code>用于现场注入：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    lateinit var titleRepository: HibernateTitleRepository

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以配置要使用的类<code>@Autowired</code>用于二传手注射，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExtendWith(SpringExtension::class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    lateinit var titleRepository: HibernateTitleRepository

    @Autowired
    fun setTitleRepository(titleRepository: HibernateTitleRepository) {
        this.titleRepository = titleRepository
    }

    @Test
    fun findById() {
        val title = titleRepository.findById(10)
        assertNotNull(title)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码清单使用相同的XML上下文文件来引用<code>@ContextConfiguration</code>注释（即， <code>repository-config.xml</code> ）。下面显示了此配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;
    &lt;bean id="titleRepository" class="com.foo.repository.hibernate.HibernateTitleRepository"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
        &lt;!-- configuration elided for brevity --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您是从Spring提供的恰好使用的测试基类扩展而来<code>@Autowired</code>在其setter方法之一上，您可能在应用程序上下文中定义了多个受影响类型的Bean（例如，多个<code>DataSource</code>beans）。在这种情况下，您可以覆盖setter方法并使用<code>@Qualifier</code>用来指示特定目标bean的注释，如下所示（但请确保也委托给超类中的重写方法）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// ...

    @Autowired
    @Override
    public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
        super.setDataSource(dataSource);
    }

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// ...

    @Autowired
    override fun setDataSource(@Qualifier("myDataSource") dataSource: DataSource) {
        super.setDataSource(dataSource)
    }

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>指定的限定符值表示特定的<code>DataSource</code>要注入的bean，将类型匹配的范围缩小到特定的bean。其值与<code><qualifier></code>对应内的声明<code><bean></code>定义。Bean名称用作后备限定符值，因此您也可以在该名称中有效地指向特定的Bean（如先前所示，假设<code>myDataSource</code>是 bean <code>id</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-web-scoped-beans"><a class="anchor" href="#testcontext-web-scoped-beans"></a> 3.5.7。测试请求和会话范围的Bean</h4>
<div class="paragraph">
<p> Spring 已经支持<a href="core.html#beans-factory-scopes-other">请求-和会话作用域bean</a>由于早年，您可以通过以下步骤测试你的请求范围和会话范围 bean ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保一个<code>WebApplicationContext</code>通过注释测试类为您的测试加载<code>@WebAppConfiguration</code> 。</p>
</li>
<li>
<p>将模拟请求或会话注入到测试实例中，并适当地准备测试夹具。</p>
</li>
<li>
<p>调用从配置文件中检索到的Web组件<code>WebApplicationContext</code> （带有依赖项注入）。</p>
</li>
<li>
<p>对模拟执行断言。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一个代码片段显示了登录用例的XML配置。请注意<code>userService</code> bean对请求范围的依赖<code>loginAction</code> bean 。另外， <code>LoginAction</code>通过使用<a href="core.html#expressions">SpEL表达式</a>实例化该<a href="core.html#expressions">对象</a> ，该<a href="core.html#expressions">表达式</a>从当前HTTP请求中检索用户名和密码。在我们的测试中，我们想通过TestContext框架管理的模拟来配置这些请求参数。以下清单显示了此用例的配置：</p>
</div>
<div class="listingblock">
<div class="title">请求范围的Bean配置</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:loginAction-ref="loginAction"/&gt;

    &lt;bean id="loginAction" class="com.example.LoginAction"
            c:username="#{request.getParameter('user')}"
            c:password="#{request.getParameter('pswd')}"
            scope="request"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<code>RequestScopedBeanTests</code> ，我们同时注入<code>UserService</code> （即被测对象）和<code>MockHttpServletRequest</code>进入我们的测试实例。在我们内<code>requestScope()</code>测试方法，我们通过在提供的参数中设置请求参数来设置测试夹具<code>MockHttpServletRequest</code> 。当。。。的时候<code>loginUser()</code>方法在我们的<code>userService</code> ，我们保证用户服务可以访问请求范围<code>loginAction</code>目前<code>MockHttpServletRequest</code> （也就是说，我们只是在其中设置参数）。然后，我们可以根据用户名和密码的已知输入对结果进行断言。以下清单显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter("user", "enigma");
        request.setParameter("pswd", "$pr!ng");

        LoginResults results = userService.loginUser();
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var request: MockHttpServletRequest

    @Test
    fun requestScope() {
        request.setParameter("user", "enigma")
        request.setParameter("pswd", "\$pr!ng")

        val results = userService.loginUser()
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下代码段类似于我们之前针对请求范围的Bean看到的代码段。但是，这次， <code>userService</code> bean对会话范围的依赖<code>userPreferences</code> bean 。请注意<code>UserPreferences</code>通过使用SpEL表达式实例化bean，该表达式从当前HTTP会话中检索主题。在我们的测试中，我们需要在由TestContext框架管理的模拟会话中配置主题。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="title">会话范围的Bean配置</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="userService" class="com.example.SimpleUserService"
            c:userPreferences-ref="userPreferences" /&gt;

    &lt;bean id="userPreferences" class="com.example.UserPreferences"
            c:theme="#{session.getAttribute('theme')}"
            scope="session"&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<code>SessionScopedBeanTests</code> ，我们注入<code>UserService</code>和<code>MockHttpSession</code>进入我们的测试实例。在我们内<code>sessionScope()</code>测试方法，我们通过设置期望值来设置测试夹具<code>theme</code>提供的属性<code>MockHttpSession</code> 。当。。。的时候<code>processUserPreferences()</code>方法在我们的<code>userService</code> ，我们保证用户服务可以访问作用域范围内的会话<code>userPreferences</code>目前<code>MockHttpSession</code> ，我们可以根据配置的主题对结果进行断言。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute("theme", "blue");

        Results results = userService.processUserPreferences();
        // assert results
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired lateinit var userService: UserService
    @Autowired lateinit var session: MockHttpSession

    @Test
    fun sessionScope() {
        session.setAttribute("theme", "blue")

        val results = userService.processUserPreferences()
        // assert results
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-tx"><a class="anchor" href="#testcontext-tx"></a> 3.5.8。交易管理</h4>
<div class="paragraph">
<p>在TestContext框架中，交易由<code>TransactionalTestExecutionListener</code> ，即使您未明确声明，它也是默认配置的<code>@TestExecutionListeners</code>在你的测试课上。要启用对交易的支持，您必须配置一个<code>PlatformTransactionManager</code> bean 在<code>ApplicationContext</code>装有<code>@ContextConfiguration</code>语义（稍后提供更多详细信息）。此外，您必须声明Spring的<code>@Transactional</code>在类或方法级别为测试添加注释。</p>
</div>
<div class="sect4">
<h5 id="testcontext-tx-test-managed-transactions"><a class="anchor" href="#testcontext-tx-test-managed-transactions"></a>测试管理的交易</h5>
<div class="paragraph">
<p>测试管理的交易是通过使用<code>TransactionalTestExecutionListener</code>或以编程方式使用<code>TestTransaction</code> （稍后说明）。您不应将此类交易与Spring托管的交易（由Spring在内部直接管理的交易）混淆<code>ApplicationContext</code>加载以进行测试）或应用程序管理的交易（在测试所调用的应用程序代码中以编程方式管理的交易）。Spring管理的事务和应用程序管理的事务通常参与测试管理的事务。但是，如果Spring托管或应用程序托管的事务配置了除传播之外的任何传播类型，则应谨慎使用<code>REQUIRED</code>要么<code>SUPPORTS</code> （有关详细信息，请参见有关<a href="data-access.html#tx-propagation">事务传播</a>的讨论）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="title">抢先超时和测试管理的事务</div>
<div class="paragraph">
<p>当使用来自测试框架的任何形式的抢占式超时与Spring的测试管理事务一起使用时，必须小心。</p>
</div>
<div class="paragraph">
<p>具体来说，Spring的测试支持将事务状态绑定到当前线程（通过<code>java.lang.ThreadLocal</code>变量） <em>在</em>调用当前测试方法<em>之前</em> 。如果测试框架在新线程中调用当前测试方法以支持抢占式超时，则在当前测试方法内执行的任何操作都<em>不会</em>在测试管理的事务内调用。因此，任何此类操作的结果都不会随着测试管理的事务而回滚。相反，即使Spring适当地回滚了测试管理的事务，此类操作也将提交给持久性存储（例如，关系数据库）。</p>
</div>
<div class="paragraph">
<p>可能发生这种情况的情况包括但不限于以下情况。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JUnit 4的<code>@Test(timeout = …​)</code>支持和<code>TimeOut</code>规则</p>
</li>
<li>
<p>JUnit木星的<code>assertTimeoutPreemptively(…​)</code>中的方法<code>org.junit.jupiter.api.Assertions</code>类</p>
</li>
<li>
<p>TestNG的<code>@Test(timeOut = …​)</code>支持</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-enabling-transactions"><a class="anchor" href="#testcontext-tx-enabling-transactions"></a>启用和禁用事务</h5>
<div class="paragraph">
<p>用以下方法注释测试方法<code>@Transactional</code>导致测试在事务中运行，默认情况下，该事务在测试完成后会自动回滚。如果测试班级带有注释<code>@Transactional</code> ，该类层次结构中的每个测试方法都在事务中运行。未注释的测试方法<code>@Transactional</code> （在类或方法级别）不在事务内运行。注意<code>@Transactional</code>测试生命周期方法不支持—例如，用JUnit Jupiter的方法注释的方法<code>@BeforeAll</code> ， <code>@BeforeEach</code>等等。此外，带有注释的测试<code>@Transactional</code>但是有<code>propagation</code>属性设置为<code>NOT_SUPPORTED</code>不在事务内运行。</p>
</div>
<table id="testcontext-tx-attribute-support" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。 <code>@Transactional</code>属性支持</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">支持测试管理的交易</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code>和<code>transactionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只要<code>Propagation.NOT_SUPPORTED</code>支持</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>readOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackFor</code>和<code>rollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否：使用<code>TestTransaction.flagForRollback()</code>代替</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackFor</code>和<code>noRollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否：使用<code>TestTransaction.flagForCommit()</code>代替</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>方法级生命周期方法-例如，用JUnit Jupiter的方法注释的方法<code>@BeforeEach</code>要么<code>@AfterEach</code> —在测试管理的事务中运行。另一方面，套件级和类级生命周期方法-例如，用JUnit Jupiter的方法注释的方法<code>@BeforeAll</code>要么<code>@AfterAll</code>和用TestNG注释的方法<code>@BeforeSuite</code> ， <code>@AfterSuite</code> ， <code>@BeforeClass</code> ， 要么<code>@AfterClass</code> - <em>不在</em>测试管理的事务中运行。</p>
</div>
<div class="paragraph">
<p>如果您需要在事务内的套件级或类级生命周期方法中执行代码，则不妨注入相应的<code>PlatformTransactionManager</code>进入您的测试课程，然后将其与<code>TransactionTemplate</code>用于程序化交易管理。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注意<a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>和<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>在类级别预先配置为提供事务支持。</p>
</div>
<div class="paragraph">
<p>下面的示例演示了针对基于Hibernate编写集成测试的常见方案<code>UserRepository</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable("user");

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    lateinit var repository: HibernateUserRepository

    @Autowired
    lateinit var sessionFactory: SessionFactory

    lateinit var jdbcTemplate: JdbcTemplate

    @Autowired
    fun setDataSource(dataSource: DataSource) {
        this.jdbcTemplate = JdbcTemplate(dataSource)
    }

    @Test
    fun createUser() {
        // track initial state in test database:
        val count = countRowsInTable("user")

        val user = User()
        repository.save(user)

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush()
        assertNumUsers(count + 1)
    }

    private fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    private fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如“ <a href="#testcontext-tx-rollback-and-commit-behavior">事务回滚和提交行为”中所述</a> ，无需在<a href="#testcontext-tx-rollback-and-commit-behavior">事务处理</a>后清理数据库。 <code>createUser()</code>该方法将运行，因为对数据库所做的任何更改都将自动回滚<code>TransactionalTestExecutionListener</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-rollback-and-commit-behavior"><a class="anchor" href="#testcontext-tx-rollback-and-commit-behavior"></a>事务回滚和提交行为</h5>
<div class="paragraph">
<p>默认情况下，测试事务将在测试完成后自动回滚；但是，可以通过以下方式声明性地配置事务提交和回滚行为<code>@Commit</code>和<code>@Rollback</code>注释。有关更多详细信息，请参见<a href="#integration-testing-annotations">注释支持</a>部分中的相应条目。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-programmatic-tx-mgt"><a class="anchor" href="#testcontext-tx-programmatic-tx-mgt"></a>程序化交易管理</h5>
<div class="paragraph">
<p>您可以使用中的静态方法以编程方式与测试管理的交易进行交互<code>TestTransaction</code> 。例如，您可以使用<code>TestTransaction</code>在测试方法中，方法之前和之后的方法中，以启动或结束当前测试管理的事务或配置当前测试管理的事务以进行回滚或提交。支持<code>TestTransaction</code>只要<code>TransactionalTestExecutionListener</code>已启用。</p>
</div>
<div class="paragraph">
<p>以下示例演示了以下功能<code>TestTransaction</code> 。请参阅javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html"><code>TestTransaction</code></a>有关更多详细信息。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ContextConfiguration(classes = TestConfig.class)
public class ProgrammaticTransactionManagementTests extends
        AbstractTransactionalJUnit4SpringContextTests {

    @Test
    public void transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2);

        deleteFromTables("user");

        // changes to the database will be committed!
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(0);

        TestTransaction.start();
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ContextConfiguration(classes = [TestConfig::class])
class ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() {

    @Test
    fun transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2)

        deleteFromTables("user")

        // changes to the database will be committed!
        TestTransaction.flagForCommit()
        TestTransaction.end()
        assertFalse(TestTransaction.isActive())
        assertNumUsers(0)

        TestTransaction.start()
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected fun assertNumUsers(expected: Int) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-before-and-after-tx"><a class="anchor" href="#testcontext-tx-before-and-after-tx"></a>在事务外运行代码</h5>
<div class="paragraph">
<p>有时，您可能需要在事务测试方法之前或之后但在事务上下文之外执行某些代码，例如，在运行测试之前验证初始数据库状态或在测试运行之后验证预期的事务提交行为（如果测试已配置为提交事务）。
<code>TransactionalTestExecutionListener</code>支持<code>@BeforeTransaction</code>和<code>@AfterTransaction</code>正是针对此类情况的注释。您可以注释任何<code>void</code>测试类或任何其他方法<code>void</code>具有这些注释之一的测试界面中的默认方法，并且<code>TransactionalTestExecutionListener</code>确保您的交易前或交易后方法在适当的时间运行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">任何以前的方法（例如，用JUnit Jupiter注释的方法<code>@BeforeEach</code> ）和任何后续方法（例如，用JUnit Jupiter注释的方法<code>@AfterEach</code> ）在交易中运行。此外，带注释的方法<code>@BeforeTransaction</code>要么<code>@AfterTransaction</code>没有为未配置为在事务内运行的测试方法运行。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-mgr-config"><a class="anchor" href="#testcontext-tx-mgr-config"></a>配置事务管理器</h5>
<div class="paragraph">
<p><code>TransactionalTestExecutionListener</code>期望一个<code>PlatformTransactionManager</code>在Spring中定义的bean <code>ApplicationContext</code>进行测试。如果有多个实例<code>PlatformTransactionManager</code>在测试的范围内<code>ApplicationContext</code> ，您可以使用声明一个限定词<code>@Transactional("myTxMgr")</code>要么<code>@Transactional(transactionManager = "myTxMgr")</code> ， 要么<code>TransactionManagementConfigurer</code>可以由<code>@Configuration</code>类。请向<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-">javadoc咨询<code>TestContextTransactionUtils.retrieveTransactionManager()</code></a>有关用于在测试中查找交易管理器的算法的详细信息<code>ApplicationContext</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-tx-annotation-demo"><a class="anchor" href="#testcontext-tx-annotation-demo"></a>演示所有与交易相关的注释</h5>
<div class="paragraph">
<p>以下基于JUnit Jupiter的示例显示了一个虚拟的集成测试方案，该方案突出显示了所有与事务相关的注释。该示例并非旨在演示最佳实践，而是演示如何使用这些注释。有关更多信息和配置示例，请参见<a href="#integration-testing-annotations">注释支持</a>部分。<a href="#testcontext-executing-sql-declaratively-tx">交易管理<code>@Sql</code></a>包含使用的其他示例<code>@Sql</code>用于使用默认事务回滚语义执行声明性SQL脚本。以下示例显示了相关的注释：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // execute "tear down" logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    fun verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    fun setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    fun modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    fun tearDownWithinTransaction() {
        // execute "tear down" logic within the transaction
    }

    @AfterTransaction
    fun verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}</code></pre>
</div>
</div>
<div id="testcontext-tx-false-positives" class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">测试ORM代码时避免误报</div>
<div class="paragraph">
<p>当您测试操纵Hibernate会话或JPA持久性上下文状态的应用程序代码时，请确保在运行该代码的测试方法中刷新基础工作单元。未能刷新基础工作单元可能会产生误报：您的测试通过了，但是相同的代码在实际的生产环境中引发异常。请注意，这适用于任何维护内存中工作单元的ORM框架。在下面的基于Hibernate的示例测试案例中，一种方法演示了误报，另一种方法正确地公开了刷新会话的结果：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInHibernateSession();
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
    updateEntityInHibernateSession();
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush();
}

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// ...

@Autowired
lateinit var sessionFactory: SessionFactory

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInHibernateSession()
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
fun updateWithSessionFlush() {
    updateEntityInHibernateSession()
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush()
}

// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了JPA的匹配方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInJpaPersistenceContext();
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    // Manual flush is required to avoid false positive in test
    entityManager.flush();
}

// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// ...

@PersistenceContext
lateinit var entityManager:EntityManager

@Transactional
@Test // no expected exception!
fun falsePositive() {
    updateEntityInJpaPersistenceContext()
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext()
    // Manual flush is required to avoid false positive in test
    entityManager.flush()
}

// ...</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-executing-sql"><a class="anchor" href="#testcontext-executing-sql"></a> 3.5.9。执行SQL脚本</h4>
<div class="paragraph">
<p>在针对关系数据库编写集成测试时，执行SQL脚本来修改数据库架构或将测试数据插入表中通常是有益的。的<code>spring-jdbc</code> Spring提供了通过执行SQL脚本来<em>初始化</em>嵌入式数据库或现有数据库的支持<code>ApplicationContext</code>已加载。有关详细信息，请参见<a href="data-access.html#jdbc-embedded-database-support">嵌入式数据库支持</a>和使用<a href="data-access.html#jdbc-embedded-database-support">嵌入式数据库</a> <a href="data-access.html#jdbc-embedded-database-dao-testing">测试数据访问逻辑</a> 。</p>
</div>
<div class="paragraph">
<p>尽管初始化数据库以进行<em>一次</em>测试非常有用， <code>ApplicationContext</code>加载时，有时必须能够<em>在</em>集成测试<em>期间</em>修改数据库。以下各节说明在集成测试期间如何以编程方式和声明方式执行SQL脚本。</p>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-programmatically"><a class="anchor" href="#testcontext-executing-sql-programmatically"></a>以编程方式执行SQL脚本</h5>
<div class="paragraph">
<p>Spring提供了以下选项，用于在集成测试方法中以编程方式执行SQL脚本。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.jdbc.datasource.init.ScriptUtils</code></p>
</li>
<li>
<p><code>org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</code></p>
</li>
<li>
<p><code>org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ScriptUtils</code>提供了用于处理SQL脚本的静态实用程序方法的集合，并且主要供框架内部使用。但是，如果您需要完全控制如何解析和执行SQL脚本， <code>ScriptUtils</code>可能比稍后介绍的其他一些替代方法更适合您的需求。请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html">javadoc</a>中的各个方法<code>ScriptUtils</code>有关更多详细信息。</p>
</div>
<div class="paragraph">
<p><code>ResourceDatabasePopulator</code>提供了一个基于对象的API，可通过使用外部资源中定义的SQL脚本以编程方式填充，初始化或清理数据库。 <code>ResourceDatabasePopulator</code>提供用于配置在解析和运行脚本时使用的字符编码，语句分隔符，注释定界符和错误处理标志的选项。每个配置选项都有一个合理的默认值。有关默认值的详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">javadoc</a> 。运行在<code>ResourceDatabasePopulator</code> ，您可以调用<code>populate(Connection)</code>对一个执行填充器的方法<code>java.sql.Connection</code>或者<code>execute(DataSource)</code>对一个执行填充器的方法<code>javax.sql.DataSource</code> 。以下示例为测试模式和测试数据指定SQL脚本，并将语句分隔符设置为<code>@@</code> ，并针对<code>DataSource</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource("test-schema.sql"),
            new ClassPathResource("test-data.sql"));
    populator.setSeparator("@@");
    populator.execute(this.dataSource);
    // execute code that uses the test schema and data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
fun databaseTest() {
    val populator = ResourceDatabasePopulator()
    populator.addScripts(
            ClassPathResource("test-schema.sql"),
            ClassPathResource("test-data.sql"))
    populator.setSeparator("@@")
    populator.execute(dataSource)
    // execute code that uses the test schema and data
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>ResourceDatabasePopulator</code>内部代表<code>ScriptUtils</code>用于解析和运行SQL脚本。同样， <code>executeSqlScript(..)</code>方法中<a href="#testcontext-support-classes-junit4"><code>AbstractTransactionalJUnit4SpringContextTests</code></a>和<a href="#testcontext-support-classes-testng"><code>AbstractTransactionalTestNGSpringContextTests</code></a>内部使用<code>ResourceDatabasePopulator</code>运行SQL脚本。有关各种信息，请参见javadoc <code>executeSqlScript(..)</code>详细信息的方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-executing-sql-declaratively"><a class="anchor" href="#testcontext-executing-sql-declaratively"></a>使用@Sql声明式执行SQL脚本</h5>
<div class="paragraph">
<p>除了上述用于以编程方式运行SQL脚本的机制之外，您还可以在Spring TestContext Framework中声明性地配置SQL脚本。具体来说，您可以声明<code>@Sql</code>测试类或测试方法上的注释，以配置应该在集成测试方法之前或之后针对给定数据库运行的各个SQL语句或SQL脚本的资源路径。支持<code>@Sql</code>由<code>SqlScriptsTestExecutionListener</code> ，默认情况下启用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">方法级别<code>@Sql</code>声明默认情况下覆盖类级别的声明。从Spring Framework 5.2开始，可以通过以下方式针对每个测试类或每个测试方法配置此行为： <code>@SqlMergeMode</code> 。请参阅使用以下方法<a href="#testcontext-executing-sql-declaratively-script-merging">合并和覆盖配置<code>@SqlMergeMode</code></a>有关更多详细信息。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-resources"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-resources"></a>路径资源语义</h6>
<div class="paragraph">
<p>每个路径都被解释为一个Spring <code>Resource</code> 。一条普通路径（例如， <code>"schema.sql"</code> ）被视为与定义测试类的包相关的类路径资源。以斜杠开头的路径被视为绝对类路径资源（例如， <code>"/org/example/schema.sql"</code> ）。引用URL的路径（例如，前缀为的路径<code>classpath:</code> ， <code>file:</code> ， <code>http:</code> ）是通过使用指定的资源协议加载的。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@Sql</code>在基于JUnit Jupiter的集成测试类中的类级别和方法级别：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // execute code that uses the test schema without any test data
    }

    @Test
    @Sql({"/test-schema.sql", "/test-user-data.sql"})
    void userTest() {
        // execute code that uses the test schema and test data
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    fun emptySchemaTest() {
        // execute code that uses the test schema without any test data
    }

    @Test
    @Sql("/test-schema.sql", "/test-user-data.sql")
    fun userTest() {
        // execute code that uses the test schema and test data
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-detection"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-detection"></a>默认脚本检测</h6>
<div class="paragraph">
<p>如果未指定SQL脚本或语句，则尝试检测<code>default</code>脚本，具体取决于位置<code>@Sql</code>被宣布。如果无法检测到默认值，则<code>IllegalStateException</code>被抛出。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类级别的声明：如果带注释的测试类是<code>com.example.MyTest</code> ，相应的默认脚本是<code>classpath:com/example/MyTest.sql</code> 。</p>
</li>
<li>
<p>方法级别的声明：如果命名的测试方法已命名<code>testMethod()</code>并在类中定义<code>com.example.MyTest</code> ，相应的默认脚本是<code>classpath:com/example/MyTest.testMethod.sql</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-multiple-annotations"><a class="anchor" href="#testcontext-executing-sql-declaratively-multiple-annotations"></a>声明多个<code>@Sql</code>套装</h6>
<div class="paragraph">
<p>如果您需要为给定的测试类或测试方法配置多组SQL脚本，但使用不同的语法配置，不同的错误处理规则或每组不同的执行阶段，则可以声明以下内容的多个实例： <code>@Sql</code> 。使用Java 8，您可以使用<code>@Sql</code>作为可重复的注释。否则，您可以使用<code>@SqlGroup</code>批注作为用于声明多个实例的显式容器<code>@Sql</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>@Sql</code>作为Java 8的可重复注释：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
@Sql("/test-user-data.sql")
void userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Repeatable annotations with non-SOURCE retention are not yet supported by Kotlin</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上例中显示的场景中， <code>test-schema.sql</code>脚本对单行注释使用不同的语法。</p>
</div>
<div class="paragraph">
<p>以下示例与前面的示例相同，不同之处在于： <code>@Sql</code>声明被组合在一起<code>@SqlGroup</code> 。在Java 8及更高版本中， <code>@SqlGroup</code>是可选的，但您可能需要使用<code>@SqlGroup</code>与其他JVM语言（例如Kotlin）兼容。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
@SqlGroup(
    Sql("/test-schema.sql", config = SqlConfig(commentPrefix = "`")),
    Sql("/test-user-data.sql"))
fun userTest() {
    // execute code that uses the test schema and test data
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-execution-phases"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-execution-phases"></a>脚本执行阶段</h6>
<div class="paragraph">
<p>默认情况下，SQL脚本在相应的测试方法之前执行。但是，如果您需要在测试方法之后运行一组特定的脚本（例如，清理数据库状态），则可以使用<code>executionPhase</code>归因于<code>@Sql</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // execute code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
@SqlGroup(
    Sql("create-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED)),
    Sql("delete-test-data.sql",
        config = SqlConfig(transactionMode = ISOLATED),
        executionPhase = AFTER_TEST_METHOD))
fun userTest() {
    // execute code that needs the test data to be committed
    // to the database outside of the test's transaction
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>ISOLATED</code>和<code>AFTER_TEST_METHOD</code>是从静态导入的<code>Sql.TransactionMode</code>和<code>Sql.ExecutionPhase</code> ， 分别。</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-configuration"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-configuration"></a>脚本配置<code>@SqlConfig</code></h6>
<div class="paragraph">
<p>您可以使用以下命令配置脚本解析和错误处理<code>@SqlConfig</code>注解。当在集成测试类中声明为类级别的注释时， <code>@SqlConfig</code>用作测试类层次结构中所有SQL脚本的全局配置。当直接使用声明时<code>config</code>的属性<code>@Sql</code>注解， <code>@SqlConfig</code>用作外壳中声明的SQL脚本的本地配置<code>@Sql</code>注解。中的每个属性<code>@SqlConfig</code>具有隐式默认值，该默认值记录在相应属性的javadoc中。遗憾的是，由于Java语言规范中为注释属性定义了规则，因此无法分配<code>null</code>注释属性。因此，为了支持覆盖继承的全局配置， <code>@SqlConfig</code>属性的显式默认值为<code>""</code> （对于字符串）， <code>{}</code> （用于数组），或<code>DEFAULT</code> （用于枚举）。这种方法允许本地声明<code>@SqlConfig</code>有选择地从全局声明中覆盖单个属性<code>@SqlConfig</code>通过提供除<code>""</code> ， <code>{}</code> ， 要么<code>DEFAULT</code> 。全球<code>@SqlConfig</code>只要本地，就继承属性<code>@SqlConfig</code>除了以下属性外，属性不提供任何显式值<code>""</code> ， <code>{}</code> ， 要么<code>DEFAULT</code> 。因此，显式本地配置将覆盖全局配置。</p>
</div>
<div class="paragraph">
<p>提供的配置选项<code>@Sql</code>和<code>@SqlConfig</code>等价于<code>ScriptUtils</code>和<code>ResourceDatabasePopulator</code>但是是由<code><jdbc:initialize-database/></code> XML名称空间元素。请参阅中的各个属性的javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/jdbc/Sql.html"><code>@Sql</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a>有关详细信息。</p>
</div>
<div id="testcontext-executing-sql-declaratively-tx" class="paragraph">
<p><strong>交易管理<code>@Sql</code></strong></p>
</div>
<div class="paragraph">
<p>默认情况下， <code>SqlScriptsTestExecutionListener</code>为使用以下命令配置的脚本推断所需的事务语义<code>@Sql</code> 。具体来说，SQL脚本在现有的Spring管理的事务（例如，由<code>TransactionalTestExecutionListener</code>用于带有注释的测试<code>@Transactional</code> ），或在隔离的交易中，具体取决于<code>transactionMode</code>归因于<code>@SqlConfig</code>和一个的存在<code>PlatformTransactionManager</code>在测试的<code>ApplicationContext</code> 。但是，至少<code>javax.sql.DataSource</code>必须存在于测试中<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>如果使用的算法<code>SqlScriptsTestExecutionListener</code>检测一个<code>DataSource</code>和<code>PlatformTransactionManager</code>并推断出交易语义不符合您的需求，您可以通过设置<code>dataSource</code>和<code>transactionManager</code>的属性<code>@SqlConfig</code> 。此外，您可以通过设置<code>transactionMode</code>的属性<code>@SqlConfig</code> （例如，是否应在隔离的事务中运行脚本）。尽管详细讨论了所有支持的事务管理选项<code>@Sql</code>超出了本参考手册的范围，javadoc用于<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html"><code>@SqlConfig</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html"><code>SqlScriptsTestExecutionListener</code></a>提供详细的信息，下面的示例显示了一个典型的测试场景，该场景使用JUnit Jupiter和事务测试<code>@Sql</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql("/test-data.sql")
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // execute code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable("user"),
            "Number of rows in the [user] table.");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestDatabaseConfig::class)
@Transactional
class TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) {

    val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource)

    @Test
    @Sql("/test-data.sql")
    fun usersTest() {
        // verify state in test database:
        assertNumUsers(2)
        // execute code that uses the test data...
    }

    fun countRowsInTable(tableName: String): Int {
        return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)
    }

    fun assertNumUsers(expected: Int) {
        assertEquals(expected, countRowsInTable("user"),
                "Number of rows in the [user] table.")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在执行以下操作后无需清理数据库。 <code>usersTest()</code>方法将运行，因为对数据库所做的任何更改（在测试方法内还是在<code>/test-data.sql</code>脚本）会自动回滚<code>TransactionalTestExecutionListener</code> （有关详细信息，请参见<a href="#testcontext-tx">事务管理</a> ）。</p>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-executing-sql-declaratively-script-merging"><a class="anchor" href="#testcontext-executing-sql-declaratively-script-merging"></a>合并和覆盖配置<code>@SqlMergeMode</code></h6>
<div class="paragraph">
<p>从Spring Framework 5.2开始，可以合并方法级<code>@Sql</code>类级别声明的声明。例如，这允许您为每个测试类提供一次数据库模式的配置或一些常见的测试数据，然后为每种测试方法提供特定于用例的其他测试数据。启用<code>@Sql</code>合并，注释您的测试类或测试方法<code>@SqlMergeMode(MERGE)</code> 。要禁用特定测试方法（或特定测试子类）的合并，可以通过以下方法切换回默认模式<code>@SqlMergeMode(OVERRIDE)</code> 。咨询<a href="#spring-testing-annotation-sqlmergemode"><code>@SqlMergeMode</code>注释文档部分</a>中的示例和更多详细信息。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-parallel-test-execution"><a class="anchor" href="#testcontext-parallel-test-execution"></a> 3.5.10。并行测试执行</h4>
<div class="paragraph">
<p>Spring Framework 5.0引入了对使用Spring TestContext Framework时在单个JVM中并行执行测试的基本支持。通常，这意味着大多数测试类或测试方法可以并行执行，而无需更改测试代码或配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关如何设置并行测试执行的详细信息，请参见您的测试框架，构建工具或IDE的文档。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请记住，在您的测试套件中引入并发可能会导致意外的副作用，奇怪的运行时行为以及间歇性或看似随机的测试失败。因此，Spring团队针对何时不并行执行测试提供了以下一般指导。</p>
</div>
<div class="paragraph">
<p>如果测试符合以下条件，则不要并行执行测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Spring Framework 的<code>@DirtiesContext</code>支持。</p>
</li>
<li>
<p>使用Spring Boot的<code>@MockBean</code>要么<code>@SpyBean</code>支持。</p>
</li>
<li>
<p>使用JUnit 4 <code>@FixMethodOrder</code>支持或旨在确保测试方法按特定顺序运行的任何测试框架功能。但是请注意，如果整个测试类是并行执行的，则此方法不适用。</p>
</li>
<li>
<p>更改共享服务或系统（如数据库，消息代理，文件系统等）的状态。这适用于嵌入式和外部系统。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果并行测试执行失败，并有异常指出<code>ApplicationContext</code>因为当前测试不再有效，这通常意味着<code>ApplicationContext</code>已从中删除<code>ContextCache</code>在不同的线程中。</p>
</div>
<div class="paragraph">
<p>这可能是由于使用<code>@DirtiesContext</code>或由于<code>ContextCache</code> 。如果<code>@DirtiesContext</code>是罪魁祸首，您要么需要找到一种避免使用的方法<code>@DirtiesContext</code>或从并行执行中排除此类测试。如果最大尺寸<code>ContextCache</code>已超过时，可以增加缓存的最大大小。有关详细信息，请参见<a href="#testcontext-ctx-management-caching">上下文缓存</a>的讨论。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">只有在以下情况下，才可以在Spring TestContext Framework中并行执行测试<code>TestContext</code>实现提供了一个复制构造函数，如javadoc中所述<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/TestContext.html"><code>TestContext</code></a> 。的<code>DefaultTestContext</code> Spring中使用的提供了这样的构造函数。但是，如果您使用提供自定义功能的第三方库<code>TestContext</code>实施中，您需要验证它是否适合并行测试执行。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="testcontext-support-classes"><a class="anchor" href="#testcontext-support-classes"></a> 3.5.11。TestContext Framework支持类</h4>
<div class="paragraph">
<p>本节描述了支持Spring TestContext Framework的各种类。</p>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-runner"><a class="anchor" href="#testcontext-junit4-runner"></a> Spring JUnit 4运行器</h5>
<div class="paragraph">
<p>Spring TestContext Framework通过自定义运行程序（在JUnit 4.12或更高版本上受支持）提供了与JUnit 4的完全集成。通过注释测试类<code>@RunWith(SpringJUnit4ClassRunner.class)</code>或更短<code>@RunWith(SpringRunner.class)</code>作为变体，开发人员可以实现基于JUnit 4的标准单元测试和集成测试，并同时获得TestContext框架的好处，例如对加载应用程序上下文的支持，对测试实例的依赖项注入，事务性测试方法执行等。如果您想将Spring TestContext Framework与替代运行程序一起使用（例如JUnit 4的<code>Parameterized</code>跑步者）或第三方跑步者（例如<code>MockitoJUnitRunner</code> ），您可以选择使用<a href="#testcontext-junit4-rules">Spring对JUnit规则的支持</a> 。</p>
</div>
<div class="paragraph">
<p>以下代码清单显示了配置测试类以与自定义Spring一起运行的最低要求<code>Runner</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RunWith(SpringRunner::class)
@TestExecutionListeners
class SimpleTest {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>@TestExecutionListeners</code>配置为空列表以禁用默认侦听器，否则将需要<code>ApplicationContext</code>通过配置<code>@ContextConfiguration</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit4-rules"><a class="anchor" href="#testcontext-junit4-rules"></a> Spring JUnit 4规则</h5>
<div class="paragraph">
<p>的<code>org.springframework.test.context.junit4.rules</code>软件包提供了以下JUnit 4规则（在JUnit 4.12或更高版本上受支持）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SpringClassRule</code></p>
</li>
<li>
<p><code>SpringMethodRule</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SpringClassRule</code>是一个JUnit <code>TestRule</code>支持Spring TestContext Framework的类级别的功能，而<code>SpringMethodRule</code>是一个JUnit <code>MethodRule</code>支持Spring TestContext Framework的实例级和方法级功能。</p>
</div>
<div class="paragraph">
<p>与之相反<code>SpringRunner</code> ，Spring的基于规则的JUnit支持具有以下优势： <code>org.junit.runner.Runner</code>实现，因此可以与现有的替代运行程序（例如JUnit 4的<code>Parameterized</code> ）或第三方跑步者（例如<code>MockitoJUnitRunner</code> ）。</p>
</div>
<div class="paragraph">
<p>为了支持TestContext框架的全部功能，您必须结合使用<code>SpringClassRule</code>与一个<code>SpringMethodRule</code> 。以下示例显示了在集成测试中声明这些规则的正确方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
class IntegrationTest {

    @Rule
    val springMethodRule = SpringMethodRule()

    @Test
    fun testMethod() {
        // execute test logic...
    }

    companion object {
        @ClassRule
        val springClassRule = SpringClassRule()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-junit4"><a class="anchor" href="#testcontext-support-classes-junit4"></a> JUnit 4支持类</h5>
<div class="paragraph">
<p>的<code>org.springframework.test.context.junit4</code>软件包为基于JUnit 4的测试用例提供了以下支持类（在JUnit 4.12或更高版本上受支持）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractJUnit4SpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractJUnit4SpringContextTests</code>是抽象的基础测试类，它将Spring TestContext Framework与显式集成<code>ApplicationContext</code> JUnit 4环境中的测试支持。当你扩展<code>AbstractJUnit4SpringContextTests</code> ，您可以访问<code>protected</code><code>applicationContext</code>您可以用来执行显式bean查找或测试整个上下文状态的实例变量。</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalJUnit4SpringContextTests</code>是的抽象交易扩展<code>AbstractJUnit4SpringContextTests</code>这为JDBC访问添加了一些便利功能。这个班期望<code>javax.sql.DataSource</code> bean 和一个<code>PlatformTransactionManager</code>在中定义的bean <code>ApplicationContext</code> 。当你扩展<code>AbstractTransactionalJUnit4SpringContextTests</code> ，您可以访问<code>protected</code><code>jdbcTemplate</code>实例变量，可用于运行SQL语句来查询数据库。您可以在运行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，并且Spring确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具一起使用时，请确保避免<a href="#testcontext-tx-false-positives">误报</a> 。如<a href="#integration-testing-support-jdbc">JDBC测试支持中所述</a> ， <code>AbstractTransactionalJUnit4SpringContextTests</code>还提供了方便的方法，这些方法委托给<code>JdbcTestUtils</code>通过使用上述<code>jdbcTemplate</code> 。此外， <code>AbstractTransactionalJUnit4SpringContextTests</code>提供一个<code>executeSqlScript(..)</code>针对已配置的命令运行SQL脚本的方法<code>DataSource</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这些类为扩展提供了便利。如果您不希望将测试类绑定到特定于Spring的类层次结构，则可以使用以下命令配置自己的自定义测试类<code>@RunWith(SpringRunner.class)</code>或<a href="#testcontext-junit4-rules">Spring的JUnit rules</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-extension"><a class="anchor" href="#testcontext-junit-jupiter-extension"></a> JUnit Jupiter的SpringExtension</h5>
<div class="paragraph">
<p>Spring TestContext Framework提供了与JUnit 5中引入的JUnit Jupiter测试框架的完全集成。通过注释测试类<code>@ExtendWith(SpringExtension.class)</code> ，您可以实现基于JUnit Jupiter的标准单元测试和集成测试，并同时获得TestContext框架的好处，例如对加载应用程序上下文的支持，对测试实例的依赖项注入，事务性测试方法执行等。</p>
</div>
<div class="paragraph">
<p>此外，得益于JUnit Jupiter中丰富的扩展API，Spring在Spring支持JUnit 4和TestNG的功能集之外提供了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>测试构造函数，测试方法和测试生命周期回调方法的依赖注入。请参阅<a href="#testcontext-junit-jupiter-di">依赖注入<code>SpringExtension</code></a>有关更多详细信息。</p>
</li>
<li>
<p>对基于SpEL表达式，环境变量，系统属性等的<a href="https://junit.org/junit5/docs/current/user-guide/#extensions-conditions">条件测试执行</a>的强大支持。请参阅有关的文档<code>@EnabledIf</code>和<code>@DisabledIf</code>有关更多详细信息和示例，请参见<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> 。</p>
</li>
<li>
<p>定制组合注释，结合了Spring和JUnit Jupiter的注释。见<code>@TransactionalDevTestConfig</code>和<code>@TransactionalIntegrationTest</code> <a href="#integration-testing-annotations-meta">有关测试</a>的更多信息，请参见<a href="#integration-testing-annotations-meta">测试的元注释支持中的</a>示例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码清单显示了如何配置测试类以使用<code>SpringExtension</code>和这个结合<code>@ContextConfiguration</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension::class)
// Instructs Spring to load an ApplicationContext from TestConfig::class
@ContextConfiguration(classes = [TestConfig::class])
class SimpleTests {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于您还可以在JUnit 5中将注释用作元注释，因此Spring提供了<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>组成注释以简化测试的配置<code>ApplicationContext</code>和JUnit Jupiter。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@SpringJUnitConfig</code>减少前一示例中使用的配置量：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig::class)
class SimpleTests {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，以下示例使用<code>@SpringJUnitWebConfig</code>创建一个<code>WebApplicationContext</code>与JUnit Jupiter一起使用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig::class
@SpringJUnitWebConfig(TestWebConfig::class)
class SimpleWebTests {

    @Test
    fun testMethod() {
        // execute test logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅有关的文档<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>有关更多详细信息，请参见<a href="#integration-testing-annotations-junit-jupiter">Spring JUnit Jupiter Testing Annotations</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-junit-jupiter-di"><a class="anchor" href="#testcontext-junit-jupiter-di"></a>依赖注入<code>SpringExtension</code></h5>
<div class="paragraph">
<p><code>SpringExtension</code>实现<a href="https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution"><code>ParameterResolver</code></a> JUnit Jupiter的扩展API，它使Spring可以为测试构造函数，测试方法和测试生命周期回调方法提供依赖项注入。</p>
</div>
<div class="paragraph">
<p>特别， <code>SpringExtension</code>可以注入测试的依赖项<code>ApplicationContext</code>放入带有注释的测试构造函数和方法中<code>@BeforeAll</code> ， <code>@AfterAll</code> ， <code>@BeforeEach</code> ， <code>@AfterEach</code> ， <code>@Test</code> ， <code>@RepeatedTest</code> ， <code>@ParameterizedTest</code> ， 和别的。</p>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-constructor"><a class="anchor" href="#testcontext-junit-jupiter-di-constructor"></a>构造函数注入</h6>
<div class="paragraph">
<p>如果JUnit Jupiter测试类的构造函数中的特定参数为类型<code>ApplicationContext</code> （或其子类型）或以以下方式注释或进行元注释<code>@Autowired</code> ， <code>@Qualifier</code> ， 要么<code>@Value</code> ，Spring会使用测试中对应的bean或值注入该特定参数的值<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p> Spring 也可以配置自动装配的所有参数进行测试类构造函数如果构造被认为是<em>autowirable。</em>如果满足以下条件之一（按优先顺序），则认为构造函数是可自动构造的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构造函数带有注释<code>@Autowired</code> 。</p>
</li>
<li>
<p><code>@TestConstructor</code>在测试类中存在或存在<code>autowireMode</code>属性设置为<code>ALL</code> 。</p>
</li>
<li>
<p>默认的<em>测试构造自动装配模式</em>已被更改为<code>ALL</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>看到<a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a>有关使用的详细信息<code>@TestConstructor</code>如何改变全球<em>测试构造函数自动装配模式</em> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果测试类的构造函数被认为是<em>autowirable</em> ，则Spring负责解析构造函数中所有参数的参数。因此，没有其他<code>ParameterResolver</code>在JUnit Jupiter中注册的用户可以解析此类构造函数的参数。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>测试类的构造函数注入不得与JUnit Jupiter的结合使用<code>@TestInstance(PER_CLASS)</code>支持如果<code>@DirtiesContext</code>用于关闭测试的<code>ApplicationContext</code>测试方法之前或之后。</p>
</div>
<div class="paragraph">
<p>原因是<code>@TestInstance(PER_CLASS)</code>指示JUnit Jupiter在测试方法调用之间缓存测试实例。因此，测试实例将保留对最初从<code>ApplicationContext</code>后来被关闭了。由于在这种情况下测试类的构造函数将仅被调用一次，因此依赖注入不会再次发生，并且后续测试将与封闭状态下的bean进行交互。 <code>ApplicationContext</code>这可能会导致错误。</p>
</div>
<div class="paragraph">
<p>使用<code>@DirtiesContext</code>与“测试前方法”或“测试后方法”模式结合使用<code>@TestInstance(PER_CLASS)</code> ，必须配置通过字段或setter注入提供的Spring依赖项，以便可以在测试方法调用之间重新注入它们。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在以下示例中，Spring注入了<code>OrderService</code>从 bean <code>ApplicationContext</code>从加载<code>TestConfig.class</code>进入<code>OrderServiceIntegrationTests</code>构造函数。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){
    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，此功能允许测试依赖项为<code>final</code>因此是一成不变的。</p>
</div>
<div class="paragraph">
<p>如果<code>spring.test.constructor.autowire.mode</code>财产是<code>all</code> （看到<a href="#integration-testing-annotations-testconstructor"><code>@TestConstructor</code></a> ），我们可以省略<code>@Autowired</code>在上一个示例中的构造函数上，结果如下。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests(val orderService:OrderService) {
    // tests that use the injected OrderService
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testcontext-junit-jupiter-di-method"><a class="anchor" href="#testcontext-junit-jupiter-di-method"></a>方法注入</h6>
<div class="paragraph">
<p>如果JUnit Jupiter测试方法或测试生命周期回调方法中的参数为类型<code>ApplicationContext</code> （或其子类型）或以以下方式注释或进行元注释<code>@Autowired</code> ， <code>@Qualifier</code> ， 要么<code>@Value</code> ，Spring会使用测试中的相应bean注入该特定参数的值<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>在以下示例中，Spring注入了<code>OrderService</code>来自<code>ApplicationContext</code>从加载<code>TestConfig.class</code>进入<code>deleteOrder()</code>测试方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @Test
    fun deleteOrder(@Autowired orderService: OrderService) {
        // use orderService from the test's ApplicationContext
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于其坚固性<code>ParameterResolver</code>在JUnit Jupiter的支持中，您还可以将多个依赖项注入到单个方法中，不仅是从Spring，而且是从JUnit Jupiter本身或其他第三方扩展中。</p>
</div>
<div class="paragraph">
<p>以下示例说明了如何让Spring和JUnit Jupiter都将依赖项注入到<code>placeOrderRepeatedly()</code>同时测试方法。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意使用<code>@RepeatedTest</code>来自JUnit Jupiter的测试方法可以访问<code>RepetitionInfo</code> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testcontext-support-classes-testng"><a class="anchor" href="#testcontext-support-classes-testng"></a> TestNG支持类别</h5>
<div class="paragraph">
<p>的<code>org.springframework.test.context.testng</code>程序包为基于TestNG的测试用例提供以下支持类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AbstractTestNGSpringContextTests</code></p>
</li>
<li>
<p><code>AbstractTransactionalTestNGSpringContextTests</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>AbstractTestNGSpringContextTests</code>是抽象的基础测试类，它将Spring TestContext Framework与显式集成<code>ApplicationContext</code>在TestNG环境中的测试支持。当你扩展<code>AbstractTestNGSpringContextTests</code> ，您可以访问<code>protected</code><code>applicationContext</code>您可以用来执行显式bean查找或测试整个上下文状态的实例变量。</p>
</div>
<div class="paragraph">
<p><code>AbstractTransactionalTestNGSpringContextTests</code>是的抽象交易扩展<code>AbstractTestNGSpringContextTests</code>这为JDBC访问添加了一些便利功能。这个班期望<code>javax.sql.DataSource</code> bean 和一个<code>PlatformTransactionManager</code>在中定义的bean <code>ApplicationContext</code> 。当你扩展<code>AbstractTransactionalTestNGSpringContextTests</code> ，您可以访问<code>protected</code><code>jdbcTemplate</code>实例变量，可用于执行SQL语句以查询数据库。您可以在运行与数据库相关的应用程序代码之前和之后使用此类查询来确认数据库状态，并且Spring确保此类查询在与应用程序代码相同的事务范围内运行。与ORM工具一起使用时，请确保避免<a href="#testcontext-tx-false-positives">误报</a> 。如<a href="#integration-testing-support-jdbc">JDBC测试支持中所述</a> ， <code>AbstractTransactionalTestNGSpringContextTests</code>还提供了方便的方法，这些方法委托给<code>JdbcTestUtils</code>通过使用上述<code>jdbcTemplate</code> 。此外， <code>AbstractTransactionalTestNGSpringContextTests</code>提供一个<code>executeSqlScript(..)</code>针对已配置的命令运行SQL脚本的方法<code>DataSource</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这些类为扩展提供了便利。如果您不希望将测试类绑定到特定于Spring的类层次结构，则可以使用以下命令配置自己的自定义测试类<code>@ContextConfiguration</code> ， <code>@TestExecutionListeners</code> ，依此类推，并通过手动测试您的测试类<code>TestContextManager</code> 。请参阅的源代码<code>AbstractTestNGSpringContextTests</code>有关如何测试您的测试类的示例。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-mvc-test-framework"><a class="anchor" href="#spring-mvc-test-framework"></a> 3.6。Spring MVC测试框架</h3>
<div class="paragraph">
<p>Spring MVC测试框架提供了一流的支持，可使用可与JUnit，TestNG或任何其他测试框架一起使用的流畅API测试Spring MVC代码。它建立在<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html">Servlet API模拟对象</a>的基础上<code>spring-test</code>模块，因此不使用正在运行的Servlet容器。它使用<code>DispatcherServlet</code>除了提供独立模式之外，还提供了使用TestContext框架加载实际Spring配置的全部功能，以提供完整的Spring MVC运行时行为，在该模式下，您可以手动实例化控制器并一次对其进行测试。</p>
</div>
<div class="paragraph">
<p>Spring MVC Test还为使用以下代码的测试代码提供了客户端支持： <code>RestTemplate</code> 。客户端测试模拟服务器响应，并且不使用正在运行的服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Boot提供了一个选项，可以编写包括运行中的服务器在内的完整的端到端集成测试。如果这是您的目标，请参阅《 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">Spring Boot参考指南》</a> 。有关容器外和端到端集成测试之间差异的更多信息，请参阅<a href="#spring-mvc-test-vs-end-to-end-integration-tests">Spring MVC测试与端到端测试</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server"><a class="anchor" href="#spring-mvc-test-server"></a> 3.6.1。服务器端测试</h4>
<div class="paragraph">
<p>您可以使用JUnit或TestNG为Spring MVC控制器编写普通的单元测试。为此，请实例化控制器，向其注入模拟或存根依赖性，然后调用其方法（ <code>MockHttpServletRequest</code> ， <code>MockHttpServletResponse</code> ，以及其他（如有必要）。但是，在编写这样的单元测试时，仍有很多未经测试的内容：例如，请求映射，数据绑定，类型转换，验证等等。此外，其他控制器方法例如<code>@InitBinder</code> ， <code>@ModelAttribute</code>和<code>@ExceptionHandler</code>也可以在请求处理生命周期中调用它。</p>
</div>
<div class="paragraph">
<p>Spring MVC Test的目标是通过执行请求并通过实际生成响应来提供一种有效的方法来测试控制器<code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p>Spring MVC Test建立在<a href="#mock-objects-servlet">Servlet API中</a>熟悉<a href="#mock-objects-servlet">的Servlet API的“模拟”实现</a>之上。 <code>spring-test</code>模块。这允许执行请求和生成响应，而无需在Servlet容器中运行。在大多数情况下，一切都应该像在运行时一样工作，但有一些值得注意的例外，如<a href="#spring-mvc-test-vs-end-to-end-integration-tests">Spring MVC测试与端到端测试中所述</a> 。以下基于JUnit Jupiter的示例使用Spring MVC Test：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.<strong>;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.</strong>;

@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class ExampleTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @Test
    void getAccount() throws Exception {
        this.mockMvc.perform(get("/accounts/1")
                .accept(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(content().contentType("application/json"))
            .andExpect(jsonPath("$.name").value("Lee"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.get

@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
class ExampleTests {

    lateinit var mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    @Test
    fun getAccount() {
        mockMvc.get("/accounts/1") {
            accept = MediaType.APPLICATION_JSON
        }.andExpect {
            status { isOk }
            content { contentType(MediaType.APPLICATION_JSON) }
            jsonPath("$.name") { value("Lee") }
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Kotlin提供了专用的<a href="languages.html#mockmvc-dsl">MockMvc DSL</a></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的测试依赖于<code>WebApplicationContext</code>支持TestContext框架，以从与测试类位于同一包中的XML配置文件加载Spring配置，但是还支持基于Java和基于Groovy的配置。请参阅这些<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context">样本测试</a> 。</p>
</div>
<div class="paragraph">
<p>的<code>MockMvc</code>实例用于执行<code>GET</code>请求<code>/accounts/1</code>并确认结果响应的状态为200，内容类型为<code>application/json</code> ，并且响应主体具有一个名为的JSON属性<code>name</code>具有价值<code>Lee</code> 。的<code>jsonPath</code> Jayway <a href="https://github.com/jayway/JsonPath">JsonPath项目</a>支持语法。本文档后面将讨论用于验证执行请求结果的许多其他选项。</p>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-static-imports"><a class="anchor" href="#spring-mvc-test-server-static-imports"></a>静态进口</h5>
<div class="paragraph">
<p>上<a href="#spring-mvc-test-server">一节</a>中的示例中的fluent API需要一些静态导入，例如<code>MockMvcRequestBuilders.*</code> ， <code>MockMvcResultMatchers.*</code>和<code>MockMvcBuilders.*</code> 。查找这些类的简单方法是搜索匹配的类型<code>MockMvc*</code> 。如果您使用Eclipse或基于Eclipse的Spring Tool Suite，请确保在Java→编辑器→Content Assist→收藏夹下的Eclipse首选项中将它们添加为“收藏的静态成员”。这样，您可以在键入静态方法名称的第一个字符后使用内容辅助。其他IDE（例如IntelliJ）可能不需要任何其他配置。检查对静态成员的代码完成的支持。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-options"><a class="anchor" href="#spring-mvc-test-server-setup-options"></a>设置选择</h5>
<div class="paragraph">
<p>您可以通过两个主要选项来创建<code>MockMvc</code> 。首先是通过TestContext框架加载Spring MVC配置，该框架加载Spring配置并注入一个<code>WebApplicationContext</code>进入测试以建立一个<code>MockMvc</code>实例。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig(locations = ["my-servlet-context.xml"])
class MyWebTests {

    lateinit var mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的第二个选择是在不加载Spring配置的情况下手动创建控制器实例。相反，将自动创建基本的默认配置，该配置与MVC JavaConfig或MVC命名空间大致相当。您可以在一定程度上对其进行自定义。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyWebTests {

    lateinit var mockMvc : MockMvc

    @BeforeEach
    fun setup() {
        mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您应该使用哪个设置选项？</p>
</div>
<div class="paragraph">
<p>的<code>webAppContextSetup</code>加载实际的Spring MVC配置，从而进行更完整的集成测试。由于TestContext框架缓存了已加载的Spring配置，因此即使您在测试套件中引入更多测试，它也可以帮助保持测试快速运行。此外，您可以通过Spring配置将模拟服务注入控制器中，以继续专注于测试Web层。下面的示例使用Mockito声明一个模拟服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="accountService" class="org.mockito.Mockito" factory-method="mock"&gt;
    &lt;constructor-arg value="org.example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将模拟服务注入测试中，以设置和验证您的期望，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class AccountTests {

    @Autowired
    AccountService accountService;

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    // ...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitWebConfig(locations = ["test-servlet-context.xml"])
class AccountTests {

    @Autowired
    lateinit var accountService: AccountService

    lateinit mockMvc: MockMvc

    @BeforeEach
    fun setup(wac: WebApplicationContext) {
        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>standaloneSetup</code>另一方面，它更接近于单元测试。它一次测试一个控制器。您可以手动注入具有模拟依赖项的控制器，并且不涉及加载Spring配置。这样的测试更多地集中在样式上，并使得查看正在测试哪个控制器，是否需要任何特定的Spring MVC配置等工作变得更加容易。的<code>standaloneSetup</code>这也是编写临时测试以验证特定行为或调试问题的一种非常方便的方法。</p>
</div>
<div class="paragraph">
<p>与大多数“集成与单元测试”辩论一样，没有正确或错误的答案。但是，使用<code>standaloneSetup</code>确实暗示需要额外<code>webAppContextSetup</code>测试以验证您的Spring MVC配置。或者，您可以使用<code>webAppContextSetup</code> ，以便始终根据实际的Spring MVC配置进行测试。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-setup-steps"><a class="anchor" href="#spring-mvc-test-server-setup-steps"></a>设定功能</h5>
<div class="paragraph">
<p>无论您使用哪种MockMvc构建器，都<code>MockMvcBuilder</code>实现提供了一些常见且非常有用的功能。例如，您可以声明<code>Accept</code>所有请求的标头，期望状态为200以及<code>Content-Type</code>所有响应中的标头，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// static import of MockMvcBuilders.standaloneSetup

MockMvc mockMvc = standaloneSetup(new MusicController())
    .defaultRequest(get("/").accept(MediaType.APPLICATION_JSON))
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，第三方框架（和应用程序）可以预先打包安装说明，例如<code>MockMvcConfigurer</code> 。Spring Framework 具有一个这样的内置实现，可帮助保存和重用跨请求的HTTP会话。您可以按以下方式使用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// static import of SharedHttpSessionConfigurer.sharedHttpSession

MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

// Use mockMvc to perform requests...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html"><code>ConfigurableMockMvcBuilder</code></a>以获得所有MockMvc构建器功能的列表，或使用IDE探索可用选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-performing-requests"><a class="anchor" href="#spring-mvc-test-server-performing-requests"></a>执行请求</h5>
<div class="paragraph">
<p>您可以使用任何HTTP方法执行请求，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.post

mockMvc.post("/hotels/{id}", 42) {
    accept = MediaType.APPLICATION_JSON
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以执行内部使用的文件上传请求<code>MockMultipartHttpServletRequest</code>这样就没有对多部分请求的实际解析。相反，您必须将其设置为类似于以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.multipart

mockMvc.multipart("/doc") {
    file("a1", "ABC".toByteArray(charset("UTF8")))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用URI模板样式指定查询参数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">mockMvc.get("/hotels?thing={thing}", "somewhere")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以添加代表查询或表单参数的Servlet请求参数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(get("/hotels").param("thing", "somewhere"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.get

mockMvc.get("/hotels") {
    param("thing", "somewhere")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果应用程序代码依赖Servlet请求参数并且没有显式检查查询字符串（通常是这种情况），那么使用哪个选项都没有关系。不过请注意，URI模板提供的查询参数会被解码，而通过<code>param(…​)</code>方法应该已经被解码。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，最好将上下文路径和Servlet路径保留在请求URI之外。如果您必须使用完整的请求URI进行测试，请务必设置<code>contextPath</code>和<code>servletPath</code>因此，请求映射才能正常工作，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.get

mockMvc.get("/app/main/hotels/{id}") {
    contextPath = "/app"
    servletPath = "/main"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，设置<code>contextPath</code>和<code>servletPath</code>每个执行的请求。相反，您可以设置默认请求属性，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        mockMvc = standaloneSetup(new AccountController())
            .defaultRequest(get("/")
            .contextPath("/app").servletPath("/main")
            .accept(MediaType.APPLICATION_JSON)).build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>前述属性会影响通过<code>MockMvc</code>实例。如果在给定请求上也指定了相同的属性，则它将覆盖默认值。这就是默认请求中的HTTP方法和URI无关紧要的原因，因为必须在每个请求中都指定它们。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-defining-expectations"><a class="anchor" href="#spring-mvc-test-server-defining-expectations"></a>定义期望</h5>
<div class="paragraph">
<p>您可以通过附加一个或多个定义期望<code>.andExpect(..)</code>执行请求后调用，如下例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(get("/accounts/1")).andExpect(status().isOk());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.get

mockMvc.get("/accounts/1").andExpect {
    status().isOk()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MockMvcResultMatchers.*</code>提供了许多期望，其中一些期望与更详细的期望进一步嵌套。</p>
</div>
<div class="paragraph">
<p>期望分为两大类。第一类断言验证响应的属性（例如，响应状态，标头和内容）。这些是要断言的最重要的结果。</p>
</div>
<div class="paragraph">
<p>第二类断言超出了响应范围。这些断言使您可以检查Spring MVC的特定方面，例如哪种控制器方法处理了请求，是否引发和处理异常，模型的内容是什么，选择了哪种视图，添加了哪些闪存属性，等等。它们还使您可以检查Servlet的特定方面，例如请求和会话属性。</p>
</div>
<div class="paragraph">
<p>以下测试断言绑定或验证失败：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(post("/persons"))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andExpect {
    status().isOk()
    model {
        attributeHasErrors("person")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很多时候，编写测试时，转储已执行请求的结果很有用。您可以按照以下方式进行操作： <code>print()</code>是从静态导入<code>MockMvcResultHandlers</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(post("/persons"))
    .andDo(print())
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.servlet.post

mockMvc.post("/persons").andDo {
        print()
    }.andExpect {
        status().isOk()
        model {
            attributeHasErrors("person")
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要请求处理不会导致未处理的异常， <code>print()</code>方法将所有可用结果数据打印到<code>System.out</code> 。还有一个<code>log()</code>方法和两个其他变体<code>print()</code>方法，接受一种<code>OutputStream</code>而一个接受<code>Writer</code> 。例如，调用<code>print(System.err)</code>将结果数据打印到<code>System.err</code> ，同时调用<code>print(myWriter)</code>将结果数据打印到自定义编写器。如果要记录结果数据而不是打印结果，则可以调用<code>log()</code>方法，将结果数据记录为一个<code>DEBUG</code>消息下<code>org.springframework.test.web.servlet.result</code>日志记录类别。</p>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望直接访问结果并验证否则无法验证的内容。这可以通过附加<code>.andReturn()</code>在所有其他期望值之后，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
// ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">var mvcResult = mockMvc.post("/persons").andExpect { status().isOk() }.andReturn()
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所有测试都重复相同的期望，则在构建<code>MockMvc</code>实例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，通常会应用共同的期望，并且在不创建单独期望的情况下不能将其覆盖<code>MockMvc</code>实例。</p>
</div>
<div class="paragraph">
<p>当JSON响应内容包含使用<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时，您可以使用JsonPath表达式来验证结果链接，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">mockMvc.get("/people") {
    accept(MediaType.APPLICATION_JSON)
}.andExpect {
    jsonPath("$.links[?(@.rel == 'self')].href") {
        value("http://localhost:8080/people")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当XML响应内容包含使用<a href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时，可以使用XPath表达式来验证生成的链接：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Map&lt;String, String&gt; ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
    .andExpect(xpath("/person/ns:link[@rel='self']/@href", ns).string("http://localhost:8080/people"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ns = mapOf("ns" to "http://www.w3.org/2005/Atom")
mockMvc.get("/handle") {
    accept(MediaType.APPLICATION_XML)
}.andExpect {
    xpath("/person/ns:link[@rel='self']/@href", ns) {
        string("http://localhost:8080/people")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-async-requests"><a class="anchor" href="#spring-mvc-test-async-requests"></a>异步请求</h5>
<div class="paragraph">
<p><a href="web.html#mvc-ann-async">Spring MVC支持的</a> Servlet 3.0异步请求通过退出Servlet容器线程并允许应用程序异步计算响应来工作，此后进行异步调度以完成对Servlet容器线程的处理。</p>
</div>
<div class="paragraph">
<p>在Spring MVC Test中，可以通过以下方法测试异步请求：首先声明产生的异步值，然后手动执行异步分派，最后验证响应。以下是返回的控制器方法的示例测试<code>DeferredResult</code> ， <code>Callable</code>或反应式，例如Reactor <code>Mono</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void test() throws Exception {
    MvcResult mvcResult = this.mockMvc.perform(get("/path"))
            .andExpect(status().isOk()) <i class="conum" data-value="1"></i><b>(1)</b>
            .andExpect(request().asyncStarted()) <i class="conum" data-value="2"></i><b>(2)</b>
            .andExpect(request().asyncResult("body")) <i class="conum" data-value="3"></i><b>(3)</b>
            .andReturn();

    this.mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect(status().isOk()) <i class="conum" data-value="5"></i><b>(5)</b>
            .andExpect(content().string("body"));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检查响应状态仍然不变</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>异步处理必须已经开始</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>等待并声明异步结果</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>手动执行ASYNC调度（因为没有正在运行的容器）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>验证最终答复</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
fun test() {
    var mvcResult = mockMvc.get("/path").andExpect {
        status().isOk() <i class="conum" data-value="1"></i><b>(1)</b>
        request { asyncStarted() } <i class="conum" data-value="2"></i><b>(2)</b>
        // TODO Remove unused generic parameter
        request { asyncResult&lt;Nothing&gt;("body") } <i class="conum" data-value="3"></i><b>(3)</b>
    }.andReturn()


    mockMvc.perform(asyncDispatch(mvcResult)) <i class="conum" data-value="4"></i><b>(4)</b>
            .andExpect {
                status().isOk() <i class="conum" data-value="5"></i><b>(5)</b>
                content().string("body")
            }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>检查响应状态仍然不变</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>异步处理必须已经开始</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>等待并声明异步结果</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>手动执行ASYNC调度（因为没有正在运行的容器）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>验证最终答复</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-streaming-response"><a class="anchor" href="#spring-mvc-test-vs-streaming-response"></a>流式响应</h5>
<div class="paragraph">
<p>Spring MVC Test中没有内置选项可用于无容器测试流响应。利用<a href="web.html#mvc-ann-async-http-streaming">Spring MVC流</a>选项的应用程序可以使用<a href="#webtestclient-stream">WebTestClient</a>对运行中的服务器执行端到端的集成测试。Spring Boot也支持此功能，您可以在其中使用以下命令<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server">测试正在运行的服务器</a> <code>WebTestClient</code> 。一项额外的优势是能够使用<code>StepVerifier</code>来自Reactor项目，它可以声明对数据流的期望。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-filters"><a class="anchor" href="#spring-mvc-test-server-filters"></a>筛选注册</h5>
<div class="paragraph">
<p>设置一个<code>MockMvc</code>实例，您可以注册一个或多个Servlet <code>Filter</code>实例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>已注册的过滤器通过<code>MockFilterChain</code>从<code>spring-test</code> ，最后一个过滤器委托给<code>DispatcherServlet</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-vs-end-to-end-integration-tests"><a class="anchor" href="#spring-mvc-test-vs-end-to-end-integration-tests"></a> Spring MVC测试与端到端测试</h5>
<div class="paragraph">
<p>Spring MVC Test建立在Servlet API模拟实现的基础上， <code>spring-test</code>模块，并且不依赖于正在运行的容器。因此，与使用实际客户端和实时服务器运行的完整端到端集成测试相比，存在一些差异。</p>
</div>
<div class="paragraph">
<p>考虑这一点的最简单方法是从空白开始<code>MockHttpServletRequest</code> 。您添加到其中的内容就是请求的内容。可能令您感到惊讶的是，默认情况下没有上下文路径。没有<code>jsessionid</code>曲奇饼;没有转发，错误或异步调度；因此，没有实际的JSP呈现。而是将“转发”和“重定向” URL保存在<code>MockHttpServletResponse</code>可以用期望来断言。</p>
</div>
<div class="paragraph">
<p>这意味着，如果您使用JSP，则可以验证将请求转发到的JSP页面，但不会呈现HTML。换句话说，不调用JSP。但是请注意，不依赖转发的所有其他渲染技术（例如Thymeleaf和Freemarker）都按预期将HTML渲染到响应主体。通过以下方式呈现JSON，XML和其他格式也是如此： <code>@ResponseBody</code>方法。</p>
</div>
<div class="paragraph">
<p>另外，您可以考虑使用Spring Boot提供的完整的端到端集成测试支持。 <code>@SpringBootTest</code> 。请参阅《 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing">Spring Boot参考指南》</a> 。</p>
</div>
<div class="paragraph">
<p>每种方法都各有利弊。从经典的单元测试到全面的集成测试，Spring MVC Test中提供的选项在规模上是不同的。可以肯定的是，Spring MVC Test中的所有选项都不属于经典单元测试的类别，但与之接近。例如，您可以通过将模拟服务注入控制器来隔离Web层，在这种情况下，您仅通过<code>DispatcherServlet</code>但是使用实际的Spring配置，因为您可能会隔离数据访问层与其上方的层进行测试。此外，您可以使用独立设置，一次只关注一个控制器，然后手动提供使其工作所需的配置。</p>
</div>
<div class="paragraph">
<p>使用Spring MVC Test时的另一个重要区别是，从概念上讲，此类测试是服务器端的，因此您可以检查使用了哪个处理程序，如果使用HandlerExceptionResolver处理了异常，则模型的内容是什么，绑定错误是什么？还有其他细节。这意味着编写期望值更容易，因为服务器不是一个黑盒子，就像通过实际的HTTP客户端对其进行测试时那样。通常，这是经典单元测试的一个优势：编写，推理和调试更容易，但不能代替完全集成测试的需要。同时，重要的是不要忽略响应是最重要的检查事实。简而言之，即使在同一项目中，这里也有多种样式和测试策略的空间。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-resources"><a class="anchor" href="#spring-mvc-test-server-resources"></a>进一步的例子</h5>
<div class="paragraph">
<p>框架自己的测试包括<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">许多示例测试，</a>旨在展示如何使用Spring MVC Test。您可以浏览这些示例以获取进一步的想法。另外， <a href="https://github.com/spring-projects/spring-mvc-showcase"><code>spring-mvc-showcase</code></a>该项目具有基于Spring MVC Test的完整测试范围。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-server-htmlunit"><a class="anchor" href="#spring-mvc-test-server-htmlunit"></a> 3.6.2。HtmlUnit集成</h4>
<div class="paragraph">
<p>Spring提供了<a href="#spring-mvc-test-server">MockMvc</a>和<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a>之间的集成。使用基于HTML的视图时，这简化了执行端到端测试的过程。通过此集成，您可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<a href="http://htmlunit.sourceforge.net/">HtmlUnit</a> ， <a href="https://www.seleniumhq.org">WebDriver</a>和<a href="http://www.gebish.org/manual/current/#spock-junit-testng">Geb</a>等工具可以轻松测试HTML页面，而无需部署到Servlet容器。</p>
</li>
<li>
<p>在页面中测试JavaScript。</p>
</li>
<li>
<p>（可选）使用模拟服务进行测试以加快测试速度。</p>
</li>
<li>
<p>在容器内端到端测试和容器外集成测试之间共享逻辑。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">MockMvc使用不依赖Servlet容器的模板技术（例如Thymeleaf，FreeMarker等），但不适用于JSP，因为它们依赖Servlet容器。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why"></a>为什么要进行HtmlUnit集成？</h5>
<div class="paragraph">
<p>想到的最明显的问题是“我为什么需要这个？”通过探索一个非常基本的示例应用程序，最好找到答案。假设您有一个Spring MVC Web应用程序，该应用程序支持对<code>Message</code>宾语。该应用程序还支持所有消息的分页。您将如何进行测试？</p>
</div>
<div class="paragraph">
<p>借助Spring MVC Test，我们可以轻松测试是否能够创建一个<code>Message</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param("summary", "Spring Rocks")
        .param("text", "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Test
fun test() {
    mockMvc.post("/messages/") {
        param("summary", "Spring Rocks")
        param("text", "In case you didn't know, Spring Rocks!")
    }.andExpect {
        status().is3xxRedirection()
        redirectedUrl("/messages/123")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们要测试允许我们创建消息的表单视图怎么办？例如，假设我们的表单类似于以下代码段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form id="messageForm" action="/messages/" method="post"&gt;
    &lt;div class="pull-right"&gt;&lt;a href="/messages/"&gt;Messages&lt;/a&gt;&lt;/div&gt;

    &lt;label for="summary"&gt;Summary&lt;/label&gt;
    &lt;input type="text" class="required" id="summary" name="summary" value="" /&gt;

    &lt;label for="text"&gt;Message&lt;/label&gt;
    &lt;textarea id="text" name="text"&gt;&lt;/textarea&gt;

    &lt;div class="form-actions"&gt;
        &lt;input type="submit" value="Create" /&gt;
    &lt;/div&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们如何确保表单产生正确的请求以创建新消息？天真的尝试可能类似于以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='summary']").exists())
        .andExpect(xpath("//textarea[@name='text']").exists());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='summary']") { exists() }
    xpath("//textarea[@name='text']") { exists() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此测试有一些明显的缺点。如果我们更新控制器以使用参数<code>message</code>代替<code>text</code> ，即使HTML表单与控制器不同步，我们的表单测试也继续通过。为了解决这个问题，我们可以结合以下两个测试：</p>
</div>
<div id="spring-mvc-test-server-htmlunit-mock-mvc-test" class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String summaryParamName = "summary";
String textParamName = "text";
mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='" + summaryParamName + "']").exists())
        .andExpect(xpath("//textarea[@name='" + textParamName + "']").exists());

MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param(summaryParamName, "Spring Rocks")
        .param(textParamName, "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val summaryParamName = "summary";
val textParamName = "text";
mockMvc.get("/messages/form").andExpect {
    xpath("//input[@name='$summaryParamName']") { exists() }
    xpath("//textarea[@name='$textParamName']") { exists() }
}
mockMvc.post("/messages/") {
    param(summaryParamName, "Spring Rocks")
    param(textParamName, "In case you didn't know, Spring Rocks!")
}.andExpect {
    status().is3xxRedirection()
    redirectedUrl("/messages/123")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以减少测试不正确通过的风险，但是仍然存在一些问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果页面上有多个表单怎么办？诚然，我们可以更新XPath表达式，但是由于我们考虑了更多因素，它们变得更加复杂：字段是正确的类型吗？是否启用了字段？等等。</p>
</li>
<li>
<p>另一个问题是我们正在做我们期望的两倍的工作。我们必须首先验证视图，然后使用刚刚验证的相同参数提交视图。理想情况下，可以一次完成所有操作。</p>
</li>
<li>
<p>最后，我们仍然无法解释某些事情。例如，如果表单也具有我们希望测试的JavaScript验证，该怎么办？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>总体问题是，测试网页不涉及单个交互。相反，它是用户如何与网页交互以及该网页与其他资源交互的组合。例如，表单视图的结果用作用户创建消息的输入。另外，我们的表单视图可以潜在地使用影响页面行为的其他资源，例如JavaScript验证。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-integration"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-integration"></a>对救援进行集成测试？</h6>
<div class="paragraph">
<p>为了解决前面提到的问题，我们可以执行端到端集成测试，但这有一些缺点。考虑测试允许我们翻阅消息的视图。我们可能需要以下测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们的页面是否向用户显示通知，以指示消息为空时没有可用结果？</p>
</li>
<li>
<p>我们的页面是否正确显示一条消息？</p>
</li>
<li>
<p>我们的页面是否正确支持分页？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要设置这些测试，我们需要确保我们的数据库包含正确的消息。这带来了许多其他挑战：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保数据库中包含正确的消息可能很繁琐。（考虑外键约束。）</p>
</li>
<li>
<p>测试可能会变慢，因为每次测试都需要确保数据库处于正确的状态。</p>
</li>
<li>
<p>由于我们的数据库需要处于特定状态，因此我们无法并行运行测试。</p>
</li>
<li>
<p>对诸如自动生成的ID，时间戳等项目进行断言可能很困难。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些挑战并不意味着我们应该完全放弃端到端集成测试。相反，我们可以通过重构我们的详细测试以使用运行速度更快，更可靠且没有副作用的模拟服务来减少端到端集成测试的数量。然后，我们可以实施少量真正的端到端集成测试，以验证简单的工作流程，以确保一切正常工作。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-why-mockmvc"><a class="anchor" href="#spring-mvc-test-server-htmlunit-why-mockmvc"></a>输入HtmlUnit集成</h6>
<div class="paragraph">
<p>那么，如何在测试页面的交互性之间保持平衡，并在测试套件中保持良好的性能呢？答案是：“通过将MockMvc与HtmlUnit集成。”</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-options"><a class="anchor" href="#spring-mvc-test-server-htmlunit-options"></a> HtmlUnit集成选项</h6>
<div class="paragraph">
<p>要将MockMvc与HtmlUnit集成时，有很多选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-mah">MockMvc和HtmlUnit</a> ：如果要使用原始的HtmlUnit库，请使用此选项。</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-webdriver">MockMvc和WebDriver</a> ：使用此选项可以简化集成和端到端测试之间的开发和重用代码。</p>
</li>
<li>
<p><a href="#spring-mvc-test-server-htmlunit-geb">MockMvc和Geb</a> ：如果要使用Groovy进行测试，简化开发并在集成和端到端测试之间重用代码，请使用此选项。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-mah"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah"></a> MockMvc和HtmlUnit</h5>
<div class="paragraph">
<p>本节介绍如何集成MockMvc和HtmlUnit。如果要使用原始的HtmlUnit库，请使用此选项。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-setup"></a> MockMvc和HtmlUnit设置</h6>
<div class="paragraph">
<p>首先，请确保您已经包含了对<code>net.sourceforge.htmlunit:htmlunit</code> 。为了与Apache HttpComponents 4.5+一起使用HtmlUnit，您需要使用HtmlUnit 2.18或更高版本。</p>
</div>
<div class="paragraph">
<p>我们可以轻松创建一个HtmlUnit <code>WebClient</code>通过使用与MockMvc集成<code>MockMvcWebClientBuilder</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是使用的简单示例<code>MockMvcWebClientBuilder</code> 。有关高级用法，请参阅<a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">高级<code>MockMvcWebClientBuilder</code></a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这样可以确保任何引用的网址<code>localhost</code>由于服务器是定向到我们的<code>MockMvc</code>实例，而无需真正的HTTP连接。通常，通过使用网络连接来请求其他任何URL。这使我们可以轻松测试CDN的使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-usage"></a> MockMvc和HtmlUnit用法</h6>
<div class="paragraph">
<p>现在，我们可以像往常一样使用HtmlUnit，而无需将应用程序部署到Servlet容器。例如，我们可以请求视图创建以下消息：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val createMsgFormPage = webClient.getPage("http://localhost/messages/form")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认上下文路径为<code>""</code> 。或者，我们可以指定上下文路径，如<a href="#spring-mvc-test-server-htmlunit-mah-advanced-builder">高级中所述<code>MockMvcWebClientBuilder</code></a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦我们引用了<code>HtmlPage</code> ，然后我们可以填写表格并将其提交以创建一条消息，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
summaryInput.setValueAttribute("Spring Rocks");
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
textInput.setText("In case you didn't know, Spring Rocks!");
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
HtmlPage newMessagePage = submit.click();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val form = createMsgFormPage.getHtmlElementById("messageForm")
val summaryInput = createMsgFormPage.getHtmlElementById("summary")
summaryInput.setValueAttribute("Spring Rocks")
val textInput = createMsgFormPage.getHtmlElementById("text")
textInput.setText("In case you didn't know, Spring Rocks!")
val submit = form.getOneHtmlElementByAttribute("input", "type", "submit")
val newMessagePage = submit.click()</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们可以验证是否成功创建了新消息。以下断言使用<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>库：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
String id = newMessagePage.getHtmlElementById("id").getTextContent();
assertThat(id).isEqualTo("123");
String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
assertThat(summary).isEqualTo("Spring Rocks");
String text = newMessagePage.getHtmlElementById("text").getTextContent();
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123")
val id = newMessagePage.getHtmlElementById("id").getTextContent()
assertThat(id).isEqualTo("123")
val summary = newMessagePage.getHtmlElementById("summary").getTextContent()
assertThat(summary).isEqualTo("Spring Rocks")
val text = newMessagePage.getHtmlElementById("text").getTextContent()
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码以多种方式改进了我们的<a href="#spring-mvc-test-server-htmlunit-mock-mvc-test">MockMvc测试</a> 。首先，我们不再需要显式验证表单，然后创建类似于表单的请求。相反，我们要求表单，将其填写并提交，从而大大减少了开销。</p>
</div>
<div class="paragraph">
<p>另一个重要因素是<a href="http://htmlunit.sourceforge.net/javascript.html">HtmlUnit使用Mozilla Rhino引擎</a>来评估JavaScript。这意味着我们还可以在页面内测试JavaScript的行为。</p>
</div>
<div class="paragraph">
<p>有关使用HtmlUnit的其他信息，请参见<a href="http://htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit文档</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-mah-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-mah-advanced-builder"></a>高级<code>MockMvcWebClientBuilder</code></h6>
<div class="paragraph">
<p>在到目前为止的示例中，我们使用了<code>MockMvcWebClientBuilder</code>以最简单的方式，通过构建一个<code>WebClient</code>根据<code>WebApplicationContext</code>由Spring TestContext Framework为我们加载。在以下示例中重复此方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">lateinit var webClient: WebClient

@BeforeEach
fun setup(context: WebApplicationContext) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以指定其他配置选项，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient webClient;

@BeforeEach
void setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">lateinit var webClient: WebClient

@BeforeEach
fun setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，我们可以通过配置<code>MockMvc</code>单独实例并提供给<code>MockMvcWebClientBuilder</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

webClient = MockMvcWebClientBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>这比较冗长，但是通过构建<code>WebClient</code>与一个<code>MockMvc</code>例如，我们唾手可得MockMvc的全部功能。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关创建广告的其他信息<code>MockMvc</code>实例，请参阅“ <a href="#spring-mvc-test-server-setup-options">设置选择”</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-webdriver"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver"></a> MockMvc和WebDriver</h5>
<div class="paragraph">
<p>在前面的部分中，我们已经了解了如何将MockMvc与原始HtmlUnit API结合使用。在本节中，我们在Selenium <a href="https://docs.seleniumhq.org/projects/webdriver/">WebDriver中</a>使用其他抽象使事情变得更加容易。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-why"></a>为什么要使用WebDriver和MockMvc？</h6>
<div class="paragraph">
<p>我们已经可以使用HtmlUnit和MockMvc，那么为什么要使用WebDriver？Selenium WebDriver提供了一个非常优雅的API，使我们可以轻松地组织代码。为了更好地说明其工作原理，我们在本节中探索一个示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管是<a href="https://docs.seleniumhq.org/">Selenium</a>的一部分，WebDriver并不需要Selenium Server来运行测试。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>假设我们需要确保正确创建一条消息。测试涉及找到HTML表单输入元素，将其填写并做出各种断言。</p>
</div>
<div class="paragraph">
<p>这种方法会导致大量单独的测试，因为我们也想测试错误情况。例如，如果只填写表格的一部分，我们要确保得到一个错误。如果我们填写整个表格，那么新创建的消息将在之后显示。</p>
</div>
<div class="paragraph">
<p>如果将其中一个字段命名为“ summary”，我们可能会在测试中的多个位置重复以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
summaryInput.setValueAttribute(summary);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val summaryInput = currentPage.getHtmlElementById("summary")
summaryInput.setValueAttribute(summary)</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，如果我们更改<code>id</code>至<code>smmry</code> ？这样做将迫使我们更新所有测试以纳入此更改。这违反了DRY原理，因此理想情况下，我们应将此代码提取到其自己的方法中，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
    setSummary(currentPage, summary);
    // ...
}

public void setSummary(HtmlPage currentPage, String summary) {
    HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
    summaryInput.setValueAttribute(summary);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{
    setSummary(currentPage, summary);
    // ...
}

fun setSummary(currentPage:HtmlPage , summary: String) {
    val summaryInput = currentPage.getHtmlElementById("summary")
    summaryInput.setValueAttribute(summary)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做可以确保在更改UI时不必更新所有测试。</p>
</div>
<div class="paragraph">
<p>我们甚至可以更进一步，将此逻辑放在<code>Object</code>代表<code>HtmlPage</code>如下面的示例所示，我们正在使用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CreateMessagePage {

    final HtmlPage currentPage;

    final HtmlTextInput summaryInput;

    final HtmlSubmitInput submit;

    public CreateMessagePage(HtmlPage currentPage) {
        this.currentPage = currentPage;
        this.summaryInput = currentPage.getHtmlElementById("summary");
        this.submit = currentPage.getHtmlElementById("submit");
    }

    public &lt;T&gt; T createMessage(String summary, String text) throws Exception {
        setSummary(summary);

        HtmlPage result = submit.click();
        boolean error = CreateMessagePage.at(result);

        return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));
    }

    public void setSummary(String summary) throws Exception {
        summaryInput.setValueAttribute(summary);
    }

    public static boolean at(HtmlPage page) {
        return "Create Message".equals(page.getTitleText());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">    class CreateMessagePage(private val currentPage: HtmlPage) {

        val summaryInput: HtmlTextInput = currentPage.getHtmlElementById("summary")

        val submit: HtmlSubmitInput = currentPage.getHtmlElementById("submit")

        fun &lt;T&gt; createMessage(summary: String, text: String): T {
            setSummary(summary)

            val result = submit.click()
            val error = at(result)

            return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T
        }

        fun setSummary(summary: String) {
            summaryInput.setValueAttribute(summary)
        }

        fun at(page: HtmlPage): Boolean {
            return "Create Message" == page.getTitleText()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以前，这种模式被称为<a href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects">Page Object Pattern</a> 。尽管我们当然可以使用HtmlUnit做到这一点，但WebDriver提供了一些工具，我们将在以下各节中进行探讨，以使该模式的实现更加容易。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-setup"></a> MockMvc和WebDriver设置</h6>
<div class="paragraph">
<p>要将Selenium WebDriver与Spring MVC Test框架一起使用，请确保您的项目包括对以下项目的测试依赖项： <code>org.seleniumhq.selenium:selenium-htmlunit-driver</code> 。</p>
</div>
<div class="paragraph">
<p>我们可以使用以下方法轻松创建与MockMvc集成的Selenium WebDriver <code>MockMvcHtmlUnitDriverBuilder</code>如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是使用的简单示例<code>MockMvcHtmlUnitDriverBuilder</code> 。有关更多高级用法，请参阅<a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">高级。 <code>MockMvcHtmlUnitDriverBuilder</code></a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的示例确保任何引用的URL <code>localhost</code>由于服务器是定向到我们的<code>MockMvc</code>实例，而无需真正的HTTP连接。通常，通过使用网络连接来请求其他任何URL。这使我们可以轻松测试CDN的使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-usage"></a> MockMvc和WebDriver的用法</h6>
<div class="paragraph">
<p>现在，我们可以像往常一样使用WebDriver，而无需将应用程序部署到Servlet容器。例如，我们可以请求视图创建以下消息：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">CreateMessagePage page = CreateMessagePage.to(driver);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val page = CreateMessagePage.to(driver)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以填写表格并提交以创建一条消息，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ViewMessagePage viewMessagePage =
        page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val viewMessagePage =
    page.createMessage(ViewMessagePage::class, expectedSummary, expectedText)</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过利用Page Object Pattern，这可以改善我们的<a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit测试</a>的设计。正如我们在“ <a href="#spring-mvc-test-server-htmlunit-webdriver-why">为什么要使用WebDriver和MockMvc？”中</a>提到的<a href="#spring-mvc-test-server-htmlunit-webdriver-why">那样。</a> ，我们可以将Page Object Pattern与HtmlUnit一起使用，但使用WebDriver则容易得多。考虑以下<code>CreateMessagePage</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CreateMessagePage
        extends AbstractPage { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private WebElement summary;
    private WebElement text;

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private WebElement submit;

    public CreateMessagePage(WebDriver driver) {
        super(driver);
    }

    public &lt;T&gt; T createMessage(Class&lt;T&gt; resultPage, String summary, String details) {
        this.summary.sendKeys(summary);
        this.text.sendKeys(details);
        this.submit.click();
        return PageFactory.initElements(driver, resultPage);
    }

    public static CreateMessagePage to(WebDriver driver) {
        driver.get("http://localhost:9990/mail/messages/form");
        return PageFactory.initElements(driver, CreateMessagePage.class);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>CreateMessagePage</code>扩展<code>AbstractPage</code> 。我们不详细介绍<code>AbstractPage</code> ，但总而言之，它包含了我们所有页面的通用功能。例如，如果我们的应用程序具有导航栏，全局错误消息和其他功能，则可以将此逻辑放置在共享位置。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对于我们感兴趣的HTML页面的每个部分，我们都有一个成员变量。这些是类型<code>WebElement</code> 。WebDriver的<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a>让我们从HtmlUnit版本的<code>CreateMessagePage</code>通过自动解决每个<code>WebElement</code> 。的<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class<T>)</code></a>方法自动解决每个<code>WebElement</code>通过使用字段名称并通过<code>id</code>要么<code>name</code> HTML页面中元素的位置。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以使用<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code>注释</a>以覆盖默认的查找行为。我们的示例说明了如何使用<code>@FindBy</code>注释以使用<code>css</code>选择器（ <strong>input [type = submit]</strong> ）。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { <i class="conum" data-value="1"></i><b>(1)</b>

    <i class="conum" data-value="2"></i><b>(2)</b>
    private lateinit var summary: WebElement
    private lateinit var text: WebElement

    <i class="conum" data-value="3"></i><b>(3)</b>
    @FindBy(css = "input[type=submit]")
    private lateinit var submit: WebElement

    fun &lt;T&gt; createMessage(resultPage: Class&lt;T&gt;, summary: String, details: String): T {
        this.summary.sendKeys(summary)
        text.sendKeys(details)
        submit.click()
        return PageFactory.initElements(driver, resultPage)
    }
    companion object {
        fun to(driver: WebDriver): CreateMessagePage {
            driver.get("http://localhost:9990/mail/messages/form")
            return PageFactory.initElements(driver, CreateMessagePage::class.java)
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>CreateMessagePage</code>扩展<code>AbstractPage</code> 。我们不详细介绍<code>AbstractPage</code> ，但总而言之，它包含了我们所有页面的通用功能。例如，如果我们的应用程序具有导航栏，全局错误消息和其他功能，则可以将此逻辑放置在共享位置。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>对于我们感兴趣的HTML页面的每个部分，我们都有一个成员变量。这些是类型<code>WebElement</code> 。WebDriver的<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory"><code>PageFactory</code></a>让我们从HtmlUnit版本的<code>CreateMessagePage</code>通过自动解决每个<code>WebElement</code> 。的<a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-"><code>PageFactory#initElements(WebDriver,Class<T>)</code></a>方法自动解决每个<code>WebElement</code>通过使用字段名称并通过<code>id</code>要么<code>name</code> HTML页面中元素的位置。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>我们可以使用<a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations"><code>@FindBy</code>注释</a>以覆盖默认的查找行为。我们的示例说明了如何使用<code>@FindBy</code>注释以使用<code>css</code>选择器（ <strong>input [type = submit]</strong> ）。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后，我们可以验证是否成功创建了新消息。以下断言使用<a href="https://joel-costigliola.github.io/assertj/">AssertJ</a>断言库：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
assertThat(viewMessagePage.getSuccess()).isEqualTo("Successfully created a new message");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">assertThat(viewMessagePage.message.isEqualTo(expectedMessage)
assertThat(viewMessagePage.success.isEqualTo("Successfully created a new message")</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以看到我们的<code>ViewMessagePage</code>让我们与自定义域模型进行交互。例如，它公开了一个返回<code>Message</code>宾语：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public Message getMessage() throws ParseException {
    Message message = new Message();
    message.setId(getId());
    message.setCreated(getCreated());
    message.setSummary(getSummary());
    message.setText(getText());
    return message;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun getMessage() = Message(getId(), getCreated(), getSummary(), getText())</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以在声明中使用富域对象。</p>
</div>
<div class="paragraph">
<p>最后，我们一定不要忘记关闭<code>WebDriver</code>测试完成后的实例，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@AfterEach
void destroy() {
    if (driver != null) {
        driver.close();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@AfterEach
fun destroy() {
    if (driver != null) {
        driver.close()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关使用WebDriver的其他信息，请参阅Selenium <a href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started">WebDriver文档</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-webdriver-advanced-builder"><a class="anchor" href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder"></a>高级<code>MockMvcHtmlUnitDriverBuilder</code></h6>
<div class="paragraph">
<p>在到目前为止的示例中，我们使用了<code>MockMvcHtmlUnitDriverBuilder</code>以最简单的方式，通过构建一个<code>WebDriver</code>根据<code>WebApplicationContext</code>由Spring TestContext Framework为我们加载。在此重复此方法，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">lateinit var driver: WebDriver

@BeforeEach
fun setup(context: WebApplicationContext) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以指定其他配置选项，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebDriver driver;

@BeforeEach
void setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">lateinit var driver: WebDriver

@BeforeEach
fun setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，我们可以通过配置<code>MockMvc</code>单独实例并提供给<code>MockMvcHtmlUnitDriverBuilder</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

driver = MockMvcHtmlUnitDriverBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed</code></pre>
</div>
</div>
<div class="paragraph">
<p>这比较冗长，但是通过构建<code>WebDriver</code>与一个<code>MockMvc</code>例如，我们唾手可得MockMvc的全部功能。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关创建广告的其他信息<code>MockMvc</code>实例，请参阅“ <a href="#spring-mvc-test-server-setup-options">设置选择”</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-server-htmlunit-geb"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb"></a> MockMvc和Geb</h5>
<div class="paragraph">
<p>在上一节中，我们了解了如何在WebDriver中使用MockMvc。在本节中，我们将使用<a href="http://www.gebish.org/">Geb</a>进行甚至Groovy-er的测试。</p>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-why"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-why"></a>为什么选择Geb和MockMvc？</h6>
<div class="paragraph">
<p>Geb由WebDriver支持，因此它提供了许多与WebDriver <a href="#spring-mvc-test-server-htmlunit-webdriver-why">相同的好处</a> 。但是，Geb通过为我们处理一些样板代码使事情变得更加轻松。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-setup"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-setup"></a> MockMvc和Geb设置</h6>
<div class="paragraph">
<p>我们可以轻松地初始化一个Geb <code>Browser</code>使用使用MockMvc的Selenium WebDriver，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">def setup() {
    browser.driver = MockMvcHtmlUnitDriverBuilder
        .webAppContextSetup(context)
        .build()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是使用的简单示例<code>MockMvcHtmlUnitDriverBuilder</code> 。有关更多高级用法，请参阅<a href="#spring-mvc-test-server-htmlunit-webdriver-advanced-builder">高级。 <code>MockMvcHtmlUnitDriverBuilder</code></a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这样可以确保任何URL引用<code>localhost</code>由于服务器是定向到我们的<code>MockMvc</code>实例，而无需真正的HTTP连接。通常，通过使用网络连接来请求其他任何URL。这使我们可以轻松测试CDN的使用。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-mvc-test-server-htmlunit-geb-usage"><a class="anchor" href="#spring-mvc-test-server-htmlunit-geb-usage"></a> MockMvc和Geb用法</h6>
<div class="paragraph">
<p>现在，我们可以像往常一样使用Geb了，而无需将应用程序部署到Servlet容器中。例如，我们可以请求视图创建以下消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">to CreateMessagePage</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以填写表格并提交以创建一条消息，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)</code></pre>
</div>
</div>
<div class="paragraph">
<p>找不到的所有无法识别的方法调用或属性访问或引用都将转发到当前页面对象。这消除了我们直接使用WebDriver时需要的许多样板代码。</p>
</div>
<div class="paragraph">
<p>与直接使用WebDriver一样，这通过使用Page Object Pattern改进了<a href="#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit测试</a>的设计。如前所述，我们可以将Page Object Pattern与HtmlUnit和WebDriver一起使用，但使用Geb则更加容易。考虑我们基于Groovy的新产品<code>CreateMessagePage</code>实施：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">class CreateMessagePage extends Page {
    static url = 'messages/form'
    static at = { assert title == 'Messages : Create'; true }
    static content =  {
        submit { $('input[type=submit]') }
        form { $('form') }
        errors(required:false) { $('label.error, .alert-error')?.text() }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的<code>CreateMessagePage</code>延伸<code>Page</code> 。我们不详细介绍<code>Page</code> ，但总而言之，它包含了我们所有页面的通用功能。我们定义一个可在其中找到此页面的URL。这使我们可以导航到页面，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">to CreateMessagePage</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还有一个<code>at</code>确定我们是否在指定页面上的闭包。它应该返回<code>true</code>如果我们在正确的页面上。这就是为什么我们可以断言我们在正确的页面上的原因，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">then:
at CreateMessagePage
errors.contains('This field is required.')</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们在闭包中使用一个断言，以便我们可以确定错误页面出在哪里。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接下来，我们创建一个<code>content</code>指定页面中所有感兴趣区域的闭包。我们可以使用<a href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api">jQuery-ish Navigator API</a>来选择我们感兴趣的内容。</p>
</div>
<div class="paragraph">
<p>最后，我们可以验证是否成功创建了新消息，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">then:
at ViewMessagePage
success == 'Successfully created a new message'
id
date
summary == expectedSummary
message == expectedMessage</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关如何充分利用Geb的更多详细信息，请参见<a href="http://www.gebish.org/manual/current/">The Geb Book</a>用户手册。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-mvc-test-client"><a class="anchor" href="#spring-mvc-test-client"></a> 3.6.3。客户端REST测试</h4>
<div class="paragraph">
<p>您可以使用客户端测试来测试内部使用<code>RestTemplate</code> 。这个想法是声明预期的请求并提供“存根”响应，以便您可以专注于隔离测试代码（即，不运行服务器）。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

// Test code that uses the above RestTemplate ...

mockServer.verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess())

// Test code that uses the above RestTemplate ...

mockServer.verify()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>MockRestServiceServer</code> （客户端REST测试的中心类）配置<code>RestTemplate</code>自定义<code>ClientHttpRequestFactory</code>断言实际请求超出期望，并返回“存根”响应。在这种情况下，我们希望有一个请求<code>/greeting</code>并希望返回200响应<code>text/plain</code>内容。我们可以根据需要定义其他预期的请求和存根响应。当我们定义预期的请求和存根响应时， <code>RestTemplate</code>可以照常在客户端代码中使用。在测试结束时， <code>mockServer.verify()</code>可用于验证是否满足所有期望。</p>
</div>
<div class="paragraph">
<p>默认情况下，请求应按声明的期望顺序进行。您可以设置<code>ignoreExpectOrder</code>选项在构建服务器时使用，在这种情况下，将检查所有期望（以便）以找到给定请求的匹配项。这意味着允许请求以任何顺序出现。以下示例使用<code>ignoreExpectOrder</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使默认情况下无顺序请求，每个请求也只能执行一次。的<code>expect</code>方法提供了接受一个重载变量<code>ExpectedCount</code>指定计数范围的参数（例如， <code>once</code> ， <code>manyTimes</code> ， <code>max</code> ， <code>min</code> ， <code>between</code> ， 等等）。以下示例使用<code>times</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

// ...

mockServer.verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val restTemplate = RestTemplate()

val mockServer = MockRestServiceServer.bindTo(restTemplate).build()
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess())
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess())

// ...

mockServer.verify()</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，当<code>ignoreExpectOrder</code>未设置（默认），因此，请求应按声明顺序进行，然后该顺序仅适用于任何预期请求中的第一个。例如，如果期望“ / something”两次，然后是“ / somewhere”三次，那么在请求“ / somewhere”之前应该先请求“ / something”，但是除了随后的“ /”东西”和“ /某处”，请求可以随时发出。</p>
</div>
<div class="paragraph">
<p>作为上述所有方法的替代，客户端测试支持还提供了一个<code>ClientHttpRequestFactory</code>您可以将其配置为<code>RestTemplate</code>绑定到一个<code>MockMvc</code>实例。这样就可以使用实际的服务器端逻辑来处理请求，而无需运行服务器。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

// Test code that uses the above RestTemplate ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()
restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))

// Test code that uses the above RestTemplate ...</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-client-static-imports"><a class="anchor" href="#spring-mvc-test-client-static-imports"></a>静态进口</h5>
<div class="paragraph">
<p>与服务器端测试一样，用于客户端测试的流利API需要进行一些静态导入。通过搜索很容易找到那些<code>MockRest*</code> 。Eclipse用户应添加<code>MockRestRequestMatchers.*</code>和<code>MockRestResponseCreators.*</code>在Java→编辑器→Content Assist→收藏夹下，作为Eclipse首选项中的“收藏夹静态成员”。这样可以在键入静态方法名称的第一个字符后使用内容辅助。其他IDE（例如IntelliJ）可能不需要任何其他配置。检查是否支持静态成员上的代码完成。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-mvc-test-client-resources"><a class="anchor" href="#spring-mvc-test-client-resources"></a>客户端REST测试的更多示例</h5>
<div class="paragraph">
<p>Spring MVC Test自己的测试包括客户端REST测试的<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples">示例</a>测试。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webtestclient"><a class="anchor" href="#webtestclient"></a> 3.7。WebTestClient</h3>
<div class="paragraph">
<p><code>WebTestClient</code>是围绕<a href="web-reactive.html#webflux-client">WebClient的</a>薄壳，使用它执行请求并公开专用的流利API来验证响应。
<code>WebTestClient</code>通过使用<a href="#mock-objects-web-reactive">模拟请求和响应</a>绑定到WebFlux应用程序，或者它可以通过HTTP连接测试任何Web服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Kotlin用户：请参阅<a href="languages.html#kotlin-webtestclient-issue">本节</a>与<code>WebTestClient</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="webtestclient-setup"><a class="anchor" href="#webtestclient-setup"></a> 3.7.1。设定</h4>
<div class="paragraph">
<p>创建一个<code>WebTestClient</code>您必须选择多个服务器设置选项之一。实际上，您正在配置WebFlux应用程序以绑定到或使用URL连接到正在运行的服务器。</p>
</div>
<div class="sect4">
<h5 id="webtestclient-controller-config"><a class="anchor" href="#webtestclient-controller-config"></a>绑定到控制器</h5>
<div class="paragraph">
<p>以下示例显示了如何创建服务器设置来测试一个<code>@Controller</code>一次：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client = WebTestClient.bindToController(new TestController()).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client = WebTestClient.bindToController(TestController()).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例加载<a href="web-reactive.html#webflux-config">WebFlux Java配置</a>并注册给定的控制器。使用模拟请求和响应对象，可以在没有HTTP服务器的情况下测试生成的WebFlux应用程序。构建器上有更多方法可以定制默认WebFlux Java配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-fn-config"><a class="anchor" href="#webtestclient-fn-config"></a>绑定到路由器功能</h5>
<div class="paragraph">
<p>以下示例显示如何通过<a href="web-reactive.html#webflux-fn">RouterFunction</a>设置服务器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;?&gt; route = ...
client = WebTestClient.bindToRouterFunction(route).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val route: RouterFunction&lt;*&gt; = ...
val client = WebTestClient.bindToRouterFunction(route).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在内部，配置被传递到<code>RouterFunctions.toWebHandler</code> 。使用模拟请求和响应对象，可以在没有HTTP服务器的情况下测试生成的WebFlux应用程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-context-config"><a class="anchor" href="#webtestclient-context-config"></a>绑定到<code>ApplicationContext</code></h5>
<div class="paragraph">
<p>以下示例显示了如何通过应用程序或其部分子集的Spring配置来设置服务器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringJUnitConfig(WebConfig.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTests {

    WebTestClient client;

    @BeforeEach
    void setUp(ApplicationContext context) {  <i class="conum" data-value="2"></i><b>(2)</b>
        client = WebTestClient.bindToApplicationContext(context).build(); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定要加载的配置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入配置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建<code>WebTestClient</code></td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(WebConfig::class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyTests {

    lateinit var client: WebTestClient

    @BeforeEach
    fun setUp(context: ApplicationContext) { <i class="conum" data-value="2"></i><b>(2)</b>
        client = WebTestClient.bindToApplicationContext(context).build() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定要加载的配置</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注入配置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建<code>WebTestClient</code></td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在内部，配置被传递到<code>WebHttpHandlerBuilder</code>建立请求处理链。有关更多详细信息，请参见<a href="web-reactive.html#webflux-web-handler-api">WebHandler API</a> 。使用模拟请求和响应对象，可以在没有HTTP服务器的情况下测试生成的WebFlux应用程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-server-config"><a class="anchor" href="#webtestclient-server-config"></a>绑定到服务器</h5>
<div class="paragraph">
<p>以下服务器设置选项使您可以连接到正在运行的服务器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-client-config"><a class="anchor" href="#webtestclient-client-config"></a>客户建设者</h5>
<div class="paragraph">
<p>除了前面描述的服务器设置选项之外，您还可以配置客户端选项，包括基本URL，默认标头，客户端过滤器等。这些选项可以随时使用<code>bindToServer</code> 。对于其他所有人，您需要使用<code>configureClient()</code>从服务器配置过渡到客户端配置，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client = WebTestClient.bindToController(new TestController())
        .configureClient()
        .baseUrl("/test")
        .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client = WebTestClient.bindToController(TestController())
        .configureClient()
        .baseUrl("/test")
        .build()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webtestclient-tests"><a class="anchor" href="#webtestclient-tests"></a> 3.7.2。写作测试</h4>
<div class="paragraph">
<p><code>WebTestClient</code>通过使用以下命令提供与<a href="web-reactive.html#webflux-client">WebClient</a>相同的API直到执行请求为止<code>exchange()</code> 。之后会发生什么<code>exchange()</code>是用于验证响应的链式API工作流程。</p>
</div>
<div class="paragraph">
<p>通常，首先声明响应状态和标头，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client.get().uri("/persons/1")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client.get().uri("/persons/1")
        .accept(MediaType.APPLICATION_JSON)
        .exchange()
        .expectStatus().isOk()
        .expectHeader().contentType(MediaType.APPLICATION_JSON)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您指定如何解码和使用响应主体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectBody(Class<T>)</code> ：解码为单个对象。</p>
</li>
<li>
<p><code>expectBodyList(Class<T>)</code> ：解码并收集对象到<code>List<T></code> 。</p>
</li>
<li>
<p><code>expectBody()</code> ：解码为<code>byte[]</code> <a href="#webtestclient-json">JSON内容</a>或空的正文。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，您可以对主体使用内置的断言。下面的示例显示了一种方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBodyList(Person.class).hasSize(3).contains(person);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.reactive.server.expectBodyList

client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBodyList&lt;Person&gt;().hasSize(3).contains(person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以超越内置的断言并创建自己的断言，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.test.web.reactive.server.expectBody

client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .consumeWith(result -&gt; {
            // custom assertions (e.g. AssertJ)...
        });</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody&lt;Person&gt;()
        .consumeWith {
            // custom assertions (e.g. AssertJ)...
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以退出工作流程并获得结果，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">EntityExchangeResult&lt;Person&gt; result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody(Person.class)
        .returnResult();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.reactive.server.expectBody

val result = client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk
        .expectBody&lt;Person&gt;()
        .returnResult()</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">当您需要使用泛型解码为目标类型时，请寻找可以接受的重载方法<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/ParameterizedTypeReference.html"><code>ParameterizedTypeReference</code></a>代替<code>Class<T></code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="webtestclient-no-content"><a class="anchor" href="#webtestclient-no-content"></a>无内容</h5>
<div class="paragraph">
<p>如果响应中没有内容（或者您不在乎），请使用<code>Void.class</code> ，以确保释放资源。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client.get().uri("/persons/123")
        .exchange()
        .expectStatus().isNotFound()
        .expectBody(Void.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client.get().uri("/persons/123")
        .exchange()
        .expectStatus().isNotFound
        .expectBody&lt;Unit&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果要断言没有响应内容，则可以使用类似于以下内容的代码：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client.post().uri("/persons")
        .body(personMono, Person.class)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client.post().uri("/persons")
        .bodyValue(person)
        .exchange()
        .expectStatus().isCreated()
        .expectBody().isEmpty()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-json"><a class="anchor" href="#webtestclient-json"></a> JSON内容</h5>
<div class="paragraph">
<p>使用时<code>expectBody()</code> ，响应作为<code>byte[]</code> 。这对于原始内容声明很有用。例如，您可以使用<a href="https://jsonassert.skyscreamer.org">JSONAssert</a>来验证JSON内容，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json("{\"name\":\"Jane\"}")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client.get().uri("/persons/1")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .json("{\"name\":\"Jane\"}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用<a href="https://github.com/jayway/JsonPath">JSONPath</a>表达式，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Jane")
        .jsonPath("$[1].name").isEqualTo("Jason");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">client.get().uri("/persons")
        .exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Jane")
        .jsonPath("$[1].name").isEqualTo("Jason")</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-stream"><a class="anchor" href="#webtestclient-stream"></a>流式响应</h5>
<div class="paragraph">
<p>测试无限流（例如， <code>"text/event-stream"</code>要么<code>"application/stream+json"</code> ），您需要退出链接的API（通过使用<code>returnResult</code> ），紧接在响应状态和标头声明之后，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">FluxExchangeResult&lt;MyEvent&gt; result = client.get().uri("/events")
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult(MyEvent.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.test.web.reactive.server.returnResult

val result = client.get().uri("/events")
        .accept(TEXT_EVENT_STREAM)
        .exchange()
        .expectStatus().isOk()
        .returnResult&lt;MyEvent&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您可以食用<code>Flux<T></code> ，在它们到达时声明已解码的对象，然后在达到测试目标时在某个时候取消。我们建议使用<code>StepVerifier</code>来自<code>reactor-test</code>模块执行此操作，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Event&gt; eventFlux = result.getResponseBody();

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith(p -&gt; ...)
        .thenCancel()
        .verify();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val eventFlux = result.getResponseBody()

StepVerifier.create(eventFlux)
        .expectNext(person)
        .expectNextCount(4)
        .consumeNextWith { p -&gt; ... }
        .thenCancel()
        .verify()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webtestclient-request-body"><a class="anchor" href="#webtestclient-request-body"></a>请求正文</h5>
<div class="paragraph">
<p>当涉及建立请求时， <code>WebTestClient</code>提供与<code>WebClient</code> ，并且实现大部分是简单的传递。有关如何使用正文准备请求的示例，请参阅<a href="web-reactive.html#webflux-client-body">WebClient文档</a> ，包括提交表单数据，多部分请求等。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-resources"><a class="anchor" href="#testing-resources"></a> 4。更多资源</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有关测试的更多信息，请参见以下资源：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.junit.org/">JUnit</a> ：“一个程序员友好的Java测试框架”。由Spring Framework在其测试套件中使用，并在<a href="#testcontext-framework">Spring TestContext Framework中</a>得到支持。</p>
</li>
<li>
<p><a href="https://testng.org/">TestNG</a> ：一个受JUnit启发的测试框架，它对测试组，数据驱动的测试，分布式测试和其他功能提供了额外的支持。在<a href="#testcontext-framework">Spring TestContext Framework中</a>受支持</p>
</li>
<li>
<p><a href="https://joel-costigliola.github.io/assertj/">AssertJ</a> ：“ Java的有效断言”，包括对Java 8 lambda，流和其他功能的支持。</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Mock_Object">模拟对象</a> ：维基百科中的文章。</p>
</li>
<li>
<p><a href="http://www.mockobjects.com/">MockObjects.com</a> ：专门用于模拟对象的网站，一种用于在测试驱动的开发中改进代码设计的技术。</p>
</li>
<li>
<p><a href="https://mockito.github.io">Mockito</a> ：基于<a href="http://xunitpatterns.com/Test Spy.html">Test Spy</a>模式的Java模拟库。由Spring Framework在其测试套件中使用。</p>
</li>
<li>
<p><a href="https://easymock.org/">EasyMock</a> ：Java库“通过使用Java的代理机制动态生成接口来为接口（以及通过类扩展的对象）提供Mock对象。”</p>
</li>
<li>
<p><a href="https://jmock.org/">JMock</a> ：支持使用模拟对象测试驱动的Java代码开发的库。</p>
</li>
<li>
<p><a href="https://www.dbunit.org/">DbUnit</a> ：JUnit扩展（也可与Ant和Maven一起使用），针对数据库驱动的项目，除其他外，它使数据库在测试运行之间进入已知状态。</p>
</li>
<li>
<p><a href="https://sourceforge.net/projects/grinder/">Grinder</a> ：Java负载测试框架。</p>
</li>
<li>
<p><a href="https://github.com/Ninja-Squad/springmockk">SpringMockK</a> ：支持使用<a href="https://mockk.io/">MockK</a>而不是Mockito用Kotlin编写的Spring Boot集成测试。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:52 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>