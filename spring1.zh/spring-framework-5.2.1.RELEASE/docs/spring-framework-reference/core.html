<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>核心技术</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



</head><body id="spring-core" class="book toc2 toc-left" ><div id="header">
<h1>核心技术</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#beans">1。IoC容器</a>
<ul class="sectlevel2">
<li><a href="#beans-introduction">1.1。Spring IoC容器和Bean简介</a></li>
<li><a href="#beans-basics">1.2。容器概述</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-metadata">1.2.1。配置元数据</a></li>
<li><a href="#beans-factory-instantiation">1.2.2。实例化容器</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-xml-import">组成基于XML的配置元数据</a></li>
<li><a href="#groovy-bean-definition-dsl">Groovy Bean定义DSL</a></li>
</ul>
</li>
<li><a href="#beans-factory-client">1.2.3。使用容器</a></li>
</ul>
</li>
<li><a href="#beans-definition">1.3。Bean总览</a>
<ul class="sectlevel3">
<li><a href="#beans-beanname">1.3.1。命名豆</a>
<ul class="sectlevel4">
<li><a href="#beans-beanname-alias">在Bean定义之外别名Bean</a></li>
</ul>
</li>
<li><a href="#beans-factory-class">1.3.2。实例化豆</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-class-ctor">用构造函数实例化</a></li>
<li><a href="#beans-factory-class-static-factory-method">用静态工厂方法实例化</a></li>
<li><a href="#beans-factory-class-instance-factory-method">使用实例工厂方法实例化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-dependencies">1.4。依存关系</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-collaborators">1.4.1。依赖注入</a>
<ul class="sectlevel4">
<li><a href="#beans-constructor-injection">基于构造函数的依赖注入</a></li>
<li><a href="#beans-setter-injection">基于Setter的依赖注入</a></li>
<li><a href="#beans-dependency-resolution">依赖性解析过程</a></li>
<li><a href="#beans-some-examples">依赖注入的例子</a></li>
</ul>
</li>
<li><a href="#beans-factory-properties-detailed">1.4.2。依赖性和详细配置</a>
<ul class="sectlevel4">
<li><a href="#beans-value-element">直值（原语，字符串等）</a></li>
<li><a href="#beans-ref-element">对其他Bean的引用（协作者）</a></li>
<li><a href="#beans-inner-beans">内豆</a></li>
<li><a href="#beans-collection-elements">馆藏</a></li>
<li><a href="#beans-null-element">空字符串值和空字符串值</a></li>
<li><a href="#beans-p-namespace">带p命名空间的XML快捷方式</a></li>
<li><a href="#beans-c-namespace">具有c-namespace的XML快捷方式</a></li>
<li><a href="#beans-compound-property-names">复合属性名称</a></li>
</ul>
</li>
<li><a href="#beans-factory-dependson">1.4.3。使用<code>depends-on</code></a></li>
<li><a href="#beans-factory-lazy-init">1.4.4。懒初始化豆</a></li>
<li><a href="#beans-factory-autowire">1.4.5。自动装配协作器</a>
<ul class="sectlevel4">
<li><a href="#beans-autowired-exceptions">自动接线的局限性和缺点</a></li>
<li><a href="#beans-factory-autowire-candidate">从自动装配中排除Bean</a></li>
</ul>
</li>
<li><a href="#beans-factory-method-injection">1.4.6。方法注入</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lookup-method-injection">查找方法注入</a></li>
<li><a href="#beans-factory-arbitrary-method-replacement">任意方法替换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-scopes">1.5。豆范围</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-scopes-singleton">1.5.1。单例范围</a></li>
<li><a href="#beans-factory-scopes-prototype">1.5.2。原型范围</a></li>
<li><a href="#beans-factory-scopes-sing-prot-interaction">1.5.3。具有原型Bean依赖关系的Singleton Bean</a></li>
<li><a href="#beans-factory-scopes-other">1.5.4。请求，会话，应用程序和WebSocket范围</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-other-web-configuration">初始Web配置</a></li>
<li><a href="#beans-factory-scopes-request">要求范围</a></li>
<li><a href="#beans-factory-scopes-session">会议范围</a></li>
<li><a href="#beans-factory-scopes-application">适用范围</a></li>
<li><a href="#beans-factory-scopes-other-injection">范围豆作为依赖项</a></li>
</ul>
</li>
<li><a href="#beans-factory-scopes-custom">1.5.5。自定义范围</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-custom-creating">创建自定义范围</a></li>
<li><a href="#beans-factory-scopes-custom-using">使用自定义范围</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-nature">1.6。自定义豆的性质</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-lifecycle">1.6.1。生命周期回调</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lifecycle-initializingbean">初始化回调</a></li>
<li><a href="#beans-factory-lifecycle-disposablebean">销毁回调</a></li>
<li><a href="#beans-factory-lifecycle-default-init-destroy-methods">默认初始化和销毁方法</a></li>
<li><a href="#beans-factory-lifecycle-combined-effects">组合生命周期机制</a></li>
<li><a href="#beans-factory-lifecycle-processor">启动和关机回调</a></li>
<li><a href="#beans-factory-shutdown">在非Web应用程序中正常关闭Spring IoC容器</a></li>
</ul>
</li>
<li><a href="#beans-factory-aware">1.6.2。 <code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></li>
<li><a href="#aware-list">1.6.3。其他<code>Aware</code>介面</a></li>
</ul>
</li>
<li><a href="#beans-child-bean-definitions">1.7。Bean定义继承</a></li>
<li><a href="#beans-factory-extension">1.8。集装箱延伸点</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-extension-bpp">1.8.1。使用a自定义Bean <code>BeanPostProcessor</code></a>
<ul class="sectlevel4">
<li><a href="#beans-factory-extension-bpp-examples-hw">范例：Hello World， <code>BeanPostProcessor</code> -样式</a></li>
<li><a href="#beans-factory-extension-bpp-examples-rabpp">示例：<code>RequiredAnnotationBeanPostProcessor</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factory-postprocessors">1.8.2。使用以下命令自定义配置元数据<code>BeanFactoryPostProcessor</code></a>
<ul class="sectlevel4">
<li><a href="#beans-factory-placeholderconfigurer">示例：类名替换<code>PropertySourcesPlaceholderConfigurer</code></a></li>
<li><a href="#beans-factory-overrideconfigurer">示例：<code>PropertyOverrideConfigurer</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factorybean">1.8.3。自定义实例化逻辑<code>FactoryBean</code></a></li>
</ul>
</li>
<li><a href="#beans-annotation-config">1.9。基于注释的容器配置</a>
<ul class="sectlevel3">
<li><a href="#beans-required-annotation">1.9.1。@Required</a></li>
<li><a href="#beans-autowired-annotation">1.9.2。使用<code>@Autowired</code></a></li>
<li><a href="#beans-autowired-annotation-primary">1.9.3。通过微调基于注释的自动装配<code>@Primary</code></a></li>
<li><a href="#beans-autowired-annotation-qualifiers">1.9.4。使用限定符对基于注释的自动装配进行微调</a></li>
<li><a href="#beans-generics-as-qualifiers">1.9.5。将泛型用作自动装配限定符</a></li>
<li><a href="#beans-custom-autowire-configurer">1.9.6。使用<code>CustomAutowireConfigurer</code></a></li>
<li><a href="#beans-resource-annotation">1.9.7。注射用<code>@Resource</code></a></li>
<li><a href="#beans-value-annotations">1.9.8。使用<code>@Value</code></a></li>
<li><a href="#beans-postconstruct-and-predestroy-annotations">1.9.9。使用<code>@PostConstruct</code>和<code>@PreDestroy</code></a></li>
</ul>
</li>
<li><a href="#beans-classpath-scanning">1.10。类路径扫描和托管组件</a>
<ul class="sectlevel3">
<li><a href="#beans-stereotype-annotations">1.10.1。 <code>@Component</code>和更多的刻板印象注释</a></li>
<li><a href="#beans-meta-annotations">1.10.2。使用元注释和组合注释</a></li>
<li><a href="#beans-scanning-autodetection">1.10.3。自动检测类并注册Bean定义</a></li>
<li><a href="#beans-scanning-filters">1.10.4。使用过滤器自定义扫描</a></li>
<li><a href="#beans-factorybeans-annotations">1.10.5。在组件中定义Bean元数据</a></li>
<li><a href="#beans-scanning-name-generator">1.10.6。命名自动检测的组件</a></li>
<li><a href="#beans-scanning-scope-resolver">1.10.7。提供自动检测组件的范围</a></li>
<li><a href="#beans-scanning-qualifiers">1.10.8。提供带有注释的限定符元数据</a></li>
<li><a href="#beans-scanning-index">1.10.9。生成候选组件的索引</a></li>
</ul>
</li>
<li><a href="#beans-standard-annotations">1.11。使用JSR 330标准注释</a>
<ul class="sectlevel3">
<li><a href="#beans-inject-named">1.11.1。依赖注入<code>@Inject</code>和<code>@Named</code></a></li>
<li><a href="#beans-named">1.11.2。 <code>@Named</code>和<code>@ManagedBean</code> ：等价于<code>@Component</code>注解</a></li>
<li><a href="#beans-standard-annotations-limitations">1.11.3。JSR-330标准注释的局限性</a></li>
</ul>
</li>
<li><a href="#beans-java">1.12。基于Java的容器配置</a>
<ul class="sectlevel3">
<li><a href="#beans-java-basic-concepts">1.12.1。基本概念： <code>@Bean</code>和<code>@Configuration</code></a></li>
<li><a href="#beans-java-instantiating-container">1.12.2。使用实例化Spring容器<code>AnnotationConfigApplicationContext</code></a>
<ul class="sectlevel4">
<li><a href="#beans-java-instantiating-container-constructor">施工简单</a></li>
<li><a href="#beans-java-instantiating-container-register">通过使用编程方式构建容器<code>register(Class<?>…​)</code></a></li>
<li><a href="#beans-java-instantiating-container-scan">使用启用组件扫描<code>scan(String…​)</code></a></li>
<li><a href="#beans-java-instantiating-container-web">支持Web应用程序<code>AnnotationConfigWebApplicationContext</code></a></li>
</ul>
</li>
<li><a href="#beans-java-bean-annotation">1.12.3。使用<code>@Bean</code>注解</a>
<ul class="sectlevel4">
<li><a href="#beans-java-declaring-a-bean">声明一个豆</a></li>
<li><a href="#beans-java-dependencies">Bean依赖</a></li>
<li><a href="#beans-java-lifecycle-callbacks">接收生命周期回调</a></li>
<li><a href="#beans-java-specifying-bean-scope">指定Bean范围</a></li>
<li><a href="#beans-java-customizing-bean-naming">自定义Bean命名</a></li>
<li><a href="#beans-java-bean-aliasing">Bean别名</a></li>
<li><a href="#beans-java-bean-description">豆描述</a></li>
</ul>
</li>
<li><a href="#beans-java-configuration-annotation">1.12.4。使用<code>@Configuration</code>注解</a>
<ul class="sectlevel4">
<li><a href="#beans-java-injecting-dependencies">注入bean间的依赖关系</a></li>
<li><a href="#beans-java-method-injection">查找方法注入</a></li>
<li><a href="#beans-java-further-information-java-config">有关基于Java的配置在内部如何工作的更多信息</a></li>
</ul>
</li>
<li><a href="#beans-java-composing-configuration-classes">1.12.5。组成基于Java的配置</a>
<ul class="sectlevel4">
<li><a href="#beans-java-using-import">使用<code>@Import</code>注解</a></li>
<li><a href="#beans-java-conditional">有条件地包括<code>@Configuration</code>类或<code>@Bean</code>方法</a></li>
<li><a href="#beans-java-combining">结合Java和XML配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-environment">1.13。环境抽象</a>
<ul class="sectlevel3">
<li><a href="#beans-definition-profiles">1.13.1。Bean定义配置文件</a>
<ul class="sectlevel4">
<li><a href="#beans-definition-profiles-java">使用<code>@Profile</code></a></li>
<li><a href="#beans-definition-profiles-xml">XML Bean定义配置文件</a></li>
<li><a href="#beans-definition-profiles-enable">激活个人资料</a></li>
<li><a href="#beans-definition-profiles-default">默认配置文件</a></li>
</ul>
</li>
<li><a href="#beans-property-source-abstraction">1.13.2。 <code>PropertySource</code> 抽象化</a></li>
<li><a href="#beans-using-propertysource">1.13.3。使用<code>@PropertySource</code></a></li>
<li><a href="#beans-placeholder-resolution-in-statements">1.13.4。声明中的占位符解析</a></li>
</ul>
</li>
<li><a href="#context-load-time-weaver">1.14。注册一个<code>LoadTimeWeaver</code></a></li>
<li><a href="#context-introduction">1.15。的其他功能<code>ApplicationContext</code></a>
<ul class="sectlevel3">
<li><a href="#context-functionality-messagesource">1.15.1。国际化使用<code>MessageSource</code></a></li>
<li><a href="#context-functionality-events">1.15.2。标准和自定义事件</a>
<ul class="sectlevel4">
<li><a href="#context-functionality-events-annotation">基于注释的事件侦听器</a></li>
<li><a href="#context-functionality-events-async">异步侦听器</a></li>
<li><a href="#context-functionality-events-order">订购听众</a></li>
<li><a href="#context-functionality-events-generics">一般事件</a></li>
</ul>
</li>
<li><a href="#context-functionality-resources">1.15.3。方便地访问低级资源</a></li>
<li><a href="#context-create">1.15.4。Web应用程序的便捷ApplicationContext实例化</a></li>
<li><a href="#context-deploy-rar">1.15.5。部署 Spring <code>ApplicationContext</code>作为Java EE RAR文件</a></li>
</ul>
</li>
<li><a href="#beans-beanfactory">1.16。的<code>BeanFactory</code></a>
<ul class="sectlevel3">
<li><a href="#context-introduction-ctx-vs-beanfactory">1.16.1。 <code>BeanFactory</code>要么<code>ApplicationContext</code> ？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">2。资源资源</a>
<ul class="sectlevel2">
<li><a href="#resources-introduction">2.1。介绍</a></li>
<li><a href="#resources-resource">2.2。资源接口</a></li>
<li><a href="#resources-implementations">2.3。内置资源实现</a>
<ul class="sectlevel3">
<li><a href="#resources-implementations-urlresource">2.3.1。<code>UrlResource</code></a></li>
<li><a href="#resources-implementations-classpathresource">2.3.2。<code>ClassPathResource</code></a></li>
<li><a href="#resources-implementations-filesystemresource">2.3.3。<code>FileSystemResource</code></a></li>
<li><a href="#resources-implementations-servletcontextresource">2.3.4。<code>ServletContextResource</code></a></li>
<li><a href="#resources-implementations-inputstreamresource">2.3.5。<code>InputStreamResource</code></a></li>
<li><a href="#resources-implementations-bytearrayresource">2.3.6。<code>ByteArrayResource</code></a></li>
</ul>
</li>
<li><a href="#resources-resourceloader">2.4。的<code>ResourceLoader</code></a></li>
<li><a href="#resources-resourceloaderaware">2.5。的<code>ResourceLoaderAware</code>接口</a></li>
<li><a href="#resources-as-dependencies">2.6。资源依赖</a></li>
<li><a href="#resources-app-ctx">2.7。应用程序上下文和资源路径</a>
<ul class="sectlevel3">
<li><a href="#resources-app-ctx-construction">2.7.1。构造应用程序上下文</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-classpathxml">建造中<code>ClassPathXmlApplicationContext</code>实例-快捷方式</a></li>
</ul>
</li>
<li><a href="#resources-app-ctx-wildcards-in-resource-paths">2.7.2。应用程序上下文构造函数资源路径中的通配符</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-ant-patterns-in-paths">蚂蚁风格的图案</a></li>
<li><a href="#resources-classpath-wildcards">的<code>classpath*:</code>字首</a></li>
<li><a href="#resources-wildcards-in-path-other-stuff">有关通配符的其他说明</a></li>
</ul>
</li>
<li><a href="#resources-filesystemresource-caveats">2.7.3。 <code>FileSystemResource</code> 注意事项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#validation">3。验证，数据绑定和类型转换</a>
<ul class="sectlevel2">
<li><a href="#validator">3.1。通过使用Spring的Validator接口进行验证</a></li>
<li><a href="#validation-conversion">3.2。将代码解析为错误消息</a></li>
<li><a href="#beans-beans">3.3。Bean操作和<code>BeanWrapper</code></a>
<ul class="sectlevel3">
<li><a href="#beans-beans-conventions">3.3.1。设置和获取基本和嵌套属性</a></li>
<li><a href="#beans-beans-conversion">3.3.2。内建<code>PropertyEditor</code>实作</a>
<ul class="sectlevel4">
<li><a href="#beans-beans-conversion-customeditor-registration">注册其他自定义<code>PropertyEditor</code>实作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core-convert">3.4。 Spring 类型转换</a>
<ul class="sectlevel3">
<li><a href="#core-convert-Converter-API">3.4.1。转换器SPI</a></li>
<li><a href="#core-convert-ConverterFactory-SPI">3.4.2。使用<code>ConverterFactory</code></a></li>
<li><a href="#core-convert-GenericConverter-SPI">3.4.3。使用<code>GenericConverter</code></a>
<ul class="sectlevel4">
<li><a href="#core-convert-ConditionalGenericConverter-SPI">使用<code>ConditionalGenericConverter</code></a></li>
</ul>
</li>
<li><a href="#core-convert-ConversionService-API">3.4.4。的<code>ConversionService</code> API</a></li>
<li><a href="#core-convert-Spring-config">3.4.5。配置一个<code>ConversionService</code></a></li>
<li><a href="#core-convert-programmatic-usage">3.4.6。用一个<code>ConversionService</code>以编程方式</a></li>
</ul>
</li>
<li><a href="#format">3.5。Spring字段格式</a>
<ul class="sectlevel3">
<li><a href="#format-Formatter-SPI">3.5.1。的<code>Formatter</code> SPI</a></li>
<li><a href="#format-CustomFormatAnnotations">3.5.2。注释驱动的格式</a>
<ul class="sectlevel4">
<li><a href="#format-annotations-api">格式注释API</a></li>
</ul>
</li>
<li><a href="#format-FormatterRegistry-SPI">3.5.3。的<code>FormatterRegistry</code> SPI</a></li>
<li><a href="#format-FormatterRegistrar-SPI">3.5.4。的<code>FormatterRegistrar</code> SPI</a></li>
<li><a href="#format-configuring-formatting-mvc">3.5.5。在Spring MVC中配置格式</a></li>
</ul>
</li>
<li><a href="#format-configuring-formatting-globaldatetimeformat">3.6。配置全局日期和时间格式</a></li>
<li><a href="#validation-beanvalidation">3.7。Spring Validation</a>
<ul class="sectlevel3">
<li><a href="#validation-beanvalidation-overview">3.7.1。JSR-303 Bean验证API概述</a></li>
<li><a href="#validation-beanvalidation-spring">3.7.2。配置Bean验证提供程序</a>
<ul class="sectlevel4">
<li><a href="#validation-beanvalidation-spring-inject">注入验证器</a></li>
<li><a href="#validation-beanvalidation-spring-constraints">配置自定义约束</a></li>
<li><a href="#validation-beanvalidation-spring-method"> Spring-driven 方法验证</a></li>
<li><a href="#validation-beanvalidation-spring-other">其他配置选项</a></li>
</ul>
</li>
<li><a href="#validation-binder">3.7.3。配置一个<code>DataBinder</code></a></li>
<li><a href="#validation-mvc">3.7.4。Spring MVC 3验证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions">4。 Spring Expression Language （SpEL）</a>
<ul class="sectlevel2">
<li><a href="#expressions-evaluation">4.1。评价</a>
<ul class="sectlevel3">
<li><a href="#expressions-evaluation-context">4.1.1。理解<code>EvaluationContext</code></a>
<ul class="sectlevel4">
<li><a href="#expressions-type-conversion">类型转换</a></li>
</ul>
</li>
<li><a href="#expressions-parser-configuration">4.1.2。解析器配置</a></li>
<li><a href="#expressions-spel-compilation">4.1.3。SpEL编译</a>
<ul class="sectlevel4">
<li><a href="#expressions-compiler-configuration">编译器配置</a></li>
<li><a href="#expressions-compiler-limitations">编译器限制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions-beandef">4.2。Bean定义中的表达式</a>
<ul class="sectlevel3">
<li><a href="#expressions-beandef-xml-based">4.2.1。XML配置</a></li>
<li><a href="#expressions-beandef-annotation-based">4.2.2。注释配置</a></li>
</ul>
</li>
<li><a href="#expressions-language-ref">4.3。语言参考</a>
<ul class="sectlevel3">
<li><a href="#expressions-ref-literal">4.3.1。文字表达</a></li>
<li><a href="#expressions-properties-arrays">4.3.2。属性，数组，列表，映射和索引器</a></li>
<li><a href="#expressions-inline-lists">4.3.3。内联列表</a></li>
<li><a href="#expressions-inline-maps">4.3.4。内联地图</a></li>
<li><a href="#expressions-array-construction">4.3.5。阵列构造</a></li>
<li><a href="#expressions-methods">4.3.6。方法</a></li>
<li><a href="#expressions-operators">4.3.7。经营者</a>
<ul class="sectlevel4">
<li><a href="#expressions-operators-relational">关系运算符</a></li>
<li><a href="#expressions-operators-logical">逻辑运算符</a></li>
<li><a href="#expressions-operators-mathematical">数学运算符</a></li>
<li><a href="#expressions-assignment">赋值运算符</a></li>
</ul>
</li>
<li><a href="#expressions-types">4.3.8。种类</a></li>
<li><a href="#expressions-constructors">4.3.9。建设者</a></li>
<li><a href="#expressions-ref-variables">4.3.10。变数</a>
<ul class="sectlevel4">
<li><a href="#expressions-this-root">的<code>#this</code>和<code>#root</code>变数</a></li>
</ul>
</li>
<li><a href="#expressions-ref-functions">4.3.11。功能</a></li>
<li><a href="#expressions-bean-references">4.3.12。Bean参考</a></li>
<li><a href="#expressions-operator-ternary">4.3.13。三元运算符（If-Then-Else）</a></li>
<li><a href="#expressions-operator-elvis">4.3.14。猫王算子</a></li>
<li><a href="#expressions-operator-safe-navigation">4.3.15。安全导航操作员</a></li>
<li><a href="#expressions-collection-selection">4.3.16。馆藏选择</a></li>
<li><a href="#expressions-collection-projection">4.3.17。集合投影</a></li>
<li><a href="#expressions-templating">4.3.18。表达式模板</a></li>
</ul>
</li>
<li><a href="#expressions-example-classes">4.4。示例中使用的类</a></li>
</ul>
</li>
<li><a href="#aop">5，Spring面向切面的编程</a>
<ul class="sectlevel2">
<li><a href="#aop-introduction-defn">5.1。AOP概念</a></li>
<li><a href="#aop-introduction-spring-defn">5.2。Spring AOP能力和目标</a></li>
<li><a href="#aop-introduction-proxies">5.3。AOP代理</a></li>
<li><a href="#aop-ataspectj">5.4。@AspectJ支持</a>
<ul class="sectlevel3">
<li><a href="#aop-aspectj-support">5.4.1。启用@AspectJ支持</a>
<ul class="sectlevel4">
<li><a href="#aop-enable-aspectj-java">通过Java配置启用@AspectJ支持</a></li>
<li><a href="#aop-enable-aspectj-xml">通过XML配置启用@AspectJ支持</a></li>
</ul>
</li>
<li><a href="#aop-at-aspectj">5.4.2。声明一个方面</a></li>
<li><a href="#aop-pointcuts">5.4.3。声明切入点</a>
<ul class="sectlevel4">
<li><a href="#aop-pointcuts-designators">支持的切入点指示符</a></li>
<li><a href="#aop-pointcuts-combining">组合切入点表达式</a></li>
<li><a href="#aop-common-pointcuts">共享通用切入点定义</a></li>
<li><a href="#aop-pointcuts-examples">例子</a></li>
<li><a href="#writing-good-pointcuts">写好切入点</a></li>
</ul>
</li>
<li><a href="#aop-advice">5.4.4。宣告建议</a>
<ul class="sectlevel4">
<li><a href="#aop-advice-before">咨询前</a></li>
<li><a href="#aop-advice-after-returning">返回建议后</a></li>
<li><a href="#aop-advice-after-throwing">投掷建议后</a></li>
<li><a href="#aop-advice-after-finally">经过（最后）建议</a></li>
<li><a href="#aop-ataspectj-around-advice">忠告</a></li>
<li><a href="#aop-ataspectj-advice-params">建议参数</a></li>
<li><a href="#aop-ataspectj-advice-ordering">咨询订购</a></li>
</ul>
</li>
<li><a href="#aop-introductions">5.4.5。引言</a></li>
<li><a href="#aop-instantiation-models">5.4.6。方面实例化模型</a></li>
<li><a href="#aop-ataspectj-example">5.4.7。AOP示例</a></li>
</ul>
</li>
<li><a href="#aop-schema">5.5。基于架构的AOP支持</a>
<ul class="sectlevel3">
<li><a href="#aop-schema-declaring-an-aspect">5.5.1。声明一个方面</a></li>
<li><a href="#aop-schema-pointcuts">5.5.2。声明切入点</a></li>
<li><a href="#aop-schema-advice">5.5.3。宣告建议</a>
<ul class="sectlevel4">
<li><a href="#aop-schema-advice-before">咨询前</a></li>
<li><a href="#aop-schema-advice-after-returning">返回建议后</a></li>
<li><a href="#aop-schema-advice-after-throwing">投掷建议后</a></li>
<li><a href="#aop-schema-advice-after-finally">经过（最后）建议</a></li>
<li><a href="#aop-schema-advice-around">忠告</a></li>
<li><a href="#aop-schema-params">建议参数</a></li>
<li><a href="#aop-ordering">咨询订购</a></li>
</ul>
</li>
<li><a href="#aop-schema-introductions">5.5.4。引言</a></li>
<li><a href="#aop-schema-instatiation-models">5.5.5。方面实例化模型</a></li>
<li><a href="#aop-schema-advisors">5.5.6。顾问</a></li>
<li><a href="#aop-schema-example">5.5.7。AOP模式示例</a></li>
</ul>
</li>
<li><a href="#aop-choosing">5.6。选择要使用的AOP声明样式</a>
<ul class="sectlevel3">
<li><a href="#aop-spring-or-aspectj">5.6.1。Spring AOP还是Full AspectJ？</a></li>
<li><a href="#aop-ataspectj-or-xml">5.6.2。@AspectJ或Spring AOP的XML？</a></li>
</ul>
</li>
<li><a href="#aop-mixing-styles">5.7。混合方面类型</a></li>
<li><a href="#aop-proxying">5.8。代理机制</a>
<ul class="sectlevel3">
<li><a href="#aop-understanding-aop-proxies">5.8.1。了解AOP代理</a></li>
</ul>
</li>
<li><a href="#aop-aspectj-programmatic">5.9。以编程方式创建@AspectJ代理</a></li>
<li><a href="#aop-using-aspectj">5.10。在Spring应用程序中使用AspectJ</a>
<ul class="sectlevel3">
<li><a href="#aop-atconfigurable">5.10.1。使用AspectJ通过Spring依赖注入域对象</a>
<ul class="sectlevel4">
<li><a href="#aop-configurable-testing">单元测试<code>@Configurable</code>对象</a></li>
<li><a href="#aop-configurable-container">使用多个应用程序上下文</a></li>
</ul>
</li>
<li><a href="#aop-ajlib-other">5.10.2。AspectJ的其他Spring方面</a></li>
<li><a href="#aop-aj-configure">5.10.3。使用Spring IoC配置AspectJ Aspects</a></li>
<li><a href="#aop-aj-ltw">5.10.4。在Spring Framework中使用AspectJ进行加载时编织</a>
<ul class="sectlevel4">
<li><a href="#aop-aj-ltw-first-example">第一个例子</a></li>
<li><a href="#aop-aj-ltw-the-aspects">方面</a></li>
<li><a href="#aop-aj-ltw-aop_dot_xml">'META-INF / aop.xml'</a></li>
<li><a href="#aop-aj-ltw-libraries">所需的库（JARS）</a></li>
<li><a href="#aop-aj-ltw-spring">Spring 配置</a></li>
<li><a href="#aop-aj-ltw-environments">特定于环境的配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-resources">5.11。更多资源</a></li>
</ul>
</li>
<li><a href="#aop-api">6。Spring AOP API</a>
<ul class="sectlevel2">
<li><a href="#aop-api-pointcuts">6.1。Spring中的Pointcut API</a>
<ul class="sectlevel3">
<li><a href="#aop-api-concepts">6.1.1。概念</a></li>
<li><a href="#aop-api-pointcut-ops">6.1.2。切入点的操作</a></li>
<li><a href="#aop-api-pointcuts-aspectj">6.1.3。AspectJ表达切入点</a></li>
<li><a href="#aop-api-pointcuts-impls">6.1.4。便捷切入点实现</a>
<ul class="sectlevel4">
<li><a href="#aop-api-pointcuts-static">静态切入点</a></li>
<li><a href="#aop-api-pointcuts-dynamic">动态切入点</a></li>
</ul>
</li>
<li><a href="#aop-api-pointcuts-superclasses">6.1.5。切入点超类</a></li>
<li><a href="#aop-api-pointcuts-custom">6.1.6。自定义切入点</a></li>
</ul>
</li>
<li><a href="#aop-api-advice">6.2。Advice API in Spring</a>
<ul class="sectlevel3">
<li><a href="#aop-api-advice-lifecycle">6.2.1。Advice 生命周期</a></li>
<li><a href="#aop-api-advice-types">6.2.2。春天的建议类型</a>
<ul class="sectlevel4">
<li><a href="#aop-api-advice-around">拦截咨询</a></li>
<li><a href="#aop-api-advice-before">咨询前</a></li>
<li><a href="#aop-api-advice-throws">提出建议</a></li>
<li><a href="#aop-api-advice-after-returning">返回建议后</a></li>
<li><a href="#aop-api-advice-introduction">简介建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-api-advisor">6.3。Spring的Advisor API</a></li>
<li><a href="#aop-pfb">6.4。使用<code>ProxyFactoryBean</code>创建AOP代理</a>
<ul class="sectlevel3">
<li><a href="#aop-pfb-1">6.4.1。基本</a></li>
<li><a href="#aop-pfb-2">6.4.2。JavaBean属性</a></li>
<li><a href="#aop-pfb-proxy-types">6.4.3。基于JDK和CGLIB的代理</a></li>
<li><a href="#aop-api-proxying-intf">6.4.4。代理接口</a></li>
<li><a href="#aop-api-proxying-class">6.4.5。代理课程</a></li>
<li><a href="#aop-global-advisors">6.4.6。使用“全球”顾问</a></li>
</ul>
</li>
<li><a href="#aop-concise-proxy">6.5。简洁的代理定义</a></li>
<li><a href="#aop-prog">6.6。使用以下程序以编程方式创建AOP代理<code>ProxyFactory</code></a></li>
<li><a href="#aop-api-advised">6.7。操作建议对象</a></li>
<li><a href="#aop-autoproxy">6.8。使用“自动代理”功能</a>
<ul class="sectlevel3">
<li><a href="#aop-autoproxy-choices">6.8.1。自动代理Bean定义</a>
<ul class="sectlevel4">
<li><a href="#aop-api-autoproxy"><code>BeanNameAutoProxyCreator</code></a></li>
<li><a href="#aop-api-autoproxy-default"><code>DefaultAdvisorAutoProxyCreator</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-targetsource">6.9。使用<code>TargetSource</code>实作</a>
<ul class="sectlevel3">
<li><a href="#aop-ts-swap">6.9.1。可热交换的目标源</a></li>
<li><a href="#aop-ts-pool">6.9.2。汇集目标源</a></li>
<li><a href="#aop-ts-prototype">6.9.3。原型目标源</a></li>
<li><a href="#aop-ts-threadlocal">6.9.4。 <code>ThreadLocal</code> 目标来源</a></li>
</ul>
</li>
<li><a href="#aop-extensibility">6.10。定义新的建议类型</a></li>
</ul>
</li>
<li><a href="#null-safety">7。Null-safety</a>
<ul class="sectlevel2">
<li><a href="#use-cases">7.1。用例</a></li>
<li><a href="#jsr-305-meta-annotations">7.2。JSR-305元注释</a></li>
</ul>
</li>
<li><a href="#databuffers">8。数据缓冲区和编解码器</a>
<ul class="sectlevel2">
<li><a href="#databuffers-factory">8.1。<code>DataBufferFactory</code></a></li>
<li><a href="#databuffers-buffer">8.2。<code>DataBuffer</code></a></li>
<li><a href="#databuffers-buffer-pooled">8.3。<code>PooledDataBuffer</code></a></li>
<li><a href="#databuffers-utils">8.4。<code>DataBufferUtils</code></a></li>
<li><a href="#codecs">8.5。编解码器</a></li>
<li><a href="#databuffers-using">8.6。使用<code>DataBuffer</code></a></li>
</ul>
</li>
<li><a href="#appendix">9。附录</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">9.1。XML模式</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-util">9.1.1。的<code>util</code>架构图</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-util-constant">使用<code><util:constant/></code></a></li>
<li><a href="#xsd-schemas-util-property-path">使用<code><util:property-path/></code></a></li>
<li><a href="#xsd-schemas-util-properties">使用<code><util:properties/></code></a></li>
<li><a href="#xsd-schemas-util-list">使用<code><util:list/></code></a></li>
<li><a href="#xsd-schemas-util-map">使用<code><util:map/></code></a></li>
<li><a href="#xsd-schemas-util-set">使用<code><util:set/></code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-aop">9.1.2。的<code>aop</code>架构图</a></li>
<li><a href="#xsd-schemas-context">9.1.3。的<code>context</code>架构图</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-context-pphc">使用<code><property-placeholder/></code></a></li>
<li><a href="#xsd-schemas-context-ac">使用<code><annotation-config/></code></a></li>
<li><a href="#xsd-schemas-context-component-scan">使用<code><component-scan/></code></a></li>
<li><a href="#xsd-schemas-context-ltw">使用<code><load-time-weaver/></code></a></li>
<li><a href="#xsd-schemas-context-sc">使用<code><spring-configured/></code></a></li>
<li><a href="#xsd-schemas-context-mbe">使用<code><mbean-export/></code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-beans">9.1.4。Bean模式</a></li>
</ul>
</li>
<li><a href="#xml-custom">9.2。XML模式创作</a>
<ul class="sectlevel3">
<li><a href="#xsd-custom-schema">9.2.1。编写架构</a></li>
<li><a href="#xsd-custom-namespacehandler">9.2.2。编码a<code>NamespaceHandler</code></a></li>
<li><a href="#xsd-custom-parser">9.2.3。使用<code>BeanDefinitionParser</code></a></li>
<li><a href="#xsd-custom-registration">9.2.4。注册处理程序和架构</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-registration-spring-handlers">写作<code>META-INF/spring.handlers</code></a></li>
<li><a href="#xsd-custom-registration-spring-schemas">编写“ META-INF / spring.schemas”</a></li>
</ul>
</li>
<li><a href="#xsd-custom-using">9.2.5。在Spring XML配置中使用自定义扩展</a></li>
<li><a href="#xsd-custom-meat">9.2.6。更详细的例子</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-custom-nested">在自定义元素中嵌套自定义元素</a></li>
<li><a href="#xsd-custom-custom-just-attributes">“普通”元素上的自定义属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>参考文档的这一部分涵盖了Spring Framework 必不可少的所有技术。</p>
</div>
<div class="paragraph">
<p>其中最重要的是Spring Framework 的控制反转（IoC）容器。对Spring Framework 的IoC容器进行彻底处理之后，将全面介绍Spring的面向方面编程（AOP）技术。Spring Framework 拥有自己的AOP框架，该框架在概念上易于理解，并且成功解决了Java企业编程中AOP要求的80％的难题。</p>
</div>
<div class="paragraph">
<p>还提供了Spring与AspectJ的集成（就功能而言，目前是最丰富的-当然肯定是Java企业领域中最成熟的AOP实现）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans"><a class="anchor" href="#beans"></a> 1。IoC容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Spring的控制反转（IoC）容器。</p>
</div>
<div class="sect2">
<h3 id="beans-introduction"><a class="anchor" href="#beans-introduction"></a> 1.1。Spring IoC容器和Bean简介</h3>
<div class="paragraph">
<p>本章介绍了控制反转（IoC）原理的Spring Framework 实现。IoC也称为依赖注入（DI）。在此过程中，对象仅通过构造函数参数，工厂方法的参数或在构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，与它们一起使用的其他对象） 。然后，容器在创建bean时注入那些依赖项。此过程从根本上讲是通过使用类的直接构造或诸如服务定位器模式的机制来控制其依赖关系的实例化或位置的Bean本身的逆过程（因此称为Control Inversion）。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring Framework的IoC容器的基础。的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>接口提供了能够管理任何类型的对象的高级配置机制。
<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>是的子接口<code>BeanFactory</code> 。它增加了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与Spring的AOP功能轻松集成</p>
</li>
<li>
<p>消息资源处理（用于国际化）</p>
</li>
<li>
<p>活动发布</p>
</li>
<li>
<p>应用层特定的上下文，例如<code>WebApplicationContext</code>用于Web应用程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>简而言之， <code>BeanFactory</code>提供配置框架和基本功能，以及<code>ApplicationContext</code>添加更多企业特定功能。的<code>ApplicationContext</code>是的完整超集<code>BeanFactory</code>并且仅在本章中对Spring的IoC容器的描述中使用。有关使用<code>BeanFactory</code>而不是<code>ApplicationContext,</code>看<a href="#beans-beanfactory">的<code>BeanFactory</code></a> 。</p>
</div>
<div class="paragraph">
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是由Spring IoC容器实例化，组装和以其他方式管理的对象。否则，bean仅仅是应用程序中许多对象之一。Bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-basics"><a class="anchor" href="#beans-basics"></a> 1.2。容器概述</h3>
<div class="paragraph">
<p>的<code>org.springframework.context.ApplicationContext</code>接口代表Spring IoC容器，并负责实例化，配置和组装Bean。容器通过读取配置元数据来获取有关要实例化，配置和组装哪些对象的指令。配置元数据以XML，Java批注或Java代码表示。它使您能够表达组成应用程序的对象以及这些对象之间的丰富相互依赖关系。</p>
</div>
<div class="paragraph">
<p>的几种实现<code>ApplicationContext</code>接口随Spring提供。在独立应用程序中，通常创建一个实例<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>要么<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a> 。尽管XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置来声明性地启用对这些其他元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。</p>
</div>
<div class="paragraph">
<p>在大多数应用场景中，不需要显式用户代码即可实例化一个Spring IoC容器的一个或多个实例。例如，在一个Web应用程序场景中，简单的八（约）行样板Web描述符XML <code>web.xml</code>该应用程序的文件通常就足够了（请参阅<a href="#context-create">Web应用程序的便捷ApplicationContext实例化</a> ）。如果使用<a href="https://spring.io/tools/sts">Spring Tool Suite</a> （基于Eclipse的开发环境），则只需单击几次鼠标或击键即可轻松创建此样板配置。</p>
</div>
<div class="paragraph">
<p>下图显示了Spring的工作原理的高级视图。您的应用程序类与配置元数据结合在一起，以便<code>ApplicationContext</code>创建并初始化后，您便拥有一个完全配置且可执行的系统或应用程序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/container-magic.png" alt="容器魔术">
</div>
<div class="title">图1。Spring IoC容器</div>
</div>
<div class="sect3">
<h4 id="beans-factory-metadata"><a class="anchor" href="#beans-factory-metadata"></a> 1.2.1。配置元数据</h4>
<div class="paragraph">
<p>如上图所示，Spring IoC容器使用一种形式的配置元数据。这个配置元数据表示您作为应用程序开发人员如何告诉Spring容器实例化，配置和组装应用程序中的对象。</p>
</div>
<div class="paragraph">
<p>传统上，配置元数据以简单直观的XML格式提供，这是本章大部分内容用来传达Spring IoC容器的关键概念和功能的内容。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">基于XML的元数据不是配置元数据的唯一允许形式。Spring IoC容器本身与实际写入此配置元数据的格式完全脱钩。如今，许多开发人员为他们的Spring应用程序选择<a href="#beans-java">基于Java的配置</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关在Spring容器中使用其他形式的元数据的信息，请参见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-annotation-config">基于注解的配置</a> ：Spring 2.5引入了对基于注解的配置元数据的支持。</p>
</li>
<li>
<p><a href="#beans-java">基于Java的配置</a> ：从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring Framework的一部分。因此，您可以使用Java而不是XML文件来定义应用程序类外部的bean。要使用这些新功能，请参见<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>和<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a>注释。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring配置由容器必须管理的至少一个（通常是一个以上）bean定义组成。基于XML的配置元数据将这些bean配置为<code><bean/></code>顶层内的元素<code><beans/></code>元件。Java配置通常使用<code>@Bean</code>内的注释方法<code>@Configuration</code>类。</p>
</div>
<div class="paragraph">
<p>这些bean定义对应于组成应用程序的实际对象。通常，您定义服务层对象，数据访问对象（DAO），表示对象（例如Struts） <code>Action</code>实例，基础结构对象（例如Hibernate） <code>SessionFactories</code> ，JMS <code>Queues</code>等等。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是DAO和业务逻辑的职责。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。请参阅<a href="#aop-atconfigurable">使用AspectJ与Spring依赖注入域对象</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了基于XML的配置元数据的基本结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="..." class="..."&gt; <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id="..." class="..."&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>id</code> attribute是标识单个bean定义的字符串。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>class</code>属性定义bean的类型并使用完全限定的类名。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的价值<code>id</code>属性是指协作对象。在此示例中未显示用于引用协作对象的XML。有关更多信息，请参见<a href="#beans-dependencies">依赖项</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-instantiation"><a class="anchor" href="#beans-factory-instantiation"></a> 1.2.2。实例化容器</h4>
<div class="paragraph">
<p>位置路径或提供给<code>ApplicationContext</code>构造函数是资源字符串，可让容器从各种外部资源（例如本地文件系统，Java）加载配置元数据<code>CLASSPATH</code> ， 等等。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>了解了Spring的IoC容器后，您可能想了解更多有关Spring的IoC容器的信息。 <code>Resource</code>抽象（如<a href="#resources">参考资料中所述</a> ），它提供了一种方便的机制，用于从URI语法中定义的位置读取InputStream。特别是， <code>Resource</code>路径用于构造应用程序上下文，如“ <a href="#resources-app-ctx">应用程序上下文和资源路径”中所述</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了服务层对象<code>(services.xml)</code>配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- services --&gt;

    &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt;
        &lt;property name="accountDao" ref="accountDao"/&gt;
        &lt;property name="itemDao" ref="itemDao"/&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for services go here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了数据访问对象<code>daos.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for data access objects go here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，服务层包括<code>PetStoreServiceImpl</code>类和两个类型的数据访问对象<code>JpaAccountDao</code>和<code>JpaItemDao</code> （基于JPA对象关系映射标准）。的<code>property name</code>元素引用JavaBean属性的名称，并且<code>ref</code> element引用另一个bean定义的名称。之间的这种联系<code>id</code>和<code>ref</code>元素表示协作对象之间的依赖关系。有关配置对象的依赖关系的详细信息，请参见<a href="#beans-dependencies">依赖关系</a> 。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-xml-import"><a class="anchor" href="#beans-factory-xml-import"></a>组成基于XML的配置元数据</h5>
<div class="paragraph">
<p>使bean定义跨越多个XML文件可能很有用。通常，每个单独的XML配置文件都代表体系结构中的逻辑层或模块。</p>
</div>
<div class="paragraph">
<p>您可以使用应用程序上下文构造函数从所有这些XML片段中加载bean定义。该构造函数需要多个<code>Resource</code>位置，如上<a href="#beans-factory-instantiation">一节中</a>所示。或者，使用一次或多次<code><import/></code>元素以从另一个文件或多个文件加载bean定义。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;import resource="services.xml"/&gt;
    &lt;import resource="resources/messageSource.xml"/&gt;
    &lt;import resource="/resources/themeSource.xml"/&gt;

    &lt;bean id="bean1" class="..."/&gt;
    &lt;bean id="bean2" class="..."/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，外部Bean定义是从三个文件加载的： <code>services.xml</code> ， <code>messageSource.xml</code>和<code>themeSource.xml</code> 。所有位置路径都相对于进行导入的定义文件，因此<code>services.xml</code>必须与执行导入的文件位于同一目录或类路径位置，同时<code>messageSource.xml</code>和<code>themeSource.xml</code>必须在<code>resources</code>导入文件位置下方的位置。如您所见，斜杠被忽略。但是，鉴于这些路径是相对的，最好不要使用任何斜线。导入文件的内容，包括顶层<code><beans/></code>元素，根据Spring Schema，必须是有效的XML bean定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以但不建议使用相对的“ ../”路径引用父目录中的文件。这样做会创建对当前应用程序外部文件的依赖。特别是，不建议将该参考用于<code>classpath:</code>网址（例如， <code>classpath:../services.xml</code> ），在运行时解析过程中，选择“最近的”类路径根，然后查看其父目录。类路径配置的更改可能导致选择其他错误的目录。</p>
</div>
<div class="paragraph">
<p>您始终可以使用标准资源位置而不是相对路径：例如， <code>file:C:/config/services.xml</code>要么<code>classpath:/config/services.xml</code> 。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。通常最好为这样的绝对位置保留一个间接寻址，例如，通过在运行时针对JVM系统属性解析的“ $ {…}”占位符。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>命名空间本身提供了导入指令功能。Spring提供的一系列XML名称空间提供了除普通bean定义之外的其他配置功能-例如， <code>context</code>和<code>util</code>命名空间。</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy-bean-definition-dsl"><a class="anchor" href="#groovy-bean-definition-dsl"></a> Groovy Bean定义DSL</h5>
<div class="paragraph">
<p>作为外部化配置元数据的另一个示例，Bean定义也可以在Spring的Groovy Bean定义DSL中表达，如Grails框架所知。通常，这种配置位于“ .groovy”文件中，其结构如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean -&gt;
            dataSource = dataSource
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种配置样式在很大程度上等同于XML bean定义，甚至支持Spring的XML配置名称空间。它还允许通过导入XML bean定义文件。 <code>importBeans</code>指示。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-client"><a class="anchor" href="#beans-factory-client"></a> 1.2.3。使用容器</h4>
<div class="paragraph">
<p>的<code>ApplicationContext</code>是高级工厂的界面，该工厂能够维护不同Bean及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class<T> requiredType)</code> ，您可以检索bean的实例。</p>
</div>
<div class="paragraph">
<p>的<code>ApplicationContext</code>允许您读取和访问bean定义，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

// create and configure beans
val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

// retrieve configured instance
val service = context.getBean&lt;PetStoreService&gt;("petStore")

// use configured instance
var userList = service.getUsernameList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Groovy配置，引导看起来非常相似。它有一个不同的上下文实现类，该类可识别Groovy（但也了解XML Bean定义）。以下示例显示了Groovy配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")</code></pre>
</div>
</div>
<div class="paragraph">
<p>最灵活的变体是<code>GenericApplicationContext</code>与读者代表结合-例如，与<code>XmlBeanDefinitionReader</code>用于XML文件，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context = GenericApplicationContext()
XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
context.refresh()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>GroovyBeanDefinitionReader</code>对于Groovy文件，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context = GenericApplicationContext()
GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
context.refresh()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在同一位置混合和匹配此类读者代表<code>ApplicationContext</code> ，从各种配置源中读取bean定义。</p>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>getBean</code>检索您的bean的实例。的<code>ApplicationContext</code>接口还有其他几种检索bean的方法，但是理想情况下，您的应用程序代码永远不要使用它们。确实，您的应用程序代码不应调用<code>getBean()</code>方法，因此完全不依赖Spring API。例如，Spring与Web框架的集成为各种Web框架组件（例如控制器和JSF管理的Bean）提供了依赖项注入，使您可以通过元数据（例如自动装配注释）声明对特定Bean的依赖项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-definition"><a class="anchor" href="#beans-definition"></a> 1.3。Bean总览</h3>
<div class="paragraph">
<p>Spring IoC容器管理一个或多个bean。这些bean是使用您提供给容器的配置元数据创建的（例如，以XML的形式） <code><bean/></code>定义）。</p>
</div>
<div class="paragraph">
<p>在容器本身内，这些bean定义表示为<code>BeanDefinition</code>对象，其中包含（除其他信息外）以下元数据：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包限定的类名：通常，定义了Bean的实际实现类。</p>
</li>
<li>
<p>Bean行为配置元素，用于声明Bean在容器中的行为（作用域，生命周期回调等）。</p>
</li>
<li>
<p>对其他bean进行工作所需的引用。这些引用也称为协作者或依赖项。</p>
</li>
<li>
<p>要在新创建的对象中设置的其他配置设置，例如，池的大小限制或要在管理连接池的bean中使用的连接数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此元数据转换为构成每个bean定义的一组属性。下表描述了这些属性：</p>
</div>
<table id="beans-factory-bean-definition-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。Bean定义</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">在...中解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">实例化豆</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-beanname">命名豆</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">范围</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes">豆范围</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">构造函数参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">物产</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动接线方式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-autowire">自动装配协作器</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">延迟初始化模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lazy-init">懒初始化豆</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">初始化方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-initializingbean">初始化回调</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">销毁方式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-disposablebean">销毁回调</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了包含有关如何创建特定Bean的信息的Bean定义外， <code>ApplicationContext</code>实现还允许注册在容器外部（由用户）创建的现有对象。这是通过以下方式访问ApplicationContext的BeanFactory来完成的： <code>getBeanFactory()</code>方法，该方法返回BeanFactory <code>DefaultListableBeanFactory</code>实施。<code>DefaultListableBeanFactory</code>通过以下方式支持此注册<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法。但是，典型的应用程序只能与通过常规bean定义元数据定义的bean一起使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤中正确地推理它们。尽管在某种程度上支持覆盖现有元数据和现有单例实例，但官方不支持在运行时（与对工厂的实时访问同时）对新bean的注册，并且可能导致并发访问异常，bean容器中的状态不一致或都。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="beans-beanname"><a class="anchor" href="#beans-beanname"></a> 1.3.1。命名豆</h4>
<div class="paragraph">
<p>每个bean具有一个或多个标识符。这些标识符在承载Bean的容器内必须是唯一的。一个bean通常只有一个标识符。但是，如果需要多个，则可以将多余的别名视为别名。</p>
</div>
<div class="paragraph">
<p>在基于XML的配置元数据中，您可以使用<code>id</code>属性， <code>name</code>属性，或同时使用两者来指定Bean标识符。的<code>id</code>属性可让您精确指定一个ID。按照惯例，这些名称是字母数字（“ myBean”，“ someService”等），但它们也可以包含特殊字符。如果要为bean引入其他别名，也可以在<code>name</code>属性，以逗号（ <code>,</code> ），分号（ <code>;</code> ）或空白。作为历史记录，在Spring 3.1之前的版本中， <code>id</code>属性定义为<code>xsd:ID</code>类型，它限制了可能的字符。从3.1开始，它被定义为<code>xsd:string</code>类型。注意豆<code>id</code>唯一性仍然由容器强制执行，尽管不再由XML解析器执行。</p>
</div>
<div class="paragraph">
<p>您不需要提供<code>name</code>或<code>id</code>换一个豆子。如果您不提供<code>name</code>要么<code>id</code>明确地，容器为该bean生成一个唯一的名称。但是，如果要通过名称引用该bean，请使用<code>ref</code>元素或<a href="#beans-servicelocator">服务定位器</a>样式查找，您必须提供一个名称。不提供名称的动机与使用<a href="#beans-inner-beans">内部bean</a>和<a href="#beans-factory-autowire">自动装配合作者有关</a> 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bean命名约定</div>
<div class="paragraph">
<p>约定是在命名bean时将标准Java约定用于实例字段名称。也就是说，bean名称以小写字母开头，并从那里用驼峰式大小写。此类名称的示例包括<code>accountManager</code> ， <code>accountService</code> ， <code>userDao</code> ， <code>loginController</code>等等。</p>
</div>
<div class="paragraph">
<p>一致地命名Bean使您的配置更易于阅读和理解。另外，如果您使用Spring AOP，则在将建议应用于名称相关的一组bean时，它会很有帮助。</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过在类路径中进行组件扫描，Spring会按照前面描述的规则为未命名的组件生成Bean名称：从本质上讲，采用简单的类名称并将其初始字符转换为小写。但是，在（不寻常的）特殊情况下，如果有多个字符并且第一个和第二个字符均为大写字母，则会保留原始大小写。这些是与定义相同的规则<code>java.beans.Introspector.decapitalize</code> （Spring在这里使用）。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="beans-beanname-alias"><a class="anchor" href="#beans-beanname-alias"></a>在Bean定义之外别名Bean</h5>
<div class="paragraph">
<p>在Bean定义本身中，您可以为Bean提供多个名称，方法是使用以下名称最多指定一个名称的组合： <code>id</code>属性以及<code>name</code>属性。这些名称可以是同一bean的等效别名，并且在某些情况下很有用，例如通过使用特定于该组件本身的bean名称，让应用程序中的每个组件都引用一个公共依赖项。</p>
</div>
<div class="paragraph">
<p>但是，在实际定义bean的地方指定所有别名并不总是足够的。有时需要为在别处定义的bean引入别名。这在大型系统中通常是这种情况，在大型系统中，配置在每个子系统之间分配，每个子系统都有自己的对象定义集。在基于XML的配置元数据中，您可以使用<code><alias/></code>元素来实现这一目标。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;alias name="fromName" alias="toName"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，一个名为Bean（位于同一容器中）的<code>fromName</code>在使用该别名定义之后，也可以称为<code>toName</code> 。</p>
</div>
<div class="paragraph">
<p>例如，子系统A的配置元数据可以通过以下名称引用数据源： <code>subsystemA-dataSource</code> 。子系统B的配置元数据可以通过以下名称引用数据源： <code>subsystemB-dataSource</code> 。组成使用这两个子系统的主应用程序时，主应用程序通过以下名称引用数据源： <code>myApp-dataSource</code> 。要使所有三个名称都引用同一个对象，可以将以下别名定义添加到配置元数据中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;alias name="myApp-dataSource" alias="subsystemA-dataSource"/&gt;
&lt;alias name="myApp-dataSource" alias="subsystemB-dataSource"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，每个组件和主应用程序都可以通过唯一的名称引用数据源，并保证不会与任何其他定义冲突（有效地创建名称空间），但它们引用的是同一bean。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Java配置</div>
<div class="paragraph">
<p>如果您使用Java配置， <code>@Bean</code>批注可用于提供别名。请参阅<a href="#beans-java-bean-annotation">使用<code>@Bean</code>注释</a>了解详情。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-class"><a class="anchor" href="#beans-factory-class"></a> 1.3.2。实例化豆</h4>
<div class="paragraph">
<p>Bean定义本质上是创建一个或多个对象的方法。容器在被询问时会查看命名bean的配方，并使用该bean定义封装的配置元数据来创建（或获取）实际对象。</p>
</div>
<div class="paragraph">
<p>如果您使用基于XML的配置元数据，则可以指定要实例化的对象的类型（或类）。 <code>class</code>的属性<code><bean/></code>元件。这个<code>class</code>属性（在内部是<code>Class</code>物业<code>BeanDefinition</code>实例）通常是强制性的。（有关例外，请参阅<a href="#beans-factory-class-instance-factory-method">使用实例工厂方法</a>和<a href="#beans-child-bean-definitions">Bean定义继承</a> <a href="#beans-factory-class-instance-factory-method">实例化</a> 。）您可以使用<code>Class</code>属性可以通过以下两种方式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常，在容器本身通过反射性地调用其构造函数直接创建Bean的情况下，指定要构造的Bean类，这在某种程度上等同于Java代码， <code>new</code>操作员。</p>
</li>
<li>
<p>要指定包含<code>static</code>在不太常见的情况下，容器调用<code>static</code>在类上使用factory方法创建bean。调用时返回的对象类型<code>static</code>工厂方法可以是同一类，也可以完全是另一类。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<div class="title">内部班级名称</div>
<p>如果您要为<code>static</code>嵌套类，则必须使用嵌套类的二进制名称。</p>
</div>
<div class="paragraph">
<p>例如，如果您有一个名为<code>SomeThing</code>在里面<code>com.example</code>包装，这个<code>SomeThing</code>班上有一个<code>static</code>嵌套类称为<code>OtherThing</code> ，的价值<code>class</code> Bean定义上的属性将是<code>com.example.SomeThing$OtherThing</code> 。</p>
</div>
<div class="paragraph">
<p>注意使用<code>$</code>名称中的字符，以将嵌套的类名与外部类名分开。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-ctor"><a class="anchor" href="#beans-factory-class-ctor"></a>用构造函数实例化</h5>
<div class="paragraph">
<p>当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定bean类就足够了。但是，根据您用于该特定bean的IoC类型，您可能需要一个默认（空）构造函数。</p>
</div>
<div class="paragraph">
<p>Spring IoC容器几乎可以管理您要管理的任何类。它不仅限于管理真正的JavaBean。大多数Spring用户更喜欢仅具有默认（无参数）构造函数以及根据容器中的属性建模的适当的setter和getter的实际JavaBean。您还可以在容器中具有更多奇特的非bean样式类。例如，如果您需要使用绝对不符合JavaBean规范的旧式连接池，则Spring也可以对其进行管理。</p>
</div>
<div class="paragraph">
<p>使用基于XML的配置元数据，您可以如下指定bean类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;

&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关向构造函数提供参数（如果需要）并在构造对象之后设置对象实例属性的机制的详细信息，请参见<a href="#beans-factory-collaborators">注入依赖项</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-static-factory-method"><a class="anchor" href="#beans-factory-class-static-factory-method"></a>用静态工厂方法实例化</h5>
<div class="paragraph">
<p>定义使用静态工厂方法创建的bean时，请使用<code>class</code>属性以指定包含以下内容的类<code>static</code>工厂方法和一个名为<code>factory-method</code>指定工厂方法本身的名称。您应该能够调用此方法（带有可选参数，如后面所述），并返回一个活动对象，该对象随后将被视为已通过构造函数创建。这种bean定义的一种用法是调用<code>static</code>遗留代码中的工厂。</p>
</div>
<div class="paragraph">
<p>以下bean定义指定通过调用工厂方法来创建bean。该定义不指定返回对象的类型（类），而仅指定包含工厂方法的类。在此示例中， <code>createInstance()</code>方法必须是静态方法。以下示例显示如何指定工厂方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了可与前面的bean定义一起使用的类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ClientService private constructor() {
    companion object {
        private val clientService = ClientService()
        fun createInstance() = clientService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关为工厂方法提供（可选）参数并在从工厂返回对象后设置对象实例属性的机制的详细信息，请参见<a href="#beans-factory-properties-detailed">Dependencies and Configuration in Detail</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-instance-factory-method"><a class="anchor" href="#beans-factory-class-instance-factory-method"></a>使用实例工厂方法实例化</h5>
<div class="paragraph">
<p>类似于通过<a href="#beans-factory-class-static-factory-method">静态工厂方法</a>实例化，使用实例工厂方法实例化从容器中调用现有bean的非静态方法以创建新bean。要使用此机制，请保留<code>class</code>属性为空，并且在<code>factory-bean</code>属性，请在当前（或父或祖先）容器中指定Bean的名称，该容器包含将被调用以创建对象的实例方法。使用设置工厂方法本身的名称<code>factory-method</code>属性。以下示例显示了如何配置此类Bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class DefaultServiceLocator {
    companion object {
        private val clientService = ClientServiceImpl()
    }
    fun createClientServiceInstance(): ClientService {
        return clientService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个工厂类也可以包含一个以上的工厂方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/&gt;

&lt;bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class DefaultServiceLocator {
    companion object {
        private val clientService = ClientServiceImpl()
        private val accountService = AccountServiceImpl()
    }

    fun createClientServiceInstance(): ClientService {
        return clientService
    }

    fun createAccountServiceInstance(): AccountService {
        return accountService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法表明，工厂Bean本身可以通过依赖项注入（DI）进行管理和配置。<a href="#beans-factory-properties-detailed">详细信息，</a>请参见<a href="#beans-factory-properties-detailed">依赖性和配置</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在Spring文档中，“ factory bean”是指在Spring容器中配置并通过<a href="#beans-factory-class-instance-factory-method">实例</a>或<a href="#beans-factory-class-static-factory-method">静态</a>工厂方法创建对象的bean。相比之下， <code>FactoryBean</code> （注意大写）是指特定于Spring的<a href="#beans-factory-extension-factorybean"><code>FactoryBean</code></a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-dependencies"><a class="anchor" href="#beans-dependencies"></a> 1.4。依存关系</h3>
<div class="paragraph">
<p>典型的企业应用程序不包含单个对象（或Spring中的bean）。即使是最简单的应用程序，也有一些对象可以协同工作，以呈现最终用户视为一致的应用程序。下一部分将说明如何从定义多个独立的Bean定义到实现对象协作以实现目标的完全实现的应用程序。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-collaborators"><a class="anchor" href="#beans-factory-collaborators"></a> 1.4.1。依赖注入</h4>
<div class="paragraph">
<p>依赖注入（DI）是一个过程，通过该过程，对象只能通过构造函数参数，工厂方法的参数或在构造或创建对象实例后在对象实例上设置的属性来定义其依赖关系（即，与它们一起工作的其他对象）。从工厂方法返回。然后，容器在创建bean时注入那些依赖项。从根本上讲，此过程是通过使用类的直接构造或服务定位器模式来控制bean自身依赖关系的实例化或位置的bean本身的逆过程（因此称为Control Inversion）。</p>
</div>
<div class="paragraph">
<p>使用DI原理，代码更加简洁，当为对象提供依赖项时，去耦会更有效。该对象不查找其依赖项，也不知道依赖项的位置或类。结果，您的类变得更易于测试，尤其是当依赖项依赖于接口或抽象基类时，它们允许在单元测试中使用存根或模拟实现。</p>
</div>
<div class="paragraph">
<p>DI存在两个主要变体： <a href="#beans-constructor-injection">基于构造函数的依赖注入</a>和<a href="#beans-setter-injection">基于Setter的依赖注入</a> 。</p>
</div>
<div class="sect4">
<h5 id="beans-constructor-injection"><a class="anchor" href="#beans-constructor-injection"></a>基于构造函数的依赖注入</h5>
<div class="paragraph">
<p>基于构造函数的DI是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。叫一个<code>static</code>具有用于构造Bean的特定参数的工厂方法几乎是等效的，并且此讨论将参数视为构造函数和<code>static</code>工厂方法类似。以下示例显示了只能通过构造函数注入进行依赖项注入的类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// a constructor so that the Spring container can inject a MovieFinder
class SimpleMovieLister(private val movieFinder: MovieFinder) {
    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，该类没有什么特别的。它是一个POJO，不依赖于特定于容器的接口，基类或注释。</p>
</div>
<div class="sect5">
<h6 id="beans-factory-ctor-arguments-resolution"><a class="anchor" href="#beans-factory-ctor-arguments-resolution"></a>构造函数参数解析</h6>
<div class="paragraph">
<p>构造函数参数解析匹配通过使用参数的类型进行。如果Bean定义的构造函数参数中不存在潜在的歧义，则在实例化Bean时，在Bean定义中定义构造函数参数的顺序就是将这些参数提供给适当的构造函数的顺序。考虑以下类别：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package x.y

class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)</code></pre>
</div>
</div>
<div class="paragraph">
<p>假如说<code>ThingTwo</code>和<code>ThingThree</code>类与继承无关，不存在潜在的歧义。因此，以下配置可以正常运行，并且您无需在配置文件中显式指定构造函数参数索引或类型。 <code><constructor-arg/></code>元件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="beanOne" class="x.y.ThingOne"&gt;
        &lt;constructor-arg ref="beanTwo"/&gt;
        &lt;constructor-arg ref="beanThree"/&gt;
    &lt;/bean&gt;

    &lt;bean id="beanTwo" class="x.y.ThingTwo"/&gt;

    &lt;bean id="beanThree" class="x.y.ThingThree"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当引用另一个bean时，类型是已知的，并且可以发生匹配（与前面的示例一样）。使用简单类型时，例如<code><value>true</value></code> ，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。考虑以下类别：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package examples

class ExampleBean(
    private val years: Int, // Number of years to calculate the Ultimate Answer
    private val ultimateAnswer: String// The Answer to Life, the Universe, and Everything
)</code></pre>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-type"></a>构造函数参数类型匹配</div>
<div class="content">
<div class="paragraph">
<p>在上述情况下，如果通过使用显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配。 <code>type</code>属性。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg type="int" value="7500000"/&gt;
    &lt;constructor-arg type="java.lang.String" value="42"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-index"></a>构造函数参数索引</div>
<div class="content">
<div class="paragraph">
<p>您可以使用<code>index</code>属性，以明确指定构造函数参数的索引，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg index="0" value="7500000"/&gt;
    &lt;constructor-arg index="1" value="42"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了解决多个简单值的歧义性之外，指定索引还可以解决歧义，其中构造函数具有两个相同类型的参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">索引从0开始。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-name"></a>构造函数参数名称</div>
<div class="content">
<div class="paragraph">
<p>您还可以使用构造函数参数名称来消除歧义，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg name="years" value="7500000"/&gt;
    &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，要使此工作立即可用，必须在启用调试标志的情况下编译代码，以便Spring可以从构造函数中查找参数名称。如果您不能或不希望使用debug标志编译代码，则可以使用<a href="https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK注释显式命名构造函数参数。然后，样本类必须如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package examples

class ExampleBean
@ConstructorProperties("years", "ultimateAnswer")
constructor(val years: Int, val ultimateAnswer: String)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-setter-injection"><a class="anchor" href="#beans-setter-injection"></a>基于Setter的依赖注入</h5>
<div class="paragraph">
<p>通过调用无参数构造函数或无参数的容器在您的bean上调用setter方法来完成基于Setter的DI <code>static</code>实例化bean的工厂方法。</p>
</div>
<div class="paragraph">
<p>下面的示例显示只能通过使用纯setter注入来依赖注入的类。此类是常规的Java。它是一个POJO，不依赖于特定于容器的接口，基类或注释。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    // a late-initialized property so that the Spring container can inject a MovieFinder
    lateinit var movieFinder: MovieFinder

    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>ApplicationContext</code>支持其管理的bean的基于构造函数和基于setter的DI。在通过构造函数方法注入了某些依赖项之后，它还支持基于setter的DI。您可以以<code>BeanDefinition</code> ，您可以结合使用<code>PropertyEditor</code>实例将属性从一种格式转换为另一种格式。但是，大多数Spring用户不是直接（即以编程方式）使用这些类，而是使用XML <code>bean</code>定义，带注释的组件（即带注释的类<code>@Component</code> ， <code>@Controller</code> ，依此类推），或<code>@Bean</code>基于Java的方法<code>@Configuration</code>类。然后将这些源在内部转换为以下实例<code>BeanDefinition</code>并用于加载整个Spring IoC容器实例。</p>
</div>
<div id="beans-constructor-vs-setter-injection" class="sidebarblock">
<div class="content">
<div class="title">基于构造函数或基于setter的DI？</div>
<div class="paragraph">
<p>由于可以混合使用基于构造函数的DI和基于setter的DI，因此，将构造函数用于强制性依赖项并将setter方法或配置方法用于可选依赖性是一个很好的经验法则。注意，在setter方法上使用<a href="#beans-required-annotation">@Required</a>批注可以使该属性成为必需的依赖项。但是，最好使用带有参数的程序验证的构造函数注入。</p>
</div>
<div class="paragraph">
<p>Spring团队通常提倡构造函数注入，因为它可以让您将应用程序组件实现为不可变的对象，并确保不存在必需的依赖项。 <code>null</code> 。此外，构造函数注入的组件始终以完全初始化的状态返回到客户端（调用）代码。附带说明一下，大量的构造函数自变量是一种不好的代码味道，这意味着该类可能承担了太多的职责，应该对其进行重构以更好地解决关注点分离问题。</p>
</div>
<div class="paragraph">
<p>Setter注入主要应仅用于可以在类中分配合理的默认值的可选依赖项。否则，必须在代码使用依赖项的任何地方执行非空检查。setter注入的一个好处是，setter方法使该类的对象可以在以后重新配置或重新注入。因此，通过<a href="integration.html#jmx">JMX MBean进行</a>管理是用于setter注入的引人注目的用例。</p>
</div>
<div class="paragraph">
<p>使用最适合特定班级的DI风格。有时，在处理您没有源代码的第三方类时，将为您做出选择。例如，如果第三方类未公开任何setter方法，则构造函数注入可能是DI的唯一可用形式。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-dependency-resolution"><a class="anchor" href="#beans-dependency-resolution"></a>依赖性解析过程</h5>
<div class="paragraph">
<p>容器执行bean依赖项解析，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>ApplicationContext</code>使用描述所有Bean的配置元数据创建和初始化。可以通过XML，Java代码或注释指定配置元数据。</p>
</li>
<li>
<p>对于每个bean，其依赖关系都以属性，构造函数参数或static-factory方法的参数的形式表示（如果使用它而不是普通的构造函数）。实际创建Bean时，会将这些依赖项提供给Bean。</p>
</li>
<li>
<p>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。</p>
</li>
<li>
<p>每个值的属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将以字符串格式提供的值转换为所有内置类型，例如<code>int</code> ， <code>long</code> ， <code>String</code> ， <code>boolean</code>等等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在创建容器时，Spring容器会验证每个bean的配置。但是，在实际创建Bean之前，不会设置Bean属性本身。创建容器时，将创建具有单例作用域并设置为预先实例化（默认）的Bean。范围在<a href="#beans-factory-scopes">Bean范围</a>中定义。否则，仅在请求时才创建Bean。创建和分配bean的依赖关系及其依赖关系（依此类推）时，创建bean可能会导致创建一个bean图。请注意，这些依赖项之间的分辨率不匹配可能会显示得较晚-即在首次创建受影响的bean时。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">循环依赖</div>
<div class="paragraph">
<p>如果主要使用构造函数注入，则可能会创建无法解决的循环依赖方案。</p>
</div>
<div class="paragraph">
<p>例如：A类通过构造函数注入需要B类的实例，而B类通过构造函数注入需要A类的实例。如果您将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测到此循环引用，并抛出一个<code>BeanCurrentlyInCreationException</code> 。</p>
</div>
<div class="paragraph">
<p>一种可能的解决方案是编辑某些类的源代码，这些类的源代码由设置者而不是构造函数来配置。或者，避免构造函数注入，而仅使用setter注入。换句话说，尽管不建议这样做，但是您可以使用setter注入配置循环依赖项。</p>
</div>
<div class="paragraph">
<p>与典型情况（没有循环依赖关系）不同，Bean A和Bean B之间的循环依赖关系迫使其中一个Bean在完全完全初始化之前被注入另一个Bean（经典的“鸡与蛋”场景）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>通常，您可以信任Spring做正确的事。它在容器加载时检测配置问题，例如对不存在的Bean的引用和循环依赖项。在实际创建bean时，Spring设置属性并尽可能晚地解决依赖关系。这意味着，如果创建对象或其依赖项之一有问题，则正确加载的Spring容器以后可以在您请求对象时生成异常-例如，由于缺少或无效，Bean引发异常属性。某些配置问题的这种潜在的延迟可见性是为什么<code>ApplicationContext</code>默认情况下，实现会实例化单例bean。在实际需要这些bean之前，要花一些前期时间和内存来创建它们，您会发现当<code>ApplicationContext</code>创建，而不是稍后。您仍然可以覆盖此默认行为，以便单例bean延迟初始化，而不是预先实例化。</p>
</div>
<div class="paragraph">
<p>如果不存在循环依赖关系，则当将一个或多个协作bean注入到依赖bean中时，每个协作bean在注入到依赖bean中之前都已完全配置。这意味着，如果bean A依赖于bean B，则Spring IoC容器会在对bean A调用setter方法之前完全配置beanB。换句话说，实例化了bean（如果它不是预先实例化的单例） ），设置其依赖项，并调用相关的生命周期方法（例如已<a href="#beans-factory-lifecycle-initializingbean">配置的init方法</a>或<a href="#beans-factory-lifecycle-initializingbean">InitializingBean回调方法</a> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-some-examples"><a class="anchor" href="#beans-some-examples"></a>依赖注入的例子</h5>
<div class="paragraph">
<p>以下示例将基于XML的配置元数据用于基于setter的DI。 Spring XML配置文件的一小部分指定了一些bean定义，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;!-- setter injection using the nested ref element --&gt;
    &lt;property name="beanOne"&gt;
        &lt;ref bean="anotherExampleBean"/&gt;
    &lt;/property&gt;

    &lt;!-- setter injection using the neater ref attribute --&gt;
    &lt;property name="beanTwo" ref="yetAnotherBean"/&gt;
    &lt;property name="integerProperty" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了对应的<code>ExampleBean</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleBean {
    lateinit var beanOne: AnotherBean
    lateinit var beanTwo: YetAnotherBean
    var i: Int = 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，声明了setter以与XML文件中指定的属性匹配。以下示例使用基于构造函数的DI：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;!-- constructor injection using the nested ref element --&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean="anotherExampleBean"/&gt;
    &lt;/constructor-arg&gt;

    &lt;!-- constructor injection using the neater ref attribute --&gt;
    &lt;constructor-arg ref="yetAnotherBean"/&gt;

    &lt;constructor-arg type="int" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了对应的<code>ExampleBean</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class ExampleBean(
        private val beanOne: AnotherBean,
        private val beanTwo: YetAnotherBean,
        private val i: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bean定义中指定的构造函数参数用作<code>ExampleBean</code> 。</p>
</div>
<div class="paragraph">
<p>现在考虑该示例的一个变体，在该变体中，不使用构造函数，而是告诉Spring调用一个<code>static</code>返回对象实例的工厂方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance"&gt;
    &lt;constructor-arg ref="anotherExampleBean"/&gt;
    &lt;constructor-arg ref="yetAnotherBean"/&gt;
    &lt;constructor-arg value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了对应的<code>ExampleBean</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleBean private constructor() {
    companion object {
        // a static factory method; the arguments to this method can be
        // considered the dependencies of the bean that is returned,
        // regardless of how those arguments are actually used.
        fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {
            val eb = ExampleBean (...)
            // some other operations...
            return eb
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于的争论<code>static</code>工厂方法由提供<code><constructor-arg/></code>元素，就像实际使用构造函数一样。factory方法返回的类的类型不必与包含该类的类的类型相同。 <code>static</code>工厂方法（尽管在此示例中为）。实例（非静态）工厂方法可以以基本上相同的方式使用（除了使用<code>factory-bean</code>属性而不是<code>class</code>属性），因此我们不在此讨论这些细节。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-properties-detailed"><a class="anchor" href="#beans-factory-properties-detailed"></a> 1.4.2。依赖性和详细配置</h4>
<div class="paragraph">
<p>如上<a href="#beans-factory-collaborators">一节所述</a> ，您可以将bean属性和构造函数参数定义为对其他托管bean（协作者）的引用或内联定义的值。Spring的基于XML的配置元数据在其内部支持子元素类型<code><property/></code>和<code><constructor-arg/></code>为此目的的元素。</p>
</div>
<div class="sect4">
<h5 id="beans-value-element"><a class="anchor" href="#beans-value-element"></a>直值（原语，字符串等）</h5>
<div class="paragraph">
<p>的<code>value</code>的属性<code><property/></code>元素将属性或构造函数参数指定为人类可读的字符串表示形式。Spring的<a href="#core-convert-ConversionService-API">转换服务</a>用于从<code>String</code>属性或参数的实际类型。以下示例显示了设置的各种值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;!-- results in a setDriverClassName(String) call --&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt;
    &lt;property name="username" value="root"/&gt;
    &lt;property name="password" value="masterkaoli"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例使用<a href="#beans-p-namespace">p-namespace</a>进行更简洁的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="masterkaoli"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的XML更简洁。但是，除非在创建bean定义时使用支持自动属性完成的IDE（例如<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>或<a href="https://spring.io/tools/sts">Spring Tool Suite</a> ），否则错字是在运行时而不是设计时发现的。强烈建议您使用此类IDE帮助。</p>
</div>
<div class="paragraph">
<p>您还可以配置<code>java.util.Properties</code>实例如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="mappings"
    class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name="properties"&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring容器将文本转换为<code><value/></code>元素成<code>java.util.Properties</code>使用JavaBeans实例<code>PropertyEditor</code>机制。这是一个不错的捷径，并且是Spring团队偏爱使用嵌套的少数几个地方之一<code><value/></code>元素在<code>value</code>属性样式。</p>
</div>
<div class="sect5">
<h6 id="beans-idref-element"><a class="anchor" href="#beans-idref-element"></a>的<code>idref</code>元件</h6>
<div class="paragraph">
<p>的<code>idref</code>元素只是通过<code>id</code>容器中另一个bean的（字符串值-不是引用） <code><constructor-arg/></code>要么<code><property/></code>元件。以下示例显示了如何使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的bean定义片段（在运行时）与下面的片段完全等效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="theTargetBean" class="..." /&gt;

&lt;bean id="client" class="..."&gt;
    &lt;property name="targetName" value="theTargetBean"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一种形式优于第二种形式，因为使用<code>idref</code>标签使容器在部署时验证所引用的名为bean的实际存在。在第二个变体中，不对传递给<code>targetName</code>的属性<code>client</code>豆。错别字只有在<code>client</code> bean实际上是实例化的。如果<code>client</code> bean是<a href="#beans-factory-scopes">原型</a> bean，这种错别字和所产生的异常只有在部署容器很长时间之后才能发现。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>local</code>的属性<code>idref</code>元素在4.0 bean XSD中不再受支持，因为它不能提供常规值<code>bean</code>引用更多。更改您现有的<code>idref local</code>提及<code>idref bean</code>升级到4.0模式时。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一个常见的地方（至少在Spring 2.0之前的版本中） <code><idref/></code>元素带来的价值在于<a href="#aop-pfb-1">AOP拦截器</a>的配置<code>ProxyFactoryBean</code> Bean定义。使用<code><idref/></code>指定拦截器名称时使用元素可防止您拼写错误的拦截器ID。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-ref-element"><a class="anchor" href="#beans-ref-element"></a>对其他Bean的引用（协作者）</h5>
<div class="paragraph">
<p>的<code>ref</code>元素是内部的最后一个元素<code><constructor-arg/></code>要么<code><property/></code>定义元素。在这里，您将bean的指定属性的值设置为对容器管理的另一个bean（协作者）的引用。引用的bean是要设置其属性的bean的依赖关系，并且在设置属性之前根据需要对其进行初始化。（如果协作者是单例bean，则它可能已经由容器初始化了。）所有引用最终都是对另一个对象的引用。范围和验证取决于您是否通过以下方式指定其他对象的ID或名称： <code>bean</code> ， <code>local,</code>要么<code>parent</code>属性。</p>
</div>
<div class="paragraph">
<p>通过指定目标bean <code>bean</code>的属性<code><ref/></code>标记是最通用的形式，它允许在同一容器或父容器中创建对任何bean的引用，而不管它是否在同一XML文件中。的价值<code>bean</code>属性可能与<code>id</code>目标Bean的属性，或与Bean中的值之一相同<code>name</code>目标bean的属性。以下示例显示了如何使用<code>ref</code>元件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ref bean="someBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过指定目标bean <code>parent</code>属性创建对当前容器的父容器中的bean的引用。的价值<code>parent</code>属性可能与<code>id</code>目标Bean的属性或其中的值之一<code>name</code>目标bean的属性。目标Bean必须位于当前容器的父容器中。主要在具有容器层次结构并且要使用与父bean名称相同的代理将现有bean封装在父容器中时，才应使用此bean参考变量。以下一对清单显示了如何使用<code>parent</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- in the parent context --&gt;
&lt;bean id="accountService" class="com.something.SimpleAccountService"&gt;
    &lt;!-- insert dependencies as required as here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- in the child (descendant) context --&gt;
&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="target"&gt;
        &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>local</code>的属性<code>ref</code>元素在4.0 bean XSD中不再受支持，因为它不能提供常规值<code>bean</code>引用更多。更改您现有的<code>ref local</code>提及<code>ref bean</code>升级到4.0模式时。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-inner-beans"><a class="anchor" href="#beans-inner-beans"></a>内豆</h5>
<div class="paragraph">
<p>一种<code><bean/></code>内的元素<code><property/></code>要么<code><constructor-arg/></code>元素定义了一个内部bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="outer" class="..."&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name="name" value="Fiona Apple"/&gt;
            &lt;property name="age" value="25"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>内部bean定义不需要定义的ID或名称。如果指定，则容器不使用该值作为标识符。容器也忽略了<code>scope</code>在创建时添加标记，因为内部bean始终是匿名的，并且始终与外部bean创建。不可能独立访问内部bean或将它们注入到协作bean中而不是封装在bean中。</p>
</div>
<div class="paragraph">
<p>作为一个极端的例子，可以从自定义范围接收破坏回调，例如，针对单例bean中包含的请求范围内的bean。内部bean实例的创建与其包含的bean绑定在一起，但是销毁回调使它可以参与请求范围的生命周期。这不是常见的情况。内部bean通常只共享其包含bean的作用域。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-collection-elements"><a class="anchor" href="#beans-collection-elements"></a>馆藏</h5>
<div class="paragraph">
<p>的<code><list/></code> ， <code><set/></code> ， <code><map/></code>和<code><props/></code>元素设置Java的属性和参数<code>Collection</code>类型<code>List</code> ， <code>Set</code> ， <code>Map</code>和<code>Properties</code> ， 分别。以下示例显示了如何使用它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name="adminEmails"&gt;
        &lt;props&gt;
            &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key="support"&gt;support@example.org&lt;/prop&gt;
            &lt;prop key="development"&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name="someList"&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name="someMap"&gt;
        &lt;map&gt;
            &lt;entry key="an entry" value="just some string"/&gt;
            &lt;entry key ="a ref" value-ref="myDataSource"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name="someSet"&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>映射键或值的值或设置值也可以是以下任意元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">bean | ref | idref | list | set | map | props | value | null</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-merging"><a class="anchor" href="#beans-collection-elements-merging"></a>集合合并</h6>
<div class="paragraph">
<p>Spring容器还支持合并集合。应用程序开发人员可以定义父级<code><list/></code> ， <code><map/></code> ， <code><set/></code>要么<code><props/></code>元素，有孩子<code><list/></code> ， <code><map/></code> ， <code><set/></code>要么<code><props/></code>元素从父集合继承并覆盖值。也就是说，子集合的值是合并父集合和子集合的元素的结果，子集合的元素将覆盖父集合中指定的值。</p>
</div>
<div class="paragraph">
<p>关于合并的本节讨论了父子bean机制。不熟悉父级和子级bean定义的读者可能希望先阅读<a href="#beans-child-bean-definitions">相关部分，</a>然后再继续。</p>
</div>
<div class="paragraph">
<p>下面的示例演示了集合合并：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt;
        &lt;property name="adminEmails"&gt;
            &lt;props&gt;
                &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt;
                &lt;prop key="support"&gt;support@example.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="child" parent="parent"&gt;
        &lt;property name="adminEmails"&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge="true"&gt;
                &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt;
                &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意使用<code>merge=true</code>的属性<code><props/></code>的元素<code>adminEmails</code>的属性<code>child</code> Bean定义。当。。。的时候<code>child</code> Bean由容器解析和实例化，结果实例具有一个<code>adminEmails</code><code>Properties</code>包含合并孩子的结果的集合<code>adminEmails</code>与父母的收集<code>adminEmails</code>采集。以下清单显示了结果：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</pre>
</div>
</div>
<div class="paragraph">
<p>孩子<code>Properties</code>集合的值集从父级继承所有属性元素<code><props/></code> ，以及孩子对<code>support</code> value覆盖父集合中的值。</p>
</div>
<div class="paragraph">
<p>这种合并行为类似地适用于<code><list/></code> ， <code><map/></code>和<code><set/></code>集合类型。在特定情况下<code><list/></code>元素，与<code>List</code>集合类型（即<code>ordered</code>值的集合）。父级的值位于所有子级列表的值之前。在这种情况下<code>Map</code> ， <code>Set</code>和<code>Properties</code>集合类型，不存在排序。因此，对于关联类型基础的集合类型，没有排序语义是有效的<code>Map</code> ， <code>Set</code>和<code>Properties</code>容器内部使用的实现类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-merge-limitations"><a class="anchor" href="#beans-collection-merge-limitations"></a>馆藏合并的局限性</h6>
<div class="paragraph">
<p>您不能合并其他集合类型（例如<code>Map</code>和一个<code>List</code> ）。如果您确实尝试这样做， <code>Exception</code>被抛出。的<code>merge</code>必须在较低的继承子定义中指定属性。指定<code>merge</code>父集合定义上的Attribute是多余的，不会导致所需的合并。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-strongly-typed"><a class="anchor" href="#beans-collection-elements-strongly-typed"></a>强类型集合</h6>
<div class="paragraph">
<p>随着Java 5中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明一个<code>Collection</code>使其只能包含的类型（例如） <code>String</code>元素。如果您使用Spring依赖注入强类型<code>Collection</code>到Bean中，您可以利用Spring的类型转换支持，以便强类型的元素<code>Collection</code>实例先转换为适当的类型，然后再添加到<code>Collection</code> 。以下Java类和bean定义显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SomeClass {

    private Map&lt;String, Float&gt; accounts;

    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SomeClass {
    lateinit var accounts: Map&lt;String, Float&gt;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="something" class="x.y.SomeClass"&gt;
        &lt;property name="accounts"&gt;
            &lt;map&gt;
                &lt;entry key="one" value="9.99"/&gt;
                &lt;entry key="two" value="2.75"/&gt;
                &lt;entry key="six" value="3.99"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当。。。的时候<code>accounts</code>的属性<code>something</code> bean已准备好进行注入，有关强类型元素类型的泛型信息<code>Map<String, Float></code>可通过反射获得。因此，Spring的类型转换基础架构将各种值元素识别为类型<code>Float</code> ，以及字符串值（ <code>9.99, 2.75</code>和<code>3.99</code> ）转换为实际<code>Float</code>类型。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-null-element"><a class="anchor" href="#beans-null-element"></a>空字符串值和空字符串值</h5>
<div class="paragraph">
<p>Spring将属性等的空参数视为空<code>Strings</code> 。以下基于XML的配置元数据片段设置了<code>email</code>属性为空<code>String</code>值（“”）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="ExampleBean"&gt;
    &lt;property name="email" value=""/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例等效于以下Java代码：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">exampleBean.setEmail("");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">exampleBean.email = ""</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code><null/></code>元素句柄<code>null</code>价值观。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置等效于下面的Java代码：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">exampleBean.setEmail(null);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">exampleBean.email = null</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-p-namespace"><a class="anchor" href="#beans-p-namespace"></a>带p命名空间的XML快捷方式</h5>
<div class="paragraph">
<p>p命名空间可让您使用<code>bean</code>元素的属性（而不是嵌套的<code><property/></code>元素）来描述协作Bean的属性值，或同时描述两者。</p>
</div>
<div class="paragraph">
<p>Spring支持基于XML Schema定义的<a href="#xsd-schemas">具有名称空间的</a>可扩展配置格式。的<code>beans</code>本章讨论的配置格式是在XML Schema文档中定义的。但是，p命名空间未在XSD文件中定义，仅存在于Spring的核心中。</p>
</div>
<div class="paragraph">
<p>以下示例显示了两个XML代码段（第一个使用标准XML格式，第二个使用p命名空间），它们可以解析为相同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean name="classic" class="com.example.ExampleBean"&gt;
        &lt;property name="email" value="someone@somewhere.com"/&gt;
    &lt;/bean&gt;

    &lt;bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例显示了p命名空间中的一个名为<code>email</code>在bean定义中。这告诉Spring包含一个属性声明。如前所述，p名称空间没有架构定义，因此可以将属性名称设置为属性名称。</p>
</div>
<div class="paragraph">
<p>下一个示例包括另外两个bean定义，它们都引用了另一个bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean name="john-classic" class="com.example.Person"&gt;
        &lt;property name="name" value="John Doe"/&gt;
        &lt;property name="spouse" ref="jane"/&gt;
    &lt;/bean&gt;

    &lt;bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/&gt;

    &lt;bean name="jane" class="com.example.Person"&gt;
        &lt;property name="name" value="Jane Doe"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例不仅包括使用p-namespace的属性值，而且还使用特殊格式来声明属性引用。而第一个bean定义使用<code><property name="spouse" ref="jane"/></code>从bean创建引用<code>john</code>去豆子<code>jane</code> ，第二个bean定义使用<code>p:spouse-ref="jane"</code>作为属性来做完全相同的事情。在这种情况下， <code>spouse</code>是属性名称，而<code>-ref</code> part指示这不是一个直接值，而是对另一个bean的引用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">p命名空间不如标准XML格式灵活。例如，用于声明属性引用的格式与以结尾的属性冲突<code>Ref</code> ，而标准XML格式则没有。我们建议您仔细选择方法，并将其传达给团队成员，以避免同时使用这三种方法生成XML文档。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-c-namespace"><a class="anchor" href="#beans-c-namespace"></a>具有c-namespace的XML快捷方式</h5>
<div class="paragraph">
<p>与<a href="#beans-p-namespace">带有p-namespace</a>的<a href="#beans-p-namespace">XML Shortcut</a>类似，在Spring 3.1中引入的c-namespace允许内联属性用于配置构造函数参数，而不是嵌套的<code>constructor-arg</code>元素。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>c:</code>命名空间与<a href="#beans-constructor-injection">基于构造函数的依赖注入的作用相同</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="beanTwo" class="x.y.ThingTwo"/&gt;
    &lt;bean id="beanThree" class="x.y.ThingThree"/&gt;

    &lt;!-- traditional declaration with optional argument names --&gt;
    &lt;bean id="beanOne" class="x.y.ThingOne"&gt;
        &lt;constructor-arg name="thingTwo" ref="beanTwo"/&gt;
        &lt;constructor-arg name="thingThree" ref="beanThree"/&gt;
        &lt;constructor-arg name="email" value="something@somewhere.com"/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration with argument names --&gt;
    &lt;bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>c:</code>名称空间使用与相同的约定<code>p:</code>一个（尾随<code>-ref</code> （用于Bean引用），用于通过其名称设置构造函数参数。同样，即使未在XSD模式中定义它（也存在于Spring内核中），也需要在XML文件中声明它。</p>
</div>
<div class="paragraph">
<p>对于极少数情况下无法使用构造函数自变量名称的情况（通常，如果字节码是在没有调试信息的情况下编译的），则可以对参数索引使用后备，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- c-namespace index declaration --&gt;
&lt;bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="something@somewhere.com"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于XML语法的原因，索引符号要求前导<code>_</code> ，因为XML属性名称不能以数字开头（即使某些IDE允许）。相应的索引符号也可用于<code><constructor-arg></code>元素，但不常用，因为声明的简单顺序通常就足够了。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>实际上，构造函数解析<a href="#beans-factory-ctor-arguments-resolution">机制</a>在匹配参数方面非常有效，因此，除非您确实需要，否则我们建议在整个配置过程中使用名称表示法。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-compound-property-names"><a class="anchor" href="#beans-compound-property-names"></a>复合属性名称</h5>
<div class="paragraph">
<p>设置bean属性时，可以使用复合属性名称或嵌套属性名称，只要路径中除最终属性名称以外的所有组成部分都没有<code>null</code> 。考虑以下bean定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="something" class="things.ThingOne"&gt;
    &lt;property name="fred.bob.sammy" value="123" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>something</code>豆有一个<code>fred</code>属性，其中有一个<code>bob</code>属性，其中有一个<code>sammy</code>属性，以及最终<code>sammy</code>属性设置为的值<code>123</code> 。为了使其正常工作， <code>fred</code>的财产<code>something</code>和<code>bob</code>的财产<code>fred</code>必须不<code>null</code>在构造完bean之后。否则， <code>NullPointerException</code>被抛出。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-dependson"><a class="anchor" href="#beans-factory-dependson"></a> 1.4.3。使用<code>depends-on</code></h4>
<div class="paragraph">
<p>如果一个bean是另一个bean的依赖项，则通常意味着将一个bean设置为另一个bean的属性。通常，您可以通过<a href="#beans-ref-element"><code><ref/></code></a>基于XML的配置元数据中的<a href="#beans-ref-element">元素</a> 。但是，有时bean之间的依赖性不太直接。一个示例是何时需要触发类中的静态初始值设定项，例如用于数据库驱动程序注册。的<code>depends-on</code>属性可以在初始化使用此元素的bean之前显式强制初始化一个或多个bean。以下示例使用<code>depends-on</code>属性表示对单个bean的依赖关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;
&lt;bean id="manager" class="ManagerBean" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要表示对多个Bean的依赖关系，请提供一个Bean名称列表作为Bean的值。 <code>depends-on</code>属性（逗号，空格和分号是有效的分隔符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&gt;
    &lt;property name="manager" ref="manager" /&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;
&lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>depends-on</code>属性既可以指定初始化时间相关性，也可以仅在<a href="#beans-factory-scopes-singleton">单例</a> bean的情况下指定相应的销毁时间相关性。定义一个<code>depends-on</code>与给定bean的关系在销毁给定bean本身之前先被销毁。从而， <code>depends-on</code>还可以控制关机顺序。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-lazy-init"><a class="anchor" href="#beans-factory-lazy-init"></a> 1.4.4。懒初始化豆</h4>
<div class="paragraph">
<p>默认， <code>ApplicationContext</code>实现渴望在初始化过程中创建和配置所有<a href="#beans-factory-scopes-singleton">单例</a> bean。通常，这种预初始化是可取的，因为与数小时甚至数天后相比，会立即发现配置或周围环境中的错误。如果不希望使用此行为，则可以通过将bean定义标记为延迟初始化来防止单例bean的预实例化。延迟初始化的bean告诉IoC容器在首次请求时而不是在启动时创建一个bean实例。</p>
</div>
<div class="paragraph">
<p>在XML中，此行为由<code>lazy-init</code>的属性<code><bean/></code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/&gt;
&lt;bean name="not.lazy" class="com.something.AnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当前面的配置被一个服务器占用时<code>ApplicationContext</code> ， <code>lazy</code> Bean并不急于预先实例化<code>ApplicationContext</code>开始，而<code>not.lazy</code> Bean迫切需要预先安装。</p>
</div>
<div class="paragraph">
<p>但是，当延迟初始化的bean是未延迟初始化的单例bean的依赖项时， <code>ApplicationContext</code>在启动时创建延迟初始化的bean，因为它必须满足单例的依赖关系。延迟初始化的bean被注入到其他未延迟初始化的单例bean中。</p>
</div>
<div class="paragraph">
<p>您还可以使用以下命令在容器级别控制延迟初始化<code>default-lazy-init</code>的属性<code><beans/></code>元素，以下示例显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans default-lazy-init="true"&gt;
    &lt;!-- no beans will be pre-instantiated... --&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-autowire"><a class="anchor" href="#beans-factory-autowire"></a> 1.4.5。自动装配协作器</h4>
<div class="paragraph">
<p>Spring容器可以自动装配协作bean之间的关系。您可以通过检查以下内容来让Spring自动为您的bean解决协作者（其他bean）的问题： <code>ApplicationContext</code> 。自动装配具有以下优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动装配可以大大减少指定属性或构造函数参数的需要。（ <a href="#beans-child-bean-definitions">在本章其他地方讨论的</a>其他机制（例如Bean模板）在这方面也很有价值。）</p>
</li>
<li>
<p>随着对象的发展，自动装配可以更新配置。例如，如果您需要向类中添加依赖项，则无需修改配置即可自动满足该依赖项。因此，自动装配在开发过程中特别有用，而不必担心当代码库变得更稳定时切换到显式接线的选择。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用基于XML的配置元数据时（请参阅<a href="#beans-factory-collaborators">Dependency Injection</a> ），可以使用以下命令为bean定义指定自动装配模式： <code>autowire</code>的属性<code><bean/></code>元件。自动装配功能具有四种模式。您可以为每个bean指定自动装配，因此可以选择要自动装配的装配。下表描述了四种自动装配模式：</p>
</div>
<table id="beans-factory-autowiring-modes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表2。自动装配模式</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">模式</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>no</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认）无自动装配。Bean引用必须由<code>ref</code>元素。对于较大的部署，建议不要更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">按属性名称自动布线。Spring寻找与需要自动装配的属性同名的bean。例如，如果Bean定义设置为按名称自动装配，并且其中包含一个<code>master</code>属性（即它具有一个<code>setMaster(..)</code>方法），Spring寻找一个名为的bean定义<code>master</code>并使用它来设置属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果容器中恰好存在一个该属性类型的bean，则使该属性自动装配。如果存在多个，则会引发致命异常，这表明您可能无法使用<code>byType</code>为该bean自动装配。如果没有匹配的bean，则什么都不会发生（未设置该属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>constructor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似于<code>byType</code>但适用于构造函数参数。如果容器中不存在构造函数参数类型的一个bean，则将引发致命错误。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>用<code>byType</code>要么<code>constructor</code>在自动装配模式下，您可以装配数组和键入的集合。在这种情况下，将提供容器中与期望类型匹配的所有自动装配候选，以满足相关性。您可以自动连接强类型<code>Map</code>实例，如果预期的密钥类型是<code>String</code> 。自动接线<code>Map</code>实例的值包括所有与预期类型匹配的bean实例，以及<code>Map</code>实例的键包含相应的Bean名称。</p>
</div>
<div class="sect4">
<h5 id="beans-autowired-exceptions"><a class="anchor" href="#beans-autowired-exceptions"></a>自动接线的局限性和缺点</h5>
<div class="paragraph">
<p>当在项目中一致使用自动装配时，自动装配效果最好。如果通常不使用自动装配，则可能使开发人员仅使用自动装配来连接一个或两个bean定义而感到困惑。</p>
</div>
<div class="paragraph">
<p>考虑自动装配的局限性和缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>显式依赖<code>property</code>和<code>constructor-arg</code>设置始终会覆盖自动装配。您无法自动连线简单的属性，例如基元， <code>Strings</code>和<code>Classes</code> （以及此类简单属性的数组）。此限制是设计使然。</p>
</li>
<li>
<p>自动装配不如显式接线精确。尽管如前所述，Spring还是谨慎地避免猜测，以免产生意想不到的结果。Spring管理的对象之间的关系不再明确记录。</p>
</li>
<li>
<p>接线信息可能不适用于可能从Spring容器生成文档的工具。</p>
</li>
<li>
<p>容器内的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。对于数组，集合或<code>Map</code>实例，这不一定是问题。但是，对于需要单个值的依赖项，不会任意解决此歧义。如果没有唯一的bean定义可用，则会引发异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在后一种情况下，您有几种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>放弃自动布线，转而使用明确的布线。</p>
</li>
<li>
<p>通过设置bean定义避免自动装配bean定义<code>autowire-candidate</code>归因于<code>false</code> ，如<a href="#beans-factory-autowire-candidate">下一节所述</a> 。</p>
</li>
<li>
<p>通过设置单个Bean定义作为主要候选者<code>primary</code>其属性<code><bean/></code>元素<code>true</code> 。</p>
</li>
<li>
<p>如<a href="#beans-annotation-config">基于注释的容器配置中</a>所述， <a href="#beans-annotation-config">通过基于</a>注释的配置实现更细粒度的控件。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-autowire-candidate"><a class="anchor" href="#beans-factory-autowire-candidate"></a>从自动装配中排除Bean</h5>
<div class="paragraph">
<p>在每个bean的基础上，您可以从自动装配中排除一个bean。以Spring的XML格式设置<code>autowire-candidate</code>的属性<code><bean/></code>元素<code>false</code> 。容器使特定的bean定义不适用于自动装配基础结构（包括注释样式配置，例如<a href="#beans-autowired-annotation"><code>@Autowired</code></a> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>autowire-candidate</code>属性设计为仅影响基于类型的自动装配。它不会影响按名称显示的显式引用，即使未将指定的Bean标记为自动装配候选，该名称也可得到解析。因此，如果名称匹配，按名称自动装配仍然会注入Bean。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以基于与Bean名称的模式匹配来限制自动装配候选。顶层<code><beans/></code>元素在其元素内接受一个或多个模式<code>default-autowire-candidates</code>属性。例如，将自动装配候选状态限制为名称以结尾的任何bean <code>Repository</code> ，提供一个值<code>*Repository</code> 。要提供多种模式，请在以逗号分隔的列表中定义它们。的显式值<code>true</code>要么<code>false</code>对于bean的定义<code>autowire-candidate</code>属性始终优先。对于此类bean，模式匹配规则不适用。</p>
</div>
<div class="paragraph">
<p>这些技术对于您不希望通过自动装配将其注入其他bean的bean非常有用。这并不意味着排除的bean本身不能使用自动装配进行配置。相反，bean本身不是自动装配其他bean的候选对象。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-method-injection"><a class="anchor" href="#beans-factory-method-injection"></a> 1.4.6。方法注入</h4>
<div class="paragraph">
<p>在大多数应用场景中，容器中的大多数bean是<a href="#beans-factory-scopes-singleton">singletons</a> 。当单例Bean需要与另一个单例Bean协作或非单例Bean需要与另一个非单例Bean协作时，通常可以通过将一个Bean定义为另一个Bean的属性来处理依赖性。当bean的生命周期不同时会出现问题。假设单例bean A需要使用非单例（原型）bean B，也许在A的每个方法调用上都使用。容器仅创建一次单例bean A，因此只有一次机会来设置属性。每次需要一个容器时，容器都无法为bean A提供一个新的bean B实例。</p>
</div>
<div class="paragraph">
<p>一个解决方案是放弃某些控制反转。你可以<a href="#beans-factory-aware">做一个豆意识到容器</a>通过实施<code>ApplicationContextAware</code>接口，并且通过<a href="#beans-factory-client">使一个<code>getBean("B")</code></a>每次<a href="#beans-factory-client">容器</a> A需要它时<a href="#beans-factory-client">，对容器的调用都会</a>请求（通常是新的）bean B实例。以下示例显示了此方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple

// Spring-API imports
import org.springframework.context.ApplicationContext
import org.springframework.context.ApplicationContextAware

class CommandManager : ApplicationContextAware {

    private lateinit var applicationContext: ApplicationContext

    fun process(commandState: Map&lt;*, *&gt;): Any {
        // grab a new instance of the appropriate Command
        val command = createCommand()
        // set the state on the (hopefully brand new) Command instance
        command.state = commandState
        return command.execute()
    }

    // notice the Spring API dependency!
    protected fun createCommand() =
            applicationContext.getBean("command", Command::class.java)

    override fun setApplicationContext(applicationContext: ApplicationContext) {
        this.applicationContext = applicationContext
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的内容是不理想的，因为业务代码知道并耦合到Spring Framework 。方法注入是Spring IoC容器的一项高级功能，使您可以干净地处理此用例。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>您可以在<a href="https://spring.io/blog/2004/08/06/method-injection/">此博客条目中</a>了解有关方法注入动机的更多信息。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lookup-method-injection"><a class="anchor" href="#beans-factory-lookup-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>查找方法注入是容器重写容器管理的Bean上的方法并返回容器中另一个命名Bean的查找结果的能力。查找通常涉及原型bean，如上<a href="#beans-factory-method-injection">一节中所述</a> 。Spring Framework 通过使用从CGLIB库生成字节码来动态生成覆盖该方法的子类来实现此方法注入。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>为了使此动态子类起作用，Spring bean容器子类不能是<code>final</code> ，并且不能覆盖的方法是<code>final</code> ，或者。</p>
</li>
<li>
<p>对具有以下内容的类进行单元测试<code>abstract</code>方法要求您自己对类进行子类化，并提供<code>abstract</code>方法。</p>
</li>
<li>
<p>组件扫描也需要具体方法，这需要具体的类别。</p>
</li>
<li>
<p>另一个关键限制是查找方法不适用于工厂方法，尤其不适用于工厂方法。 <code>@Bean</code>配置类中的方法，因为在这种情况下，容器不负责创建实例，因此无法即时创建运行时生成的子类。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下<code>CommandManager</code>上一个代码段中的类，Spring容器动态覆盖了<code>createCommand()</code>方法。的<code>CommandManager</code>该类没有任何Spring依赖项，如重新编写的示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package fiona.apple

// no more Spring imports!

abstract class CommandManager {

    fun process(commandState: Any): Any {
        // grab a new instance of the appropriate Command interface
        val command = createCommand()
        // set the state on the (hopefully brand new) Command instance
        command.state = commandState
        return command.execute()
    }

    // okay... but where is the implementation of this method?
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在包含要注入的方法的客户端类中（ <code>CommandManager</code>在这种情况下，要注入的方法需要以下形式的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果方法是<code>abstract</code> ，动态生成的子类将实现该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt;
    &lt;lookup-method name="createCommand" bean="myCommand"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>标识为<code>commandManager</code>称自己<code>createCommand()</code>需要新实例的方法时<code>myCommand</code>豆。您必须小心部署<code>myCommand</code>实际需要的话，将其作为原型。如果是<a href="#beans-factory-scopes-singleton">单例</a> ，则相同的实例<code>myCommand</code>每次都返回bean。</p>
</div>
<div class="paragraph">
<p>另外，在基于注释的组件模型中，您可以通过以下方式声明查找方法<code>@Lookup</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">abstract class CommandManager {

    fun process(commandState: Any): Any {
        val command = createCommand()
        command.state = commandState
        return command.execute()
    }

    @Lookup("myCommand")
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，更习惯地说，您可以依赖于目标bean来针对lookup方法的声明的返回类型进行解析：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">abstract class CommandManager {

    fun process(commandState: Any): Any {
        val command = createCommand()
        command.state = commandState
        return command.execute()
    }

    @Lookup
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，通常应使用具体的存根实现声明此类带注释的查找方法，以使它们与Spring的组件扫描规则兼容，在默认情况下抽象类将被忽略。此限制不适用于显式注册或显式导入的Bean类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>访问范围不同的目标Bean的另一种方法是<code>ObjectFactory</code> / <code>Provider</code>注射点。见<a href="#beans-factory-scopes-other-injection">作用域bean与依赖</a> 。</p>
</div>
<div class="paragraph">
<p>您可能还会发现<code>ServiceLocatorFactoryBean</code> （在里面<code>org.springframework.beans.factory.config</code>包）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-arbitrary-method-replacement"><a class="anchor" href="#beans-factory-arbitrary-method-replacement"></a>任意方法替换</h5>
<div class="paragraph">
<p>与查找方法注入相比，方法注入的一种不太有用的形式是能够用另一种方法实现替换托管bean中的任意方法。您可以放心地跳过本节的其余部分，直到您真正需要此功能为止。</p>
</div>
<div class="paragraph">
<p>借助基于XML的配置元数据，您可以使用<code>replaced-method</code>元素，用于将已部署的bean的现有方法实现替换为另一个方法实现。考虑下面的类，该类具有一个称为<code>computeValue</code>我们要覆盖的内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyValueCalculator {

    fun computeValue(input: String): String {
        // some real code...
    }

    // some other methods...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现<code>org.springframework.beans.factory.support.MethodReplacer</code>接口提供了新的方法定义，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">/**
* meant to be used to override the existing computeValue(String)
* implementation in MyValueCalculator
*/
class ReplacementComputeValue : MethodReplacer {

    override fun reimplement(obj: Any, method: Method, args: Array&lt;out Any&gt;): Any {
        // get the input value, work with it, and return a computed result
        val input = args[0] as String;
        ...
        return ...;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用于部署原始类并指定方法覆盖的Bean定义类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用一个或多个<code><arg-type/></code>内的元素<code><replaced-method/></code>元素，指示要覆盖的方法的方法签名。仅当方法重载且类中存在多个变体时，才需要对参数签名。为了方便起见，参数的类型字符串可以是完全限定类型名称的子字符串。例如，以下所有匹配项<code>java.lang.String</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">java.lang.String
String
Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为参数的数量通常足以区分每个可能的选择，所以通过让您仅键入与参数类型匹配的最短字符串，此快捷方式可以节省很多输入。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-scopes"><a class="anchor" href="#beans-factory-scopes"></a> 1.5。豆范围</h3>
<div class="paragraph">
<p>创建bean定义时，将创建一个配方，用于创建该bean定义所定义的类的实际实例。bean定义是配方的想法很重要，因为它意味着与类一样，您可以从一个配方中创建许多对象实例。</p>
</div>
<div class="paragraph">
<p>您不仅可以控制要插入到从特定bean定义创建的对象中的各种依赖项和配置值，还可以控制从特定bean定义创建的对象的范围。这种方法功能强大且灵活，因为您可以选择通过配置创建的对象的范围，而不必在Java类级别上烘烤对象的范围。可以将Bean定义为部署在多个范围之一中。Spring Framework 支持六个范围，其中只有在使用网络感知时才可用四个范围<code>ApplicationContext</code> 。您还可以创建<a href="#beans-factory-scopes-custom">自定义范围。</a></p>
</div>
<div class="paragraph">
<p>下表描述了受支持的范围：</p>
</div>
<table id="beans-factory-scopes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表3。Bean作用域</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">范围</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-singleton">单身人士</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认）将每个Spring IoC容器的单个bean定义范围限定为单个对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-prototype">原型</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义的作用域限定为任意数量的对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-request">请求</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义的范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个在单个bean定义后面创建的bean实例。仅在基于Web的Spring上下文中有效<code>ApplicationContext</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-session">会议</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为HTTP的生命周期<code>Session</code> 。仅在基于Web的Spring上下文中有效<code>ApplicationContext</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-application">应用</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为一个bean的生命周期<code>ServletContext</code> 。仅在基于Web的Spring上下文中有效<code>ApplicationContext</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#websocket-stomp-websocket-scope">网络套接字</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将单个bean定义范围限定为一个bean的生命周期<code>WebSocket</code> 。仅在基于Web的Spring上下文中有效<code>ApplicationContext</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring 3.0开始，线程作用域可用，但默认情况下未注册。有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a> 。有关如何注册此自定义范围或任何其他自定义范围的说明，请参阅《 <a href="#beans-factory-scopes-custom-using">使用自定义范围》</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-singleton"><a class="anchor" href="#beans-factory-scopes-singleton"></a> 1.5.1。单例范围</h4>
<div class="paragraph">
<p>仅管理一个singleton bean的一个共享实例，并且所有具有ID或与该bean定义相匹配的ID的bean请求都将导致该特定的bean实例由Spring容器返回。</p>
</div>
<div class="paragraph">
<p>换句话说，当您定义一个bean定义并且其作用域为单例时，Spring IoC容器将为该bean定义定义的对象创建一个实例。该单个实例存储在此类单例bean的高速缓存中，并且对该命名bean的所有后续请求和引用都返回该高速缓存的对象。下图显示了单例作用域的工作方式：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/singleton.png" alt="单身人士">
</div>
</div>
<div class="paragraph">
<p>Spring的singleton bean的概念与“四人帮”（GoF）模式一书中定义的singleton模式不同。GoF单例对对象的范围进行硬编码，这样每个ClassLoader只能创建一个特定类的一个实例。最好将Spring单例的范围描述为每个容器和每个bean。这意味着，如果您在单个Spring容器中为特定类定义一个bean，则Spring容器将创建该bean定义所定义的类的一个实例，并且只有一个实例。单例作用域是Spring中的默认作用域。要将bean定义为XML中的单例，可以定义bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="accountService" class="com.something.DefaultAccountService"/&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-prototype"><a class="anchor" href="#beans-factory-scopes-prototype"></a> 1.5.2。原型范围</h4>
<div class="paragraph">
<p>每次对特定bean提出请求时，bean部署的非单一原型范围都会导致创建一个新bean实例。也就是说，该Bean被注入到另一个Bean中，或者您通过一个<code>getBean()</code>容器上的方法调用。通常，应将原型作用域用于所有有状态Bean，将单例作用域用于无状态Bean。</p>
</div>
<div class="paragraph">
<p>下图说明了Spring原型范围：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/prototype.png" alt="原型">
</div>
</div>
<div class="paragraph">
<p>（数据访问对象（DAO）通常不配置为原型，因为典型的DAO不保存任何对话状态。对我们来说，重用单例图的核心更加容易。</p>
</div>
<div class="paragraph">
<p>以下示例将bean定义为XML原型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他作用域相比，Spring不能管理原型Bean的完整生命周期。容器实例化，配置或组装原型对象，然后将其交给客户端，而无需对该原型实例的进一步记录。因此，尽管在不考虑范围的情况下在所有对象上都调用了初始化生命周期回调方法，但是在原型的情况下，不会调用已配置的销毁生命周期回调。客户端代码必须清除原型作用域内的对象并释放原型Bean拥有的昂贵资源。要使Spring容器释放由原型作用域的bean占用的资源，请尝试使用自定义<a href="#beans-factory-extension-bpp">bean后处理器</a> ，其中包含对需要清理的bean的引用。</p>
</div>
<div class="paragraph">
<p>在某些方面，Spring容器在原型作用域Bean方面的角色是Java的替代品<code>new</code>操作员。超过该时间点的所有生命周期管理必须由客户端处理。（有关Spring容器中bean生命周期的详细信息，请参阅<a href="#beans-factory-lifecycle">Lifecycle Callbacks</a> 。）</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-sing-prot-interaction"><a class="anchor" href="#beans-factory-scopes-sing-prot-interaction"></a> 1.5.3。具有原型Bean依赖关系的Singleton Bean</h4>
<div class="paragraph">
<p>当您使用对原型Bean有依赖性的单例作用域Bean时，请注意，依赖性在实例化时已解决。因此，如果将依赖项原型的bean依赖项注入到单例范围的bean中，则将实例化新的原型bean，然后将依赖项注入到单例bean中。原型实例是曾经提供给单例范围的bean的唯一实例。</p>
</div>
<div class="paragraph">
<p>但是，假设您希望单例作用域的bean在运行时重复获取原型作用域的bean的新实例。您不能将原型作用域的bean依赖项注入到您的单例bean中，因为当Spring容器实例化单例bean并解析并注入其依赖项时，该注入仅发生一次。如果在运行时不止一次需要原型bean的新实例，请参见<a href="#beans-factory-method-injection">方法注入。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-other"><a class="anchor" href="#beans-factory-scopes-other"></a> 1.5.4。请求，会话，应用程序和WebSocket范围</h4>
<div class="paragraph">
<p>的<code>request</code> ， <code>session</code> ， <code>application</code>和<code>websocket</code>范围仅在使用网络感知的Spring时可用<code>ApplicationContext</code>实施（例如<code>XmlWebApplicationContext</code> ）。如果您将这些范围与常规的Spring IoC容器一起使用，例如<code>ClassPathXmlApplicationContext</code> ， <code>IllegalStateException</code>抱怨抛出一个未知的bean作用域。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-web-configuration"><a class="anchor" href="#beans-factory-scopes-other-web-configuration"></a>初始Web配置</h5>
<div class="paragraph">
<p>为了支持在<code>request</code> ， <code>session</code> ， <code>application</code>和<code>websocket</code>级别（网络范围的Bean），在定义Bean之前需要进行一些较小的初始配置。（对于标准示波器，不需要此初始设置： <code>singleton</code>和<code>prototype</code> ）</p>
</div>
<div class="paragraph">
<p>如何完成此初始设置取决于您的特定Servlet环境。</p>
</div>
<div class="paragraph">
<p>如果您实际上是在Spring处理的请求中访问Spring Web MVC中的作用域Bean <code>DispatcherServlet</code> ，则无需进行特殊设置。
<code>DispatcherServlet</code>已经公开了所有相关状态。</p>
</div>
<div class="paragraph">
<p>如果您使用Servlet 2.5 Web容器，则在Spring的外部处理请求<code>DispatcherServlet</code> （例如，使用JSF或Struts时），您需要注册<code>org.springframework.web.context.request.RequestContextListener</code><code>ServletRequestListener</code> 。对于Servlet 3.0+，可以通过使用<code>WebApplicationInitializer</code>接口。或者，或者对于较旧的容器，将以下声明添加到Web应用程序的<code>web.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;
    ...
    &lt;listener&gt;
        &lt;listener-class&gt;
            org.springframework.web.context.request.RequestContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;
    ...
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果您的监听器设置存在问题，请考虑使用Spring的<code>RequestContextFilter</code> 。过滤器映射取决于周围的Web应用程序配置，因此您必须适当地对其进行更改。以下清单显示了Web应用程序的过滤器部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;
    ...
    &lt;filter&gt;
        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ...
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code> ， <code>RequestContextListener</code>和<code>RequestContextFilter</code>都做完全相同的事情，即将HTTP请求对象绑定到<code>Thread</code>为该请求提供服务。这使得在请求链和会话范围内的bean可以在调用链的更下游使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-request"><a class="anchor" href="#beans-factory-scopes-request"></a>要求范围</h5>
<div class="paragraph">
<p>考虑以下XML配置来定义bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="loginAction" class="com.something.LoginAction" scope="request"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring容器会创建一个新的实例<code>LoginAction</code>通过使用<code>loginAction</code>每个HTTP请求的bean定义。那就是<code>loginAction</code> bean的作用域在HTTP请求级别。您可以根据需要更改创建实例的内部状态，因为其他实例是从同一实例创建的<code>loginAction</code> bean定义看不到这些状态变化。它们特定于单个请求。当请求完成处理时，将限制作用于该请求的Bean。</p>
</div>
<div class="paragraph">
<p>使用注释驱动的组件或Java配置时， <code>@RequestScope</code>批注可用于将组件分配给<code>request</code>范围。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestScope
@Component
public class LoginAction {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RequestScope
@Component
class LoginAction {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-session"><a class="anchor" href="#beans-factory-scopes-session"></a>会议范围</h5>
<div class="paragraph">
<p>考虑以下XML配置来定义bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring容器会创建一个新的实例<code>UserPreferences</code>通过使用<code>userPreferences</code>一个HTTP的生存期的bean定义<code>Session</code> 。换句话说， <code>userPreferences</code> bean有效地限制在HTTP范围内<code>Session</code>水平。与请求范围的Bean一样，您可以更改所创建实例的内部状态，只要知道其他HTTP即可<code>Session</code>实例也使用从同一实例创建的实例<code>userPreferences</code> bean定义看不到这些状态变化，因为它们是特定于单个HTTP的<code>Session</code> 。当HTTP <code>Session</code>最终被丢弃，范围为该特定HTTP的bean <code>Session</code>也被丢弃。</p>
</div>
<div class="paragraph">
<p>使用注释驱动的组件或Java配置时，可以使用<code>@SessionScope</code>注释以将组件分配给<code>session</code>范围。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SessionScope
@Component
public class UserPreferences {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SessionScope
@Component
class UserPreferences {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-application"><a class="anchor" href="#beans-factory-scopes-application"></a>适用范围</h5>
<div class="paragraph">
<p>考虑以下XML配置来定义bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="appPreferences" class="com.something.AppPreferences" scope="application"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring容器会创建一个新的实例<code>AppPreferences</code>通过使用<code>appPreferences</code>整个Web应用程序一次定义bean。那就是<code>appPreferences</code> bean的作用域为<code>ServletContext</code>级别并定期存储<code>ServletContext</code>属性。这有点类似于Spring单例bean，但是有两个重要的区别： <code>ServletContext</code> ，而不是Spring的“ ApplicationContext”（在任何给定的Web应用程序中可能都有多个），它实际上是公开的，因此可以看到<code>ServletContext</code>属性。</p>
</div>
<div class="paragraph">
<p>使用注释驱动的组件或Java配置时，可以使用<code>@ApplicationScope</code>注释以将组件分配给<code>application</code>范围。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ApplicationScope
@Component
public class AppPreferences {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ApplicationScope
@Component
class AppPreferences {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-injection"><a class="anchor" href="#beans-factory-scopes-other-injection"></a>范围豆作为依赖项</h5>
<div class="paragraph">
<p>Spring IoC容器不仅管理对象（bean）的实例化，而且还管理协作者（或依赖项）的连接。如果要将（例如）HTTP请求范围的Bean注入（例如）另一个作用域更长的Bean，则可以选择注入AOP代理来代替已定义范围的Bean。也就是说，您需要注入一个代理对象，该对象公开与范围对象相同的公共接口，但也可以从相关范围（例如HTTP请求）中检索实际目标对象，并将方法调用委托给实际对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您也可以使用<code><aop:scoped-proxy/></code>在范围为<code>singleton</code> ，然后参考通过可序列化的中间代理，因此可以在反序列化时重新获得目标单例bean。</p>
</div>
<div class="paragraph">
<p>申报时<code><aop:scoped-proxy/></code>针对范围豆<code>prototype</code> ，共享代理上的每个方法调用都会导致创建新的目标实例，然后将该调用转发到该目标实例。</p>
</div>
<div class="paragraph">
<p>同样，作用域代理不是以生命周期安全的方式从较短的作用域访问bean的唯一方法。您也可以将注入点声明为（即，构造函数或setter参数或自动装配字段）为<code>ObjectFactory<MyTargetBean></code> ，允许<code>getObject()</code>调用，以在每次需要时按需检索当前实例，而无需保留该实例或将其单独存储。</p>
</div>
<div class="paragraph">
<p>作为扩展变体，您可以声明<code>ObjectProvider<MyTargetBean></code> ，它提供了其他几种访问方式，包括<code>getIfAvailable</code>和<code>getIfUnique</code> 。</p>
</div>
<div class="paragraph">
<p>这种的JSR-330变体称为<code>Provider</code>并与<code>Provider<MyTargetBean></code>声明和相应的<code>get()</code>要求进行每次检索尝试。有关JSR-330总体的更多详细信息，请参见<a href="#beans-standard-annotations">此处</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例中的配置只有一行，但是了解其背后的“原因”和“方式”很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;
    &lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"&gt;
        &lt;!-- instructs the container to proxy the surrounding bean --&gt;
        &lt;aop:scoped-proxy/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;/bean&gt;

    &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;
    &lt;bean id="userService" class="com.something.SimpleUserService"&gt;
        &lt;!-- a reference to the proxied userPreferences bean --&gt;
        &lt;property name="userPreferences" ref="userPreferences"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义代理的行。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要创建这样的代理，请插入一个子代<code><aop:scoped-proxy/></code>元素到作用域bean定义中（请参阅<a href="#beans-factory-scopes-other-injection-proxies">选择要创建的代理类型</a>和<a href="#xsd-schemas">基于XML Schema的配置</a> ）。为什么Bean的定义只限于<code>request</code> ， <code>session</code>和自定义范围级别需要<code><aop:scoped-proxy/></code>元件？考虑以下单例bean定义，并将其与需要为上述范围定义的内容进行对比（请注意，以下内容<code>userPreferences</code>目前的bean定义不完整）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"/&gt;

&lt;bean id="userManager" class="com.something.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，单例Bean（ <code>userManager</code> ）注入了对HTTP的引用<code>Session</code>范围的豆类（ <code>userPreferences</code> ）。这里的重点是<code>userManager</code> Bean是一个单例对象：每个容器及其实例（在这种情况下只有一个，即<code>userPreferences</code>豆）也只能注入一次。这意味着<code>userManager</code> bean仅在完全相同的条件下运行<code>userPreferences</code>对象（即最初注入对象的对象）。</p>
</div>
<div class="paragraph">
<p>将寿命较短的作用域bean注入寿命较长的作用域bean时，这不是您想要的行为（例如，注入HTTP <code>Session</code>范围的协作bean作为对Singleton bean的依赖）。相反，您需要一个<code>userManager</code>对象，并且在HTTP的生存期内<code>Session</code> ， 你需要一个<code>userPreferences</code>特定于HTTP的对象<code>Session</code> 。因此，容器创建了一个对象，该对象公开了与<code>UserPreferences</code>类（理想情况下是<code>UserPreferences</code>实例），可以获取真实的<code>UserPreferences</code>作用域机制（HTTP请求， <code>Session</code> ，依此类推）。容器将此代理对象注入到<code>userManager</code>豆，这并不知道<code>UserPreferences</code>参考是代理。在此示例中，当<code>UserManager</code>实例在注入依赖项时调用方法<code>UserPreferences</code>对象，实际上是在代理上调用方法。代理然后获取真实<code>UserPreferences</code>来自（在这种情况下）HTTP的对象<code>Session</code>并将方法调用委托到检索到的实数上<code>UserPreferences</code>宾语。</p>
</div>
<div class="paragraph">
<p>因此，注入时需要以下（正确和完整）的配置<code>request-</code>和<code>session-scoped</code> Bean变成协作对象，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;

&lt;bean id="userManager" class="com.something.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-scopes-other-injection-proxies"><a class="anchor" href="#beans-factory-scopes-other-injection-proxies"></a>选择要创建的代理类型</h6>
<div class="paragraph">
<p>默认情况下，当Spring容器为标记为的bean创建代理时， <code><aop:scoped-proxy/></code>元素，将创建一个基于CGLIB的类代理。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>CGLIB代理仅拦截公共方法调用！不要在这样的代理上调用非公共方法。它们没有被委派给实际的作用域目标对象。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另外，您可以配置Spring容器，以便通过指定以下范围的Bean创建标准的基于JDK接口的代理。 <code>false</code>为的价值<code>proxy-target-class</code>的属性<code><aop:scoped-proxy/></code>元件。使用基于JDK接口的代理意味着您不需要应用程序类路径中的其他库即可影响此类代理。但是，这也意味着作用域bean的类必须实现至少一个接口，并且作用域bean注入到其中的所有协作者都必须通过其接口之一来引用该bean。以下示例显示了基于接口的代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;
&lt;bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session"&gt;
    &lt;aop:scoped-proxy proxy-target-class="false"/&gt;
&lt;/bean&gt;

&lt;bean id="userManager" class="com.stuff.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关选择基于类或基于接口的代理的详细信息，请参阅<a href="#aop-proxying">代理机制</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-custom"><a class="anchor" href="#beans-factory-scopes-custom"></a> 1.5.5。自定义范围</h4>
<div class="paragraph">
<p>bean的作用域机制是可扩展的。您可以定义自己的作用域，甚至重新定义现有作用域，尽管后者被认为是不好的做法，并且您不能覆盖内置作用域<code>singleton</code>和<code>prototype</code>范围。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-creating"><a class="anchor" href="#beans-factory-scopes-custom-creating"></a>创建自定义范围</h5>
<div class="paragraph">
<p>要将您的自定义范围集成到Spring容器中，您需要实现<code>org.springframework.beans.factory.config.Scope</code>接口，在本节中进行介绍。有关如何实现自己的范围的想法，请参见<code>Scope</code> Spring Framework 本身和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code></a> javadoc，它详细解释了您需要实现的方法。</p>
</div>
<div class="paragraph">
<p>的<code>Scope</code>接口有四种方法可以从作用域中获取对象，将其从作用域中删除，然后将其销毁。</p>
</div>
<div class="paragraph">
<p>例如，会话范围实现返回会话范围的Bean（如果不存在，则该方法将其绑定到会话上以供将来参考之后，将返回该Bean的新实例）。以下方法从基础范围返回对象：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Object get(String name, ObjectFactory&lt;?&gt; objectFactory)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun get(name: String, objectFactory: ObjectFactory&lt;*&gt;): Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>会话范围的实现，例如，从基础会话中删除了会话范围的bean。应该返回该对象，但是如果找不到具有指定名称的对象，则可以返回null。以下方法从基础范围中删除该对象：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Object remove(String name)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun remove(name: String): Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下方法注册在销毁作用域或销毁作用域中的指定对象时作用域应执行的回调：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">void registerDestructionCallback(String name, Runnable destructionCallback)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun registerDestructionCallback(name: String, destructionCallback: Runnable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关销毁回调的更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback">javadoc</a>或Spring范围实现。</p>
</div>
<div class="paragraph">
<p>以下方法获取基础范围的会话标识符：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String getConversationId()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun getConversationId(): String</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个范围的标识符都不相同。对于会话范围的实现，此标识符可以是会话标识符。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-using"><a class="anchor" href="#beans-factory-scopes-custom-using"></a>使用自定义范围</h5>
<div class="paragraph">
<p>编写并测试一个或多个自定义项后<code>Scope</code>实现，您需要使Spring容器意识到您的新作用域。以下方法是注册新方法的主要方法<code>Scope</code>使用Spring容器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">void registerScope(String scopeName, Scope scope);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun registerScope(scopeName: String, scope: Scope)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此方法在<code>ConfigurableBeanFactory</code>界面，可通过<code>BeanFactory</code>大多数混凝土的特性<code>ApplicationContext</code> Spring附带的实现。</p>
</div>
<div class="paragraph">
<p>第一个参数<code>registerScope(..)</code> method是与范围关联的唯一名称。Spring容器本身中的此类名称示例如下： <code>singleton</code>和<code>prototype</code> 。第二个论点<code>registerScope(..)</code>方法是自定义的实际实例<code>Scope</code>您希望注册和使用的实现。</p>
</div>
<div class="paragraph">
<p>假设您编写了自定义<code>Scope</code>实现，然后如下面的示例所示注册它。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">下一个示例使用<code>SimpleThreadScope</code> ，它包含在Spring中，但默认情况下未注册。说明将与您的自定义相同<code>Scope</code>实现。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope("thread", threadScope);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val threadScope = SimpleThreadScope()
beanFactory.registerScope("thread", threadScope)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以创建符合自定义范围规则的bean定义。 <code>Scope</code> ， 如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="..." class="..." scope="thread"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义<code>Scope</code>实施时，您不仅限于程序注册的范围。您也可以<code>Scope</code>声明式注册，使用<code>CustomScopeConfigurer</code>类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
        &lt;property name="scopes"&gt;
            &lt;map&gt;
                &lt;entry key="thread"&gt;
                    &lt;bean class="org.springframework.context.support.SimpleThreadScope"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="thing2" class="x.y.Thing2" scope="thread"&gt;
        &lt;property name="name" value="Rick"/&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

    &lt;bean id="thing1" class="x.y.Thing1"&gt;
        &lt;property name="thing2" ref="thing2"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当你放置<code><aop:scoped-proxy/></code>在一个<code>FactoryBean</code>实现，范围是工厂bean本身，而不是从中返回的对象<code>getObject()</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-nature"><a class="anchor" href="#beans-factory-nature"></a> 1.6。自定义豆的性质</h3>
<div class="paragraph">
<p>Spring Framework 提供了许多接口，可用于自定义Bean的性质。本节将它们分组如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-factory-lifecycle">生命周期回调</a></p>
</li>
<li>
<p><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p>
</li>
<li>
<p><a href="#aware-list">其他<code>Aware</code>介面</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beans-factory-lifecycle"><a class="anchor" href="#beans-factory-lifecycle"></a> 1.6.1。生命周期回调</h4>
<div class="paragraph">
<p>要与容器对bean生命周期的管理进行交互，可以实现Spring <code>InitializingBean</code>和<code>DisposableBean</code>接口。容器调用<code>afterPropertiesSet()</code>对于前者和<code>destroy()</code>后者让Bean在初始化和销毁Bean时执行某些操作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR-250 <code>@PostConstruct</code>和<code>@PreDestroy</code>注释通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean没有耦合到特定于Spring的接口。有关详细信息，请参见<a href="#beans-postconstruct-and-predestroy-annotations">使用<code>@PostConstruct</code>和<code>@PreDestroy</code></a> 。</p>
</div>
<div class="paragraph">
<p>如果您不想使用JSR-250批注，但仍想删除耦合，请考虑<code>init-method</code>和<code>destroy-method</code> bean定义元数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在内部，Spring Framework 使用<code>BeanPostProcessor</code>实现以处理它可以找到并调用适当方法的任何回调接口。如果您需要自定义功能或其他生命周期行为（默认情况下，Spring不提供），则可以实施<code>BeanPostProcessor</code>你自己有关更多信息，请参见<a href="#beans-factory-extension">容器扩展点</a> 。</p>
</div>
<div class="paragraph">
<p>除了初始化和销毁回调外，Spring管理的对象还可以实现<code>Lifecycle</code>接口，以便这些对象可以在容器自身生命周期的驱动下参与启动和关闭过程。</p>
</div>
<div class="paragraph">
<p>本节介绍了生命周期回调接口。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-initializingbean"><a class="anchor" href="#beans-factory-lifecycle-initializingbean"></a>初始化回调</h5>
<div class="paragraph">
<p>的<code>org.springframework.beans.factory.InitializingBean</code>接口在容器对bean设置了所有必要的属性之后，bean可以执行初始化工作。的<code>InitializingBean</code>接口指定单个方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">void afterPropertiesSet() throws Exception;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun afterPropertiesSet()</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们建议您不要使用<code>InitializingBean</code>接口，因为它不必要地将代码耦合到Spring。另外，我们建议您使用<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a>批注或指定POJO初始化方法。对于基于XML的配置元数据，您可以使用<code>init-method</code>属性，用于指定具有无效无参数签名的方法的名称。通过Java配置，您可以使用<code>initMethod</code>的属性<code>@Bean</code> 。请参阅<a href="#beans-java-lifecycle-callbacks">接收生命周期回调</a> 。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleBean {

    fun init() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例与下面的示例（包含两个清单）几乎具有完全相同的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class AnotherExampleBean : InitializingBean {

    override fun afterPropertiesSet() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，前面两个示例中的第一个示例并未将代码耦合到Spring。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-disposablebean"><a class="anchor" href="#beans-factory-lifecycle-disposablebean"></a>销毁回调</h5>
<div class="paragraph">
<p>实施<code>org.springframework.beans.factory.DisposableBean</code>接口在破坏包含bean的容器时使bean获得回调。的<code>DisposableBean</code>接口指定单个方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">void destroy() throws Exception;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun destroy()</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它不必要地将代码耦合到Spring。另外，我们建议您使用<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a>批注或指定bean定义支持的通用方法。借助基于XML的配置元数据，您可以使用<code>destroy-method</code>的属性<code><bean/></code> 。通过Java配置，您可以使用<code>destroyMethod</code>的属性<code>@Bean</code> 。请参阅<a href="#beans-java-lifecycle-callbacks">接收生命周期回调</a> 。考虑以下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ExampleBean {

    fun cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的定义与下面的定义几乎具有完全相同的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class AnotherExampleBean : DisposableBean {

    override fun destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，前面两个定义中的第一个没有将代码耦合到Spring。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以分配<code>destroy-method</code>一个的属性<code><bean></code>特殊元素<code>(inferred)</code>值，指示Spring自动检测公共<code>close</code>要么<code>shutdown</code>特定bean类上的方法。（任何实现<code>java.lang.AutoCloseable</code>要么<code>java.io.Closeable</code>因此会匹配。）您还可以设置此特殊<code>(inferred)</code>的价值<code>default-destroy-method</code>一个的属性<code><beans></code>元素，以将此行为应用于整个bean集（请参见<a href="#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a> ）。请注意，这是Java配置的默认行为。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-default-init-destroy-methods"><a class="anchor" href="#beans-factory-lifecycle-default-init-destroy-methods"></a>默认初始化和销毁方法</h5>
<div class="paragraph">
<p>当您编写不使用特定于Spring的初始化和销毁方法回调时<code>InitializingBean</code>和<code>DisposableBean</code>回调接口，通常使用以下名称编写方法： <code>init()</code> ， <code>initialize()</code> ， <code>dispose()</code> ， 等等。理想情况下，此类生命周期回调方法的名称应在整个项目中标准化，以便所有开发人员都使用相同的方法名称并确保一致性。</p>
</div>
<div class="paragraph">
<p>您可以将Spring容器配置为“寻找”命名的初始化，并销毁每个bean上的回调方法名称。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用称为<code>init()</code> ，而无需配置<code>init-method="init"</code>每个bean定义的属性。Spring IoC容器在创建bean时（并根据<a href="#beans-factory-lifecycle">前面描述</a>的标准生命周期回调协定）调用该方法。此功能还对初始化和销毁方法回调强制执行一致的命名约定。</p>
</div>
<div class="paragraph">
<p>假设您的初始化回调方法已命名<code>init()</code>和您的destroy回调方法被命名为<code>destroy()</code> 。然后，您的班级类似于以下示例中的班级：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class DefaultBlogService : BlogService {

    private var blogDao: BlogDao? = null

    // this is (unsurprisingly) the initialization callback method
    fun init() {
        if (blogDao == null) {
            throw IllegalStateException("The [blogDao] property must be set.")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以在类似于以下内容的Bean中使用该类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans default-init-method="init"&gt;

    &lt;bean id="blogService" class="com.something.DefaultBlogService"&gt;
        &lt;property name="blogDao" ref="blogDao" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>存在的<code>default-init-method</code>顶层属性<code><beans/></code> element属性使Spring IoC容器识别称为<code>init</code>在bean类上作为初始化方法的回调。创建和组装bean时，如果bean类具有这种方法，则会在适当的时间调用它。</p>
</div>
<div class="paragraph">
<p>您可以通过以下方式类似地（在XML中）配置destroy方法回调： <code>default-destroy-method</code>顶层属性<code><beans/></code>元件。</p>
</div>
<div class="paragraph">
<p>如果现有的Bean类已经具有按约定命名的回调方法，则可以通过使用（在XML中）指定方法名称来覆盖默认值。 <code>init-method</code>和<code>destroy-method</code>的属性<code><bean/></code>本身。</p>
</div>
<div class="paragraph">
<p>Spring容器保证在为bean提供所有依赖项后立即调用已配置的初始化回调。因此，将在原始bean引用上调用初始化回调，这意味着AOP拦截器等尚未应用于bean。首先完全创建目标bean，然后应用带有其拦截器链的AOP代理（例如）。如果目标Bean和代理分别定义，则您的代码甚至可以绕过代理与原始目标Bean进行交互。因此，将拦截器应用于<code>init</code>方法，因为这样做会将目标Bean的生命周期耦合到其代理或拦截器，并在代码直接与原始目标Bean交互时留下奇怪的语义。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-combined-effects"><a class="anchor" href="#beans-factory-lifecycle-combined-effects"></a>组合生命周期机制</h5>
<div class="paragraph">
<p>从Spring 2.5开始，您可以使用三个选项来控制Bean生命周期行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<a href="#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a>和<a href="#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a>回调接口</p>
</li>
<li>
<p>自订<code>init()</code>和<code>destroy()</code>方法</p>
</li>
<li>
<p>的<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code>和<code>@PreDestroy</code>注解</a> 。您可以结合使用这些机制来控制给定的bean。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果为一个bean配置了多个生命周期机制，并且为每个机制配置了不同的方法名称，则将按照此注释后列出的顺序执行每个已配置的方法。但是，如果配置了相同的方法名称，例如， <code>init()</code>对于初始化方法-对于以上生命周期机制中的一种以上生命周期机制，该方法仅执行一次，如上<a href="#beans-factory-lifecycle-default-init-destroy-methods">一节所述</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为同一个bean配置的具有不同初始化方法的多种生命周期机制如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用注释的方法<code>@PostConstruct</code></p>
</li>
<li>
<p><code>afterPropertiesSet()</code>如<code>InitializingBean</code>回调接口</p>
</li>
<li>
<p>自定义配置<code>init()</code>方法</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>销毁方法的调用顺序相同：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用注释的方法<code>@PreDestroy</code></p>
</li>
<li>
<p><code>destroy()</code>如<code>DisposableBean</code>回调接口</p>
</li>
<li>
<p>自定义配置<code>destroy()</code>方法</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-processor"><a class="anchor" href="#beans-factory-lifecycle-processor"></a>启动和关机回调</h5>
<div class="paragraph">
<p>的<code>Lifecycle</code>接口为具有生命周期要求（例如启动和停止某些后台进程）的任何对象定义基本方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Lifecycle {

    fun start()

    fun stop()

    val isRunning: Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何Spring管理的对象都可以实现<code>Lifecycle</code>接口。然后，当<code>ApplicationContext</code>本身接收启动和停止信号（例如，对于运行时的停止/重新启动场景），它将这些调用级联到所有<code>Lifecycle</code>在该上下文中定义的实现。它通过委派给<code>LifecycleProcessor</code> ，如以下清单所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface LifecycleProcessor : Lifecycle {

    fun onRefresh()

    fun onClose()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意<code>LifecycleProcessor</code>本身就是<code>Lifecycle</code>接口。它还添加了其他两种方法来对正在刷新和关闭的上下文做出反应。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意常规<code>org.springframework.context.Lifecycle</code> interface是用于显式启动和停止通知的简单协定，并不意味着在上下文刷新时自动启动。为了对特定bean的自动启动进行精细控制（包括启动阶段），请考虑实施<code>org.springframework.context.SmartLifecycle</code>代替。</p>
</div>
<div class="paragraph">
<p>另外，请注意，不能保证会在销毁之前发出停止通知。定期关闭时，所有<code>Lifecycle</code> bean在传播一般销毁回调之前首先收到停止通知。但是，在上下文生命周期中进行热刷新或中止刷新尝试时，仅调用destroy方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，而在依赖之前停止。但是，有时直接依赖项是未知的。您可能只知道某种类型的对象应该先于另一种类型的对象开始。在这种情况下， <code>SmartLifecycle</code>接口定义了另一个选项，即<code>getPhase()</code>在其超级接口上定义的方法， <code>Phased</code> 。以下清单显示了<code>Phased</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Phased {

    int getPhase();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Phased {

    val phase: Int
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了<code>SmartLifecycle</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface SmartLifecycle : Lifecycle, Phased {

    val isAutoStartup: Boolean

    fun stop(callback: Runnable)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>启动时，相位最低的对象首先启动。停止时，遵循相反的顺序。因此，一个实现<code>SmartLifecycle</code>和谁<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>将是第一个开始，最后一个停止。在频谱的另一端，相位值为<code>Integer.MAX_VALUE</code>表示该对象应该最后启动，然后首先停止（可能是因为该对象取决于正在运行的其他进程）。在考虑相位值时，知道任何“正常”相位的默认相位也很重要<code>Lifecycle</code>没有实现的对象<code>SmartLifecycle</code>是<code>0</code> 。因此，任何负相位值都表明对象应在这些标准组件之前开始（并在它们之后停止）。对于任何正相位值，反之亦然。</p>
</div>
<div class="paragraph">
<p>停止方法定义为<code>SmartLifecycle</code>接受回调。任何实现都必须调用该回调的<code>run()</code>该实现的关闭过程完成后的方法。由于默认情况下， <code>LifecycleProcessor</code>接口， <code>DefaultLifecycleProcessor</code> ，等待每个阶段内的对象组的超时值来调用该回调。默认的每阶段超时是30秒。您可以通过定义一个名为bean来覆盖默认的生命周期处理器实例。 <code>lifecycleProcessor</code>在上下文中。如果只想修改超时，则定义以下内容即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor"&gt;
    &lt;!-- timeout value in milliseconds --&gt;
    &lt;property name="timeoutPerShutdownPhase" value="10000"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述， <code>LifecycleProcessor</code>接口还定义了用于刷新和关闭上下文的回调方法。后者驱动关机过程，就像<code>stop()</code>已被显式调用，但在上下文关闭时会发生。另一方面，“刷新”回调启用了<code>SmartLifecycle</code>豆子。刷新上下文后（在所有对象都实例化和初始化之后），将调用该回调。此时，默认生命周期处理器将检查每个生命周期返回的布尔值。 <code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>方法。如果<code>true</code> ，该对象即在该时间点启动，而不是等待上下文或其自身的显式调用<code>start()</code>方法（与上下文刷新不同，对于标准上下文实现，上下文启动不会自动发生）。的<code>phase</code>值和任何“依赖”关系确定启动顺序，如前所述。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-shutdown"><a class="anchor" href="#beans-factory-shutdown"></a>在非Web应用程序中正常关闭Spring IoC容器</h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本节仅适用于非Web应用程序。基于Web的Spring <code>ApplicationContext</code>实现已经有适当的代码，可以在相关Web应用程序关闭时正常关闭Spring IoC容器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您在非Web应用程序环境中（例如，在富客户端桌面环境中）使用Spring的IoC容器，请向JVM注册一个关闭钩子。这样做可以确保正常关机，并在您的Singleton bean上调用相关的destroy方法，以便释放所有资源。您仍然必须正确配置和实现这些destroy回调。</p>
</div>
<div class="paragraph">
<p>要注册关闭钩子，请调用<code>registerShutdownHook()</code>在上声明的方法<code>ConfigurableApplicationContext</code>界面，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.context.support.ClassPathXmlApplicationContext

fun main() {
    val ctx = ClassPathXmlApplicationContext("beans.xml")

    // add a shutdown hook for the above context...
    ctx.registerShutdownHook()

    // app runs here...

    // main method exits, hook is called prior to the app shutting down...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-aware"><a class="anchor" href="#beans-factory-aware"></a> 1.6.2。 <code>ApplicationContextAware</code>和<code>BeanNameAware</code></h4>
<div class="paragraph">
<p>当一个<code>ApplicationContext</code>创建一个实现<code>org.springframework.context.ApplicationContextAware</code>接口，该实例具有对该实例的引用<code>ApplicationContext</code> 。以下清单显示了<code>ApplicationContextAware</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface ApplicationContextAware {

    @Throws(BeansException::class)
    fun setApplicationContext(applicationContext: ApplicationContext)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，bean可以以编程方式操纵<code>ApplicationContext</code>创造了他们，通过<code>ApplicationContext</code>接口或通过将引用转换为该接口的已知子类（例如<code>ConfigurableApplicationContext</code> ，其中包含其他功能）。一种用途是通过编程方式检索其他bean。有时，此功能很有用。但是，通常应避免使用它，因为它会将代码耦合到Spring，并且不遵循控制反转样式，在该样式中，将协作者作为属性提供给bean。其他方法<code>ApplicationContext</code>提供对文件资源的访问，发布应用程序事件以及访问文件<code>MessageSource</code> 。这些附加功能<a href="#context-introduction">在<code>ApplicationContext</code></a> 。</p>
</div>
<div class="paragraph">
<p>自动布线是获得参考的另一种选择<code>ApplicationContext</code> 。<em>传统的</em> <code>constructor</code>和<code>byType</code>自动<a href="#beans-factory-autowire">装配</a>模式（如“ <a href="#beans-factory-autowire">自动装配协作器”中所述</a> ）可以提供类型的依赖关系<code>ApplicationContext</code>分别用于构造函数参数或setter方法参数。要获得更大的灵活性，包括能够自动连接字段和使用多个参数方法，请使用基于注释的自动装配功能。如果这样做， <code>ApplicationContext</code>会自动连接到需要以下内容的字段，构造函数参数或方法参数中<code>ApplicationContext</code>键入有关字段，构造函数或方法是否携带<code>@Autowired</code>注解。有关更多信息，请参见<a href="#beans-autowired-annotation">使用<code>@Autowired</code></a> 。</p>
</div>
<div class="paragraph">
<p>当一个<code>ApplicationContext</code>创建一个实现<code>org.springframework.beans.factory.BeanNameAware</code>接口，该类具有对在其关联的对象定义中定义的名称的引用。以下清单显示了BeanNameAware接口的定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface BeanNameAware {

    @Throws(BeansException::class)
    fun setBeanName(name: String)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在填充正常的bean属性之后但在初始化回调（例如）之前调用该回调<code>InitializingBean</code> ， <code>afterPropertiesSet</code> ，或自定义的初始化方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="aware-list"><a class="anchor" href="#aware-list"></a> 1.6.3。其他<code>Aware</code>介面</h4>
<div class="paragraph">
<p>除了<code>ApplicationContextAware</code>和<code>BeanNameAware</code> （前面<a href="#beans-factory-aware">已经</a>讨论<a href="#beans-factory-aware">过</a> ），Spring提供了广泛的<code>Aware</code>允许bean向容器指示它们需要某种基础结构依赖性的回调接口。通常，名称表示依赖项类型。下表总结了最重要的<code>Aware</code>接口：</p>
</div>
<table id="beans-factory-nature-aware-list" class="tableblock frame-all grid-all spread">
<caption class="title">表4。感知接口</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">注入依赖</th>
<th class="tableblock halign-left valign-top">在...中解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宣告<code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEventPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">附件的事件发布者<code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">的其他功能<code>ApplicationContext</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanClassLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类加载器，用于加载Bean类。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">实例化豆</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanFactoryAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宣告<code>BeanFactory</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明bean的名称。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code>和<code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BootstrapContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">资源适配器<code>BootstrapContext</code>容器在其中运行。通常仅在支持JCA的情况下可用<code>ApplicationContext</code>实例。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#cci">JCA CCI</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LoadTimeWeaverAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义的编织器，用于在加载时处理类定义。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#aop-aj-ltw">在Spring Framework中使用AspectJ进行加载时编织</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageSourceAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决消息的已配置策略（支持参数化和国际化）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">的其他功能<code>ApplicationContext</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotificationPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring JMX通知发布者。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#jmx-notifications">通知事项</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置的加载程序，用于对资源的低级别访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resources">资源资源</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletConfigAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前<code>ServletConfig</code>容器在其中运行。仅在可识别网络的Spring中有效<code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">春季MVC</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前<code>ServletContext</code>容器在其中运行。仅在可识别网络的Spring中有效<code>ApplicationContext</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">春季MVC</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>再次注意，使用这些接口会将您的代码与Spring API绑定在一起，并且不遵循“控制反转”样式。因此，我们建议将它们用于需要以编程方式访问容器的基础结构Bean。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-child-bean-definitions"><a class="anchor" href="#beans-child-bean-definitions"></a> 1.7。Bean定义继承</h3>
<div class="paragraph">
<p>Bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用父bean和子bean定义可以节省很多输入。实际上，这是一种模板形式。</p>
</div>
<div class="paragraph">
<p>如果您使用<code>ApplicationContext</code>以编程方式接口，子bean定义由<code>ChildBeanDefinition</code>类。大多数用户不在此级别上与他们合作。相反，它们在诸如的类中声明性地配置bean定义。 <code>ClassPathXmlApplicationContext</code> 。使用基于XML的配置元数据时，可以使用<code>parent</code>属性，将父bean指定为该属性的值。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize"&gt;  <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;property name="name" value="override"/&gt;
    &lt;!-- the age property value of 1 will be inherited from parent --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注意<code>parent</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果未指定子bean定义，则使用父定义中的bean类，但也可以覆盖它。在后一种情况下，子bean类必须与父类兼容（也就是说，它必须接受父类的属性值）。</p>
</div>
<div class="paragraph">
<p>子bean定义从父项继承范围，构造函数参数值，属性值和方法替代，并可以选择添加新值。任何范围，初始化方法，destroy方法或<code>static</code>您指定的工厂方法设置将覆盖相应的父设置。</p>
</div>
<div class="paragraph">
<p>其余设置始终从子定义中获取：依赖项，自动装配模式，依赖项检查，单例和惰性初始化。</p>
</div>
<div class="paragraph">
<p>前面的示例通过使用来将父bean定义显式标记为抽象。 <code>abstract</code>属性。如果父定义未指定类，则将父bean定义显式标记为<code>abstract</code>是必需的，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="inheritedTestBeanWithoutClass" abstract="true"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
    &lt;property name="name" value="override"/&gt;
    &lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>父bean不能单独实例化，因为它不完整，并且还被明确标记为<code>abstract</code> 。当定义是<code>abstract</code> ，仅可用作纯模板bean定义，用作子定义的父定义。尝试使用这样的<code>abstract</code>通过将其称为另一个bean的ref属性或进行显式操作来单独实现父bean <code>getBean()</code>带有父bean ID的调用返回错误。同样，容器的内部<code>preInstantiateSingletons()</code>方法将忽略定义为抽象的bean定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>ApplicationContext</code>默认情况下预先实例化所有单例。因此，重要的是（至少对于单例bean），如果有一个（父）bean定义仅打算用作模板，并且此定义指定了一个类，则必须确保将<em>abstract</em>属性设置为<em>true</em> ，否则应用程序上下文将实际（尝试）预先实例化<code>abstract</code>豆。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-extension"><a class="anchor" href="#beans-factory-extension"></a> 1.8。集装箱延伸点</h3>
<div class="paragraph">
<p>通常，应用程序开发人员不需要子类化<code>ApplicationContext</code>实现类。相反，可以通过插入特殊集成接口的实现来扩展Spring IoC容器。接下来的几节描述了这些集成接口。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-bpp"><a class="anchor" href="#beans-factory-extension-bpp"></a> 1.8.1。使用a自定义Bean<code>BeanPostProcessor</code></h4>
<div class="paragraph">
<p>的<code>BeanPostProcessor</code>接口定义了回调方法，您可以实现这些回调方法以提供您自己的（或覆盖容器的默认值）实例化逻辑，依赖项解析逻辑等。如果您想在Spring容器完成实例化，配置和初始化bean之后实现一些自定义逻辑，则可以插入一个或多个自定义<code>BeanPostProcessor</code>实现。</p>
</div>
<div class="paragraph">
<p>您可以配置多个<code>BeanPostProcessor</code>实例，您可以控制这些实例的顺序<code>BeanPostProcessor</code>实例通过设置<code>order</code>属性。只有在<code>BeanPostProcessor</code>实现<code>Ordered</code>接口。如果你写自己的<code>BeanPostProcessor</code> ，您应该考虑实施<code>Ordered</code>界面。有关更多详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><code>BeanPostProcessor</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a>接口。另请参阅有关<a href="#beans-factory-programmatically-registering-beanpostprocessors">程序注册的说明<code>BeanPostProcessor</code>实例</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>BeanPostProcessor</code>实例在bean（或对象）实例上运行。也就是说，Spring IoC容器实例化一个bean实例，然后<code>BeanPostProcessor</code>实例完成工作。</p>
</div>
<div class="paragraph">
<p><code>BeanPostProcessor</code>实例是按容器划分作用域的。仅在使用容器层次结构时，这才有意义。如果您定义<code>BeanPostProcessor</code>在一个容器中，它仅后处理该容器中的bean。换句话说，在一个容器中定义的bean不会由容器进行后处理<code>BeanPostProcessor</code>即使两个容器都属于同一层次结构，也可以在另一个容器中定义它。</p>
</div>
<div class="paragraph">
<p>要更改实际的bean定义（即定义bean的蓝图），您需要使用<code>BeanFactoryPostProcessor</code> ，如使用“ <a href="#beans-factory-extension-factory-postprocessors">自定义配置元数据”中所述<code>BeanFactoryPostProcessor</code></a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口完全由两个回调方法组成。当此类被注册为容器的后处理器时，对于容器创建的每个bean实例，后处理器都会在容器初始化方法（例如<code>InitializingBean.afterPropertiesSet()</code>或任何声明的<code>init</code>方法），并在任何bean初始化回调之后调用。后处理器可以对bean实例执行任何操作，包括完全忽略回调。Bean后处理器通常检查回调接口，或者可以用代理包装Bean。一些Spring AOP基础结构类被实现为bean后处理器，以提供代理包装逻辑。</p>
</div>
<div class="paragraph">
<p>一个<code>ApplicationContext</code>自动检测实现该配置的配置元数据中定义的所有bean <code>BeanPostProcessor</code>接口。的<code>ApplicationContext</code>将这些Bean注册为后处理器，以便以后在创建Bean时调用它们。Bean后处理器可以与其他Bean相同的方式部署在容器中。</p>
</div>
<div class="paragraph">
<p>请注意，在声明一个<code>BeanPostProcessor</code>通过使用<code>@Bean</code>在配置类上的factory方法，factory方法的返回类型应该是实现类本身，或者至少是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，明确指示该bean的后处理器性质。否则， <code>ApplicationContext</code>无法在完全创建之前按类型自动检测它。由于一个<code>BeanPostProcessor</code>为了在上下文中应用于其他bean的初始化，需要尽早实例化，这种早期类型检测至关重要。</p>
</div>
<div id="beans-factory-programmatically-registering-beanpostprocessors" class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">以编程方式注册<code>BeanPostProcessor</code>实例</div>虽然推荐的方法<code>BeanPostProcessor</code>注册是通过<code>ApplicationContext</code>自动检测（如前所述），您可以针对<code>ConfigurableBeanFactory</code>通过使用<code>addBeanPostProcessor</code>方法。当您需要在注册之前评估条件逻辑，甚至需要跨层次结构的上下文复制Bean后处理器时，这将非常有用。但是请注意， <code>BeanPostProcessor</code>以编程方式添加的实例不遵守<code>Ordered</code>接口。在这里，注册的顺序决定了执行的顺序。另请注意<code>BeanPostProcessor</code>以编程方式注册的实例总是在通过自动检测注册的实例之前处理，而不考虑任何明确的顺序。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title"><code>BeanPostProcessor</code>实例和AOP自动代理</div>
<div class="paragraph">
<p>实现<code>BeanPostProcessor</code>界面很特殊，容器对它们的处理方式也有所不同。所有<code>BeanPostProcessor</code>它们直接引用的实例和Bean在启动时实例化，这是该应用程序特殊启动阶段的一部分<code>ApplicationContext</code> 。接下来，全部<code>BeanPostProcessor</code>实例以排序的方式注册，并应用于容器中的所有其他bean。由于AOP自动代理是作为<code>BeanPostProcessor</code>本身，两者都不<code>BeanPostProcessor</code>实例或它们直接引用的bean都有资格进行自动代理，因此没有任何方面可以编织。</p>
</div>
<div class="paragraph">
<p>对于任何此类bean，您应该看到一条参考日志消息： <code>Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</code> 。</p>
</div>
<div class="paragraph">
<p>如果您有咖啡豆连接到您的<code>BeanPostProcessor</code>通过使用自动接线或<code>@Resource</code> （这可能会导致自动装配），Spring在搜索类型匹配的依赖项候选对象时可能会访问意外的bean，因此使它们不符合自动代理或其他类型的bean后处理的条件。例如，如果您的依赖项带有注释<code>@Resource</code>如果字段或设置器的名称不直接与bean的声明名称相对应，并且不使用name属性，Spring将访问其他bean以按类型匹配它们。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何编写，注册和使用<code>BeanPostProcessor</code>实例<code>ApplicationContext</code> 。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-hw"><a class="anchor" href="#beans-factory-extension-bpp-examples-hw"></a>范例：Hello World， <code>BeanPostProcessor</code> -样式</h5>
<div class="paragraph">
<p>第一个示例说明了基本用法。该示例显示了一个自定义<code>BeanPostProcessor</code>实现调用<code>toString()</code>由容器创建的每个bean的方法，并将结果字符串输出到系统控制台。</p>
</div>
<div class="paragraph">
<p>以下清单显示了自定义<code>BeanPostProcessor</code>实现类的定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    // simply return the instantiated bean as-is
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean; // we could potentially return any object reference here...
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.config.BeanPostProcessor

class InstantiationTracingBeanPostProcessor : BeanPostProcessor {

    // simply return the instantiated bean as-is
    override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
        return bean // we could potentially return any object reference here...
    }

    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        println("Bean '$beanName' created : $bean")
        return bean
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下列<code>beans</code>元素使用<code>InstantiationTracingBeanPostProcessor</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        https://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;lang:groovy id="messenger"
            script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy"&gt;
        &lt;lang:property name="message" value="Fiona Apple Is Just So Dreamy."/&gt;
    &lt;/lang:groovy&gt;

    &lt;!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    --&gt;
    &lt;bean class="scripting.InstantiationTracingBeanPostProcessor"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意<code>InstantiationTracingBeanPostProcessor</code>仅被定义。它甚至没有名称，并且因为它是Bean，所以可以像注入其他任何Bean一样对其进行依赖注入。（前面的配置还定义了一个由Groovy脚本支持的bean。在标题为“ <a href="languages.html#dynamic-language">动态语言支持”</a>的一章中详细介绍了Spring动态语言<a href="languages.html#dynamic-language">支持</a> 。</p>
</div>
<div class="paragraph">
<p>以下Java应用程序运行上述代码和配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = ctx.getBean("messenger", Messenger.class);
        System.out.println(messenger);
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = ClassPathXmlApplicationContext("scripting/beans.xml")
    val messenger = ctx.getBean&lt;Messenger&gt;("messenger")
    println(messenger)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的应用程序的输出类似于以下内容：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-rabpp"><a class="anchor" href="#beans-factory-extension-bpp-examples-rabpp"></a>示例：<code>RequiredAnnotationBeanPostProcessor</code></h5>
<div class="paragraph">
<p>结合使用回调接口或注释和自定义<code>BeanPostProcessor</code>实现是扩展Spring IoC容器的常用方法。一个例子是Spring的<code>RequiredAnnotationBeanPostProcessor</code> - 一种<code>BeanPostProcessor</code> Spring发行版附带的实现，并确保使用（任意）批注标记的bean上的JavaBean属性实际上（配置为）依赖注入了一个值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factory-postprocessors"><a class="anchor" href="#beans-factory-extension-factory-postprocessors"></a> 1.8.2。使用以下命令自定义配置元数据<code>BeanFactoryPostProcessor</code></h4>
<div class="paragraph">
<p>我们要看的下一个扩展点是<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code> 。这个介面的语义与<code>BeanPostProcessor</code> ，主要区别在于： <code>BeanFactoryPostProcessor</code>对Bean配置元数据进行操作。也就是说，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>在容器实例化除bean以外的任何bean <em>之前</em> ，请读取配置元数据并可能更改它<code>BeanFactoryPostProcessor</code>实例。</p>
</div>
<div class="paragraph">
<p>您可以配置多个<code>BeanFactoryPostProcessor</code>实例，您可以控制这些实例的顺序<code>BeanFactoryPostProcessor</code>实例通过设置<code>order</code>属性。但是，只有在以下情况下才能设置此属性： <code>BeanFactoryPostProcessor</code>实现<code>Ordered</code>接口。如果你写自己的<code>BeanFactoryPostProcessor</code> ，您应该考虑实施<code>Ordered</code>界面。参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html"><code>BeanFactoryPostProcessor</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a>界面以获取更多详细信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要更改实际的bean实例（即，从配置元数据创建的对象），则需要使用<code>BeanPostProcessor</code> （前面在<a href="#beans-factory-extension-bpp">使用定制Bean中进行了介绍<code>BeanPostProcessor</code></a> ）。从技术上讲，可以在<code>BeanFactoryPostProcessor</code> （例如，通过使用<code>BeanFactory.getBean()</code> ），这样做会导致bean实例化过早，从而违反了标准容器的生命周期。这可能会导致负面影响，例如绕过bean后处理。</p>
</div>
<div class="paragraph">
<p>也， <code>BeanFactoryPostProcessor</code>实例是按容器划分作用域的。仅在使用容器层次结构时才有意义。如果您定义<code>BeanFactoryPostProcessor</code>在一个容器中，它仅应用于该容器中的bean定义。一个容器中的Bean定义不会由<code>BeanFactoryPostProcessor</code>实例，即使两个容器都属于同一层次结构，也是如此。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在工厂内部声明Bean工厂后处理器会自动执行<code>ApplicationContext</code> ，以便将更改应用于定义容器的配置元数据。Spring包含许多预定义的bean工厂后处理器，例如<code>PropertyOverrideConfigurer</code>和<code>PropertySourcesPlaceholderConfigurer</code> 。您也可以使用自定义<code>BeanFactoryPostProcessor</code> —例如，注册自定义属性编辑器。</p>
</div>
<div class="paragraph">
<p>一个<code>ApplicationContext</code>自动检测部署到其中的实现了<code>BeanFactoryPostProcessor</code>接口。它在适当的时候将这些bean用作bean工厂的后处理器。您可以像部署其他任何bean一样部署这些后处理器bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与<code>BeanPostProcessor</code> s，您通常不想配置<code>BeanFactoryPostProcessor</code> s用于延迟初始化。如果没有其他bean引用a <code>Bean(Factory)PostProcessor</code> ，该后处理器将完全不会实例化。因此，将其标记为延迟初始化将被忽略，并且<code>Bean(Factory)PostProcessor</code>即使您设置了<code>default-lazy-init</code>归因于<code>true</code>在您的声明上<code><beans /></code>元件。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="beans-factory-placeholderconfigurer"><a class="anchor" href="#beans-factory-placeholderconfigurer"></a>示例：类名替换<code>PropertySourcesPlaceholderConfigurer</code></h5>
<div class="paragraph">
<p>您可以使用<code>PropertySourcesPlaceholderConfigurer</code>使用标准Java在一个单独的文件中从bean定义外部化属性值<code>Properties</code>格式。这样做使部署应用程序的人员可以自定义特定于环境的属性，例如数据库URL和密码，而无需为修改容器的主要XML定义文件而复杂或有风险。</p>
</div>
<div class="paragraph">
<p>考虑以下基于XML的配置元数据片段，其中<code>DataSource</code>具有占位符值的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;
    &lt;property name="locations" value="classpath:com/something/jdbc.properties"/&gt;
&lt;/bean&gt;

&lt;bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例显示了从外部配置的属性<code>Properties</code>文件。在运行时， <code>PropertySourcesPlaceholderConfigurer</code>应用于替换数据源某些属性的元数据。将要替换的值指定为表单的占位符<code>${property-name}</code> ，它遵循Ant和log4j和JSP EL样式。</p>
</div>
<div class="paragraph">
<p>实际值来自标准Java中的另一个文件<code>Properties</code>格式：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre>
</div>
</div>
<div class="paragraph">
<p>因此， <code>${jdbc.username}</code>字符串在运行时被替换为值“ sa”，并且其他与属性文件中的键匹配的占位符值也是如此。的<code>PropertySourcesPlaceholderConfigurer</code>检查bean定义的大多数属性和属性中的占位符。此外，您可以自定义占位符前缀和后缀。</p>
</div>
<div class="paragraph">
<p>随着<code>context</code>在Spring 2.5中引入的命名空间，您可以使用专用的配置元素来配置属性占位符。您可以在一个或多个位置中以逗号分隔的列表的形式提供<code>location</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context:property-placeholder location="classpath:com/something/jdbc.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>PropertySourcesPlaceholderConfigurer</code>不仅在<code>Properties</code>您指定的文件。默认情况下，如果无法在指定的属性文件中找到属性，则会针对Spring进行检查<code>Environment</code>属性和常规Java <code>System</code>属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用<code>PropertySourcesPlaceholderConfigurer</code>替换类名，当您必须在运行时选择特定的实现类时，这有时很有用。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer"&gt;
    &lt;property name="locations"&gt;
        &lt;value&gt;classpath:com/something/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="properties"&gt;
        &lt;value&gt;custom.strategy.class=com.something.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="serviceStrategy" class="${custom.strategy.class}"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果无法在运行时将该类解析为有效的类，则在将要创建该bean时（即在运行期间），该bean的解析将失败。 <code>preInstantiateSingletons()</code>一个阶段<code>ApplicationContext</code>对于非延迟初始化bean。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-overrideconfigurer"><a class="anchor" href="#beans-factory-overrideconfigurer"></a>示例：<code>PropertyOverrideConfigurer</code></h5>
<div class="paragraph">
<p>的<code>PropertyOverrideConfigurer</code> ，另一个bean工厂的后处理器类似于<code>PropertySourcesPlaceholderConfigurer</code> ，但是与后者不同，原始定义对于bean属性可以具有默认值，也可以完全没有值。如果压倒一切<code>Properties</code>如果文件没有某个bean属性的条目，则使用默认的上下文定义。</p>
</div>
<div class="paragraph">
<p>请注意，bean定义不知道会被覆盖，因此从XML定义文件中不能立即看出正在使用覆盖配置器。如果有多个<code>PropertyOverrideConfigurer</code>实例为同一bean属性定义了不同的值，由于覆盖机制，最后一个实例获胜。</p>
</div>
<div class="paragraph">
<p>属性文件配置行采用以下格式：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>beanName.property=value</pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了格式的示例：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre>
</div>
</div>
<div class="paragraph">
<p>此示例文件可以与包含名为Bean的容器定义一起使用<code>dataSource</code>有<code>driver</code>和<code>url</code>属性。</p>
</div>
<div class="paragraph">
<p>只要路径的每个组成部分（最终属性被覆盖）之外的所有组成部分都已经为非空（可能是由构造函数初始化），则也支持复合属性名。在以下示例中， <code>sammy</code>的属性<code>bob</code>的属性<code>fred</code>的属性<code>tom</code> bean设置为标量值<code>123</code> ：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tom.fred.bob.sammy=123</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">指定的替代值始终是文字值。它们不会转换为bean引用。当XML bean定义中的原始值指定bean引用时，此约定也适用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>随着<code>context</code>在Spring 2.5中引入的命名空间，可以使用专用配置元素配置属性覆盖，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context:property-override location="classpath:override.properties"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factorybean"><a class="anchor" href="#beans-factory-extension-factorybean"></a> 1.8.3。自定义实例化逻辑<code>FactoryBean</code></h4>
<div class="paragraph">
<p>您可以实施<code>org.springframework.beans.factory.FactoryBean</code>本身就是工厂的对象的接口。</p>
</div>
<div class="paragraph">
<p>的<code>FactoryBean</code>接口是可插入Spring IoC容器的实例化逻辑的一点。如果您有复杂的初始化代码，可以用Java更好地表达（而不是（可能）冗长的XML），则可以创建自己的<code>FactoryBean</code> ，在该类中编写复杂的初始化，然后插入自定义<code>FactoryBean</code>放入容器。</p>
</div>
<div class="paragraph">
<p>的<code>FactoryBean</code>界面提供了三种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object getObject()</code> ：返回此工厂创建的对象的实例。实例可以共享，具体取决于该工厂返回单例还是原型。</p>
</li>
<li>
<p><code>boolean isSingleton()</code> ：退货<code>true</code>如果这<code>FactoryBean</code>返回单例或<code>false</code>除此以外。</p>
</li>
<li>
<p><code>Class getObjectType()</code> ：返回由对象返回的对象类型。 <code>getObject()</code>方法或<code>null</code>如果事先不知道类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>FactoryBean</code> Spring Framework 中的许多地方都使用了概念和接口。超过50种实施<code>FactoryBean</code> Spring本身附带的接口。</p>
</div>
<div class="paragraph">
<p>当您需要向容器询问实际的<code>FactoryBean</code>实例本身而不是它产生的bean，在bean的前面<code>id</code>与符号（ <code>&</code> ）时<code>getBean()</code>的方法<code>ApplicationContext</code> 。因此，对于给定<code>FactoryBean</code>带着<code>id</code>的<code>myBean</code> ，调用<code>getBean("myBean")</code>在容器上返回的产品<code>FactoryBean</code> ，而调用<code>getBean("&myBean")</code>返回<code>FactoryBean</code>实例本身。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-annotation-config"><a class="anchor" href="#beans-annotation-config"></a> 1.9。基于注释的容器配置</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">注释在配置Spring方面比XML更好吗？</div>
<div class="paragraph">
<p>基于注解的配置的引入提出了一个问题，即这种方法是否比XML“更好”。简短的答案是“取决于情况”。长答案是每种方法都有其优缺点，通常，由开发人员决定哪种策略更适合他们。由于定义方式的不同，注释在声明中提供了许多上下文，从而使配置更短，更简洁。但是，XML擅长连接组件而不接触其源代码或重新编译它们。一些开发人员更喜欢将布线靠近源头，而另一些开发人员则认为带注释的类不再是POJO，而且，配置变得分散并且难以控制。</p>
</div>
<div class="paragraph">
<p>无论选择如何，Spring都可以容纳两种样式，甚至可以将它们混合在一起。值得指出的是，通过其<a href="#beans-java">JavaConfig</a>选项，Spring允许以非侵入方式使用批注，而无需接触目标组件的源代码，并且就工具而言， <a href="https://spring.io/tools/sts">Spring Tool Suite</a>支持所有配置样式。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>基于注解的配置提供了XML设置的替代方法，该配置依赖字节码元数据来连接组件，而不是尖括号声明。通过使用相关类，方法或字段声明上的注释，开发人员无需使用XML来描述bean的连接，而是将配置移入组件类本身。如<a href="#beans-factory-extension-bpp-examples-rabpp">示例中所述： <code>RequiredAnnotationBeanPostProcessor</code></a> ， 用一个<code>BeanPostProcessor</code>结合注释是扩展Spring IoC容器的常用方法。例如，Spring 2.0引入了使用<a href="#beans-required-annotation"><code>@Required</code></a>注解。Spring 2.5使遵循相同的通用方法来驱动Spring的依赖注入成为可能。本质上， <code>@Autowired</code>注解提供的功能与<a href="#beans-factory-autowire">自动装配协作器中</a>所述的功能相同，但具有更细粒度的控制和更广泛的适用性。Spring 2.5还添加了对JSR-250批注的支持，例如<code>@PostConstruct</code>和<code>@PreDestroy</code> 。Spring 3.0添加了对JSR-330（Java依赖注入）注释的支持，该注释包含在<code>javax.inject</code>包如<code>@Inject</code>和<code>@Named</code> 。有关这些注释的详细信息，请参见<a href="#beans-standard-annotations">相关章节</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注释注入在XML注入之前执行。因此，XML配置将覆盖通过两种方法连接的属性的注释。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与往常一样，您可以将它们注册为单独的bean定义，但是也可以通过在基于XML的Spring配置中包含以下标记来隐式注册它们（请注意， <code>context</code>命名空间）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>（隐式注册的后处理器包括<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a> ，以及上述<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a> ）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code><context:annotation-config/></code>只在定义它的相同应用程序上下文中查找关于bean的注释。这意味着，如果您把<code><context:annotation-config/></code>在一个<code>WebApplicationContext</code>为一个<code>DispatcherServlet</code> ，它只会检查<code>@Autowired</code>控制器中的bean，而不是服务中的bean。有关更多信息，请参见<a href="web.html#mvc-servlet">DispatcherServlet</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a> 1.9.1。@Required</h4>
<div class="paragraph">
<p>的<code>@Required</code>注释适用于bean属性设置器方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">    class SimpleMovieLister {

    @Required
    lateinit var movieFinder: MovieFinder

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此注释指示必须在配置时通过bean定义中的显式属性值或通过自动装配来填充受影响的bean属性。如果尚未填充受影响的bean属性，则容器将引发异常。这样可以避免出现明显的故障，避免<code>NullPointerException</code>实例等。我们仍然建议您将断言放入bean类本身中（例如，放入init方法中）。这样做会强制执行那些必需的引用和值，即使您在容器外部使用该类也是如此。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@Required</code>自Spring Framework 5.1起，正式不建议使用批注，而建议使用构造函数注入进行必需的设置（或自定义实现） <code>InitializingBean.afterPropertiesSet()</code>以及bean属性设置器方法）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a> 1.9.2。使用<code>@Autowired</code></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR 330的<code>@Inject</code>注释可以代替Spring的<code>@Autowired</code>本节中包含的示例中的注释。有关更多详细信息，请参见<a href="#beans-standard-annotations">此处</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以应用<code>@Autowired</code>构造函数的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender @Autowired constructor(
    private val customerPreferenceDao: CustomerPreferenceDao)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.3开始， <code>@Autowired</code>如果目标Bean仅定义一个开始的构造函数，则不再需要在此类构造函数上添加注释。但是，如果有多个构造函数可用，则必须至少用一个注释<code>@Autowired</code>为了指示该容器使用哪个容器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您也可以应用<code>@Autowired</code>如以下示例所示，为<em>传统的</em> setter方法添加注释：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    @Autowired
    lateinit var movieFinder: MovieFinder

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以将注释应用于具有任意名称和多个参数的方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    private lateinit var movieCatalog: MovieCatalog

    private lateinit var customerPreferenceDao: CustomerPreferenceDao

    @Autowired
    fun prepare(movieCatalog: MovieCatalog,
                customerPreferenceDao: CustomerPreferenceDao) {
        this.movieCatalog = movieCatalog
        this.customerPreferenceDao = customerPreferenceDao
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以申请<code>@Autowired</code>到字段，甚至将其与构造函数混合，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender @Autowired constructor(
    private val customerPreferenceDao: CustomerPreferenceDao) {

    @Autowired
    private lateinit var movieCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保您的目标组件（例如， <code>MovieCatalog</code>要么<code>CustomerPreferenceDao</code> ）始终由您用于您的类型的声明<code>@Autowired</code>注释的注射点。否则，注入可能会由于运行时出现“找不到类型匹配”错误而失败。</p>
</div>
<div class="paragraph">
<p>对于通过类路径扫描找到的XML定义的bean或组件类，容器通常预先知道具体的类型。但是，对于<code>@Bean</code>工厂方法，您需要确保声明的返回类型具有足够的表现力。对于实现多个接口的组件或可能由其实现类型引用的组件，请考虑在工厂方法中声明最具体的返回类型（至少根据引用您的bean的注入点的要求进行声明）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以指示Spring提供来自的所有特定类型的bean。 <code>ApplicationContext</code>通过添加<code>@Autowired</code>如以下示例所示，对需要该类型数组的字段或方法的注释：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    private lateinit var movieCatalogs: Array&lt;MovieCatalog&gt;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如下例所示，这同样适用于类型化集合：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private Set&lt;MovieCatalog&gt; movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    lateinit var movieCatalogs: Set&lt;MovieCatalog&gt;

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您的目标Bean可以实现<code>org.springframework.core.Ordered</code>界面或使用<code>@Order</code>或标准<code>@Priority</code>如果希望数组或列表中的项目以特定顺序排序，则添加注释。否则，它们的顺序将遵循容器中相应目标bean定义的注册顺序。</p>
</div>
<div class="paragraph">
<p>您可以声明<code>@Order</code>在目标类级别及以后的注释<code>@Bean</code>方法，可能适用于单个bean定义（如果使用同一bean类的多个定义）。 <code>@Order</code>值可能会影响注入点的优先级，但请注意它们不会影响单例启动顺序，这是由依赖关系和<code>@DependsOn</code>声明。</p>
</div>
<div class="paragraph">
<p>注意标准<code>javax.annotation.Priority</code>注释在处不可用<code>@Bean</code>级别，因为它不能在方法上声明。它的语义可以通过以下方式建模<code>@Order</code>值与<code>@Primary</code>在每种类型的单个bean上。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>连打<code>Map</code>只要预期的密钥类型是<code>String</code> 。映射值包含所有预期类型的bean，并且键包含相应的bean名称，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private Map&lt;String, MovieCatalog&gt; movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    lateinit var movieCatalogs: Map&lt;String, MovieCatalog&gt;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，当给定注入点没有匹配的候选bean可用时，自动装配将失败。对于声明的数组，集合或映射，至少应有一个匹配元素。</p>
</div>
<div class="paragraph">
<p>默认行为是将带注释的方法和字段视为指示所需的依赖项。您可以按照以下示例中的说明更改此行为，从而使框架可以通过将其标记为不需要来跳过不满意的注入点（即，通过将<code>required</code>归因于<code>@Autowired</code>至<code>false</code> ）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    @Autowired(required = false)
    var movieFinder: MovieFinder? = null

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不需要的方法（或在多个参数的情况下，其中一个依赖项）不可用，则根本不会调用该方法。在这种情况下，不需要的字段将完全不会填充，而将其默认值保留在适当的位置。</p>
</div>
<div class="paragraph">
<p>注入的构造函数和工厂方法参数是一种特殊情况，因为<code>required</code>归因于<code>@Autowired</code>由于Spring的构造函数解析算法可能会处理多个构造函数，因此其含义有所不同。默认情况下，有效地需要构造函数和工厂方法参数，但是在单构造函数场景中需要一些特殊规则，例如，如果没有可用的匹配bean，则多元素注入点（数组，集合，映射）可以解析为空实例。这允许一种通用的实现模式，其中所有依赖项都可以在唯一的多参数构造函数中声明-例如，声明为单个公共构造函数而没有<code>@Autowired</code>注解。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>任何给定bean类的构造函数只能声明<code>@Autowired</code>与<code>required</code>属性设置为<code>true</code> ，指示用作Spring bean时要自动装配<em>的</em>构造函数。此外，如果<code>required</code>属性设置为<code>true</code> ，只有一个构造函数可以用注释<code>@Autowired</code> 。如果多个<em>不需要的</em>构造函数声明了注释，则它们将被视为自动装配的候选对象。将选择通过匹配Spring容器中的bean可以满足的依赖关系数量最多的构造函数。如果没有一个候选者满意，则将使用主/默认构造函数（如果存在）。如果一个类仅声明一个单一的构造函数开始，即使没有注释，也将始终使用它。带注释的构造函数不必是公共的。</p>
</div>
<div class="paragraph">
<p>的<code>required</code>的属性<code>@Autowired</code>建议在不推荐的地方使用<code>@Required</code> setter方法上的注释。设置<code>required</code>归因于<code>false</code>指示该属性对于自动装配不是必需的，并且如果无法自动装配，则将忽略该属性。 <code>@Required</code>另一方面，它更强大，因为它强制通过容器支持的任何方式来设置属性，并且如果未定义任何值，则会引发相应的异常。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另外，您可以通过Java 8来表达特定依赖项的非必需性质<code>java.util.Optional</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从Spring Framework 5.0开始，您还可以使用<code>@Nullable</code>注释（任何包中的任何注释，例如， <code>javax.annotation.Nullable</code> （来自JSR-305）或仅利用Kotlin内置的null安全支持：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    @Autowired
    var movieFinder: MovieFinder? = null

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>@Autowired</code>对于众所周知的可解决依赖性的接口： <code>BeanFactory</code> ， <code>ApplicationContext</code> ， <code>Environment</code> ， <code>ResourceLoader</code> ， <code>ApplicationEventPublisher</code>和<code>MessageSource</code> 。这些接口及其扩展接口，例如<code>ConfigurableApplicationContext</code>要么<code>ResourcePatternResolver</code>会自动解决，无需进行特殊设置。以下示例自动接线<code>ApplicationContext</code>宾语：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    lateinit var context: ApplicationContext

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>@Autowired</code> ， <code>@Inject</code> ， <code>@Value</code>和<code>@Resource</code>注释由Spring处理<code>BeanPostProcessor</code>实现。这意味着您不能在自己的内部应用这些注释<code>BeanPostProcessor</code>要么<code>BeanFactoryPostProcessor</code>类型（如果有）。必须使用XML或Spring明确“连接”这些类型<code>@Bean</code>方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a> 1.9.3。通过微调基于注释的自动装配<code>@Primary</code></h4>
<div class="paragraph">
<p>由于按类型自动布线可能会导致多个候选对象，因此通常有必要对选择过程进行更多控制。一种实现此目标的方法是使用Spring的<code>@Primary</code>注解。 <code>@Primary</code>指示当多个bean是要自动装配到单值依赖项的候选对象时，应给予特定bean优先权。如果候选中恰好存在一个主bean，则它将成为自动装配的值。</p>
</div>
<div class="paragraph">
<p>考虑以下定义的配置<code>firstMovieCatalog</code>作为主要<code>MovieCatalog</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class MovieConfiguration {

    @Bean
    @Primary
    fun firstMovieCatalog(): MovieCatalog { ... }

    @Bean
    fun secondMovieCatalog(): MovieCatalog { ... }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用前面的配置，下面的<code>MovieRecommender</code>与<code>firstMovieCatalog</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    private lateinit var movieCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相应的bean定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog" primary="true"&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a> 1.9.4。使用限定符对基于注释的自动装配进行微调</h4>
<div class="paragraph">
<p><code>@Primary</code>当可以确定一个主要候选对象时，它是在几种情况下按类型使用自动装配的有效方法。当您需要对选择过程进行更多控制时，可以使用Spring的<code>@Qualifier</code>注解。您可以将限定符值与特定的参数相关联，从而缩小类型匹配的范围，以便为每个参数选择特定的bean。在最简单的情况下，这可以是简单的描述性值，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private lateinit var movieCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以指定<code>@Qualifier</code>各个构造函数参数或方法参数的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    private lateinit var movieCatalog: MovieCatalog

    private lateinit var customerPreferenceDao: CustomerPreferenceDao

    @Autowired
    fun prepare(@Qualifier("main") movieCatalog: MovieCatalog,
                customerPreferenceDao: CustomerPreferenceDao) {
        this.movieCatalog = movieCatalog
        this.customerPreferenceDao = customerPreferenceDao
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的bean定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier value="main"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier value="action"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>与豆<code>main</code>限定符值与限定有相同值的构造函数参数关联。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>与豆<code>action</code>限定符值与限定有相同值的构造函数参数关联。</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>对于后备匹配，bean名称被认为是默认的限定符值。因此，您可以使用<code>id</code>的<code>main</code>而不是嵌套的限定符元素，从而导致相同的匹配结果。但是，尽管您可以使用此约定按名称引用特定的bean， <code>@Autowired</code>从根本上讲，是带有可选语义限定符的类型驱动注入。这意味着限定符值，即使具有bean名称回退，也总是在类型匹配集中具有狭窄的语义。它们没有在语义上表示对唯一bean的引用<code>id</code> 。好的限定词值是<code>main</code>要么<code>EMEA</code>要么<code>persistent</code> ，表示独立于Bean的特定组件的特征<code>id</code> ，如果是匿名bean定义（例如前面的示例中的定义），则可以自动生成。</p>
</div>
<div class="paragraph">
<p>限定词还适用于类型化的集合，如前所述-例如， <code>Set<MovieCatalog></code> 。在这种情况下，根据声明的限定符，将所有匹配的bean作为集合注入。这意味着限定词不必是唯一的。相反，它们构成了过滤标准。例如，您可以定义多个<code>MovieCatalog</code>具有相同限定值“操作”的bean，所有这些都注入到<code>Set<MovieCatalog></code>带有注释<code>@Qualifier("action")</code> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>在类型匹配的候选对象中，让限定符值根据目标Bean名称进行选择，不需要<code>@Qualifier</code>注入点的注释。如果没有其他解析度指示符（例如限定词或主标记），则对于非唯一依赖性情况，Spring将注入点名称（即字段名称或参数名称）与目标Bean名称进行匹配，然后选择同名候选人（如果有）。</p>
</div>
<div class="paragraph">
<p>就是说，如果您打算按名称表示注释驱动的注入，请不要主要使用<code>@Autowired</code> ，即使它能够在类型匹配的候选对象中按bean名称进行选择。而是使用JSR-250 <code>@Resource</code>注解，在语义上定义为通过其唯一名称标识特定目标组件，而声明的类型与匹配过程无关。 <code>@Autowired</code>具有不同的语义：按类型选择候选bean之后，指定的<code>String</code>限定符值仅在这些类型选择的候选中被考虑（例如，与<code>account</code>带有标记相同限定符的bean的限定符）。</p>
</div>
<div class="paragraph">
<p>对于本身定义为集合的bean， <code>Map</code>或数组类型， <code>@Resource</code>是一个很好的解决方案，通过唯一名称引用特定的集合或数组bean。也就是说，从4.3版本开始，您可以匹配<code>Map</code> ，以及通过Spring的数组类型<code>@Autowired</code>类型匹配算法，只要元素类型信息保留在<code>@Bean</code>返回类型签名或集合继承层次结构。在这种情况下，您可以使用限定符值在同类型的集合中进行选择，如上一段所述。</p>
</div>
<div class="paragraph">
<p>从4.3开始， <code>@Autowired</code>还考虑将自我引用用于注入（即，引用回当前注入的Bean）。请注意，自我注入是一个后备。对其他组件的常规依赖始终优先。从这个意义上说，自我推荐不参与常规的候选人选择，因此尤其是绝不是主要的。相反，它们总是以最低优先级结束。实际上，您应该仅将自我引用用作最后的手段（例如，通过Bean的事务代理在同一实例上调用其他方法）。考虑在这种情况下将受影响的方法分解为单独的委托bean。或者，您可以使用<code>@Resource</code> ，它可以通过其唯一名称获得返回到当前bean的代理。</p>
</div>
<div class="paragraph">
<p><code>@Autowired</code>适用于字段，构造函数和多参数方法，从而允许在参数级别缩小限定符注释的范围。相反， <code>@Resource</code>仅支持具有单个参数的字段和bean属性设置器方法。因此，如果注入目标是构造函数或多参数方法，则应坚持使用限定符。</p>
</div>
<div class="paragraph">
<p>您可以创建自己的自定义限定符注释。为此，请定义一个注释并提供<code>@Qualifier</code>定义中的注解，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class Genre(val value: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以在自动连接的字段和参数上提供自定义限定符，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    @Genre("Action")
    private lateinit var actionCatalog: MovieCatalog

    private lateinit var comedyCatalog: MovieCatalog

    @Autowired
    fun setComedyCatalog(@Genre("Comedy") comedyCatalog: MovieCatalog) {
        this.comedyCatalog = comedyCatalog
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，您可以提供有关候选bean定义的信息。你可以加<code><qualifier/></code>标签作为的子元素<code><bean/></code>标签，然后指定<code>type</code>和<code>value</code>以匹配您的自定义限定词注释。该类型与注释的标准类名匹配。另外，为方便起见，如果不存在名称冲突的风险，则可以使用简短的类名。下面的示例演示了两种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="Genre" value="Action"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="example.Genre" value="Comedy"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在“ <a href="#beans-classpath-scanning">类路径扫描和托管组件”中</a> ，您可以看到基于注释的替代方法，以XML提供限定符元数据。具体来说，请参阅<a href="#beans-scanning-qualifiers">为Qualifier元数据提供注释</a> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，使用没有值的注释就足够了。当注释用于更一般的用途并且可以应用于几种不同类型的依赖项时，这将很有用。例如，您可以提供一个脱机目录，当没有Internet连接可用时可以进行搜索。首先，定义简单的批注，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class Offline</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将注释添加到要自动装配的字段或属性，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    @Offline <i class="conum" data-value="1"></i><b>(1)</b>
    private MovieCatalog offlineCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这行添加<code>@Offline</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    @Offline <i class="conum" data-value="1"></i><b>(1)</b>
    private lateinit var offlineCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这行添加<code>@Offline</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，bean定义只需要一个限定符<code>type</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="example.SimpleMovieCatalog"&gt;
    &lt;qualifier type="Offline"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;!-- inject any dependencies required by this bean --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>该元素指定限定词。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以定义自定义限定符批注，该批注除了简单名称之外（或代替简单名称）还接受命名属性<code>value</code>属性。如果随后在要自动装配的字段或参数上指定了多个属性值，则Bean定义必须与所有此类属性值匹配才能被视为自动装配候选。例如，请考虑以下注释定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class MovieQualifier(val genre: String, val format: Format)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下<code>Format</code>是一个枚举，定义如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public enum Format {
    VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">enum class Format {
    VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要自动装配的字段用自定义限定符注释，并包括两个属性的值： <code>genre</code>和<code>format</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Autowired
    @MovieQualifier(format = Format.VHS, genre = "Action")
    private lateinit var actionVhsCatalog: MovieCatalog

    @Autowired
    @MovieQualifier(format = Format.VHS, genre = "Comedy")
    private lateinit var comedyVhsCatalog: MovieCatalog

    @Autowired
    @MovieQualifier(format = Format.DVD, genre = "Action")
    private lateinit var actionDvdCatalog: MovieCatalog

    @Autowired
    @MovieQualifier(format = Format.BLURAY, genre = "Comedy")
    private lateinit var comedyBluRayCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，bean定义应包含匹配的限定符值。此示例还演示了可以使用bean元属性代替<code><qualifier/></code>元素。如果有的话， <code><qualifier/></code>元素及其属性优先，但是自动装配机制会依赖于<code><meta/></code>如果不存在这样的限定符，则使用标记，如以下示例中的最后两个bean定义所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Action"/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Comedy"/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="DVD"/&gt;
        &lt;meta key="genre" value="Action"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="BLURAY"/&gt;
        &lt;meta key="genre" value="Comedy"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a> 1.9.5。将泛型用作自动装配限定符</h4>
<div class="paragraph">
<p>除了<code>@Qualifier</code>注解，您可以使用Java泛型类型作为限定的隐式形式。例如，假设您具有以下配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class MyConfiguration {

    @Bean
    fun stringStore() = StringStore()

    @Bean
    fun integerStore() = IntegerStore()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设前面的Bean实现了通用接口（即， <code>Store<String></code>和<code>Store<Integer></code> ）， 您可以<code>@Autowire</code>的<code>Store</code>接口，泛型用作限定符，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Autowired
private lateinit var s1: Store&lt;String&gt; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private lateinit var s2: Store&lt;Integer&gt; // &lt;Integer&gt; qualifier, injects the integerStore bean</code></pre>
</div>
</div>
<div class="paragraph">
<p>通用限定词在自动装配列表时也适用， <code>Map</code>实例和数组。下面的示例自动连接通用<code>List</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private List&lt;Store&lt;Integer&gt;&gt; s;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private lateinit var s: List&lt;Store&lt;Integer&gt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a> 1.9.6。使用<code>CustomAutowireConfigurer</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>是一个<code>BeanFactoryPostProcessor</code>这样您就可以注册自己的自定义限定符注释类型，即使它们没有用Spring的注释符注释<code>@Qualifier</code>注解。以下示例显示了如何使用<code>CustomAutowireConfigurer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;
    &lt;property name="customQualifierTypes"&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>AutowireCandidateResolver</code>通过以下方式确定自动接线候选：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>autowire-candidate</code>每个bean定义的值</p>
</li>
<li>
<p>任何<code>default-autowire-candidates</code>可用的图案<code><beans/></code>元件</p>
</li>
<li>
<p>存在<code>@Qualifier</code>注释以及在上注册的所有自定义注释<code>CustomAutowireConfigurer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当多个bean符合自动装配候选条件时，“主要”的确定如下：如果候选中恰好有一个bean定义具有<code>primary</code>属性设置为<code>true</code> ，它被选中。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a> 1.9.7。注射用<code>@Resource</code></h4>
<div class="paragraph">
<p>Spring还通过使用JSR-250支持注入<code>@Resource</code>注释（ <code>javax.annotation.Resource</code> ）或bean属性设置器方法。这是Java EE中的一种常见模式：例如，在JSF管理的Bean和JAX-WS端点中。Spring也为Spring管理的对象支持此模式。</p>
</div>
<div class="paragraph">
<p><code>@Resource</code>具有名称属性。默认情况下，Spring将该值解释为要注入的Bean名称。换句话说，它遵循命名语义，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder") <i class="conum" data-value="1"></i><b>(1)</b>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这行注入一个<code>@Resource</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    @Resource(name="myMovieFinder") <i class="conum" data-value="1"></i><b>(1)</b>
    private lateinit var movieFinder:MovieFinder
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这行注入一个<code>@Resource</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果未明确指定名称，则默认名称是从字段名称或setter方法派生的。如果是字段，则采用字段名称。在使用setter方法的情况下，它采用bean属性名称。下面的例子将把bean命名为<code>movieFinder</code>注入其setter方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    @Resource
    private lateinit var movieFinder: MovieFinder

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">批注提供的名称由解析为Bean名称。 <code>ApplicationContext</code>其中<code>CommonAnnotationBeanPostProcessor</code>知道。如果您配置Spring的名称，则可以通过JNDI解析名称。 <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>明确地。但是，我们建议您依靠默认行为并使用Spring的JNDI查找功能来保留间接级别。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在排他性的情况下<code>@Resource</code>未指定明确名称的用法，类似于<code>@Autowired</code> ， <code>@Resource</code>查找主类型匹配而不是特定的命名Bean，并解决众所周知的可解决依赖项： <code>BeanFactory</code> ， <code>ApplicationContext</code> ， <code>ResourceLoader</code> ， <code>ApplicationEventPublisher</code>和<code>MessageSource</code>接口。</p>
</div>
<div class="paragraph">
<p>因此，在以下示例中， <code>customerPreferenceDao</code>字段首先查找名为“ customerPreferenceDao”的bean，然后回退到该类型的主类型匹配项<code>CustomerPreferenceDao</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; <i class="conum" data-value="1"></i><b>(1)</b>

    public MovieRecommender() {
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>context</code>根据已知的可解决依赖类型注入字段： <code>ApplicationContext</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender {

    @Resource
    private lateinit var customerPreferenceDao: CustomerPreferenceDao


    @Resource
    private lateinit var context: ApplicationContext <i class="conum" data-value="1"></i><b>(1)</b>

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>context</code>根据已知的可解决依赖类型注入字段： <code>ApplicationContext</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-value-annotations"><a class="anchor" href="#beans-value-annotations"></a> 1.9.8。使用<code>@Value</code></h4>
<div class="paragraph">
<p><code>@Value</code>通常用于注入外部属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class MovieRecommender(@Value("\${catalog.name}") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@PropertySource("classpath:application.properties")
class AppConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>而以下<code>application.properties</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">catalog.name=MovieCatalog</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>catalog</code>参数和字段将等于<code>MovieCatalog</code>值。</p>
</div>
<div class="paragraph">
<p>Spring提供了一个默认的宽松内嵌值解析器。它将尝试解析属性值，如果无法解析，则尝试使用属性名称（例如<code>${catalog.name}</code> ）将作为值被注入。如果要严格控制不存在的值，则应声明一个<code>PropertySourcesPlaceholderConfigurer</code> Bean，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">配置一个<code>PropertySourcesPlaceholderConfigurer</code>使用JavaConfig， <code>@Bean</code>方法必须是<code>static</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用以上配置可确保Spring初始化失败（如果有） <code>${}</code>占位符无法解析。也可以使用类似的方法<code>setPlaceholderPrefix</code> ， <code>setPlaceholderSuffix</code> ， 要么<code>setValueSeparator</code>自定义占位符。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot默认配置一个<code>PropertySourcesPlaceholderConfigurer</code>从中获取属性的bean <code>application.properties</code>和<code>application.yml</code>文件。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring提供的内置转换器支持允许简单的类型转换（ <code>Integer</code>要么<code>int</code>例如）自动处理。多个逗号分隔的值可以自动转换为String数组，而无需付出额外的努力。</p>
</div>
<div class="paragraph">
<p>可以提供如下默认值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class MovieRecommender(@Value("\${catalog.name:defaultCatalog}") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>春天<code>BeanPostProcessor</code>使用一个<code>ConversionService</code>在后台处理转换String值的过程<code>@Value</code>到目标类型。如果要为自己的自定义类型提供转换支持，则可以提供自己的自定义类型<code>ConversionService</code> Bean实例如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun conversionService(): ConversionService {
            return DefaultFormattingConversionService().apply {
            addConverter(MyCustomConverter())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么时候<code>@Value</code>包含一个<a href="#expressions"><code>SpEL</code>表达式，</a>该值将在运行时动态计算，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class MovieRecommender(
    @Value("#{systemProperties['user.catalog'] + 'Catalog' }") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>SpEL还可以使用更复杂的数据结构：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MovieRecommender {

    private final Map&lt;String, Integer&gt; countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map&lt;String, Integer&gt; countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class MovieRecommender(
    @Value("#{{'Thriller': 100, 'Comedy': 300}}") private val countOfMoviesPerCatalog: Map&lt;String, Int&gt;)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a> 1.9.9。使用<code>@PostConstruct</code>和<code>@PreDestroy</code></h4>
<div class="paragraph">
<p>的<code>CommonAnnotationBeanPostProcessor</code>不仅认识到<code>@Resource</code>注释，还有JSR-250生命周期注释： <code>javax.annotation.PostConstruct</code>和<code>javax.annotation.PreDestroy</code> 。在Spring 2.5中引入了对这些注释的支持，为<a href="#beans-factory-lifecycle-initializingbean">初始化回调</a>和<a href="#beans-factory-lifecycle-disposablebean">销毁回调中</a>描述的生命周期回调机制提供了一种替代<a href="#beans-factory-lifecycle-disposablebean">方法</a> 。前提是<code>CommonAnnotationBeanPostProcessor</code>在春季注册<code>ApplicationContext</code> ，在生命周期中与相应的Spring生命周期接口方法或显式声明的回调方法在同一点调用带有这些批注之一的方法。在以下示例中，缓存在初始化时预先填充，并在销毁时清除：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CachingMovieLister {

    @PostConstruct
    fun populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    fun clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关组合各种生命周期机制的效果的详细信息，请参见<a href="#beans-factory-lifecycle-combined-effects">组合生命周期机制</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>喜欢<code>@Resource</code> ， <code>@PostConstruct</code>和<code>@PreDestroy</code>批注类型是JDK 6至8的标准Java库的一部分。但是，整个<code>javax.annotation</code>软件包与JDK 9中的核心Java模块分离，并最终在JDK 11中删除。如果需要， <code>javax.annotation-api</code>现在需要通过Maven Central获取工件，只需像其他任何库一样将其添加到应用程序的类路径中即可。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-classpath-scanning"><a class="anchor" href="#beans-classpath-scanning"></a> 1.10。类路径扫描和托管组件</h3>
<div class="paragraph">
<p>本章中的大多数示例都使用XML来指定生成每个配置的配置元数据<code>BeanDefinition</code>在Spring容器中。上一节（ <a href="#beans-annotation-config">基于注释的容器配置</a> ）演示了如何通过源级别的注释提供许多配置元数据。但是，即使在这些示例中，“基本” bean定义也已在XML文件中明确定义，而注释仅驱动依赖项注入。本节介绍了通过扫描类路径来隐式检测候选组件的选项。候选组件是与过滤条件匹配的类，并具有在容器中注册的相应bean定义。这消除了使用XML进行bean注册的需要。相反，您可以使用注释（例如， <code>@Component</code> ），AspectJ类型表达式或您自己的自定义过滤条件，以选择哪些类已向容器注册了bean定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring 3.0开始，Spring JavaConfig项目提供的许多功能是核心Spring Framework的一部分。这使您可以使用Java而不是使用传统的XML文件来定义bean。看看<code>@Configuration</code> ， <code>@Bean</code> ， <code>@Import</code>和<code>@DependsOn</code>有关如何使用这些新功能的示例的注释。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a> 1.10.1。 <code>@Component</code>和更多的刻板印象注释</h4>
<div class="paragraph">
<p>的<code>@Repository</code>批注是实现存储库的角色或构造型（也称为数据访问对象或DAO）的任何类的标记。如<a href="data-access.html#orm-exception-translation">Exception Translation中</a>所述，该标记的用途是自动翻译<a href="data-access.html#orm-exception-translation">异常</a> 。</p>
</div>
<div class="paragraph">
<p>Spring提供了进一步的构造型注释： <code>@Component</code> ， <code>@Service</code>和<code>@Controller</code> 。 <code>@Component</code>是任何Spring托管组件的通用构造型。
<code>@Repository</code> ， <code>@Service</code>和<code>@Controller</code>是的专业<code>@Component</code>用于更具体的用例（分别在持久性，服务和表示层）。因此，您可以使用以下方式注释组件类<code>@Component</code> ，但是用<code>@Repository</code> ， <code>@Service</code> ， 要么<code>@Controller</code>相反，您的类更适合于通过工具进行处理或与方面相关联。例如，这些构造型注释成为切入点的理想目标。 <code>@Repository</code> ， <code>@Service</code>和<code>@Controller</code>可以在Spring Framework 的将来版本中携带其他语义。因此，如果您选择使用<code>@Component</code>要么<code>@Service</code>对于您的服务层<code>@Service</code>显然是更好的选择。同样，如前所述， <code>@Repository</code>已被支持作为持久层中自动异常翻译的标记。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a> 1.10.2。使用元注释和组合注释</h4>
<div class="paragraph">
<p>Spring提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。例如， <code>@Service</code>注释提到<a href="#beans-stereotype-annotations">前面</a>是荟萃标注了<code>@Component</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component <i class="conum" data-value="1"></i><b>(1)</b>
public @interface Service {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Component</code>原因<code>@Service</code>对待方式与<code>@Component</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@Component <i class="conum" data-value="1"></i><b>(1)</b>
annotation class Service {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Component</code>原因<code>@Service</code>对待方式与<code>@Component</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以组合元注释来创建“组合注释”。例如， <code>@RestController</code> Spring MVC的注释由<code>@Controller</code>和<code>@ResponseBody</code> 。</p>
</div>
<div class="paragraph">
<p>此外，组合注释可以选择从元注释中重新声明属性，以允许自定义。当您只希望公开元注释属性的子集时，此功能特别有用。例如，春天的<code>@SessionScope</code>批注将作用域名称硬编码为<code>session</code>但仍允许自定义<code>proxyMode</code> 。以下清单显示了<code>SessionScope</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@Scope(WebApplicationContext.SCOPE_SESSION)
annotation class SessionScope(
        @get:AliasFor(annotation = Scope::class)
        val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>@SessionScope</code>没有声明<code>proxyMode</code>如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
@SessionScope
public class SessionScopedService {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Service
@SessionScope
class SessionScopedService {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以覆盖<code>proxyMode</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
class SessionScopedUserService : UserService {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation编程模型</a> Wiki页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a> 1.10.3。自动检测类并注册Bean定义</h4>
<div class="paragraph">
<p>Spring可以自动检测构造型类并注册相应的类<code>BeanDefinition</code>具有的实例<code>ApplicationContext</code> 。例如，以下两个类别有资格进行这种自动检测：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Service
class SimpleMovieLister(private val movieFinder: MovieFinder)</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository
class JpaMovieFinder : MovieFinder {
    // implementation elided for clarity
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要自动检测这些类并注册相应的bean，您需要添加<code>@ComponentScan</code>给你<code>@Configuration</code>课，在那里<code>basePackages</code> attribute是两个类的公共父包。（或者，您可以指定一个逗号分隔，分号分隔或空格分隔的列表，其中包括每个类的父包。）</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"])
class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为简便起见，前面的示例可以使用<code>value</code>注释的属性（即， <code>@ComponentScan("org.example")</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下替代方法使用XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="org.example"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">指某东西的用途<code><context:component-scan></code>隐式启用以下功能<code><context:annotation-config></code> 。通常无需包括<code><context:annotation-config></code>使用时的元素<code><context:component-scan></code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用Ant构建JAR时，请确保未激活JAR任务的仅文件开关。此外，在某些环境中，可能不会基于安全策略公开类路径目录，例如，在JDK 1.7.0_45及更高版本上的独立应用程序（这需要在清单中设置“受信任的库”，请参见<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">https://stackoverflow.com/ Questions / 19394570 / java-jre-7u45-breaks-classloader-getresources</a> ）。</p>
</div>
<div class="paragraph">
<p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常可以按预期进行。但是，请确保将组件类导出到您的<code>module-info</code>描述符。如果您希望Spring调用您的类的非公共成员，请确保已“打开”它们（即，他们使用<code>opens</code>声明而不是<code>exports</code>在你的声明<code>module-info</code>描述符）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此外， <code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>当您使用component-scan元素时，它们都隐式包括在内。这意味着将自动检测这两个组件并将它们连接在一起，而这一切都不需要XML中提供的任何bean配置元数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以禁用注册<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>通过包括<code>annotation-config</code>值为的属性<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a> 1.10.4。使用过滤器自定义扫描</h4>
<div class="paragraph">
<p>默认情况下，带注释的类<code>@Component</code> ， <code>@Repository</code> ， <code>@Service</code> ， <code>@Controller</code> ， <code>@Configuration</code> ，或带有注释的自定义注释<code>@Component</code>是唯一检测到的候选成分。但是，您可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为<code>includeFilters</code>要么<code>excludeFilters</code>的属性<code>@ComponentScan</code>注释（或作为<code><context:include-filter /></code>要么<code><context:exclude-filter /></code>的子元素<code><context:component-scan></code> XML配置中的元素）。每个过滤器元素都需要<code>type</code>和<code>expression</code>属性。下表描述了过滤选项：</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表5。筛选器类型</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">过滤器类型</th>
<th class="tableblock halign-left valign-top">范例表达</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释（默认）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在目标组件中的类型级别上<em>存在</em>或<em>元存在</em>的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">可分配的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">目标组件可分配给（扩展或实现）的类（或接口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方面</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example..*Service+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">目标组件要匹配的AspectJ类型表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">正则表达式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org\.example\.Default.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要与目标组件的类名匹配的正则表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">习俗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的自定义实现<code>org.springframework.core.type.TypeFilter</code>接口。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下示例显示了忽略所有配置<code>@Repository</code>批注并改用“存根”存储库：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = [Filter(type = FilterType.REGEX, pattern = [".*Stub.*Repository"])],
        excludeFilters = [Filter(Repository::class)])
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了等效的XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example"&gt;
        &lt;context:include-filter type="regex"
                expression=".*Stub.*Repository"/&gt;
        &lt;context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以通过设置禁用默认过滤器<code>useDefaultFilters=false</code>在注释上或通过提供<code>use-default-filters="false"</code>作为<code><component-scan/></code>元件。这有效地禁用了自动检测带注解或元注解的类的功能。 <code>@Component</code> ， <code>@Repository</code> ， <code>@Service</code> ， <code>@Controller</code> ， <code>@RestController</code> ， 要么<code>@Configuration</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a> 1.10.5。在组件中定义Bean元数据</h4>
<div class="paragraph">
<p>Spring组件还可以将bean定义元数据贡献给容器。您可以使用相同的方法<code>@Bean</code>用于在其中定义bean元数据的注释<code>@Configuration</code>带注释的类。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    fun publicInstance() = TestBean("publicInstance")

    fun doWork() {
        // Component method implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上一类是Spring组件，其组件中包含特定于应用程序的代码<code>doWork()</code>方法。但是，它也提供了具有工厂方法的bean定义，该方法引用了该方法<code>publicInstance()</code> 。的<code>@Bean</code>批注标识工厂方法和其他bean定义属性，例如通过<code>@Qualifier</code>注解。可以指定的其他方法级别的注释是<code>@Scope</code> ， <code>@Lazy</code>以及自定义限定符注释。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">除了用于组件初始化的角色外，您还可以将<code>@Lazy</code>标记为的注射点的注释<code>@Autowired</code>要么<code>@Inject</code> 。在这种情况下，它导致注入了惰性解析代理。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如前所述，支持自动接线的字段和方法，并自动接线<code>@Bean</code>方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class FactoryMethodComponent {

    companion object {
        private var i: Int = 0
    }

    @Bean
    @Qualifier("public")
    fun publicInstance() = TestBean("publicInstance")

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected fun protectedInstance(
            @Qualifier("public") spouse: TestBean,
            @Value("#{privateInstance.age}") country: String) = TestBean("protectedInstance", 1).apply {
        this.spouse = spouse
        this.country = country
    }

    @Bean
    private fun privateInstance() = TestBean("privateInstance", i++)

    @Bean
    @RequestScope
    fun requestScopedInstance() = TestBean("requestScopedInstance", 3)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例自动连接<code>String</code>方法参数<code>country</code>到<code>age</code>另一个名为bean的属性<code>privateInstance</code> 。Spring Expression Language元素通过符号定义属性的值<code>#{ <expression> }</code> 。对于<code>@Value</code>注解，表达式解析器已预先配置为在解析表达式文本时查找bean名称。</p>
</div>
<div class="paragraph">
<p>从Spring Framework 4.3开始，您还可以声明类型的工厂方法参数<code>InjectionPoint</code> （或更具体的子类： <code>DependencyDescriptor</code> ）访问触发当前bean创建的请求注入点。请注意，这仅适用于实际创建的Bean实例，不适用于注入现有实例。因此，此功能对原型范围的bean最有意义。对于其他范围，factory方法仅在给定范围内看到触发创建新bean实例的注入点（例如，触发创建懒惰单例bean的依赖项）。在这种情况下，可以将提供的注入点元数据与语义一起使用。以下示例显示了如何使用<code>InjectionPoint</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class FactoryMethodComponent {

    @Bean
    @Scope("prototype")
    fun prototypeInstance(injectionPoint: InjectionPoint) =
            TestBean("prototypeInstance for ${injectionPoint.member}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@Bean</code>常规Spring组件中的方法与Spring中相应方法的处理方式不同<code>@Configuration</code>类。区别在于<code>@Component</code> CGLIB无法增强类，以拦截方法和字段的调用。CGLIB代理是在其中调用方法或字段的方式<code>@Bean</code>方法中<code>@Configuration</code>类创建对协作对象的Bean元数据引用。此类方法不是用普通的Java语义调用的，而是通过容器进行的，以提供Spring Bean的常规生命周期管理和代理，即使通过编程调用其他Bean时也是如此。 <code>@Bean</code>方法。相反，在<code>@Bean</code>平原内的方法<code>@Component</code>类具有标准的Java语义，没有特殊的CGLIB处理或其他限制。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以声明<code>@Bean</code>方法为<code>static</code> ，允许调用它们而不将其包含的配置类创建为实例。这在定义后处理器Bean（例如，类型为<code>BeanFactoryPostProcessor</code>要么<code>BeanPostProcessor</code> ），因为此类bean在容器生命周期的早期就已初始化，因此应避免在那一刻触发配置的其他部分。</p>
</div>
<div class="paragraph">
<p>调用静态<code>@Bean</code>方法永远不会被容器拦截，甚至不会被容器拦截<code>@Configuration</code>由于技术限制，这些类（如本节前面所述）：CGLIB子类只能覆盖非静态方法。结果，直接呼叫另一个<code>@Bean</code>方法具有标准的Java语义，导致直接从工厂方法本身返回一个独立的实例。</p>
</div>
<div class="paragraph">
<p>Java语言的可视性<code>@Bean</code>方法不会对Spring容器中的结果bean定义产生直接影响。您可以随意声明自己的工厂方法，以适合非<code>@Configuration</code>类以及任何地方的静态方法。但是，定期<code>@Bean</code>方法中<code>@Configuration</code>类必须是可重写的-即，不能将它们声明为<code>private</code>要么<code>final</code> 。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code>还可以在给定组件或配置类的基类上以及在由组件或配置类实现的接口中声明的Java 8默认方法上发现方法。这为组合复杂的配置安排提供了很大的灵活性，从Spring 4.2开始，通过Java 8默认方法甚至可以进行多重继承。</p>
</div>
<div class="paragraph">
<p>最后，一个类可以容纳多个<code>@Bean</code>用于同一bean的方法，作为运行时取决于可用依赖项的多个工厂方法的安排。这与在其他配置方案中选择“最贪婪”的构造函数或工厂方法的算法相同：在构造时选择具有最大可满足依赖关系数量的变体，类似于容器在多个容器之间进行选择的方式<code>@Autowired</code>构造函数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a> 1.10.6。命名自动检测的组件</h4>
<div class="paragraph">
<p>当在扫描过程中自动检测到某个组件时，其bean名称由<code>BeanNameGenerator</code>扫描程序已知的策略。默认情况下，任何Spring构造型注释（ <code>@Component</code> ， <code>@Repository</code> ， <code>@Service</code>和<code>@Controller</code> ）包含一个名称<code>value</code>从而将该名称提供给相应的bean定义。</p>
</div>
<div class="paragraph">
<p>如果这样的注释不包含名称<code>value</code>或对于任何其他检测到的组件（例如，由自定义过滤器发现的组件），默认bean名称生成器将返回不使用大写字母的非限定类名。例如，如果检测到以下组件类，则名称为<code>myMovieLister</code>和<code>movieFinderImpl</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Service("myMovieLister")
class SimpleMovieLister {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository
class MovieFinderImpl : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您不想依赖默认的Bean命名策略，则可以提供自定义Bean命名策略。首先，实施<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a>接口，并确保包含默认的无参数构造函数。然后，在配置扫描器时提供完全限定的类名，如以下示例注释和Bean定义所示：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"], nameGenerator = MyNameGenerator::class)
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" /&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，请考虑在其他组件可能对其进行显式引用时，使用批注指定名称。另一方面，只要容器负责接线，自动生成的名称就足够了。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a> 1.10.7。提供自动检测组件的范围</h4>
<div class="paragraph">
<p>通常，与Spring管理的组件一样，自动检测到的组件的默认范围也是最常见的范围是<code>singleton</code> 。但是，有时您需要一个不同的范围，而该范围可以由<code>@Scope</code>注解。您可以在注释中提供范围的名称，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Scope("prototype")
@Repository
class MovieFinderImpl : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@Scope</code>注释仅在具体的bean类（对于带注释的组件）或工厂方法（对于<code>@Bean</code>方法）。与XML bean定义相反，没有bean定义继承的概念，并且在类级别的继承层次结构与元数据目的无关。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关特定于Web的范围的详细信息，例如Spring上下文中的“ request”或“ session”，请参阅<a href="#beans-factory-scopes-other">Request，Session，Application和WebSocket Scope</a> 。与这些范围的预构建注释一样，您也可以使用Spring的元注释方法来编写自己的作用域注释：例如，使用<code>@Scope("prototype")</code> ，也可能会声明自定义范围代理模式。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要提供用于范围解析的自定义策略，而不是依靠基于注释的方法，您可以实施<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a>接口。确保包括默认的无参数构造函数。然后，您可以在配置扫描器时提供完全限定的类名，如以下注释和Bean定义示例所示：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用某些非单作用域时，可能有必要为作用域对象生成代理。在<a href="#beans-factory-scopes-other-injection">范围Bean中将</a>推理描述<a href="#beans-factory-scopes-other-injection">为依赖项</a> 。为此，在component-scan元素上可以使用scoped-proxy属性。三个可能的值是： <code>no</code> ， <code>interfaces</code>和<code>targetClass</code> 。例如，以下配置生成标准的JDK动态代理：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example" scoped-proxy="interfaces"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a> 1.10.8。提供带有注释的限定符元数据</h4>
<div class="paragraph">
<p>的<code>@Qualifier</code>在<a href="#beans-autowired-annotation-qualifiers">带有限定符的基于注释的自动装配中</a>讨论了<a href="#beans-autowired-annotation-qualifiers">注释</a> 。该部分中的示例说明了<code>@Qualifier</code>注解和自定义限定符注解在解析自动装配候选时提供细粒度的控制。由于这些示例均基于XML Bean定义，因此通过使用<code>qualifier</code>要么<code>meta</code>的子元素<code>bean</code> XML中的元素。当依靠类路径扫描来自动检测组件时，可以在候选类上为限定符元数据提供类型级别的注释。下面的三个示例演示了此技术：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
@Qualifier("Action")
class ActionMovieCatalog : MovieCatalog</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
@Genre("Action")
class ActionMovieCatalog : MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
@Offline
class CachingMovieCatalog : MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与大多数基于注释的替代方法一样，请记住，注释元数据绑定到类定义本身，而XML的使用允许相同类型的多个bean提供其限定符元数据的变体，因为该元数据是按-instance而不是按类。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a> 1.10.9。生成候选组件的索引</h4>
<div class="paragraph">
<p>尽管类路径扫描非常快，但可以通过在编译时创建候选静态列表来提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用此机制。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您现有的<code>@ComponentScan</code>要么<code><context:component-scan</code>指令必须保持原样，以请求上下文扫描某些软件包中的候选对象。当。。。的时候<code>ApplicationContext</code>检测到这样的索引，它会自动使用它而不是扫描类路径。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要生成索引，请向每个包含组件的模块添加附加依赖关系，这些组件是组件扫描指令的目标。以下示例显示了如何使用Maven进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
        &lt;version&gt;5.2.1.RELEASE&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.5及更早版本，相关性应在<code>compileOnly</code>配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compileOnly "org.springframework:spring-context-indexer:5.2.1.RELEASE"
}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>在Gradle 4.6及更高版本中，相关性应在<code>annotationProcessor</code>配置，如以下示例所示：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:{spring-version}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该过程会产生一个<code>META-INF/spring.components</code> jar文件中包含的文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在IDE中使用此模式时， <code>spring-context-indexer</code>必须注册为注释处理器，以确保在更新候选组件时索引是最新的。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在以下情况下，索引会自动启用： <code>META-INF/spring.components</code>在类路径上找到。如果索引对于某些库（或用例）部分可用，但无法为整个应用程序构建，则可以通过设置<code>spring.index.ignore</code>至<code>true</code> ，作为系统属性或<code>spring.properties</code>文件位于类路径的根目录。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-standard-annotations"><a class="anchor" href="#beans-standard-annotations"></a> 1.11。使用JSR 330标准注释</h3>
<div class="paragraph">
<p>从Spring 3.0开始，Spring提供对JSR-330标准注释（依赖注入）的支持。这些注释的扫描方式与Spring注释的扫描方式相同。要使用它们，您需要在类路径中有相关的jar。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您使用Maven， <code>javax.inject</code>标准Maven存储库（ <a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/">https://repo1.maven.org/maven2/javax/inject/javax.inject/1/</a> ）中提供了工件。您可以将以下依赖项添加到文件pom.xml中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="beans-inject-named"><a class="anchor" href="#beans-inject-named"></a> 1.11.1。依赖注入<code>@Inject</code>和<code>@Named</code></h4>
<div class="paragraph">
<p>代替<code>@Autowired</code> ， 您可以使用<code>@javax.inject.Inject</code>如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.inject.Inject

class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder


    fun listMovies() {
        movieFinder.findMovies(...)
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与<code>@Autowired</code> ， 您可以使用<code>@Inject</code>在字段级别，方法级别和构造函数参数级别。此外，您可以将注射点声明为<code>Provider</code> ，允许按需访问范围较小的bean，或者通过以下方式懒惰访问其他bean： <code>Provider.get()</code>呼叫。以下示例提供了先前示例的变体：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider&lt;MovieFinder&gt; movieFinder;

    @Inject
    public void setMovieFinder(Provider&lt;MovieFinder&gt; movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.inject.Inject

class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder


    fun listMovies() {
        movieFinder.findMovies(...)
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想为应注入的依赖项使用限定名称，则应使用<code>@Named</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.inject.Inject
import javax.inject.Named

class SimpleMovieLister {

    private lateinit var movieFinder: MovieFinder

    @Inject
    fun setMovieFinder(@Named("main") movieFinder: MovieFinder) {
        this.movieFinder = movieFinder
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与<code>@Autowired</code> ， <code>@Inject</code>也可以与<code>java.util.Optional</code>要么<code>@Nullable</code> 。这在这里更适用，因为<code>@Inject</code>没有一个<code>required</code>属性。下面的示例展示了如何使用<code>@Inject</code>和<code>@Nullable</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    @Inject
    var movieFinder: MovieFinder? = null
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-named"><a class="anchor" href="#beans-named"></a> 1.11.2。 <code>@Named</code>和<code>@ManagedBean</code> ：等价于<code>@Component</code>注解</h4>
<div class="paragraph">
<p>代替<code>@Component</code> ， 您可以使用<code>@javax.inject.Named</code>要么<code>javax.annotation.ManagedBean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.inject.Inject;
import javax.inject.Named;

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.inject.Inject
import javax.inject.Named

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用非常普遍<code>@Component</code>而不指定组件名称。
<code>@Named</code>可以类似的方式使用，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.inject.Inject
import javax.inject.Named

@Named
class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用时<code>@Named</code>要么<code>@ManagedBean</code> ，您可以使用与使用Spring注释完全相同的方式来使用组件扫描，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["org.example"])
class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与之相反<code>@Component</code> JSR-330 <code>@Named</code>和JSR-250 <code>ManagedBean</code>注释不可组合。您应该使用Spring的构造型模型来构建自定义组件注释。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-standard-annotations-limitations"><a class="anchor" href="#beans-standard-annotations-limitations"></a> 1.11.3。JSR-330标准注释的局限性</h4>
<div class="paragraph">
<p>当使用标准注释时，您应该知道某些重要功能不可用，如下表所示：</p>
</div>
<table id="annotations-comparison" class="tableblock frame-all grid-all spread">
<caption class="title">表6。Spring 组件模型元素与JSR-330变体</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">javax.inject。*</th>
<th class="tableblock halign-left valign-top">javax.inject限制/注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Autowired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Inject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Inject</code>没有“必填”属性。可以与Java 8一起使用<code>Optional</code>代替。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Component</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Named / @ManagedBean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330不提供可组合的模型，仅提供一种识别命名组件的方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Scope("singleton")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Singleton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330的默认范围就像Spring的<code>prototype</code> 。但是，为了使其与Spring的常规默认设置保持一致，在Spring容器中声明的JSR-330 bean是一个<code>singleton</code>默认。为了使用除<code>singleton</code> ，您应该使用Spring的<code>@Scope</code>注解。 <code>javax.inject</code>还提供了<a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a>批注。不过，此仅用于创建自己的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier / @Named</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Qualifier</code>只是用于构建自定义限定符的元注释。具体<code>String</code>限定词（如Spring的<code>@Qualifier</code>值）可以通过关联<code>javax.inject.Named</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有等效</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有等效</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有等效</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Provider</code>是Spring的直接替代品<code>ObjectFactory</code> ，只有较短的<code>get()</code>方法名称。也可以与Spring的组合使用<code>@Autowired</code>或带有未注释的构造函数和setter方法。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-java"><a class="anchor" href="#beans-java"></a> 1.12。基于Java的容器配置</h3>
<div class="paragraph">
<p>本节介绍如何在Java代码中使用注释来配置Spring容器。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-java-basic-concepts">基本概念： <code>@Bean</code>和<code>@Configuration</code></a></p>
</li>
<li>
<p><a href="#beans-java-instantiating-container">使用实例化Spring容器<code>AnnotationConfigApplicationContext</code></a></p>
</li>
<li>
<p><a href="#beans-java-bean-annotation">使用<code>@Bean</code>注解</a></p>
</li>
<li>
<p><a href="#beans-java-configuration-annotation">使用<code>@Configuration</code>注解</a></p>
</li>
<li>
<p><a href="#beans-java-composing-configuration-classes">组成基于Java的配置</a></p>
</li>
<li>
<p><a href="#beans-definition-profiles">Bean定义配置文件</a></p>
</li>
<li>
<p><a href="#beans-property-source-abstraction"><code>PropertySource</code>抽象化</a></p>
</li>
<li>
<p><a href="#beans-using-propertysource">使用<code>@PropertySource</code></a></p>
</li>
<li>
<p><a href="#beans-placeholder-resolution-in-statements">声明中的占位符解析</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beans-java-basic-concepts"><a class="anchor" href="#beans-java-basic-concepts"></a> 1.12.1。基本概念： <code>@Bean</code>和<code>@Configuration</code></h4>
<div class="paragraph">
<p>Spring的新Java配置支持中的主要构件是<code>@Configuration</code> -带注释的类和<code>@Bean</code> -带注释的方法。</p>
</div>
<div class="paragraph">
<p>的<code>@Bean</code>批注用于指示方法实例化，配置和初始化要由Spring IoC容器管理的新对象。对于那些熟悉Spring的人<code><beans/></code> XML配置<code>@Bean</code>注释与<code><bean/></code>元件。您可以使用<code>@Bean</code> Spring的方法注释方法<code>@Component</code> 。但是，它们最常与<code>@Configuration</code>豆子。</p>
</div>
<div class="paragraph">
<p>用注释课程<code>@Configuration</code>指示其主要目的是作为Bean定义的来源。此外， <code>@Configuration</code>类通过调用other来定义bean之间的依赖关系<code>@Bean</code>同一类中的方法。最简单的可能<code>@Configuration</code>该类的内容如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun myService(): MyService {
        return MyServiceImpl()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的<code>AppConfig</code>类等效于以下Spring <code><beans/></code> XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">完整的@Configuration与“精简” @Bean模式？</div>
<div class="paragraph">
<p>什么时候<code>@Bean</code>方法在不带注释的类中声明<code>@Configuration</code> ，它们被称为以“精简”模式进行处理。在Bean中声明的Bean方法<code>@Component</code>甚至在普通的旧类中也被视为“精简版”，其包含类的主要目的与<code>@Bean</code>方法是那里的一种奖励。例如，服务组件可以通过其他方式向容器公开管理视图<code>@Bean</code>每个适用的组件类上的方法。在这种情况下， <code>@Bean</code>方法是通用的工厂方法机制。</p>
</div>
<div class="paragraph">
<p>不像满<code>@Configuration</code> ，精简版<code>@Bean</code>方法不能声明Bean间的依赖关系。取而代之的是，它们在其包含组件的内部状态上进行操作，并根据需要声明的参数进行操作。这样的<code>@Bean</code>因此，该方法不应调用其他方法<code>@Bean</code>方法。实际上，每个此类方法仅是用于特定bean引用的工厂方法，而没有任何特殊的运行时语义。这样做的积极作用是，不必在运行时应用CGLIB子类，因此在类设计方面没有任何限制（也就是说，包含类可能是<code>final</code>等等）。</p>
</div>
<div class="paragraph">
<p>在常见情况下， <code>@Bean</code>方法应在内部声明<code>@Configuration</code>类，以确保始终使用“完全”模式，因此跨方法引用将重定向到容器的生命周期管理。这样可以防止相同<code>@Bean</code>通过常规Java调用意外地调用该方法，这有助于减少在“精简”模式下运行时难以跟踪的细微错误。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>@Bean</code>和<code>@Configuration</code>以下各节将对注释进行深入讨论。但是，首先，我们介绍了使用基于Java的配置来创建spring容器的各种方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-instantiating-container"><a class="anchor" href="#beans-java-instantiating-container"></a> 1.12.2。使用实例化Spring容器<code>AnnotationConfigApplicationContext</code></h4>
<div class="paragraph">
<p>以下各节介绍Spring的<code>AnnotationConfigApplicationContext</code> ，在Spring 3.0中引入。这种多功能<code>ApplicationContext</code>实现不仅能够接受<code>@Configuration</code>类作为输入但也很简单<code>@Component</code>类和带有JSR-330元数据注释的类。</p>
</div>
<div class="paragraph">
<p>什么时候<code>@Configuration</code>提供类作为输入， <code>@Configuration</code>类本身已注册为bean定义，并已全部声明<code>@Bean</code>类中的方法也被注册为bean定义。</p>
</div>
<div class="paragraph">
<p>什么时候<code>@Component</code>提供了JSR-330和JSR-330类，它们被注册为bean定义，并且假定DI元数据如<code>@Autowired</code>要么<code>@Inject</code>在必要时在这些类中使用。</p>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-constructor"><a class="anchor" href="#beans-java-instantiating-container-constructor"></a>施工简单</h5>
<div class="paragraph">
<p>实例化a时，使用Spring XML文件作为输入的方式几乎相同<code>ClassPathXmlApplicationContext</code> ， 您可以使用<code>@Configuration</code>实例化一个类时作为输入<code>AnnotationConfigApplicationContext</code> 。如下面的示例所示，这允许完全不使用XML来使用Spring容器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
    val myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面提到的， <code>AnnotationConfigApplicationContext</code>不仅仅限于与<code>@Configuration</code>类。任何<code>@Component</code>可以将JSR-330注释的类或JSR-330作为输入提供给构造函数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(MyServiceImpl::class.java, Dependency1::class.java, Dependency2::class.java)
    val myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例假定<code>MyServiceImpl</code> ， <code>Dependency1</code>和<code>Dependency2</code>使用Spring依赖项注入注释，例如<code>@Autowired</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-register"><a class="anchor" href="#beans-java-instantiating-container-register"></a>通过使用编程方式构建容器<code>register(Class<?>…​)</code></h5>
<div class="paragraph">
<p>您可以实例化一个<code>AnnotationConfigApplicationContext</code>通过使用无参数构造函数，然后使用<code>register()</code>方法。以编程方式构建<code>AnnotationConfigApplicationContext</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext()
    ctx.register(AppConfig::class.java, OtherConfig::class.java)
    ctx.register(AdditionalConfig::class.java)
    ctx.refresh()
    val myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-scan"><a class="anchor" href="#beans-java-instantiating-container-scan"></a>使用启用组件扫描<code>scan(String…​)</code></h5>
<div class="paragraph">
<p>要启用组件扫描，您可以注释您的<code>@Configuration</code>类如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan(basePackages = "com.acme") <i class="conum" data-value="1"></i><b>(1)</b>
public class AppConfig  {
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>此注释启用组件扫描。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan(basePackages = ["com.acme"]) <i class="conum" data-value="1"></i><b>(1)</b>
class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>此注释启用组件扫描。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>经验丰富的Spring用户可能熟悉Spring的等效XML声明<code>context:</code>名称空间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;context:component-scan base-package="com.acme"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>com.acme</code>扫描包裹以查找任何<code>@Component</code> -带注释的类，并且这些类在容器中注册为Spring Bean定义。 <code>AnnotationConfigApplicationContext</code>暴露<code>scan(String…​)</code>允许相同组件扫描功能的方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val ctx = AnnotationConfigApplicationContext()
    ctx.scan("com.acme")
    ctx.refresh()
    val myService = ctx.getBean&lt;MyService&gt;()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请记住<code>@Configuration</code>类带有<a href="#beans-meta-annotations">元注释</a> <code>@Component</code> ，因此它们是组件扫描的候选对象。在前面的示例中，假设<code>AppConfig</code>在<code>com.acme</code>包（或下面的任何包），在调用<code>scan()</code> 。在<code>refresh()</code> ，所有<code>@Bean</code>方法在容器中处理并注册为Bean定义。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-web"><a class="anchor" href="#beans-java-instantiating-container-web"></a>支持Web应用程序<code>AnnotationConfigWebApplicationContext</code></h5>
<div class="paragraph">
<p>一种<code>WebApplicationContext</code>的变体<code>AnnotationConfigApplicationContext</code>可用于<code>AnnotationConfigWebApplicationContext</code> 。您可以在配置Spring时使用此实现<code>ContextLoaderListener</code> Servlet侦听器，Spring MVC <code>DispatcherServlet</code>等等。下列<code>web.xml</code>片段配置了一个典型的Spring MVC Web应用程序（请注意<code>contextClass</code>上下文参数和初始化参数）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;
    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            &lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-bean-annotation"><a class="anchor" href="#beans-java-bean-annotation"></a> 1.12.3。使用<code>@Bean</code>注解</h4>
<div class="paragraph">
<p><code>@Bean</code>是方法级别的注释，是XML的直接类似物<code><bean/></code>元件。注释支持以下项提供的某些属性<code><bean/></code> ，例如：* <a href="#beans-factory-lifecycle-initializingbean">初始化方法</a> * <a href="#beans-factory-lifecycle-disposablebean">破坏方法</a> * <a href="#beans-factory-autowire">自动装配</a> * <code>name</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@Bean</code>一个中的注释<code>@Configuration</code> -带注释或<code>@Component</code> -带注释的类。</p>
</div>
<div class="sect4">
<h5 id="beans-java-declaring-a-bean"><a class="anchor" href="#beans-java-declaring-a-bean"></a>声明一个豆</h5>
<div class="paragraph">
<p>要声明Bean，您可以使用<code>@Bean</code>注解。您可以使用此方法在一个<code>ApplicationContext</code>类型指定为方法的返回值。缺省情况下，bean名称与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun transferService() = TransferServiceImpl()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置与下面的Spring XML完全等效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个声明都使一个名为<code>transferService</code>可在<code>ApplicationContext</code> ，绑定到类型的对象实例<code>TransferServiceImpl</code> ，如下图所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>transferService -&gt; com.acme.TransferServiceImpl</pre>
</div>
</div>
<div class="paragraph">
<p>您也可以声明您的<code>@Bean</code>具有接口（或基类）的方法返回类型，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun transferService(): TransferService {
        return TransferServiceImpl()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这会将高级类型预测的可见性限制为指定的接口类型（ <code>TransferService</code> ）。然后，使用完整类型（ <code>TransferServiceImpl</code> ）（仅对容器已知一次），受影响的单例bean已实例化。非惰性单例bean根据其声明顺序实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试按非声明类型进行匹配（例如<code>@Autowired TransferServiceImpl</code> ，它只能解析一次<code>transferService</code> bean已实例化）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您通过声明的服务接口始终引用您的类型，则您的<code>@Bean</code>返回类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或由其实现类型潜在引用的组件，声明可能的最具体的返回类型（至少与引用您的bean的注入点所要求的具体类型一样）更为安全。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-dependencies"><a class="anchor" href="#beans-java-dependencies"></a> Bean依赖</h5>
<div class="paragraph">
<p>一种<code>@Bean</code> -带注释的方法可以具有任意数量的参数，这些参数描述构建该bean所需的依赖关系。例如，如果我们<code>TransferService</code>需要一个<code>AccountRepository</code> ，我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun transferService(accountRepository: AccountRepository): TransferService {
        return TransferServiceImpl(accountRepository)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析机制与基于构造函数的依赖注入几乎相同。<a href="#beans-constructor-injection">有关</a>更多详细信息，请参见<a href="#beans-constructor-injection">相关部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-lifecycle-callbacks"><a class="anchor" href="#beans-java-lifecycle-callbacks"></a>接收生命周期回调</h5>
<div class="paragraph">
<p>用<code>@Bean</code>注释支持常规的生命周期回调，并且可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code> JSR-250的注释。有关更多详细信息，请参见<a href="#beans-postconstruct-and-predestroy-annotations">JSR-250注释</a> 。</p>
</div>
<div class="paragraph">
<p>还完全支持常规的Spring <a href="#beans-factory-nature">生命周期</a>回调。如果一个bean实现<code>InitializingBean</code> ， <code>DisposableBean</code> ， 要么<code>Lifecycle</code> ，它们各自的方法由容器调用。</p>
</div>
<div class="paragraph">
<p>标准套<code>*Aware</code>也完全支持接口（例如<a href="#beans-beanfactory">BeanFactoryAware</a> ， <a href="#beans-factory-aware">BeanNameAware</a> ， <a href="#context-functionality-messagesource">MessageSourceAware</a> ， <a href="#beans-factory-aware">ApplicationContextAware</a>等）。</p>
</div>
<div class="paragraph">
<p>的<code>@Bean</code>注释支持指定任意的初始化和销毁回调方法，就像Spring XML的<code>init-method</code>和<code>destroy-method</code>上的属性<code>bean</code>元素，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class BeanOne {

    public void init() {
        // initialization logic
    }
}

public class BeanTwo {

    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public BeanOne beanOne() {
        return new BeanOne();
    }

    @Bean(destroyMethod = "cleanup")
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class BeanOne {

    fun init() {
        // initialization logic
    }
}

class BeanTwo {

    fun cleanup() {
        // destruction logic
    }
}

@Configuration
class AppConfig {

    @Bean(initMethod = "init")
    fun beanOne() = BeanOne()

    @Bean(destroyMethod = "cleanup")
    fun beanTwo() = BeanTwo()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，使用公共配置的Java配置定义的bean <code>close</code>要么<code>shutdown</code>方法会自动通过销毁回调进行登记。如果你有公众<code>close</code>要么<code>shutdown</code>方法，并且您不希望在容器关闭时调用它，可以添加<code>@Bean(destroyMethod="")</code>到您的bean定义以禁用默认值<code>(inferred)</code>模式。</p>
</div>
<div class="paragraph">
<p>默认情况下，您可能要对通过JNDI获取的资源执行此操作，因为其生命周期是在应用程序外部进行管理的。特别是，请确保始终这样做<code>DataSource</code> ，这在Java EE应用程序服务器上是有问题的。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何防止针对<code>DataSource</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean(destroyMethod="")
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup("MyDS");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean(destroyMethod = "")
fun dataSource(): DataSource {
    return jndiTemplate.lookup("MyDS") as DataSource
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有<code>@Bean</code>方法，通常使用程序化的JNDI查找，方法是使用Spring的<code>JndiTemplate</code>要么<code>JndiLocatorDelegate</code>助手或直接JNDI <code>InitialContext</code>用法，但不是<code>JndiObjectFactoryBean</code>变体（这将迫使您将返回类型声明为<code>FactoryBean</code>类型而不是实际的目标类型，这使得在其他类型中很难用于交叉引用调用<code>@Bean</code>旨在参考此处提供的资源的方法）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果是<code>BeanOne</code>从上述注释的示例中，调用<code>init()</code>方法直接在构造过程中进行，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun beanOne() = BeanOne().apply {
        init()
    }

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">当您直接使用Java工作时，您可以对对象执行任何操作，而不必始终依赖于容器生命周期。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-specifying-bean-scope"><a class="anchor" href="#beans-java-specifying-bean-scope"></a>指定Bean范围</h5>
<div class="paragraph">
<p>春天包括<code>@Scope</code>批注，以便您可以指定bean的范围。</p>
</div>
<div class="sect5">
<h6 id="beans-java-available-scopes"><a class="anchor" href="#beans-java-available-scopes"></a>使用<code>@Scope</code>注解</h6>
<div class="paragraph">
<p>您可以指定使用<code>@Bean</code>注释应具有特定范围。您可以使用<a href="#beans-factory-scopes">Bean Scopes</a>部分中指定的任何标准范围。</p>
</div>
<div class="paragraph">
<p>默认范围是<code>singleton</code> ，但您可以使用<code>@Scope</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MyConfiguration {

    @Bean
    @Scope("prototype")
    public Encryptor encryptor() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class MyConfiguration {

    @Bean
    @Scope("prototype")
    fun encryptor(): Encryptor {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-scoped-proxy"><a class="anchor" href="#beans-java-scoped-proxy"></a><code>@Scope</code>和<code>scoped-proxy</code></h6>
<div class="paragraph">
<p>Spring提供了一种通过<a href="#beans-factory-scopes-other-injection">作用域代理</a>处理作用域依赖性的便捷方法。使用XML配置时，创建此类代理的最简单方法是<code><aop:scoped-proxy/></code>元件。使用以下命令在Java中配置bean <code>@Scope</code>注释与<code>proxyMode</code>属性。默认为无代理（ <code>ScopedProxyMode.NO</code> ），但您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>要么<code>ScopedProxyMode.INTERFACES</code> 。</p>
</div>
<div class="paragraph">
<p>如果您将XML参考文档（请参阅<a href="#beans-factory-scopes-other-injection">作用域代理</a> ）中的作用域代理示例移植到我们的<code>@Bean</code>使用Java，它类似于以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() {
    return new UserPreferences();
}

@Bean
public Service userService() {
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
fun userPreferences() = UserPreferences()

@Bean
fun userService(): Service {
    return SimpleUserService().apply {
        // a reference to the proxied userPreferences bean
        setUserPreferences(userPreferences()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-customizing-bean-naming"><a class="anchor" href="#beans-java-customizing-bean-naming"></a>自定义Bean命名</h5>
<div class="paragraph">
<p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。但是，可以使用<code>name</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean(name = "myThing")
    public Thing thing() {
        return new Thing();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean("myThing")
    fun thing() = Thing()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-aliasing"><a class="anchor" href="#beans-java-bean-aliasing"></a> Bean别名</h5>
<div class="paragraph">
<p>如<a href="#beans-beanname">Naming Beans中</a>所讨论的，有时希望为单个Bean提供多个名称，否则称为Bean别名。的<code>name</code>的属性<code>@Bean</code>批注为此目的接受一个String数组。以下示例显示了如何为bean设置多个别名：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean("dataSource", "subsystemA-dataSource", "subsystemB-dataSource")
    fun dataSource(): DataSource {
        // instantiate, configure and return DataSource bean...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-description"><a class="anchor" href="#beans-java-bean-description"></a>豆描述</h5>
<div class="paragraph">
<p>有时，提供有关bean的更详细的文本描述会很有帮助。当出于监视目的而暴露（可能通过JMX）bean时，这尤其有用。</p>
</div>
<div class="paragraph">
<p>要添加描述<code>@Bean</code> ，您可以使用<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    public Thing thing() {
        return new Thing();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    fun thing() = Thing()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-configuration-annotation"><a class="anchor" href="#beans-java-configuration-annotation"></a> 1.12.4。使用<code>@Configuration</code>注解</h4>
<div class="paragraph">
<p><code>@Configuration</code>是类级别的注释，指示对象是Bean定义的源。 <code>@Configuration</code>类通过公共声明bean <code>@Bean</code>带注释的方法。致电<code>@Bean</code>方法论<code>@Configuration</code>类也可以用于定义Bean间的依赖关系。请参阅<a href="#beans-java-basic-concepts">基本概念： <code>@Bean</code>和<code>@Configuration</code></a>进行一般介绍。</p>
</div>
<div class="sect4">
<h5 id="beans-java-injecting-dependencies"><a class="anchor" href="#beans-java-injecting-dependencies"></a>注入bean间的依赖关系</h5>
<div class="paragraph">
<p>当bean相互依赖时，表达这种依赖就像使一个bean方法调用另一个一样简单，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }

    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun beanOne() = BeanOne(beanTwo())

    @Bean
    fun beanTwo() = BeanTwo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>beanOne</code>收到对<code>beanTwo</code>通过构造函数注入。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这种声明bean间依赖关系的方法仅在<code>@Bean</code>方法在<code>@Configuration</code>类。您不能通过使用plain声明bean之间的依赖关系<code>@Component</code>类。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-method-injection"><a class="anchor" href="#beans-java-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>如前所述， <a href="#beans-factory-method-injection">查找方法注入</a>是一项高级功能，您应该很少使用。在单例作用域的bean依赖于原型作用域的bean的情况下，这很有用。将Java用于这种类型的配置为实现这种模式提供了自然的方法。以下示例显示如何使用查找方法注入：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">abstract class CommandManager {
    fun process(commandState: Any): Any {
        // grab a new instance of the appropriate Command interface
        val command = createCommand()
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState)
        return command.execute()
    }

    // okay... but where is the implementation of this method?
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用Java配置，您可以创建以下内容的子类： <code>CommandManager</code>哪里抽象<code>createCommand()</code>方法被覆盖以使其查找新的（原型）命令对象。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
}

@Bean
public CommandManager commandManager() {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
@Scope("prototype")
fun asyncCommand(): AsyncCommand {
    val command = AsyncCommand()
    // inject dependencies here as required
    return command
}

@Bean
fun commandManager(): CommandManager {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return object : CommandManager() {
        override fun createCommand(): Command {
            return asyncCommand()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-further-information-java-config"><a class="anchor" href="#beans-java-further-information-java-config"></a>有关基于Java的配置在内部如何工作的更多信息</h5>
<div class="paragraph">
<p>考虑以下示例，该示例显示了<code>@Bean</code>带注释的方法被调用两次：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun clientService1(): ClientService {
        return ClientServiceImpl().apply {
            clientDao = clientDao()
        }
    }

    @Bean
    fun clientService2(): ClientService {
        return ClientServiceImpl().apply {
            clientDao = clientDao()
        }
    }

    @Bean
    fun clientDao(): ClientDao {
        return ClientDaoImpl()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientDao()</code>已经被叫过一次<code>clientService1()</code>然后进入<code>clientService2()</code> 。由于此方法创建了一个新实例<code>ClientDaoImpl</code>并返回它，您通常希望有两个实例（每个服务一个）。那绝对是有问题的：在春季，实例化的bean有一个<code>singleton</code>默认范围。这就是魔术的来历：全部<code>@Configuration</code>类在启动时被子类化<code>CGLIB</code> 。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存（作用域）的bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">根据bean的范围，行为可能有所不同。我们在这里谈论单例。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring 3.2开始，不再需要将CGLIB添加到您的类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code>并直接包含在春季核心JAR中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于CGLIB在启动时会动态添加功能，因此存在一些限制。特别是，配置类不能是最终的。但是，从4.3版本开始，配置类中允许使用任何构造函数，包括使用<code>@Autowired</code>或用于默认注入的单个非默认构造函数声明。</p>
</div>
<div class="paragraph">
<p>如果您希望避免任何CGLIB施加的限制，请考虑声明您的<code>@Bean</code>非方法<code>@Configuration</code>类（例如，普通<code>@Component</code>类）。之间的跨方法调用<code>@Bean</code>然后不会拦截方法，因此您必须专门依赖那里的构造函数或方法级别的依赖项注入。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-composing-configuration-classes"><a class="anchor" href="#beans-java-composing-configuration-classes"></a> 1.12.5。组成基于Java的配置</h4>
<div class="paragraph">
<p>Spring的基于Java的配置功能使您可以编写批注，这可以降低配置的复杂性。</p>
</div>
<div class="sect4">
<h5 id="beans-java-using-import"><a class="anchor" href="#beans-java-using-import"></a>使用<code>@Import</code>注解</h5>
<div class="paragraph">
<p>就像<code><import/></code>元素用于Spring XML文件中，以帮助模块化配置， <code>@Import</code>批注允许加载<code>@Bean</code>如以下示例所示，来自另一个配置类的定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class ConfigA {

    @Bean
    fun a() = A()
}

@Configuration
@Import(ConfigA::class)
class ConfigB {

    @Bean
    fun b() = B()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，无需同时指定两者<code>ConfigA.class</code>和<code>ConfigB.class</code>实例化上下文时，仅<code>ConfigB</code>需要显式提供，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(ConfigB::class.java)

    // now both beans A and B will be available...
    val a = ctx.getBean&lt;A&gt;()
    val b = ctx.getBean&lt;B&gt;()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法简化了容器的实例化，因为只需要处理一个类，而不是需要记住大量可能的类。 <code>@Configuration</code>施工期间上课。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring Framework 4.2开始， <code>@Import</code>还支持对常规组件类的引用，类似于<code>AnnotationConfigApplicationContext.register</code>方法。如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="beans-java-injecting-imported-beans"><a class="anchor" href="#beans-java-injecting-imported-beans"></a>对进口产品的依赖<code>@Bean</code>定义</h6>
<div class="paragraph">
<p>前面的示例有效，但过于简单。在大多数实际情况下，Bean在配置类之间相互依赖。使用XML时，这不是问题，因为不涉及编译器，您可以声明<code>ref="someBean"</code>并信任Spring在容器初始化期间解决这个问题。使用时<code>@Configuration</code>类，Java编译器对配置模型施加了约束，因为对其他bean的引用必须是有效的Java语法。</p>
</div>
<div class="paragraph">
<p>幸运的是，解决这个问题很简单。正如<a href="#beans-java-dependencies">我们已经讨论过的</a> ， <code>@Bean</code>方法可以具有任意数量的描述Bean依赖项的参数。考虑以下几种更实际的情况<code>@Configuration</code>类，每个类都取决于其他类中声明的bean：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

@Configuration
class ServiceConfig {

    @Bean
    fun transferService(accountRepository: AccountRepository): TransferService {
        return TransferServiceImpl(accountRepository)
    }
}

@Configuration
class RepositoryConfig {

    @Bean
    fun accountRepository(dataSource: DataSource): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }
}

@Configuration
@Import(ServiceConfig::class, RepositoryConfig::class)
class SystemTestConfig {

    @Bean
    fun dataSource(): DataSource {
        // return new DataSource
    }
}


fun main() {
    val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
    // everything wires up across configuration classes...
    val transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(100.00, "A123", "C456")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有另一种方法可以达到相同的结果。请记住<code>@Configuration</code>类最终只是容器中的另一个bean：这意味着它们可以利用<code>@Autowired</code>和<code>@Value</code>注入和其他功能与任何其他bean相同。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保以这种方式注入的依赖项只是最简单的一种。<code>@Configuration</code>在上下文的初始化过程中很早就处理了类，并且强制以这种方式注入依赖项可能会导致意外的早期初始化。如上例所示，尽可能使用基于参数的注入。</p>
</div>
<div class="paragraph">
<p>另外，请特别注意<code>BeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>通过定义<code>@Bean</code> 。这些通常应声明为<code>static @Bean</code>方法，不触发其包含的配置类的实例化。除此以外， <code>@Autowired</code>和<code>@Value</code>不能对配置类本身进行操作，因为它太早被创建为Bean实例。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例说明如何将一个bean自动连接到另一个bean：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

@Configuration
class ServiceConfig {

    @Autowired
    lateinit var accountRepository: AccountRepository

    @Bean
    fun transferService(): TransferService {
        return TransferServiceImpl(accountRepository)
    }
}

@Configuration
class RepositoryConfig(private val dataSource: DataSource) {

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }
}

@Configuration
@Import(ServiceConfig::class, RepositoryConfig::class)
class SystemTestConfig {

    @Bean
    fun dataSource(): DataSource {
        // return new DataSource
    }
}

fun main() {
    val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
    // everything wires up across configuration classes...
    val transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(100.00, "A123", "C456")
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">构造函数注入<code>@Configuration</code>从Spring Framework 4.3开始仅支持类。另请注意，无需指定<code>@Autowired</code>如果目标bean仅定义一个构造函数。
</td>
</tr>
</tbody></table>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-injecting-imported-beans-fq"></a>完全合格的进口豆，易于浏览</div>
<div class="content">
<div class="paragraph">
<p>在上述情况下，使用<code>@Autowired</code>可以很好地工作并提供所需的模块化，但是确切地确定自动装配的bean定义的声明位置仍然有些模棱两可。例如，作为开发人员<code>ServiceConfig</code> ，您怎么确切知道<code>@Autowired AccountRepository</code>豆被宣布？它在代码中不是明确的，这可能很好。请记住， <a href="https://spring.io/tools/sts">Spring Tool Suite</a>提供了可以渲染图形的工具，这些图形显示了所有接线的方式，这可能就是您所需要的。另外，您的Java IDE可以轻松地找到所有的声明和使用<code>AccountRepository</code>输入并快速向您显示<code>@Bean</code>返回该类型的方法。</p>
</div>
<div class="paragraph">
<p>如果这种歧义是不可接受的，并且您希望从IDE中直接进行导航<code>@Configuration</code>如果要使用其他类，请考虑自动装配配置类。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // navigate 'through' the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class ServiceConfig {

    @Autowired
    private lateinit var repositoryConfig: RepositoryConfig

    @Bean
    fun transferService(): TransferService {
        // navigate 'through' the config class to the @Bean method!
        return TransferServiceImpl(repositoryConfig.accountRepository())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述情况下， <code>AccountRepository</code>定义是完全明确的。然而， <code>ServiceConfig</code>现在紧密耦合到<code>RepositoryConfig</code> 。那是权衡。通过使用基于接口或基于抽象类的连接，可以在某种程度上缓解这种紧密耦合<code>@Configuration</code>类。考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();
}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }
}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

@Configuration
class ServiceConfig {

    @Autowired
    private lateinit var repositoryConfig: RepositoryConfig

    @Bean
    fun transferService(): TransferService {
        return TransferServiceImpl(repositoryConfig.accountRepository())
    }
}

@Configuration
interface RepositoryConfig {

    @Bean
    fun accountRepository(): AccountRepository
}

@Configuration
class DefaultRepositoryConfig : RepositoryConfig {

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(...)
    }
}

@Configuration
@Import(ServiceConfig::class, DefaultRepositoryConfig::class)  // import the concrete config!
class SystemTestConfig {

    @Bean
    fun dataSource(): DataSource {
        // return DataSource
    }

}

fun main() {
    val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
    val transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(100.00, "A123", "C456")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在<code>ServiceConfig</code>相对于混凝土是松散耦合的<code>DefaultRepositoryConfig</code> ，并且内置的IDE工具仍然很有用：您可以轻松地获得<code>RepositoryConfig</code>实现。这样，导航<code>@Configuration</code>类及其依赖关系与导航基于接口的代码的通常过程没有什么不同。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要影响某些bean的启动创建顺序，请考虑将其中一些声明为<code>@Lazy</code> （用于首次访问而不是启动时创建）或<code>@DependsOn</code>某些其他Bean（确保在当前Bean之前创建了特定的其他Bean，超出了后者的直接依赖项所暗示的范围）。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-conditional"><a class="anchor" href="#beans-java-conditional"></a>有条件地包括<code>@Configuration</code>类或<code>@Bean</code>方法</h5>
<div class="paragraph">
<p>有条件地启用或禁用完整<code>@Configuration</code>阶级甚至个人<code>@Bean</code>方法，基于一些任意的系统状态。一个常见的例子是使用<code>@Profile</code>注释仅在Spring中启用了特定概要文件时才能激活Bean <code>Environment</code> （有关详细<a href="#beans-definition-profiles">信息</a> ，请参见<a href="#beans-definition-profiles">Bean定义配置文件</a> ）。</p>
</div>
<div class="paragraph">
<p>的<code>@Profile</code>注释实际上是通过使用更加灵活的注释来实现的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a> 。的<code>@Conditional</code>注释表示特定<code>org.springframework.context.annotation.Condition</code>实施前应咨询的实现<code>@Bean</code>已被注册。</p>
</div>
<div class="paragraph">
<p>的实现<code>Condition</code>界面提供了<code>matches(…​)</code>返回的方法<code>true</code>要么<code>false</code> 。例如，以下清单显示了实际的<code>Condition</code>用于的实现<code>@Profile</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // Read the @Profile annotation attributes
    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get("value")) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">override fun matches(context: ConditionContext, metadata: AnnotatedTypeMetadata): Boolean {
    // Read the @Profile annotation attributes
    val attrs = metadata.getAllAnnotationAttributes(Profile::class.java.name)
    if (attrs != null) {
        for (value in attrs["value"]!!) {
            if (context.environment.acceptsProfiles(Profiles .of(*value as Array&lt;String&gt;))) {
                return true
            }
        }
        return false
    }
    return true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a> javadoc以获得更多详细信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-combining"><a class="anchor" href="#beans-java-combining"></a>结合Java和XML配置</h5>
<div class="paragraph">
<p>春天的<code>@Configuration</code>类支持并非旨在100％完全替代Spring XML。某些工具（例如Spring XML名称空间）仍然是配置容器的理想方法。在使用XML方便或有必要的情况下，您可以选择：使用“以XML为中心”的方式实例化容器，例如， <code>ClassPathXmlApplicationContext</code> ，或使用“以Java为中心”的方式实例化它<code>AnnotationConfigApplicationContext</code>和<code>@ImportResource</code>注释以根据需要导入XML。</p>
</div>
<div class="sect5">
<h6 id="beans-java-combining-xml-centric"><a class="anchor" href="#beans-java-combining-xml-centric"></a>以XML为中心的使用<code>@Configuration</code>班级</h6>
<div class="paragraph">
<p>最好从XML引导Spring容器并包含<code>@Configuration</code>临时上课。例如，在使用Spring XML的现有大型代码库中，创建起来更容易<code>@Configuration</code>类根据需要进行分类，并将其包含在现有XML文件中。在本节的后面，我们将介绍使用<code>@Configuration</code>类处于这种“以XML为中心”的情况。</p>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-declare-as-bean"></a>宣告<code>@Configuration</code>普通春天类<code><bean/></code>元素</div>
<div class="content">
<div class="paragraph">
<p>请记住<code>@Configuration</code>类最终是容器中的bean定义。在本系列示例中，我们创建了一个<code>@Configuration</code>类命名<code>AppConfig</code>并包含在其中<code>system-test-config.xml</code>作为一个<code><bean/></code>定义。因为<code><context:annotation-config/></code>开启后，容器识别出<code>@Configuration</code>注释并处理<code>@Bean</code>在中声明的方法<code>AppConfig</code>正确地。</p>
</div>
<div class="paragraph">
<p>以下示例显示了Java中的普通配置类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Autowired
    private lateinit var dataSource: DataSource

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }

    @Bean
    fun transferService() = TransferService(accountRepository())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了示例的一部分<code>system-test-config.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;
    &lt;context:annotation-config/&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;

    &lt;bean class="com.acme.AppConfig"/&gt;

    &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了一种可能<code>jdbc.properties</code>文件：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val ctx = ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml")
    val transferService = ctx.getBean&lt;TransferService&gt;()
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在<code>system-test-config.xml</code>文件， <code>AppConfig</code><code><bean/></code>没有声明<code>id</code>元件。尽管这样做是可以接受的，但由于没有其他bean引用过它，因此这是不必要的，并且不太可能通过名称从容器中显式获取。同样， <code>DataSource</code> bean只能按类型自动接线，因此，显式bean <code>id</code>并非严格要求。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-component-scan"></a>使用<context:component-scan></context:component-scan>捡起<code>@Configuration</code>类</div>
<div class="content">
<div class="paragraph">
<p>因为<code>@Configuration</code>带有元注释<code>@Component</code> ， <code>@Configuration</code> -带注释的类自动成为组件扫描的候选项。使用与上一示例相同的场景，我们可以重新定义<code>system-test-config.xml</code>利用组件扫描。请注意，在这种情况下，我们无需显式声明<code><context:annotation-config/></code> ，因为<code><context:component-scan/></code>启用相同的功能。</p>
</div>
<div class="paragraph">
<p>以下示例显示了修改后的<code>system-test-config.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;!-- picks up and registers AppConfig as a bean definition --&gt;
    &lt;context:component-scan base-package="com.acme"/&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;

    &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-combining-java-centric"><a class="anchor" href="#beans-java-combining-java-centric"></a><code>@Configuration</code>以类为中心的XML与<code>@ImportResource</code></h6>
<div class="paragraph">
<p>在应用中<code>@Configuration</code>类是配置容器的主要机制，仍然有可能至少需要使用一些XML。在这些情况下，您可以使用<code>@ImportResource</code>并仅定义所需的XML。这样做实现了一种“以Java为中心”的方法来配置容器，并将XML保持在最低限度。以下示例（包括配置类，定义Bean的XML文件，属性文件和<code>main</code>类）展示了如何使用<code>@ImportResource</code>注释以实现按需使用XML的“以Java为中心”的配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
class AppConfig {

    @Value("\${jdbc.url}")
    private lateinit var url: String

    @Value("\${jdbc.username}")
    private lateinit var username: String

    @Value("\${jdbc.password}")
    private lateinit var password: String

    @Bean
    fun dataSource(): DataSource {
        return DriverManagerDataSource(url, username, password)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">properties-config.xml
&lt;beans&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
    val transferService = ctx.getBean&lt;TransferService&gt;()
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-environment"><a class="anchor" href="#beans-environment"></a> 1.13。环境抽象</h3>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/env/Environment.html"><code>Environment</code></a>接口是集成在容器中的抽象，它对应用程序环境的两个关键方面进行建模： <a href="#beans-definition-profiles">配置文件</a>和<a href="#beans-property-source-abstraction">属性</a> 。</p>
</div>
<div class="paragraph">
<p>概要文件是仅在给定概要文件处于活动状态时才向容器注册的Bean定义的命名逻辑组。可以将Bean分配给概要文件，无论是以XML定义还是带有注释。的作用<code>Environment</code>与配置文件相关的对象是确定哪些配置文件（如果有）当前处于活动状态，以及哪些配置文件（如果有）在默认情况下应处于活动状态。</p>
</div>
<div class="paragraph">
<p>属性在几乎所有应用程序中都起着重要作用，并且可能源自各种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，即席<code>Properties</code>对象<code>Map</code>对象等等。的作用<code>Environment</code>与属性相关的对象是为用户提供方便的服务界面，用于配置属性源并从中解析属性。</p>
</div>
<div class="sect3">
<h4 id="beans-definition-profiles"><a class="anchor" href="#beans-definition-profiles"></a> 1.13.1。Bean定义配置文件</h4>
<div class="paragraph">
<p>Bean定义概要文件在核心容器中提供了一种机制，该机制允许在不同环境中注册不同的Bean。“环境”一词对不同的用户可能具有不同的含义，并且此功能可以帮助解决许多用例，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理开发中的内存中数据源，而不是在进行QA或生产时从JNDI查找相同的数据源。</p>
</li>
<li>
<p>仅在将应用程序部署到性能环境中时注册监视基础结构。</p>
</li>
<li>
<p>为客户A和客户B部署注册bean的自定义实现。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑在实际应用中第一个用例需要<code>DataSource</code> 。在测试环境中，配置可能类似于以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("my-schema.sql")
            .addScript("my-test-data.sql")
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，假设该应用程序的数据源已在生产应用程序服务器的JNDI目录中注册，请考虑如何将该应用程序部署到QA或生产环境中。我们的<code>dataSource</code> bean现在看起来像下面的清单：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean(destroyMethod="")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean(destroyMethod = "")
fun dataSource(): DataSource {
    val ctx = InitialContext()
    return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是如何根据当前环境在使用这两种变体之间进行切换。随着时间的流逝，Spring用户已经设计出许多方法来完成此任务，通常依靠系统环境变量和XML的组合<code><import/></code>陈述包含<code>${placeholder}</code>根据环境变量的值解析为正确的配置文件路径的令牌。Bean定义配置文件是一项核心容器功能，可提供此问题的解决方案。</p>
</div>
<div class="paragraph">
<p>如果我们概括前面特定于环境的Bean定义示例中所示的用例，则最终需要在某些上下文中而不是在其他上下文中注册某些Bean定义。您可能会说您要在情况A中注册一个特定的bean定义配置文件，在情况B中注册一个不同的配置文件。我们首先更新配置以反映这种需求。</p>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-java"><a class="anchor" href="#beans-definition-profiles-java"></a>使用<code>@Profile</code></h5>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a>注释可让您指示一个或多个指定配置文件处于活动状态时有资格注册的组件。使用前面的示例，我们可以重写<code>dataSource</code>配置如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("development")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@Profile("development")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如前所述， <code>@Bean</code>方法，您通常可以选择使用程序化JNDI查找，方法是使用Spring的<code>JndiTemplate</code> / <code>JndiLocatorDelegate</code>助手或直JNDI <code>InitialContext</code>用法如前所示，但没有<code>JndiObjectFactoryBean</code>变体，这将迫使您将返回类型声明为<code>FactoryBean</code>类型。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置文件字符串可以包含一个简单的配置文件名称（例如， <code>production</code> ）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑（例如， <code>production & us-east</code> ）。概要文件表达式中支持以下运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>!</code> ：配置文件的逻辑“不”</p>
</li>
<li>
<p><code>&</code> ：配置文件的逻辑“与”</p>
</li>
<li>
<p><code>|</code> ：配置文件的逻辑“或”</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您不能混用<code>&</code>和<code>|</code>不使用括号的运算符。例如， <code>production & us-east | eu-central</code>不是有效的表达式。它必须表示为<code>production & (us-east | eu-central)</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<code>@Profile</code>作为<a href="#beans-meta-annotations">元注释</a> ，目的是创建自定义的组合注释。以下示例定义了一个自定义<code>@Production</code>可以用作替代的注释<code>@Profile("production")</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile("production")
public @interface Production {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Profile("production")
annotation class Production</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果一个<code>@Configuration</code>班级标有<code>@Profile</code> ， 全部<code>@Bean</code>方法和<code>@Import</code>除非一个或多个指定的配置文件处于活动状态，否则将忽略与该类关联的注释。如果一个<code>@Component</code>要么<code>@Configuration</code>班级标有<code>@Profile({"p1", "p2"})</code> ，除非激活了配置文件“ p1”或“ p2”，否则该类不会注册或处理。如果给定的配置文件以NOT运算符作为前缀（ <code>!</code> ），则只有在配置文件未激活时才注册带注释的元素。例如，给定<code>@Profile({"p1", "!p2"})</code> ，如果配置文件“ p1”处于活动状态或配置文件“ p2”未处于活动状态，则会进行注册。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>@Profile</code>也可以在方法级别声明为仅包含配置类的一个特定Bean（例如，特定Bean的替代变体），如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean("dataSource")
    @Profile("development") <i class="conum" data-value="1"></i><b>(1)</b>
    public DataSource standaloneDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }

    @Bean("dataSource")
    @Profile("production") <i class="conum" data-value="2"></i><b>(2)</b>
    public DataSource jndiDataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>standaloneDataSource</code>该方法仅在<code>development</code>轮廓。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>jndiDataSource</code>该方法仅在<code>production</code>轮廓。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean("dataSource")
    @Profile("development") <i class="conum" data-value="1"></i><b>(1)</b>
    fun standaloneDataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }

    @Bean("dataSource")
    @Profile("production") <i class="conum" data-value="2"></i><b>(2)</b>
    fun jndiDataSource() =
        InitialContext().lookup("java:comp/env/jdbc/datasource") as DataSource
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>standaloneDataSource</code>该方法仅在<code>development</code>轮廓。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>jndiDataSource</code>该方法仅在<code>production</code>轮廓。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>用<code>@Profile</code>上<code>@Bean</code>方法，可能会出现特殊情况：在过载的情况下<code>@Bean</code>具有相同Java方法名称的方法（类似于构造函数重载）， <code>@Profile</code>条件必须在所有重载方法上一致声明。如果条件不一致，则仅重载方法中第一个声明的条件很重要。因此， <code>@Profile</code>不能用于选择具有特定自变量签名的重载方法。在创建时，相同bean的所有工厂方法之间的解析都遵循Spring的构造函数解析算法。</p>
</div>
<div class="paragraph">
<p>如果要定义具有不同概要文件条件的备用Bean，请使用不同的Java方法名称来指向相同的Bean名称，方法是使用<code>@Bean</code>名称属性，如上例所示。如果参数签名都相同（例如，所有变体都具有no-arg工厂方法），则这是首先在有效Java类中表示这种排列的唯一方法（因为只能有一个特定名称和参数签名的方法）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-xml"><a class="anchor" href="#beans-definition-profiles-xml"></a> XML Bean定义配置文件</h5>
<div class="paragraph">
<p>XML对应的是<code>profile</code>的属性<code><beans></code>元件。我们前面的示例配置可以用两个XML文件重写，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans profile="development"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xsi:schemaLocation="..."&gt;

    &lt;jdbc:embedded-database id="dataSource"&gt;
        &lt;jdbc:script location="classpath:com/bank/config/sql/schema.sql"/&gt;
        &lt;jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/&gt;
    &lt;/jdbc:embedded-database&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans profile="production"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以避免拆分和嵌套<code><beans/></code>如以下示例所示，同一文件中的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile="development"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script location="classpath:com/bank/config/sql/schema.sql"/&gt;
            &lt;jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile="production"&gt;
        &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>spring-bean.xsd</code>已被限制为仅允许这些元素作为文件中的最后一个元素。这应该有助于提供灵活性，而不会引起XML文件混乱。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>XML对应项不支持前面描述的配置文件表达式。但是，可以通过使用<code>!</code>操作员。也可以通过嵌套配置文件来应用逻辑“和”，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile="production"&gt;
        &lt;beans profile="us-east"&gt;
            &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
        &lt;/beans&gt;
    &lt;/beans&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>dataSource</code>如果两个<code>production</code>和<code>us-east</code>配置文件处于活动状态。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-enable"><a class="anchor" href="#beans-definition-profiles-enable"></a>激活个人资料</h5>
<div class="paragraph">
<p>现在我们已经更新了配置，我们仍然需要指示Spring哪个配置文件处于活动状态。如果我们现在启动示例应用程序，将会看到一个<code>NoSuchBeanDefinitionException</code>抛出，因为容器找不到名为Spring的bean <code>dataSource</code> 。</p>
</div>
<div class="paragraph">
<p>可以通过多种方式来激活配置文件，但是最直接的方法是针对<code>Environment</code>可通过<code>ApplicationContext</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("development");
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = AnnotationConfigApplicationContext().apply {
    environment.setActiveProfiles("development")
    register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java)
    refresh()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，您还可以通过以下方式声明性地激活配置文件<code>spring.profiles.active</code>属性，可以通过系统环境变量，JVM系统属性， <code>web.xml</code> ，甚至可以作为JNDI中的条目（请参见<a href="#beans-property-source-abstraction"><code>PropertySource</code>抽象</a> ）。在集成测试中，可以使用<code>@ActiveProfiles</code>中的注释<code>spring-test</code>模块（请参阅<a href="testing.html#testcontext-ctx-management-env-profiles">带有环境配置文件的上下文配置</a> ）。</p>
</div>
<div class="paragraph">
<p>请注意，配置文件不是“非此即彼”的命题。您可以一次激活多个配置文件。您可以通过编程方式为<code>setActiveProfiles()</code>方法，它接受<code>String…​</code>可变参数。以下示例激活多个配置文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ctx.getEnvironment().setActiveProfiles("profile1", "profile2");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">ctx.getEnvironment().setActiveProfiles("profile1", "profile2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>声明性地， <code>spring.profiles.active</code>可以接受以逗号分隔的配置文件名称列表，如以下示例所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    -Dspring.profiles.active="profile1,profile2"</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-default"><a class="anchor" href="#beans-definition-profiles-default"></a>默认配置文件</h5>
<div class="paragraph">
<p>默认配置文件表示默认情况下启用的配置文件。考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有配置文件处于活动状态，则<code>dataSource</code>被建造。您可以看到这是为一个或多个bean提供默认定义的一种方法。如果启用了任何配置文件，则默认配置文件将不适用。</p>
</div>
<div class="paragraph">
<p>您可以使用以下方法更改默认配置文件的名称<code>setDefaultProfiles()</code>在<code>Environment</code>或声明性地，通过使用<code>spring.profiles.default</code>属性。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-property-source-abstraction"><a class="anchor" href="#beans-property-source-abstraction"></a> 1.13.2。 <code>PropertySource</code> 抽象化</h4>
<div class="paragraph">
<p>春天的<code>Environment</code>抽象提供了对属性源可配置层次结构的搜索操作。考虑以下清单：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty("my-property");
System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = GenericApplicationContext()
val env = ctx.environment
val containsMyProperty = env.containsProperty("my-property")
println("Does my environment contain the 'my-property' property? $containsMyProperty")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的代码段中，我们看到了一种高级方式来询问Spring是否<code>my-property</code>属性是为当前环境定义的。为了回答这个问题， <code>Environment</code>对象对一组进行搜索<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a>对象。一种<code>PropertySource</code>是对任何键值对来源的简单抽象，而Spring的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a>配置了两个PropertySource对象-一个代表JVM系统属性集（ <code>System.getProperties()</code> ），代表系统环境变量集（ <code>System.getenv()</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这些默认属性源存在于<code>StandardEnvironment</code> ，用于独立应用程序。<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a>用其他默认属性源（包括servlet配置和servlet上下文参数）填充。它可以选择启用<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a> 。有关详细信息，请参见javadoc。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>具体来说，当您使用<code>StandardEnvironment</code> ，致电<code>env.containsProperty("my-property")</code>如果a返回true <code>my-property</code>系统属性或<code>my-property</code>运行时存在环境变量。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>执行的搜索是分层的。默认情况下，系统属性优先于环境变量。所以，如果<code>my-property</code>呼叫期间，两个地方都同时设定了属性<code>env.getProperty("my-property")</code> ，系统属性值“ wins”并返回。请注意，属性值不会合并，而是会被前面的条目完全覆盖。</p>
</div>
<div class="paragraph">
<p>对于一个普通的<code>StandardServletEnvironment</code> ，完整的层次结构如下，优先级最高的条目位于顶部：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ServletConfig参数（如果适用，例如<code>DispatcherServlet</code>上下文）</p>
</li>
<li>
<p>ServletContext参数（web.xml上下文参数条目）</p>
</li>
<li>
<p>JNDI环境变量（ <code>java:comp/env/</code>条目）</p>
</li>
<li>
<p>JVM系统属性（ <code>-D</code>命令行参数）</p>
</li>
<li>
<p>JVM系统环境（操作系统环境变量）</p>
</li>
</ol>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最重要的是，整个机制是可配置的。也许您有一个要集成到此搜索中的自定义属性源。为此，请实现并实例化自己的实例<code>PropertySource</code>并将其添加到<code>PropertySources</code>目前<code>Environment</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = GenericApplicationContext()
val sources = ctx.environment.propertySources
sources.addFirst(MyPropertySource())</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的代码中， <code>MyPropertySource</code>已在搜索中以最高优先级添加。如果包含<code>my-property</code>属性，该属性被检测并返回，有利于任何<code>my-property</code>其他财产<code>PropertySource</code> 。的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a> API公开了许多方法，可以对属性源集进行精确操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-using-propertysource"><a class="anchor" href="#beans-using-propertysource"></a> 1.13.3。使用<code>@PropertySource</code></h4>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>注释提供了一种方便的声明性机制来添加<code>PropertySource</code>到春天的<code>Environment</code> 。</p>
</div>
<div class="paragraph">
<p>给定一个名为<code>app.properties</code>包含键值对<code>testbean.name=myTestBean</code> ， 下列<code>@Configuration</code>课堂使用<code>@PropertySource</code>以这样的方式<code>testBean.getName()</code>退货<code>myTestBean</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@PropertySource("classpath:/com/myco/app.properties")
class AppConfig {

    @Autowired
    private lateinit var env: Environment

    @Bean
    fun testBean() = TestBean().apply {
        name = env.getProperty("testbean.name")!!
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何<code>${…​}</code>占位符出现在<code>@PropertySource</code>根据已针对环境注册的一组属性源来解析资源位置，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@PropertySource("classpath:/com/\${my.placeholder:default/path}/app.properties")
class AppConfig {

    @Autowired
    private lateinit var env: Environment

    @Bean
    fun testBean() = TestBean().apply {
        name = env.getProperty("testbean.name")!!
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假如说<code>my.placeholder</code>如果已注册的属性源之一（例如，系统属性或环境变量）中存在“占位符”，则占位符将解析为相应的值。如果没有，那么<code>default/path</code>用作默认值。如果未指定默认值且无法解析属性，则<code>IllegalArgumentException</code>被抛出。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>@PropertySource</code>根据Java 8约定，注解是可重复的。但是，所有这些<code>@PropertySource</code>批注需要在同一级别上声明，可以直接在配置类上声明，也可以在同一自定义批注中声明为元批注。不建议将直接注释和元注释混合使用，因为直接注释会有效地覆盖元注释。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="beans-placeholder-resolution-in-statements"><a class="anchor" href="#beans-placeholder-resolution-in-statements"></a> 1.13.4。声明中的占位符解析</h4>
<div class="paragraph">
<p>从历史上看，元素中占位符的值只能根据JVM系统属性或环境变量来解析。这已不再是这种情况。因为<code>Environment</code>抽象集成在整个容器中，很容易通过它路由占位符的解析。这意味着您可以按照自己喜欢的任何方式配置解析过程。您可以更改搜索系统属性和环境变量的优先级，也可以完全删除它们。您还可以根据需要将自己的属性源添加到混合中。</p>
</div>
<div class="paragraph">
<p>具体而言，无论<code>customer</code>属性已定义，只要它在<code>Environment</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;import resource="com/bank/service/${customer}-config.xml"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-load-time-weaver"><a class="anchor" href="#context-load-time-weaver"></a> 1.14。注册一个<code>LoadTimeWeaver</code></h3>
<div class="paragraph">
<p>的<code>LoadTimeWeaver</code>当类加载到Java虚拟机（JVM）中时，Spring使用它来动态转换类。</p>
</div>
<div class="paragraph">
<p>要启用加载时编织，您可以添加<code>@EnableLoadTimeWeaving</code>给你的一个<code>@Configuration</code>类，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableLoadTimeWeaving
class AppConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，对于XML配置，您可以使用<code>context:load-time-weaver</code>元件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦为<code>ApplicationContext</code> ，其中的任何bean <code>ApplicationContext</code>可能实现<code>LoadTimeWeaverAware</code> ，从而收到对加载时织布器实例的引用。与<a href="data-access.html#orm-jpa">Spring的JPA支持</a>结合使用时，该功能特别有用，因为对于JPA类转换，可能需要加载时间编织。咨询<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html"><code>LocalContainerEntityManagerFactoryBean</code></a> javadoc以获得更多详细信息。有关AspectJ加载时编织的更多信息，请参见<a href="#aop-aj-ltw">Spring Framework中的AspectJ加载时编织</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="context-introduction"><a class="anchor" href="#context-introduction"></a> 1.15。的其他功能<code>ApplicationContext</code></h3>
<div class="paragraph">
<p>如<a href="#beans">本章简介</a>中所述， <code>org.springframework.beans.factory</code>软件包提供了用于管理和操作Bean的基本功能，包括以编程方式。的<code>org.springframework.context</code>包中添加了<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>接口，扩展了<code>BeanFactory</code>接口，除了扩展其他接口以提供更多面向应用程序框架的样式的附加功能外。许多人使用<code>ApplicationContext</code>以完全声明的方式，甚至没有以编程方式创建它，而是依赖于诸如<code>ContextLoader</code>自动实例化一个<code>ApplicationContext</code>作为Java EE Web应用程序正常启动过程的一部分。</p>
</div>
<div class="paragraph">
<p>加强<code>BeanFactory</code>为了以更面向框架的方式提供功能，上下文包还提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过以下方式访问i18n风格的邮件<code>MessageSource</code>接口。</p>
</li>
<li>
<p>通过以下方式访问资源（例如URL和文件） <code>ResourceLoader</code>接口。</p>
</li>
<li>
<p>事件发布，即实现<code>ApplicationListener</code>界面，通过使用<code>ApplicationEventPublisher</code>接口。</p>
</li>
<li>
<p>加载多个（分层）上下文，使每个上下文都可以通过<code>HierarchicalBeanFactory</code>接口。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="context-functionality-messagesource"><a class="anchor" href="#context-functionality-messagesource"></a> 1.15.1。国际化使用<code>MessageSource</code></h4>
<div class="paragraph">
<p>的<code>ApplicationContext</code>接口扩展了称为<code>MessageSource</code>因此，它提供了国际化（“ i18n”）功能。Spring还提供了<code>HierarchicalMessageSource</code>接口，可以分层解析消息。这些接口一起提供了Spring影响消息解析的基础。这些接口上定义的方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getMessage(String code, Object[] args, String default, Locale loc)</code> ：用于从中检索消息的基本方法<code>MessageSource</code> 。如果找不到针对指定语言环境的消息，则使用默认消息。传入的所有参数都将成为替换值，使用<code>MessageFormat</code>标准库提供的功能。</p>
</li>
<li>
<p><code>String getMessage(String code, Object[] args, Locale loc)</code> ：与以前的方法基本相同，但有一个区别：不能指定默认消息。如果找不到该消息，则<code>NoSuchMessageException</code>被抛出。</p>
</li>
<li>
<p><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code> ：上述方法中使用的所有属性也都包装在一个名为的类中<code>MessageSourceResolvable</code> ，您可以使用此方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当一个<code>ApplicationContext</code>已加载，它会自动搜索<code>MessageSource</code>在上下文中定义的bean。Bean必须具有名称<code>messageSource</code> 。如果找到了这样的bean，则对前面方法的所有调用都将委派给消息源。如果找不到消息源，则<code>ApplicationContext</code>尝试查找包含相同名称的bean的父对象。如果是这样，它将使用该bean作为<code>MessageSource</code> 。如果<code>ApplicationContext</code>找不到任何消息来源，一个空白<code>DelegatingMessageSource</code>实例化以便能够接受对上面定义的方法的调用。</p>
</div>
<div class="paragraph">
<p>春季提供两个<code>MessageSource</code>实现， <code>ResourceBundleMessageSource</code>和<code>StaticMessageSource</code> 。两者都实现<code>HierarchicalMessageSource</code>为了做嵌套消息传递。的<code>StaticMessageSource</code>很少使用，但是提供了将消息添加到源中的编程方式。以下示例显示<code>ResourceBundleMessageSource</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="messageSource"
            class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例假定您有三个名为<code>format</code> ， <code>exceptions</code>和<code>windows</code>在您的类路径中定义。解析消息的任何请求均通过JDK标准的解析消息方式来处理，方法是通过<code>ResourceBundle</code>对象。就本示例而言，假定上述两个资源束文件的内容如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    # in format.properties
    message=Alligators rock!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    # in exceptions.properties
    argument.required=The {0} argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例显示了执行<code>MessageSource</code>功能。记住所有<code>ApplicationContext</code>实现也是<code>MessageSource</code>实现，因此可以转换为<code>MessageSource</code>接口。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
    System.out.println(message);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val resources = ClassPathXmlApplicationContext("beans.xml")
    val message = resources.getMessage("message", null, "Default", Locale.ENGLISH)
    println(message)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上程序的结果输出如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Alligators rock!</pre>
</div>
</div>
<div class="paragraph">
<p>总而言之， <code>MessageSource</code>在名为的文件中定义<code>beans.xml</code> ，它存在于类路径的根目录下。的<code>messageSource</code> bean定义通过它来引用许多资源束<code>basenames</code>属性。列表中传递给<code>basenames</code>属性以文件形式存在于类路径的根目录下，并称为<code>format.properties</code> ， <code>exceptions.properties</code>和<code>windows.properties</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>下一个示例显示了传递给消息查找的参数。这些参数被转换为<code>String</code>对象并插入到查找消息中的占位符中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;!-- this MessageSource is being used in a web application --&gt;
    &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basename" value="exceptions"/&gt;
    &lt;/bean&gt;

    &lt;!-- lets inject the above MessageSource into this POJO --&gt;
    &lt;bean id="example" class="com.something.Example"&gt;
        &lt;property name="messages" ref="messageSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", Locale.ENGLISH);
        System.out.println(message);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">    class Example {

    lateinit var messages: MessageSource

    fun execute() {
        val message = messages.getMessage("argument.required",
                arrayOf("userDao"), "Required", Locale.ENGLISH)
        println(message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用的结果输出<code>execute()</code>方法如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The userDao argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>关于国际化（“ i18n”），Spring的各种<code>MessageSource</code>实现遵循与标准JDK相同的语言环境解析和后备规则<code>ResourceBundle</code> 。简而言之，继续示例<code>messageSource</code>如果您想针对英国人（ <code>en-GB</code> ）的语言环境，您将创建名为<code>format_en_GB.properties</code> ， <code>exceptions_en_GB.properties</code>和<code>windows_en_GB.properties</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>通常，语言环境解析由应用程序的周围环境管理。在以下示例中，手动指定了针对其解析（英国）消息的语言环境：</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in exceptions_en_GB.properties
argument.required=Ebagum lad, the {0} argument is required, I say, required.</pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val resources = ClassPathXmlApplicationContext("beans.xml")
    val message = resources.getMessage("argument.required",
            arrayOf("userDao"), "Required", Locale.UK)
    println(message)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行上述程序的结果输出如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ebagum lad, the 'userDao' argument is required, I say, required.</pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>MessageSourceAware</code>接口以获取对任何对象的引用<code>MessageSource</code>已经定义。在<code>ApplicationContext</code>实现了<code>MessageSourceAware</code>接口注入了应用程序上下文的<code>MessageSource</code>创建和配置bean时。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">作为替代<code>ResourceBundleMessageSource</code> ，Spring提供了一个<code>ReloadableResourceBundleMessageSource</code>类。此变体支持相同的捆绑文件格式，但比基于标准JDK的灵活性更高<code>ResourceBundleMessageSource</code>实施。特别是，它允许从任何Spring资源位置（不仅从类路径）读取文件，并支持热重装捆绑属性文件（同时在它们之间进行有效缓存）。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html"><code>ReloadableResourceBundleMessageSource</code></a>有关详细信息，请参见javadoc。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-events"><a class="anchor" href="#context-functionality-events"></a> 1.15.2。标准和自定义事件</h4>
<div class="paragraph">
<p>事件处理<code>ApplicationContext</code>通过提供<code>ApplicationEvent</code>类和<code>ApplicationListener</code>接口。如果一个实现了<code>ApplicationListener</code>每次将接口部署到上下文中时<code>ApplicationEvent</code>被发布到<code>ApplicationContext</code> ，该bean被通知。本质上，这是标准的Observer设计模式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring 4.2开始，事件基础架构得到了显着改进，并提供了<a href="#context-functionality-events-annotation">基于注释的模型</a>以及发布任意事件的能力（即，对象不一定从<code>ApplicationEvent</code> ）。发布此类对象后，我们会为您包装一个事件。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下表描述了Spring提供的标准事件：</p>
</div>
<table id="beans-ctx-events-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表7。内置事件</caption>
<colgroup>
<col style="width:30%">
<col style="width:70%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">事件</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextRefreshedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发表时<code>ApplicationContext</code>初始化或刷新（例如，通过使用<code>refresh()</code>上的方法<code>ConfigurableApplicationContext</code>接口）。在这里，“已初始化”是指所有Bean均已加载，检测并激活了后处理器Bean，单例已预先实例化，并且<code>ApplicationContext</code>准备使用对象。只要尚未关闭上下文，就可以多次触发刷新，前提是选择的是<code>ApplicationContext</code>实际上支持这种“热”刷新。例如， <code>XmlWebApplicationContext</code>支持热刷新，但是<code>GenericApplicationContext</code>才不是。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStartedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发表时<code>ApplicationContext</code>通过使用<code>start()</code>上的方法<code>ConfigurableApplicationContext</code>接口。在这里，“开始”表示所有<code>Lifecycle</code> bean收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动Bean，但也可以用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStoppedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发表时<code>ApplicationContext</code>通过使用停止<code>stop()</code>上的方法<code>ConfigurableApplicationContext</code>接口。在这里，“停止”表示所有<code>Lifecycle</code> bean收到一个明确的停止信号。停止的上下文可以通过重新启动<code>start()</code>呼叫。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextClosedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发表时<code>ApplicationContext</code>通过使用关闭<code>close()</code>上的方法<code>ConfigurableApplicationContext</code>接口或通过JVM关闭挂钩。在这里，“封闭”意味着所有单例豆将被销毁。关闭上下文后，它将达到使用寿命，无法刷新或重新启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个特定于Web的事件，告诉所有Bean HTTP请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用Spring的Web应用程序<code>DispatcherServlet</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletRequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的子类<code>RequestHandledEvent</code>添加特定于Servlet的上下文信息。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您还可以创建和发布自己的自定义事件。以下示例显示了一个扩展Spring的简单类。 <code>ApplicationEvent</code>基类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class BlackListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlackListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class BlackListEvent(source: Any,
                    val address: String,
                    val content: String) : ApplicationEvent(source)</code></pre>
</div>
</div>
<div class="paragraph">
<p>发布自定义<code>ApplicationEvent</code> ，请<code>publishEvent()</code>上的方法<code>ApplicationEventPublisher</code> 。通常，这是通过创建一个实现以下内容的类来完成的<code>ApplicationEventPublisherAware</code>并将其注册为Spring bean。以下示例显示了此类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class EmailService implements ApplicationEventPublisherAware {

    private List&lt;String&gt; blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List&lt;String&gt; blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blackList.contains(address)) {
            publisher.publishEvent(new BlackListEvent(this, address, content));
            return;
        }
        // send email...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class EmailService : ApplicationEventPublisherAware {

    private lateinit var blackList: List&lt;String&gt;
    private lateinit var publisher: ApplicationEventPublisher

    fun setBlackList(blackList: List&lt;String&gt;) {
        this.blackList = blackList
    }

    override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) {
        this.publisher = publisher
    }

    fun sendEmail(address: String, content: String) {
        if (blackList!!.contains(address)) {
            publisher!!.publishEvent(BlackListEvent(this, address, content))
            return
        }
        // send email...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在配置时，Spring容器检测到<code>EmailService</code>贯彻<code>ApplicationEventPublisherAware</code>并自动呼叫<code>setApplicationEventPublisher()</code> 。实际上，传入的参数是Spring容器本身。您正在通过其上下文与应用程序上下文进行交互<code>ApplicationEventPublisher</code>接口。</p>
</div>
<div class="paragraph">
<p>接收风俗<code>ApplicationEvent</code> ，您可以创建一个实现<code>ApplicationListener</code>并将其注册为Spring bean。以下示例显示了此类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class BlackListNotifier : ApplicationListener&lt;BlackListEvent&gt; {

    lateinit var notificationAddres: String

    override fun onApplicationEvent(event: BlackListEvent) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>ApplicationListener</code>通常使用自定义事件的类型进行参数化（ <code>BlackListEvent</code>在前面的示例中）。这意味着<code>onApplicationEvent()</code>该方法可以保持类型安全，避免任何向下转换的需求。您可以根据需要注册任意数量的事件侦听器，但请注意，默认情况下，事件侦听器会同步接收事件。这意味着<code>publishEvent()</code>方法阻塞，直到所有侦听器都已完成对事件的处理。这种同步和单线程方法的一个优点是，当侦听器接收到事件时，如果有可用的事务上下文，它将在发布者的事务上下文内部进行操作。如果有必要采用其他发布事件的策略，请参阅Spring的javadoc。 <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html"><code>ApplicationEventMulticaster</code></a>接口和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html"><code>SimpleApplicationEventMulticaster</code></a>配置选项的实现。</p>
</div>
<div class="paragraph">
<p>以下示例显示了用于注册和配置上述每个类的Bean定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="emailService" class="example.EmailService"&gt;
    &lt;property name="blackList"&gt;
        &lt;list&gt;
            &lt;value&gt;known.spammer@example.org&lt;/value&gt;
            &lt;value&gt;known.hacker@example.org&lt;/value&gt;
            &lt;value&gt;john.doe@example.org&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListNotifier" class="example.BlackListNotifier"&gt;
    &lt;property name="notificationAddress" value="blacklist@example.org"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>放在一起时<code>sendEmail()</code>的方法<code>emailService</code>调用bean，如果有任何应将其列入黑名单的电子邮件，则该事件类型为<code>BlackListEvent</code>已出版。的<code>blackListNotifier</code> Bean已注册为<code>ApplicationListener</code>并收到<code>BlackListEvent</code> ，此时它可以通知有关各方。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring的事件机制设计用于在同一应用程序上下文内在Spring bean之间进行简单的通信。但是，对于更复杂的企业集成需求，单独维护的<a href="https://projects.spring.io/spring-integration/">Spring Integration</a>项目为基于著名的Spring编程模型构建轻量级， <a href="https://www.enterpriseintegrationpatterns.com">面向模式</a> ，事件驱动的架构提供了完整的支持。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="context-functionality-events-annotation"><a class="anchor" href="#context-functionality-events-annotation"></a>基于注释的事件侦听器</h5>
<div class="paragraph">
<p>从Spring 4.2开始，您可以使用以下命令在托管Bean的任何公共方法上注册事件侦听器： <code>@EventListener</code>注解。的<code>BlackListNotifier</code>可以重写如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class BlackListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlackListEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class BlackListNotifier {

    lateinit var notificationAddress: String

    @EventListener
    fun processBlackListEvent(event: BlackListEvent) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法签名再次声明其侦听的事件类型，但是这次使用灵活的名称且未实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析您的通用参数，也可以通过通用类型来缩小事件类型。</p>
</div>
<div class="paragraph">
<p>如果您的方法应该侦听多个事件，或者您想完全不使用任何参数来定义它，则事件类型也可以在注释本身上指定。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class)
fun handleContextStart() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以通过使用<code>condition</code>定义<a href="#expressions"><code>SpEL</code> expression</a> ，应该匹配以针对特定事件实际调用该方法。</p>
</div>
<div class="paragraph">
<p>以下示例说明了仅在以下情况下才能将我们的通知程序重写为被调用<code>content</code>事件的属性等于<code>my-event</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlackListEvent(BlackListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EventListener(condition = "#blEvent.content == 'my-event'")
fun processBlackListEvent(blEvent: BlackListEvent) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每<code>SpEL</code>表达式根据专用上下文进行评估。下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p>
</div>
<table id="context-functionality-events-annotation-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表8。Event SpEL可用的元数据</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">地点</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">事件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实际上<code>ApplicationEvent</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.event</code>要么<code>event</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于调用方法的参数（作为对象数组）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args</code>要么<code>args</code> ; <code>args[0]</code>访问第一个参数，等等。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>参数名称</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评价背景</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何方法参数的名称。如果由于某种原因这些名称不可用（例如，由于编译的字节码中没有调试信息），则也可以使用<code>#a<#arg></code>语法在哪里<code><#arg></code>代表参数索引（从0开始）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#blEvent</code>要么<code>#a0</code> （您也可以使用<code>#p0</code>要么<code>#p<#arg></code>参数符号作为别名）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意<code>#root.event</code>即使您的方法签名实际上引用了已发布的任意对象，也使您可以访问基础事件。</p>
</div>
<div class="paragraph">
<p>如果由于处理另一个事件而需要发布一个事件，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EventListener
public ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EventListener
fun handleBlackListEvent(event: BlackListEvent): ListUpdateEvent {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content"><a href="#context-functionality-events-async">异步侦听</a>器不支持此功能。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这种新方法发布了新的<code>ListUpdateEvent</code>每一个<code>BlackListEvent</code>由上述方法处理。如果您需要发布多个事件，则可以返回一个<code>Collection</code>代替事件。</p>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-async"><a class="anchor" href="#context-functionality-events-async"></a>异步侦听器</h5>
<div class="paragraph">
<p>如果希望特定的侦听器异步处理事件，则可以重用<a href="integration.html#scheduling-annotation-support-async">常规<code>@Async</code>支持</a> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EventListener
@Async
public void processBlackListEvent(BlackListEvent event) {
    // BlackListEvent is processed in a separate thread
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EventListener
@Async
fun processBlackListEvent(event: BlackListEvent) {
    // BlackListEvent is processed in a separate thread
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用异步事件时，请注意以下限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果异步事件侦听器抛出<code>Exception</code> ，则不会传播到调用者。看到<code>AsyncUncaughtExceptionHandler</code>更多细节。</p>
</li>
<li>
<p>异步事件侦听器方法无法通过返回值来发布后续事件。如果您需要发布其他事件作为处理结果，请添加一个<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html"><code>ApplicationEventPublisher</code></a>手动发布事件。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-order"><a class="anchor" href="#context-functionality-events-order"></a>订购听众</h5>
<div class="paragraph">
<p>如果您需要先调用一个侦听器，则可以添加<code>@Order</code>方法声明的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EventListener
@Order(42)
public void processBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EventListener
@Order(42)
fun processBlackListEvent(event: BlackListEvent) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-generics"><a class="anchor" href="#context-functionality-events-generics"></a>一般事件</h5>
<div class="paragraph">
<p>您还可以使用泛型来进一步定义事件的结构。考虑使用<code>EntityCreatedEvent<T></code>哪里<code>T</code>是创建的实际实体的类型。例如，您可以创建以下侦听器定义以仅接收<code>EntityCreatedEvent</code>为一个<code>Person</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EventListener
public void onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EventListener
fun onPersonCreated(event: EntityCreatedEvent&lt;Person&gt;) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于类型擦除，只有在触发的事件解析了事件侦听器所依据的通用参数（即类似<code>class PersonCreatedEvent extends EntityCreatedEvent<Person> { …​ }</code> ）。</p>
</div>
<div class="paragraph">
<p>在某些情况下，如果所有事件都遵循相同的结构，这可能会变得非常乏味（就像前面示例中的事件一样）。在这种情况下，您可以实施<code>ResolvableTypeProvider</code>指导框架超出运行时环境提供的范围。以下事件显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class EntityCreatedEvent&lt;T&gt; extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class EntityCreatedEvent&lt;T&gt;(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {

    override fun getResolvableType(): ResolvableType? {
        return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource()))
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这不仅适用于<code>ApplicationEvent</code>但您作为事件发送的任何任意对象。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-resources"><a class="anchor" href="#context-functionality-resources"></a> 1.15.3。方便地访问低级资源</h4>
<div class="paragraph">
<p>为了最佳使用和理解应用程序上下文，您应该熟悉Spring的<code>Resource</code>如<a href="#resources">参考资料中所述</a> 。</p>
</div>
<div class="paragraph">
<p>应用程序上下文是<code>ResourceLoader</code> ，可用于加载<code>Resource</code>对象。一种<code>Resource</code>本质上是JDK的功能更丰富的版本<code>java.net.URL</code>类。实际上， <code>Resource</code>包装一个实例<code>java.net.URL</code> ， 在适当情况下。一种<code>Resource</code>可以从几乎任何位置以透明方式获取低级资源，包括从类路径，文件系统位置，标准URL可以描述的任何位置以及其他一些变体。如果资源位置字符串是没有任何特殊前缀的简单路径，则这些资源的来源是特定的，并且适合于实际的应用程序上下文类型。</p>
</div>
<div class="paragraph">
<p>您可以配置部署到应用程序上下文中的Bean，以实现特殊的回调接口， <code>ResourceLoaderAware</code> ，以便在初始化时自动回调，而应用程序上下文本身作为<code>ResourceLoader</code> 。您还可以公开类型的属性<code>Resource</code> ，用于访问静态资源。它们像其他任何属性一样注入其中。您可以指定那些<code>Resource</code>属性一样简单<code>String</code>路径并依靠从这些文本字符串到实际字符串的自动转换<code>Resource</code>部署bean时的对象。</p>
</div>
<div class="paragraph">
<p>位置路径或提供给<code>ApplicationContext</code>构造函数实际上是资源字符串，并且以简单的形式根据特定的上下文实现进行适当处理。例如<code>ClassPathXmlApplicationContext</code>将简单的位置路径视为类路径位置。您也可以使用带有特殊前缀的位置路径（资源字符串）来强制从类路径或URL中加载定义，而不管实际的上下文类型如何。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-create"><a class="anchor" href="#context-create"></a> 1.15.4。Web应用程序的便捷ApplicationContext实例化</h4>
<div class="paragraph">
<p>您可以建立<code>ApplicationContext</code>声明性地使用例如<code>ContextLoader</code> 。当然，您也可以创建<code>ApplicationContext</code>使用以下其中一项以编程方式实例<code>ApplicationContext</code>实现。</p>
</div>
<div class="paragraph">
<p>您可以注册一个<code>ApplicationContext</code>通过使用<code>ContextLoaderListener</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>监听者检查<code>contextConfigLocation</code>参数。如果参数不存在，则侦听器使用<code>/WEB-INF/applicationContext.xml</code>作为默认值。当参数确实存在时，侦听器将<code>String</code>通过使用预定义的定界符（逗号，分号和空格），并将这些值用作搜索应用程序上下文的位置。还支持蚂蚁风格的路径模式。例子是<code>/WEB-INF/*Context.xml</code> （对于所有名称以“。”结尾的文件<code>Context.xml</code>并且驻留在<code>WEB-INF</code>目录）和<code>/WEB-INF/**/*Context.xml</code> （适用于以下任何子目录中的所有此类文件： <code>WEB-INF</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-deploy-rar"><a class="anchor" href="#context-deploy-rar"></a> 1.15.5。部署 Spring <code>ApplicationContext</code>作为Java EE RAR文件</h4>
<div class="paragraph">
<p>可以部署一个Spring <code>ApplicationContext</code>作为RAR文件，将上下文及其所有必需的Bean类和库JAR封装在Java EE RAR部署单元中。这等效于独立引导<code>ApplicationContext</code> （仅托管在Java EE环境中）能够访问Java EE服务器功能。对于部署无头WAR文件的情况，RAR部署是一种更自然的选择-实际上，这种WAR文件没有任何HTTP入口点，仅用于引导Spring <code>ApplicationContext</code>在Java EE环境中。</p>
</div>
<div class="paragraph">
<p>对于不需要HTTP入口点而仅由消息端点和计划的作业组成的应用程序上下文，RAR部署是理想的选择。在这样的上下文中，Bean可以使用应用程序服务器资源，例如JTA事务管理器和JNDI绑定的JDBC。 <code>DataSource</code>实例和JMS <code>ConnectionFactory</code>实例，并且还可以通过Spring的标准事务管理以及JNDI和JMX支持工具在平台的JMX服务器中注册。应用程序组件还可以与应用程序服务器的JCA进行交互<code>WorkManager</code>通过春天的<code>TaskExecutor</code>抽象。</p>
</div>
<div class="paragraph">
<p>参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>类，了解RAR部署中涉及的配置详细信息。</p>
</div>
<div class="paragraph">
<p>对于将Spring ApplicationContext作为Java EE RAR文件的简单部署：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将所有应用程序类打包到RAR文件（这是具有不同文件扩展名的标准JAR文件）中。。将所有必需的库JAR添加到RAR归档文件的根目录中。。添加一个<code>META-INF/ra.xml</code>部署描述符（如<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html">javadoc中</a>所示） <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a> ）和相应的Spring XML bean定义文件（通常是<code>META-INF/applicationContext.xml</code> ）。</p>
</li>
<li>
<p>将生成的RAR文件拖放到应用程序服务器的部署目录中。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此类RAR部署单元通常是独立的。它们不会将组件暴露给外界，甚至不会暴露给同一应用程序的其他模块。与基于RAR的交互<code>ApplicationContext</code>通常通过与其他模块共享的JMS目标发生。基于RAR <code>ApplicationContext</code>也可以例如计划一些作业或对文件系统（或类似系统）中的新文件做出反应。如果需要允许来自外部的同步访问，则可以（例如）导出RMI端点，这些端点可以由同一台计算机上的其他应用程序模块使用。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beanfactory"><a class="anchor" href="#beans-beanfactory"></a> 1.16。的<code>BeanFactory</code></h3>
<div class="paragraph">
<p>的<code>BeanFactory</code> API为Spring的IoC功能提供了基础。它的特定合同主要用于与Spring的其他部分以及相关的第三方框架集成，以及<code>DefaultListableBeanFactory</code>实施是高层的关键代表<code>GenericApplicationContext</code>容器。</p>
</div>
<div class="paragraph">
<p><code>BeanFactory</code>和相关接口（例如<code>BeanFactoryAware</code> ， <code>InitializingBean</code> ， <code>DisposableBean</code> ）是其他框架组件的重要集成点。通过不需要任何注释甚至是反射，它们允许容器及其组件之间非常有效的交互。应用程序级bean可以使用相同的回调接口，但通常更喜欢通过注释或通过程序配置进行声明式依赖注入。</p>
</div>
<div class="paragraph">
<p>注意核心<code>BeanFactory</code> API级别及其<code>DefaultListableBeanFactory</code>实现不对配置格式或要使用的任何组件注释进行假设。所有这些风味都是通过扩展（例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code> ）并在共享平台上运行<code>BeanDefinition</code>对象作为核心元数据表示形式。这就是使Spring的容器如此灵活和可扩展的本质。</p>
</div>
<div class="sect3">
<h4 id="context-introduction-ctx-vs-beanfactory"><a class="anchor" href="#context-introduction-ctx-vs-beanfactory"></a> 1.16.1。 <code>BeanFactory</code>要么<code>ApplicationContext</code> ？</h4>
<div class="paragraph">
<p>本节说明了<code>BeanFactory</code>和<code>ApplicationContext</code>容器级别及其对引导的影响。</p>
</div>
<div class="paragraph">
<p>您应该使用<code>ApplicationContext</code>除非您有充分的理由不这样做，否则<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的常见实现。这些是用于所有常见目的的Spring核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册Bean定义和带注释的类，以及（从5.0版本开始）注册功能性Bean定义。</p>
</div>
<div class="paragraph">
<p>因为<code>ApplicationContext</code>包括一个的所有功能<code>BeanFactory</code> ，一般建议在平原上<code>BeanFactory</code> ，但需要完全控制Bean处理的情况除外。在一个<code>ApplicationContext</code> （如那个<code>GenericApplicationContext</code>实现），按照约定（即，按Bean名称或Bean类型-特别是后处理器）检测几种Bean，而普通<code>DefaultListableBeanFactory</code>对任何特殊的豆都不了解。</p>
</div>
<div class="paragraph">
<p>对于许多扩展的容器功能（例如注释处理和AOP代理）， <a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code>扩展点</a>至关重要。如果您只使用平原<code>DefaultListableBeanFactory</code> ，默认情况下不会检测到此类后处理器并将其激活。这种情况可能会造成混淆，因为您的bean配置实际上并没有错。而是在这种情况下，需要通过其他设置完全引导容器。</p>
</div>
<div class="paragraph">
<p>下表列出了<code>BeanFactory</code>和<code>ApplicationContext</code>接口和实现。</p>
</div>
<table id="context-introduction-ctx-vs-beanfactory-feature-matrix" class="tableblock frame-all grid-all spread">
<caption class="title">表9。特征矩阵</caption>
<colgroup>
<col style="width:50%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">特征</th>
<th class="tableblock halign-left valign-top"><code>BeanFactory</code></th>
<th class="tableblock halign-left valign-top"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean实例化/接线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">集成生命周期管理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动<code>BeanPostProcessor</code>注册</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动<code>BeanFactoryPostProcessor</code>注册</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方便<code>MessageSource</code>访问（用于内部化）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">内建<code>ApplicationEvent</code>发布机制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>用一个显式地注册一个bean后处理器<code>DefaultListableBeanFactory</code> ，您需要以编程方式调用<code>addBeanPostProcessor</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val factory = DefaultListableBeanFactory()
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())
factory.addBeanPostProcessor(MyBeanPostProcessor())

// now start using the factory</code></pre>
</div>
</div>
<div class="paragraph">
<p>申请<code>BeanFactoryPostProcessor</code>到平原<code>DefaultListableBeanFactory</code> ，您需要调用它<code>postProcessBeanFactory</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

// bring in some property values from a Properties file
PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

// now actually do the replacement
cfg.postProcessBeanFactory(factory);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val factory = DefaultListableBeanFactory()
val reader = XmlBeanDefinitionReader(factory)
reader.loadBeanDefinitions(FileSystemResource("beans.xml"))

// bring in some property values from a Properties file
val cfg = PropertySourcesPlaceholderConfigurer()
cfg.setLocation(FileSystemResource("jdbc.properties"))

// now actually do the replacement
cfg.postProcessBeanFactory(factory)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，显式的注册步骤都不方便，这就是为什么<code>ApplicationContext</code>变体优于平原<code>DefaultListableBeanFactory</code>在Spring支持的应用程序中，尤其是在依赖<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>典型企业设置中扩展容器功能的实例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一个<code>AnnotationConfigApplicationContext</code>已注册了所有通用注释后处理器，并可以通过配置注释在幕后引入其他处理器，例如<code>@EnableTransactionManagement</code> 。在Spring基于注解的配置模型的抽象级别上，bean后处理器的概念仅是内部容器详细信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources"><a class="anchor" href="#resources"></a> 2。资源资源</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了Spring如何处理资源以及如何在Spring中使用资源。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#resources-introduction">介绍</a></p>
</li>
<li>
<p><a href="#resources-resource">资源接口</a></p>
</li>
<li>
<p><a href="#resources-implementations">内置资源实现</a></p>
</li>
<li>
<p><a href="#resources-resourceloader">的<code>ResourceLoader</code></a></p>
</li>
<li>
<p><a href="#resources-resourceloaderaware">的<code>ResourceLoaderAware</code>接口</a></p>
</li>
<li>
<p><a href="#resources-as-dependencies">资源依赖</a></p>
</li>
<li>
<p><a href="#resources-app-ctx">应用程序上下文和资源路径</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="resources-introduction"><a class="anchor" href="#resources-introduction"></a> 2.1。介绍</h3>
<div class="paragraph">
<p>Java的标准<code>java.net.URL</code>不幸的是，用于各种URL前缀的class和标准处理程序不足以满足所有对低级资源的访问。例如，没有标准化<code>URL</code>可以用于访问需要从类路径或相对于类路径获取资源的实现<code>ServletContext</code> 。虽然可以注册专门的新处理程序<code>URL</code>前缀（类似于现有的前缀处理程序，例如<code>http:</code> ），这通常很复杂，并且<code>URL</code>接口仍然缺少一些理想的功能，例如一种检查所指向资源是否存在的方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-resource"><a class="anchor" href="#resources-resource"></a> 2.2。资源接口</h3>
<div class="paragraph">
<p>春天的<code>Resource</code> interface旨在成为一种功能更强大的接口，用于抽象化对低级资源的访问。以下清单显示了<code>Resource</code>接口定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Resource extends InputStreamSource {

    boolean exists();

    boolean isOpen();

    URL getURL() throws IOException;

    File getFile() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Resource : InputStreamSource {

    fun exists(): Boolean

    val isOpen: Boolean

    val url: URL

    val file: File

    @Throws(IOException::class)
    fun createRelative(relativePath: String): Resource

    val filename: String

    val description: String
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为定义<code>Resource</code>界面显示，它扩展了<code>InputStreamSource</code>接口。以下清单显示了<code>InputStreamSource</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface InputStreamSource {

    InputStream getInputStream() throws IOException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface InputStreamSource {

    val inputStream: InputStream
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些最重要的方法<code>Resource</code>界面有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInputStream()</code> ：找到并打开资源，返回一个<code>InputStream</code>用于从资源中读取。预计每次调用都会返回一个新的<code>InputStream</code> 。呼叫者有责任关闭流。</p>
</li>
<li>
<p><code>exists()</code> ：返回一个<code>boolean</code>指示此资源是否实际以物理形式存在。</p>
</li>
<li>
<p><code>isOpen()</code> ：返回一个<code>boolean</code>指示此资源是否代表带有开放流的句柄。如果<code>true</code> ， <code>InputStream</code>不能多次读取，并且只能读取一次，然后将其关闭以避免资源泄漏。退货<code>false</code>适用于所有常规资源实施，但以下情况除外<code>InputStreamResource</code> 。</p>
</li>
<li>
<p><code>getDescription()</code> ：返回对此资源的描述，以便在使用该资源时用于错误输出。这通常是标准文件名或资源的实际URL。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其他方法可以让您获得实际的<code>URL</code>要么<code>File</code>代表资源的对象（如果基础实现兼容并且支持该功能）。</p>
</div>
<div class="paragraph">
<p>Spring本身使用<code>Resource</code>广泛地抽象为需要资源时许多方法签名中的参数类型。一些Spring API中的其他方法（例如各种<code>ApplicationContext</code>实现） <code>String</code>以简单或简单的形式用于创建<code>Resource</code>适用于该上下文实现，或通过<code>String</code>路径，让调用者指定一个特定的<code>Resource</code>实现必须创建和使用。</p>
</div>
<div class="paragraph">
<p>而<code>Resource</code> Spring和Spring经常使用该接口，实际上，在您自己的代码中单独使用该接口作为通用实用工具类来访问资源，即使您的代码不了解或不关心Spring的任何其他部分，实际上也非常有用。虽然这会将您的代码耦合到Spring，但实际上仅将其耦合到这套实用程序小类，它们可作为更强大的替代品<code>URL</code>并且可以被认为等同于您将为此目的使用的任何其他库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>Resource</code>抽象不能替代功能。它尽可能地包装它。例如，一个<code>UrlResource</code>包装URL并使用包装的URL <code>URL</code>做它的工作。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="resources-implementations"><a class="anchor" href="#resources-implementations"></a> 2.3。内置资源实现</h3>
<div class="paragraph">
<p>春季包括以下内容<code>Resource</code>实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#resources-implementations-urlresource"><code>UrlResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-classpathresource"><code>ClassPathResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-filesystemresource"><code>FileSystemResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-servletcontextresource"><code>ServletContextResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-inputstreamresource"><code>InputStreamResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-bytearrayresource"><code>ByteArrayResource</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="resources-implementations-urlresource"><a class="anchor" href="#resources-implementations-urlresource"></a> 2.3.1。<code>UrlResource</code></h4>
<div class="paragraph">
<p><code>UrlResource</code>包装一个<code>java.net.URL</code>并且可用于访问通常可以通过URL访问的任何对象，例如文件，HTTP目标，FTP目标等。所有网址都有标准化的<code>String</code>表示形式，以便使用适当的标准化前缀来指示一个URL类型与另一个URL类型。这包括<code>file:</code>用于访问文件系统路径， <code>http:</code>用于通过HTTP协议访问资源， <code>ftp:</code>用于通过FTP等访问资源。</p>
</div>
<div class="paragraph">
<p>一种<code>UrlResource</code>是由Java代码通过显式使用<code>UrlResource</code>构造函数，但通常在调用带有以下内容的API方法时隐式创建<code>String</code>参数表示路径。对于后一种情况，使用JavaBeans <code>PropertyEditor</code>最终决定哪种类型<code>Resource</code>去创造。如果路径字符串包含众所周知的前缀（例如），例如<code>classpath:</code> ），它会创建适当的专业<code>Resource</code>该前缀。但是，如果它不能识别前缀，则假定该字符串是标准URL字符串并创建一个<code>UrlResource</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-classpathresource"><a class="anchor" href="#resources-implementations-classpathresource"></a> 2.3.2。<code>ClassPathResource</code></h4>
<div class="paragraph">
<p>此类表示应从类路径获取的资源。它使用线程上下文类加载器，给定的类加载器或给定的类来加载资源。</p>
</div>
<div class="paragraph">
<p>这个<code>Resource</code>实现支持解析为<code>java.io.File</code>如果类路径资源驻留在文件系统中，而不是类路径资源驻留在jar中并且尚未（通过servlet引擎或任何环境被扩展）到文件系统的类路径资源。为了解决这个问题，各种<code>Resource</code>实现始终支持将解析作为<code>java.net.URL</code> 。</p>
</div>
<div class="paragraph">
<p>一种<code>ClassPathResource</code>是由Java代码通过显式使用<code>ClassPathResource</code>构造函数，但通常在调用带有以下内容的API方法时隐式创建<code>String</code>参数表示路径。对于后一种情况，使用JavaBeans <code>PropertyEditor</code>识别特殊前缀， <code>classpath:</code> ，在字符串路径上创建一个<code>ClassPathResource</code>在这种情况下。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-filesystemresource"><a class="anchor" href="#resources-implementations-filesystemresource"></a> 2.3.3。<code>FileSystemResource</code></h4>
<div class="paragraph">
<p>这是一个<code>Resource</code>实施<code>java.io.File</code>和<code>java.nio.file.Path</code>处理。它支持分辨率为<code>File</code>并且作为<code>URL</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-servletcontextresource"><a class="anchor" href="#resources-implementations-servletcontextresource"></a> 2.3.4。<code>ServletContextResource</code></h4>
<div class="paragraph">
<p>这是一个<code>Resource</code>实施<code>ServletContext</code>解释相关Web应用程序根目录中相对路径的资源。</p>
</div>
<div class="paragraph">
<p>它始终支持流访问和URL访问，但允许<code>java.io.File</code>仅在扩展Web应用程序归档且资源实际位于文件系统上时访问。它是在文件系统上扩展还是直接扩展，或者直接从JAR或其他类似数据库（可以想到的）访问，实际上取决于Servlet容器。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-inputstreamresource"><a class="anchor" href="#resources-implementations-inputstreamresource"></a> 2.3.5。<code>InputStreamResource</code></h4>
<div class="paragraph">
<p>一个<code>InputStreamResource</code>是一个<code>Resource</code>给定的实现<code>InputStream</code> 。仅当没有具体说明时才应使用<code>Resource</code>实施是适用的。特别喜欢<code>ByteArrayResource</code>或任何基于文件的<code>Resource</code>尽可能的实施。</p>
</div>
<div class="paragraph">
<p>与其他相比<code>Resource</code>在实现中，这是一个已经打开的资源的描述符。因此，它返回<code>true</code>从<code>isOpen()</code> 。如果您需要将资源描述符保留在某个地方，或者需要多次读取流，请不要使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-bytearrayresource"><a class="anchor" href="#resources-implementations-bytearrayresource"></a> 2.3.6。<code>ByteArrayResource</code></h4>
<div class="paragraph">
<p>这是一个<code>Resource</code>给定字节数组的实现。它创建一个<code>ByteArrayInputStream</code>给定的字节数组。</p>
</div>
<div class="paragraph">
<p>这对于从任何给定的字节数组加载内容很有用，而不必求助于一次性使用<code>InputStreamResource</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-resourceloader"><a class="anchor" href="#resources-resourceloader"></a> 2.4。的<code>ResourceLoader</code></h3>
<div class="paragraph">
<p>的<code>ResourceLoader</code>接口旨在由可以返回（即加载）的对象实现<code>Resource</code>实例。以下清单显示了<code>ResourceLoader</code>接口定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ResourceLoader {

    Resource getResource(String location);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface ResourceLoader {

    fun getResource(location: String): Resource
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有应用程序上下文均实现<code>ResourceLoader</code>接口。因此，所有应用程序上下文都可用于获取<code>Resource</code>实例。</p>
</div>
<div class="paragraph">
<p>你打电话的时候<code>getResource()</code>在特定的应用程序上下文中，并且指定的位置路径没有特定的前缀，您将获得一个<code>Resource</code>适用于该特定应用程序上下文的类型。例如，假设针对以下代码段执行了以下代码段： <code>ClassPathXmlApplicationContext</code>实例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Resource template = ctx.getResource("some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val template = ctx.getResource("some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>反对<code>ClassPathXmlApplicationContext</code> ，则该代码返回一个<code>ClassPathResource</code> 。如果对一个对象执行了相同的方法<code>FileSystemXmlApplicationContext</code>例如，它将返回一个<code>FileSystemResource</code> 。为一个<code>WebApplicationContext</code> ，它将返回一个<code>ServletContextResource</code> 。类似地，它将为每个上下文返回适当的对象。</p>
</div>
<div class="paragraph">
<p>结果，您可以以适合特定应用程序上下文的方式加载资源。</p>
</div>
<div class="paragraph">
<p>另一方面，您也可以强制<code>ClassPathResource</code>通过指定特殊字符可以在不考虑应用程序上下文类型的情况下使用<code>classpath:</code>前缀，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val template = ctx.getResource("classpath:some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以强制<code>UrlResource</code>通过指定任何标准来使用<code>java.net.URL</code>前缀。以下示例使用<code>file</code>和<code>http</code>前缀：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val template = ctx.getResource("file:///some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Resource template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表总结了转换策略<code>String</code>反对<code>Resource</code>对象：</p>
</div>
<table id="resources-resource-strings" class="tableblock frame-all grid-all spread">
<caption class="title">表10。资源字符串</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字首</th>
<th class="tableblock halign-left valign-top">例</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类路径：</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classpath:com/myapp/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从类路径加载。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件：</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="file:///data/config.xml" class="bare">file:///data/config.xml</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">载入为<code>URL</code>从文件系统。也可以看看<a href="#resources-filesystemresource-caveats"><code>FileSystemResource</code>注意事项</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http：</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="https://myserver/logo.png" class="bare">https://myserver/logo.png</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">载入为<code>URL</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（没有）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/data/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">取决于基础<code>ApplicationContext</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="resources-resourceloaderaware"><a class="anchor" href="#resources-resourceloaderaware"></a> 2.5。的<code>ResourceLoaderAware</code>接口</h3>
<div class="paragraph">
<p>的<code>ResourceLoaderAware</code> interface是一个特殊的回调接口，用于标识期望随组件一起提供的组件。 <code>ResourceLoader</code>参考。以下清单显示了<code>ResourceLoaderAware</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ResourceLoaderAware {

    void setResourceLoader(ResourceLoader resourceLoader);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface ResourceLoaderAware {

    fun setResourceLoader(resourceLoader: ResourceLoader)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当一个类实现时<code>ResourceLoaderAware</code>并部署到应用程序上下文中（作为Spring托管Bean），它被识别为<code>ResourceLoaderAware</code>通过应用程序上下文。然后，应用程序上下文会调用<code>setResourceLoader(ResourceLoader)</code> ，以自身作为参数（请记住，Spring中的所有应用程序上下文都实现了<code>ResourceLoader</code>接口）。</p>
</div>
<div class="paragraph">
<p>由于一个<code>ApplicationContext</code>是一个<code>ResourceLoader</code> ，bean也可以实现<code>ApplicationContextAware</code>接口并直接使用提供的应用程序上下文来加载资源。但是，一般来说，最好使用专门的<code>ResourceLoader</code>界面，仅此而已。该代码将仅耦合到资源加载接口（可以视为实用程序接口），而不耦合到整个Spring。 <code>ApplicationContext</code>接口。</p>
</div>
<div class="paragraph">
<p>在应用程序组件中，您还可以依靠自动装配<code>ResourceLoader</code>作为实施<code>ResourceLoaderAware</code>接口。“传统” <code>constructor</code>和<code>byType</code>自动<a href="#beans-factory-autowire">装配</a>模式（如“ <a href="#beans-factory-autowire">自动装配协作器”中所述</a> ）能够提供<code>ResourceLoader</code>分别用于构造函数参数或setter方法参数。为了获得更大的灵活性（包括自动装配字段和多个参数方法的能力），请考虑使用基于注释的自动装配功能。在这种情况下， <code>ResourceLoader</code>会自动连接到需要以下内容的字段，构造函数参数或方法参数中<code>ResourceLoader</code>只要相关的字段，构造函数或方法带有<code>@Autowired</code>注解。有关更多信息，请参见<a href="#beans-autowired-annotation">使用<code>@Autowired</code></a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-as-dependencies"><a class="anchor" href="#resources-as-dependencies"></a> 2.6。资源依赖</h3>
<div class="paragraph">
<p>如果Bean本身将通过某种动态过程来确定和提供资源路径，那么Bean使用<code>ResourceLoader</code>加载资源的接口。例如，考虑加载某种模板，其中所需的特定资源取决于用户的角色。如果资源是静态的，则消除使用<code>ResourceLoader</code>完全接口，让bean暴露<code>Resource</code>它需要的属性，并期望将它们注入其中。</p>
</div>
<div class="paragraph">
<p>然后注入这些属性的琐事是所有应用程序上下文都注册并使用特殊的JavaBeans <code>PropertyEditor</code> ，可以转换<code>String</code>通往<code>Resource</code>对象。因此，如果<code>myBean</code>具有类型的模板属性<code>Resource</code> ，可以为该资源配置一个简单的字符串，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myBean" class="..."&gt;
    &lt;property name="template" value="some/resource/path/myTemplate.txt"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，资源路径没有前缀。因此，因为应用程序上下文本身将用作<code>ResourceLoader</code> ，资源本身是通过<code>ClassPathResource</code> ， 一种<code>FileSystemResource</code>或<code>ServletContextResource</code> ，具体取决于上下文的确切类型。</p>
</div>
<div class="paragraph">
<p>如果您需要强制特定<code>Resource</code>要使用的类型，可以使用前缀。以下两个示例显示了如何强制<code>ClassPathResource</code>和一个<code>UrlResource</code> （后者用于访问文件系统文件）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;property name="template" value="classpath:some/resource/path/myTemplate.txt"&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;property name="template" value="file:///some/resource/path/myTemplate.txt"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-app-ctx"><a class="anchor" href="#resources-app-ctx"></a> 2.7。应用程序上下文和资源路径</h3>
<div class="paragraph">
<p>本节介绍如何使用资源创建应用程序上下文，包括使用XML的快捷方式，如何使用通配符以及其他详细信息。</p>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-construction"><a class="anchor" href="#resources-app-ctx-construction"></a> 2.7.1。构造应用程序上下文</h4>
<div class="paragraph">
<p>应用程序上下文构造函数（针对特定的应用程序上下文类型）通常采用字符串或字符串数组作为资源的位置路径，例如构成上下文定义的XML文件。</p>
</div>
<div class="paragraph">
<p>如果此类位置路径没有前缀，则<code>Resource</code>从该路径构建并用于加载Bean定义的类型取决于并且适合于特定的应用程序上下文。例如，请考虑以下示例，该示例创建了一个<code>ClassPathXmlApplicationContext</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = ClassPathXmlApplicationContext("conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bean定义是从类路径加载的，因为<code>ClassPathResource</code>用来。但是，请考虑以下示例，该示例创建了一个<code>FileSystemXmlApplicationContext</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = FileSystemXmlApplicationContext("conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，bean定义是从文件系统位置（在这种情况下，是相对于当前工作目录）加载的。</p>
</div>
<div class="paragraph">
<p>请注意，在位置路径上使用特殊的classpath前缀或标准URL前缀会覆盖默认的<code>Resource</code>创建以加载定义。考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = FileSystemXmlApplicationContext("classpath:conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用<code>FileSystemXmlApplicationContext</code>从类路径加载bean定义。但是，它仍然是<code>FileSystemXmlApplicationContext</code> 。如果随后用作<code>ResourceLoader</code> ，所有未加前缀的路径仍被视为文件系统路径。</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-classpathxml"><a class="anchor" href="#resources-app-ctx-classpathxml"></a>建造中<code>ClassPathXmlApplicationContext</code>实例-快捷方式</h5>
<div class="paragraph">
<p>的<code>ClassPathXmlApplicationContext</code>公开了许多构造函数以实现方便的实例化。基本思想是，您只能提供一个字符串数组，该字符串数组仅包含XML文件本身的文件名（不包含前导路径信息），并且还提供<code>Class</code> 。的<code>ClassPathXmlApplicationContext</code>然后从提供的类中导出路径信息。</p>
</div>
<div class="paragraph">
<p>请考虑以下目录布局：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/
  foo/
    services.xml
    daos.xml
    MessengerService.class</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了<code>ClassPathXmlApplicationContext</code>由在名为file的文件中定义的bean组成的实例<code>services.xml</code>和<code>daos.xml</code> （在类路径上）可以实例化：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "daos.xml"}, MessengerService.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = ClassPathXmlApplicationContext(arrayOf("services.xml", "daos.xml"), MessengerService::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>ClassPathXmlApplicationContext</code></a>有关各种构造函数的详细信息，请参见javadoc。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-wildcards-in-resource-paths"><a class="anchor" href="#resources-app-ctx-wildcards-in-resource-paths"></a> 2.7.2。应用程序上下文构造函数资源路径中的通配符</h4>
<div class="paragraph">
<p>应用程序上下文构造函数值中的资源路径可以是简单路径（如前所述），每个路径都具有与目标的一对一映射<code>Resource</code>或者，也可以包含特殊的“ classpath *：”前缀或内部Ant样式的正则表达式（通过使用Spring的<code>PathMatcher</code>效用）。后者都是有效的通配符。</p>
</div>
<div class="paragraph">
<p>这种机制的一种用途是当您需要进行组件样式的应用程序组装时。所有组件都可以将上下文定义片段“发布”到一个众所周知的位置路径，并且在最终应用程序上下文使用前缀为相同的路径创建时<code>classpath*:</code> ，所有组件片段都会自动提取。</p>
</div>
<div class="paragraph">
<p>请注意，此通配符特定于应用程序上下文构造函数中资源路径的使用（或当您使用<code>PathMatcher</code>实用程序类层次结构直接），并在构造时解决。它与<code>Resource</code>自行输入。您不能使用<code>classpath*:</code>前缀构造一个实际的<code>Resource</code> ，因为一种资源一次仅指向一种资源。</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-ant-patterns-in-paths"><a class="anchor" href="#resources-app-ctx-ant-patterns-in-paths"></a>蚂蚁风格的图案</h5>
<div class="paragraph">
<p>路径位置可以包含Ant样式的模式，如以下示例所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/WEB-INF/<strong>-context.xml
com/mycompany/<strong>/applicationContext.xml
file:C:/some/path/</strong>-context.xml
classpath:com/mycompany/</strong>/applicationContext.xml</pre>
</div>
</div>
<div class="paragraph">
<p>当路径位置包含Ant样式的模式时，解析程序将遵循更复杂的过程来尝试解析通配符。它产生一个<code>Resource</code>直到最后一个非通配符段的路径，并从中获取URL。如果此网址不是<code>jar:</code> URL或特定于容器的变体（例如<code>zip:</code>在WebLogic中<code>wsjar</code>在WebSphere等中）， <code>java.io.File</code>从中获取通配符，并将其用于遍历文件系统来解析通配符。如果是jar URL，则解析程序会获取一个<code>java.net.JarURLConnection</code>从它或手动解析jar URL，然后遍历jar文件的内容以解析通配符。</p>
</div>
<div class="sect5">
<h6 id="resources-app-ctx-portability"><a class="anchor" href="#resources-app-ctx-portability"></a>对可移植性的影响</h6>
<div class="paragraph">
<p>如果指定的路径已经是文件URL（要么隐式，因为<code>ResourceLoader</code>是一个文件系统（或明确地是一个文件系统），通配符可以完全可移植的方式工作。</p>
</div>
<div class="paragraph">
<p>如果指定的路径是类路径位置，则解析器必须通过使<code>Classloader.getResource()</code>呼叫。由于这只是路径的一个节点（而不是最后的文件），因此实际上是未定义的（在<code>ClassLoader</code>在这种情况下，返回的是哪种类型的URL。实际上，它始终是<code>java.io.File</code>表示目录（类路径资源解析为文件系统位置的目录）或某种jar URL（类路径资源解析为jar位置的URL）。尽管如此，此操作仍存在可移植性问题。</p>
</div>
<div class="paragraph">
<p>如果为最后一个非通配符段获取了jar URL，则解析程序必须能够获取<code>java.net.JarURLConnection</code>从中或手动解析jar URL，以便能够遍历jar的内容并解析通配符。这在大多数环境中确实有效，但在其他环境中则无效，因此我们强烈建议您在依赖特定环境之前，对来自jars的资源的通配符解析进行彻底测试。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="resources-classpath-wildcards"><a class="anchor" href="#resources-classpath-wildcards"></a>的<code>classpath*:</code>字首</h5>
<div class="paragraph">
<p>在构造基于XML的应用程序上下文时，位置字符串可以使用特殊的<code>classpath*:</code>前缀，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = ClassPathXmlApplicationContext("classpath*:conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个特殊的前缀指定必须获取与给定名称匹配的所有类路径资源（在内部，这实际上是通过调用<code>ClassLoader.getResources(…​)</code> ），然后合并形成最终的应用程序上下文定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通配符类路径依赖于<code>getResources()</code>基础类加载器的方法。由于当今大多数应用程序服务器提供其自己的类加载器实现，因此行为可能有所不同，尤其是在处理jar文件时。一个简单的测试，以检查是否<code>classpath*</code>可行的方法是使用类加载器从类路径上的jar中加载文件： <code>getClass().getClassLoader().getResources("<someFileInsideTheJar>")</code> 。尝试对具有相同名称但位于两个不同位置的文件进行此测试。如果返回了不合适的结果，请检查应用程序服务器文档中可能影响类加载器行为的设置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您也可以将<code>classpath*:</code>带一个前缀<code>PathMatcher</code>位置路径其余部分中的样式（例如， <code>classpath*:META-INF/*-beans.xml</code> ）。在这种情况下，解决策略非常简单： <code>ClassLoader.getResources()</code>在最后一个非通配符路径段上使用调用，以获取类加载器层次结构中的所有匹配资源，然后从每个资源获取相同的资源<code>PathMatcher</code>前面描述的解析策略用于通配符子路径。</p>
</div>
</div>
<div class="sect4">
<h5 id="resources-wildcards-in-path-other-stuff"><a class="anchor" href="#resources-wildcards-in-path-other-stuff"></a>有关通配符的其他说明</h5>
<div class="paragraph">
<p>注意<code>classpath*:</code> ，当与Ant样式的模式结合使用时，除非模式文件实际存在于目标文件中，否则在模式启动之前，它至少必须与至少一个根目录可靠地配合使用。这意味着诸如<code>classpath*:*.xml</code>可能不会从jar文件的根目录检索文件，而只能从扩展目录的根目录检索文件。</p>
</div>
<div class="paragraph">
<p>Spring检索类路径条目的能力源自JDK的<code>ClassLoader.getResources()</code>方法，该方法仅返回文件系统中的空字符串位置（指示可能要搜索的根）。春天评估<code>URLClassLoader</code>运行时配置和<code>java.class.path</code>清单文件中也包含清单，但不能保证会导致可移植行为。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>扫描类路径包需要在类路径中存在相应的目录条目。使用Ant构建JAR时，请勿激活JAR任务的仅文件开关。另外，在某些环境中，基于安全策略可能不会暴露类路径目录，例如，在JDK 1.7.0_45及更高版本上的独立应用程序（这需要在清单中设置“受信任的库”）。参见<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a> ）。</p>
</div>
<div class="paragraph">
<p>在JDK 9的模块路径（Jigsaw）上，Spring的类路径扫描通常可以按预期进行。强烈建议在此处将资源放入专用目录中，以避免在搜索jar文件根目录级别时遇到上述可移植性问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>蚂蚁风格的图案搭配<code>classpath:</code>如果要搜索的根包在多个类路径位置中可用，则不能保证资源会找到匹配的资源。考虑以下资源位置示例：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/mycompany/package1/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>现在考虑某人可能用来尝试找到该文件的Ant样式的路径：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>classpath:com/mycompany/**/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>这样的资源可能只在一个位置，但是当使用诸如上一示例的路径尝试对其进行解析时，解析器将根据由（例如） <code>getResource("com/mycompany");</code> 。如果此基本包节点存在于多个类加载器位置，则实际的最终资源可能不存在。因此，在这种情况下，您应该优先使用<code>classpath*:</code>具有相同的Ant样式模式，该模式将搜索包含根包的所有类路径位置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-filesystemresource-caveats"><a class="anchor" href="#resources-filesystemresource-caveats"></a> 2.7.3。 <code>FileSystemResource</code> 注意事项</h4>
<div class="paragraph">
<p>一种<code>FileSystemResource</code>没有连接到<code>FileSystemApplicationContext</code> （即<code>FileSystemApplicationContext</code>不是实际的<code>ResourceLoader</code> ）会按您期望的那样处理绝对路径和相对路径。相对路径是相对于当前工作目录的，而绝对路径是相对于文件系统的根的。</p>
</div>
<div class="paragraph">
<p>但是，出于向后兼容（历史）的原因，当<code>FileSystemApplicationContext</code>是个<code>ResourceLoader</code> 。的<code>FileSystemApplicationContext</code>部队全部附上<code>FileSystemResource</code>实例将所有位置路径都视为相对路径，无论它们是否以前斜杠开头。实际上，这意味着以下示例是等效的：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = FileSystemXmlApplicationContext("conf/context.xml")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx = FileSystemXmlApplicationContext("/conf/context.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例也是等效的（即使它们有所不同也有意义，因为一种情况是相对的，另一种情况是绝对的）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx: FileSystemXmlApplicationContext = ...
ctx.getResource("some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val ctx: FileSystemXmlApplicationContext = ...
ctx.getResource("/some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，如果您需要真实的绝对文件系统路径，则应避免将绝对路径与<code>FileSystemResource</code>要么<code>FileSystemXmlApplicationContext</code>并强制使用<code>UrlResource</code>通过使用<code>file:</code> URL前缀。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:///conf/context.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
val ctx = FileSystemXmlApplicationContext("file:///conf/context.xml")</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation"><a class="anchor" href="#validation"></a> 3。验证，数据绑定和类型转换</h2>
<div class="sectionbody">
<div class="paragraph">
<p>考虑将验证作为业务逻辑是有利有弊，Spring提供了一种验证（和数据绑定）设计，但并不排除其中任何一个。具体来说，验证不应与Web层绑定，并且应该易于本地化，并且应该可以插入任何可用的验证器。考虑到这些问题，Spring提出了<code>Validator</code>在应用程序的每个层中既基本又非常有用的接口。</p>
</div>
<div class="paragraph">
<p>数据绑定对于使用户输入动态绑定到应用程序的域模型（或用于处理用户输入的任何对象）非常有用。Spring提供了恰当的名称<code>DataBinder</code>要做到这一点。的<code>Validator</code>和<code>DataBinder</code>弥补<code>validation</code>软件包，主要用于但不限于MVC框架。</p>
</div>
<div class="paragraph">
<p>的<code>BeanWrapper</code>是Spring Framework 中的基本概念，并在许多地方得到了使用。但是，您可能不需要使用<code>BeanWrapper</code>直。但是，因为这是参考文档，所以我们认为可能需要进行一些解释。我们解释<code>BeanWrapper</code>在本章中，因为如果您将要使用它，那么在尝试将数据绑定到对象时最有可能使用它。</p>
</div>
<div class="paragraph">
<p>春天的<code>DataBinder</code>和下层<code>BeanWrapper</code>都使用<code>PropertyEditorSupport</code>解析和格式化属性值的实现。的<code>PropertyEditor</code>和<code>PropertyEditorSupport</code>类型是JavaBeans规范的一部分，本章还将对此进行说明。Spring 3引入了<code>core.convert</code>提供常规类型转换工具的软件包，以及用于格式化UI字段值的高级“格式”软件包。您可以将这些软件包用作以下更简单的选择<code>PropertyEditorSupport</code>实现。本章还将对它们进行讨论。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">JSR-303 / JSR-349 Bean验证</div>
<div class="paragraph">
<p>从4.0版开始，Spring Framework支持Bean验证1.0（JSR-303）和Bean验证1.1（JSR-349）来提供设置支持并使其适应Spring的要求。 <code>Validator</code>接口。</p>
</div>
<div class="paragraph">
<p>应用程序可以选择一次在全局启用Bean验证，如<a href="#validation-beanvalidation">Spring Validation中所述</a> ，并将其专门用于所有验证需求。</p>
</div>
<div class="paragraph">
<p>应用程序还可以注册其他Spring <code>Validator</code>每个实例<code>DataBinder</code>实例，如<a href="#validation-binder">配置<code>DataBinder</code></a> 。这对于在不使用注释的情况下插入验证逻辑可能很有用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="validator"><a class="anchor" href="#validator"></a> 3.1。通过使用Spring的Validator接口进行验证</h3>
<div class="paragraph">
<p>春天特色<code>Validator</code>可以用来验证对象的界面。的<code>Validator</code>界面通过使用<code>Errors</code>对象，以便在验证时，验证者可以将验证失败报告给<code>Errors</code>宾语。</p>
</div>
<div class="paragraph">
<p>考虑以下小数据对象的示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Person {

    private String name;
    private int age;

    // the usual getters and setters...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Person(val name: String, val age: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例提供了针对<code>Person</code>类，通过实现以下两种方法<code>org.springframework.validation.Validator</code>接口：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supports(Class)</code> ：可以吗<code>Validator</code>验证提供的实例<code>Class</code> ？</p>
</li>
<li>
<p><code>validate(Object, org.springframework.validation.Errors)</code> ：验证给定对象，并在验证错误的情况下，将给定对象注册<code>Errors</code>宾语。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实施<code>Validator</code>非常简单，尤其是当您知道<code>ValidationUtils</code> Spring Framework 还提供的helper类。以下示例实现<code>Validator</code>对于<code>Person</code>实例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() &gt; 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonValidator : Validator {

    /<strong>*
     * This Validator validates only Person instances
     */
    override fun supports(clazz: Class&lt;</strong>&gt;): Boolean {
        return Person::class.java == clazz
    }

    override fun validate(obj: Any, e: Errors) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty")
        val p = obj as Person
        if (p.age &lt; 0) {
            e.rejectValue("age", "negativevalue")
        } else if (p.age &gt; 110) {
            e.rejectValue("age", "too.darn.old")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>static</code><code>rejectIfEmpty(..)</code>上的方法<code>ValidationUtils</code>类用于拒绝<code>name</code>如果是财产<code>null</code>或空字符串。看看<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/validation/ValidationUtils.html"><code>ValidationUtils</code></a> javadoc来查看它提供了除了先前显示的示例之外的功能。</p>
</div>
<div class="paragraph">
<p>虽然当然可以实施一个<code>Validator</code>类来验证丰富对象中的每个嵌套对象，最好将每个嵌套对象类的验证逻辑封装在自己的对象中<code>Validator</code>实施。一个“丰富”对象的简单示例是<code>Customer</code>由两个组成<code>String</code>属性（名字和名字）和一个复数<code>Address</code>宾语。 <code>Address</code>对象可以独立于<code>Customer</code>对象，因此与众不同<code>AddressValidator</code>已实施。如果你想要你的<code>CustomerValidator</code>重用包含在其中的逻辑<code>AddressValidator</code>类，而不必求助于复制粘贴，您可以依赖注入或实例化<code>AddressValidator</code>在你内<code>CustomerValidator</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CustomerValidator(private val addressValidator: Validator) : Validator {

    init {
        if (addressValidator == null) {
            throw IllegalArgumentException("The supplied [Validator] is required and must not be null.")
        }
        if (!addressValidator.supports(Address::class.java)) {
            throw IllegalArgumentException("The supplied [Validator] must support the validation of [Address] instances.")
        }
    }

    /<strong>*
    * This Validator validates Customer instances, and any subclasses of Customer too
    */
    override fun supports(clazz: Class&lt;</strong>&gt;): Boolean {
        return Customer::class.java.isAssignableFrom(clazz)
    }

    override fun validate(target: Any, errors: Errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required")
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required")
        val customer = target as Customer
        try {
            errors.pushNestedPath("address")
            ValidationUtils.invokeValidator(this.addressValidator, customer.address, errors)
        } finally {
            errors.popNestedPath()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>验证错误会报告给<code>Errors</code>对象传递给验证器。对于Spring Web MVC，您可以使用<code><spring:bind/></code>标签来检查错误消息，但您也可以检查<code>Errors</code>反对自己。关于它提供的方法的更多信息可以在<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframeworkvalidation/Errors.html">javadoc中</a>找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-conversion"><a class="anchor" href="#validation-conversion"></a> 3.2。将代码解析为错误消息</h3>
<div class="paragraph">
<p>我们介绍了数据绑定和验证。本节介绍与验证错误相对应的输出消息。在上<a href="#validator">一节</a>显示的示例中，我们拒绝了<code>name</code>和<code>age</code>领域。如果我们想使用<code>MessageSource</code> ，我们可以使用拒绝字段时提供的错误代码（在这种情况下为“名称”和“年龄”）进行操作。当您致电（直接或间接通过使用例如<code>ValidationUtils</code>类） <code>rejectValue</code>或另一个<code>reject</code>来自的方法<code>Errors</code>接口，基础实现不仅注册您传入的代码，还注册许多其他错误代码。的<code>MessageCodesResolver</code>确定哪个错误代码<code>Errors</code>接口寄存器。默认情况下， <code>DefaultMessageCodesResolver</code>使用（例如），它不仅使用您提供的代码注册消息，而且还注册包含您传递给reject方法的字段名称的消息。因此，如果您通过使用拒绝字段<code>rejectValue("age", "too.darn.old")</code> ，除了<code>too.darn.old</code>代码，Spring也注册<code>too.darn.old.age</code>和<code>too.darn.old.age.int</code> （第一个包含字段名称，第二个包含字段类型）。这样做是为了方便开发人员在定位错误消息时提供帮助。</p>
</div>
<div class="paragraph">
<p>有关的更多信息<code>MessageCodesResolver</code>默认策略可以在的javadoc中找到<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html"><code>MessageCodesResolver</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html"><code>DefaultMessageCodesResolver</code></a> ， 分别。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-beans"><a class="anchor" href="#beans-beans"></a> 3.3。Bean操作和<code>BeanWrapper</code></h3>
<div class="paragraph">
<p>的<code>org.springframework.beans</code>软件包遵循JavaBeans标准。JavaBean是具有默认无参数构造函数的类，并且遵循命名约定，其中（例如）一个名为<code>bingoMadness</code>将有一个setter方法<code>setBingoMadness(..)</code>和吸气方法<code>getBingoMadness()</code> 。有关JavaBean和规范的更多信息，请参见<a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">javabeans</a> 。</p>
</div>
<div class="paragraph">
<p>bean程序包中的一个非常重要的类是<code>BeanWrapper</code>接口及其相应的实现（ <code>BeanWrapperImpl</code> ）。如javadoc所述， <code>BeanWrapper</code>提供设置和获取属性值（单独或批量），获取属性描述符和查询属性以确定它们是否可读或可写的功能。另外， <code>BeanWrapper</code>提供对嵌套属性的支持，从而可以将子属性上的属性设置为无限深度。的<code>BeanWrapper</code>还支持添加标准JavaBeans的功能<code>PropertyChangeListeners</code>和<code>VetoableChangeListeners</code> ，而无需在目标类中支持代码。最后但并非最不重要的是<code>BeanWrapper</code>提供对设置索引属性的支持。的<code>BeanWrapper</code>通常不直接由应用程序代码使用，而是由<code>DataBinder</code>和<code>BeanFactory</code> 。</p>
</div>
<div class="paragraph">
<p>的方式<code>BeanWrapper</code> works部分地由其名称表示：它包装了一个bean，以对该bean执行操作，例如设置和检索属性。</p>
</div>
<div class="sect3">
<h4 id="beans-beans-conventions"><a class="anchor" href="#beans-beans-conventions"></a> 3.3.1。设置和获取基本和嵌套属性</h4>
<div class="paragraph">
<p>设置和获取属性是通过使用<code>setPropertyValue</code> ， <code>setPropertyValues</code> ， <code>getPropertyValue</code>和<code>getPropertyValues</code>带有一些重载变体的方法。Springs javadoc更详细地描述了它们。JavaBeans规范具有用于指示对象属性的约定。下表显示了这些约定的一些示例：</p>
</div>
<table id="beans-beans-conventions-properties-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表11。属性示例</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表达</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示属性<code>name</code>对应于<code>getName()</code>要么<code>isName()</code>和<code>setName(..)</code>方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示嵌套的属性<code>name</code>财产的<code>account</code>对应于（例如） <code>getAccount().setName()</code>要么<code>getAccount().getName()</code>方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[2]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示索引属性的<em>第三个</em>元素<code>account</code> 。索引属性可以是类型<code>array</code> ， <code>list</code>或其他自然排序的集合。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[COMPANYNAME]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示由索引的地图条目的值<code>COMPANYNAME</code>的关键<code>account</code><code>Map</code>属性。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>（如果您不打算使用<code>BeanWrapper</code>直。如果仅使用<code>DataBinder</code>和<code>BeanFactory</code>及其默认实现，您应该跳到<a href="#beans-beans-conversion">有关<code>PropertyEditors</code></a> ）</p>
</div>
<div class="paragraph">
<p>以下两个示例类使用<code>BeanWrapper</code>获取和设置属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Company {

    private String name;
    private Employee managingDirector;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getManagingDirector() {
        return this.managingDirector;
    }

    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Company {
    var name: String? = null
    var managingDirector: Employee? = null
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Employee {

    private String name;

    private float salary;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getSalary() {
        return salary;
    }

    public void setSalary(float salary) {
        this.salary = salary;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Employee {
    var name: String? = null
    var salary: Float? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下代码段显示了一些有关如何检索和操纵实例化属性的示例。 <code>Companies</code>和<code>Employees</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue("managingDirector.salary");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val company = BeanWrapperImpl(Company())
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.")
// ... can also be done like this:
val value = PropertyValue("name", "Some Company Inc.")
company.setPropertyValue(value)

// ok, let's create the director and tie it to the company:
val jim = BeanWrapperImpl(Employee())
jim.setPropertyValue("name", "Jim Stravinsky")
company.setPropertyValue("managingDirector", jim.wrappedInstance)

// retrieving the salary of the managingDirector through the company
val salary = company.getPropertyValue("managingDirector.salary") as Float?</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-beans-conversion"><a class="anchor" href="#beans-beans-conversion"></a> 3.3.2。内建<code>PropertyEditor</code>实作</h4>
<div class="paragraph">
<p>Spring使用了一个概念<code>PropertyEditor</code>以实现<code>Object</code>和一个<code>String</code> 。以不同于对象本身的方式表示属性可能很方便。例如，一个<code>Date</code>可以以人类可读的方式表示（如<code>String</code> ： <code>'2007-14-09'</code> ），尽管我们仍然可以将可读格式转换为原始日期（或者更好的是，将以可读格式输入的任何日期转换为原始日期） <code>Date</code>对象）。通过注册类型的自定义编辑器可以实现此行为<code>java.beans.PropertyEditor</code> 。在网站上注册自定义编辑器<code>BeanWrapper</code>或者，也可以在特定的IoC容器中（如上一章所述），了解如何将属性转换为所需的类型。有关更多<code>PropertyEditor</code> ，看<a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">的javadoc的<code>java.beans</code>来自Oracle的软件包</a> 。</p>
</div>
<div class="paragraph">
<p>在Spring中使用属性编辑的两个示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在bean上设置属性是通过使用<code>PropertyEditor</code>实现。使用时<code>String</code>作为您在XML文件中声明的某个bean的属性值，Spring（如果对应属性的设置器具有一个<code>Class</code>参数）的用途<code>ClassEditor</code>尝试将参数解析为<code>Class</code>宾语。</p>
</li>
<li>
<p>在Spring的MVC框架中解析HTTP请求参数是通过使用各种<code>PropertyEditor</code>您可以在所有子类中手动绑定的实现<code>CommandController</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring有很多内置的<code>PropertyEditor</code>实施使生活变得轻松。它们都位于<code>org.springframework.beans.propertyeditors</code>包。默认情况下，大多数（但不是全部，如下表所示）是由以下人员注册的： <code>BeanWrapperImpl</code> 。在可以某种方式配置属性编辑器的地方，您仍然可以注册自己的变量来覆盖默认变量。下表介绍了各种<code>PropertyEditor</code> Spring提供的实现：</p>
</div>
<table id="beans-beans-property-editors-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表12。内建<code>PropertyEditor</code>实作</caption>
<colgroup>
<col style="width:30%">
<col style="width:70%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayPropertyEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节数组的编辑器。将字符串转换为其相应的字节表示形式。默认情况下注册<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClassEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将代表类的字符串解析为实际类，反之亦然。当找不到课程时， <code>IllegalArgumentException</code>被抛出。默认情况下，由<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomBooleanEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可自定义的属性编辑器，用于<code>Boolean</code>属性。默认情况下，由<code>BeanWrapperImpl</code>但是可以通过将其自定义实例注册为自定义编辑器来覆盖它。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomCollectionEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合的属性编辑器，可转换任何源<code>Collection</code>到给定的目标<code>Collection</code>类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomDateEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可自定义的属性编辑器，用于<code>java.util.Date</code> ，支持自定义<code>DateFormat</code> 。默认未注册。必须根据需要以适当的格式进行用户注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomNumberEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可自定义的属性编辑器<code>Number</code>子类，例如<code>Integer</code> ， <code>Long</code> ， <code>Float</code> ， 要么<code>Double</code> 。默认情况下，由<code>BeanWrapperImpl</code>但是可以通过将其自定义实例注册为自定义编辑器来覆盖它。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将字符串解析为<code>java.io.File</code>对象。默认情况下，由<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InputStreamEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单向属性编辑器，可以获取字符串并产生（通过中间<code>ResourceEditor</code>和<code>Resource</code> ） <code>InputStream</code>以便<code>InputStream</code>属性可以直接设置为字符串。请注意，默认用法不会关闭<code>InputStream</code>为了你。默认情况下，由<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以将字符串解析为<code>Locale</code>对象，反之亦然（字符串格式为<code><em class="language">[country]</em>[variant]</code> ，与<code>toString()</code>的方法<code>Locale</code> ）。默认情况下，由<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以将字符串解析为<code>java.util.regex.Pattern</code>对象，反之亦然。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PropertiesEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以转换字符串（格式为的javadoc中定义的格式<code>java.util.Properties</code>课） <code>Properties</code>对象。默认情况下，由<code>BeanWrapperImpl</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringTrimmerEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修剪字符串的属性编辑器。（可选）允许将空字符串转换为<code>null</code>值。默认情况下未注册-必须是用户注册的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>URLEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以将URL的字符串表示形式解析为实际的<code>URL</code>宾语。默认情况下，由<code>BeanWrapperImpl</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>春季使用<code>java.beans.PropertyEditorManager</code>设置可能需要的属性编辑器的搜索路径。搜索路径还包括<code>sun.bean.editors</code> ， 包括<code>PropertyEditor</code>类型的实现，例如<code>Font</code> ， <code>Color</code> ，以及大多数原始类型。还要注意，标准JavaBeans基础结构会自动发现<code>PropertyEditor</code>类（无需显式注册它们），如果它们与它们处理的类在同一个包中，并且具有与该类相同的名称，则<code>Editor</code>附加。例如，一个人可能具有以下类和包结构，这足以满足<code>SomethingEditor</code>被识别并用作<code>PropertyEditor</code>对于<code>Something</code>类型的属性。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您也可以使用标准<code>BeanInfo</code>这里也有JavaBeans机制（在某种程度上进行<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">了</a>描述）。以下示例使用<code>BeanInfo</code>明确注册一个或多个的机制<code>PropertyEditor</code>具有关联类的属性的实例：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Something
      SomethingBeanInfo // the BeanInfo for the Something class</pre>
</div>
</div>
<div class="paragraph">
<p>以下Java源代码供参考<code>SomethingBeanInfo</code>班级同伙<code>CustomNumberEditor</code>与<code>age</code>的属性<code>Something</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SomethingBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                };
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SomethingBeanInfo : SimpleBeanInfo() {

    override fun getPropertyDescriptors(): Array&lt;PropertyDescriptor&gt; {
        try {
            val numberPE = CustomNumberEditor(Int::class.java, true)
            val ageDescriptor = object : PropertyDescriptor("age", Something::class.java) {
                override fun createPropertyEditor(bean: Any): PropertyEditor {
                    return numberPE
                }
            }
            return arrayOf(ageDescriptor)
        } catch (ex: IntrospectionException) {
            throw Error(ex.toString())
        }

    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="beans-beans-conversion-customeditor-registration"><a class="anchor" href="#beans-beans-conversion-customeditor-registration"></a>注册其他自定义<code>PropertyEditor</code>实作</h5>
<div class="paragraph">
<p>当将bean属性设置为字符串值时，Spring IoC容器最终会使用标准JavaBeans <code>PropertyEditor</code>将这些字符串转换为属性的复杂类型的实现。Spring预注册了一些自定义<code>PropertyEditor</code>实现（例如，将以字符串形式表示的类名转换为<code>Class</code>宾语）。此外，Java的标准JavaBeans <code>PropertyEditor</code>查找机制使<code>PropertyEditor</code>为一个类适当地命名，并将其与其提供支持的类放在同一包中，以便可以自动找到它。</p>
</div>
<div class="paragraph">
<p>如果需要注册其他风俗<code>PropertyEditors</code> ，有几种可用的机制。通常不方便或不建议使用的最手动的方法是使用<code>registerCustomEditor()</code>的方法<code>ConfigurableBeanFactory</code>界面，假设您有一个<code>BeanFactory</code>参考。另一种（稍微方便些）的机制是使用一种特殊的bean工厂后处理器，称为<code>CustomEditorConfigurer</code> 。尽管您可以将bean工厂后处理器用于<code>BeanFactory</code>实现， <code>CustomEditorConfigurer</code>具有嵌套的属性设置，因此我们强烈建议您将其与<code>ApplicationContext</code> ，您可以在其中以与其他任何Bean类似的方式部署它，并在其中可以自动检测和应用它。</p>
</div>
<div class="paragraph">
<p>请注意，所有Bean工厂和应用程序上下文通过使用内置的属性编辑器自动使用许多内置的属性编辑器。 <code>BeanWrapper</code>处理属性转换。标准属性编辑器<code>BeanWrapper</code>寄存器在上<a href="#beans-beans-conversion">一节</a>中列出。另外， <code>ApplicationContexts</code>还重写或添加其他编辑器，以适合于特定应用程序上下文类型的方式来处理资源查找。</p>
</div>
<div class="paragraph">
<p>标准JavaBeans <code>PropertyEditor</code>实例用于将表示为字符串的属性值转换为该属性的实际复杂类型。您可以使用<code>CustomEditorConfigurer</code> ，bean工厂的后处理器，以方便地添加对其他功能的支持<code>PropertyEditor</code>实例到<code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p>考虑下面的示例，该示例定义了一个名为<code>ExoticType</code>还有一个叫做<code>DependsOnExoticType</code> ，这需要<code>ExoticType</code>设置为属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package example;

public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {

    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package example

class ExoticType(val name: String)

class DependsOnExoticType {

    var type: ExoticType? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When things are properly set up, we want to be able to assign the type property as a
string, which a <code>PropertyEditor</code> converts into an actual
<code>ExoticType</code> instance. The following bean definition shows how to set up this relationship:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type" value="aNameForExoticType"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PropertyEditor</code> implementation could look similar to the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// converts string representation to ExoticType object
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

    public void setAsText(String text) {
        setValue(new ExoticType(text.toUpperCase()));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// converts string representation to ExoticType object
package example

import java.beans.PropertyEditorSupport

class ExoticTypeEditor : PropertyEditorSupport() {

    override fun setAsText(text: String) {
        value = ExoticType(text.toUpperCase())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the following example shows how to use <code>CustomEditorConfigurer</code> to register the new <code>PropertyEditor</code> with the
<code>ApplicationContext</code>, which will then be able to use it as needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="customEditors"&gt;
        &lt;map&gt;
            &lt;entry key="example.ExoticType" value="example.ExoticTypeEditor"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-beans-conversion-customeditor-registration-per"><a class="anchor" href="#beans-beans-conversion-customeditor-registration-per"></a>Using <code>PropertyEditorRegistrar</code></h6>
<div class="paragraph">
<p>Another mechanism for registering property editors with the Spring container is to
create and use a <code>PropertyEditorRegistrar</code>. This interface is particularly useful when
you need to use the same set of property editors in several different situations.
You can write a corresponding registrar and reuse it in each case.
<code>PropertyEditorRegistrar</code> instances work in conjunction with an interface called
<code>PropertyEditorRegistry</code>, an interface that is implemented by the Spring <code>BeanWrapper</code>
(and <code>DataBinder</code>). <code>PropertyEditorRegistrar</code> instances are particularly convenient
when used in conjunction with <code>CustomEditorConfigurer</code> (described
<a href="#beans-beans-conversion-customeditor-registration">here</a>), which exposes a property
called <code>setPropertyEditorRegistrars(..)</code>. <code>PropertyEditorRegistrar</code> instances added
to a <code>CustomEditorConfigurer</code> in this fashion can easily be shared with <code>DataBinder</code> and
Spring MVC controllers. 此外，它避免了在自定义编辑器上进行同步的需要：A <code>PropertyEditorRegistrar</code>有望创造新鲜<code>PropertyEditor</code>每个bean创建尝试的实例。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何创建自己的<code>PropertyEditorRegistrar</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo.editors.spring

import org.springframework.beans.PropertyEditorRegistrar
import org.springframework.beans.PropertyEditorRegistry

class CustomPropertyEditorRegistrar : PropertyEditorRegistrar {

    override fun registerCustomEditors(registry: PropertyEditorRegistry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType::class.java, ExoticTypeEditor())

        // you could register as many custom property editors as are required here...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请参阅<code>org.springframework.beans.support.ResourceEditorRegistrar</code>举个例子<code>PropertyEditorRegistrar</code>实施。请注意，如何执行<code>registerCustomEditors(..)</code>方法，它会创建每个属性编辑器的新实例。</p>
</div>
<div class="paragraph">
<p>下一个示例显示了如何配置<code>CustomEditorConfigurer</code>并注入我们的实例<code>CustomPropertyEditorRegistrar</code>进去：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="propertyEditorRegistrars"&gt;
        &lt;list&gt;
            &lt;ref bean="customPropertyEditorRegistrar"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="customPropertyEditorRegistrar"
    class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后（使用<a href="web.html#mvc">Spring MVC Web框架</a>的读者与本章重点有所偏离），使用<code>PropertyEditorRegistrars</code>结合数据绑定<code>Controllers</code> （如<code>SimpleFormController</code> ）可以非常方便。以下示例使用<code>PropertyEditorRegistrar</code>在执行<code>initBinder(..)</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    }

    // other methods to do with registering a User
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class RegisterUserController(
    private val customPropertyEditorRegistrar: PropertyEditorRegistrar) : SimpleFormController() {

    protected fun initBinder(request: HttpServletRequest,
                            binder: ServletRequestDataBinder) {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder)
    }

    // other methods to do with registering a User
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种风格<code>PropertyEditor</code>注册会导致代码简洁（执行<code>initBinder(..)</code>只有一线长），让我们共同<code>PropertyEditor</code>注册代码封装在一个类中，然后在尽可能多的共享<code>Controllers</code>如所须。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert"><a class="anchor" href="#core-convert"></a> 3.4。 Spring 类型转换</h3>
<div class="paragraph">
<p>Spring 3引入了<code>core.convert</code>提供常规类型转换系统的软件包。该系统定义了一个用于实现类型转换逻辑的SPI和一个用于在运行时执行类型转换的API。在Spring容器中，您可以使用此系统来替代<code>PropertyEditor</code>将外部化的bean属性值字符串转换为所需属性类型的实现。您还可以在应用程序中需要类型转换的任何地方使用公共API。</p>
</div>
<div class="sect3">
<h4 id="core-convert-Converter-API"><a class="anchor" href="#core-convert-Converter-API"></a> 3.4.1。转换器SPI</h4>
<div class="paragraph">
<p>SPI实现类型转换逻辑很简单，且类型严格，如以下接口定义所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; {

    T convert(S source);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.core.convert.converter

interface Converter&lt;S, T&gt; {

    fun convert(source: S): T
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建自己的转换器，请实施<code>Converter</code>接口和参数化<code>S</code>作为您要转换的类型，并且<code>T</code>作为您要转换为的类型。您也可以透明地应用这样的转换器，如果<code>S</code>需要转换为数组或集合<code>T</code> ，前提是还已注册了一个委托数组或集合转换器（ <code>DefaultConversionService</code>会默认执行）。</p>
</div>
<div class="paragraph">
<p>每次致电<code>convert(S)</code> ，保证源参数不为null。你的<code>Converter</code>如果转换失败，则可能引发任何未经检查的异常。具体来说，它应该抛出一个<code>IllegalArgumentException</code>报告无效的源值。注意确保您的<code>Converter</code>实现是线程安全的。</p>
</div>
<div class="paragraph">
<p>在以下内容中提供了几种转换器实现<code>core.convert.support</code>包装为方便。这些包括从字符串到数字和其他常见类型的转换器。以下清单显示了<code>StringToInteger</code>类，这是典型的<code>Converter</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.core.convert.support

import org.springframework.core.convert.converter.Converter

internal class StringToInteger : Converter&lt;String, Int&gt; {

    override fun convert(source: String): Int? {
        return Integer.valueOf(source)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConverterFactory-SPI"><a class="anchor" href="#core-convert-ConverterFactory-SPI"></a> 3.4.2。使用<code>ConverterFactory</code></h4>
<div class="paragraph">
<p>当您需要集中整个类层次结构的转换逻辑时（例如，从<code>String</code>至<code>Enum</code>对象），您可以实施<code>ConverterFactory</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; {

    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.core.convert.converter

interface ConverterFactory&lt;S, R&gt; {

    fun &lt;T : R&gt; getConverter(targetType: Class&lt;T&gt;): Converter&lt;S, T&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>参数化S为您要转换的类型，参数R为基础类型，定义可以转换为的类的<em>范围</em> 。然后实施<code>getConverter(Class<T>)</code> ，其中T是R的子类。</p>
</div>
<div class="paragraph">
<p>考虑一下<code>StringToEnumConverterFactory</code>举个例子：</p>
</div>
<div class="listingblock">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {

    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {

        private Class&lt;T&gt; enumType;

        public StringToEnumConverter(Class&lt;T&gt; enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-GenericConverter-SPI"><a class="anchor" href="#core-convert-GenericConverter-SPI"></a> 3.4.3。使用<code>GenericConverter</code></h4>
<div class="paragraph">
<p>当您需要复杂的<code>Converter</code>实施，请考虑使用<code>GenericConverter</code>接口。具有比其灵活但强度不高的签名<code>Converter</code> ， 一种<code>GenericConverter</code>支持多种源类型和目标类型之间的转换。此外， <code>GenericConverter</code>使您可以在实现转换逻辑时使用可用的源字段和目标字段上下文。这种上下文允许类型转换由字段注释或在字段签名上声明的通用信息驱动。以下清单显示了接口的定义<code>GenericConverter</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.core.convert.converter;

public interface GenericConverter {

    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.core.convert.converter

interface GenericConverter {

    fun getConvertibleTypes(): Set&lt;ConvertiblePair&gt;?

    fun convert(@Nullable source: Any?, sourceType: TypeDescriptor, targetType: TypeDescriptor): Any?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实施<code>GenericConverter</code> ，有<code>getConvertibleTypes()</code>返回支持的源→目标类型对。然后实施<code>convert(Object, TypeDescriptor, TypeDescriptor)</code>包含您的转换逻辑。来源<code>TypeDescriptor</code>提供对包含要转换的值的源字段的访问。目标<code>TypeDescriptor</code>提供对要设置转换值的目标字段的访问。</p>
</div>
<div class="paragraph">
<p>一个很好的例子<code>GenericConverter</code>是在Java数组和集合之间进行转换的转换器。这样的<code>ArrayToCollectionConverter</code>内省声明声明目标集合类型的字段以解析集合的元素类型。这样就可以在将集合设置到目标字段上之前，将源数组中的每个元素转换为集合元素类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">因为<code>GenericConverter</code>是一个更复杂的SPI接口，仅应在需要时使用它。宠爱<code>Converter</code>要么<code>ConverterFactory</code>满足基本类型转换需求。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="core-convert-ConditionalGenericConverter-SPI"><a class="anchor" href="#core-convert-ConditionalGenericConverter-SPI"></a>使用<code>ConditionalGenericConverter</code></h5>
<div class="paragraph">
<p>有时，您想要<code>Converter</code>仅在满足特定条件的情况下运行。例如，您可能要运行<code>Converter</code>仅当目标字段上存在特定注释时，或者您可能要运行<code>Converter</code>仅在特定方法（例如<code>static valueOf</code>方法）是在目标类上定义的。
<code>ConditionalGenericConverter</code>是<code>GenericConverter</code>和<code>ConditionalConverter</code>用于定义此类自定义匹配条件的界面：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ConditionalConverter {

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface ConditionalConverter {

    fun matches(sourceType: TypeDescriptor, targetType: TypeDescriptor): Boolean
}

interface ConditionalGenericConverter : GenericConverter, ConditionalConverter</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个很好的例子<code>ConditionalGenericConverter</code>是一个<code>EntityConverter</code>在持久性实体标识符和实体引用之间转换。这样的<code>EntityConverter</code>仅在目标实体类型声明静态查找程序方法时才匹配（例如， <code>findAccount(Long)</code> ）。您可能会在实现中执行这种finder方法检查<code>matches(TypeDescriptor, TypeDescriptor)</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConversionService-API"><a class="anchor" href="#core-convert-ConversionService-API"></a> 3.4.4。的<code>ConversionService</code> API</h4>
<div class="paragraph">
<p><code>ConversionService</code>定义了一个统一的API，用于在运行时执行类型转换逻辑。转换器通常在以下外观界面后面执行：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.core.convert

interface ConversionService {

    fun canConvert(sourceType: Class&lt;*&gt;, targetType: Class&lt;*&gt;): Boolean

    fun &lt;T&gt; convert(source: Any, targetType: Class&lt;T&gt;): T

    fun canConvert(sourceType: TypeDescriptor, targetType: TypeDescriptor): Boolean

    fun convert(source: Any, sourceType: TypeDescriptor, targetType: TypeDescriptor): Any

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最<code>ConversionService</code>实现也实现<code>ConverterRegistry</code> ，它提供用于注册转换器的SPI。在内部， <code>ConversionService</code>实现委托其注册的转换器执行类型转换逻辑。</p>
</div>
<div class="paragraph">
<p>坚固<code>ConversionService</code>实现在<code>core.convert.support</code>包。 <code>GenericConversionService</code>是适用于大多数环境的通用实现。 <code>ConversionServiceFactory</code>提供了一个方便的工厂来创建通用<code>ConversionService</code>配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-Spring-config"><a class="anchor" href="#core-convert-Spring-config"></a> 3.4.5。配置一个<code>ConversionService</code></h4>
<div class="paragraph">
<p>一种<code>ConversionService</code>是一个无状态对象，旨在在应用程序启动时实例化，然后在多个线程之间共享。在Spring应用程序中，通常会配置一个<code>ConversionService</code>每个Spring容器的实例（或<code>ApplicationContext</code> ）。春天来了<code>ConversionService</code>并在框架需要执行类型转换时使用它。您也可以注入<code>ConversionService</code>放入您的任何bean中并直接调用它。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果不<code>ConversionService</code>已向Spring注册，原始<code>PropertyEditor</code>基于的系统。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注册默认<code>ConversionService</code>在Spring中，将以下bean定义与<code>id</code>的<code>conversionService</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="conversionService"
    class="org.springframework.context.support.ConversionServiceFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认值<code>ConversionService</code>可以在字符串，数字，枚举，集合，映射和其他常见类型之间转换。要使用您自己的自定义转换器来补充或覆盖默认转换器，请设置<code>converters</code>属性。属性值可以实现任何<code>Converter</code> ， <code>ConverterFactory</code> ， 要么<code>GenericConverter</code>接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="conversionService"
        class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;
    &lt;property name="converters"&gt;
        &lt;set&gt;
            &lt;bean class="example.MyCustomConverter"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常使用<code>ConversionService</code>在Spring MVC应用程序中。参见Spring MVC一章中的<a href="web.html#mvc-config-conversion">转换和格式化</a> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望在转换过程中应用格式设置。查看<a href="#format-FormatterRegistry-SPI">该<code>FormatterRegistry</code> SPI</a>有关使用的详细信息<code>FormattingConversionServiceFactoryBean</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-programmatic-usage"><a class="anchor" href="#core-convert-programmatic-usage"></a> 3.4.6。用一个<code>ConversionService</code>以编程方式</h4>
<div class="paragraph">
<p>与<code>ConversionService</code>通过编程实例，可以像对其他任何bean一样注入对其的引用。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    public MyService(ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    public void doIt() {
        this.conversionService.convert(...)
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Service
class MyService(private val conversionService: ConversionService) {

    fun doIt() {
        conversionService.convert(...)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下，您可以使用<code>convert</code>指定的方法<code>targetType</code> ，但不适用于更复杂的类型，例如参数化元素的集合。例如，如果您要转换<code>List</code>的<code>Integer</code>到<code>List</code>的<code>String</code>以编程方式，您需要提供源类型和目标类型的正式定义。</p>
</div>
<div class="paragraph">
<p>幸好， <code>TypeDescriptor</code>如以下示例所示，它提供了多种使操作变得简单的选项：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultConversionService cs = new DefaultConversionService();

List&lt;Integer&gt; input = ...
cs.convert(input,
    TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val cs = DefaultConversionService()

val input: List&lt;Integer&gt; = ...
cs.convert(input,
        TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
        TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(String::class.java)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>DefaultConversionService</code>自动注册适用于大多数环境的转换器。这包括收集转换器，标量转换器和基本<code>Object</code> -至- <code>String</code>转换器。您可以将相同的转换器注册到任何<code>ConverterRegistry</code>通过使用静态<code>addDefaultConverters</code>上的方法<code>DefaultConversionService</code>类。</p>
</div>
<div class="paragraph">
<p>值类型的转换器可重复用于数组和集合，因此无需创建特定的转换器即可从<code>Collection</code>的<code>S</code>到<code>Collection</code>的<code>T</code> ，假设标准的收集处理适当。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format"><a class="anchor" href="#format"></a> 3.5。Spring字段格式</h3>
<div class="paragraph">
<p>如上一节所述， <a href="#core-convert"><code>core.convert</code></a>是通用类型转换系统。它提供了一个统一的<code>ConversionService</code> API以及强类型<code>Converter</code> SPI，用于实现从一种类型到另一种类型的转换逻辑。Spring容器使用此系统绑定bean属性值。此外，Spring Expression Language（SpEL）和<code>DataBinder</code>使用此系统绑定字段值。例如，当SpEL需要强制<code>Short</code>到<code>Long</code>完成一个<code>expression.setValue(Object bean, Object value)</code>尝试， <code>core.convert</code>系统执行强制。</p>
</div>
<div class="paragraph">
<p>现在考虑典型客户端环境（例如Web或桌面应用程序）的类型转换要求。在这种环境下，您通常会从<code>String</code>支持客户回发流程以及<code>String</code>支持视图渲染过程。此外，您经常需要本地化<code>String</code>价值观。更一般<code>core.convert</code><code>Converter</code> SPI不能直接解决此类格式化要求。为了直接解决这些问题，Spring 3引入了一种方便的方法<code>Formatter</code> SPI提供了一种简单而强大的替代方案<code>PropertyEditor</code>客户端环境的实现。</p>
</div>
<div class="paragraph">
<p>通常，您可以使用<code>Converter</code>当您需要实现通用类型转换逻辑时（例如，在<code>java.util.Date</code>和一个<code>Long</code> 。您可以使用<code>Formatter</code>在客户端环境（例如Web应用程序）中工作并且需要解析和打印本地化的字段值时的SPI。的<code>ConversionService</code>为两个SPI提供统一的类型转换API。</p>
</div>
<div class="sect3">
<h4 id="format-Formatter-SPI"><a class="anchor" href="#format-Formatter-SPI"></a> 3.5.1。的<code>Formatter</code> SPI</h4>
<div class="paragraph">
<p>的<code>Formatter</code>实现字段格式逻辑的SPI很简单且类型很严格。以下清单显示了<code>Formatter</code>接口定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.format;

public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Formatter</code>从<code>Printer</code>和<code>Parser</code>构件接口。以下清单显示了这两个接口的定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Printer&lt;T&gt; {

    String print(T fieldValue, Locale locale);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Printer&lt;T&gt; {

    fun print(fieldValue: T, locale: Locale): String
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.text.ParseException;

public interface Parser&lt;T&gt; {

    T parse(String clientValue, Locale locale) throws ParseException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Parser&lt;T&gt; {

    @Throws(ParseException::class)
    fun parse(clientValue: String, locale: Locale): T
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创造自己的<code>Formatter</code> ，实施<code>Formatter</code>界面如前所示。参数化<code>T</code>成为您要格式化的对象的类型，例如， <code>java.util.Date</code> 。实施<code>print()</code>打印一个实例的操作<code>T</code>以显示在客户端语言环境中。实施<code>parse()</code>解析实例的操作<code>T</code>从客户端语言环境返回的格式化表示形式中。你的<code>Formatter</code>应该扔一个<code>ParseException</code>或<code>IllegalArgumentException</code>如果解析尝试失败。注意确保您的<code>Formatter</code>实现是线程安全的。</p>
</div>
<div class="paragraph">
<p>的<code>format</code>子包提供了几个<code>Formatter</code>为方便起见。的<code>number</code>套餐提供<code>NumberStyleFormatter</code> ， <code>CurrencyStyleFormatter</code>和<code>PercentStyleFormatter</code>格式化<code>Number</code>使用一个的对象<code>java.text.NumberFormat</code> 。的<code>datetime</code>包提供了<code>DateFormatter</code>格式化<code>java.util.Date</code>带一个对象<code>java.text.DateFormat</code> 。的<code>datetime.joda</code>软件包提供了基于<a href="https://www.joda.org/joda-time/">Joda-Time库的</a>全面的日期时间格式支持。</p>
</div>
<div class="paragraph">
<p>下列<code>DateFormatter</code>是一个例子<code>Formatter</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.format.datetime;

public final class DateFormatter implements Formatter&lt;Date&gt; {

    private String pattern;

    public DateFormatter(String pattern) {
        this.pattern = pattern;
    }

    public String print(Date date, Locale locale) {
        if (date == null) {
            return "";
        }
        return getDateFormat(locale).format(date);
    }

    public Date parse(String formatted, Locale locale) throws ParseException {
        if (formatted.length() == 0) {
            return null;
        }
        return getDateFormat(locale).parse(formatted);
    }

    protected DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
        dateFormat.setLenient(false);
        return dateFormat;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class DateFormatter(private val pattern: String) : Formatter&lt;Date&gt; {

    override fun print(date: Date, locale: Locale)
            = getDateFormat(locale).format(date)

    @Throws(ParseException::class)
    override fun parse(formatted: String, locale: Locale)
            = getDateFormat(locale).parse(formatted)

    protected fun getDateFormat(locale: Locale): DateFormat {
        val dateFormat = SimpleDateFormat(this.pattern, locale)
        dateFormat.isLenient = false
        return dateFormat
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>春季团队欢迎社区主导<code>Formatter</code>贡献。请参阅<a href="https://github.com/spring-projects/spring-framework/issues">GitHub问题</a>以做出贡献。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-CustomFormatAnnotations"><a class="anchor" href="#format-CustomFormatAnnotations"></a> 3.5.2。注释驱动的格式</h4>
<div class="paragraph">
<p>可以通过字段类型或注释配置字段格式。将注释绑定到<code>Formatter</code> ， 实行<code>AnnotationFormatterFactory</code> 。以下清单显示了<code>AnnotationFormatterFactory</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.format;

public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {

    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();

    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);

    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.format

interface AnnotationFormatterFactory&lt;A : Annotation&gt; {

    val fieldTypes: Set&lt;Class&lt;*&gt;&gt;

    fun getPrinter(annotation: A, fieldType: Class&lt;*&gt;): Printer&lt;*&gt;

    fun getParser(annotation: A, fieldType: Class&lt;*&gt;): Parser&lt;*&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建一个实现：。参数化A为字段<code>annotationType</code>您希望与之关联的格式化逻辑-例如<code>org.springframework.format.annotation.DateTimeFormat</code> 。。有<code>getFieldTypes()</code>返回可以在其上使用注释的字段的类型。。有<code>getPrinter()</code>返回一个<code>Printer</code>打印带注释的字段的值。。有<code>getParser()</code>返回一个<code>Parser</code>解析一个<code>clientValue</code>用于带注释的字段。</p>
</div>
<div class="paragraph">
<p>下面的例子<code>AnnotationFormatterFactory</code>实现绑定<code>@NumberFormat</code>格式化程序的注释，以指定数字样式或模式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public final class NumberFormatAnnotationFormatterFactory
        implements AnnotationFormatterFactory&lt;NumberFormat&gt; {

    public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {
        return new HashSet&lt;Class&lt;?&gt;&gt;(asList(new Class&lt;?&gt;[] {
            Short.class, Integer.class, Long.class, Float.class,
            Double.class, BigDecimal.class, BigInteger.class }));
    }

    public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        if (!annotation.pattern().isEmpty()) {
            return new NumberStyleFormatter(annotation.pattern());
        } else {
            Style style = annotation.style();
            if (style == Style.PERCENT) {
                return new PercentStyleFormatter();
            } else if (style == Style.CURRENCY) {
                return new CurrencyStyleFormatter();
            } else {
                return new NumberStyleFormatter();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory&lt;NumberFormat&gt; {

    override fun getFieldTypes(): Set&lt;Class&lt;*&gt;&gt; {
        return setOf(Short::class.java, Int::class.java, Long::class.java, Float::class.java, Double::class.java, BigDecimal::class.java, BigInteger::class.java)
    }

    override fun getPrinter(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Printer&lt;Number&gt; {
        return configureFormatterFrom(annotation, fieldType)
    }

    override fun getParser(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Parser&lt;Number&gt; {
        return configureFormatterFrom(annotation, fieldType)
    }

    private fun configureFormatterFrom(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Formatter&lt;Number&gt; {
        return if (annotation.pattern.isNotEmpty()) {
            NumberStyleFormatter(annotation.pattern)
        } else {
            val style = annotation.style
            when {
                style === NumberFormat.Style.PERCENT -&gt; PercentStyleFormatter()
                style === NumberFormat.Style.CURRENCY -&gt; CurrencyStyleFormatter()
                else -&gt; NumberStyleFormatter()
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要触发格式设置，可以使用@NumberFormat注释字段，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyModel {

    @NumberFormat(style=Style.CURRENCY)
    private BigDecimal decimal;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyModel(
    @field:NumberFormat(style = Style.CURRENCY) private val decimal: BigDecimal
)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="format-annotations-api"><a class="anchor" href="#format-annotations-api"></a>格式注释API</h5>
<div class="paragraph">
<p>可移植格式注释API存在于<code>org.springframework.format.annotation</code>包。您可以使用<code>@NumberFormat</code>格式化<code>Number</code>诸如<code>Double</code>和<code>Long</code>和<code>@DateTimeFormat</code>格式化<code>java.util.Date</code> ， <code>java.util.Calendar</code> ， <code>Long</code> （毫秒级时间戳）以及JSR-310 <code>java.time</code>和Joda-Time值类型。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@DateTimeFormat</code>格式化<code>java.util.Date</code>作为ISO日期（yyyy-MM-dd）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyModel {

    @DateTimeFormat(iso=ISO.DATE)
    private Date date;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyModel(
    @DateTimeFormat(iso= ISO.DATE) private val date: Date
)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistry-SPI"><a class="anchor" href="#format-FormatterRegistry-SPI"></a> 3.5.3。的<code>FormatterRegistry</code> SPI</h4>
<div class="paragraph">
<p>的<code>FormatterRegistry</code>是用于注册格式器和转换器的SPI。
<code>FormattingConversionService</code>是一个实现<code>FormatterRegistry</code>适用于大多数环境。您可以通过编程方式或声明方式将此变体配置为Spring Bean，例如，通过使用<code>FormattingConversionServiceFactoryBean</code> 。因为此实现还实现<code>ConversionService</code> ，您可以直接配置它以用于Spring的<code>DataBinder</code>和Spring Expression Language（SpEL）。</p>
</div>
<div class="paragraph">
<p>以下清单显示了<code>FormatterRegistry</code> SPI：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry {

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

    void addFormatterForFieldType(Formatter&lt;?&gt; formatter);

    void addFormatterForAnnotation(AnnotationFormatterFactory&lt;?&gt; factory);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.format

interface FormatterRegistry : ConverterRegistry {

    fun addFormatterForFieldType(fieldType: Class&lt;*&gt;, printer: Printer&lt;*&gt;, parser: Parser&lt;*&gt;)

    fun addFormatterForFieldType(fieldType: Class&lt;*&gt;, formatter: Formatter&lt;*&gt;)

    fun addFormatterForFieldType(formatter: Formatter&lt;*&gt;)

    fun addFormatterForAnnotation(factory: AnnotationFormatterFactory&lt;*&gt;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面的清单所示，您可以按字段类型或批注注册格式化程序。</p>
</div>
<div class="paragraph">
<p>的<code>FormatterRegistry</code> SPI使您可以集中配置格式设置规则，而不必在控制器之间复制此类配置。例如，您可能要强制所有日期字段以某种方式设置格式或带有特定注释的字段以某种方式设置格式。与共享<code>FormatterRegistry</code> ，您只需定义一次这些规则，然后在需要格式化时就会应用它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistrar-SPI"><a class="anchor" href="#format-FormatterRegistrar-SPI"></a> 3.5.4。的<code>FormatterRegistrar</code> SPI</h4>
<div class="paragraph">
<p><code>FormatterRegistrar</code>是用于通过FormatterRegistry注册格式器和转换器的SPI。以下清单显示了其接口定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.format;

public interface FormatterRegistrar {

    void registerFormatters(FormatterRegistry registry);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.format

interface FormatterRegistrar {

    fun registerFormatters(registry: FormatterRegistry)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种<code>FormatterRegistrar</code>为给定的格式类别（例如日期格式）注册多个相关的转换器和格式器时，此功能很有用。在声明式注册不足的情况下（例如，当格式化程序需要在不同于其自身的特定字段类型下进行索引时），它也很有用。 <code><T></code>或注册一个<code>Printer</code> / <code>Parser</code>对。下一节将提供有关转换器和格式化程序注册的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-configuring-formatting-mvc"><a class="anchor" href="#format-configuring-formatting-mvc"></a> 3.5.5。在Spring MVC中配置格式</h4>
<div class="paragraph">
<p>参见Spring MVC一章中的<a href="web.html#mvc-config-conversion">转换和格式化</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-configuring-formatting-globaldatetimeformat"><a class="anchor" href="#format-configuring-formatting-globaldatetimeformat"></a> 3.6。配置全局日期和时间格式</h3>
<div class="paragraph">
<p>默认情况下，不带注释的日期和时间字段<code>@DateTimeFormat</code>通过使用<code>DateFormat.SHORT</code>样式。如果愿意，可以通过定义自己的全局格式来更改此设置。</p>
</div>
<div class="paragraph">
<p>为此，您需要确保Spring不注册默认格式器。相反，您应该手动注册所有格式化程序。使用<code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code>要么<code>org.springframework.format.datetime.DateFormatterRegistrar</code>类，具体取决于您是否使用Joda-Time库。</p>
</div>
<div class="paragraph">
<p>例如，以下Java配置注册一个全局<code>yyyyMMdd</code>格式（此示例不依赖于Joda-Time库）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class AppConfig {

    @Bean
    fun conversionService(): FormattingConversionService {
        // Use the DefaultFormattingConversionService but do not register defaults
        return DefaultFormattingConversionService(false).apply {
            // Ensure @NumberFormat is still supported
            addFormatterForFieldAnnotation(NumberFormatAnnotationFormatterFactory())
            // Register date conversion with a specific global format
            val registrar = DateFormatterRegistrar()
            registrar.setFormatter(DateFormatter("yyyyMMdd"))
            registrar.registerFormatters(this)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您喜欢基于XML的配置，则可以使用<code>FormattingConversionServiceFactoryBean</code> 。以下示例显示了如何执行此操作（这次使用Joda Time）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;
        &lt;property name="registerDefaultFormatters" value="false" /&gt;
        &lt;property name="formatters"&gt;
            &lt;set&gt;
                &lt;bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name="formatterRegistrars"&gt;
            &lt;set&gt;
                &lt;bean class="org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar"&gt;
                    &lt;property name="dateFormatter"&gt;
                        &lt;bean class="org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean"&gt;
                            &lt;property name="pattern" value="yyyyMMdd"/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Joda-Time提供了不同的独立类型来表示<code>date</code> ， <code>time</code>和<code>date-time</code>价值观。的<code>dateFormatter</code> ， <code>timeFormatter</code>和<code>dateTimeFormatter</code>的属性<code>JodaTimeFormatterRegistrar</code>应该用于为每种类型配置不同的格式。的<code>DateTimeFormatterFactoryBean</code>提供了创建格式化程序的便捷方法。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果使用Spring MVC，请记住显式配置所使用的转换服务。对于基于Java的<code>@Configuration</code> ，这意味着扩展<code>WebMvcConfigurationSupport</code>类并覆盖<code>mvcConversionService()</code>方法。对于XML，您应该使用<code>conversion-service</code>的属性<code>mvc:annotation-driven</code>元件。有关详细信息，请参见<a href="web.html#mvc-config-conversion">转换和格式化</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation"><a class="anchor" href="#validation-beanvalidation"></a> 3.7。Spring Validation</h3>
<div class="paragraph">
<p>Spring 3对其验证支持进行了一些增强。首先，完全支持JSR-303 Bean验证API。其次，当以编程方式使用时，Spring的<code>DataBinder</code>可以验证对象并绑定到它们。第三，Spring MVC支持声明式验证<code>@Controller</code>输入。</p>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-overview"><a class="anchor" href="#validation-beanvalidation-overview"></a> 3.7.1。JSR-303 Bean验证API概述</h4>
<div class="paragraph">
<p>JSR-303标准化了Java平台的验证约束声明和元数据。通过使用此API，您可以使用声明性验证约束来注释域模型属性，并且运行时会强制执行它们。您可以使用许多内置约束。您还可以定义自己的自定义约束。</p>
</div>
<div class="paragraph">
<p>考虑以下示例，该示例显示了一个简单的<code>PersonForm</code>具有两个属性的模型：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonForm {
    private String name;
    private int age;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonForm(
        private val name: String,
        private val age: Int
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSR-303允许您针对此类属性定义声明性验证约束，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonForm {

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonForm(
    @get:NotNull @get:Size(max=64)
    private val name: String,
    @get:Min(0)
    private val age: Int
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当JSR-303验证程序验证此类的实例时，将强制执行这些约束。</p>
</div>
<div class="paragraph">
<p>有关JSR-303和JSR-349的一般信息，请访问<a href="https://beanvalidation.org/">Bean Validation网站</a> 。有关默认参考实现的特定功能的信息，请参见<a href="https://www.hibernate.org/412.html">Hibernate Validator</a>文档。要学习如何将bean验证提供程序设置为Spring bean，请继续阅读。</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring"><a class="anchor" href="#validation-beanvalidation-spring"></a> 3.7.2。配置Bean验证提供程序</h4>
<div class="paragraph">
<p>Spring提供了对Bean验证API的全面支持。这包括对将JSR-303或JSR-349 Bean验证提供程序引导为Spring Bean的便捷支持。这可以让您注入<code>javax.validation.ValidatorFactory</code>要么<code>javax.validation.Validator</code>在您的应用程序中需要验证的任何地方。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>LocalValidatorFactoryBean</code>将默认的Validator配置为Spring Bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="validator"
    class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的基本配置触发Bean验证以使用其默认引导机制进行初始化。诸如Hibernate Validator之类的JSR-303或JSR-349提供程序应该出现在类路径中并被自动检测到。</p>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-inject"><a class="anchor" href="#validation-beanvalidation-spring-inject"></a>注入验证器</h5>
<div class="paragraph">
<p><code>LocalValidatorFactoryBean</code>同时实现<code>javax.validation.ValidatorFactory</code>和<code>javax.validation.Validator</code>以及Spring的<code>org.springframework.validation.Validator</code> 。您可以将对这些接口之一的引用注入需要调用验证逻辑的bean中。</p>
</div>
<div class="paragraph">
<p>您可以注入对<code>javax.validation.Validator</code>如果您希望直接使用Bean Validation API，则如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.validation.Validator;

@Service
class MyService(@Autowired private val validator: Validator)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以注入对<code>org.springframework.validation.Validator</code>如果您的bean需要Spring Validation API，则如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.validation.Validator

@Service
class MyService(@Autowired private val validator: Validator)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-constraints"><a class="anchor" href="#validation-beanvalidation-spring-constraints"></a>配置自定义约束</h5>
<div class="paragraph">
<p>每个bean验证约束都包括两个部分：* A <code>@Constraint</code>声明约束及其可配置属性的注释。*的实现<code>javax.validation.ConstraintValidator</code>实现约束行为的接口。</p>
</div>
<div class="paragraph">
<p>要将声明与实现相关联，每个<code>@Constraint</code>注释引用了一个对应的<code>ConstraintValidator</code>实现类。在运行时， <code>ConstraintValidatorFactory</code>在域模型中遇到约束注释时，实例化引用的实现。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>LocalValidatorFactoryBean</code>配置一个<code>SpringConstraintValidatorFactory</code>使用Spring创建的<code>ConstraintValidator</code>实例。这使您的自定义<code>ConstraintValidators</code>像其他任何Spring bean一样受益于依赖注入。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个自定义<code>@Constraint</code>声明后跟相关的<code>ConstraintValidator</code>使用Spring进行依赖注入的实现：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = MyConstraintValidator::class)
annotation class MyConstraint</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

    @Autowired;
    private Foo aDependency;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.validation.ConstraintValidator

class MyConstraintValidator(private val aDependency: Foo) : ConstraintValidator {

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面的示例所示， <code>ConstraintValidator</code>实现可以有它的依赖<code>@Autowired</code>和其他任何Spring bean一样。</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-method"><a class="anchor" href="#validation-beanvalidation-spring-method"></a> Spring-driven 方法验证</h5>
<div class="paragraph">
<p>您可以通过<code>MethodValidationPostProcessor</code> bean定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了有资格进行Spring驱动的方法验证，所有目标类都必须使用Spring的注释<code>@Validated</code>注解。（或者，您也可以声明要使用的验证组。）见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html"><code>MethodValidationPostProcessor</code></a>有关Hibernate Validator和Bean Validation 1.1提供程序的设置详细信息，请参见javadoc。</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-other"><a class="anchor" href="#validation-beanvalidation-spring-other"></a>其他配置选项</h5>
<div class="paragraph">
<p>默认值<code>LocalValidatorFactoryBean</code>在大多数情况下，配置就足够了。从消息插值到遍历解析，有许多用于各种Bean验证构造的配置选项。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html"><code>LocalValidatorFactoryBean</code></a>有关这些选项的更多信息，请参见javadoc。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validation-binder"><a class="anchor" href="#validation-binder"></a> 3.7.3。配置一个<code>DataBinder</code></h4>
<div class="paragraph">
<p>从Spring 3开始，您可以配置<code>DataBinder</code>具有一个的实例<code>Validator</code> 。配置完成后，您可以调用<code>Validator</code>通过打电话<code>binder.validate()</code> 。任何验证<code>Errors</code>自动添加到活页夹的<code>BindingResult</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>DataBinder</code>绑定到目标对象后以编程方式调用验证逻辑：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val target = Foo()
val binder = DataBinder(target)
binder.validator = FooValidator()

// bind to the target object
binder.bind(propertyValues)

// validate the target object
binder.validate()

// get BindingResult that includes any validation errors
val results = binder.bindingResult</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以配置<code>DataBinder</code>与多个<code>Validator</code>通过实例<code>dataBinder.addValidators</code>和<code>dataBinder.replaceValidators</code> 。将结合全局配置的bean验证与Spring结合使用时，这很有用<code>Validator</code>在DataBinder实例上本地配置。参见<a href="#validation-mvc-configuring">[validation-mvc-configuring]</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-mvc"><a class="anchor" href="#validation-mvc"></a> 3.7.4。Spring MVC 3验证</h4>
<div class="paragraph">
<p>参见Spring MVC一章中的<a href="web.html#mvc-config-validation">验证</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions"><a class="anchor" href="#expressions"></a> 4。 Spring Expression Language （SpEL）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring表达式语言（简称“ SpEL”）是一种功能强大的表达式语言，支持在运行时查询和操作对象图。语言语法与Unified EL相似，但提供了其他功能，最著名的是方法调用和基本的字符串模板功能。</p>
</div>
<div class="paragraph">
<p>尽管还有其他几种Java表达式语言可用-OGNL，MVEL和JBoss EL，仅举几例-Spring Expression Language的创建是为了向Spring社区提供一种受良好支持的表达式语言，该语言可用于该版本中的所有产品。春季投资组合。它的语言功能受Spring产品组合中项目的要求驱动，包括基于Eclipse的Spring Tool Suite中代码完成支持的工具要求。也就是说，SpEL基于与技术无关的API，如果需要，可以将其他表达语言实现集成在一起。</p>
</div>
<div class="paragraph">
<p>虽然SpEL是Spring产品组合中表达评估的基础，但它并不直接与Spring绑定，可以独立使用。为了自成一体，本章中的许多示例都将SpEL用作独立的表达语言。这需要创建一些自举基础结构类，例如解析器。Spring的大多数用户不需要处理这种基础结构，而只能编写表达式字符串进行评估。这种典型用法的一个示例是将SpEL集成到创建XML或基于注释的Bean定义中，如<a href="#expressions-beandef">Expression对定义Bean定义的支持</a>所示。</p>
</div>
<div class="paragraph">
<p>本章介绍了表达语言，其API和语言语法的功能。在几个地方<code>Inventor</code>和<code>Society</code>类用作表达式评估的目标对象。这些类声明和用于填充它们的数据在本章末尾列出。</p>
</div>
<div class="paragraph">
<p>表达式语言支持以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>文字表达</p>
</li>
<li>
<p>布尔运算符和关系运算符</p>
</li>
<li>
<p>常用表达</p>
</li>
<li>
<p>类表达式</p>
</li>
<li>
<p>访问属性，数组，列表和映射</p>
</li>
<li>
<p>方法调用</p>
</li>
<li>
<p>关系运算符</p>
</li>
<li>
<p>分配</p>
</li>
<li>
<p>调用构造函数</p>
</li>
<li>
<p>Bean参考</p>
</li>
<li>
<p>阵列构造</p>
</li>
<li>
<p>内联列表</p>
</li>
<li>
<p>内联地图</p>
</li>
<li>
<p>三元运算符</p>
</li>
<li>
<p>变数</p>
</li>
<li>
<p>用户定义的功能</p>
</li>
<li>
<p>集合投影</p>
</li>
<li>
<p>选集</p>
</li>
<li>
<p>模板表达式</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="expressions-evaluation"><a class="anchor" href="#expressions-evaluation"></a> 4.1。评价</h3>
<div class="paragraph">
<p>本节介绍SpEL接口及其表达语言的简单用法。完整的语言参考可以在<a href="#expressions-language-ref">语言参考中</a>找到。</p>
</div>
<div class="paragraph">
<p>以下代码介绍了SpEL API来评估文字字符串表达式， <code>Hello World</code> 。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'"); <i class="conum" data-value="1"></i><b>(1)</b>
String message = (String) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>消息变量的值为<code>'Hello World'</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val exp = parser.parseExpression("'Hello World'") <i class="conum" data-value="1"></i><b>(1)</b>
val message = exp.value as String</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>消息变量的值为<code>'Hello World'</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您最可能使用的SpEL类和接口位于<code>org.springframework.expression</code>包及其子包，例如<code>spel.support</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>ExpressionParser</code>接口负责解析表达式字符串。在前面的示例中，表达式字符串是由周围的单引号表示的字符串文字。的<code>Expression</code>接口负责评估先前定义的表达式字符串。可以抛出两个异常， <code>ParseException</code>和<code>EvaluationException</code> ，打电话时<code>parser.parseExpression</code>和<code>exp.getValue</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>SpEL支持多种功能，例如调用方法，访问属性和调用构造函数。</p>
</div>
<div class="paragraph">
<p>在以下方法调用示例中，我们将<code>concat</code>字符串文字上的方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'.concat('!')"); <i class="conum" data-value="1"></i><b>(1)</b>
String message = (String) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的价值<code>message</code>现在是“ Hello World！'。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val exp = parser.parseExpression("'Hello World'.concat('!')") <i class="conum" data-value="1"></i><b>(1)</b>
val message = exp.value as String</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的价值<code>message</code>现在是“ Hello World！'。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下调用JavaBean属性的示例调用<code>String</code>属性<code>Bytes</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes()'
Expression exp = parser.parseExpression("'Hello World'.bytes"); <i class="conum" data-value="1"></i><b>(1)</b>
byte[] bytes = (byte[]) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>此行将文字转换为字节数组。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()

// invokes 'getBytes()'
val exp = parser.parseExpression("'Hello World'.bytes") <i class="conum" data-value="1"></i><b>(1)</b>
val bytes = exp.value as ByteArray</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>此行将文字转换为字节数组。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>SpEL还通过使用标准的点表示法（例如， <code>prop1.prop2.prop3</code> ）以及相应的属性值设置。也可以访问公共字段。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用点表示法获取文字的长度：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression("'Hello World'.bytes.length"); <i class="conum" data-value="1"></i><b>(1)</b>
int length = (Integer) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>'Hello World'.bytes.length</code>给出文字的长度。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()

// invokes 'getBytes().length'
val exp = parser.parseExpression("'Hello World'.bytes.length") <i class="conum" data-value="1"></i><b>(1)</b>
val length = exp.value as Int</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>'Hello World'.bytes.length</code>给出文字的长度。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以调用String的构造函数，而不是使用字符串文字，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("new String('hello world').toUpperCase()"); <i class="conum" data-value="1"></i><b>(1)</b>
String message = exp.getValue(String.class);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>构造一个新的<code>String</code>从字面上看并使其变为大写。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val exp = parser.parseExpression("new String('hello world').toUpperCase()")  <i class="conum" data-value="1"></i><b>(1)</b>
val message = exp.getValue(String::class.java)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>构造一个新的<code>String</code>从字面上看并使其变为大写。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>注意通用方法的使用： <code>public <T> T getValue(Class<T> desiredResultType)</code> 。使用此方法无需将表达式的值强制转换为所需的结果类型。一个<code>EvaluationException</code>如果无法将值强制转换为类型，则抛出该异常<code>T</code>或使用注册的类型转换器进行转换。</p>
</div>
<div class="paragraph">
<p>SpEL的更常见用法是提供一个针对特定对象实例（称为根对象）进行评估的表达式字符串。以下示例显示了如何检索<code>name</code>实例的属性<code>Inventor</code>类或创建布尔条件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression("name"); // Parse name as an expression
String name = (String) exp.getValue(tesla);
// name == "Nikola Tesla"

exp = parser.parseExpression("name == 'Nikola Tesla'");
boolean result = exp.getValue(tesla, Boolean.class);
// result == true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Create and set a calendar
val c = GregorianCalendar()
c.set(1856, 7, 9)

// The constructor arguments are name, birthday, and nationality.
val tesla = Inventor("Nikola Tesla", c.time, "Serbian")

val parser = SpelExpressionParser()

var exp = parser.parseExpression("name") // Parse name as an expression
val name = exp.getValue(tesla) as String
// name == "Nikola Tesla"

exp = parser.parseExpression("name == 'Nikola Tesla'")
val result = exp.getValue(tesla, Boolean::class.java)
// result == true</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="expressions-evaluation-context"><a class="anchor" href="#expressions-evaluation-context"></a> 4.1.1。理解<code>EvaluationContext</code></h4>
<div class="paragraph">
<p>的<code>EvaluationContext</code>在评估表达式以解析属性，方法或字段并帮助执行类型转换时，使用interface。Spring提供了两种实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SimpleEvaluationContext</code> ：针对不需要全部SpEL语言语法范围且应受到有意义限制的表达式类别，公开了SpEL基本语言功能和配置选项的子集。示例包括但不限于数据绑定表达式和基于属性的过滤器。</p>
</li>
<li>
<p><code>StandardEvaluationContext</code> ：公开全部SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SimpleEvaluationContext</code>设计为仅支持SpEL语言语法的子集。它不包括Java类型引用，构造函数和Bean引用。它还要求您明确选择对表达式中的属性和方法的支持级别。默认情况下， <code>create()</code>静态工厂方法仅允许对属性的读取访问。您还可以获取构建器来配置所需的确切支持级别，并针对以下一种或某种组合：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自订<code>PropertyAccessor</code>仅（无反射）</p>
</li>
<li>
<p>只读访问的数据绑定属性</p>
</li>
<li>
<p>读写的数据绑定属性</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="expressions-type-conversion"><a class="anchor" href="#expressions-type-conversion"></a>类型转换</h5>
<div class="paragraph">
<p>默认情况下，SpEL使用Spring核心（ <code>org.springframework.core.convert.ConversionService</code> ）。此转换服务随附有许多用于常见转换的内置转换器，但它也是完全可扩展的，因此您可以在类型之间添加自定义转换。此外，它是泛型感知的。这意味着，当您在表达式中使用泛型类型时，SpEL会尝试进行转换以维护遇到的任何对象的类型正确性。</p>
</div>
<div class="paragraph">
<p>实际上这是什么意思？假设使用<code>setValue()</code> ，用于设置<code>List</code>属性。该属性的类型实际上是<code>List<Boolean></code> 。SpEL认识到列表中的元素需要转换为<code>Boolean</code>在放入之前。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class Simple {
    public List&lt;Boolean&gt; booleanList = new ArrayList&lt;Boolean&gt;();
}

Simple simple = new Simple();
simple.booleanList.add(true);

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// "false" is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
parser.parseExpression("booleanList[0]").setValue(context, simple, "false");

// b is false
Boolean b = simple.booleanList.get(0);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Simple {
    var booleanList: MutableList&lt;Boolean&gt; = ArrayList()
}

val simple = Simple()
simple.booleanList.add(true)

val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

// "false" is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
parser.parseExpression("booleanList[0]").setValue(context, simple, "false")

// b is false
val b = simple.booleanList[0]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-parser-configuration"><a class="anchor" href="#expressions-parser-configuration"></a> 4.1.2。解析器配置</h4>
<div class="paragraph">
<p>可以使用解析器配置对象来配置SpEL表达式解析器（ <code>org.springframework.expression.spel.SpelParserConfiguration</code> ）。配置对象控制某些表达式组件的行为。例如，如果您索引到数组或集合中，并且指定索引处的元素是<code>null</code> ，您可以自动创建元素。当使用由属性引用链组成的表达式时，这很有用。如果您索引到数组或列表中并指定的索引超出了数组或列表当前大小的末尾，则可以自动增长数组或列表以容纳该索引。下面的示例演示如何自动增加列表：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class Demo {
    public List&lt;String&gt; list;
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
SpelParserConfiguration config = new SpelParserConfiguration(true,true);

ExpressionParser parser = new SpelExpressionParser(config);

Expression expression = parser.parseExpression("list[3]");

Demo demo = new Demo();

Object o = expression.getValue(demo);

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Demo {
    var list: List&lt;String&gt;? = null
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
val config = SpelParserConfiguration(true, true)

val parser = SpelExpressionParser(config)

val expression = parser.parseExpression("list[3]")

val demo = Demo()

val o = expression.getValue(demo)

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-spel-compilation"><a class="anchor" href="#expressions-spel-compilation"></a> 4.1.3。SpEL编译</h4>
<div class="paragraph">
<p>Spring Framework 4.1包含一个基本的表达式编译器。通常对表达式进行解释，这在评估过程中提供了很大的动态灵活性，但没有提供最佳性能。对于偶尔使用表达式，这很好，但是，当与其他组件（例如Spring Integration）一起使用时，性能可能非常重要，并且不需要动态性。</p>
</div>
<div class="paragraph">
<p>SpEL编译器旨在满足这一需求。在评估过程中，编译器生成一个Java类，该类体现了运行时的表达式行为，并使用该类来实现更快的表达式评估。由于缺少在表达式周围输入内容的信息，因此编译器在执行编译时会使用在表达式的解释求值过程中收集的信息。例如，它不仅仅从表达式中就知道属性引用的类型，而是在第一次解释求值时就知道它是什么。当然，如果各种表达元素的类型随时间变化，则基于此类派生信息进行编译会在以后引起麻烦。因此，编译最适合类型信息在重复求值时不会改变的表达式。</p>
</div>
<div class="paragraph">
<p>考虑以下基本表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>someArray[0].someProperty.someOtherProperty &lt; 0.1</pre>
</div>
</div>
<div class="paragraph">
<p>由于前面的表达式涉及数组访问，一些属性取消引用和数字运算，因此性能提升可能非常明显。在一个示例中，进行了50000次迭代的微基准测试，使用解释器评估需要75毫秒，而使用表达式的编译版本仅需要3毫秒。</p>
</div>
<div class="sect4">
<h5 id="expressions-compiler-configuration"><a class="anchor" href="#expressions-compiler-configuration"></a>编译器配置</h5>
<div class="paragraph">
<p>默认情况下不打开编译器，但是您可以通过两种不同的方式之一来打开它。当SpEL用法嵌入到另一个组件中时，可以使用解析器配置过程（ <a href="#expressions-parser-configuration">如前所述</a> ）或使用系统属性来打开它。本节讨论这两个选项。</p>
</div>
<div class="paragraph">
<p>编译器可以三种模式之一运行，这三种模式在<code>org.springframework.expression.spel.SpelCompilerMode</code>枚举。模式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OFF</code> （默认）：编译器已关闭。</p>
</li>
<li>
<p><code>IMMEDIATE</code> ：在立即模式下，将尽快编译表达式。通常是在第一次解释评估之后。如果编译的表达式失败（通常是由于类型更改，如前所述），则表达式求值的调用者将收到异常。</p>
</li>
<li>
<p><code>MIXED</code> ：在混合模式下，表达式会随着时间静默在解释模式和编译模式之间切换。经过一定数量的解释运行后，它们会切换到编译形式，如果编译形式出了问题（例如，如前面所述的类型更改），则表达式会自动再次切换回解释形式。稍后，它可能会生成另一个已编译的表单并切换到该表单。基本上，用户进入的例外<code>IMMEDIATE</code>而是在内部处理模式。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>IMMEDIATE</code>存在模式是因为<code>MIXED</code>模式可能会导致具有副作用的表达式出现问题。如果已编译的表达式在部分成功后就崩溃了，则它可能已经完成了影响系统状态的操作。如果发生这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能运行了两次。</p>
</div>
<div class="paragraph">
<p>选择模式后，使用<code>SpelParserConfiguration</code>配置解析器。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
    this.getClass().getClassLoader());

SpelExpressionParser parser = new SpelExpressionParser(config);

Expression expr = parser.parseExpression("payload");

MyMessage message = new MyMessage();

Object payload = expr.getValue(message);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val config = SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
        this.javaClass.classLoader)

val parser = SpelExpressionParser(config)

val expr = parser.parseExpression("payload")

val message = MyMessage()

val payload = expr.getValue(message)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当指定编译器模式时，还可以指定一个类加载器（允许传递null）。编译的表达式在提供的任何子类加载器中定义。重要的是要确保，如果指定了类加载器，则它可以查看表达式求值过程中涉及的所有类型。如果未指定类加载器，则使用默认的类加载器（通常是在表达式求值期间运行的线程的上下文类加载器）。</p>
</div>
<div class="paragraph">
<p>第二种配置编译器的方法是将SpEL嵌入到其他组件中，并且可能无法通过配置对象进行配置。在这些情况下，可以使用系统属性。您可以设置<code>spring.expression.compiler.mode</code>财产之一<code>SpelCompilerMode</code>枚举值（ <code>off</code> ， <code>immediate</code> ， 要么<code>mixed</code> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-compiler-limitations"><a class="anchor" href="#expressions-compiler-limitations"></a>编译器限制</h5>
<div class="paragraph">
<p>从Spring Framework 4.1开始，已经有了基本的编译框架。但是，该框架尚不支持编译每种表达式。最初的重点是可能在性能关键型上下文中使用的通用表达式。目前无法编译以下类型的表达式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>涉及赋值的表达</p>
</li>
<li>
<p>表达式依赖转换服务</p>
</li>
<li>
<p>使用自定义解析器或访问器的表达式</p>
</li>
<li>
<p>使用选择或投影的表达式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将来会编译更多类型的表达。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-beandef"><a class="anchor" href="#expressions-beandef"></a> 4.2。Bean定义中的表达式</h3>
<div class="paragraph">
<p>您可以将SpEL表达式与基于XML或基于注解的配置元数据一起使用来定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法都采用以下形式： <code>#{ <expression string> }</code> 。</p>
</div>
<div class="sect3">
<h4 id="expressions-beandef-xml-based"><a class="anchor" href="#expressions-beandef-xml-based"></a> 4.2.1。XML配置</h4>
<div class="paragraph">
<p>可以使用表达式来设置属性或构造函数参数值，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt;
    &lt;property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>systemProperties</code>变量是预定义的，因此您可以在表达式中使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="taxCalculator" class="org.spring.samples.TaxCalculator"&gt;
    &lt;property name="defaultLocale" value="#{ systemProperties['user.region'] }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您不必在预定义变量的前面加上<code>#</code>在这种情况下的符号。</p>
</div>
<div class="paragraph">
<p>您还可以按名称引用其他bean属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt;
    &lt;property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;

&lt;bean id="shapeGuess" class="org.spring.samples.ShapeGuess"&gt;
    &lt;property name="initialShapeSeed" value="#{ numberGuess.randomNumber }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-beandef-annotation-based"><a class="anchor" href="#expressions-beandef-annotation-based"></a> 4.2.2。注释配置</h4>
<div class="paragraph">
<p>要指定默认值，您可以将<code>@Value</code>字段，方法以及方法或构造函数参数上的注释。</p>
</div>
<div class="paragraph">
<p>下面的示例设置字段变量的默认值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class FieldValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    private String defaultLocale;

    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class FieldValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    var defaultLocale: String? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了等效的但使用属性设置器方法的示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PropertyValueTestBean {

    private String defaultLocale;

    @Value("#{ systemProperties['user.region'] }")
    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PropertyValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    var defaultLocale: String? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自动连线的方法和构造函数也可以使用<code>@Value</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleMovieLister {

    private MovieFinder movieFinder;
    private String defaultLocale;

    @Autowired
    public void configure(MovieFinder movieFinder,
            @Value("#{ systemProperties['user.region'] }") String defaultLocale) {
        this.movieFinder = movieFinder;
        this.defaultLocale = defaultLocale;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleMovieLister {

    private lateinit var movieFinder: MovieFinder
    private lateinit var defaultLocale: String

    @Autowired
    fun configure(movieFinder: MovieFinder,
                @Value("#{ systemProperties['user.region'] }") defaultLocale: String) {
        this.movieFinder = movieFinder
        this.defaultLocale = defaultLocale
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MovieRecommender {

    private String defaultLocale;

    private CustomerPreferenceDao customerPreferenceDao;

    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
            @Value("#{systemProperties['user.country']}") String defaultLocale) {
        this.customerPreferenceDao = customerPreferenceDao;
        this.defaultLocale = defaultLocale;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MovieRecommender(private val customerPreferenceDao: CustomerPreferenceDao,
            @Value("#{systemProperties['user.country']}") private val defaultLocale: String) {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-language-ref"><a class="anchor" href="#expressions-language-ref"></a> 4.3。语言参考</h3>
<div class="paragraph">
<p>本节描述了Spring Expression Language的工作方式。它涵盖以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#expressions-ref-literal">文字表达</a></p>
</li>
<li>
<p><a href="#expressions-properties-arrays">属性，数组，列表，映射和索引器</a></p>
</li>
<li>
<p><a href="#expressions-inline-lists">内联列表</a></p>
</li>
<li>
<p><a href="#expressions-inline-maps">内联地图</a></p>
</li>
<li>
<p><a href="#expressions-array-construction">阵列构造</a></p>
</li>
<li>
<p><a href="#expressions-methods">方法</a></p>
</li>
<li>
<p><a href="#expressions-operators">经营者</a></p>
</li>
<li>
<p><a href="#expressions-types">种类</a></p>
</li>
<li>
<p><a href="#expressions-constructors">建设者</a></p>
</li>
<li>
<p><a href="#expressions-ref-variables">变数</a></p>
</li>
<li>
<p><a href="#expressions-ref-functions">功能</a></p>
</li>
<li>
<p><a href="#expressions-bean-references">Bean参考</a></p>
</li>
<li>
<p><a href="#expressions-operator-ternary">三元运算符（If-Then-Else）</a></p>
</li>
<li>
<p><a href="#expressions-operator-elvis">猫王算子</a></p>
</li>
<li>
<p><a href="#expressions-operator-safe-navigation">安全导航操作员</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="expressions-ref-literal"><a class="anchor" href="#expressions-ref-literal"></a> 4.3.1。文字表达</h4>
<div class="paragraph">
<p>支持的文字表达式的类型为字符串，数值（int，实数，十六进制），布尔值和null。字符串由单引号引起来。要将单引号本身放在字符串中，请使用两个单引号字符。</p>
</div>
<div class="paragraph">
<p>以下清单显示了文字的简单用法。通常，它们不是像这样孤立地使用，而是作为更复杂的表达式的一部分使用-例如，在逻辑比较运算符的一侧使用文字。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();

// evals to "Hello World"
String helloWorld = (String) parser.parseExpression("'Hello World'").getValue();

double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue();

// evals to 2147483647
int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();

boolean trueValue = (Boolean) parser.parseExpression("true").getValue();

Object nullValue = parser.parseExpression("null").getValue();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()

// evals to "Hello World"
val helloWorld = parser.parseExpression("'Hello World'").value as String

val avogadrosNumber = parser.parseExpression("6.0221415E+23").value as Double

// evals to 2147483647
val maxValue = parser.parseExpression("0x7FFFFFFF").value as Int

val trueValue = parser.parseExpression("true").value as Boolean

val nullValue = parser.parseExpression("null").value</code></pre>
</div>
</div>
<div class="paragraph">
<p>数字支持使用负号，指数符号和小数点。默认情况下，使用Double.parseDouble（）解析实数。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-properties-arrays"><a class="anchor" href="#expressions-properties-arrays"></a> 4.3.2。属性，数组，列表，映射和索引器</h4>
<div class="paragraph">
<p>使用属性引用进行导航很容易。为此，请使用句点来指示嵌套的属性值。的实例<code>Inventor</code>类， <code>pupin</code>和<code>tesla</code> ， <a href="#expressions-example-classes">使用示例</a>部分中<a href="#expressions-example-classes">使用</a>的<a href="#expressions-example-classes">类中</a>列出的数据填充。要向下导航并获取特斯拉的出生年份和普平的出生城市，我们使用以下表达式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// evals to 1856
int year = (Integer) parser.parseExpression("Birthdate.Year + 1900").getValue(context);

String city = (String) parser.parseExpression("placeOfBirth.City").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// evals to 1856
val year = parser.parseExpression("Birthdate.Year + 1900").getValue(context) as Int

val city = parser.parseExpression("placeOfBirth.City").getValue(context) as String</code></pre>
</div>
</div>
<div class="paragraph">
<p>属性名称的首字母允许不区分大小写。数组和列表的内容通过使用方括号表示法获得，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// Inventions Array

// evaluates to "Induction motor"
String invention = parser.parseExpression("inventions[3]").getValue(
        context, tesla, String.class);

// Members List

// evaluates to "Nikola Tesla"
String name = parser.parseExpression("Members[0].Name").getValue(
        context, ieee, String.class);

// List and Array navigation
// evaluates to "Wireless communication"
String invention = parser.parseExpression("Members[0].Inventions[6]").getValue(
        context, ieee, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

// Inventions Array

// evaluates to "Induction motor"
val invention = parser.parseExpression("inventions[3]").getValue(
        context, tesla, String::class.java)

// Members List

// evaluates to "Nikola Tesla"
val name = parser.parseExpression("Members[0].Name").getValue(
        context, ieee, String::class.java)

// List and Array navigation
// evaluates to "Wireless communication"
val invention = parser.parseExpression("Members[0].Inventions[6]").getValue(
        context, ieee, String::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在方括号内指定文字键值可以获取映射的内容。在以下示例中，因为<code>Officers</code> map是字符串，我们可以指定字符串文字：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Officer's Dictionary

Inventor pupin = parser.parseExpression("Officers['president']").getValue(
        societyContext, Inventor.class);

// evaluates to "Idvor"
String city = parser.parseExpression("Officers['president'].PlaceOfBirth.City").getValue(
        societyContext, String.class);

// setting values
parser.parseExpression("Officers['advisors'][0].PlaceOfBirth.Country").setValue(
        societyContext, "Croatia");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Officer's Dictionary

val pupin = parser.parseExpression("Officers['president']").getValue(
        societyContext, Inventor::class.java)

// evaluates to "Idvor"
val city = parser.parseExpression("Officers['president'].PlaceOfBirth.City").getValue(
        societyContext, String::class.java)

// setting values
parser.parseExpression("Officers['advisors'][0].PlaceOfBirth.Country").setValue(
        societyContext, "Croatia")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-lists"><a class="anchor" href="#expressions-inline-lists"></a> 4.3.3。内联列表</h4>
<div class="paragraph">
<p>您可以使用来直接在表达式中表达列表<code>{}</code>符号。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// evaluates to a Java list containing the four numbers
List numbers = (List) parser.parseExpression("{1,2,3,4}").getValue(context);

List listOfLists = (List) parser.parseExpression("{{'a','b'},{'x','y'}}").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// evaluates to a Java list containing the four numbers
val numbers = parser.parseExpression("{1,2,3,4}").getValue(context) as List&lt;*&gt;

val listOfLists = parser.parseExpression("{{'a','b'},{'x','y'}}").getValue(context) as List&lt;*&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{}</code>本身意味着一个空列表。出于性能原因，如果列表本身完全由固定文字组成，则会创建一个常量列表来表示该表达式（而不是在每次求值时都建立一个新列表）。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-maps"><a class="anchor" href="#expressions-inline-maps"></a> 4.3.4。内联地图</h4>
<div class="paragraph">
<p>您还可以使用来直接在表达式中表达地图<code>{key:value}</code>符号。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// evaluates to a Java map containing the two entries
Map inventorInfo = (Map) parser.parseExpression("{name:'Nikola',dob:'10-July-1856'}").getValue(context);

Map mapOfMaps = (Map) parser.parseExpression("{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// evaluates to a Java map containing the two entries
val inventorInfo = parser.parseExpression("{name:'Nikola',dob:'10-July-1856'}").getValue(context) as Map&lt;*, <strong>&gt;

val mapOfMaps = parser.parseExpression("{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}").getValue(context) as Map&lt;</strong>, *&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{:}</code>本身意味着一个空的地图。出于性能方面的考虑，如果映射图本身由固定的文字或其他嵌套的常量结构（列表或映射图）组成，则会创建一个常量映射图来表示该表达式（而不是在每次求值时都构建一个新的映射图）。映射键的引用是可选的。上面的示例不使用带引号的键。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-array-construction"><a class="anchor" href="#expressions-array-construction"></a> 4.3.5。阵列构造</h4>
<div class="paragraph">
<p>您可以使用熟悉的Java语法来构建数组，可以选择提供一个初始化程序，以在构造时填充该数组。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">int[] numbers1 = (int[]) parser.parseExpression("new int[4]").getValue(context);

// Array with initializer
int[] numbers2 = (int[]) parser.parseExpression("new int[]{1,2,3}").getValue(context);

// Multi dimensional array
int[][] numbers3 = (int[][]) parser.parseExpression("new int[4][5]").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val numbers1 = parser.parseExpression("new int[4]").getValue(context) as IntArray

// Array with initializer
val numbers2 = parser.parseExpression("new int[]{1,2,3}").getValue(context) as IntArray

// Multi dimensional array
val numbers3 = parser.parseExpression("new int[4][5]").getValue(context) as Array&lt;IntArray&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>构造多维数组时，当前无法提供初始化程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-methods"><a class="anchor" href="#expressions-methods"></a> 4.3.6。方法</h4>
<div class="paragraph">
<p>您可以使用典型的Java编程语法来调用方法。您还可以在文字上调用方法。还支持变量参数。下面的示例演示如何调用方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// string literal, evaluates to "bc"
String bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String.class);

// evaluates to true
boolean isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(
        societyContext, Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// string literal, evaluates to "bc"
val bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String::class.java)

// evaluates to true
val isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(
        societyContext, Boolean::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operators"><a class="anchor" href="#expressions-operators"></a> 4.3.7。经营者</h4>
<div class="paragraph">
<p>Spring表达式语言支持以下几种运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#expressions-operators-relational">关系运算符</a></p>
</li>
<li>
<p><a href="#expressions-operators-logical">逻辑运算符</a></p>
</li>
<li>
<p><a href="#expressions-operators-mathematical">数学运算符</a></p>
</li>
<li>
<p><a href="#expressions-assignment">赋值运算符</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="expressions-operators-relational"><a class="anchor" href="#expressions-operators-relational"></a>关系运算符</h5>
<div class="paragraph">
<p>使用标准运算符表示法支持关系运算符（等于，不等于，小于，小于或等于，大于和大于或等于）。以下清单显示了一些运算符示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// evaluates to true
boolean trueValue = parser.parseExpression("2 == 2").getValue(Boolean.class);

// evaluates to false
boolean falseValue = parser.parseExpression("2 &lt; -5.0").getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression("'black' &lt; 'block'").getValue(Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// evaluates to true
val trueValue = parser.parseExpression("2 == 2").getValue(Boolean::class.java)

// evaluates to false
val falseValue = parser.parseExpression("2 &lt; -5.0").getValue(Boolean::class.java)

// evaluates to true
val trueValue = parser.parseExpression("'black' &lt; 'block'").getValue(Boolean::class.java)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>大于和小于比较<code>null</code>遵循一个简单的规则： <code>null</code>被视为无（不是零）。结果，任何其他值始终大于<code>null</code> （ <code>X > null</code>总是<code>true</code> ），并且没有其他任何值比不上（ <code>X < null</code>总是<code>false</code> ）。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢数字比较，请避免基于数字的比较<code>null</code>赞成与零进行比较（例如， <code>X > 0</code>要么<code>X < 0</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了标准的关系运算符外，SpEL还支持<code>instanceof</code>和基于正则表达式<code>matches</code>操作员。以下清单显示了两个示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// evaluates to false
boolean falseValue = parser.parseExpression(
        "'xyz' instanceof T(Integer)").getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(
        "'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);

//evaluates to false
boolean falseValue = parser.parseExpression(
        "'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// evaluates to false
val falseValue = parser.parseExpression(
        "'xyz' instanceof T(Integer)").getValue(Boolean::class.java)

// evaluates to true
val trueValue = parser.parseExpression(
        "'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean::class.java)

//evaluates to false
val falseValue = parser.parseExpression(
        "'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean::class.java)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">注意原始类型，因为它们会立即被包装为包装类型，因此<code>1 instanceof T(int)</code>评估为<code>false</code>而<code>1 instanceof T(Integer)</code>评估为<code>true</code> ，正如预期的那样。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每个符号运算符也可以指定为纯字母等效项。这样可以避免使用的符号对于嵌入表达式的文档类型（例如在XML文档中）具有特殊含义的问题。等效的文字是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lt</code> （ <code><</code> ）</p>
</li>
<li>
<p><code>gt</code> （ <code>></code> ）</p>
</li>
<li>
<p><code>le</code> （ <code><=</code> ）</p>
</li>
<li>
<p><code>ge</code> （ <code>>=</code> ）</p>
</li>
<li>
<p><code>eq</code> （ <code>==</code> ）</p>
</li>
<li>
<p><code>ne</code> （ <code>!=</code> ）</p>
</li>
<li>
<p><code>div</code> （ <code>/</code> ）</p>
</li>
<li>
<p><code>mod</code> （ <code>%</code> ）</p>
</li>
<li>
<p><code>not</code> （ <code>!</code> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有的文本运算符都不区分大小写。</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-logical"><a class="anchor" href="#expressions-operators-logical"></a>逻辑运算符</h5>
<div class="paragraph">
<p>SpEL支持以下逻辑运算符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>and</code></p>
</li>
<li>
<p><code>or</code></p>
</li>
<li>
<p><code>not</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用逻辑运算符</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// -- AND --

// evaluates to false
boolean falseValue = parser.parseExpression("true and false").getValue(Boolean.class);

// evaluates to true
String expression = "isMember('Nikola Tesla') and isMember('Mihajlo Pupin')";
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- OR --

// evaluates to true
boolean trueValue = parser.parseExpression("true or false").getValue(Boolean.class);

// evaluates to true
String expression = "isMember('Nikola Tesla') or isMember('Albert Einstein')";
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- NOT --

// evaluates to false
boolean falseValue = parser.parseExpression("!true").getValue(Boolean.class);

// -- AND and NOT --
String expression = "isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')";
boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// -- AND --

// evaluates to false
val falseValue = parser.parseExpression("true and false").getValue(Boolean::class.java)

// evaluates to true
val expression = "isMember('Nikola Tesla') and isMember('Mihajlo Pupin')"
val trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)

// -- OR --

// evaluates to true
val trueValue = parser.parseExpression("true or false").getValue(Boolean::class.java)

// evaluates to true
val expression = "isMember('Nikola Tesla') or isMember('Albert Einstein')"
val trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)

// -- NOT --

// evaluates to false
val falseValue = parser.parseExpression("!true").getValue(Boolean::class.java)

// -- AND and NOT --
val expression = "isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')"
val falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-mathematical"><a class="anchor" href="#expressions-operators-mathematical"></a>数学运算符</h5>
<div class="paragraph">
<p>您可以在数字和字符串上使用加法运算符。您只能对数字使用减法，乘法和除法运算符。您还可以使用模数（％）和指数幂（^）运算符。强制执行标准运算符优先级。以下示例显示了正在使用的数学运算符：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Addition
int two = parser.parseExpression("1 + 1").getValue(Integer.class);  // 2

String testString = parser.parseExpression(
        "'test' + ' ' + 'string'").getValue(String.class);  // 'test string'

// Subtraction
int four = parser.parseExpression("1 - -3").getValue(Integer.class);  // 4

double d = parser.parseExpression("1000.00 - 1e4").getValue(Double.class);  // -9000

// Multiplication
int six = parser.parseExpression("-2 * -3").getValue(Integer.class);  // 6

double twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(Double.class);  // 24.0

// Division
int minusTwo = parser.parseExpression("6 / -3").getValue(Integer.class);  // -2

double one = parser.parseExpression("8.0 / 4e0 / 2").getValue(Double.class);  // 1.0

// Modulus
int three = parser.parseExpression("7 % 4").getValue(Integer.class);  // 3

int one = parser.parseExpression("8 / 5 % 2").getValue(Integer.class);  // 1

// Operator precedence
int minusTwentyOne = parser.parseExpression("1+2-3*8").getValue(Integer.class);  // -21</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Addition
val two = parser.parseExpression("1 + 1").getValue(Int::class.java)  // 2

val testString = parser.parseExpression(
        "'test' + ' ' + 'string'").getValue(String::class.java)  // 'test string'

// Subtraction
val four = parser.parseExpression("1 - -3").getValue(Int::class.java)  // 4

val d = parser.parseExpression("1000.00 - 1e4").getValue(Double::class.java)  // -9000

// Multiplication
val six = parser.parseExpression("-2 * -3").getValue(Int::class.java)  // 6

val twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(Double::class.java)  // 24.0

// Division
val minusTwo = parser.parseExpression("6 / -3").getValue(Int::class.java)  // -2

val one = parser.parseExpression("8.0 / 4e0 / 2").getValue(Double::class.java)  // 1.0

// Modulus
val three = parser.parseExpression("7 % 4").getValue(Int::class.java)  // 3

val one = parser.parseExpression("8 / 5 % 2").getValue(Int::class.java)  // 1

// Operator precedence
val minusTwentyOne = parser.parseExpression("1+2-3*8").getValue(Int::class.java)  // -21</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-assignment"><a class="anchor" href="#expressions-assignment"></a>赋值运算符</h5>
<div class="paragraph">
<p>要设置属性，请使用赋值运算符（ <code>=</code> ）。这通常是在的调用中完成的<code>setValue</code>但也可以在<code>getValue</code> 。下面的清单显示了使用赋值运算符的两种方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Inventor inventor = new Inventor();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();

parser.parseExpression("Name").setValue(context, inventor, "Aleksandar Seovic");

// alternatively
String aleks = parser.parseExpression(
        "Name = 'Aleksandar Seovic'").getValue(context, inventor, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val inventor = Inventor()
val context = SimpleEvaluationContext.forReadWriteDataBinding().build()

parser.parseExpression("Name").setValue(context, inventor, "Aleksandar Seovic")

// alternatively
val aleks = parser.parseExpression(
        "Name = 'Aleksandar Seovic'").getValue(context, inventor, String::class.java)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-types"><a class="anchor" href="#expressions-types"></a> 4.3.8。种类</h4>
<div class="paragraph">
<p>您可以使用特殊<code>T</code>运算符，指定的实例<code>java.lang.Class</code> （类型）。静态方法也通过使用此运算符来调用。的<code>StandardEvaluationContext</code>使用一个<code>TypeLocator</code>查找类型，以及<code>StandardTypeLocator</code> （可以替换）的构建是基于对<code>java.lang</code>包。这意味着<code>T()</code>对类型的引用<code>java.lang</code>不需要完全合格，但是所有其他类型引用必须是完全合格的。以下示例显示了如何使用<code>T</code>操作员：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Class dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class.class);

Class stringClass = parser.parseExpression("T(String)").getValue(Class.class);

boolean trueValue = parser.parseExpression(
        "T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR")
        .getValue(Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class::class.java)

val stringClass = parser.parseExpression("T(String)").getValue(Class::class.java)

val trueValue = parser.parseExpression(
        "T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR")
        .getValue(Boolean::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-constructors"><a class="anchor" href="#expressions-constructors"></a> 4.3.9。建设者</h4>
<div class="paragraph">
<p>您可以使用来调用构造函数<code>new</code>操作员。除基本类型外，所有其他类型都应使用完全限定的类名（ <code>int</code> ， <code>float</code> ，等等）和字符串。以下示例显示了如何使用<code>new</code>运算符调用构造函数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Inventor einstein = p.parseExpression(
        "new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')")
        .getValue(Inventor.class);

//create new inventor instance within add method of List
p.parseExpression(
        "Members.add(new org.spring.samples.spel.inventor.Inventor(
            'Albert Einstein', 'German'))").getValue(societyContext);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val einstein = p.parseExpression(
        "new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')")
        .getValue(Inventor::class.java)

//create new inventor instance within add method of List
p.parseExpression(
        "Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))")
        .getValue(societyContext)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-variables"><a class="anchor" href="#expressions-ref-variables"></a> 4.3.10。变数</h4>
<div class="paragraph">
<p>您可以使用来引用表达式中的变量<code>#variableName</code>句法。变量是通过使用<code>setVariable</code>方法开启<code>EvaluationContext</code>实现。以下示例显示了如何使用变量：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Inventor tesla = new Inventor("Nikola Tesla", "Serbian");

EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable("newName", "Mike Tesla");

parser.parseExpression("Name = #newName").getValue(context, tesla);
System.out.println(tesla.getName())  // "Mike Tesla"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val tesla = Inventor("Nikola Tesla", "Serbian")

val context = SimpleEvaluationContext.forReadWriteDataBinding().build()
context.setVariable("newName", "Mike Tesla")

parser.parseExpression("Name = #newName").getValue(context, tesla)
println(tesla.name)  // "Mike Tesla"</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="expressions-this-root"><a class="anchor" href="#expressions-this-root"></a>的<code>#this</code>和<code>#root</code>变数</h5>
<div class="paragraph">
<p>的<code>#this</code>变量始终是定义的，并且指向当前的评估对象（针对不合格的引用将被解析）。的<code>#root</code>变量始终是定义的，并且指向根上下文对象。虽然<code>#this</code>可能会随着表达式的组成部分的评估而变化， <code>#root</code>总是指根。以下示例显示了如何使用<code>#this</code>和<code>#root</code>变量：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// create an array of integers
List&lt;Integer&gt; primes = new ArrayList&lt;Integer&gt;();
primes.addAll(Arrays.asList(2,3,5,7,11,13,17));

// create parser and set variable 'primes' as the array of integers
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess();
context.setVariable("primes", primes);

// all prime numbers &gt; 10 from the list (using selection ?{...})
// evaluates to [11, 13, 17]
List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(
        "#primes.?[#this&gt;10]").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// create an array of integers
val primes = ArrayList&lt;Int&gt;()
primes.addAll(listOf(2, 3, 5, 7, 11, 13, 17))

// create parser and set variable 'primes' as the array of integers
val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataAccess()
context.setVariable("primes", primes)

// all prime numbers &gt; 10 from the list (using selection ?{...})
// evaluates to [11, 13, 17]
val primesGreaterThanTen = parser.parseExpression(
        "#primes.?[#this&gt;10]").getValue(context) as List&lt;Int&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-functions"><a class="anchor" href="#expressions-ref-functions"></a> 4.3.11。功能</h4>
<div class="paragraph">
<p>您可以通过注册可以在表达式字符串中调用的用户定义函数来扩展SpEL。该功能通过<code>EvaluationContext</code> 。下面的示例显示如何注册用户定义的函数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Method method = ...;

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable("myFunction", method);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val method: Method = ...

val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()
context.setVariable("myFunction", method)</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，考虑以下用于反转字符串的实用程序方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class StringUtils {

    public static String reverseString(String input) {
        StringBuilder backwards = new StringBuilder(input.length());
        for (int i = 0; i &lt; input.length(); i++) {
            backwards.append(input.charAt(input.length() - 1 - i));
        }
        return backwards.toString();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun reverseString(input: String): String {
    val backwards = StringBuilder(input.length)
    for (i in 0 until input.length) {
        backwards.append(input[input.length - 1 - i])
    }
    return backwards.toString()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以注册并使用前面的方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable("reverseString",
        StringUtils.class.getDeclaredMethod("reverseString", String.class));

String helloWorldReversed = parser.parseExpression(
        "#reverseString('hello')").getValue(context, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()

val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()
context.setVariable("reverseString", ::reverseString::javaMethod)

val helloWorldReversed = parser.parseExpression(
        "#reverseString('hello')").getValue(context, String::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-bean-references"><a class="anchor" href="#expressions-bean-references"></a> 4.3.12。Bean参考</h4>
<div class="paragraph">
<p>如果已使用bean解析器配置了评估上下文，则可以使用来从表达式中查找bean。 <code>@</code>符号。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation
Object bean = parser.parseExpression("@something").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val context = StandardEvaluationContext()
context.setBeanResolver(MyBeanResolver())

// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation
val bean = parser.parseExpression("@something").getValue(context)</code></pre>
</div>
</div>
<div class="paragraph">
<p>要访问工厂Bean本身，应改为在Bean名称前添加一个<code>&</code>符号。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,"&amp;foo") on MyBeanResolver during evaluation
Object bean = parser.parseExpression("&amp;foo").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val context = StandardEvaluationContext()
context.setBeanResolver(MyBeanResolver())

// This will end up calling resolve(context,"&amp;foo") on MyBeanResolver during evaluation
val bean = parser.parseExpression("&amp;foo").getValue(context)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-ternary"><a class="anchor" href="#expressions-operator-ternary"></a> 4.3.13。三元运算符（If-Then-Else）</h4>
<div class="paragraph">
<p>您可以使用三元运算符在表达式内部执行if-then-else条件逻辑。以下清单显示了一个最小的示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String falseString = parser.parseExpression(
        "false ? 'trueExp' : 'falseExp'").getValue(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val falseString = parser.parseExpression(
        "false ? 'trueExp' : 'falseExp'").getValue(String::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，布尔值<code>false</code>导致返回字符串值<code>'falseExp'</code> 。一个更现实的示例如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">parser.parseExpression("Name").setValue(societyContext, "IEEE");
societyContext.setVariable("queryName", "Nikola Tesla");

expression = "isMember(#queryName)? #queryName + ' is a member of the ' " +
        "+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'";

String queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String.class);
// queryResultString = "Nikola Tesla is a member of the IEEE Society"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">parser.parseExpression("Name").setValue(societyContext, "IEEE")
societyContext.setVariable("queryName", "Nikola Tesla")

expression = "isMember(#queryName)? #queryName + ' is a member of the ' " + "+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'"

val queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String::class.java)
// queryResultString = "Nikola Tesla is a member of the IEEE Society"</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关三元运算符的更短语法，请参阅关于Elvis运算符的下一部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-elvis"><a class="anchor" href="#expressions-operator-elvis"></a> 4.3.14。猫王算子</h4>
<div class="paragraph">
<p>Elvis运算符是三元运算符语法的简化，并且在<a href="http://www.groovy-lang.org/operators.html#_elvis_operator">Groovy</a>语言中使用。使用三元运算符语法，通常必须将变量重复两次，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">String name = "Elvis Presley";
String displayName = (name != null ? name : "Unknown");</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，您可以使用Elvis运算符（以与Elvis的发型相似的方式命名）。以下示例显示了如何使用Elvis运算符：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();

String name = parser.parseExpression("name?:'Unknown'").getValue(String.class);
System.out.println(name);  // 'Unknown'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()

val name = parser.parseExpression("name?:'Unknown'").getValue(String::class.java)
println(name)  // 'Unknown'</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了一个更复杂的示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
String name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String.class);
System.out.println(name);  // Nikola Tesla

tesla.setName(null);
name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String.class);
System.out.println(name);  // Elvis Presley</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

val tesla = Inventor("Nikola Tesla", "Serbian")
var name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String::class.java)
println(name)  // Nikola Tesla

tesla.setName(null)
name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String::class.java)
println(name)  // Elvis Presley</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用Elvis运算符在表达式中应用默认值。以下示例显示了如何在<code>@Value</code>表达：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Value("#{systemProperties['pop3.port'] ?: 25}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将注入系统属性<code>pop3.port</code>如果已定义，则为25。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-safe-navigation"><a class="anchor" href="#expressions-operator-safe-navigation"></a> 4.3.15。安全导航操作员</h4>
<div class="paragraph">
<p>安全导航操作符用于避免<code>NullPointerException</code>并且来自<a href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator">Groovy</a>语言。通常，当您引用一个对象时，可能需要在访问该对象的方法或属性之前验证其是否为null。为了避免这种情况，安全导航运算符返回null而不是引发异常。下面的示例演示如何使用安全导航操作符：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
tesla.setPlaceOfBirth(new PlaceOfBirth("Smiljan"));

String city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String.class);
System.out.println(city);  // Smiljan

tesla.setPlaceOfBirth(null);
city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String.class);
System.out.println(city);  // null - does not throw NullPointerException!!!</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

val tesla = Inventor("Nikola Tesla", "Serbian")
tesla.setPlaceOfBirth(PlaceOfBirth("Smiljan"))

var city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String::class.java)
println(city)  // Smiljan

tesla.setPlaceOfBirth(null)
city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String::class.java)
println(city)  // null - does not throw NullPointerException!!!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-selection"><a class="anchor" href="#expressions-collection-selection"></a> 4.3.16。馆藏选择</h4>
<div class="paragraph">
<p>选择是一种强大的表达语言功能，可让您通过从源集合中进行选择来将其转换为另一个集合。</p>
</div>
<div class="paragraph">
<p>选择使用的语法<code>.?[selectionExpression]</code> 。它过滤集合并返回一个包含原始元素子集的新集合。例如，通过选择，我们可以轻松地获得塞尔维亚发明人的列表，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(
        "Members.?[Nationality == 'Serbian']").getValue(societyContext);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val list = parser.parseExpression(
        "Members.?[Nationality == 'Serbian']").getValue(societyContext) as List&lt;Inventor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在列表和地图上都可以选择。对于列表，将针对每个单独的列表元素评估选择标准。针对地图，针对每个地图条目（Java类型的对象）评估选择标准<code>Map.Entry</code> ）。每个地图条目都有其键和值，可作为属性访问以供选择。</p>
</div>
<div class="paragraph">
<p>以下表达式返回一个新地图，该地图由原始地图中输入值小于27的那些元素组成：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Map newMap = parser.parseExpression("map.?[value&lt;27]").getValue();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val newMap = parser.parseExpression("map.?[value&lt;27]").getValue()</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了返回所有选定的元素外，您只能检索第一个或最后一个值。要获得与所选内容匹配的第一个条目，语法为<code>.^[selectionExpression]</code> 。为了获得最后的匹配选择，语法为<code>.$[selectionExpression]</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-projection"><a class="anchor" href="#expressions-collection-projection"></a> 4.3.17。集合投影</h4>
<div class="paragraph">
<p>投影使集合可以驱动子表达式的求值，结果是一个新的集合。投影的语法是<code>.![projectionExpression]</code> 。例如，假设我们有一个发明家列表，但是想要他们出生的城市列表。实际上，我们希望为发明人列表中的每个条目评估“ placeOfBirth.city”。下面的示例使用投影来做到这一点：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// returns ['Smiljan', 'Idvor' ]
List placesOfBirth = (List)parser.parseExpression("Members.![placeOfBirth.city]");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// returns ['Smiljan', 'Idvor' ]
val placesOfBirth = parser.parseExpression("Members.![placeOfBirth.city]") as List&lt;*&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用地图来驱动投影，在这种情况下，将根据地图中的每个条目（以Java表示）来评估投影表达式<code>Map.Entry</code> ）。跨地图的投影结果是一个列表，其中包含针对每个地图条目的投影表达式的评估。</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-templating"><a class="anchor" href="#expressions-templating"></a> 4.3.18。表达式模板</h4>
<div class="paragraph">
<p>表达式模板允许将文字文本与一个或多个评估块混合。每个评估块均以您可以定义的前缀和后缀字符分隔。常见的选择是使用<code>#{ }</code>作为定界符，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String randomPhrase = parser.parseExpression(
        "random number is #{T(java.lang.Math).random()}",
        new TemplateParserContext()).getValue(String.class);

// evaluates to "random number is 0.7038186818312008"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val randomPhrase = parser.parseExpression(
        "random number is #{T(java.lang.Math).random()}",
        TemplateParserContext()).getValue(String::class.java)

// evaluates to "random number is 0.7038186818312008"</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过串联文字来评估字符串<code>'random number is '</code>计算表达式内部的表达式的结果<code>#{ }</code>定界符（在这种情况下，是调用<code>random()</code>方法）。第二个论点<code>parseExpression()</code>方法的类型<code>ParserContext</code> 。的<code>ParserContext</code>接口用于影响表达式的解析方式，以支持表达式模板功能。的定义<code>TemplateParserContext</code>如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class TemplateParserContext implements ParserContext {

    public String getExpressionPrefix() {
        return "#{";
    }

    public String getExpressionSuffix() {
        return "}";
    }

    public boolean isTemplate() {
        return true;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class TemplateParserContext : ParserContext {

    override fun getExpressionPrefix(): String {
        return "#{"
    }

    override fun getExpressionSuffix(): String {
        return "}"
    }

    override fun isTemplate(): Boolean {
        return true
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-example-classes"><a class="anchor" href="#expressions-example-classes"></a> 4.4。示例中使用的类</h3>
<div class="paragraph">
<p>本节列出了本章示例中使用的类。</p>
</div>
<div class="listingblock primary">
<div class="title">发明者。爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.spring.samples.spel.inventor;

import java.util.Date;
import java.util.GregorianCalendar;

public class Inventor {

    private String name;
    private String nationality;
    private String[] inventions;
    private Date birthdate;
    private PlaceOfBirth placeOfBirth;

    public Inventor(String name, String nationality) {
        GregorianCalendar c= new GregorianCalendar();
        this.name = name;
        this.nationality = nationality;
        this.birthdate = c.getTime();
    }

    public Inventor(String name, Date birthdate, String nationality) {
        this.name = name;
        this.nationality = nationality;
        this.birthdate = birthdate;
    }

    public Inventor() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNationality() {
        return nationality;
    }

    public void setNationality(String nationality) {
        this.nationality = nationality;
    }

    public Date getBirthdate() {
        return birthdate;
    }

    public void setBirthdate(Date birthdate) {
        this.birthdate = birthdate;
    }

    public PlaceOfBirth getPlaceOfBirth() {
        return placeOfBirth;
    }

    public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {
        this.placeOfBirth = placeOfBirth;
    }

    public void setInventions(String[] inventions) {
        this.inventions = inventions;
    }

    public String[] getInventions() {
        return inventions;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">发明家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Inventor(
    var name: String,
    var nationality: String,
    var inventions: Array&lt;String&gt;? = null,
    var birthdate: Date =  GregorianCalendar().time,
    var placeOfBirth: PlaceOfBirth? = null)</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">PlaceOfBirth.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.spring.samples.spel.inventor;

public class PlaceOfBirth {

    private String city;
    private String country;

    public PlaceOfBirth(String city) {
        this.city=city;
    }

    public PlaceOfBirth(String city, String country) {
        this(city);
        this.country = country;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String s) {
        this.city = s;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">出生地</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PlaceOfBirth(var city: String, var country: String? = null) {</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">社会.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.spring.samples.spel.inventor;

import java.util.*;

public class Society {

    private String name;

    public static String Advisors = "advisors";
    public static String President = "president";

    private List&lt;Inventor&gt; members = new ArrayList&lt;Inventor&gt;();
    private Map officers = new HashMap();

    public List getMembers() {
        return members;
    }

    public Map getOfficers() {
        return officers;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isMember(String name) {
        for (Inventor inventor : members) {
            if (inventor.getName().equals(name)) {
                return true;
            }
        }
        return false;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">社会</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.spring.samples.spel.inventor

import java.util.*

class Society {

    val Advisors = "advisors"
    val President = "president"

    var name: String? = null

    val members = ArrayList&lt;Inventor&gt;()
    val officers = mapOf&lt;Any, Any&gt;()

    fun isMember(name: String): Boolean {
        for (inventor in members) {
            if (inventor.name == name) {
                return true
            }
        }
        return false
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop"><a class="anchor" href="#aop"></a> 5，Spring面向切面的编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>面向切面的编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象的编程（OOP）。OOP中模块化的关键单元是类，而在AOP中模块化是方面。方面使关注点（例如事务管理）的模块化跨越了多个类型和对象。（这种关注在AOP文献中通常被称为“跨领域”关注。）</p>
</div>
<div class="paragraph">
<p>Spring的关键组件之一是AOP框架。尽管Spring IoC容器不依赖于AOP（这意味着您不需要使用AOP），但AOP是对Spring IoC的补充，以提供功能强大的中间件解决方案。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">具有AspectJ切入点的Spring AOP</div>
<div class="paragraph">
<p>Spring通过使用<a href="#aop-schema">基于模式的方法</a>或<a href="#aop-ataspectj">@AspectJ批注样式，</a>提供了编写自定义方面的简单而强大的方法。这两种样式都提供了完全类型化的建议，并使用了AspectJ切入点语言，同时仍使用Spring AOP进行编织。</p>
</div>
<div class="paragraph">
<p>本章讨论基于架构和基于@AspectJ的AOP支持。<a href="#aop-api">下一章</a>将讨论较低级别的AOP支持。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>AOP在Spring Framework 中用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供声明式企业服务。最重要的此类服务是<a href="data-access.html#transaction-declarative">声明式事务管理</a> 。</p>
</li>
<li>
<p>让用户实现自定义方面，并用AOP补充其对OOP的使用。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您只对通用声明性服务或其他预打包的声明性中间件服务（例如池）感兴趣，则无需直接使用Spring AOP，并且可以跳过本章的大部分内容。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="aop-introduction-defn"><a class="anchor" href="#aop-introduction-defn"></a> 5.1。AOP概念</h3>
<div class="paragraph">
<p>让我们首先定义一些主要的AOP概念和术语。这些术语不是特定于Spring的。不幸的是，AOP术语并不是特别直观。但是，如果使用Spring自己的术语，将会更加令人困惑。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方面：涉及多个类别的关注点的模块化。事务管理是企业Java应用程序中横切关注的一个很好的例子。在Spring AOP中，方面是通过使用常规类（ <a href="#aop-schema">基于模式的方法</a> ）或带有注释的常规类来实现的。 <code>@Aspect</code>批注（ <a href="#aop-ataspectj">@AspectJ样式</a> ）。</p>
</li>
<li>
<p>连接点：在程序执行过程中的一点，例如方法的执行或异常的处理。在Spring AOP中，连接点始终代表方法的执行。</p>
</li>
<li>
<p>建议：方面在特定的连接点处采取的操作。不同类型的建议包括“周围”，“之前”和“之后”建议。（建议类型将在后面讨论。）许多AOP框架（包括Spring）将建议建模为拦截器，并在连接点周围维护一系列拦截器。</p>
</li>
<li>
<p>切入点：与连接点匹配的谓词。建议与切入点表达式关联，并在与该切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。切入点表达式匹配的连接点的概念是AOP的核心，默认情况下，Spring使用AspectJ切入点表达语言。</p>
</li>
<li>
<p>简介：代表类型声明其他方法或字段。Spring AOP允许您向任何建议对象引入新的接口（和相应的实现）。例如，您可以使用简介来使Bean实现<code>IsModified</code>接口，以简化缓存。（在AspectJ社区中，介绍被称为类型间声明。）</p>
</li>
<li>
<p>目标对象：一个或多个方面建议的对象。也称为“建议对象”。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。</p>
</li>
<li>
<p>AOP代理：由AOP框架创建的一个对象，用于实现方面协定（建议方法执行等）。在Spring Framework中，AOP代理是JDK动态代理或CGLIB代理。</p>
</li>
<li>
<p>编织：将方面与其他应用程序类型或对象链接以创建建议的对象。这可以在编译时（例如，使用AspectJ编译器），加载时或在运行时完成。像其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring AOP包括以下类型的建议：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在建议之前：在连接点之前运行的建议，但是它不能阻止执行流程继续进行到连接点（除非它引发异常）。</p>
</li>
<li>
<p>返回建议后：在连接点正常完成后要运行的建议（例如，如果方法返回而没有引发异常）。</p>
</li>
<li>
<p>抛出建议后：如果方法因抛出异常而退出，则执行建议。</p>
</li>
<li>
<p>建议之后（最终）：无论连接点退出的方式如何（正常或特殊返回），均应执行建议。</p>
</li>
<li>
<p>围绕建议：围绕连接点的建议，例如方法调用。这是最有力的建议。周围建议可以在方法调用之前和之后执行自定义行为。它还负责选择是返回连接点还是通过返回其自身的返回值或引发异常来捷径建议的方法执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>围绕建议是最通用的建议。由于Spring AOP与AspectJ一样，提供了各种建议类型，因此我们建议您使用功能最弱的建议类型，以实现所需的行为。例如，如果您只需要使用方法的返回值更新缓存，则最好使用返回后的建议而不是周围的建议，尽管周围的建议可以完成相同的事情。使用最具体的建议类型可提供更简单的编程模型，并减少出错的可能性。例如，您不需要调用<code>proceed()</code>上的方法<code>JoinPoint</code>用于周围的建议，因此，您不能不调用它。</p>
</div>
<div class="paragraph">
<p>所有建议参数都是静态类型的，因此您可以使用适当类型的建议参数（例如，方法执行的返回值的类型），而不是<code>Object</code>数组。</p>
</div>
<div class="paragraph">
<p>切入点匹配的连接点的概念是AOP的关键，它与仅提供拦截功能的旧技术有所不同。切入点使建议的目标独立于面向对象的层次结构。例如，您可以将提供声明性事务管理的环绕建议应用于跨越多个对象（例如服务层中的所有业务操作）的一组方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-introduction-spring-defn"><a class="anchor" href="#aop-introduction-spring-defn"></a> 5.2。Spring AOP能力和目标</h3>
<div class="paragraph">
<p>Spring AOP是用纯Java实现的。不需要特殊的编译过程。Spring AOP不需要控制类加载器的层次结构，因此适合在Servlet容器或应用程序服务器中使用。</p>
</div>
<div class="paragraph">
<p>Spring AOP当前仅支持方法执行连接点（建议在Spring Bean上执行方法）。尽管可以在不破坏核心Spring AOP API的情况下添加对字段拦截的支持，但并未实现字段拦截。如果需要建议字段访问和更新连接点，请考虑使用诸如AspectJ之类的语言。</p>
</div>
<div class="paragraph">
<p>Spring AOP的AOP方法不同于大多数其他AOP框架。目的不是提供最完整的AOP实现（尽管Spring AOP相当强大）。相反，其目的是在AOP实现和Spring IoC之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。</p>
</div>
<div class="paragraph">
<p>因此，例如，通常将Spring Framework的AOP功能与Spring IoC容器结合使用。通过使用常规bean定义语法来配置方面（尽管这允许强大的“自动代理”功能）。这是与其他AOP实现的关键区别。使用Spring AOP不能轻松或高效地完成某些事情，例如建议非常细粒度的对象（通常是域对象）。在这种情况下，AspectJ是最佳选择。但是，我们的经验是，Spring AOP为AOP可以解决的企业Java应用程序中的大多数问题提供了出色的解决方案。</p>
</div>
<div class="paragraph">
<p>Spring AOP从未努力与AspectJ竞争以提供全面的AOP解决方案。我们认为，基于代理的框架（如Spring AOP）和成熟的框架（如AspectJ）都是有价值的，它们是互补的，而不是竞争。Spring无缝地将Spring AOP和IoC与AspectJ集成在一起，以在基于Spring的一致应用程序架构中支持AOP的所有使用。这种集成不会影响Spring AOP API或AOP Alliance API。 Spring AOP仍然向后兼容。请参阅<a href="#aop-api">下一章</a> ，以讨论Spring AOP API。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Framework 的中心宗旨之一是非侵入性。这是一个想法，您不应被迫将特定于框架的类和接口引入业务或域模型。但是，在某些地方，Spring Framework确实为您提供了将特定于Spring Framework的依赖项引入代码库的选项。提供此类选项的理由是，在某些情况下，以这种方式阅读或编码某些特定功能可能会变得更加容易。但是，Spring Framework （几乎）总是为您提供选择：您可以自由地就哪个选项最适合您的特定用例或场景做出明智的决定。</p>
</div>
<div class="paragraph">
<p>与本章相关的一种选择是选择哪种AOP框架（以及哪种AOP样式）。您可以选择AspectJ和/或Spring AOP。您也可以选择@AspectJ注释样式方法或Spring XML配置样式方法。本章选择首先介绍@AspectJ样式的方法这一事实不应被视为表明Spring团队比Spring XML配置样式更喜欢@AspectJ注释样式的方法。</p>
</div>
<div class="paragraph">
<p>有关每种样式的“为什么和为什么”的更完整讨论，请参见<a href="#aop-choosing">选择要使用的AOP声明样式</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="aop-introduction-proxies"><a class="anchor" href="#aop-introduction-proxies"></a> 5.3。AOP代理</h3>
<div class="paragraph">
<p>Spring AOP默认将标准JDK动态代理用于AOP代理。这使得可以代理任何接口（或一组接口）。</p>
</div>
<div class="paragraph">
<p>Spring AOP也可以使用CGLIB代理。这对于代理类而不是接口是必需的。默认情况下，如果业务对象未实现接口，则使用CGLIB。由于对接口而不是对类进行编程是一种好习惯，因此业务类通常实现一个或多个业务接口。在那些需要建议在接口上未声明的方法或需要将代理对象作为具体类型传递给方法的情况下（在极少数情况下），可以<a href="#aop-proxying">强制使用CGLIB</a> 。</p>
</div>
<div class="paragraph">
<p>掌握Spring AOP是基于代理的这一事实很重要。请参阅<a href="#aop-understanding-aop-proxies">了解AOP代理</a>以全面了解此实现细节的实际含义。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj"><a class="anchor" href="#aop-ataspectj"></a> 5.4。@AspectJ支持</h3>
<div class="paragraph">
<p>@AspectJ是一种将方面声明为带有注释的常规Java类的样式。@AspectJ样式是<a href="https://www.eclipse.org/aspectj">AspectJ项目</a>在AspectJ 5版本中引入的。Spring使用AspectJ提供的用于切入点解析和匹配的库来解释与AspectJ 5相同的注释。但是，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ编译器或编织器。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用AspectJ编译器和weaver可以使用完整的AspectJ语言，有关在<a href="#aop-using-aspectj">Spring Applications</a>中<a href="#aop-using-aspectj">使用AspectJ进行</a>了讨论。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="aop-aspectj-support"><a class="anchor" href="#aop-aspectj-support"></a> 5.4.1。启用@AspectJ支持</h4>
<div class="paragraph">
<p>要在Spring配置中使用@AspectJ方面，您需要启用Spring支持以基于@AspectJ方面配置Spring AOP，并根据这些方面是否建议对它们进行自动代理。通过自动代理，我们的意思是，如果Spring确定一个或多个方面建议使用bean，它将自动为该bean生成一个代理以拦截方法调用并确保按需执行建议。</p>
</div>
<div class="paragraph">
<p>可以使用XML或Java样式的配置来启用@AspectJ支持。无论哪种情况，您都需要确保AspectJ的<code>aspectjweaver.jar</code>库位于应用程序的类路径（版本1.8或更高版本）上。该库位于<code>lib</code> AspectJ分发目录或Maven Central存储库中。</p>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-java"><a class="anchor" href="#aop-enable-aspectj-java"></a>通过Java配置启用@AspectJ支持</h5>
<div class="paragraph">
<p>在Java中启用@AspectJ支持<code>@Configuration</code> ，添加<code>@EnableAspectJAutoProxy</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableAspectJAutoProxy
class AppConfig</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-xml"><a class="anchor" href="#aop-enable-aspectj-xml"></a>通过XML配置启用@AspectJ支持</h5>
<div class="paragraph">
<p>要通过基于XML的配置启用@AspectJ支持，请使用<code>aop:aspectj-autoproxy</code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspectj-autoproxy/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>假定您使用<a href="#xsd-schemas">基于XML Schema的配置中</a>所述的模式支持。请参阅<a href="#xsd-schemas-aop">AOP模式</a>以了解如何在<code>aop</code>命名空间。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-at-aspectj"><a class="anchor" href="#aop-at-aspectj"></a> 5.4.2。声明一个方面</h4>
<div class="paragraph">
<p>启用@AspectJ支持后，您的应用程序上下文中使用@AspectJ方面的类定义的任何bean（具有<code>@Aspect</code>注释）由Spring自动检测并用于配置Spring AOP。接下来的两个示例显示了一个不太有用的方面所需的最小定义。</p>
</div>
<div class="paragraph">
<p>这两个示例中的第一个示例显示了应用程序上下文中的常规bean定义，该定义指向具有以下内容的bean类： <code>@Aspect</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt;
    &lt;!-- configure properties of the aspect here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个示例中的第二个显示了<code>NotVeryUsefulAspect</code>类定义，该定义用<code>org.aspectj.lang.annotation.Aspect</code>注解;</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.xyz

import org.aspectj.lang.annotation.Aspect;

@Aspect
class NotVeryUsefulAspect</code></pre>
</div>
</div>
<div class="paragraph">
<p>方面（带有注释的类<code>@Aspect</code> ）可以具有与其他任何类相同的方法和字段。它们还可以包含切入点，建议和介绍（类型间）声明。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">通过组件扫描自动检测方面</div>您可以将方面类注册为Spring XML配置中的常规bean，也可以通过类路径扫描自动检测它们-与其他任何Spring管理的bean一样。但是，请注意<code>@Aspect</code>注释不足以在类路径中进行自动检测。为此，您需要添加一个单独的<code>@Component</code>注释（或者，或者，按照Spring的组件扫描程序的规则，有资格的自定义构造型注释）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="title">向其他方面提供建议？</div>在Spring AOP中，方面本身不能成为其他方面的建议目标。的<code>@Aspect</code>类上的注释将其标记为一个方面，因此将其从自动代理中排除。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts"><a class="anchor" href="#aop-pointcuts"></a> 5.4.3。声明切入点</h4>
<div class="paragraph">
<p>切入点确定了感兴趣的连接点，从而使我们能够控制何时执行建议。Spring AOP仅支持Spring Bean的方法执行连接点，因此您可以将切入点视为与Spring Bean上的方法执行相匹配。切入点声明有两个部分：一个包含名称和任何参数的签名，以及一个切入点表达式，该切入点表达式精确确定我们感兴趣的方法执行。在AOP的@AspectJ批注样式中，常规方法定义提供了切入点签名，并通过使用<code>@Pointcut</code>批注（用作切入点签名的方法必须具有<code>void</code>返回类型）。</p>
</div>
<div class="paragraph">
<p>一个示例可能有助于使切入点签名和切入点表达式之间的区别变得清晰。下面的示例定义一个名为<code>anyOldTransfer</code>匹配任何名为以下方法的执行<code>transfer</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Pointcut("execution(* transfer(..))") // the pointcut expression
private void anyOldTransfer() {} // the pointcut signature</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Pointcut("execution(* transfer(..))") // the pointcut expression
private fun anyOldTransfer() {} // the pointcut signature</code></pre>
</div>
</div>
<div class="paragraph">
<p>构成切入点值的切入点表达式<code>@Pointcut</code>注解是一个常规的AspectJ 5切入点表达式。有关AspectJ的切入点语言的完整讨论，请参见<a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ编程指南</a> （以及扩展，包括<a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5开发人员的笔记本</a> ）或有关AspectJ的书籍之一（如Colyer等人的<em>Eclipse AspectJ</em> ，或《 <em>AspectJ in Action》</em> ，由Ramnivas Laddad撰写）。</p>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-designators"><a class="anchor" href="#aop-pointcuts-designators"></a>支持的切入点指示符</h5>
<div class="paragraph">
<p>Spring AOP支持以下在切入点表达式中使用的AspectJ切入点指示符（PCD）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>execution</code> ：用于匹配方法执行的连接点。这是使用Spring AOP时要使用的主要切入点指示符。</p>
</li>
<li>
<p><code>within</code> ：将匹配限制为某些类型内的连接点（使用Spring AOP时，在匹配类型内声明的方法的执行）。</p>
</li>
<li>
<p><code>this</code> ：限制匹配到连接点（使用Spring AOP时方法的执行）的匹配，其中bean引用（Spring AOP代理）是给定类型的实例。</p>
</li>
<li>
<p><code>target</code> ：在目标对象（代理的应用程序对象）是给定类型的实例的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。</p>
</li>
<li>
<p><code>args</code> ：在参数是给定类型的实例的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。</p>
</li>
<li>
<p><code>@target</code> ：在执行对象的类具有给定类型的注释的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。</p>
</li>
<li>
<p><code>@args</code> ：限制匹配的连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。</p>
</li>
<li>
<p><code>@within</code> ：将匹配限制为具有给定注释的类型内的连接点（使用Spring AOP时，使用给定注释的类型中声明的方法的执行）。</p>
</li>
<li>
<p><code>@annotation</code> ：将匹配限制在连接点的主题（Spring AOP中正在执行的方法）具有给定注释的连接点上。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">其他切入点类型</div>
<div class="paragraph">
<p>完整的AspectJ切入点语言支持Spring不支持的其他切入点指示符： <code>call</code> ， <code>get</code> ， <code>set</code> ， <code>preinitialization</code> ， <code>staticinitialization</code> ， <code>initialization</code> ， <code>handler</code> ， <code>adviceexecution</code> ， <code>withincode</code> ， <code>cflow</code> ， <code>cflowbelow</code> ， <code>if</code> ， <code>@this</code>和<code>@withincode</code> 。在Spring AOP解释的切入点表达式中使用这些切入点指示符会导致<code>IllegalArgumentException</code>被抛出。</p>
</div>
<div class="paragraph">
<p>Spring AOP支持的切入点指示符集合可能会在将来的版本中扩展，以支持更多的AspectJ切入点指示符。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>由于Spring AOP仅将匹配限制为仅方法执行连接点，因此前面对切入点指示符的讨论所给出的定义比在AspectJ编程指南中所能找到的要窄。此外，AspectJ本身具有基于类型的语义，并且在执行连接点处，两者<code>this</code>和<code>target</code>引用同一对象：执行该方法的对象。Spring AOP是一个基于代理的系统，区分代理对象本身（绑定到<code>this</code> ）和代理后面的目标对象（绑定到<code>target</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于Spring的AOP框架基于代理的性质，因此根据定义，不会拦截目标对象内的调用。对于JDK代理，只能拦截代理上的公共接口方法调用。使用CGLIB，将拦截代理上的公共方法和受保护的方法调用（必要时甚至包可见的方法）。但是，通常应通过公共签名设计通过代理进行的常见交互。</p>
</div>
<div class="paragraph">
<p>请注意，切入点定义通常与任何拦截方法匹配。如果严格地将切入点设置为仅公开使用，即使在CGLIB代理方案中通过代理可能存在非公开交互，也需要相应地进行定义。</p>
</div>
<div class="paragraph">
<p>如果您的拦截需要在目标类中包括方法调用甚至构造函数，请考虑使用Spring驱动的<a href="#aop-aj-ltw">本机AspectJ编织，</a>而不是Spring的基于代理的AOP框架。这构成了具有不同特征的AOP使用模式，因此请确保在做出决定之前先熟悉编织。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring AOP还支持名为<code>bean</code> 。使用PCD，可以将连接点的匹配限制为特定的命名Spring Bean或一组命名Spring Bean（使用通配符时）。的<code>bean</code> PCD具有以下形式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>idOrNameOfBean</code> token可以是任何Spring bean的名称。有限的通配符支持，使用<code>*</code>提供了字符，因此，如果您为Spring bean建立了一些命名约定，则可以编写一个<code>bean</code> PCD表达式选择它们。与其他切入点指示符一样， <code>bean</code> PCD可以与<code>&&</code> （和）， <code>||</code> （或），以及<code>!</code> （否定）运算符。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>bean</code>仅Spring AOP支持PCD，而本机AspectJ编织不支持PCD。它是AspectJ定义的标准PCD的特定于Spring的扩展，因此不适用于在<code>@Aspect</code>模型。</p>
</div>
<div class="paragraph">
<p>的<code>bean</code> PCD在实例级别（基于Spring bean名称概念构建）上运行，而不是仅在类型级别（基于编织的AOP受其限制）上运行。基于实例的切入点指示符是Spring基于代理的AOP框架及其与Spring bean工厂的紧密集成的一种特殊功能，在这里自然而直接地通过名称来标识特定的bean。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-combining"><a class="anchor" href="#aop-pointcuts-combining"></a>组合切入点表达式</h5>
<div class="paragraph">
<p>您可以使用组合切入点表达式<code>&&,</code><code>||</code>和<code>!</code> 。您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Pointcut("execution(public * <strong>(..))")
private void anyPublicOperation() {} <i class="conum" data-value="1"></i><b>(1)</b>

@Pointcut("within(com.xyz.someapp.trading..</strong>)")
private void inTrading() {} <i class="conum" data-value="2"></i><b>(2)</b>

@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
private void tradingOperation() {} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>anyPublicOperation</code>如果方法执行连接点表示任何公共方法的执行，则匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>inTrading</code>如果交易模块中有方法执行，则匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>tradingOperation</code>如果方法执行代表交易模块中的任何公共方法，则匹配。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Pointcut("execution(public * <strong>(..))")
private fun anyPublicOperation() {} <i class="conum" data-value="1"></i><b>(1)</b>

@Pointcut("within(com.xyz.someapp.trading..</strong>)")
private fun inTrading() {} <i class="conum" data-value="2"></i><b>(2)</b>

@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
private fun tradingOperation() {} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>anyPublicOperation</code>如果方法执行连接点表示任何公共方法的执行，则匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>inTrading</code>如果交易模块中有方法执行，则匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>tradingOperation</code>如果方法执行代表交易模块中的任何公共方法，则匹配。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最佳实践是从较小的命名组件中构建更复杂的切入点表达式，如先前所示。按名称引用切入点时，将应用常规的Java可见性规则（您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何地方的公共切入点，等等）。可见性不影响切入点匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-common-pointcuts"><a class="anchor" href="#aop-common-pointcuts"></a>共享通用切入点定义</h5>
<div class="paragraph">
<p>在使用企业应用程序时，开发人员通常希望从多个方面引用应用程序的模块和特定的操作集。我们建议为此定义一个“ SystemArchitecture”方面，以捕获常见的切入点表达式。这样的方面通常类似于以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.xyz.someapp;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class SystemArchitecture {

    /<strong>
     * A join point is in the web layer if the method is defined
     * in a type in the com.xyz.someapp.web package or any sub-package
     * under that.
     <strong>/
    @Pointcut("within(com.xyz.someapp.web..</strong>)")
    public void inWebLayer() {}

    /</strong>
     * A join point is in the service layer if the method is defined
     * in a type in the com.xyz.someapp.service package or any sub-package
     * under that.
     <strong>/
    @Pointcut("within(com.xyz.someapp.service..</strong>)")
    public void inServiceLayer() {}

    /<strong>
     * A join point is in the data access layer if the method is defined
     * in a type in the com.xyz.someapp.dao package or any sub-package
     * under that.
     <strong>/
    @Pointcut("within(com.xyz.someapp.dao..</strong>)")
    public void inDataAccessLayer() {}

    /</strong>
     * A business service is the execution of any method defined on a service
     * interface. This definition assumes that interfaces are placed in the
     * "service" package, and that implementation types are in sub-packages.
     *
     * If you group service interfaces by functional area (for example,
     * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
     * the pointcut expression "execution(* com.xyz.someapp..service.<strong>.</strong>(..))"
     * could be used instead.
     *
     * Alternatively, you can write the expression using the 'bean'
     * PCD, like so "bean(<strong>Service)". (This assumes that you have
     * named your Spring service beans in a consistent fashion.)
     */
    @Pointcut("execution(</strong> com.xyz.someapp..service.<strong>.</strong>(..))")
    public void businessService() {}

    /<strong>*
     * A data access operation is the execution of any method defined on a
     * dao interface. This definition assumes that interfaces are placed in the
     * "dao" package, and that implementation types are in sub-packages.
     */
    @Pointcut("execution(</strong> com.xyz.someapp.dao.<strong>.</strong>(..))")
    public void dataAccessOperation() {}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.xyz.someapp

import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Pointcut

import org.springframework.aop.Pointcut

@Aspect
class SystemArchitecture {

    /<strong>
    * A join point is in the web layer if the method is defined
    * in a type in the com.xyz.someapp.web package or any sub-package
    * under that.
    <strong>/
    @Pointcut("within(com.xyz.someapp.web..</strong>)")
    fun inWebLayer() {
    }

    /</strong>
    * A join point is in the service layer if the method is defined
    * in a type in the com.xyz.someapp.service package or any sub-package
    * under that.
    <strong>/
    @Pointcut("within(com.xyz.someapp.service..</strong>)")
    fun inServiceLayer() {
    }

    /<strong>
    * A join point is in the data access layer if the method is defined
    * in a type in the com.xyz.someapp.dao package or any sub-package
    * under that.
    <strong>/
    @Pointcut("within(com.xyz.someapp.dao..</strong>)")
    fun inDataAccessLayer() {
    }

    /</strong>
    * A business service is the execution of any method defined on a service
    * interface. This definition assumes that interfaces are placed in the
    * "service" package, and that implementation types are in sub-packages.
    *
    * If you group service interfaces by functional area (for example,
    * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
    * the pointcut expression "execution(* com.xyz.someapp..service.<strong>.</strong>(..))"
    * could be used instead.
    *
    * Alternatively, you can write the expression using the 'bean'
    * PCD, like so "bean(<strong>Service)". (This assumes that you have
    * named your Spring service beans in a consistent fashion.)
    */
    @Pointcut("execution(</strong> com.xyz.someapp..service.<strong>.</strong>(..))")
    fun businessService() {
    }

    /<strong>*
    * A data access operation is the execution of any method defined on a
    * dao interface. This definition assumes that interfaces are placed in the
    * "dao" package, and that implementation types are in sub-packages.
    */
    @Pointcut("execution(</strong> com.xyz.someapp.dao.<strong>.</strong>(..))")
    fun dataAccessOperation() {
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在需要切入点表达式的任何地方引用在此方面定义的切入点。例如，要使服务层具有事务性，您可以编写以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;
    &lt;aop:advisor
        pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
        advice-ref="tx-advice"/&gt;
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="*" propagation="REQUIRED"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code><aop:config></code>和<code><aop:advisor></code> <a href="#aop-schema">基于模式的AOP支持</a>中讨论了元素。<a href="data-access.html#transaction">事务管理</a>中讨论了<a href="data-access.html#transaction">事务</a>元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-examples"><a class="anchor" href="#aop-pointcuts-examples"></a>例子</h5>
<div class="paragraph">
<p>Spring AOP用户可能会使用<code>execution</code>切入点指示符是最常见的。执行表达式的格式如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
                throws-pattern?)</pre>
</div>
</div>
<div class="paragraph">
<p>除返回类型模式（ <code>ret-type-pattern</code>在前面的代码段中），名称模式和参数模式是可选的。返回类型模式确定该方法的返回类型必须是什么才能使连接点匹配。
<code>*</code>最常用作返回类型模式。它匹配任何返回类型。仅当方法返回给定类型时，标准类型名称才匹配。名称模式与方法名称匹配。您可以使用<code>*</code>通配符作为名称模式的全部或一部分。如果指定声明类型模式，请在其末尾添加<code>.</code>将其加入名称模式组件。参数模式稍微复杂一些： <code>()</code>匹配不带参数的方法，而<code>(..)</code>匹配任意数量（零个或多个）的参数。的<code>(*)</code>模式与采用任何类型的一个参数的方法匹配。
<code>(*,String)</code>与采用两个参数的方法匹配。第一个可以是任何类型，而第二个必须是<code>String</code> 。有关更多信息，请查阅AspectJ编程指南的“ <a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义”</a>部分。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一些常用的切入点表达式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何公共方法的执行：</p>
<div class="literalblock">
<div class="content">
<pre>    execution(public * *(..))</pre>
</div>
</div>
</li>
<li>
<p>名称以开头的任何方法的执行<code>set</code> ：</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* set*(..))</pre>
</div>
</div>
</li>
<li>
<p>执行由<code>AccountService</code>接口：</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* com.xyz.service.AccountService.*(..))</pre>
</div>
</div>
</li>
<li>
<p>执行在<code>service</code>包：</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* com.xyz.service.<strong>.</strong>(..))</pre>
</div>
</div>
</li>
<li>
<p>服务包或其子包之一中定义的任何方法的执行：</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* com.xyz.service..<strong>.</strong>(..))</pre>
</div>
</div>
</li>
<li>
<p>服务包中的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="literalblock">
<div class="content">
<pre>    within(com.xyz.service.*)</pre>
</div>
</div>
</li>
<li>
<p>服务包或其子包之一中的任何连接点（仅在Spring AOP中执行方法）：</p>
<div class="literalblock">
<div class="content">
<pre>    within(com.xyz.service..*)</pre>
</div>
</div>
</li>
<li>
<p>代理实现的任何连接点（仅在Spring AOP中执行方法） <code>AccountService</code>接口：</p>
<div class="literalblock">
<div class="content">
<pre>    this(com.xyz.service.AccountService)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">“ this”通常以绑定形式使用。有关如何在建议正文中使代理对象可用的信息，请参阅“ <a href="#aop-advice">声明建议</a> ”部分。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>目标对象在其中实现目标的任何连接点（仅在Spring AOP中执行方法） <code>AccountService</code>接口：</p>
<div class="literalblock">
<div class="content">
<pre>    target(com.xyz.service.AccountService)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">“目标”通常以绑定形式使用。有关如何使目标对象在建议正文中可用的信息，请参见“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>任何采用单个参数且运行时传递的参数为的连接点（仅在Spring AOP中是方法执行）是<code>Serializable</code> ：</p>
<div class="literalblock">
<div class="content">
<pre>    args(java.io.Serializable)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">“ args”通常以绑定形式使用。有关如何使方法参数在建议正文中可用的信息，请参见“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，此示例中给出的切入点与<code>execution(* *(java.io.Serializable))</code> 。如果在运行时传递的参数为，则args版本匹配<code>Serializable</code> ，并且如果方法签名声明了单个类型的参数，则执行版本匹配<code>Serializable</code> 。</p>
</div>
</li>
<li>
<p>目标对象具有任何连接点的任何连接点（仅在Spring AOP中执行方法） <code>@Transactional</code>注解：</p>
<div class="literalblock">
<div class="content">
<pre>    @target(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以在绑定形式中使用“ @target”。有关如何使注释对象在建议正文中可用的信息，请参见“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>目标对象的声明类型具有任何连接点的任何连接点（仅在Spring AOP中执行方法） <code>@Transactional</code>注解：</p>
<div class="literalblock">
<div class="content">
<pre>    @within(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以在绑定形式中使用“ @within”。有关如何使注释对象在建议正文中可用的信息，请参见“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>执行方法具有以下条件的任何连接点（仅在Spring AOP中为方法执行） <code>@Transactional</code>注解：</p>
<div class="literalblock">
<div class="content">
<pre>    @annotation(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以在绑定形式中使用“ @annotation”。有关如何使注释对象在建议正文中可用的信息，请参见“ <a href="#aop-advice">声明建议”</a>部分。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>任何采用单个参数的联接点（仅在Spring AOP中是方法执行），并且传递的参数的运行时类型具有<code>@Classified</code>注解：</p>
<div class="literalblock">
<div class="content">
<pre>    @args(com.xyz.security.Classified)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以在绑定形式中使用“ @args”。请参阅“ <a href="#aop-advice">声明建议”</a>部分，如何使<a href="#aop-advice">建议</a>对象中的注释对象可用。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>名为Spring的bean上的任何连接点（仅在Spring AOP中执行方法） <code>tradeService</code> ：</p>
<div class="literalblock">
<div class="content">
<pre>    bean(tradeService)</pre>
</div>
</div>
</li>
<li>
<p>名称与通配符表达式匹配的Spring Bean上的任何连接点（仅在Spring AOP中执行方法） <code>*Service</code> ：</p>
<div class="literalblock">
<div class="content">
<pre>    bean(*Service)</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="writing-good-pointcuts"><a class="anchor" href="#writing-good-pointcuts"></a>写好切入点</h5>
<div class="paragraph">
<p>在编译期间，AspectJ处理切入点以优化匹配性能。检查代码并确定每个连接点是否（静态或动态）匹配给定的切入点是一个昂贵的过程。（动态匹配意味着无法从静态分析中完全确定匹配，并且在代码中进行了测试以确定代码运行时是否存在实际匹配）。首次遇到切入点声明时，AspectJ将其重写为匹配过程的最佳形式。这是什么意思？基本上，切入点以DNF（析取范式）重写，并且对切入点的组件进行排序，以便首先检查那些较便宜的组件。这意味着您不必担心理解各种切入点指示符的性能，并且可以在切入点声明中以任何顺序提供它们。</p>
</div>
<div class="paragraph">
<p>但是，AspectJ只能使用所告诉的内容。为了获得最佳的匹配性能，您应该考虑他们试图达到的目标，并在定义中尽可能缩小匹配的搜索空间。现有的指示符自然分为三类之一：同类，作用域和上下文：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>亲切的指示者选择一种特殊的连接点： <code>execution</code> ， <code>get</code> ， <code>set</code> ， <code>call</code>和<code>handler</code> 。</p>
</li>
<li>
<p>作用域指定者选择一组感兴趣的连接点（可能有多种）： <code>within</code>和<code>withincode</code></p>
</li>
<li>
<p>上下文指示符根据上下文匹配（并可选地绑定）： <code>this</code> ， <code>target</code>和<code>@annotation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>编写正确的切入点至少应包括前两种类型（种类和作用域）。您可以包括上下文指示符以根据连接点上下文进行匹配，也可以绑定该上下文以在建议中使用。仅提供同类的标识符或仅提供上下文的标识符是可行的，但是由于额外的处理和分析，可能会影响编织性能（使用的时间和内存）。作用域指示符的匹配非常快，使用它们的使用意味着AspectJ可以非常迅速地消除不应进一步处理的连接点组。一个好的切入点应尽可能包括一个切入点。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice"><a class="anchor" href="#aop-advice"></a> 5.4.4。宣告建议</h4>
<div class="paragraph">
<p>建议与切入点表达式关联，并且在切入点匹配的方法执行之前，之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是就地声明的切入点表达式。</p>
</div>
<div class="sect4">
<h5 id="aop-advice-before"><a class="anchor" href="#aop-advice-before"></a>咨询前</h5>
<div class="paragraph">
<p>您可以使用<code>@Before</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    public void doAccessCheck() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before

@Aspect
class BeforeExample {

    @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    fun doAccessCheck() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用就地切入点表达式，则可以将前面的示例重写为以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before("execution(* com.xyz.myapp.dao.<strong>.</strong>(..))")
    public void doAccessCheck() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before

@Aspect
class BeforeExample {

    @Before("execution(* com.xyz.myapp.dao.<strong>.</strong>(..))")
    fun doAccessCheck() {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-returning"><a class="anchor" href="#aop-advice-after-returning"></a>返回建议后</h5>
<div class="paragraph">
<p>返回建议后，当匹配的方法执行正常返回时运行建议。您可以使用<code>@AfterReturning</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

    @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    public void doAccessCheck() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterReturning

@Aspect
class AfterReturningExample {

    @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    fun doAccessCheck() {
        // ...
    }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以在同一方面内拥有多个建议声明（以及其他成员）。在这些示例中，我们仅显示单个建议声明，以集中每个建议的效果。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有时，您需要在建议正文中访问返回的实际值。您可以使用以下形式<code>@AfterReturning</code>绑定返回值以获得该访问权限，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

    @AfterReturning(
        pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
        returning="retVal")
    public void doAccessCheck(Object retVal) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterReturning

@Aspect
class AfterReturningExample {

    @AfterReturning(pointcut = "com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning = "retVal")
    fun doAccessCheck(retVal: Any) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>名称中使用的<code>returning</code>属性必须与建议方法中的参数名称相对应。当方法执行返回时，返回值将作为相应的参数值传递到通知方法。一种<code>returning</code>子句还将匹配仅限制为返回指定类型值的方法执行（在这种情况下， <code>Object</code> ，该值与任何返回值匹配）。</p>
</div>
<div class="paragraph">
<p>请注意，返回建议后使用时，不可能返回完全不同的参考。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-throwing"><a class="anchor" href="#aop-advice-after-throwing"></a>投掷建议后</h5>
<div class="paragraph">
<p>抛出建议后，当匹配的方法执行通过抛出异常退出时运行。您可以使用<code>@AfterThrowing</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

    @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    public void doRecoveryActions() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterThrowing

@Aspect
class AfterThrowingExample {

    @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    fun doRecoveryActions() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，您希望通知仅在引发给定类型的异常时才运行，并且您通常还需要访问通知正文中的引发异常。您可以使用<code>throwing</code>同时限制匹配的属性（如果需要，请使用<code>Throwable</code>作为异常类型，否则将抛出的异常绑定到advice参数。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

    @AfterThrowing(
        pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
        throwing="ex")
    public void doRecoveryActions(DataAccessException ex) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterThrowing

@Aspect
class AfterThrowingExample {

    @AfterThrowing(pointcut = "com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing = "ex")
    fun doRecoveryActions(ex: DataAccessException) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>名称中使用的<code>throwing</code>属性必须与建议方法中的参数名称相对应。当通过引发异常退出方法执行时，该异常将作为相应的参数值传递给通知方法。一种<code>throwing</code>子句也将匹配限制为仅引发指定类型异常的方法执行（ <code>DataAccessException</code> ， 在这种情况下）。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-finally"><a class="anchor" href="#aop-advice-after-finally"></a>经过（最后）建议</h5>
<div class="paragraph">
<p>当匹配的方法执行退出时，通知（最终）运行。通过使用<code>@After</code>注解。之后必须准备处理正常和异常返回条件的建议。它通常用于释放资源和类似目的。以下示例显示了最终建议后的用法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class AfterFinallyExample {

    @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    public void doReleaseLock() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.After

@Aspect
class AfterFinallyExample {

    @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
    fun doReleaseLock() {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-around-advice"><a class="anchor" href="#aop-ataspectj-around-advice"></a>忠告</h5>
<div class="paragraph">
<p>最后一种建议是围绕建议。围绕建议在匹配方法的执行过程中“围绕”运行。它有机会在方法执行之前和之后进行工作，并确定何时，如何以及什至根本不执行该方法。如果需要以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态，则通常使用绕行建议。始终使用最不可行的建议形式来满足您的要求（也就是说，在建议可以使用之前，不要在建议周围使用）。</p>
</div>
<div class="paragraph">
<p>周围的建议是通过使用<code>@Around</code>注解。咨询方法的第一个参数必须为类型<code>ProceedingJoinPoint</code> 。在建议的正文中，调用<code>proceed()</code>在<code>ProceedingJoinPoint</code>使底层方法执行。的<code>proceed</code>方法也可以传递<code>Object[]</code> 。数组中的值用作方法执行时的参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的行为<code>proceed</code>当用<code>Object[]</code>与...的行为有些不同<code>proceed</code>有关由AspectJ编译器编译的建议。对于使用传统AspectJ语言编写的周围建议，传递给<code>proceed</code>必须与传递给around建议的参数数量（而不是基础连接点采用的参数数量）相匹配，并且传递给定值以在给定参数位置进行的值取代了该实体在连接点处的原始值势必会（请不要担心，如果这现在没有意义）。Spring采取的方法更简单，并且更适合其基于代理的，仅执行的语义。如果您编译为Spring编写的@AspectJ方面并使用，则只需要意识到这种差异即可。 <code>proceed</code>与AspectJ编译器和编织器一起使用的参数。有一种方法可以在Spring AOP和AspectJ之间100％兼容，并且在<a href="#aop-ataspectj-advice-params">下面有关建议参数的部分中</a>对此进行了讨论。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用周围建议：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;

@Aspect
public class AroundExample {

    @Around("com.xyz.myapp.SystemArchitecture.businessService()")
    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
        // start stopwatch
        Object retVal = pjp.proceed();
        // stop stopwatch
        return retVal;
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Around
import org.aspectj.lang.ProceedingJoinPoint

@Aspect
class AroundExample {

    @Around("com.xyz.myapp.SystemArchitecture.businessService()")
    fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
        // start stopwatch
        val retVal = pjp.proceed()
        // stop stopwatch
        return pjp.proceed()
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>周围建议返回的值是该方法的调用者看到的返回值。例如，如果一个简单的缓存方面有一个值，则可以从缓存中返回一个值并调用<code>proceed()</code>如果没有。注意<code>proceed</code>可以在周围建议的正文中一次，多次或完全不调用。所有这些都是合法的。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params"><a class="anchor" href="#aop-ataspectj-advice-params"></a>建议参数</h5>
<div class="paragraph">
<p>Spring提供了完全类型化的建议，这意味着您可以在建议签名中声明所需的参数（如我们先前在返回和抛出示例中所见），而不是使用<code>Object[]</code>一直在排列。我们将在本节的后面部分介绍如何使参数和其他上下文值可用于建议主体。首先，我们看一下如何编写通用建议，以了解该建议当前建议的方法。</p>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-the-joinpoint"><a class="anchor" href="#aop-ataspectj-advice-params-the-joinpoint"></a>访问当前<code>JoinPoint</code></h6>
<div class="paragraph">
<p>任何建议方法都可以将类型为参数的参数声明为其第一个参数<code>org.aspectj.lang.JoinPoint</code> （请注意，需要周围的建议来声明类型的第一个参数<code>ProceedingJoinPoint</code> ，这是的子类<code>JoinPoint</code> 。的<code>JoinPoint</code>界面提供了许多有用的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getArgs()</code> ：返回方法参数。</p>
</li>
<li>
<p><code>getThis()</code> ：返回代理对象。</p>
</li>
<li>
<p><code>getTarget()</code> ：返回目标对象。</p>
</li>
<li>
<p><code>getSignature()</code> ：返回建议使用的方法的描述。</p>
</li>
<li>
<p><code>toString()</code> ：打印有关所建议方法的有用描述。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html">javadoc</a> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-passing"><a class="anchor" href="#aop-ataspectj-advice-params-passing"></a>将参数传递给建议</h6>
<div class="paragraph">
<p>我们已经看到了如何绑定返回的值或异常值（在返回之后和引发建议之后使用）。要使参数值可用于建议正文，可以使用的绑定形式<code>args</code> 。如果在args表达式中使用参数名称代替类型名称，则在调用建议时会将相应参数的值作为参数值传递。一个例子应该使这一点更清楚。假设您要建议执行需要花费大量时间的DAO操作<code>Account</code>对象作为第一个参数，您需要访问建议正文中的帐户。您可以编写以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
public void validateAccount(Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
fun validateAccount(account: Account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>args(account,..)</code>切入点表达式的一部分有两个目的。首先，它将匹配限制为仅方法采用至少一个参数并且传递给该参数的参数为的实例的方法执行。 <code>Account</code> 。其次，它使实际<code>Account</code>对象可通过<code>account</code>参数。</p>
</div>
<div class="paragraph">
<p>编写此代码的另一种方法是声明一个“提供” <code>Account</code>与连接点匹配的对象值，然后从通知中引用命名的切入点。如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
private void accountDataAccessOperation(Account account) {}

@Before("accountDataAccessOperation(account)")
public void validateAccount(Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")
private fun accountDataAccessOperation(account: Account) {
}

@Before("accountDataAccessOperation(account)")
fun validateAccount(account: Account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见AspectJ编程指南。</p>
</div>
<div class="paragraph">
<p>代理对象（ <code>this</code> ），目标对象（ <code>target</code> ）和注释（ <code>@within</code> ， <code>@target</code> ， <code>@annotation</code>和<code>@args</code> ）都可以以类似的方式绑定。接下来的两个示例展示了如何匹配以注释的方法的执行<code>@Auditable</code>注释并提取审核代码：</p>
</div>
<div class="paragraph">
<p>这两个示例中的第一个显示了<code>@Auditable</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Auditable {
    AuditCode value();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Auditable(val value: AuditCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个示例中的第二个示例显示了与以下命令的执行相匹配的建议<code>@Auditable</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")
public void audit(Auditable auditable) {
    AuditCode code = auditable.value();
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")
fun audit(auditable: Auditable) {
    val code = auditable.value()
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-generics"><a class="anchor" href="#aop-ataspectj-advice-params-generics"></a>咨询参数和泛型</h6>
<div class="paragraph">
<p>Spring AOP可以处理类声明和方法参数中使用的泛型。假设您具有如下通用类型：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Sample&lt;T&gt; {
    void sampleGenericMethod(T param);
    void sampleGenericCollectionMethod(Collection&lt;T&gt; param);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Sample&lt;T&gt; {
    fun sampleGenericMethod(param: T)
    fun sampleGenericCollectionMethod(param: Collection&lt;T&gt;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过在要截获该方法的参数类型中键入advice参数，将截获方法类型限制为某些参数类型：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(MyType param) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
fun beforeSampleMethod(param: MyType) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法不适用于通用集合。因此，您不能按以下方式定义切入点：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(Collection&lt;MyType&gt; param) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
fun beforeSampleMethod(param: Collection&lt;MyType&gt;) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使这项工作有效，我们将不得不检查集合的每个元素，这是不合理的，因为我们也无法决定如何处理<code>null</code>一般的价值观。要实现类似的目的，您必须输入参数<code>Collection<?></code>并手动检查元素的类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-names"><a class="anchor" href="#aop-ataspectj-advice-params-names"></a>确定参数名称</h6>
<div class="paragraph">
<p>通知调用中的参数绑定依赖于切入点表达式中使用的名称与通知和切入点方法签名中声明的参数名称的匹配。通过Java反射无法获得参数名称，因此Spring AOP使用以下策略来确定参数名称：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果用户已明确指定参数名称，则使用指定的参数名称。建议和切入点注释均具有可选的<code>argNames</code>属性，可用于指定带注释的方法的参数名称。这些参数名称在运行时可用。以下示例显示了如何使用<code>argNames</code>属性：</p>
</li>
</ul>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
        argNames="bean,auditable")
public void audit(Object bean, Auditable auditable) {
    AuditCode code = auditable.value();
    // ... use code and bean
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames = "bean,auditable")
fun audit(bean: Any, auditable: Auditable) {
    val code = auditable.value()
    // ... use code and bean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果第一个参数是<code>JoinPoint</code> ， <code>ProceedingJoinPoint</code> ， 要么<code>JoinPoint.StaticPart</code>类型，则可以从参数的值中省略参数的名称<code>argNames</code>属性。例如，如果您修改前面的建议以接收连接点对象，则<code>argNames</code>属性不需要包含它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
        argNames="bean,auditable")
public void audit(JoinPoint jp, Object bean, Auditable auditable) {
    AuditCode code = auditable.value();
    // ... use code, bean, and jp
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames = "bean,auditable")
fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {
    val code = auditable.value()
    // ... use code, bean, and jp
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对第一个参数的特殊处理<code>JoinPoint</code> ， <code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型对于不收集任何其他联接点上下文的建议实例特别方便。在这种情况下，您可以省略<code>argNames</code>属性。例如，以下建议无需声明<code>argNames</code>属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
public void audit(JoinPoint jp) {
    // ... use jp
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
fun audit(jp: JoinPoint) {
    // ... use jp
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<code>'argNames'</code>属性有点笨拙，因此如果<code>'argNames'</code>尚未指定属性，Spring AOP将查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要已使用调试信息编译了类，该信息就会存在（ <code>'-g:vars'</code>最低限度）。启用此标志时进行编译的结果是：（1）您的代码稍微易于理解（反向工程），（2）类文件的大小非常大（通常无关紧要），（3）删除未使用的本地代码的优化变量不适用于您的编译器。换句话说，通过启用该标志，您应该不会遇到任何困难。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果即使没有调试信息，AspectJ编译器（ajc）都已编译@AspectJ方面，则无需添加<code>argNames</code>属性，因为编译器保留了所需的信息。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>如果在没有必要调试信息的情况下编译了代码，Spring AOP会尝试推断绑定变量与参数的配对（例如，如果切入点表达式中仅绑定了一个变量，并且advice方法仅接受一个参数，则配对很明显）。如果在给定可用信息的情况下变量的绑定不明确，则<code>AmbiguousBindingException</code>被抛出。</p>
</li>
<li>
<p>如果以上所有策略均失败，则<code>IllegalArgumentException</code>被抛出。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-proceeding-with-the-call"><a class="anchor" href="#aop-ataspectj-advice-proceeding-with-the-call"></a>进行论证</h6>
<div class="paragraph">
<p>我们之前说过，我们将描述如何编写<code>proceed</code>使用在Spring AOP和AspectJ中始终有效的参数进行调用。解决方案是确保建议签名按顺序绑定每个方法参数。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
        "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")
public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
        String accountHolderNamePattern) throws Throwable {
    String newPattern = preProcess(accountHolderNamePattern);
    return pjp.proceed(new Object[] {newPattern});
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
        "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")
fun preProcessQueryPattern(pjp: ProceedingJoinPoint,
                        accountHolderNamePattern: String): Any {
    val newPattern = preProcess(accountHolderNamePattern)
    return pjp.proceed(arrayOf&lt;Any&gt;(newPattern))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多情况下，无论如何都要进行此绑定（如上例所示）。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-ordering"><a class="anchor" href="#aop-ataspectj-advice-ordering"></a>咨询订购</h5>
<div class="paragraph">
<p>当多条建议都希望在同一连接点上运行时会发生什么？Spring AOP遵循与AspectJ相同的优先级规则来确定建议执行的顺序。优先级最高的建议首先在“途中”运行（因此，给定两条优先建议，则优先级最高的建议首先运行）。从连接点“出路”时，优先级最高的建议将最后运行（因此，给定两条后置通知，优先级最高的建议将排名第二）。</p>
</div>
<div class="paragraph">
<p>当在不同方面定义的两条建议都需要在同一连接点上运行时，除非另行指定，否则执行顺序是不确定的。您可以通过指定优先级来控制执行顺序。这可以通过实施常规的Spring方式来完成<code>org.springframework.core.Ordered</code>方面类中的接口，或使用<code>Order</code>注解。给定两个方面，从以下方面返回较低值的方面<code>Ordered.getValue()</code> （或注释值）具有更高的优先级。</p>
</div>
<div class="paragraph">
<p>当在同一方面定义的两条建议都需要在同一连接点上运行时，其顺序是未定义的（因为无法通过反射为javac编译的类检索声明顺序）。考虑在每个方面类中的每个连接点将此类建议方法折叠为一个建议方法，或将建议重构为可在方面级别订购的单独方面类。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-introductions"><a class="anchor" href="#aop-introductions"></a> 5.4.5。引言</h4>
<div class="paragraph">
<p>简介（在AspectJ中称为类型间声明）使方面可以声明建议对象实现给定的接口，并代表那些对象提供该接口的实现。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@DeclareParents</code>注解。此批注用于声明匹配类型具有新的父代（因此而得名）。例如，给定一个名为<code>UsageTracked</code>以及名为该接口的实现<code>DefaultUsageTracked</code> ，以下方面声明服务接口的所有实现者也都实现了<code>UsageTracked</code>接口（例如，通过JMX公开统计信息）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Aspect
public class UsageTracking {

    @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)
    public static UsageTracked mixin;

    @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)")
    public void recordUsage(UsageTracked usageTracked) {
        usageTracked.incrementUseCount();
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Aspect
class UsageTracking {

    companion object {
        @DeclareParents(value = "com.xzy.myapp.service.*+", defaultImpl = DefaultUsageTracked::class)
        lateinit var mixin: UsageTracked
    }

    @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)")
    fun recordUsage(usageTracked: UsageTracked) {
        usageTracked.incrementUseCount()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要实现的接口由带注释的字段的类型确定。的<code>value</code>的属性<code>@DeclareParents</code>注释是AspectJ类型的模式。任何匹配类型的bean都会实现<code>UsageTracked</code>接口。请注意，在前面示例的之前建议中，服务Bean可以直接用作<code>UsageTracked</code>接口。如果以编程方式访问bean，则应编写以下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val usageTracked = context.getBean("myService") as UsageTracked</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-instantiation-models"><a class="anchor" href="#aop-instantiation-models"></a> 5.4.6。方面实例化模型</h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是一个高级主题。如果您刚开始使用AOP，则可以放心地跳过它，直到以后。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，应用程序上下文中每个方面都有一个实例。AspectJ将此称为单例实例化模型。可以使用备用生命周期来定义方面。Spring支持AspectJ的<code>perthis</code>和<code>pertarget</code>实例化模型（ <code>percflow, percflowbelow,</code>和<code>pertypewithin</code>目前不受支持）。</p>
</div>
<div class="paragraph">
<p>您可以声明一个<code>perthis</code>通过指定一个方面<code>perthis</code>中的子句<code>@Aspect</code>注解。考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
public class MyAspect {

    private int someState;

    @Before(com.xyz.myapp.SystemArchitecture.businessService())
    public void recordServiceUsage() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
class MyAspect {

    private val someState: Int = 0

    @Before(com.xyz.myapp.SystemArchitecture.businessService())
    fun recordServiceUsage() {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>'perthis'</code>子句是为每个执行业务服务的唯一服务对象创建一个方面实例（每个唯一对象在与切入点表达式匹配的连接点处绑定到“ this”）。方面实例是在服务对象上首次调用方法时创建的。当服务对象超出范围时，方面将超出范围。在创建方面实例之前，其中的任何建议都不会执行。创建方面实例后，在其中声明的建议将在匹配的连接点处执行，但是仅当服务对象是与此方面相关联的对象时才执行。有关更多信息，请参见AspectJ编程指南。 <code>per</code>条款。</p>
</div>
<div class="paragraph">
<p>的<code>pertarget</code>实例化模型的工作原理与<code>perthis</code> ，但会在匹配的连接点为每个唯一目标对象创建一个方面实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-example"><a class="anchor" href="#aop-ataspectj-example"></a> 5.4.7。AOP示例</h4>
<div class="paragraph">
<p>既然您已经了解了所有组成部分是如何工作的，那么我们可以将它们放在一起做一些有用的事情。</p>
</div>
<div class="paragraph">
<p>有时由于并发问题（例如，死锁失败者），业务服务的执行可能会失败。如果重试该操作，则很可能在下一次尝试中成功。对于适合在这种情况下重试的业务服务（不需要重新返回给用户以解决冲突的幂等操作），我们希望透明地重试该操作，以避免客户看到<code>PessimisticLockingFailureException</code> 。这项要求明确地跨越了服务层中的多个服务，因此非常适合通过一个方面实施。</p>
</div>
<div class="paragraph">
<p>因为我们想重试该操作，所以我们需要使用一些建议，以便我们可以调用<code>proceed</code>多次。以下清单显示了基本方面的实现：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Aspect
public class ConcurrentOperationExecutor implements Ordered {

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;
    private int order = 1;

    public void setMaxRetries(int maxRetries) {
        this.maxRetries = maxRetries;
    }

    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    @Around("com.xyz.myapp.SystemArchitecture.businessService()")
    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
        int numAttempts = 0;
        PessimisticLockingFailureException lockFailureException;
        do {
            numAttempts++;
            try {
                return pjp.proceed();
            }
            catch(PessimisticLockingFailureException ex) {
                lockFailureException = ex;
            }
        } while(numAttempts &lt;= this.maxRetries);
        throw lockFailureException;
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Aspect
class ConcurrentOperationExecutor : Ordered {

    private val DEFAULT_MAX_RETRIES = 2
    private var maxRetries = DEFAULT_MAX_RETRIES
    private var order = 1

    fun setMaxRetries(maxRetries: Int) {
        this.maxRetries = maxRetries
    }

    override fun getOrder(): Int {
        return this.order
    }

    fun setOrder(order: Int) {
        this.order = order
    }

    @Around("com.xyz.myapp.SystemArchitecture.businessService()")
    fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
        var numAttempts = 0
        var lockFailureException: PessimisticLockingFailureException
        do {
            numAttempts++
            try {
                return pjp.proceed()
            } catch (ex: PessimisticLockingFailureException) {
                lockFailureException = ex
            }

        } while (numAttempts &lt;= this.maxRetries)
        throw lockFailureException
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，方面实现了<code>Ordered</code>界面，以便我们可以将方面的优先级设置为高于交易建议（每次重试时都需要一个新的交易）。的<code>maxRetries</code>和<code>order</code>属性都由Spring配置。主要动作发生在<code>doConcurrentOperation</code>周围的建议。请注意，目前，我们将重试逻辑应用于每个<code>businessService()</code> 。我们会尝试继续，如果我们失败了， <code>PessimisticLockingFailureException</code> ，我们将再试一次，除非我们用尽了所有的重试尝试。</p>
</div>
<div class="paragraph">
<p>相应的Spring配置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspectj-autoproxy/&gt;

&lt;bean id="concurrentOperationExecutor" class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
    &lt;property name="maxRetries" value="3"/&gt;
    &lt;property name="order" value="100"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了完善方面，使其仅重试幂等操作，我们可以定义以下内容<code>Idempotent</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    // marker annotation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
annotation class Idempotent// marker annotation</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以使用注释来注释服务操作的实现。方面的更改仅重试幂等操作涉及精简切入点表达式，以便<code>@Idempotent</code>操作匹配，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Around("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; " +
        "@annotation(com.xyz.myapp.service.Idempotent)")
public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Around("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; " + "@annotation(com.xyz.myapp.service.Idempotent)")
fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema"><a class="anchor" href="#aop-schema"></a> 5.5。基于架构的AOP支持</h3>
<div class="paragraph">
<p>如果您喜欢基于XML的格式，Spring还提供了对使用新的定义方面的支持。 <code>aop</code>命名空间标签。支持与使用@AspectJ样式时完全相同的切入点表达式和建议类型。因此，在本节中，我们将重点放在新语法上，并使读者参考上一节中的讨论（ <a href="#aop-ataspectj">@AspectJ support</a> ），以了解编写切入点表达式和建议参数的绑定。</p>
</div>
<div class="paragraph">
<p>要使用本节中介绍的aop名称空间标签，您需要导入<code>spring-aop</code>架构，如<a href="#xsd-schemas">基于XML架构的配置中所述</a> 。请参阅<a href="#xsd-schemas-aop">AOP模式</a>以了解如何在<code>aop</code>命名空间。</p>
</div>
<div class="paragraph">
<p>在您的Spring配置中，所有方面和顾问程序元素都必须放在<code><aop:config></code>元素（您可以有多个<code><aop:config></code>应用程序上下文配置中的元素）。一个<code><aop:config></code>元素可以包含切入点，顾问和方面元素（请注意，这些元素必须按此顺序声明）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">的<code><aop:config></code>样式的配置大量使用了Spring的<a href="#aop-autoproxy">自动代理</a>机制。如果您已经通过使用以下方式使用显式自动代理，则可能会导致问题（例如，未编制建议） <code>BeanNameAutoProxyCreator</code>或类似的东西。推荐的使用方式是仅使用<code><aop:config></code>样式或仅<code>AutoProxyCreator</code>风格，切勿混搭。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="aop-schema-declaring-an-aspect"><a class="anchor" href="#aop-schema-declaring-an-aspect"></a> 5.5.1。声明一个方面</h4>
<div class="paragraph">
<p>使用模式支持时，方面是在Spring应用程序上下文中定义为Bean的常规Java对象。状态和行为在对象的字段和方法中捕获，切入点和建议信息在XML中捕获。</p>
</div>
<div class="paragraph">
<p>您可以使用<aop:aspect>元素</aop:aspect>声明一个方面<aop:aspect>，并</aop:aspect>使用来<aop:aspect>引用支持bean <code>ref</code>属性，如以下示例所示：</aop:aspect></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;
    &lt;aop:aspect id="myAspect" ref="aBean"&gt;
        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持方面的Bean（ <code>aBean</code>在这种情况下，当然可以像配置任何其他Spring bean一样配置和注入依赖项。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-pointcuts"><a class="anchor" href="#aop-schema-pointcuts"></a> 5.5.2。声明切入点</h4>
<div class="paragraph">
<p>您可以在<code><aop:config></code>元素，以便在多个方面和顾问程序之间共享切入点定义。</p>
</div>
<div class="paragraph">
<p>可以定义代表服务层中任何业务服务的执行的切入点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:pointcut id="businessService"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，切入点表达式本身使用的是<a href="#aop-ataspectj">@AspectJ support中</a>所述的AspectJ切入点表达式语言。如果使用基于架构的声明样式，则可以引用在切入点表达式中的类型（@Aspects）中定义的命名切入点。定义上述切入点的另一种方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:pointcut id="businessService"
        expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设您有一个<code>SystemArchitecture</code> <a href="#aop-common-pointcuts">共享公共切入点定义中</a>描述的方面。</p>
</div>
<div class="paragraph">
<p>然后，在方面内声明切入点与声明顶级切入点非常相似，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:aspect id="myAspect" ref="aBean"&gt;

        &lt;aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

        ...

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与@AspectJ方面几乎相同，通过使用基于架构的定义样式声明的切入点可以收集连接点上下文。例如，以下切入点收集了<code>this</code>对象作为连接点上下文，并将其传递给建议：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:aspect id="myAspect" ref="aBean"&gt;

        &lt;aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt;

        &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;

        ...

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>必须声明该建议以通过包含匹配名称的参数来接收收集的连接点上下文，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void monitor(Object service) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun monitor(service: Any) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结合切入点子表达式时， <code>&&</code>在XML文档中比较尴尬，因此您可以使用<code>and</code> ， <code>or</code>和<code>not</code>关键字代替<code>&&</code> ， <code>||</code>和<code>!</code> ， 分别。例如，上一个切入点可以更好地编写如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:aspect id="myAspect" ref="aBean"&gt;

        &lt;aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..)) and this(service)"/&gt;

        &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;

        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，以这种方式定义的切入点由其XML引用<code>id</code>并且不能用作命名的切入点以形成复合切入点。因此，基于架构的定义样式中的命名切入点支持比@AspectJ样式所提供的更受限制。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice"><a class="anchor" href="#aop-schema-advice"></a> 5.5.3。宣告建议</h4>
<div class="paragraph">
<p>基于模式的AOP支持使用与@AspectJ样式相同的五种建议，并且它们具有完全相同的语义。</p>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-before"><a class="anchor" href="#aop-schema-advice-before"></a>咨询前</h5>
<div class="paragraph">
<p>在执行匹配的方法之前，先运行建议。在内部声明<code><aop:aspect></code>通过使用<aop:before>元素，如以下示例所示：</aop:before></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before
        pointcut-ref="dataAccessOperation"
        method="doAccessCheck"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里， <code>dataAccessOperation</code>是个<code>id</code>在顶部定义的切入点（ <code><aop:config></code> ）级别。要内联定义切入点，请替换<code>pointcut-ref</code>具有一个属性<code>pointcut</code>属性，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before
        pointcut="execution(* com.xyz.myapp.dao.*.*(..))"
        method="doAccessCheck"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们在@AspectJ样式的讨论中所指出的那样，使用命名切入点可以显着提高代码的可读性。</p>
</div>
<div class="paragraph">
<p>的<code>method</code>属性标识方法（ <code>doAccessCheck</code> ），以提供建议的正文。必须为包含建议的Aspect元素所引用的bean定义此方法。在执行数据访问操作（与切入点表达式匹配的方法执行连接点）之前， <code>doAccessCheck</code>方面Bean上的方法被调用。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-returning"><a class="anchor" href="#aop-schema-advice-after-returning"></a>返回建议后</h5>
<div class="paragraph">
<p>返回的建议在匹配的方法执行正常完成时运行。在内部声明<code><aop:aspect></code>与之前的建议相同。以下示例显示了如何声明它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning
        pointcut-ref="dataAccessOperation"
        method="doAccessCheck"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与@AspectJ样式一样，您可以在建议正文中获取返回值。为此，使用returning属性指定返回值应传递到的参数的名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning
        pointcut-ref="dataAccessOperation"
        returning="retVal"
        method="doAccessCheck"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>doAccessCheck</code>方法必须声明一个名为<code>retVal</code> 。该参数的类型以与上述相同的方式约束匹配<code>@AfterReturning</code> 。例如，您可以按以下方式声明方法签名：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void doAccessCheck(Object retVal) {...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun doAccessCheck(retVal: Any) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-throwing"><a class="anchor" href="#aop-schema-advice-after-throwing"></a>投掷建议后</h5>
<div class="paragraph">
<p>抛出建议后，当匹配的方法执行通过抛出异常退出时执行建议。在内部声明<code><aop:aspect></code>通过使用掷后元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing
        pointcut-ref="dataAccessOperation"
        method="doRecoveryActions"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与@AspectJ样式一样，您可以在通知正文中获取引发的异常。为此，请使用throwing属性指定异常应传递到的参数的名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing
        pointcut-ref="dataAccessOperation"
        throwing="dataAccessEx"
        method="doRecoveryActions"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>doRecoveryActions</code>方法必须声明一个名为<code>dataAccessEx</code> 。该参数的类型以与上述相同的方式约束匹配<code>@AfterThrowing</code> 。例如，方法签名可以声明如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void doRecoveryActions(DataAccessException dataAccessEx) {...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun doRecoveryActions(dataAccessEx: DataAccessException) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-finally"><a class="anchor" href="#aop-schema-advice-after-finally"></a>经过（最后）建议</h5>
<div class="paragraph">
<p>无论最终如何执行匹配的方法，建议（最终）都会运行。您可以使用<code>after</code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt;

    &lt;aop:after
        pointcut-ref="dataAccessOperation"
        method="doReleaseLock"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-around"><a class="anchor" href="#aop-schema-advice-around"></a>忠告</h5>
<div class="paragraph">
<p>最后一种建议是围绕建议。围绕建议在匹配的方法执行“周围”运行。它有机会在方法执行之前和之后进行工作，并确定何时，如何以及什至根本不执行该方法。周围建议通常用于以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态。始终使用最不强大的建议形式，以满足您的要求。如果建议无法完成工作，请勿在建议周围使用。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>aop:around</code>元件。咨询方法的第一个参数必须为类型<code>ProceedingJoinPoint</code> 。在建议的正文中，调用<code>proceed()</code>在<code>ProceedingJoinPoint</code>使底层方法执行。的<code>proceed</code>方法也可以使用<code>Object[]</code> 。数组中的值用作方法执行时的参数。有关致电的说明，请参见“ <a href="#aop-ataspectj-around-advice">周围建议</a> ” <code>proceed</code>带着<code>Object[]</code> 。以下示例显示了如何在XML中围绕建议进行声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="aroundExample" ref="aBean"&gt;

    &lt;aop:around
        pointcut-ref="businessService"
        method="doBasicProfiling"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>实施<code>doBasicProfiling</code>建议可以与@AspectJ示例完全相同（当然要减去注释），如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
    // start stopwatch
    Object retVal = pjp.proceed();
    // stop stopwatch
    return retVal;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
    // start stopwatch
    val retVal = pjp.proceed()
    // stop stopwatch
    return pjp.proceed()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-params"><a class="anchor" href="#aop-schema-params"></a>建议参数</h5>
<div class="paragraph">
<p>基于架构的声明样式以与@AspectJ支持相同的方式支持完全类型的建议，即按名称将切入点参数与建议方法参数进行匹配。有关详细信息，请参见<a href="#aop-ataspectj-advice-params">建议参数</a> 。如果您希望为建议方法明确指定参数名称（不依赖于先前描述的检测策略），则可以使用<code>arg-names</code>建议元素的属性，其处理方式与<code>argNames</code>通知注释中的属性（如<a href="#aop-ataspectj-advice-params-names">确定参数名称中所述</a> ）。以下示例显示如何在XML中指定参数名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:before
    pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
    method="audit"
    arg-names="auditable"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>arg-names</code>属性接受以逗号分隔的参数名称列表。</p>
</div>
<div class="paragraph">
<p>以下是基于XSD的方法中涉及程度稍高的示例，显示了一些与许多强类型参数结合使用的建议：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package x.y.service;

public interface PersonService {

    Person getPerson(String personName, int age);
}

public class DefaultFooService implements FooService {

    public Person getPerson(String name, int age) {
        return new Person(name, age);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package x.y.service

interface PersonService {

    fun getPerson(personName: String, age: Int): Person
}

class DefaultFooService : FooService {

    fun getPerson(name: String, age: Int): Person {
        return Person(name, age)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是方面。请注意， <code>profile(..)</code>方法接受许多强类型参数，第一个恰好是用于进行方法调用的连接点。此参数的存在表明<code>profile(..)</code>用作<code>around</code>建议，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;

public class SimpleProfiler {

    public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
        StopWatch clock = new StopWatch("Profiling for '" + name + "' and '" + age + "'");
        try {
            clock.start(call.toShortString());
            return call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.aspectj.lang.ProceedingJoinPoint
import org.springframework.util.StopWatch

class SimpleProfiler {

    fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any {
        val clock = StopWatch("Profiling for '$name' and '$age'")
        try {
            clock.start(call.toShortString())
            return call.proceed()
        } finally {
            clock.stop()
            println(clock.prettyPrint())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，以下示例XML配置影响了特定连接点的上述建议的执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;
    &lt;bean id="personService" class="x.y.service.DefaultPersonService"/&gt;

    &lt;!-- this is the actual advice itself --&gt;
    &lt;bean id="profiler" class="x.y.SimpleProfiler"/&gt;

    &lt;aop:config&gt;
        &lt;aop:aspect ref="profiler"&gt;

            &lt;aop:pointcut id="theExecutionOfSomePersonServiceMethod"
                expression="execution(* x.y.service.PersonService.getPerson(String,int))
                and args(name, age)"/&gt;

            &lt;aop:around pointcut-ref="theExecutionOfSomePersonServiceMethod"
                method="profile"/&gt;

        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下驱动程序脚本：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.service.PersonService;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
        PersonService person = (PersonService) ctx.getBean("personService");
        person.getPerson("Pengo", 12);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val ctx = ClassPathXmlApplicationContext("x/y/plain.xml")
    val person = ctx.getBean("personService") as PersonService
    person.getPerson("Pengo", 12)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这样的Boot类，我们将在标准输出上获得类似于以下内容的输出：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ordering"><a class="anchor" href="#aop-ordering"></a>咨询订购</h5>
<div class="paragraph">
<p>当需要在同一连接点（执行方法）上执行多个建议时，排序规则如“ <a href="#aop-ataspectj-advice-ordering">建议排序”中所述</a> 。方面之间的优先级通过添加<code>Order</code>对支持方面的Bean的注释或通过使Bean实现<code>Ordered</code>接口。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-introductions"><a class="anchor" href="#aop-schema-introductions"></a> 5.5.4。引言</h4>
<div class="paragraph">
<p>简介（在AspectJ中称为类型间声明）使方面可以声明建议的对象实现给定的接口，并代表那些对象提供该接口的实现。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>aop:declare-parents</code>里面的元素<code>aop:aspect</code> 。您可以使用<code>aop:declare-parents</code>元素，以声明匹配的类型具有新的父级（因此而得名）。例如，给定一个名为<code>UsageTracked</code>以及名为该接口的实现<code>DefaultUsageTracked</code> ，以下方面声明服务接口的所有实现者也都实现了<code>UsageTracked</code>接口。（例如，为了通过JMX公开统计信息。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt;

    &lt;aop:declare-parents
        types-matching="com.xzy.myapp.service.*+"
        implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
        default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt;

    &lt;aop:before
        pointcut="com.xyz.myapp.SystemArchitecture.businessService()
            and this(usageTracked)"
            method="recordUsage"/&gt;

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持该类的类<code>usageTracking</code>然后，bean将包含以下方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun recordUsage(usageTracked: UsageTracked) {
    usageTracked.incrementUseCount()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要实现的接口由<code>implement-interface</code>属性。的价值<code>types-matching</code>属性是一个AspectJ类型的模式。任何匹配类型的bean都会实现<code>UsageTracked</code>接口。请注意，在前面示例的之前建议中，服务Bean可以直接用作<code>UsageTracked</code>接口。要以编程方式访问bean，可以编写以下代码：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val usageTracked = context.getBean("myService") as UsageTracked</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-instatiation-models"><a class="anchor" href="#aop-schema-instatiation-models"></a> 5.5.5。方面实例化模型</h4>
<div class="paragraph">
<p>模式定义方面唯一受支持的实例化模型是单例模型。在将来的版本中可能会支持其他实例化模型。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advisors"><a class="anchor" href="#aop-schema-advisors"></a> 5.5.6。顾问</h4>
<div class="paragraph">
<p>“顾问”的概念来自Spring中定义的AOP支持，并且在AspectJ中没有直接等效的概念。顾问就像一个独立的小方面，只有一条建议。通知本身由bean表示，并且必须实现<a href="#aop-api-advice-types">Spring的“建议类型”中</a>描述的建议接口<a href="#aop-api-advice-types">之一</a> 。顾问可以利用AspectJ切入点表达式。</p>
</div>
<div class="paragraph">
<p>Spring通过以下方式支持顾问程序概念： <code><aop:advisor></code>元件。您通常会看到它与事务建议结合使用，事务建议在Spring中也有其自己的名称空间支持。以下示例显示顾问程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:pointcut id="businessService"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

    &lt;aop:advisor
        pointcut-ref="businessService"
        advice-ref="tx-advice"/&gt;

&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="*" propagation="REQUIRED"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及<code>pointcut-ref</code>上例中使用的属性，您也可以使用<code>pointcut</code>属性定义一个内联切入点表达式。</p>
</div>
<div class="paragraph">
<p>要定义顾问的优先级，以便该建议可以参与订购，请使用<code>order</code>属性来定义<code>Ordered</code>顾问的价值。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-example"><a class="anchor" href="#aop-schema-example"></a> 5.5.7。AOP模式示例</h4>
<div class="paragraph">
<p>本节说明使用模式支持重写时， <a href="#aop-ataspectj-example">AOP示例中</a>的并发锁定失败重试示例<a href="#aop-ataspectj-example">的</a>外观。</p>
</div>
<div class="paragraph">
<p>有时由于并发问题（例如，死锁失败者），业务服务的执行可能会失败。如果重试该操作，则很可能在下一次尝试中成功。对于适合在这种情况下重试的业务服务（不需要重新返回给用户以解决冲突的幂等操作），我们希望透明地重试该操作，以避免客户看到<code>PessimisticLockingFailureException</code> 。这项要求明确地跨越了服务层中的多个服务，因此非常适合通过一个方面实施。</p>
</div>
<div class="paragraph">
<p>因为我们想重试该操作，所以我们需要使用一些建议，以便我们可以调用<code>proceed</code>多次。以下清单显示了基本方面的实现（这是使用模式支持的常规Java类）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ConcurrentOperationExecutor implements Ordered {

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;
    private int order = 1;

    public void setMaxRetries(int maxRetries) {
        this.maxRetries = maxRetries;
    }

    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
        int numAttempts = 0;
        PessimisticLockingFailureException lockFailureException;
        do {
            numAttempts++;
            try {
                return pjp.proceed();
            }
            catch(PessimisticLockingFailureException ex) {
                lockFailureException = ex;
            }
        } while(numAttempts &lt;= this.maxRetries);
        throw lockFailureException;
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ConcurrentOperationExecutor : Ordered {

    private val DEFAULT_MAX_RETRIES = 2

    private var maxRetries = DEFAULT_MAX_RETRIES
    private var order = 1

    fun setMaxRetries(maxRetries: Int) {
        this.maxRetries = maxRetries
    }

    override fun getOrder(): Int {
        return this.order
    }

    fun setOrder(order: Int) {
        this.order = order
    }

    fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
        var numAttempts = 0
        var lockFailureException: PessimisticLockingFailureException
        do {
            numAttempts++
            try {
                return pjp.proceed()
            } catch (ex: PessimisticLockingFailureException) {
                lockFailureException = ex
            }

        } while (numAttempts &lt;= this.maxRetries)
        throw lockFailureException
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，方面实现了<code>Ordered</code>界面，以便我们可以将方面的优先级设置为高于交易建议（每次重试时都需要一个新的交易）。的<code>maxRetries</code>和<code>order</code>属性都由Spring配置。主要动作发生在<code>doConcurrentOperation</code>周围的建议方法。我们尝试继续。如果我们失败了<code>PessimisticLockingFailureException</code> ，我们将再试一次，除非我们用尽了所有的重试尝试。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该类与@AspectJ示例中使用的类相同，但是除去了注释。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>相应的Spring配置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;

    &lt;aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor"&gt;

        &lt;aop:pointcut id="idempotentOperation"
            expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

        &lt;aop:around
            pointcut-ref="idempotentOperation"
            method="doConcurrentOperation"/&gt;

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;

&lt;bean id="concurrentOperationExecutor"
    class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
        &lt;property name="maxRetries" value="3"/&gt;
        &lt;property name="order" value="100"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，目前我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入以下内容来优化方面，使其仅重试真正的幂等操作。 <code>Idempotent</code>注释，并使用该注释来注释服务操作的实现，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    // marker annotation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
annotation class Idempotent {
    // marker annotation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>方面的更改仅重试幂等操作涉及精简切入点表达式，以便<code>@Idempotent</code>操作匹配，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:pointcut id="idempotentOperation"
        expression="execution(* com.xyz.myapp.service.*.*(..)) and
        @annotation(com.xyz.myapp.service.Idempotent)"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-choosing"><a class="anchor" href="#aop-choosing"></a> 5.6。选择要使用的AOP声明样式</h3>
<div class="paragraph">
<p>一旦确定方面是实现给定需求的最佳方法，您如何决定在使用Spring AOP或AspectJ以及在Aspect语言（代码）样式，@ AspectJ批注样式或Spring XML样式之间进行选择？这些决定受许多因素影响，包括应用程序需求，开发工具和团队对AOP的熟悉程度。</p>
</div>
<div class="sect3">
<h4 id="aop-spring-or-aspectj"><a class="anchor" href="#aop-spring-or-aspectj"></a> 5.6.1。Spring AOP还是Full AspectJ？</h4>
<div class="paragraph">
<p>使用最简单的方法即可。Spring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器/编织器。如果您只需要建议在Spring bean上执行操作，则Spring AOP是正确的选择。如果您需要建议不受Spring容器管理的对象（通常是域对象），则需要使用AspectJ。如果您希望建议除简单方法执行以外的连接点（例如，字段get或设置连接点等），则还需要使用AspectJ。</p>
</div>
<div class="paragraph">
<p>使用AspectJ时，可以选择AspectJ语言语法（也称为“代码样式”）或@AspectJ注释样式。显然，如果您不使用Java 5+，则已经为您做出了选择：使用代码样式。如果方面在您的设计中起着重要作用，并且您能够使用用于Eclipse的<a href="https://www.eclipse.org/ajdt/">AspectJ开发工具（AJDT）</a>插件，则AspectJ语言语法是首选。它更干净，更简单，因为该语言是专为编写方面而设计的。如果您不使用Eclipse或只有少数几个方面在您的应用程序中不起作用，那么您可能要考虑使用@AspectJ样式，在IDE中坚持常规Java编译，并向其中添加方面编织阶段您的构建脚本。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-or-xml"><a class="anchor" href="#aop-ataspectj-or-xml"></a> 5.6.2。@AspectJ或Spring AOP的XML？</h4>
<div class="paragraph">
<p>如果您选择使用Spring AOP，则可以选择@AspectJ或XML样式。有各种折衷考虑。</p>
</div>
<div class="paragraph">
<p>XML样式可能是现有Spring用户最熟悉的，并且得到了真正的POJO的支持。当使用AOP作为配置企业服务的工具时，XML可能是一个不错的选择（一个很好的测试是您是否将切入点表达式视为配置的一部分，您可能希望独立更改）。使用XML样式，可以说从您的配置中可以更清楚地了解系统中存在哪些方面。</p>
</div>
<div class="paragraph">
<p>XML样式有两个缺点。首先，它没有完全将要解决的需求的实现封装在一个地方。DRY原则说，系统中的任何知识都应该有一个单一，明确，权威的表示形式。使用XML样式时，关于如何实现需求的知识会在配置文件中的后备bean类的声明和XML中分散。当您使用@AspectJ样式时，此信息将封装在一个模块中：方面。其次，与@AspectJ样式相比，XML样式在表达能力上有更多限制：仅支持“单例”方面实例化模型，并且无法组合以XML声明的命名切入点。例如，使用@AspectJ样式，您可以编写如下内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Pointcut("execution(* get*())")
public void propertyAccess() {}

@Pointcut("execution(org.xyz.Account+ *(..))")
public void operationReturningAnAccount() {}

@Pointcut("propertyAccess() &amp;&amp; operationReturningAnAccount()")
public void accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Pointcut("execution(* get*())")
fun propertyAccess() {}

@Pointcut("execution(org.xyz.Account+ *(..))")
fun operationReturningAnAccount() {}

@Pointcut("propertyAccess() &amp;&amp; operationReturningAnAccount()")
fun accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在XML样式中，您可以声明前两个切入点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:pointcut id="propertyAccess"
        expression="execution(* get*())"/&gt;

&lt;aop:pointcut id="operationReturningAnAccount"
        expression="execution(org.xyz.Account+ *(..))"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>XML方法的缺点是您无法定义<code>accountPropertyAccess</code>通过结合这些定义切入点。</p>
</div>
<div class="paragraph">
<p>@AspectJ样式支持其他实例化模型和更丰富的切入点组合。它具有将方面保持为模块化单元的优势。它还具有的优点是，Spring AOP和AspectJ都可以理解@AspectJ方面。因此，如果您以后决定需要AspectJ的功能来实现其他要求，则可以轻松地迁移到经典的AspectJ设置。总而言之，Spring团队在自定义方面更喜欢@AspectJ样式，而不是简单地配置企业服务。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-mixing-styles"><a class="anchor" href="#aop-mixing-styles"></a> 5.7。混合方面类型</h3>
<div class="paragraph">
<p>通过使用模式定义的自动代理支持，可以完美地混合@AspectJ样式方面<code><aop:aspect></code>方面， <code><aop:advisor></code>在相同的配置中声明的顾问，甚至其他样式的代理和拦截器。所有这些都是通过使用相同的基础支持机制实现的，并且可以毫无困难地共存。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-proxying"><a class="anchor" href="#aop-proxying"></a> 5.8。代理机制</h3>
<div class="paragraph">
<p>Spring AOP使用JDK动态代理或CGLIB创建给定目标对象的代理。JDK内置了JDK动态代理，而CGLIB是常见的开源类定义库（重新打包为<code>spring-core</code> ）。</p>
</div>
<div class="paragraph">
<p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。代理了由目标类型实现的所有接口。如果目标对象未实现任何接口，则将创建CGLIB代理。</p>
</div>
<div class="paragraph">
<p>如果要强制使用CGLIB代理（例如，代理为目标对象定义的每个方法，而不仅是由其接口实现的方法），都可以这样做。但是，您应该考虑以下问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用CGLIB， <code>final</code>不能建议使用方法，因为不能在运行时生成的子类中覆盖这些方法。</p>
</li>
<li>
<p>从Spring 4.0开始，由于CGLIB代理实例是通过Objenesis创建的，因此不再调用代理对象的构造函数两次。仅当您的JVM不允许绕过构造函数时，您才可能从Spring的AOP支持中看到两次调用和相应的调试日志条目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要强制使用CGLIB代理，请设置<code>proxy-target-class</code>的属性<code><aop:config></code>元素设置为true，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config proxy-target-class="true"&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在使用@AspectJ自动代理支持时强制CGLIB代理，请设置<code>proxy-target-class</code>的属性<code><aop:aspectj-autoproxy></code>元素<code>true</code> ， 如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>多<code><aop:config/></code>部分折叠到在运行时一个统一的自动代理的创建者，其应用<em>最强的</em>代理设置任何的<code><aop:config/></code>指定的部分（通常来自不同的XML bean定义文件）。这也适用于<code><tx:annotation-driven/></code>和<code><aop:aspectj-autoproxy/></code>元素。</p>
</div>
<div class="paragraph">
<p>要清楚，使用<code>proxy-target-class="true"</code>上<code><tx:annotation-driven/></code> ， <code><aop:aspectj-autoproxy/></code> ， 要么<code><aop:config/></code>元素强制<em>对所有三个</em>元素使用CGLIB代理。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="aop-understanding-aop-proxies"><a class="anchor" href="#aop-understanding-aop-proxies"></a> 5.8.1。了解AOP代理</h4>
<div class="paragraph">
<p>Spring AOP是基于代理的。在编写自己的方面或使用Spring Framework 随附的任何基于Spring AOP的方面之前，掌握最后一条语句实际含义的语义至关重要。</p>
</div>
<div class="paragraph">
<p>首先考虑您有一个普通的，未经代理的，无特殊要求的，直接的对象引用的情况，如以下代码片段所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimplePojo implements Pojo {

    public void foo() {
        // this next method invocation is a direct call on the 'this' reference
        this.bar();
    }

    public void bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimplePojo : Pojo {

    fun foo() {
        // this next method invocation is a direct call on the 'this' reference
        this.bar()
    }

    fun bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图和清单所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-plain-pojo-call.png" alt="aop代理普通pojo呼叫">
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Main {

    public static void main(String[] args) {
        Pojo pojo = new SimplePojo();
        // this is a direct method call on the 'pojo' reference
        pojo.foo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val pojo = SimplePojo()
    // this is a direct method call on the 'pojo' reference
    pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当客户端代码具有的引用是代理时，情况会稍有变化。考虑以下图表和代码片段：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-call.png" alt="aop代理呼叫">
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Main {

    public static void main(String[] args) {
        ProxyFactory factory = new ProxyFactory(new SimplePojo());
        factory.addInterface(Pojo.class);
        factory.addAdvice(new RetryAdvice());

        Pojo pojo = (Pojo) factory.getProxy();
        // this is a method call on the proxy!
        pojo.foo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val factory = ProxyFactory(SimplePojo())
    factory.addInterface(Pojo::class.java)
    factory.addAdvice(RetryAdvice())

    val pojo = factory.proxy as Pojo
    // this is a method call on the proxy!
    pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里要了解的关键是， <code>main(..)</code>的方法<code>Main</code>类具有对代理的引用。这意味着该对象引用上的方法调用是代理上的调用。结果，代理可以委派给与该特定方法调用相关的所有拦截器（建议）。但是，一旦调用最终到达目标对象（ <code>SimplePojo</code> ，在这种情况下为引用），它可能对其自身进行的任何方法调用，例如<code>this.bar()</code>要么<code>this.foo()</code> ，将针对<code>this</code>参考，而不是代理。这具有重要的意义。这意味着自调用不会导致与方法调用相关的建议得到执行的机会。</p>
</div>
<div class="paragraph">
<p>好吧，那么该怎么办？最佳方法（在这里宽松地使用术语“最佳”）是重构代码，以免发生自调用。这确实需要您做一些工作，但这是最好的，侵入性最小的方法。下一种方法绝对可怕，我们正要指出这一点，恰恰是因为它是如此可怕。您可以（对我们来说是痛苦的）完全将类中的逻辑与Spring AOP绑定在一起，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimplePojo implements Pojo {

    public void foo() {
        // this works, but... gah!
        ((Pojo) AopContext.currentProxy()).bar();
    }

    public void bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimplePojo : Pojo {

    fun foo() {
        // this works, but... gah!
        (AopContext.currentProxy() as Pojo).bar()
    }

    fun bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将您的代码完全耦合到Spring AOP，并且使类本身意识到在AOP上下文中使用它的事实，而AOP上下文却是这样。创建代理时，还需要一些其他配置，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Main {

    public static void main(String[] args) {
        ProxyFactory factory = new ProxyFactory(new SimplePojo());
        factory.addInterface(Pojo.class);
        factory.addAdvice(new RetryAdvice());
        factory.setExposeProxy(true);

        Pojo pojo = (Pojo) factory.getProxy();
        // this is a method call on the proxy!
        pojo.foo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun main() {
    val factory = ProxyFactory(SimplePojo())
    factory.addInterface(Pojo::class.java)
    factory.addAdvice(RetryAdvice())
    factory.isExposeProxy = true

    val pojo = factory.proxy as Pojo
    // this is a method call on the proxy!
    pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，必须注意，AspectJ没有此自调用问题，因为它不是基于代理的AOP框架。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-aspectj-programmatic"><a class="anchor" href="#aop-aspectj-programmatic"></a> 5.9。以编程方式创建@AspectJ代理</h3>
<div class="paragraph">
<p>除了使用以下任一方法在配置中声明方面<code><aop:config></code>要么<code><aop:aspectj-autoproxy></code> ，也可以通过编程方式创建建议目标对象的代理。有关Spring的AOP API的完整详细信息，请参见<a href="#aop-api">下一章</a> 。在这里，我们要重点介绍通过使用@AspectJ方面自动创建代理的功能。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code>类为一个或多个@AspectJ方面建议的目标对象创建代理。此类的基本用法非常简单，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// create a factory that can generate a proxy for the given target object
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager.class);

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker);

// now get the proxy object...
MyInterfaceType proxy = factory.getProxy();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// create a factory that can generate a proxy for the given target object
val factory = AspectJProxyFactory(targetObject)

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager::class.java)

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker)

// now get the proxy object...
val proxy = factory.getProxy&lt;Any&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html">javadoc</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-using-aspectj"><a class="anchor" href="#aop-using-aspectj"></a> 5.10。在Spring应用程序中使用AspectJ</h3>
<div class="paragraph">
<p>到目前为止，本章介绍的所有内容都是纯Spring AOP。在本节中，我们研究了如果您的需求超出了Spring AOP所提供的功能，那么如何使用AspectJ编译器或weaver代替Spring AOP或除Spring AOP之外使用。</p>
</div>
<div class="paragraph">
<p>Spring附带一个小的AspectJ方面库，可以在您的发行版中独立使用<code>spring-aspects.jar</code> 。您需要将其添加到类路径中才能使用其中的方面。<a href="#aop-atconfigurable">使用AspectJ依赖于Spring</a>和<a href="#aop-ajlib-other">AspectJ的其他Spring方面来</a> <a href="#aop-atconfigurable">注入域对象</a>以及<a href="#aop-ajlib-other">AspectJ</a>讨论了该库的内容以及如何使用它。<a href="#aop-aj-configure">使用Spring IoC配置AspectJ方面</a>讨论了如何依赖注入使用AspectJ编译器编织的AspectJ方面。最后， <a href="#aop-aj-ltw">Spring Framework</a>中使用AspectJ进行的加载时编织为使用AspectJ的Spring应用程序提供了加载时编织的介绍。</p>
</div>
<div class="sect3">
<h4 id="aop-atconfigurable"><a class="anchor" href="#aop-atconfigurable"></a> 5.10.1。使用AspectJ通过Spring依赖注入域对象</h4>
<div class="paragraph">
<p>Spring容器实例化并配置在您的应用程序上下文中定义的bean。给定包含要应用的配置的Bean定义的名称，也可以要求Bean工厂配置预先存在的对象。
<code>spring-aspects.jar</code>包含注释驱动的方面，该方面利用此功能允许依赖项注入任何对象。该支撑旨在用于在任何容器的控制范围之外创建的对象。域对象通常属于此类，因为它们通常是使用<code>new</code>操作员或通过ORM工具作为数据库查询的结果。</p>
</div>
<div class="paragraph">
<p>的<code>@Configurable</code>注释将一个类标记为符合Spring驱动的配置的条件。在最简单的情况下，您可以将其纯粹用作标记注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable
public class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.xyz.myapp.domain

import org.springframework.beans.factory.annotation.Configurable

@Configurable
class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当以此方式用作标记接口时，Spring会配置带注释类型的新实例（ <code>Account</code> ，在这种情况下，使用与完全合格的类型名称同名的Bean定义（通常是原型作用域） <code>com.xyz.myapp.domain.Account</code> ）。由于Bean的默认名称是其类型的全限定名称，因此声明原型定义的简便方法是省略<code>id</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="com.xyz.myapp.domain.Account" scope="prototype"&gt;
    &lt;property name="fundsTransferService" ref="fundsTransferService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要显式指定要使用的原型bean定义的名称，则可以直接在批注中这样做，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable("account")
public class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.xyz.myapp.domain

import org.springframework.beans.factory.annotation.Configurable

@Configurable("account")
class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring现在正在寻找一个名为<code>account</code>并将其用作定义新配置的定义<code>Account</code>实例。</p>
</div>
<div class="paragraph">
<p>您也可以使用自动装配来避免完全指定专用的bean定义。要让Spring应用自动装配，请使用<code>autowire</code>的属性<code>@Configurable</code>注解。您可以指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>要么<code>@Configurable(autowire=Autowire.BY_NAME</code>分别按类型或名称自动接线。或者，最好为您的注释指定显式的，注释驱动的依赖项注入。 <code>@Configurable</code>通过豆<code>@Autowired</code>要么<code>@Inject</code>在字段或方法级别（有关更多详细信息，请参见<a href="#beans-annotation-config">基于注释的容器配置</a> ）。</p>
</div>
<div class="paragraph">
<p>最后，您可以使用来为新创建和配置的对象中的对象引用启用Spring依赖项检查。 <code>dependencyCheck</code>属性（例如， <code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code> ）。如果此属性设置为<code>true</code> ，Spring在配置后验证是否已设置了所有属性（不是基元或集合）。</p>
</div>
<div class="paragraph">
<p>请注意，单独使用注释不会执行任何操作。它是<code>AnnotationBeanConfigurerAspect</code>在<code>spring-aspects.jar</code>对注释的存在起作用。从本质上讲，方面说：“从带有注释类型的新对象的初始化返回之后， <code>@Configurable</code> ，然后根据注释的属性使用Spring配置新创建的对象。在这种情况下，“初始化”是指新实例化的对象（例如，用<code>new</code>运算符）以及<code>Serializable</code>正在反序列化的对象（例如，通过<a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">readResolve（）</a> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>上段中的关键短语之一是“本质上”。在大多数情况下，“从新对象的初始化返回后”的确切语义是可以的。在这种情况下，“初始化之后”是指在构造对象之后注入依赖项。这意味着该依赖项不可在类的构造函数体中使用。如果希望在构造函数主体执行之前注入依赖项，从而可以在构造函数主体中使用依赖项，则需要在<code>@Configurable</code>声明如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configurable(preConstruction = true)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configurable(preConstruction = true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以<a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">在</a> 《 <a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ编程指南》的</a> <a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">附录</a>中找到有关AspectJ <a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">中</a>各种切入点类型的语言语义的更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为此，必须将带注释的类型与AspectJ编织器编织在一起。您可以使用构建时Ant或Maven任务来执行此操作（例如，请参见<a href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ开发环境指南</a> ），也可以使用加载时编织（请参见<a href="#aop-aj-ltw">Spring Framework中的使用AspectJ进行加载时编织</a> ）。的<code>AnnotationBeanConfigurerAspect</code>本身需要由Spring进行配置（以获取对将用于配置新对象的Bean工厂的引用）。如果您使用基于Java的配置，则可以添加<code>@EnableSpringConfigured</code>去任何<code>@Configuration</code>类，如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableSpringConfigured
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableSpringConfigured
class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您更喜欢基于XML的配置，那么Spring <a href="#xsd-schemas-context"><code>context</code>命名空间</a>定义了一个方便<code>context:spring-configured</code>元素，您可以如下使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context:spring-configured/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的实例<code>@Configurable</code>在配置方面之前创建的对象会导致向调试日志发出一条消息，并且不会进行对象的配置。一个示例可能是Spring配置中的bean，当它由Spring初始化时会创建域对象。在这种情况下，您可以使用<code>depends-on</code> bean属性，以手动指定bean取决于配置方面。以下示例显示了如何使用<code>depends-on</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myService"
        class="com.xzy.myapp.service.MyService"
        depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"&gt;

    &lt;!-- ... --&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不要激活<code>@Configurable</code>除非您真的想在运行时依赖它的语义，否则将通过bean配置器方面进行处理。特别是，请确保不要使用<code>@Configurable</code>在使用容器注册为常规Spring bean的bean类上。这样做会导致两次初始化，一次是通过容器，一次是通过方面。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="aop-configurable-testing"><a class="anchor" href="#aop-configurable-testing"></a>单元测试<code>@Configurable</code>对象</h5>
<div class="paragraph">
<p>的目标之一<code>@Configurable</code>支持是实现域对象的独立单元测试，而不会遇到与硬编码查找相关的困难。如果<code>@Configurable</code>尚未由AspectJ编织类型，注释在单元测试期间没有影响。您可以在被测对象中设置模拟或存根属性引用，然后照常进行。如果<code>@Configurable</code>类型由AspectJ编织而成，您仍然可以像往常一样在容器外部进行单元测试，但是每次构造一个<code>@Configurable</code>表示尚未由Spring配置的对象。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-configurable-container"><a class="anchor" href="#aop-configurable-container"></a>使用多个应用程序上下文</h5>
<div class="paragraph">
<p>的<code>AnnotationBeanConfigurerAspect</code>用于实现<code>@Configurable</code>支持是AspectJ单例方面。单例方面的范围与的范围相同<code>static</code>成员：每个类加载器都有一个方面实例来定义类型。这意味着，如果您在同一个类加载器层次结构中定义多个应用程序上下文，则需要考虑在何处定义<code>@EnableSpringConfigured</code>豆和放置位置<code>spring-aspects.jar</code>在类路径上。</p>
</div>
<div class="paragraph">
<p>考虑一个典型的Spring Web应用程序配置，该配置具有一个共享的父应用程序上下文，该上下文定义了通用的业务服务，支持那些服务所需的一切，以及每个Servlet的一个子应用程序上下文（其中包含该Servlet的特定定义）。所有这些上下文共存于相同的类加载器层次结构中，因此<code>AnnotationBeanConfigurerAspect</code>只能引用其中之一。在这种情况下，我们建议定义<code>@EnableSpringConfigured</code>共享（父）应用程序上下文中的bean。这定义了您可能想注入域对象的服务。结果是，您无法使用@Configurable机制来配置域对象，该域对象引用的是在子（特定于servlet的）上下文中定义的bean的引用（无论如何，这可能不是您想要做的）。</p>
</div>
<div class="paragraph">
<p>在同一容器中部署多个Web应用程序时，请确保每个Web应用程序将类型加载到<code>spring-aspects.jar</code>通过使用自己的类加载器（例如，通过放置<code>spring-aspects.jar</code>在<code>'WEB-INF/lib'</code> ）。如果<code>spring-aspects.jar</code>仅将其添加到容器级的类路径中（并因此由共享的父类加载器加载），所有Web应用程序共享相同的方面实例（可能不是您想要的）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ajlib-other"><a class="anchor" href="#aop-ajlib-other"></a> 5.10.2。AspectJ的其他Spring方面</h4>
<div class="paragraph">
<p>除了<code>@Configurable</code>方面， <code>spring-aspects.jar</code>包含一个AspectJ方面，您可以使用它来驱动Spring的事务管理，以管理带有注释的类型和方法。 <code>@Transactional</code>注解。这主要适用于希望在Spring容器之外使用Spring Framework的事务支持的用户。</p>
</div>
<div class="paragraph">
<p>解释的方面<code>@Transactional</code>注释是<code>AnnotationTransactionAspect</code> 。使用此方面时，必须注释实现类（或该类中的方法或两者），而不是注释该类所实现的接口（如果有）。AspectJ遵循Java的规则，即不继承接口上的注释。</p>
</div>
<div class="paragraph">
<p>一种<code>@Transactional</code>类上的注释指定用于执行类中任何公共操作的默认事务语义。</p>
</div>
<div class="paragraph">
<p>一种<code>@Transactional</code>类内方法的注解会覆盖类注解（如果存在）给出的默认事务语义。可以注释任何可见性的方法，包括私有方法。直接注释非公共方法是执行此类方法而获得事务划分的唯一方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">从Spring Framework 4.2开始， <code>spring-aspects</code>提供相似的方面，为标准提供完全相同的功能<code>javax.transaction.Transactional</code>注解。校验<code>JtaAnnotationTransactionAspect</code>更多细节。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于想要使用Spring配置和事务管理支持但又不想（或不能）使用注释的AspectJ程序员， <code>spring-aspects.jar</code>还包含<code>abstract</code>您可以扩展以提供自己的切入点定义的方面。请参阅源<code>AbstractBeanConfigurerAspect</code>和<code>AbstractTransactionAspect</code>有关更多信息的方面。例如，以下摘录显示了如何编写方面来使用与完全限定的类名匹配的原型Bean定义来配置域模型中定义的对象的所有实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

    public DomainObjectConfiguration() {
        setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
    }

    // the creation of a new bean (any object in the domain model)
    protected pointcut beanCreation(Object beanInstance) :
        initialization(new(..)) &amp;&amp;
        SystemArchitecture.inDomainModel() &amp;&amp;
        this(beanInstance);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-configure"><a class="anchor" href="#aop-aj-configure"></a> 5.10.3。使用Spring IoC配置AspectJ Aspects</h4>
<div class="paragraph">
<p>当您将AspectJ方面与Spring应用程序一起使用时，既自然又希望能够使用Spring配置这些方面。AspectJ运行时本身负责创建方面，并且通过Spring配置AspectJ创建的方面的方法取决于AspectJ实例化模型（ <code>per-xxx</code>条款使用的条款）。</p>
</div>
<div class="paragraph">
<p>AspectJ的大多数方面都是单例方面。这些方面的配置很容易。您可以创建一个bean定义，该bean定义按常规引用方面类型并包括<code>factory-method="aspectOf"</code> bean属性。这样可以确保Spring通过向AspectJ索要长宽比实例，而不是尝试自己创建实例来获得长宽比实例。以下示例显示了如何使用<code>factory-method="aspectOf"</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="profiler" class="com.xyz.profiler.Profiler"
        factory-method="aspectOf"&gt; <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;property name="profilingStrategy" ref="jamonProfilingStrategy"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注意<code>factory-method="aspectOf"</code>属性</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>非单一方面很难配置。但是，可以通过创建原型bean定义并使用<code>@Configurable</code>来自的支持<code>spring-aspects.jar</code>一旦AspectJ运行时创建了bean，就配置方面实例。</p>
</div>
<div class="paragraph">
<p>如果您有一些要与AspectJ编织的@AspectJ方面（例如，对域模型类型使用加载时编织）以及要与Spring AOP一起使用的其他@AspectJ方面，那么这些方面都已在Spring中配置，您需要告诉Spring AOP @AspectJ自动代理支持，应使用配置中定义的@AspectJ方面的确切子集进行自动代理。您可以使用一个或多个来做到这一点<code><include/></code>里面的元素<code><aop:aspectj-autoproxy/></code>宣言。每<code><include/></code>元素指定一个名称模式，并且只有名称与至少一个模式匹配的bean才可用于Spring AOP自动代理配置。以下示例显示了如何使用<code><include/></code>元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:aspectj-autoproxy&gt;
    &lt;aop:include name="thisBean"/&gt;
    &lt;aop:include name="thatBean"/&gt;
&lt;/aop:aspectj-autoproxy&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不要被名称误导<code><aop:aspectj-autoproxy/></code>元件。使用它可以创建Spring AOP代理。这里使用的是@AspectJ样式的方面声明，但不涉及AspectJ运行时。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw"><a class="anchor" href="#aop-aj-ltw"></a> 5.10.4。在Spring Framework中使用AspectJ进行加载时编织</h4>
<div class="paragraph">
<p>加载时编织（LTW）是指将AspectJ方面加载到应用程序的类文件中时将其编织到Java虚拟机（JVM）中的过程。本节的重点是在Spring Framework 的特定上下文中配置和使用LTW。本节不是LTW的一般介绍。有关LTW的详细信息以及仅使用AspectJ配置LTW（完全不涉及Spring）的详细信息，请参阅<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">《 AspectJ开发环境指南》</a>的<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">LTW部分</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Framework 为AspectJ LTW带来的价值在于能够对编织过程进行更精细的控制。“ Vanilla” AspectJ LTW是通过使用Java（5+）代理来实现的，该代理在启动JVM时通过指定VM参数来打开。因此，它是JVM范围的设置，在某些情况下可能很好，但通常有点过于粗糙。启用了Spring的LTW可让您在每个<code>ClassLoader</code>一个更细粒度的基础，并且在“单个JVM-多个应用程序”环境（例如在典型的应用程序服务器环境中发现）中更有意义。</p>
</div>
<div class="paragraph">
<p>此外， <a href="#aop-aj-ltw-environments">在某些环境中</a> ，此支持可实现加载时编织，而无需对添加添加所需的应用程序服务器的启动脚本进行任何修改。 <code>-javaagent:path/to/aspectjweaver.jar</code>或（如本节稍后所述） <code>-javaagent:path/to/spring-instrument.jar</code> 。开发人员将应用程序上下文配置为启用加载时编织，而不是依赖通常负责部署配置（例如启动脚本）的管理员。</p>
</div>
<div class="paragraph">
<p>现在，销售工作已经结束，让我们首先浏览一个使用Spring的AspectJ LTW的快速示例，然后详细介绍该示例中引入的元素。有关完整示例，请参见<a href="https://github.com/spring-projects/spring-petclinic">Petclinic示例应用程序</a> 。</p>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-first-example"><a class="anchor" href="#aop-aj-ltw-first-example"></a>第一个例子</h5>
<div class="paragraph">
<p>假设您是一位负责诊断系统中某些性能问题的原因的应用程序开发人员。我们将打开一个简单的配置方面，而不是使用配置文件工具，使我们可以快速获取一些性能指标。然后，我们可以立即在该特定区域应用更细粒度的分析工具。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此处提供的示例使用XML配置。您还可以配置@AspectJ并将其与<a href="#beans-java">Java配置</a>一起使用。具体来说，您可以使用<code>@EnableLoadTimeWeaving</code>注释替代<code><context:load-time-weaver/></code> （有关详情，请参见<a href="#aop-aj-ltw-spring">下文</a> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例显示了配置方面的信息，这并不理想。这是一个基于时间的探查器，它使用@AspectJ样式的方面声明：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package foo;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.util.StopWatch;
import org.springframework.core.annotation.Order;

@Aspect
public class ProfilingAspect {

    @Around("methodsToBeProfiled()")
    public Object profile(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch sw = new StopWatch(getClass().getSimpleName());
        try {
            sw.start(pjp.getSignature().getName());
            return pjp.proceed();
        } finally {
            sw.stop();
            System.out.println(sw.prettyPrint());
        }
    }

    @Pointcut("execution(public * foo..<strong>.</strong>(..))")
    public void methodsToBeProfiled(){}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package foo

import org.aspectj.lang.ProceedingJoinPoint
import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Around
import org.aspectj.lang.annotation.Pointcut
import org.springframework.util.StopWatch
import org.springframework.core.annotation.Order

@Aspect
class ProfilingAspect {

    @Around("methodsToBeProfiled()")
    fun profile(pjp: ProceedingJoinPoint): Any {
        val sw = StopWatch(javaClass.simpleName)
        try {
            sw.start(pjp.getSignature().getName())
            return pjp.proceed()
        } finally {
            sw.stop()
            println(sw.prettyPrint())
        }
    }

    @Pointcut("execution(public * foo..<strong>.</strong>(..))")
    fun methodsToBeProfiled() {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还需要创建一个<code>META-INF/aop.xml</code>文件，以通知AspectJ编织者我们要编织我们的<code>ProfilingAspect</code>进入我们的班级。此文件约定，即在Java类路径上存在一个或多个文件，称为<code>META-INF/aop.xml</code>是标准的AspectJ。以下示例显示了<code>aop.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;
&lt;aspectj&gt;

    &lt;weaver&gt;
        &lt;!-- only weave classes in our application-specific packages --&gt;
        &lt;include within="foo.*"/&gt;
    &lt;/weaver&gt;

    &lt;aspects&gt;
        &lt;!-- weave in just this aspect --&gt;
        &lt;aspect name="foo.ProfilingAspect"/&gt;
    &lt;/aspects&gt;

&lt;/aspectj&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以继续进行配置中特定于Spring的部分。我们需要配置一个<code>LoadTimeWeaver</code> （稍后说明）。该加载时织工是负责将方面配置编织到一个或多个中的基本组件<code>META-INF/aop.xml</code>文件放入应用程序的类中。好处是，它不需要很多配置（您可以指定一些其他选项，但是稍后会详细介绍），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- a service object; we will be profiling its methods --&gt;
    &lt;bean id="entitlementCalculationService"
            class="foo.StubEntitlementCalculationService"/&gt;

    &lt;!-- this switches on the load-time weaving --&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，所有必需的工件（方面， <code>META-INF/aop.xml</code>文件和Spring配置），我们可以使用<code>main(..)</code>演示LTW的方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService =
                (EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

        // the profiling aspect is 'woven' around this method execution
        entitlementCalculationService.calculateEntitlement();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package foo

import org.springframework.context.support.ClassPathXmlApplicationContext

fun main() {
    val ctx = ClassPathXmlApplicationContext("beans.xml")

    val entitlementCalculationService = ctx.getBean("entitlementCalculationService") as EntitlementCalculationService

    // the profiling aspect is 'woven' around this method execution
    entitlementCalculationService.calculateEntitlement()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还有最后一件事要做。本节的引言确实说过，每个人都可以选择打开LTW。 <code>ClassLoader</code>以Spring为基础，这是事实。但是，对于此示例，我们使用Java代理（Spring随附）打开LTW。我们使用以下命令来运行<code>Main</code>前面显示的类：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>-javaagent</code>是用于指定和启用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">代理以对在JVM上运行的程序进行检测</a>的标志。 Spring Framework附带了这样的代理， <code>InstrumentationSavingAgent</code> ，包装在<code>spring-instrument.jar</code>作为价值提供<code>-javaagent</code>上例中的参数。</p>
</div>
<div class="paragraph">
<p>执行的输出<code>Main</code>程序类似于下一个示例。（我介绍了一个<code>Thread.sleep(..)</code>声明成<code>calculateEntitlement()</code>实现，以便探查器实际上捕获的不是0毫秒（ <code>01234</code>毫秒不是AOP引入的开销。以下清单显示了运行分析器时得到的输出：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>
</div>
</div>
<div class="paragraph">
<p>由于此LTW是通过使用成熟的AspectJ来实现的，因此我们不仅限于建议Spring Bean。以下对<code>Main</code>程序产生相同的结果：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {
        new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService =
                new StubEntitlementCalculationService();

        // the profiling aspect will be 'woven' around this method execution
        entitlementCalculationService.calculateEntitlement();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package foo

import org.springframework.context.support.ClassPathXmlApplicationContext

fun main(args: Array&lt;String&gt;) {
    ClassPathXmlApplicationContext("beans.xml")

    val entitlementCalculationService = StubEntitlementCalculationService()

    // the profiling aspect will be 'woven' around this method execution
    entitlementCalculationService.calculateEntitlement()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在前面的程序中，我们如何引导Spring容器，然后创建该容器的新实例。 <code>StubEntitlementCalculationService</code>完全不在Spring的范围内。剖析建议仍会被应用。</p>
</div>
<div class="paragraph">
<p>诚然，这个例子很简单。但是，在前面的示例中已经介绍了Spring中LTW支持的基础知识，本节的其余部分详细解释了每个配置和用法背后的“原因”。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>ProfilingAspect</code>在此示例中使用的可能是基本的，但它很有用。这是开发时方面的一个很好的示例，开发人员可以在开发过程中使用它，然后轻松地将其从部署到UAT或生产中的应用程序构建中排除。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-the-aspects"><a class="anchor" href="#aop-aj-ltw-the-aspects"></a>方面</h5>
<div class="paragraph">
<p>您在LTW中使用的方面必须是AspectJ方面。您可以使用AspectJ语言本身来编写它们，也可以使用@AspectJ风格来编写方面。这样，您的方面就是有效的AspectJ和Spring AOP方面。此外，编译的方面类需要在类路径上可用。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-aop_dot_xml"><a class="anchor" href="#aop-aj-ltw-aop_dot_xml"></a> 'META-INF / aop.xml'</h5>
<div class="paragraph">
<p>通过使用一个或多个来配置AspectJ LTW基础结构<code>META-INF/aop.xml</code> Java类路径上的文件（直接或通常在jar文件中）。</p>
</div>
<div class="paragraph">
<p>该文件的结构和内容在<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ参考文档</a>的LTW部分中进行了详细<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">说明</a> 。因为<code>aop.xml</code>文件是100％AspectJ，在此不再赘述。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-libraries"><a class="anchor" href="#aop-aj-ltw-libraries"></a>所需的库（JARS）</h5>
<div class="paragraph">
<p>至少，您需要以下库来使用Spring Framework对AspectJ LTW的支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-aop.jar</code></p>
</li>
<li>
<p><code>aspectjweaver.jar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您使用<a href="#aop-aj-ltw-environment-generic">Spring提供的代理来启用检测</a> ，则还需要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-instrument.jar</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-spring"><a class="anchor" href="#aop-aj-ltw-spring"></a>Spring 配置</h5>
<div class="paragraph">
<p>Spring的LTW支持中的关键组件是<code>LoadTimeWeaver</code>界面（在<code>org.springframework.instrument.classloading</code>软件包），以及Spring发行版附带的众多实现。一种<code>LoadTimeWeaver</code>负责添加一个或多个<code>java.lang.instrument.ClassFileTransformers</code>到<code>ClassLoader</code>在运行时，这为各种有趣的应用程序打开了大门，其中之一就是方面的LTW。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您不熟悉运行时类文件转换的概念，请参阅Javadoc API文档以了解<code>java.lang.instrument</code>包，然后继续。虽然该文档并不全面，但是至少您可以看到关键的接口和类（在您通读本节时作为参考）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置一个<code>LoadTimeWeaver</code>对于一个特定的<code>ApplicationContext</code>就像添加一行一样容易。（请注意，您几乎肯定需要使用<code>ApplicationContext</code>作为您的Spring容器-通常， <code>BeanFactory</code>还不够，因为LTW支持使用<code>BeanFactoryPostProcessors</code> ）</p>
</div>
<div class="paragraph">
<p>要启用Spring Framework的LTW支持，您需要配置一个<code>LoadTimeWeaver</code> ，通常使用<code>@EnableLoadTimeWeaving</code>注释，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableLoadTimeWeaving
class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果您更喜欢基于XML的配置，请使用<code><context:load-time-weaver/></code>元件。请注意，元素是在<code>context</code>命名空间。以下示例显示了如何使用<code><context:load-time-weaver/></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:load-time-weaver/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置自动定义并注册了许多LTW特定的基础结构Bean，例如<code>LoadTimeWeaver</code>和<code>AspectJWeavingEnabler</code> ， 为了你。默认值<code>LoadTimeWeaver</code>是个<code>DefaultContextLoadTimeWeaver</code>类，尝试装饰自动检测到的<code>LoadTimeWeaver</code> 。的确切类型<code>LoadTimeWeaver</code> “自动检测到”取决于您的运行时环境。下表总结了各种<code>LoadTimeWeaver</code>实现：</p>
</div>
<table id="aop-aj-ltw-spring-env-impls" class="tableblock frame-all grid-all spread">
<caption class="title">表13。DefaultContextLoadTimeWeaver LoadTimeWeavers</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">运行环境</th>
<th class="tableblock halign-left valign-top"><code>LoadTimeWeaver</code>实作</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在<a href="https://tomcat.apache.org/">Apache Tomcat中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在<a href="https://eclipse-ee4j.github.io/glassfish/">GlassFish中</a>运行（仅限EAR部署）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GlassFishLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Red Hat的<a href="https://www.jboss.org/jbossas/">JBoss AS</a>或<a href="https://www.wildfly.org/">WildFly中运行</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JBossLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在IBM的<a href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSphereLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Oracle的<a href="https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic中</a>运行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebLogicLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JVM从Spring开始<code>InstrumentationSavingAgent</code> （ <code>java -javaagent:path/to/spring-instrument.jar</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InstrumentationLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">回退，期望基础ClassLoader遵循通用约定（即<code>addTransformer</code>和可选的<code>getThrowawayClassLoader</code>方法）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveLoadTimeWeaver</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，该表仅列出了<code>LoadTimeWeavers</code>当您使用<code>DefaultContextLoadTimeWeaver</code> 。您可以确切指定<code>LoadTimeWeaver</code>实施使用。</p>
</div>
<div class="paragraph">
<p>指定一个特定的<code>LoadTimeWeaver</code>使用Java配置，实现<code>LoadTimeWeavingConfigurer</code>接口并覆盖<code>getLoadTimeWeaver()</code>方法。以下示例指定了<code>ReflectiveLoadTimeWeaver</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig implements LoadTimeWeavingConfigurer {

    @Override
    public LoadTimeWeaver getLoadTimeWeaver() {
        return new ReflectiveLoadTimeWeaver();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableLoadTimeWeaving
class AppConfig : LoadTimeWeavingConfigurer {

    override fun getLoadTimeWeaver(): LoadTimeWeaver {
        return ReflectiveLoadTimeWeaver()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用基于XML的配置，则可以将完全限定的类名指定为<code>weaver-class</code>的属性<code><context:load-time-weaver/></code>元件。同样，以下示例指定了<code>ReflectiveLoadTimeWeaver</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:load-time-weaver
            weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>LoadTimeWeaver</code>稍后可以使用众所周知的名称从Spring容器中检索由配置定义和注册的配置， <code>loadTimeWeaver</code> 。请记住<code>LoadTimeWeaver</code>仅作为Spring的LTW基础结构添加一个或多个的机制而存在<code>ClassFileTransformers</code> 。实际上<code>ClassFileTransformer</code> LTW是<code>ClassPreProcessorAgentAdapter</code> （来自<code>org.aspectj.weaver.loadtime</code>包）类。请参阅<code>ClassPreProcessorAgentAdapter</code>有关更多详细信息，请参见本类，因为实际如何进行编织的细节不在本文档的讨论范围之内。</p>
</div>
<div class="paragraph">
<p>该配置还有最后一个要讨论的属性： <code>aspectjWeaving</code>属性（或<code>aspectj-weaving</code>如果您使用XML）。此属性控制是否启用LTW。它接受三个可能的值之一，默认值为<code>autodetect</code>如果属性不存在。下表总结了三个可能的值：</p>
</div>
<table id="aop-aj-ltw-ltw-tag-attrs" class="tableblock frame-all grid-all spread">
<caption class="title">表14。AspectJ编织属性值</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注释值</th>
<th class="tableblock halign-left valign-top">XML值</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>on</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ正在编织，并且在加载时适当地编织了方面。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DISABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTW已关闭。加载时不会编织任何方面。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AUTODETECT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>autodetect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果Spring LTW基础架构可以找到至少一个<code>META-INF/aop.xml</code>文件，然后打开AspectJ编织。否则，它关闭。这是默认值。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments"><a class="anchor" href="#aop-aj-ltw-environments"></a>特定于环境的配置</h5>
<div class="paragraph">
<p>最后一部分包含在应用程序服务器和Web容器等环境中使用Spring的LTW支持时所需的任何其他设置和配置。</p>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-tomcat-jboss-etc"><a class="anchor" href="#aop-aj-ltw-environments-tomcat-jboss-etc"></a> Tomcat，JBoss，WebSphere，WebLogic</h6>
<div class="paragraph">
<p>Tomcat，JBoss / WildFly，IBM WebSphere Application Server和Oracle WebLogic Server都提供了通用应用程序<code>ClassLoader</code>具有本地检测能力。Spring的本地LTW可以利用这些ClassLoader实现来提供AspectJ编织。您可以简单地启用加载时编织， <a href="#aop-using-aspectj">如前所述</a> 。具体来说，您无需修改JVM启动脚本即可添加<code>-javaagent:path/to/spring-instrument.jar</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，在JBoss上，您可能需要禁用应用服务器扫描，以防止它在应用程序实际启动之前加载类。一个快速的解决方法是将一个名为的文件添加到您的工件中<code>WEB-INF/jboss-scanning.xml</code>具有以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;scanning xmlns="urn:jboss:scanning:1.0"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-generic"><a class="anchor" href="#aop-aj-ltw-environments-generic"></a>通用Java应用程序</h6>
<div class="paragraph">
<p>在特定工具不支持的环境中需要类检测时<code>LoadTimeWeaver</code>在实现中，JVM代理是通用解决方案。对于这种情况，Spring提供了<code>InstrumentationLoadTimeWeaver</code>这需要特定于Spring（但非常通用）的JVM代理， <code>spring-instrument.jar</code> ，由通用自动检测<code>@EnableLoadTimeWeaving</code>和<code><context:load-time-weaver/></code>设置。</p>
</div>
<div class="paragraph">
<p>要使用它，必须通过提供以下JVM选项来使用Spring代理启动虚拟机：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-javaagent:/path/to/spring-instrument.jar</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这需要修改JVM启动脚本，这可能会阻止您在应用程序服务器环境中使用它（取决于您的服务器和您的操作策略）。也就是说，对于每个JVM一个应用程序的部署（例如独立的Spring Boot应用程序），无论如何，您通常都可以控制整个JVM的设置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-resources"><a class="anchor" href="#aop-resources"></a> 5.11。更多资源</h3>
<div class="paragraph">
<p>可以在<a href="https://www.eclipse.org/aspectj">AspectJ网站</a>上找到有关<a href="https://www.eclipse.org/aspectj">AspectJ的</a>更多信息。</p>
</div>
<div class="paragraph">
<p><em>Eclipse AspectJ</em> ，作者：Adrian Colyer等。等（Addison-Wesley，2005年）为AspectJ语言提供了全面的介绍和参考。</p>
</div>
<div class="paragraph">
<p>强烈推荐Ramnivas Laddad撰写的<em>《 AspectJ in Action》</em>第二版（Manning，2009年）。本书的重点是AspectJ，但是（在一定程度上）探讨了许多通用的AOP主题。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api"><a class="anchor" href="#aop-api"></a> 6。Spring AOP API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>上一章通过@AspectJ和基于模式的方面定义描述了Spring对AOP的支持。在本章中，我们讨论了较低级别的Spring AOP API。对于常见的应用程序，我们建议将Spring AOP与AspectJ切入点一起使用，如上一章所述。</p>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts"><a class="anchor" href="#aop-api-pointcuts"></a> 6.1。Spring中的Pointcut API</h3>
<div class="paragraph">
<p>本节描述了Spring如何处理关键切入点概念。</p>
</div>
<div class="sect3">
<h4 id="aop-api-concepts"><a class="anchor" href="#aop-api-concepts"></a> 6.1.1。概念</h4>
<div class="paragraph">
<p>Spring的切入点模型使切入点重用不受建议类型的影响。您可以使用相同的切入点来定位不同的建议。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.aop.Pointcut</code>接口是中央接口，用于将建议定向到特定的类和方法。完整的界面如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Pointcut {

    fun getClassFilter(): ClassFilter

    fun getMethodMatcher(): MethodMatcher

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>拆分<code>Pointcut</code>接口分为两部分，可以重用类和方法匹配的部分以及细粒度的组合操作（例如与另一个方法匹配器执行“联合”）。</p>
</div>
<div class="paragraph">
<p>的<code>ClassFilter</code>接口用于将切入点限制为给定的一组目标类。如果<code>matches()</code>方法始终返回true，所有目标类均匹配。以下清单显示了<code>ClassFilter</code>接口定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ClassFilter {

    boolean matches(Class clazz);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface ClassFilter {

    fun matches(clazz: Class&lt;*&gt;): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>MethodMatcher</code>界面通常更重要。完整的界面如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface MethodMatcher {

    val isRuntime: Boolean

    fun matches(m: Method, targetClass: Class&lt;*&gt;): Boolean

    fun matches(m: Method, targetClass: Class&lt;*&gt;, args: Array&lt;Any&gt;): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>matches(Method, Class)</code>方法用于测试此切入点是否与目标类上的给定方法匹配。创建AOP代理时可以执行此评估，以避免需要对每个方法调用进行测试。如果两个参数<code>matches</code>方法返回<code>true</code>对于给定的方法， <code>isRuntime()</code> MethodMatcher的方法返回<code>true</code> ，则在每次方法调用时都会调用三参数匹配方法。这样，切入点就可以在执行目标建议之前立即查看传递给方法调用的参数。</p>
</div>
<div class="paragraph">
<p>最<code>MethodMatcher</code>实现是静态的，这意味着它们的<code>isRuntime()</code>方法返回<code>false</code> 。在这种情况下，三个参数<code>matches</code>方法永远不会被调用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果可能，请尝试使切入点成为静态，从而允许AOP框架在创建AOP代理时缓存切入点评估的结果。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcut-ops"><a class="anchor" href="#aop-api-pointcut-ops"></a> 6.1.2。切入点的操作</h4>
<div class="paragraph">
<p>Spring支持切入点上的操作（特别是联合和相交）。</p>
</div>
<div class="paragraph">
<p>联合表示两个切入点都匹配的方法。交集是指两个切入点都匹配的方法。联合通常更有用。您可以使用中的静态方法撰写切入点<code>org.springframework.aop.support.Pointcuts</code>类或使用<code>ComposablePointcut</code>类放在同一包中。但是，使用AspectJ切入点表达式通常是一种更简单的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-aspectj"><a class="anchor" href="#aop-api-pointcuts-aspectj"></a> 6.1.3。AspectJ表达切入点</h4>
<div class="paragraph">
<p>从2.0开始，Spring使用的最重要的切入点类型是<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code> 。这是一个切入点，该切入点使用AspectJ提供的库来解析AspectJ切入点表达式字符串。</p>
</div>
<div class="paragraph">
<p>有关支持的AspectJ切入点原语的讨论，请参见<a href="#aop">上一章</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-impls"><a class="anchor" href="#aop-api-pointcuts-impls"></a> 6.1.4。便捷切入点实现</h4>
<div class="paragraph">
<p>Spring提供了几种方便的切入点实现。您可以直接使用其中一些。其他的则打算在特定于应用程序的切入点中子类化。</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-static"><a class="anchor" href="#aop-api-pointcuts-static"></a>静态切入点</h5>
<div class="paragraph">
<p>静态切入点是基于方法和目标类的，不能考虑方法的参数。静态切入点对于大多数用途来说是足够的，也是最好的。首次调用方法时，Spring只能评估一次静态切入点。之后，无需在每次方法调用时再次评估切入点。</p>
</div>
<div class="paragraph">
<p>本节的其余部分描述了Spring附带的一些静态切入点实现。</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-regex"><a class="anchor" href="#aop-api-pointcuts-regex"></a>正则表达式切入点</h6>
<div class="paragraph">
<p>指定静态切入点的一种明显方法是正则表达式。除了Spring之外，还有几个AOP框架使之成为可能。
<code>org.springframework.aop.support.JdkRegexpMethodPointcut</code>是通用的正则表达式切入点，它使用JDK中的正则表达式支持。</p>
</div>
<div class="paragraph">
<p>随着<code>JdkRegexpMethodPointcut</code>类，您可以提供模式字符串列表。如果其中任何一个匹配，则切入点的计算结果为<code>true</code> 。（因此，结果实际上是这些切入点的并集。）</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>JdkRegexpMethodPointcut</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="settersAndAbsquatulatePointcut"
        class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring提供了一个名为<code>RegexpMethodPointcutAdvisor</code> ，这让我们也可以参考<code>Advice</code> （请记住， <code>Advice</code>可以在建议，引发建议等之前成为拦截器）。在幕后，Spring使用了<code>JdkRegexpMethodPointcut</code> 。使用<code>RegexpMethodPointcutAdvisor</code>简化了接线，因为一个bean封装了切入点和建议，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="settersAndAbsquatulateAdvisor"
        class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref bean="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>RegexpMethodPointcutAdvisor</code>与任何<code>Advice</code>类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-attribute-driven"><a class="anchor" href="#aop-api-pointcuts-attribute-driven"></a>属性驱动的切入点</h6>
<div class="paragraph">
<p>静态切入点的一种重要类型是元数据驱动的切入点。这将使用元数据属性的值（通常是源级别的元数据）。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-dynamic"><a class="anchor" href="#aop-api-pointcuts-dynamic"></a>动态切入点</h5>
<div class="paragraph">
<p>动态切入点比静态切入点更昂贵。它们考虑了方法参数以及静态信息。这意味着必须在每次方法调用时对它们进行评估，并且由于参数会有所不同，因此无法缓存结果。</p>
</div>
<div class="paragraph">
<p>主要的例子是<code>control flow</code>切入点。</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-cflow"><a class="anchor" href="#aop-api-pointcuts-cflow"></a>控制流切入点</h6>
<div class="paragraph">
<p>Spring 控制流切入点在概念上类似于AspectJ <code>cflow</code>切入点，尽管功能不那么强大。（当前无法指定一个切入点在与另一个切入点匹配的连接点下执行。）控制流切入点与当前调用堆栈匹配。例如，如果连接点是由<code>com.mycompany.web</code>包装或由<code>SomeCaller</code>类。控制流切入点通过使用<code>org.springframework.aop.support.ControlFlowPointcut</code>类。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与其他动态切入点相比，控制流切入点在运行时进行评估要昂贵得多。在Java 1.4中，成本大约是其他动态切入点的五倍。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-superclasses"><a class="anchor" href="#aop-api-pointcuts-superclasses"></a> 6.1.5。切入点超类</h4>
<div class="paragraph">
<p>Spring提供了有用的切入点超类，以帮助您实现自己的切入点。</p>
</div>
<div class="paragraph">
<p>因为静态切入点最有用，所以您可能应该子类化<code>StaticMethodMatcherPointcut</code> 。这仅需要实现一个抽象方法（尽管您可以覆盖其他方法以自定义行为）。以下示例显示了如何子类化<code>StaticMethodMatcherPointcut</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class TestStaticPointcut : StaticMethodMatcherPointcut() {

    override fun matches(method: Method, targetClass: Class&lt;*&gt;): Boolean {
        // return true if custom criteria match
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>动态切入点也有超类。您可以将自定义切入点与任何建议类型一起使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-custom"><a class="anchor" href="#aop-api-pointcuts-custom"></a> 6.1.6。自定义切入点</h4>
<div class="paragraph">
<p>由于Spring AOP中的切入点是Java类，而不是语言功能（如AspectJ），因此可以声明自定义切入点，无论是静态还是动态。Spring中的自定义切入点可以任意复杂。但是，如果可以的话，我们建议使用AspectJ切入点表达语言。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">更高版本的Spring可能会提供对JAC提供的“语义切入点”的支持，例如，“更改目标对象中实例变量的所有方法”。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advice"><a class="anchor" href="#aop-api-advice"></a> 6.2。Advice API in Spring</h3>
<div class="paragraph">
<p>现在，我们可以检查Spring AOP如何处理建议。</p>
</div>
<div class="sect3">
<h4 id="aop-api-advice-lifecycle"><a class="anchor" href="#aop-api-advice-lifecycle"></a> 6.2.1。Advice 生命周期</h4>
<div class="paragraph">
<p>每个建议都是一个Spring bean。建议实例可以在所有建议对象之间共享，或者对于每个建议对象都是唯一的。这对应于每个班级或每个实例的建议。</p>
</div>
<div class="paragraph">
<p>每班建议最常用。适用于一般建议，例如交易顾问。这些不依赖于代理对象的状态或添加新状态。它们仅作用于方法和参数。</p>
</div>
<div class="paragraph">
<p>每个实例的建议都适合引入，以支持mixins。在这种情况下，建议将状态添加到代理对象。</p>
</div>
<div class="paragraph">
<p>您可以在同一AOP代理中混合使用共享建议和基于实例的建议。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-types"><a class="anchor" href="#aop-api-advice-types"></a> 6.2.2。春天的建议类型</h4>
<div class="paragraph">
<p>Spring提供了几种建议类型，并且可以扩展以支持任意建议类型。本节介绍基本概念和标准建议类型。</p>
</div>
<div class="sect4">
<h5 id="aop-api-advice-around"><a class="anchor" href="#aop-api-advice-around"></a>拦截咨询</h5>
<div class="paragraph">
<p>Spring中最基本的建议类型是围绕建议的拦截。</p>
</div>
<div class="paragraph">
<p>Spring符合AOP <code>Alliance</code>使用方法拦截的周围建议的接口。实现的类<code>MethodInterceptor</code>围绕建议的实施还应该实现以下接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface MethodInterceptor extends Interceptor {

    Object invoke(MethodInvocation invocation) throws Throwable;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface MethodInterceptor : Interceptor {

    fun invoke(invocation: MethodInvocation) : Any
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>MethodInvocation</code>争论<code>invoke()</code> method公开正在调用的方法，目标连接点，AOP代理以及该方法的参数。的<code>invoke()</code>方法应返回调用的结果：连接点的返回值。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个简单的<code>MethodInterceptor</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class DebugInterceptor : MethodInterceptor {

    override fun invoke(invocation: MethodInvocation): Any {
        println("Before: invocation=[$invocation]")
        val rval = invocation.proceed()
        println("Invocation returned")
        return rval
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意呼叫<code>proceed()</code>的方法<code>MethodInvocation</code> 。这沿着拦截器链向下到达连接点。大多数拦截器都调用此方法并返回其返回值。但是， <code>MethodInterceptor</code>像任何周围的建议一样，可以返回不同的值或引发异常，而不是调用proceed方法。但是，您没有充分的理由就不想这样做。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>MethodInterceptor</code>实现提供与其他符合AOP Alliance的AOP实现的互操作性。本节其余部分讨论的其他建议类型将实现常见的AOP概念，但以特定于Spring的方式。虽然使用最具体的建议类型有优势，但请坚持使用<code>MethodInterceptor</code>如果您可能想在另一个AOP框架中运行方面，请参考建议。请注意，切入点当前无法在框架之间互操作，并且AOP Alliance当前未定义切入点接口。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-before"><a class="anchor" href="#aop-api-advice-before"></a>咨询前</h5>
<div class="paragraph">
<p>一种更简单的建议类型是事前建议。这不需要<code>MethodInvocation</code>对象，因为它仅在进入方法之前被调用。</p>
</div>
<div class="paragraph">
<p>事前通知的主要优点是无需调用<code>proceed()</code>方法，因此，不会无意中导致拦截器链失败。</p>
</div>
<div class="paragraph">
<p>以下清单显示了<code>MethodBeforeAdvice</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface MethodBeforeAdvice : BeforeAdvice {

    fun before(m: Method, args: Array&lt;Any&gt;, target: Any)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>（尽管通常的对象适用于字段拦截，并且Spring不太可能实现它，但Spring的API设计允许先于字段咨询。）</p>
</div>
<div class="paragraph">
<p>请注意，返回类型为<code>void</code> 。通知可以在联接点执行之前插入自定义行为，但不能更改返回值。如果之前的建议引发异常，它将中止拦截器链的进一步执行。异常会传播回拦截器链。如果未选中它或在调用的方法的签名上，则将其直接传递给客户端。否则，它将被AOP代理包装在未经检查的异常中。</p>
</div>
<div class="paragraph">
<p>以下示例显示了Spring中的before建议，该建议计算所有方法调用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CountingBeforeAdvice : MethodBeforeAdvice {

    var count: Int = 0

    override fun before(m: Method, args: Array&lt;Any&gt;, target: Any?) {
        ++count
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在将建议与任何切入点一起使用之前。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-throws"><a class="anchor" href="#aop-api-advice-throws"></a>提出建议</h5>
<div class="paragraph">
<p>如果联接点引发异常，则在联接点返回后调用引发通知。Spring提供类型化的抛出建议。请注意，这意味着<code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。它是一个标签接口，用于标识给定的对象实现了一个或多个类型的throws通知方法。这些应采用以下形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">afterThrowing([Method, args, target], subclassOfThrowable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅最后一个参数是必需的。方法签名可以具有一个或四个参数，具体取决于建议方法是否对该方法和参数感兴趣。接下来的两个清单显示了类，它们是引发建议的示例。</p>
</div>
<div class="paragraph">
<p>如果以下情况被调用，则以下建议<code>RemoteException</code>引发（包括从子类中）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class RemoteThrowsAdvice : ThrowsAdvice {

    fun afterThrowing(ex: RemoteException) {
        // Do something with remote exception
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与前面的建议不同，下一个示例声明四个参数，以便可以访问被调用的方法，方法参数和目标对象。如果以下情况被调用，则以下建议<code>ServletException</code>被抛出：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ServletThrowsAdviceWithArguments : ThrowsAdvice {

    fun afterThrowing(m: Method, args: Array&lt;Any&gt;, target: Any, ex: ServletException) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个示例说明了如何在处理这两个方法的单个类中使用这两种方法<code>RemoteException</code>和<code>ServletException</code> 。可以将任意数量的引发建议方法组合到一个类中。以下清单显示了最后一个示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CombinedThrowsAdvice : ThrowsAdvice {

    fun afterThrowing(ex: RemoteException) {
        // Do something with remote exception
    }

    fun afterThrowing(m: Method, args: Array&lt;Any&gt;, target: Any, ex: ServletException) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果throws-advice方法本身引发异常，则它将覆盖原始异常（即，它会将引发的异常更改给用户）。重写异常通常是RuntimeException，它与任何方法签名都兼容。但是，如果throws-advice方法抛出一个已检查的异常，则它必须与目标方法的已声明异常匹配，因此在某种程度上与特定的目标方法签名耦合。<em>不要抛出与目标方法签名不兼容的未声明检查异常！</em>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">抛出建议可以与任何切入点一起使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-after-returning"><a class="anchor" href="#aop-api-advice-after-returning"></a>返回建议后</h5>
<div class="paragraph">
<p>Spring中的回传建议必须实现<code>org.springframework.aop.AfterReturningAdvice</code>界面，如下清单所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface AfterReturningAdvice : Advice {

    fun afterReturning(returnValue: Any, m: Method, args: Array&lt;Any&gt;, target: Any)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After after returning建议可以访问返回值（它不能修改），调用的方法，方法的参数和目标。</p>
</div>
<div class="paragraph">
<p>返回建议后的以下内容将计数所有未引发异常的成功方法调用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CountingAfterReturningAdvice : AfterReturningAdvice {

    var count: Int = 0
        private set

    override fun afterReturning(returnValue: Any?, m: Method, args: Array&lt;Any&gt;, target: Any?) {
        ++count
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此建议不会更改执行路径。如果抛出异常，则会将其抛出拦截器链，而不是返回值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">返回后，建议可以与任何切入点一起使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-introduction"><a class="anchor" href="#aop-api-advice-introduction"></a>简介建议</h5>
<div class="paragraph">
<p>Spring将介绍建议视为一种特殊的拦截建议。</p>
</div>
<div class="paragraph">
<p>介绍需要<code>IntroductionAdvisor</code>和<code>IntroductionInterceptor</code>实现以下接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface IntroductionInterceptor : MethodInterceptor {

    fun implementsInterface(intf: Class&lt;*&gt;): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>invoke()</code> AOP联盟继承的方法<code>MethodInterceptor</code>接口必须实现介绍。也就是说，如果被调用的方法在引入的接口上，则引入拦截器负责处理方法调用-它不能调用<code>proceed()</code> 。</p>
</div>
<div class="paragraph">
<p>简介建议不能与任何切入点一起使用，因为它仅适用于类而不是方法级别。您只能将介绍建议与<code>IntroductionAdvisor</code> ，它具有以下方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

    ClassFilter getClassFilter();

    void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

    Class[] getInterfaces();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface IntroductionAdvisor : Advisor, IntroductionInfo {

    val classFilter: ClassFilter

    @Throws(IllegalArgumentException::class)
    fun validateInterfaces()
}

interface IntroductionInfo {

    val interfaces: Array&lt;Class&lt;*&gt;&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有<code>MethodMatcher</code>因此，没有<code>Pointcut</code>与介绍建议相关。只有类过滤是合乎逻辑的。</p>
</div>
<div class="paragraph">
<p>的<code>getInterfaces()</code>方法返回此顾问程序引入的接口。</p>
</div>
<div class="paragraph">
<p>的<code>validateInterfaces()</code>内部使用方法查看引入的接口是否可以由配置的接口实现<code>IntroductionInterceptor</code> 。</p>
</div>
<div class="paragraph">
<p>考虑一下Spring测试套件中的一个示例，并假设我们想为一个或多个对象引入以下接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Lockable {
    fun lock()
    fun unlock()
    fun locked(): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这说明了混合。我们希望能够将建议的对象投射到<code>Lockable</code> ，无论其类型如何，并调用锁定和解锁方法。如果我们称<code>lock()</code>方法，我们希望所有的setter方法都抛出一个<code>LockedException</code> 。因此，我们可以添加一个方面，使对象在不了解对象的情况下不可变：AOP的一个很好的例子。</p>
</div>
<div class="paragraph">
<p>首先，我们需要<code>IntroductionInterceptor</code>繁重的工作。在这种情况下，我们扩展<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>便利班。我们可以实施<code>IntroductionInterceptor</code>直接，但使用<code>DelegatingIntroductionInterceptor</code>最适合大多数情况。</p>
</div>
<div class="paragraph">
<p>的<code>DelegatingIntroductionInterceptor</code>旨在将引入的接口的实际实现委派给委派，并隐藏使用侦听的方式。您可以使用构造函数参数将委托设置为任何对象。默认委托（使用无参数构造函数时）为<code>this</code> 。因此，在下一个示例中，委托是<code>LockMixin</code>的子类<code>DelegatingIntroductionInterceptor</code> 。给定一个委托（默认情况下，本身），一个<code>DelegatingIntroductionInterceptor</code>实例查找委托实现的所有接口（除了<code>IntroductionInterceptor</code> ），并支持针对其中任何一个的介绍。子类，例如<code>LockMixin</code>可以打电话给<code>suppressInterface(Class intf)</code>抑制不应公开的接口的方法。但是，无论有多少个接口<code>IntroductionInterceptor</code>准备支持， <code>IntroductionAdvisor</code>用于控制实际公开哪些接口。引入的接口隐藏了目标对同一接口的任何实现。</p>
</div>
<div class="paragraph">
<p>从而， <code>LockMixin</code>延伸<code>DelegatingIntroductionInterceptor</code>并实施<code>Lockable</code>本身。超类会自动接听<code>Lockable</code>可以支持进行介绍，因此我们无需指定。我们可以通过这种方式引入任意数量的接口。</p>
</div>
<div class="paragraph">
<p>注意使用<code>locked</code>实例变量。这有效地将附加状态添加到目标对象中保存的状态。</p>
</div>
<div class="paragraph">
<p>以下示例显示了示例<code>LockMixin</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0) {
            throw new LockedException();
        }
        return super.invoke(invocation);
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class LockMixin : DelegatingIntroductionInterceptor(), Lockable {

    private var locked: Boolean = false

    fun lock() {
        this.locked = true
    }

    fun unlock() {
        this.locked = false
    }

    fun locked(): Boolean {
        return this.locked
    }

    override fun invoke(invocation: MethodInvocation): Any? {
        if (locked() &amp;&amp; invocation.method.name.indexOf("set") == 0) {
            throw LockedException()
        }
        return super.invoke(invocation)
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，您无需覆盖<code>invoke()</code>方法。的<code>DelegatingIntroductionInterceptor</code>实现（称为<code>delegate</code>如果引入了方法，则通常就足够了。在当前情况下，我们需要添加一个检查：如果处于锁定模式，则不能调用任何setter方法。</p>
</div>
<div class="paragraph">
<p>所需的介绍只需要保留一个不同的<code>LockMixin</code>实例并指定引入的接口（在这种情况下，仅<code>Lockable</code> ）。一个更复杂的示例可能引用了引入拦截器（将被定义为原型）。在这种情况下，没有与<code>LockMixin</code> ，因此我们使用<code>new</code> 。以下示例显示了我们的<code>LockMixinAdvisor</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class LockMixinAdvisor : DefaultIntroductionAdvisor(LockMixin(), Lockable::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以非常简单地应用此顾问程序，因为它不需要配置。（但是，无法使用<code>IntroductionInterceptor</code>没有<code>IntroductionAdvisor</code> ）像通常的介绍一样，顾问必须是按实例的，因为它是有状态的。我们需要一个不同的实例<code>LockMixinAdvisor</code> ， 因此<code>LockMixin</code> ，针对每个建议对象。顾问程序包含建议对象状态的一部分。</p>
</div>
<div class="paragraph">
<p>我们可以通过以下方式以编程方式应用此顾问程序： <code>Advised.addAdvisor()</code> XML配置中的方法或（建议的方式），以及其他任何顾问程序。下文讨论的所有代理创建选择，包括“自动代理创建器”，都可以正确处理介绍和有状态的混合。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advisor"><a class="anchor" href="#aop-api-advisor"></a> 6.3。Spring的Advisor API</h3>
<div class="paragraph">
<p>在Spring中，顾问程序是仅包含与切入点表达式关联的单个建议对象的方面。</p>
</div>
<div class="paragraph">
<p>除了介绍的特殊情况外，任何顾问都可以与任何建议一起使用。
<code>org.springframework.aop.support.DefaultPointcutAdvisor</code>是最常用的顾问类。可以与<code>MethodInterceptor</code> ， <code>BeforeAdvice</code> ， 要么<code>ThrowsAdvice</code> 。</p>
</div>
<div class="paragraph">
<p>可以在同一AOP代理中的Spring中混合使用顾问和建议类型。例如，您可以在一个代理配置中使用围绕建议的拦截，引发建议以及建议之前。Spring自动创建必要的拦截器链。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb"><a class="anchor" href="#aop-pfb"></a> 6.4。使用<code>ProxyFactoryBean</code>创建AOP代理</h3>
<div class="paragraph">
<p>如果您使用Spring IoC容器（ <code>ApplicationContext</code>要么<code>BeanFactory</code> ）对于您的业务对象（应该是！），您想使用Spring的AOP之一<code>FactoryBean</code>实现。（请记住，工厂bean引入了一个间接层，使它可以创建其他类型的对象。）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring AOP支持还在后台使用了工厂bean。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在Spring中创建AOP代理的基本方法是使用<code>org.springframework.aop.framework.ProxyFactoryBean</code> 。这样可以完全控制切入点，任何适用的建议及其顺序。但是，如果不需要这样的控制，则有一些更简单的选项比较可取。</p>
</div>
<div class="sect3">
<h4 id="aop-pfb-1"><a class="anchor" href="#aop-pfb-1"></a> 6.4.1。基本</h4>
<div class="paragraph">
<p>的<code>ProxyFactoryBean</code>像其他春天一样<code>FactoryBean</code>实现，介绍了一个间接级别。如果您定义<code>ProxyFactoryBean</code>命名<code>foo</code> ，引用的对象<code>foo</code>看不到<code>ProxyFactoryBean</code>实例本身，但是是通过实现创建的对象<code>getObject()</code>中的方法<code>ProxyFactoryBean</code> 。此方法创建一个包装目标对象的AOP代理。</p>
</div>
<div class="paragraph">
<p>使用a的最重要好处之一<code>ProxyFactoryBean</code>或另一个可以创建AOP的支持IoC的类是，建议和切入点也可以由IoC管理。这是一项强大的功能，可以实现某些其他AOP框架难以实现的方法。例如，受益于依赖注入提供的所有可插入性，建议本身可以引用应用程序对象（目标之外，目标应该在任何AOP框架中可用）。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-2"><a class="anchor" href="#aop-pfb-2"></a> 6.4.2。JavaBean属性</h4>
<div class="paragraph">
<p>与大多数相同<code>FactoryBean</code> Spring提供的实现<code>ProxyFactoryBean</code>类本身就是一个JavaBean。其属性用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定要代理的目标。</p>
</li>
<li>
<p>指定是否使用CGLIB（稍后介绍，另请参见<a href="#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一些关键属性继承自<code>org.springframework.aop.framework.ProxyConfig</code> （春季所有AOP代理工厂的超类）。这些关键属性包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyTargetClass</code> ： <code>true</code>如果要代理目标类，而不是目标类的接口。如果此属性值设置为<code>true</code> ，然后创建CGLIB代理（但另请参见<a href="#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a> ）。</p>
</li>
<li>
<p><code>optimize</code> ：控制是否将积极的优化应用于通过CGLIB创建的代理。除非您完全了解相关的AOP代理如何处理优化，否则不要随意使用此设置。当前仅用于CGLIB代理。它对JDK动态代理无效。</p>
</li>
<li>
<p><code>frozen</code> ：如果代理配置是<code>frozen</code> ，不再允许更改配置。这对于轻微的优化以及在您不希望调用者能够操纵代理（通过<code>Advised</code>接口）。此属性的默认值为<code>false</code> ，因此可以进行更改（例如添加其他建议）。</p>
</li>
<li>
<p><code>exposeProxy</code> ：确定是否应将当前代理暴露在<code>ThreadLocal</code>以便目标可以访问它。如果目标需要获得代理和<code>exposeProxy</code>属性设置为<code>true</code> ，目标可以使用<code>AopContext.currentProxy()</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>特定于其他属性<code>ProxyFactoryBean</code>包括以下这些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyInterfaces</code> ：一组<code>String</code>接口名称。如果未提供，则使用目标类的CGLIB代理（但另请参见<a href="#aop-pfb-proxy-types">基于JDK和CGLIB的代理</a> ）。</p>
</li>
<li>
<p><code>interceptorNames</code> ： 一种<code>String</code>的数组<code>Advisor</code> ，拦截器或其他建议名称来应用。顺序很重要，先到先得。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。</p>
<div class="paragraph">
<p>名称是当前工厂中的bean名称，包括祖先工厂中的bean名称。您不能在此处提及Bean引用，因为这样做会导致<code>ProxyFactoryBean</code>忽略建议的单例设置。</p>
</div>
<div class="paragraph">
<p>您可以在拦截器名称后加上星号（ <code>*</code> ）。这样做会导致应用所有顾问Bean，其名称以要应用星号的部分开头。您可以在“ <a href="#aop-global-advisors">使用“全局”顾问”中</a>找到使用此功能的示例。</p>
</div>
</li>
<li>
<p>单例：无论工厂多久返回一次，对象是否应返回单个对象<code>getObject()</code>方法被调用。一些<code>FactoryBean</code>实现提供了这种方法。默认值为<code>true</code> 。如果要使用有状态的建议（例如，对于有状态的混合），请使用原型建议以及单例值<code>false</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-proxy-types"><a class="anchor" href="#aop-pfb-proxy-types"></a> 6.4.3。基于JDK和CGLIB的代理</h4>
<div class="paragraph">
<p>本节是有关如何<code>ProxyFactoryBean</code>选择为特定的目标对象（将被代理）创建基于JDK的代理或基于CGLIB的代理。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的行为<code>ProxyFactoryBean</code>关于创建基于JDK或CGLIB的代理的问题，在Spring的1.2.x版和2.0版之间进行了更改。的<code>ProxyFactoryBean</code>现在在自动检测接口方面表现出与<code>TransactionProxyFactoryBean</code>类。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要代理的目标对象的类（以下简称为目标类）没有实现任何接口，则将创建基于CGLIB的代理。这是最简单的情况，因为JDK代理是基于接口的，并且没有接口意味着甚至无法进行JDK代理。您可以插入目标bean并通过设置<code>interceptorNames</code>属性。请注意，即使<code>proxyTargetClass</code>的属性<code>ProxyFactoryBean</code>已设置为<code>false</code> 。（这样做没有任何意义，最好将其从bean定义中删除，因为它充其量是多余的，并且在最糟的情况下会造成混淆。）</p>
</div>
<div class="paragraph">
<p>如果目标类实现一个（或多个）接口，则创建的代理类型取决于代理的配置。 <code>ProxyFactoryBean</code> 。</p>
</div>
<div class="paragraph">
<p>如果<code>proxyTargetClass</code>的属性<code>ProxyFactoryBean</code>已设置为<code>true</code> ，将创建基于CGLIB的代理。这是有道理的，并且符合最小惊讶原则。即使<code>proxyInterfaces</code>的属性<code>ProxyFactoryBean</code>已设置为一个或多个完全限定的接口名称， <code>proxyTargetClass</code>属性设置为<code>true</code>使基于CGLIB的代理生效。</p>
</div>
<div class="paragraph">
<p>如果<code>proxyInterfaces</code>的属性<code>ProxyFactoryBean</code>如果已将其设置为一个或多个标准接口名称，则会创建一个基于JDK的代理。创建的代理实现了在<code>proxyInterfaces</code>属性。如果目标类恰好实现比接口类中指定的接口更多的接口<code>proxyInterfaces</code>属性，这很好，但是返回的代理未实现那些其他接口。</p>
</div>
<div class="paragraph">
<p>如果<code>proxyInterfaces</code>的属性<code>ProxyFactoryBean</code>尚未设置，但是目标类确实实现了一个（或多个）接口， <code>ProxyFactoryBean</code>自动检测目标类实际上确实实现了至少一个接口，并创建了一个基于JDK的代理的事实。实际代理的接口是目标类实现的所有接口。实际上，这与向目标类提供目标类实现的每个接口的列表相同。 <code>proxyInterfaces</code>属性。但是，它的工作量大大减少，而且不容易出现印刷错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-intf"><a class="anchor" href="#aop-api-proxying-intf"></a> 6.4.4。代理接口</h4>
<div class="paragraph">
<p>考虑一个简单的例子<code>ProxyFactoryBean</code>在行动。此示例涉及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>代理的目标bean。这是<code>personTarget</code>示例中的bean定义。</p>
</li>
<li>
<p>一个<code>Advisor</code>和<code>Interceptor</code>用于提供建议。</p>
</li>
<li>
<p>用于指定目标对象（ <code>personTarget</code> bean），代理接口以及要应用的建议。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下清单显示了示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name" value="Tony"/&gt;
    &lt;property name="age" value="51"/&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person"
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;

    &lt;property name="target" ref="personTarget"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意<code>interceptorNames</code>属性需要一个列表<code>String</code> ，其中包含当前工厂中的拦截器或顾问程序的bean名称。您可以在返回之前，之后使用顾问程序，拦截器并引发建议对象。顾问的顺序很重要。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可能想知道为什么列表不包含bean引用。原因是，如果<code>ProxyFactoryBean</code>被设定为<code>false</code> ，它必须能够返回独立的代理实例。如果任何顾问本身就是原型，则需要返回一个独立的实例，因此必须能够从工厂获得原型的实例。保持引用是不够的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>person</code>前面显示的bean定义可以代替<code>Person</code>实现如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Person person = (Person) factory.getBean("person");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val person = factory.getBean("person") as Person;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与普通Java对象一样，在同一IoC上下文中的其他bean可以表达对此的强类型依赖性。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
    &lt;property name="person"&gt;&lt;ref bean="person"/&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>PersonUser</code>在此示例中的类公开了类型的属性<code>Person</code> 。就其而言，可以透明地使用AOP代理代替“真实”的人实现。但是，其类将是动态代理类。可以将其投放到<code>Advised</code>界面（稍后讨论）。</p>
</div>
<div class="paragraph">
<p>您可以使用匿名内部bean隐藏目标和代理之间的区别。只有<code>ProxyFactoryBean</code>定义是不同的。该建议仅出于完整性考虑。以下示例显示了如何使用匿名内部Bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;
    &lt;!-- Use inner bean, not local reference to target --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.mycompany.PersonImpl"&gt;
            &lt;property name="name" value="Tony"/&gt;
            &lt;property name="age" value="51"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用匿名内部bean的优点是只有一个类型的对象<code>Person</code> 。如果我们要防止应用程序上下文的用户获取对未建议对象的引用，或者需要避免使用Spring IoC自动装配的任何歧义，这将非常有用。可以说，还有一个优点是<code>ProxyFactoryBean</code>定义是独立的。但是，有时能够从工厂获得未经建议的目标实际上可能是一个优势（例如，在某些测试方案中）。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-class"><a class="anchor" href="#aop-api-proxying-class"></a> 6.4.5。代理课程</h4>
<div class="paragraph">
<p>如果您需要代理一类，而不是一个或多个接口，该怎么办？</p>
</div>
<div class="paragraph">
<p>想象一下，在我们之前的示例中，没有<code>Person</code>接口。我们需要建议一个名为<code>Person</code>没有实现任何业务接口。在这种情况下，您可以将Spring配置为使用CGLIB代理而不是动态代理。为此，请设置<code>proxyTargetClass</code>财产<code>ProxyFactoryBean</code>如前所示<code>true</code> 。尽管最好对接口而不是对类进行编程，但是在处理遗留代码时，建议未实现接口的类的功能可能会很有用。（通常，Spring不是规定性的。尽管可以轻松地应用良好做法，但可以避免强制采用特定方法。）</p>
</div>
<div class="paragraph">
<p>如果需要，即使有接口，也可以在任何情况下强制使用CGLIB。</p>
</div>
<div class="paragraph">
<p>CGLIB代理通过在运行时生成目标类的子类来工作。Spring配置此生成的子类以将方法调用委托给原始目标。子类用于实现Decorator模式，并编织在建议中。</p>
</div>
<div class="paragraph">
<p>CGLIB代理通常应对用户透明。但是，有一些问题要考虑：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Final</code>不能建议使用方法，因为它们不能被覆盖。</p>
</li>
<li>
<p>无需将CGLIB添加到您的类路径中。从Spring 3.2开始，CGLIB被重新打包并包含在spring-core JAR中。换句话说，基于CGLIB的AOP就像JDK动态代理一样“开箱即用”。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CGLIB代理和动态代理之间几乎没有性能差异。在这种情况下，性能不应作为决定性的考虑因素。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-global-advisors"><a class="anchor" href="#aop-global-advisors"></a> 6.4.6。使用“全球”顾问</h4>
<div class="paragraph">
<p>通过在拦截器名称后附加一个星号，所有具有与该星号之前的部分匹配的Bean名称的顾问程序都将添加到顾问程序链中。如果您需要添加一组标准的“全局”顾问程序，这可能会派上用场。以下示例定义了两个全局顾问程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="target" ref="service"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;global*&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-concise-proxy"><a class="anchor" href="#aop-concise-proxy"></a> 6.5。简洁的代理定义</h3>
<div class="paragraph">
<p>特别是在定义事务代理时，您可能会得到许多类似的代理定义。使用父子bean定义和子bean定义以及内部bean定义可以使代理定义更加简洁明了。</p>
</div>
<div class="paragraph">
<p>首先，我们为代理创建父模板，bean定义，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="transactionManager"/&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它本身从未实例化，因此实际上可能是不完整的。然后，每个需要创建的代理都是一个子bean定义，它将代理的目标包装为内部bean定义，因为无论如何该目标都不会单独使用。以下示例显示了这样的子bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myService" parent="txProxyTemplate"&gt;
    &lt;property name="target"&gt;
        &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以从父模板覆盖属性。在以下示例中，我们将覆盖事务传播设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
    &lt;property name="target"&gt;
        &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在父级Bean示例中，我们通过将设置为<code>abstract</code>归因于<code>true</code> ， <a href="#beans-child-bean-definitions">如前所述</a> ，因此可能永远不会被实例化。默认情况下，应用程序上下文（但不是简单的bean工厂）会预先实例化所有单例。因此，重要的是（至少对于单例bean），如果您有一个（父）bean定义仅打算用作模板，并且此定义指定了一个类，则必须确保设置<code>abstract</code>归因于<code>true</code> 。否则，应用程序上下文实际上会尝试对其进行实例化。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-prog"><a class="anchor" href="#aop-prog"></a> 6.6。使用以下程序以编程方式创建AOP代理<code>ProxyFactory</code></h3>
<div class="paragraph">
<p>使用Spring以编程方式创建AOP代理很容易。这使您可以使用Spring AOP，而无需依赖Spring IoC。</p>
</div>
<div class="paragraph">
<p>由目标对象实现的接口将被自动代理。以下清单显示了使用一个拦截器和一个顾问程序为目标对象创建代理的过程：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val factory = ProxyFactory(myBusinessInterfaceImpl)
factory.addAdvice(myMethodInterceptor)
factory.addAdvisor(myAdvisor)
val tb = factory.proxy as MyBusinessInterface</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一步是构造一个类型的对象<code>org.springframework.aop.framework.ProxyFactory</code> 。您可以使用目标对象创建此对象，如前面的示例中所示，或指定要在备用构造函数中代理的接口。</p>
</div>
<div class="paragraph">
<p>您可以添加建议（使用拦截器作为一种特殊的建议），建议程序，或同时添加这两种建议，并在生命周期中对其进行操作<code>ProxyFactory</code> 。如果您添加<code>IntroductionInterceptionAroundAdvisor</code> ，则可以使代理实现其他接口。</p>
</div>
<div class="paragraph">
<p>也有方便的方法<code>ProxyFactory</code> （继承自<code>AdvisedSupport</code> ），以便您添加其他建议类型，例如before并引发建议。
<code>AdvisedSupport</code>是两者的超类<code>ProxyFactory</code>和<code>ProxyFactoryBean</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在大多数应用程序中，将AOP代理创建与IoC框架集成在一起是最佳实践。通常，建议您使用AOP从Java代码外部化配置。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advised"><a class="anchor" href="#aop-api-advised"></a> 6.7。操作建议对象</h3>
<div class="paragraph">
<p>不过，您创建AOP代理后，可以使用<code>org.springframework.aop.framework.Advised</code>接口。任何AOP代理都可以强制转换为该接口，无论它实现了哪个其他接口。该界面包括以下方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun getAdvisors(): Array&lt;Advisor&gt;

@Throws(AopConfigException::class)
fun addAdvice(advice: Advice)

@Throws(AopConfigException::class)
fun addAdvice(pos: Int, advice: Advice)

@Throws(AopConfigException::class)
fun addAdvisor(advisor: Advisor)

@Throws(AopConfigException::class)
fun addAdvisor(pos: Int, advisor: Advisor)

fun indexOf(advisor: Advisor): Int

@Throws(AopConfigException::class)
fun removeAdvisor(advisor: Advisor): Boolean

@Throws(AopConfigException::class)
fun removeAdvisor(index: Int)

@Throws(AopConfigException::class)
fun replaceAdvisor(a: Advisor, b: Advisor): Boolean

fun isFrozen(): Boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>getAdvisors()</code>方法返回一个<code>Advisor</code>对于已添加到工厂的每个顾问，拦截器或其他建议类型。如果您添加了<code>Advisor</code> ，此索引处返回的顾问程序就是您添加的对象。如果您添加了拦截器或其他建议类型，Spring会将其包装在顾问程序中，并始终返回一个切入点<code>true</code> 。因此，如果您添加了<code>MethodInterceptor</code> ，为此索引返回的顾问是<code>DefaultPointcutAdvisor</code>返回您的<code>MethodInterceptor</code>以及与所有类和方法匹配的切入点。</p>
</div>
<div class="paragraph">
<p>的<code>addAdvisor()</code>方法可以用来添加任何<code>Advisor</code> 。通常，顾问持有切入点和建议是通用的<code>DefaultPointcutAdvisor</code> ，您可以将其与任何建议或切入点一起使用（但不能用于介绍）。</p>
</div>
<div class="paragraph">
<p>默认情况下，即使已创建代理，也可以添加或删除顾问程序或拦截器。唯一的限制是不可能添加或删除介绍顾问，因为工厂中的现有代理不会显示界面更改。（您可以从工厂获取新的代理来避免此问题。）</p>
</div>
<div class="paragraph">
<p>以下示例显示了将AOP代理投射到<code>Advised</code>界面并检查并处理其建议：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.getAdvisors().length);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val advised = myObject as Advised
val advisors = advised.advisors
val oldAdvisorCount = advisors.size
println("$oldAdvisorCount advisors")

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(DebugInterceptor())

// Add selective advice using a pointcut
advised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice))

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.advisors.size)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管无疑存在合法的使用案例，但是否建议（无双关语）修改生产中的业务对象的建议值得怀疑。但是，它在开发中（例如在测试中）非常有用。有时我们发现以拦截器或其他建议的形式添加测试代码，并进入我们要测试的方法调用中非常有用。 （例如，该建议可以进入为该方法创建的事务中，也许可以在将事务标记为回滚之前运行SQL以检查数据库是否已正确更新。）
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>根据创建代理的方式，通常可以设置一个<code>frozen</code>旗。在这种情况下， <code>Advised</code><code>isFrozen()</code>方法返回<code>true</code> ，以及通过添加或删除来修改建议的任何尝试都会导致<code>AopConfigException</code> 。冻结建议对象状态的功能在某些情况下很有用（例如，防止调用代码删除安全拦截器）。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-autoproxy"><a class="anchor" href="#aop-autoproxy"></a> 6.8。使用“自动代理”功能</h3>
<div class="paragraph">
<p>到目前为止，我们已经考虑过使用AOP显式创建AOP代理<code>ProxyFactoryBean</code>或类似的工厂bean。</p>
</div>
<div class="paragraph">
<p>Spring还允许我们使用“自动代理” Bean定义，该定义可以自动代理选定的Bean定义。它建立在Spring的“ bean后处理器”基础结构上，该基础结构允许在容器加载时修改任何bean定义。</p>
</div>
<div class="paragraph">
<p>在此模型中，您在XML bean定义文件中设置了一些特殊的bean定义，以配置自动代理基础结构。这使您可以声明有资格进行自动代理的目标。您不需要使用<code>ProxyFactoryBean</code> 。</p>
</div>
<div class="paragraph">
<p>有两种方法可以做到这一点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过使用在当前上下文中引用特定bean的自动代理创建器。</p>
</li>
<li>
<p>自动代理创建的一种特殊情况，值得单独考虑：由源级别元数据属性驱动的自动代理创建。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-choices"><a class="anchor" href="#aop-autoproxy-choices"></a> 6.8.1。自动代理Bean定义</h4>
<div class="paragraph">
<p>本节涵盖了由以下人员提供的自动代理创建者： <code>org.springframework.aop.framework.autoproxy</code>包。</p>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy"><a class="anchor" href="#aop-api-autoproxy"></a><code>BeanNameAutoProxyCreator</code></h5>
<div class="paragraph">
<p>的<code>BeanNameAutoProxyCreator</code>类是一个<code>BeanPostProcessor</code>会自动为名称与文字值或通配符匹配的bean创建AOP代理。以下示例显示了如何创建<code>BeanNameAutoProxyCreator</code>豆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
    &lt;property name="beanNames" value="jdk*,onlyJdk"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与<code>ProxyFactoryBean</code> ， 有一个<code>interceptorNames</code>属性而不是拦截器列表，以允许原型顾问程序具有正确的行为。名为“拦截器”的可以是顾问或任何建议类型。</p>
</div>
<div class="paragraph">
<p>与一般的自动代理一样，使用的要点<code>BeanNameAutoProxyCreator</code>是以最小的配置量将相同的配置一致地应用于多个对象。将声明式事务应用于多个对象是一种流行的选择。</p>
</div>
<div class="paragraph">
<p>名称匹配的Bean定义，例如<code>jdkMyBean</code>和<code>onlyJdk</code>在前面的示例中，是带有目标类的普通旧bean定义。AOP代理由<code>BeanNameAutoProxyCreator</code> 。相同的建议适用于所有匹配的bean。注意，如果使用了顾问程序（而不是前面的示例中的拦截器），则切入点可能会不同地应用于不同的bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-default"><a class="anchor" href="#aop-api-autoproxy-default"></a><code>DefaultAdvisorAutoProxyCreator</code></h5>
<div class="paragraph">
<p>一个更通用，功能更强大的自动代理创建者是<code>DefaultAdvisorAutoProxyCreator</code> 。这会自动在当前上下文中应用合格的顾问程序，而无需在自动代理顾问程序的Bean定义中包括特定的Bean名称。它具有与配置一致，避免重复的优点。 <code>BeanNameAutoProxyCreator</code> 。</p>
</div>
<div class="paragraph">
<p>使用此机制涉及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定一个<code>DefaultAdvisorAutoProxyCreator</code> Bean定义。</p>
</li>
<li>
<p>在相同或相关的上下文中指定任意数量的顾问。请注意，这些必须是顾问程序，而不是拦截器或其他建议。这是必要的，因为必须有一个评估的切入点，以检查每个建议是否符合候选bean定义。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>DefaultAdvisorAutoProxyCreator</code>自动评估每个顾问中包含的切入点，以查看应该将其应用于每个业务对象（例如， <code>businessObject1</code>和<code>businessObject2</code>在示例中）。</p>
</div>
<div class="paragraph">
<p>这意味着可以将任意数量的顾问程序自动应用于每个业务对象。如果在任何顾问程序中没有切入点与业务对象中的任何方法匹配，则该对象不会被代理。当为新的业务对象添加Bean定义时，如有必要，它们会自动被代理。</p>
</div>
<div class="paragraph">
<p>通常，自动代理的优点是使调用者或依赖者无法获得未经建议的对象。呼唤<code>getBean("businessObject1")</code>在这个<code>ApplicationContext</code>返回一个AOP代理，而不是目标业务对象。（前面显示的“ inner bean”惯用语也提供了这一好处。）</p>
</div>
<div class="paragraph">
<p>以下示例创建了一个<code>DefaultAdvisorAutoProxyCreator</code> bean和本节中讨论的其他元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
    &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
    &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>DefaultAdvisorAutoProxyCreator</code>如果要将相同的建议一致地应用于许多业务对象，此功能非常有用。基础结构定义到位后，您可以添加新的业务对象，而无需包括特定的代理配置。您也可以轻松地添加其他方面（例如，跟踪或性能监视方面），而对配置的更改最少。</p>
</div>
<div class="paragraph">
<p>的<code>DefaultAdvisorAutoProxyCreator</code>提供过滤支持（通过使用命名约定，以便仅评估某些顾问程序，从而允许在同一工厂中使用多个不同配置的AdvisorAutoProxyCreators）和排序。顾问可以实施<code>org.springframework.core.Ordered</code>界面以确保正确排序（如果有问题）。的<code>TransactionAttributeSourceAdvisor</code>在前面的示例中使用的具有可配置的订单值。默认设置为无序。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-targetsource"><a class="anchor" href="#aop-targetsource"></a> 6.9。使用<code>TargetSource</code>实作</h3>
<div class="paragraph">
<p>Spring提供了一个概念<code>TargetSource</code> ，以<code>org.springframework.aop.TargetSource</code>接口。该接口负责返回实现连接点的“目标对象”。的<code>TargetSource</code>每当AOP代理处理方法调用时，都会向实现请求目标实例。</p>
</div>
<div class="paragraph">
<p>使用Spring AOP的开发人员通常不需要直接与<code>TargetSource</code>实现，但这提供了支持池化，可热插拔和其他复杂目标的强大方法。例如，池化<code>TargetSource</code>通过使用池来管理实例，可以为每次调用返回不同的目标实例。</p>
</div>
<div class="paragraph">
<p>如果您未指定<code>TargetSource</code> ，默认实现用于包装本地对象。每次调用都返回相同的目标（与您期望的一样）。</p>
</div>
<div class="paragraph">
<p>本节的其余部分描述了Spring随附的标准目标源以及如何使用它们。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用自定义目标源时，目标通常需要是原型而不是单例bean定义。这样，Spring可以在需要时创建一个新的目标实例。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="aop-ts-swap"><a class="anchor" href="#aop-ts-swap"></a> 6.9.1。可热交换的目标源</h4>
<div class="paragraph">
<p>的<code>org.springframework.aop.target.HotSwappableTargetSource</code>存在的目的是让AOP代理的目标被切换，同时允许调用者保留对其的引用。</p>
</div>
<div class="paragraph">
<p>更改目标源的目标会立即生效。的<code>HotSwappableTargetSource</code>是线程安全的。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>swap()</code>下面的示例显示了HotSwappableTargetSource上的方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val swapper = beanFactory.getBean("swapper") as HotSwappableTargetSource
val oldTarget = swapper.swap(newTarget)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了必需的XML定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
    &lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的<code>swap()</code>调用更改可交换bean的目标。拥有对该bean的引用的客户端不知道更改，但立即开始达到新目标。</p>
</div>
<div class="paragraph">
<p>尽管本示例未添加任何建议（使用此建议无需添加建议<code>TargetSource</code> ）， 任何<code>TargetSource</code>可以与任意建议一起使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-pool"><a class="anchor" href="#aop-ts-pool"></a> 6.9.2。汇集目标源</h4>
<div class="paragraph">
<p>使用池化目标源提供了与无状态会话EJB相似的编程模型，在无状态会话EJB中，维护了相同实例的池，方法调用将释放池中的对象。</p>
</div>
<div class="paragraph">
<p>Spring池和SLSB池之间的关键区别在于，Spring池可以应用于任何POJO。通常，与Spring一样，可以以非侵入性方式应用此服务。</p>
</div>
<div class="paragraph">
<p>Spring提供对Commons Pool 2.2的支持，该池提供了相当有效的池实现。你需要<code>commons-pool</code>在应用程序的类路径上使用Jar即可使用此功能。您也可以子类化<code>org.springframework.aop.target.AbstractPoolingTargetSource</code>支持任何其他池API。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">还支持Commons Pool 1.5+，但从Spring Framework 4.2开始不推荐使用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject"
        scope="prototype"&gt;
    ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPool2TargetSource"&gt;
    &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
    &lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="targetSource" ref="poolTargetSource"/&gt;
    &lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，目标对象（ <code>businessObjectTarget</code>在前面的示例中）必须是原型。这使<code>PoolingTargetSource</code>实现创建目标的新实例以根据需要扩展池。见的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">javadoc <code>AbstractPoolingTargetSource</code></a>以及要用于其属性信息的具体子类。 <code>maxSize</code>是最基本的，并且始终保证存在。</p>
</div>
<div class="paragraph">
<p>在这种情况下， <code>myInterceptor</code>是在同一IoC上下文中需要定义的拦截器的名称。但是，您无需指定拦截器即可使用池。如果您只想池化而没有其他建议，请不要设置<code>interceptorNames</code>财产。</p>
</div>
<div class="paragraph">
<p>您可以将Spring配置为能够将任何合并对象投射到<code>org.springframework.aop.target.PoolingConfig</code>接口，通过引言公开有关池的配置和当前大小的信息。您需要定义类似于以下内容的顾问程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
    &lt;property name="targetObject" ref="poolTargetSource"/&gt;
    &lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该顾问程序是通过在<code>AbstractPoolingTargetSource</code>类，因此使用<code>MethodInvokingFactoryBean</code> 。该顾问的姓名（ <code>poolConfigAdvisor</code> ，此处）必须在拦截器名称列表中<code>ProxyFactoryBean</code>公开池对象。</p>
</div>
<div class="paragraph">
<p>演员表的定义如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val conf = beanFactory.getBean("businessObject") as PoolingConfig
println("Max pool size is " + conf.maxSize)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通常不需要合并无状态服务对象。我们不认为它应该是默认选择，因为大多数无状态对象自然是线程安全的，并且如果缓存了资源，实例池会成问题。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过使用自动代理，可以实现更简单的池化。您可以设置<code>TargetSource</code>任何自动代理创建者使用的实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-prototype"><a class="anchor" href="#aop-ts-prototype"></a> 6.9.3。原型目标源</h4>
<div class="paragraph">
<p>设置“原型”目标源类似于设置池<code>TargetSource</code> 。在这种情况下，每次方法调用都会创建目标的新实例。尽管在现代JVM中创建新对象的成本并不高，但是连接新对象（满足其IoC依赖性）的成本可能会更高。因此，没有充分的理由就不应使用此方法。</p>
</div>
<div class="paragraph">
<p>为此，您可以修改<code>poolTargetSource</code>前面显示的定义如下（为清楚起见，我们也更改了名称）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
    &lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>唯一的属性是目标Bean的名称。继承用于<code>TargetSource</code>实现以确保一致的命名。与池化目标源一样，目标bean必须是原型bean定义。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-threadlocal"><a class="anchor" href="#aop-ts-threadlocal"></a> 6.9.4。 <code>ThreadLocal</code> 目标来源</h4>
<div class="paragraph">
<p><code>ThreadLocal</code>如果您需要为每个传入请求（每个线程）创建一个对象，则目标源很有用。一个的概念<code>ThreadLocal</code>提供了一个JDK范围的工具来透明地将资源与线程一起存储。设置一个<code>ThreadLocalTargetSource</code>几乎与其他类型的目标源所解释的相同，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
    &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>ThreadLocal</code>在多线程和多类加载器环境中错误使用实例时，实例会带来严重问题（可能导致内存泄漏）。您应该始终考虑将threadlocal包装在其他类中，并且永远不要直接使用<code>ThreadLocal</code>本身（包装类中除外）。另外，您应该始终记住正确设置和取消设置（后者只是涉及到<code>ThreadLocal.set(null)</code> ）线程本地资源。在任何情况下都应进行取消设置，因为不取消设置可能会导致出现问题。春天的<code>ThreadLocal</code>支持为您做到这一点，应始终考虑使用<code>ThreadLocal</code>没有其他适当处理代码的实例。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-extensibility"><a class="anchor" href="#aop-extensibility"></a> 6.10。定义新的建议类型</h3>
<div class="paragraph">
<p>Spring AOP被设计为可扩展的。尽管目前在内部使用拦截实现策略，但除了在建议周围，在建议之前，抛出建议和返回建议之后进行拦截之外，还可以支持任意建议类型。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.aop.framework.adapter</code>软件包是SPI软件包，可以在不更改核心框架的情况下添加对新的自定义建议类型的支持。对风俗的唯一约束<code>Advice</code>类型是它必须实现<code>org.aopalliance.aop.Advice</code>标记界面。</p>
</div>
<div class="paragraph">
<p>见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html"><code>org.springframework.aop.framework.adapter</code></a>有关更多信息，请参见javadoc。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="null-safety"><a class="anchor" href="#null-safety"></a> 7。Null-safety</h2>
<div class="sectionbody">
<div class="paragraph">
<p>尽管Java不允许您使用其类型系统来表示null安全性，但Spring Framework 现在在<code>org.springframework.lang</code>包，使您可以声明API和字段的空性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a> ：用于指示可以是特定参数，返回值或字段的注释<code>null</code> 。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a> ：注释，指示特定参数，返回值或字段不能为<code>null</code> （对于参数/返回值和字段，则不需要<code>@NonNullApi</code>和<code>@NonNullFields</code>分别适用）。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a> ：程序包级别的注释，它声明非null作为参数和返回值的默认语义。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/lang/NonNullFields.html"><code>@NonNullFields</code></a> ：程序包级别的注释，它声明非null为字段的默认语义。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework 本身利用了这些注释，但是它们也可以在任何基于Spring的Java项目中使用，以声明null安全的API和可选的null安全的字段。尚不支持泛型类型参数，varargs和数组元素的可空性，但应在即将发布的版本中使用它们，有关最新信息，请参见<a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a> 。可空性声明预计将在Spring Framework版本之间进行微调，包括次要版本。在方法主体内部使用的类型的可空性超出了此功能的范围。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">其他常见的库（例如Reactor和Spring Data）提供了使用相似的可空性安排的空安全API，从而为Spring应用程序开发人员提供了一致的总体体验。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="use-cases"><a class="anchor" href="#use-cases"></a> 7.1。用例</h3>
<div class="paragraph">
<p>除了为Spring Framework API可空性提供显式声明之外，IDE（例如IDEA或Eclipse）还可以使用这些注释来提供与空安全有关的有用警告，以避免<code>NullPointerException</code>在运行时。</p>
</div>
<div class="paragraph">
<p>由于Kotlin原生支持<a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a> ，因此它们还用于在Kotlin项目中使Spring API为null-safe。<a href="languages.html#kotlin-null-safety">Kotlin支持文档</a>中提供了更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="jsr-305-meta-annotations"><a class="anchor" href="#jsr-305-meta-annotations"></a> 7.2。JSR-305元注释</h3>
<div class="paragraph">
<p>Spring注释使用<a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>注释（休眠但广泛使用的JSR）进行元注释。JSR-305元注释使工具供应商（如IDEA或Kotlin）以通用方式提供了空安全支持，而无需对Spring注释进行硬编码支持。</p>
</div>
<div class="paragraph">
<p>既不需要也不建议向项目类路径添加JSR-305依赖项以利用Spring空安全API。只有在代码库中使用空安全注释的基于Spring的库之类的项目才应添加<code>com.google.code.findbugs:jsr305:3.0.2</code>与<code>compileOnly</code> Gradle配置或Maven <code>provided</code>避免编译警告的范围。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="databuffers"><a class="anchor" href="#databuffers"></a> 8。数据缓冲区和编解码器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java NIO提供<code>ByteBuffer</code>但是许多库在顶部构建了自己的字节缓冲区API，特别是对于网络操作，其中重用缓冲区和/或使用直接缓冲区对性能有利。例如Netty有<code>ByteBuf</code>在层次结构中，Undertow使用XNIO，Jetty使用带有要释放的回调的池字节缓冲区，依此类推。的<code>spring-core</code>模块提供了一组抽象，可以与各种字节缓冲区API配合使用，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#databuffers-factory"><code>DataBufferFactory</code></a>抽象数据缓冲区的创建。</p>
</li>
<li>
<p><a href="#databuffers-buffer"><code>DataBuffer</code></a>表示一个字节缓冲区，可以将其<a href="#databuffers-buffer-pooled">合并</a> 。</p>
</li>
<li>
<p><a href="#databuffers-utils"><code>DataBufferUtils</code></a>提供数据缓冲区的实用方法。</p>
</li>
<li>
<p><a href="#codecs">编</a>解码<a href="#codecs">器</a>将流数据缓冲区流解码或编码为更高级别的对象。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="databuffers-factory"><a class="anchor" href="#databuffers-factory"></a> 8.1。<code>DataBufferFactory</code></h3>
<div class="paragraph">
<p><code>DataBufferFactory</code>用于通过以下两种方式之一创建数据缓冲区：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>分配一个新的数据缓冲区，可以选择预先指定容量（如果已知），即使实现<code>DataBuffer</code>可以按需增长和收缩。</p>
</li>
<li>
<p>包装一个现有的<code>byte[]</code>要么<code>java.nio.ByteBuffer</code> ，它会使用<code>DataBuffer</code>实施，并且不涉及分配。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请注意，WebFlux应用程序不会创建<code>DataBufferFactory</code>直接但通过<code>ServerHttpResponse</code>或者<code>ClientHttpRequest</code>在客户端。工厂的类型取决于基础客户端或服务器，例如<code>NettyDataBufferFactory</code>对于Reactor Netty， <code>DefaultDataBufferFactory</code>为他人。</p>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-buffer"><a class="anchor" href="#databuffers-buffer"></a> 8.2。<code>DataBuffer</code></h3>
<div class="paragraph">
<p>的<code>DataBuffer</code>界面提供与以下类似的操作<code>java.nio.ByteBuffer</code>但还带来了一些其他好处，其中一些是受Netty启发的<code>ByteBuf</code> 。以下是部分好处清单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在独立的位置进行读写，即不需要调用<code>flip()</code>在读写之间切换。</p>
</li>
<li>
<p>容量随需扩展<code>java.lang.StringBuilder</code> 。</p>
</li>
<li>
<p>缓冲池和引用计数通过<a href="#databuffers-buffer-pooled"><code>PooledDataBuffer</code></a> 。</p>
</li>
<li>
<p>查看缓冲区为<code>java.nio.ByteBuffer</code> ， <code>InputStream</code> ， 要么<code>OutputStream</code> 。</p>
</li>
<li>
<p>确定给定字节的索引或最后一个索引。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-buffer-pooled"><a class="anchor" href="#databuffers-buffer-pooled"></a> 8.3。<code>PooledDataBuffer</code></h3>
<div class="paragraph">
<p>如Javadoc中<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html">ByteBuffer所述</a> ，字节缓冲区可以是直接的也可以是非直接的。直接缓冲区可以驻留在Java堆之外，从而无需复制本机I / O操作。这使得直接缓冲区对于通过套接字接收和发送数据特别有用，但是它们的创建和释放也更昂贵，这导致了缓冲池的想法。</p>
</div>
<div class="paragraph">
<p><code>PooledDataBuffer</code>是...的扩展<code>DataBuffer</code>这有助于进行引用计数，这对于字节缓冲区池至关重要。它是如何工作的？当一个<code>PooledDataBuffer</code>被分配的参考计数为1。致电<code>retain()</code>增加计数，同时调用<code>release()</code>减少它。只要计数大于0，就保证不会释放缓冲区。当计数减少到0时，可以释放池中的缓冲区，这实际上意味着将为缓冲区保留的内存返回到内存池。</p>
</div>
<div class="paragraph">
<p>请注意，不要在<code>PooledDataBuffer</code>直接，在大多数情况下，最好在<code>DataBufferUtils</code>将发布或保留应用于<code>DataBuffer</code>仅当它是<code>PooledDataBuffer</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-utils"><a class="anchor" href="#databuffers-utils"></a> 8.4。<code>DataBufferUtils</code></h3>
<div class="paragraph">
<p><code>DataBufferUtils</code>提供了许多实用的方法来对数据缓冲区进行操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果底层字节缓冲区API支持，则可以通过复合缓冲区将数据缓冲区流连接到单个缓冲区（可能具有零副本），例如零复制。</p>
</li>
<li>
<p>转<code>InputStream</code>或NIO <code>Channel</code>进入<code>Flux<DataBuffer></code> ，反之亦然<code>Publisher<DataBuffer></code>进入<code>OutputStream</code>或NIO <code>Channel</code> 。</p>
</li>
<li>
<p>释放或保留内容的方法<code>DataBuffer</code>如果缓冲区是的实例<code>PooledDataBuffer</code> 。</p>
</li>
<li>
<p>从字节流中跳过或获取，直到特定的字节数为止。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="codecs"><a class="anchor" href="#codecs"></a> 8.5。编解码器</h3>
<div class="paragraph">
<p>的<code>org.springframework.core.codec</code>软件包提供以下策略接口：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Encoder</code>编码<code>Publisher<T></code>放入数据缓冲区流。</p>
</li>
<li>
<p><code>Decoder</code>解码<code>Publisher<DataBuffer></code>进入更高级别的对象流。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>spring-core</code>模块提供<code>byte[]</code> ， <code>ByteBuffer</code> ， <code>DataBuffer</code> ， <code>Resource</code>和<code>String</code>编码器和解码器的实现。的<code>spring-web</code>该模块添加了Jackson JSON，Jackson Smile，JAXB2，协议缓冲区以及其他编码器和解码器。请参阅WebFlux部分中的<a href="web-reactive.html#webflux-codecs">编解码器</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-using"><a class="anchor" href="#databuffers-using"></a> 8.6。使用<code>DataBuffer</code></h3>
<div class="paragraph">
<p>使用数据缓冲区时，必须特别小心以确保释放缓冲区，因为它们可能会被<a href="#databuffers-buffer-pooled">合并</a> 。我们将使用编解码器来说明其工作原理，但是这些概念将更普遍地应用。让我们看看编解码器必须在内部执行哪些操作来管理数据缓冲区。</p>
</div>
<div class="paragraph">
<p>一种<code>Decoder</code>在创建更高级别的对象之前，它是最后一个读取输入数据缓冲区的对象，因此它必须按以下方式释放它们：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果一个<code>Decoder</code>只需读取每个输入缓冲区并准备立即释放它，就可以通过<code>DataBufferUtils.release(dataBuffer)</code> 。</p>
</li>
<li>
<p>如果一个<code>Decoder</code>正在使用<code>Flux</code>要么<code>Mono</code>诸如<code>flatMap</code> ， <code>reduce</code> ，以及其他在内部预取和缓存数据项，或者正在使用诸如<code>filter</code> ， <code>skip</code> ，以及其他遗漏物品的物品，然后<code>doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)</code>必须将其添加到组成链中，以确保在丢弃此类缓冲区之前将其释放，这也可能是错误或取消信号的结果。</p>
</li>
<li>
<p>如果一个<code>Decoder</code>如果以任何其他方式保留一个或多个数据缓冲区，则必须确保在完全读取时释放它们，或者在读取和释放缓存的数据缓冲区之前发生错误或取消信号的情况下。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>注意<code>DataBufferUtils#join</code>提供了一种安全有效的方法来将数据缓冲区流聚合到单个数据缓冲区中。同样地<code>skipUntilByteCount</code>和<code>takeUntilByteCount</code>是供解码器使用的其他安全方法。</p>
</div>
<div class="paragraph">
<p>一个<code>Encoder</code>分配其他人必须读取（和释放）的数据缓冲区。所以<code>Encoder</code>没有太多的事情要做。但是<code>Encoder</code>如果在用数据填充缓冲区时发生序列化错误，则必须小心释放数据缓冲区。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DataBuffer buffer = factory.allocateBuffer();
boolean release = true;
try {
    // serialize and populate buffer..
    release = false;
}
finally {
    if (release) {
        DataBufferUtils.release(buffer);
    }
}
return buffer;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val buffer = factory.allocateBuffer()
var release = true
try {
    // serialize and populate buffer..
    release = false
} finally {
    if (release) {
        DataBufferUtils.release(buffer)
    }
}
return buffer</code></pre>
</div>
</div>
<div class="paragraph">
<p>消费者<code>Encoder</code>负责释放其接收的数据缓冲区。在WebFlux应用程序中， <code>Encoder</code>用于写入HTTP服务器响应或客户端HTTP请求，在这种情况下，释放数据缓冲区是代码写入服务器响应或客户端请求的责任。</p>
</div>
<div class="paragraph">
<p>请注意，在Netty上运行时，有用于调试<a href="https://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks">缓冲区泄漏的</a>调试选项。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a> 9。附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a> 9.1。XML模式</h3>
<div class="paragraph">
<p>附录的此部分列出了与核心容器相关的XML模式。</p>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util"><a class="anchor" href="#xsd-schemas-util"></a> 9.1.1。的<code>util</code>架构图</h4>
<div class="paragraph">
<p>顾名思义， <code>util</code>标签处理常见的实用程序配置问题，例如配置集合，引用常量等。要在<code>util</code>模式，您需要在Spring XML配置文件的顶部具有以下前导（代码段中的文本引用了正确的模式，以便<code>util</code>您可以使用名称空间）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"&gt;

        &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-constant"><a class="anchor" href="#xsd-schemas-util-constant"></a>使用<code><util:constant/></code></h5>
<div class="paragraph">
<p>考虑以下bean定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="..." class="..."&gt;
    &lt;property name="isolation"&gt;
        &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
                class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置使用了Spring <code>FactoryBean</code>实施（ <code>FieldRetrievingFactoryBean</code> ）来设定<code>isolation</code> Bean上的属性为<code>java.sql.Connection.TRANSACTION_SERIALIZABLE</code>不变。这一切都很好，但是很冗长，并且（不必要地）将Spring的内部管道暴露给最终用户。</p>
</div>
<div class="paragraph">
<p>以下基于XML Schema的版本更加简洁，清楚地表达了开发人员的意图（“注入此常数值”），并且读起来更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="..." class="..."&gt;
    &lt;property name="isolation"&gt;
        &lt;util:constant static-field="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="xsd-schemas-util-frfb"><a class="anchor" href="#xsd-schemas-util-frfb"></a>从字段值设置Bean属性或构造函数参数</h6>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>是一个<code>FactoryBean</code>检索<code>static</code>或非静态字段值。通常用于检索<code>public</code><code>static</code><code>final</code>常量，然后可用于为另一个bean设置属性值或构造函数参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>static</code>通过使用<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)"><code>staticField</code></a>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myField"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
    &lt;property name="staticField" value="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一种方便使用的表格，其中<code>static</code>字段指定为Bean名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这的确意味着在什么豆上不再有任何选择。 <code>id</code>是（因此，引用它的任何其他bean也必须使用该较长的名称），但是这种形式的定义非常简洁，并且非常容易用作内部bean，因为<code>id</code>不必为bean引用指定，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="..." class="..."&gt;
    &lt;property name="isolation"&gt;
        &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
                class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以访问另一个Bean的非静态（实例）字段，如API的API文档所述。 <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>类。</p>
</div>
<div class="paragraph">
<p>在Spring中，很容易将枚举值作为属性或构造函数参数注入到bean中。您实际上不必做任何事情或不了解Spring内部知识（甚至不必了解诸如<code>FieldRetrievingFactoryBean</code> ）。以下示例枚举显示了注入枚举值的难易程度：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package javax.persistence;

public enum PersistenceContextType {

    TRANSACTION,
    EXTENDED
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package javax.persistence

enum class PersistenceContextType {

    TRANSACTION,
    EXTENDED
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下类型的setter <code>PersistenceContextType</code>以及相应的bean定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package example;

public class Client {

    private PersistenceContextType persistenceContextType;

    public void setPersistenceContextType(PersistenceContextType type) {
        this.persistenceContextType = type;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package example

class Client {

    lateinit var persistenceContextType: PersistenceContextType
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="example.Client"&gt;
    &lt;property name="persistenceContextType" value="TRANSACTION"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-property-path"><a class="anchor" href="#xsd-schemas-util-property-path"></a>使用<code><util:property-path/></code></h5>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
    &lt;property name="age" value="10"/&gt;
    &lt;property name="spouse"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="11"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property 'age' of bean 'testBean' --&gt;
&lt;bean id="testBean.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置使用了Spring <code>FactoryBean</code>实施（ <code>PropertyPathFactoryBean</code> ）创建一个Bean（类型为<code>int</code> ）叫<code>testBean.age</code>其值等于<code>age</code>的属性<code>testBean</code>豆。</p>
</div>
<div class="paragraph">
<p>现在考虑以下示例，该示例添加了一个<code><util:property-path/></code>元件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
    &lt;property name="age" value="10"/&gt;
    &lt;property name="spouse"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="11"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property 'age' of bean 'testBean' --&gt;
&lt;util:property-path id="name" path="testBean.age"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的价值<code>path</code>的属性<code><property-path/></code>元素遵循以下形式<code>beanName.beanProperty</code> 。在这种情况下，它将拾取<code>age</code>名为Bean的属性<code>testBean</code> 。的价值<code>age</code>财产是<code>10</code> 。</p>
</div>
<div class="sect5">
<h6 id="xsd-schemas-util-property-path-dependency"><a class="anchor" href="#xsd-schemas-util-property-path-dependency"></a>使用<code><util:property-path/></code>设置Bean属性或构造函数参数</h6>
<div class="paragraph">
<p><code>PropertyPathFactoryBean</code>是一个<code>FactoryBean</code>计算给定目标对象上的属性路径。可以直接指定目标对象，也可以通过bean名称指定目标对象。然后，您可以在另一个bean定义中将此值用作属性值或构造函数参数。</p>
</div>
<div class="paragraph">
<p>下面的示例按名称显示了针对另一个bean的路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">// target bean to be referenced by name
&lt;bean id="person" class="org.springframework.beans.TestBean" scope="prototype"&gt;
    &lt;property name="age" value="10"/&gt;
    &lt;property name="spouse"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="11"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

// results in 11, which is the value of property 'spouse.age' of bean 'person'
&lt;bean id="theAge"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
    &lt;property name="targetBeanName" value="person"/&gt;
    &lt;property name="propertyPath" value="spouse.age"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在以下示例中，针对内部bean评估路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- results in 12, which is the value of property 'age' of the inner bean --&gt;
&lt;bean id="theAge"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
    &lt;property name="targetObject"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="12"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="propertyPath" value="age"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一种快捷方式，其中Bean名称是属性路径。以下示例显示了快捷方式表格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- results in 10, which is the value of property 'age' of bean 'person' --&gt;
&lt;bean id="person.age"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种形式的确意味着在bean名称中没有选择。对它的任何引用也必须使用相同的<code>id</code> ，这就是路径。如果用作内部bean，则根本不需要引用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="..." class="..."&gt;
    &lt;property name="age"&gt;
        &lt;bean id="person.age"
                class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在实际定义中专门设置结果类型。对于大多数用例来说，这不是必需的，但有时可能很有用。有关此功能的更多信息，请参见javadoc。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-properties"><a class="anchor" href="#xsd-schemas-util-properties"></a>使用<code><util:properties/></code></h5>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;bean id="jdbcConfiguration" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
    &lt;property name="location" value="classpath:com/foo/jdbc-production.properties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置使用了Spring <code>FactoryBean</code>实施（ <code>PropertiesFactoryBean</code> ）实例化一个<code>java.util.Properties</code>具有从提供的值加载的值的实例<a href="#resources"><code>Resource</code></a>地点）。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>util:properties</code>元素以更简洁地表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;util:properties id="jdbcConfiguration" location="classpath:com/foo/jdbc-production.properties"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-list"><a class="anchor" href="#xsd-schemas-util-list"></a>使用<code><util:list/></code></h5>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean"&gt;
    &lt;property name="sourceList"&gt;
        &lt;list&gt;
            &lt;value&gt;pechorin@hero.org&lt;/value&gt;
            &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
            &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
            &lt;value&gt;porfiry@gov.org&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置使用了Spring <code>FactoryBean</code>实施（ <code>ListFactoryBean</code> ）创建一个<code>java.util.List</code>实例，并使用提供的值对其进行初始化<code>sourceList</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code><util:list/></code>元素以更简洁地表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.List instance with the supplied values --&gt;
&lt;util:list id="emails"&gt;
    &lt;value&gt;pechorin@hero.org&lt;/value&gt;
    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
    &lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以显式控制确切的类型<code>List</code>通过使用实例化和填充<code>list-class</code>的属性<code><util:list/></code>元件。例如，如果我们真的需要<code>java.util.LinkedList</code>要实例化，我们可以使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;util:list id="emails" list-class="java.util.LinkedList"&gt;
    &lt;value&gt;jackshaftoe@vagabond.org&lt;/value&gt;
    &lt;value&gt;eliza@thinkingmanscrumpet.org&lt;/value&gt;
    &lt;value&gt;vanhoek@pirate.org&lt;/value&gt;
    &lt;value&gt;d'Arcachon@nemesis.org&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不<code>list-class</code>提供属性，容器选择一个<code>List</code>实施。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-map"><a class="anchor" href="#xsd-schemas-util-map"></a>使用<code><util:map/></code></h5>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.MapFactoryBean"&gt;
    &lt;property name="sourceMap"&gt;
        &lt;map&gt;
            &lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
            &lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
            &lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
            &lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置使用了Spring <code>FactoryBean</code>实施（ <code>MapFactoryBean</code> ）创建一个<code>java.util.Map</code>使用从提供的键值对初始化的实例<code>'sourceMap'</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code><util:map/></code>元素以更简洁地表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.Map instance with the supplied key-value pairs --&gt;
&lt;util:map id="emails"&gt;
    &lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
    &lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
    &lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
    &lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以显式控制确切的类型<code>Map</code>通过使用实例化和填充<code>'map-class'</code>的属性<code><util:map/></code>元件。例如，如果我们真的需要<code>java.util.TreeMap</code>要实例化，我们可以使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;util:map id="emails" map-class="java.util.TreeMap"&gt;
    &lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
    &lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
    &lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
    &lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不<code>'map-class'</code>提供属性，容器选择一个<code>Map</code>实施。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-set"><a class="anchor" href="#xsd-schemas-util-set"></a>使用<code><util:set/></code></h5>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.SetFactoryBean"&gt;
    &lt;property name="sourceSet"&gt;
        &lt;set&gt;
            &lt;value&gt;pechorin@hero.org&lt;/value&gt;
            &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
            &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
            &lt;value&gt;porfiry@gov.org&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置使用了Spring <code>FactoryBean</code>实施（ <code>SetFactoryBean</code> ）创建一个<code>java.util.Set</code>用从提供的值中获取的值初始化实例<code>sourceSet</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code><util:set/></code>元素以更简洁地表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- creates a java.util.Set instance with the supplied values --&gt;
&lt;util:set id="emails"&gt;
    &lt;value&gt;pechorin@hero.org&lt;/value&gt;
    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
    &lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:set&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以显式控制确切的类型<code>Set</code>通过使用实例化和填充<code>set-class</code>的属性<code><util:set/></code>元件。例如，如果我们真的需要<code>java.util.TreeSet</code>要实例化，我们可以使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;util:set id="emails" set-class="java.util.TreeSet"&gt;
    &lt;value&gt;pechorin@hero.org&lt;/value&gt;
    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
    &lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:set&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不<code>set-class</code>提供属性，容器选择一个<code>Set</code>实施。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-aop"><a class="anchor" href="#xsd-schemas-aop"></a> 9.1.2。的<code>aop</code>架构图</h4>
<div class="paragraph">
<p>的<code>aop</code>标签处理在Spring中配置AOP的所有事情，包括Spring自己的基于代理的AOP框架以及Spring与AspectJ AOP框架的集成。这些标签在名为<a href="#aop">Spring的面向切面的编程</a>的一章中进行了全面介绍。</p>
</div>
<div class="paragraph">
<p>为了完整起见，请在<code>aop</code>模式，您需要在Spring XML配置文件的顶部具有以下前导（代码段中的文本引用了正确的模式，以便<code>aop</code>您可以使用名称空间）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context"><a class="anchor" href="#xsd-schemas-context"></a> 9.1.3。的<code>context</code>架构图</h4>
<div class="paragraph">
<p>的<code>context</code>标签处理<code>ApplicationContext</code>与管道相关的配置-即通常不是对最终用户重要的bean，而是在Spring中完成大量“艰巨”工作的bean，例如<code>BeanfactoryPostProcessors</code> 。以下代码段引用了正确的架构，因此<code>context</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-pphc"><a class="anchor" href="#xsd-schemas-context-pphc"></a>使用<code><property-placeholder/></code></h5>
<div class="paragraph">
<p>该元素激活替换<code>${…​}</code>占位符，可针对指定的属性文件（作为<a href="#resources">Spring资源location</a> ）进行解析。此元素是建立<a href="#beans-factory-placeholderconfigurer"><code>PropertySourcesPlaceholderConfigurer</code></a>为了你。如果您需要进一步控制特定的<code>PropertySourcesPlaceholderConfigurer</code>安装程序中，您可以自己将其显式定义为Bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-ac"><a class="anchor" href="#xsd-schemas-context-ac"></a>使用<code><annotation-config/></code></h5>
<div class="paragraph">
<p>此元素激活Spring基础结构以检测Bean类中的注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>春天的<a href="#beans-factory-metadata"><code>@Configuration</code></a>模型</p>
</li>
<li>
<p><a href="#beans-annotation-config"><code>@Autowired</code> / <code>@Inject</code></a>和<code>@Value</code></p>
</li>
<li>
<p>JSR-250的<code>@Resource</code> ， <code>@PostConstruct</code>和<code>@PreDestroy</code> （如果可供使用的话）</p>
</li>
<li>
<p>JPA的<code>@PersistenceContext</code>和<code>@PersistenceUnit</code> （如果可供使用的话）</p>
</li>
<li>
<p>春天的<a href="#context-functionality-events-annotation"><code>@EventListener</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>或者，您可以选择显式激活个人<code>BeanPostProcessors</code>对于那些注释。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该元素不会激活Spring的处理<a href="data-access.html#transaction-declarative-annotations"><code>@Transactional</code></a>注解;您可以使用<a href="data-access.html#tx-decl-explained"><code><tx:annotation-driven/></code></a>为此目的的元素。同样，还需要显式<a href="integration.html#cache-annotation-enable">启用</a> Spring的<a href="integration.html#cache-annotations">缓存注释</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-component-scan"><a class="anchor" href="#xsd-schemas-context-component-scan"></a>使用<code><component-scan/></code></h5>
<div class="paragraph">
<p>有关<a href="#beans-annotation-config">基于注释的容器配置</a>的部分中详细介绍了此元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-ltw"><a class="anchor" href="#xsd-schemas-context-ltw"></a>使用<code><load-time-weaver/></code></h5>
<div class="paragraph">
<p><a href="#aop-aj-ltw">在Spring Framework中关于使用AspectJ</a>进行<a href="#aop-aj-ltw">加载时编织</a>的部分中详细介绍了此元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-sc"><a class="anchor" href="#xsd-schemas-context-sc"></a>使用<code><spring-configured/></code></h5>
<div class="paragraph">
<p>在<a href="#aop-atconfigurable">使用AspectJ通过Spring依赖注入域对象</a>的部分中详细介绍了此元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a>使用<code><mbean-export/></code></h5>
<div class="paragraph">
<p>有关<a href="integration.html#jmx-context-mbeanexport">配置基于注释的MBean导出</a>的部分中详细介绍了此元素。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-beans"><a class="anchor" href="#xsd-schemas-beans"></a> 9.1.4。Bean模式</h4>
<div class="paragraph">
<p>最后但并非最不重要的一点是，我们在<code>beans</code>模式。自框架诞生之初，这些元素就已经出现在春季。各种元素的示例<code>beans</code>此处未显示模式，因为它们在<a href="#beans-factory-properties-detailed">依赖项和配置中</a>非常全面地覆盖了它们（实际上，在整<a href="#beans">章中也是如此</a> ）。</p>
</div>
<div class="paragraph">
<p>请注意，您可以将零个或多个键值对添加到<code><bean/></code> XML定义。使用此额外的元数据进行的操作（如果有的话）完全取决于您自己的自定义逻辑（因此，通常只有在您按照标题为<a href="#xml-custom">XML Schema Authoring</a>的附录中所述编写自己的自定义元素时才能使用）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code><meta/></code>周围环境中的元素<code><bean/></code> （请注意，没有任何逻辑来解释它，元数据实际上是毫无用处的）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;meta key="cacheName" value="foo"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        &lt;property name="name" value="Rick"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>这是例子<code>meta</code>元件</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以假设存在一些逻辑，这些逻辑消耗了bean的定义并建立了一些使用提供的元数据的缓存基础结构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-custom"><a class="anchor" href="#xml-custom"></a> 9.2。XML模式创作</h3>
<div id="xsd-custom-introduction" class="paragraph">
<p>从2.0版开始，Spring提供了一种机制，该机制可将基于架构的扩展添加到用于定义和配置bean的基本Spring XML格式中。本节介绍如何编写自己的自定义XML Bean定义解析器，以及如何将此类解析器集成到Spring IoC容器中。</p>
</div>
<div class="paragraph">
<p>为了方便使用架构感知的XML编辑器编写配置文件，Spring的可扩展XML配置机制基于XML Schema。如果您不熟悉标准Spring发行版随附的Spring当前的XML配置扩展，则应首先阅读标题为<a href="#xsd-config">[xsd-config]</a>的附录。</p>
</div>
<div class="paragraph">
<p>要创建新的XML配置扩展，请执行以下操作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#xsd-custom-schema">编写</a> XML模式以描述您的自定义元素。</p>
</li>
<li>
<p><a href="#xsd-custom-namespacehandler">编写</a>自定义<a href="#xsd-custom-namespacehandler">代码</a> <code>NamespaceHandler</code>实施。</p>
</li>
<li>
<p><a href="#xsd-custom-parser">编码</a>一个或多个<code>BeanDefinitionParser</code>实现（这是完成实际工作的地方）。</p>
</li>
<li>
<p>向Spring <a href="#xsd-custom-registration">注册</a>新的工件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对于一个统一的示例，我们创建一个XML扩展（自定义XML元素），该扩展使我们可以配置该类型的对象<code>SimpleDateFormat</code> （来自<code>java.text</code>包）。完成后，我们将能够定义类型的bean定义<code>SimpleDateFormat</code>如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>（我们将在本附录后面提供更详细的示例。第一个简单示例的目的是引导您完成制作自定义扩展的基本步骤。）</p>
</div>
<div class="sect3">
<h4 id="xsd-custom-schema"><a class="anchor" href="#xsd-custom-schema"></a> 9.2.1。编写架构</h4>
<div class="paragraph">
<p>创建用于Spring的IoC容器的XML配置扩展首先要编写XML模式来描述扩展。对于我们的示例，我们使用以下架构进行配置<code>SimpleDateFormat</code>对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema xmlns="http://www.mycompany.example/schema/myns"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:beans="http://www.springframework.org/schema/beans"
        targetNamespace="http://www.mycompany.example/schema/myns"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified"&gt;

    &lt;xsd:import namespace="http://www.springframework.org/schema/beans"/&gt;

    &lt;xsd:element name="dateformat"&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:complexContent&gt;
                &lt;xsd:extension base="beans:identifiedType"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
                    &lt;xsd:attribute name="lenient" type="xsd:boolean"/&gt;
                    &lt;xsd:attribute name="pattern" type="xsd:string" use="required"/&gt;
                &lt;/xsd:extension&gt;
            &lt;/xsd:complexContent&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>所指示的行包含所有可识别标签的扩展名（这意味着它们具有一个<code>id</code>我们可以用作容器中bean标识符的属性）。我们可以使用此属性，因为我们导入了Spring提供的<code>beans</code>命名空间。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的架构让我们配置<code>SimpleDateFormat</code>使用以下命令将对象直接放在XML应用程序上下文文件中<code><myns:dateformat/></code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在创建基础结构类之后，上述XML片段与以下XML片段基本相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dateFormat" class="java.text.SimpleDateFormat"&gt;
    &lt;constructor-arg value="yyyy-HH-dd HH:mm"/&gt;
    &lt;property name="lenient" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面两个代码片段中的第二个在容器中创建了一个bean（由名称标识<code>dateFormat</code>类型的<code>SimpleDateFormat</code> ），并设置了几个属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">创建配置格式的基于模式的方法允许与具有模式识别XML编辑器的IDE紧密集成。通过使用正确编写的架构，可以使用自动完成功能来让用户在枚举中定义的多个配置选项之间进行选择。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-namespacehandler"><a class="anchor" href="#xsd-custom-namespacehandler"></a> 9.2.2。编码a<code>NamespaceHandler</code></h4>
<div class="paragraph">
<p>除了架构，我们还需要一个<code>NamespaceHandler</code>解析配置文件时Spring遇到的此特定名称空间的所有元素。对于此示例， <code>NamespaceHandler</code>应该注意解析<code>myns:dateformat</code>元件。</p>
</div>
<div class="paragraph">
<p>的<code>NamespaceHandler</code>界面功能三种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>init()</code> ：允许初始化<code>NamespaceHandler</code>并在使用处理程序之前由Spring调用。</p>
</li>
<li>
<p><code>BeanDefinition parse(Element, ParserContext)</code> ：当Spring遇到顶级元素（未嵌套在bean定义或其他命名空间中）时调用。此方法本身可以注册Bean定义，返回Bean定义或两者。</p>
</li>
<li>
<p><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code> ：当Spring遇到另一个名称空间的属性或嵌套元素时调用。一个或多个bean定义的修饰（例如）与<a href="#beans-factory-scopes">Spring支持</a>的<a href="#beans-factory-scopes">范围</a>一起使用。我们首先突出显示一个简单的示例，而不使用装饰，然后在一个更高级的示例中显示装饰。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然您可以自己编写代码<code>NamespaceHandler</code>对于整个名称空间（并因此提供解析该名称空间中每个元素的代码），通常情况是，Spring XML配置文件中的每个顶级XML元素都会产生一个bean定义（例如，哪里单<code><myns:dateformat/></code>元素导致单个<code>SimpleDateFormat</code> bean定义）。Spring提供了许多支持这种情况的便利类。在以下示例中，我们使用<code>NamespaceHandlerSupport</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        registerBeanDefinitionParser("dateformat", new SimpleDateFormatBeanDefinitionParser());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.samples.xml

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class MyNamespaceHandler : NamespaceHandlerSupport {

    override fun init() {
        registerBeanDefinitionParser("dateformat", SimpleDateFormatBeanDefinitionParser())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会注意到，此类中实际上没有很多解析逻辑。确实， <code>NamespaceHandlerSupport</code>类具有内置的委托概念。它支持任意数量的注册<code>BeanDefinitionParser</code>需要解析其名称空间中的元素时委托给的实例。关注点的这种清晰分离使<code>NamespaceHandler</code>在委托给名称空间的同时，处理其命名空间中所有自定义元素的解析的编排<code>BeanDefinitionParsers</code>来完成XML解析的繁琐工作。这意味着每个<code>BeanDefinitionParser</code>仅包含解析单个自定义元素的逻辑，我们将在下一步中看到。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-parser"><a class="anchor" href="#xsd-custom-parser"></a> 9.2.3。使用<code>BeanDefinitionParser</code></h4>
<div class="paragraph">
<p>一种<code>BeanDefinitionParser</code>如果使用<code>NamespaceHandler</code>遇到已映射到特定bean定义解析器（ <code>dateformat</code>在这种情况下）。换句话说， <code>BeanDefinitionParser</code>负责解析模式中定义的一个独特的顶级XML元素。在解析器中，我们可以访问XML元素（因此也可以访问其子元素），以便我们可以解析自定义XML内容，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { <i class="conum" data-value="1"></i><b>(1)</b>

    protected Class getBeanClass(Element element) {
        return SimpleDateFormat.class; <i class="conum" data-value="2"></i><b>(2)</b>
    }

    protected void doParse(Element element, BeanDefinitionBuilder bean) {
        // this will never be null since the schema explicitly requires that a value be supplied
        String pattern = element.getAttribute("pattern");
        bean.addConstructorArgValue(pattern);

        // this however is an optional property
        String lenient = element.getAttribute("lenient");
        if (StringUtils.hasText(lenient)) {
            bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
        }
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们使用Spring提供的<code>AbstractSingleBeanDefinitionParser</code>处理创建单个文件的许多基本工作<code>BeanDefinition</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们提供<code>AbstractSingleBeanDefinitionParser</code>具有我们单身类型的超类<code>BeanDefinition</code>代表。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package org.springframework.samples.xml

import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser
import org.springframework.util.StringUtils
import org.w3c.dom.Element

import java.text.SimpleDateFormat

class SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { <i class="conum" data-value="1"></i><b>(1)</b>

    override fun getBeanClass(element: Element): Class&lt;*&gt;? { <i class="conum" data-value="2"></i><b>(2)</b>
        return SimpleDateFormat::class.java
    }

    override fun doParse(element: Element, bean: BeanDefinitionBuilder) {
        // this will never be null since the schema explicitly requires that a value be supplied
        val pattern = element.getAttribute("pattern")
        bean.addConstructorArgValue(pattern)

        // this however is an optional property
        val lenient = element.getAttribute("lenient")
        if (StringUtils.hasText(lenient)) {
            bean.addPropertyValue("lenient", java.lang.Boolean.valueOf(lenient))
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们使用Spring提供的<code>AbstractSingleBeanDefinitionParser</code>处理创建单个文件的许多基本工作<code>BeanDefinition</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们提供<code>AbstractSingleBeanDefinitionParser</code>具有我们单身类型的超类<code>BeanDefinition</code>代表。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种简单的情况下，这就是我们要做的。创建我们的单曲<code>BeanDefinition</code>由<code>AbstractSingleBeanDefinitionParser</code>超类，以及Bean定义的唯一标识符的提取和设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-registration"><a class="anchor" href="#xsd-custom-registration"></a> 9.2.4。注册处理程序和架构</h4>
<div class="paragraph">
<p>编码完成。剩下要做的就是让Spring XML解析基础结构了解我们的自定义元素。我们通过注册我们的习惯来做到这一点<code>namespaceHandler</code>和自定义XSD文件放在两个专用属性文件中。这些属性文件都放置在<code>META-INF</code>目录在您的应用程序中，例如可以与您的二进制类一起分发到JAR文件中。Spring XML解析基础结构通过使用这些特殊的属性文件来自动选择您的新扩展，以下两部分将详细介绍其格式。</p>
</div>
<div class="sect4">
<h5 id="xsd-custom-registration-spring-handlers"><a class="anchor" href="#xsd-custom-registration-spring-handlers"></a>写作<code>META-INF/spring.handlers</code></h5>
<div class="paragraph">
<p>属性文件称为<code>spring.handlers</code>包含XML Schema URI到名称空间处理程序类的映射。对于我们的示例，我们需要编写以下内容：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</pre>
</div>
</div>
<div class="paragraph">
<p>（ <code>:</code>字符是Java属性格式中的有效分隔符，因此<code>:</code> URI中的字符需要用反斜杠转义。）</p>
</div>
<div class="paragraph">
<p>键值对的第一部分（键）是与您的自定义名称空间扩展关联的URI，需要与该值精确匹配<code>targetNamespace</code>属性，在您的自定义XSD架构中指定。</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-custom-registration-spring-schemas"><a class="anchor" href="#xsd-custom-registration-spring-schemas"></a>编写“ META-INF / spring.schemas”</h5>
<div class="paragraph">
<p>属性文件称为<code>spring.schemas</code>包含XML模式位置的映射（与模式声明一起称为XML文件，该文件将模式用作<code>xsi:schemaLocation</code>属性）。需要这个文件来防止Spring绝对必须使用默认值<code>EntityResolver</code>需要Internet访问才能检索架构文件。如果您在此属性文件中指定映射，则Spring会搜索架构（在这种情况下， <code>myns.xsd</code>在里面<code>org.springframework.samples.xml</code>包）。以下代码段显示了我们需要为自定义架构添加的行：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http\://www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</pre>
</div>
</div>
<div class="paragraph">
<p>（请记住<code>:</code>字符必须转义。）</p>
</div>
<div class="paragraph">
<p>建议您在XSD文件旁边部署XSD文件。 <code>NamespaceHandler</code>和<code>BeanDefinitionParser</code>类路径上的类。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-using"><a class="anchor" href="#xsd-custom-using"></a> 9.2.5。在Spring XML配置中使用自定义扩展</h4>
<div class="paragraph">
<p>使用您自己实现的自定义扩展与使用Spring提供的“自定义”扩展没有什么不同。以下示例使用自定义<code><dateformat/></code> Spring XML配置文件中先前步骤中开发的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:myns="http://www.mycompany.example/schema/myns"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"&gt;

    &lt;!-- as a top-level bean --&gt;
    &lt;myns:dateformat id="defaultDateFormat" pattern="yyyy-MM-dd HH:mm" lenient="true"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;bean id="jobDetailTemplate" abstract="true"&gt;
        &lt;property name="dateFormat"&gt;
            &lt;!-- as an inner bean --&gt;
            &lt;myns:dateformat pattern="HH:mm MM-dd-yyyy"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们的定制豆。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-meat"><a class="anchor" href="#xsd-custom-meat"></a> 9.2.6。更详细的例子</h4>
<div class="paragraph">
<p>本节提供一些更详细的自定义XML扩展示例。</p>
</div>
<div class="sect4">
<h5 id="xsd-custom-custom-nested"><a class="anchor" href="#xsd-custom-custom-nested"></a>在自定义元素中嵌套自定义元素</h5>
<div class="paragraph">
<p>本节中的示例显示如何编写满足以下配置目标所需的各种工件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:foo="http://www.foo.example/schema/component"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd"&gt;

    &lt;foo:component id="bionic-family" name="Bionic-1"&gt;
        &lt;foo:component name="Mother-1"&gt;
            &lt;foo:component name="Karate-1"/&gt;
            &lt;foo:component name="Sport-1"/&gt;
        &lt;/foo:component&gt;
        &lt;foo:component name="Rock-1"/&gt;
    &lt;/foo:component&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置在彼此之间嵌套了自定义扩展。实际配置的类<code><foo:component/></code>元素是<code>Component</code>类（在下一个示例中显示）。请注意<code>Component</code>类未公开针对<code>components</code>属性。这使得很难（或几乎不可能）为Bean配置Bean定义。 <code>Component</code>通过使用setter注入进行上课。以下清单显示了<code>Component</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import java.util.ArrayList;
import java.util.List;

public class Component {

    private String name;
    private List&lt;Component&gt; components = new ArrayList&lt;Component&gt; ();

    // mmm, there is no setter method for the 'components'
    public void addComponent(Component component) {
        this.components.add(component);
    }

    public List&lt;Component&gt; getComponents() {
        return components;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

import java.util.ArrayList

class Component {

    var name: String? = null
    private val components = ArrayList&lt;Component&gt;()

    // mmm, there is no setter method for the 'components'
    fun addComponent(component: Component) {
        this.components.add(component)
    }

    fun getComponents(): List&lt;Component&gt; {
        return components
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>解决此问题的典型方法是创建一个自定义<code>FactoryBean</code>公开了setter属性的<code>components</code>属性。以下清单显示了这样的习惯<code>FactoryBean</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.beans.factory.FactoryBean;

import java.util.List;

public class ComponentFactoryBean implements FactoryBean&lt;Component&gt; {

    private Component parent;
    private List&lt;Component&gt; children;

    public void setParent(Component parent) {
        this.parent = parent;
    }

    public void setChildren(List&lt;Component&gt; children) {
        this.children = children;
    }

    public Component getObject() throws Exception {
        if (this.children != null &amp;&amp; this.children.size() &gt; 0) {
            for (Component child : children) {
                this.parent.addComponent(child);
            }
        }
        return this.parent;
    }

    public Class&lt;Component&gt; getObjectType() {
        return Component.class;
    }

    public boolean isSingleton() {
        return true;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.FactoryBean
import org.springframework.stereotype.Component

class ComponentFactoryBean : FactoryBean&lt;Component&gt; {

    private var parent: Component? = null
    private var children: List&lt;Component&gt;? = null

    fun setParent(parent: Component) {
        this.parent = parent
    }

    fun setChildren(children: List&lt;Component&gt;) {
        this.children = children
    }

    override fun getObject(): Component? {
        if (this.children != null &amp;&amp; this.children!!.isNotEmpty()) {
            for (child in children!!) {
                this.parent!!.addComponent(child)
            }
        }
        return this.parent
    }

    override fun getObjectType(): Class&lt;Component&gt;? {
        return Component::class.java
    }

    override fun isSingleton(): Boolean {
        return true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好用，但是向最终用户暴露了很多Spring管道。我们要做的是编写一个自定义扩展名，以隐藏所有此Spring管道。如果我们坚持<a href="#xsd-custom-introduction">前面描述的步骤</a> ，那么我们首先创建XSD模式来定义我们的自定义标签的结构，如下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.example/schema/component"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.foo.example/schema/component"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified"&gt;

    &lt;xsd:element name="component"&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
                &lt;xsd:element ref="component"/&gt;
            &lt;/xsd:choice&gt;
            &lt;xsd:attribute name="id" type="xsd:ID"/&gt;
            &lt;xsd:attribute name="name" use="required" type="xsd:string"/&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次按照<a href="#xsd-custom-introduction">前面描述的过程</a> ，我们然后创建一个自定义<code>NamespaceHandler</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class ComponentNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        registerBeanDefinitionParser("component", new ComponentBeanDefinitionParser());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class ComponentNamespaceHandler : NamespaceHandlerSupport() {

    override fun init() {
        registerBeanDefinitionParser("component", ComponentBeanDefinitionParser())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是风俗<code>BeanDefinitionParser</code> 。请记住，我们正在创建一个<code>BeanDefinition</code>描述一个<code>ComponentFactoryBean</code> 。以下清单显示了我们的自定义<code>BeanDefinitionParser</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;

import java.util.List;

public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {

    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
        return parseComponentElement(element);
    }

    private static AbstractBeanDefinition parseComponentElement(Element element) {
        BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
        factory.addPropertyValue("parent", parseComponent(element));

        List&lt;Element&gt; childElements = DomUtils.getChildElementsByTagName(element, "component");
        if (childElements != null &amp;&amp; childElements.size() &gt; 0) {
            parseChildComponents(childElements, factory);
        }

        return factory.getBeanDefinition();
    }

    private static BeanDefinition parseComponent(Element element) {
        BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
        component.addPropertyValue("name", element.getAttribute("name"));
        return component.getBeanDefinition();
    }

    private static void parseChildComponents(List&lt;Element&gt; childElements, BeanDefinitionBuilder factory) {
        ManagedList&lt;BeanDefinition&gt; children = new ManagedList&lt;BeanDefinition&gt;(childElements.size());
        for (Element element : childElements) {
            children.add(parseComponentElement(element));
        }
        factory.addPropertyValue("children", children);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.config.BeanDefinition
import org.springframework.beans.factory.support.AbstractBeanDefinition
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.support.ManagedList
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser
import org.springframework.beans.factory.xml.ParserContext
import org.springframework.util.xml.DomUtils
import org.w3c.dom.Element

import java.util.List

class ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() {

    override fun parseInternal(element: Element, parserContext: ParserContext): AbstractBeanDefinition? {
        return parseComponentElement(element)
    }

    private fun parseComponentElement(element: Element): AbstractBeanDefinition {
        val factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean::class.java)
        factory.addPropertyValue("parent", parseComponent(element))

        val childElements = DomUtils.getChildElementsByTagName(element, "component")
        if (childElements != null &amp;&amp; childElements.size &gt; 0) {
            parseChildComponents(childElements, factory)
        }

        return factory.getBeanDefinition()
    }

    private fun parseComponent(element: Element): BeanDefinition {
        val component = BeanDefinitionBuilder.rootBeanDefinition(Component::class.java)
        component.addPropertyValue("name", element.getAttribute("name"))
        return component.beanDefinition
    }

    private fun parseChildComponents(childElements: List&lt;Element&gt;, factory: BeanDefinitionBuilder) {
        val children = ManagedList&lt;BeanDefinition&gt;(childElements.size)
        for (element in childElements) {
            children.add(parseComponentElement(element))
        }
        factory.addPropertyValue("children", children)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，需要通过修改XML架构向Spring XML基础架构注册各种工件。 <code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.handlers'
http\://www.foo.example/schema/component=com.foo.ComponentNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.schemas'
http\://www.foo.example/schema/component/component.xsd=com/foo/component.xsd</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-custom-custom-just-attributes"><a class="anchor" href="#xsd-custom-custom-just-attributes"></a> “普通”元素上的自定义属性</h5>
<div class="paragraph">
<p>编写自己的自定义解析器和关联的工件并不难。但是，有时这不是正确的选择。考虑一个需要将元数据添加到已经存在的bean定义的场景。在这种情况下，您当然不需要编写自己的整个自定义扩展名。相反，您只想向现有的bean定义元素添加一个附加属性。</p>
</div>
<div class="paragraph">
<p>通过另一个示例，假设您为访问集群<a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>的服务对象定义了一个Bean定义（未知），并且您想确保在周围的集群中急切启动命名的JCache实例。以下清单显示了这样的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="checkingAccountService" class="com.foo.DefaultCheckingAccountService"
        jcache:cache-name="checking.account"&gt;
    &lt;!-- other dependencies here... --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以创建另一个<code>BeanDefinition</code>当。。。的时候<code>'jcache:cache-name'</code>属性被解析。这个<code>BeanDefinition</code>然后为我们初始化命名的JCache。我们也可以修改现有的<code>BeanDefinition</code>为了<code>'checkingAccountService'</code>因此它依赖于此新的JCache初始化<code>BeanDefinition</code> 。以下清单显示了我们的<code>JCacheInitializer</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

public class JCacheInitializer {

    private String name;

    public JCacheInitializer(String name) {
        this.name = name;
    }

    public void initialize() {
        // lots of JCache API calls to initialize the named cache...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

class JCacheInitializer(private val name: String) {

    fun initialize() {
        // lots of JCache API calls to initialize the named cache...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以进入自定义扩展了。首先，我们需要编写描述自定义属性的XSD模式，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.example/schema/jcache"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.foo.example/schema/jcache"
        elementFormDefault="qualified"&gt;

    &lt;xsd:attribute name="cache-name" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们需要创建关联的<code>NamespaceHandler</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class JCacheNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        super.registerBeanDefinitionDecoratorForAttribute("cache-name",
            new JCacheInitializingBeanDefinitionDecorator());
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class JCacheNamespaceHandler : NamespaceHandlerSupport() {

    override fun init() {
        super.registerBeanDefinitionDecoratorForAttribute("cache-name",
                JCacheInitializingBeanDefinitionDecorator())
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们需要创建解析器。请注意，在这种情况下，因为我们要解析XML属性，所以我们编写了一个<code>BeanDefinitionDecorator</code>而不是<code>BeanDefinitionParser</code> 。以下清单显示了我们的<code>BeanDefinitionDecorator</code>实施：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.ParserContext;
import org.w3c.dom.Attr;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,
            ParserContext ctx) {
        String initializerBeanName = registerJCacheInitializer(source, ctx);
        createDependencyOnJCacheInitializer(holder, initializerBeanName);
        return holder;
    }

    private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,
            String initializerBeanName) {
        AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
        String[] dependsOn = definition.getDependsOn();
        if (dependsOn == null) {
            dependsOn = new String[]{initializerBeanName};
        } else {
            List dependencies = new ArrayList(Arrays.asList(dependsOn));
            dependencies.add(initializerBeanName);
            dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
        }
        definition.setDependsOn(dependsOn);
    }

    private String registerJCacheInitializer(Node source, ParserContext ctx) {
        String cacheName = ((Attr) source).getValue();
        String beanName = cacheName + "-initializer";
        if (!ctx.getRegistry().containsBeanDefinition(beanName)) {
            BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
            initializer.addConstructorArg(cacheName);
            ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
        }
        return beanName;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package com.foo

import org.springframework.beans.factory.config.BeanDefinitionHolder
import org.springframework.beans.factory.support.AbstractBeanDefinition
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.xml.BeanDefinitionDecorator
import org.springframework.beans.factory.xml.ParserContext
import org.w3c.dom.Attr
import org.w3c.dom.Node

import java.util.ArrayList

class JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator {

    override fun decorate(source: Node, holder: BeanDefinitionHolder,
                        ctx: ParserContext): BeanDefinitionHolder {
        val initializerBeanName = registerJCacheInitializer(source, ctx)
        createDependencyOnJCacheInitializer(holder, initializerBeanName)
        return holder
    }

    private fun createDependencyOnJCacheInitializer(holder: BeanDefinitionHolder,
                                                    initializerBeanName: String) {
        val definition = holder.beanDefinition as AbstractBeanDefinition
        var dependsOn = definition.dependsOn
        dependsOn = if (dependsOn == null) {
            arrayOf(initializerBeanName)
        } else {
            val dependencies = ArrayList(listOf(*dependsOn))
            dependencies.add(initializerBeanName)
            dependencies.toTypedArray()
        }
        definition.setDependsOn(*dependsOn)
    }

    private fun registerJCacheInitializer(source: Node, ctx: ParserContext): String {
        val cacheName = (source as Attr).value
        val beanName = "$cacheName-initializer"
        if (!ctx.registry.containsBeanDefinition(beanName)) {
            val initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer::class.java)
            initializer.addConstructorArg(cacheName)
            ctx.registry.registerBeanDefinition(beanName, initializer.getBeanDefinition())
        }
        return beanName
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们需要通过修改Spring XML基础结构来注册各种工件。 <code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.handlers'
http\://www.foo.example/schema/jcache=com.foo.JCacheNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.schemas'
http\://www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:51 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>