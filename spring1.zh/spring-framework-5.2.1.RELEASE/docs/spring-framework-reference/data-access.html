<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>资料存取</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



</head><body id="spring-data-tier" class="book toc2 toc-left" ><div id="header">
<h1>资料存取</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#transaction">1。交易管理</a>
<ul class="sectlevel2">
<li><a href="#transaction-motivation">1.1。Spring框架的事务支持模型的优点</a>
<ul class="sectlevel3">
<li><a href="#transaction-global">1.1.1。全球交易</a></li>
<li><a href="#transaction-local">1.1.2。本地交易</a></li>
<li><a href="#transaction-programming-model">1.1.3。Spring框架的一致编程模型</a></li>
</ul>
</li>
<li><a href="#transaction-strategies">1.2。了解Spring框架事务抽象</a></li>
<li><a href="#tx-resource-synchronization">1.3。将资源与事务同步</a>
<ul class="sectlevel3">
<li><a href="#tx-resource-synchronization-high">1.3.1。高级同步方法</a></li>
<li><a href="#tx-resource-synchronization-low">1.3.2。低级同步方法</a></li>
<li><a href="#tx-resource-synchronization-tadsp">1.3.3。<code>TransactionAwareDataSourceProxy</code></a></li>
</ul>
</li>
<li><a href="#transaction-declarative">1.4。声明式交易管理</a>
<ul class="sectlevel3">
<li><a href="#tx-decl-explained">1.4.1。了解Spring框架的声明式事务实现</a></li>
<li><a href="#transaction-declarative-first-example">1.4.2。声明式事务实现示例</a></li>
<li><a href="#transaction-declarative-rolling-back">1.4.3。回滚声明式事务</a></li>
<li><a href="#transaction-declarative-diff-tx">1.4.4。为不同的Bean配置不同的事务语义</a></li>
<li><a href="#transaction-declarative-txadvice-settings">1.4.5。 <tx:advice></tx:advice> 设定值</a></li>
<li><a href="#transaction-declarative-annotations">1.4.6。使用<code>@Transactional</code></a>
<ul class="sectlevel4">
<li><a href="#transaction-declarative-attransactional-settings"><code>@Transactional</code>设定值</a></li>
<li><a href="#tx-multiple-tx-mgrs-with-attransactional">多个交易经理<code>@Transactional</code></a></li>
<li><a href="#tx-custom-attributes">自定义快捷方式注释</a></li>
</ul>
</li>
<li><a href="#tx-propagation">1.4.7。交易传播</a>
<ul class="sectlevel4">
<li><a href="#tx-propagation-required">理解<code>PROPAGATION_REQUIRED</code></a></li>
<li><a href="#tx-propagation-requires_new">理解<code>PROPAGATION_REQUIRES_NEW</code></a></li>
<li><a href="#tx-propagation-nested">理解<code>PROPAGATION_NESTED</code></a></li>
</ul>
</li>
<li><a href="#transaction-declarative-applying-more-than-just-tx-advice">1.4.8。交易事务咨询</a></li>
<li><a href="#transaction-declarative-aspectj">1.4.9。使用<code>@Transactional</code>使用AspectJ</a></li>
</ul>
</li>
<li><a href="#transaction-programmatic">1.5。程序化交易管理</a>
<ul class="sectlevel3">
<li><a href="#tx-prog-template">1.5.1。使用<code>TransactionTemplate</code></a>
<ul class="sectlevel4">
<li><a href="#tx-prog-template-settings">指定交易设置</a></li>
</ul>
</li>
<li><a href="#transaction-programmatic-ptm">1.5.2。使用<code>PlatformTransactionManager</code></a></li>
</ul>
</li>
<li><a href="#tx-decl-vs-prog">1.6。在程序性和声明性事务管理之间进行选择</a></li>
<li><a href="#transaction-event">1.7。交易绑定事件</a></li>
<li><a href="#transaction-application-server-integration">1.8。应用服务器特定的集成</a>
<ul class="sectlevel3">
<li><a href="#transaction-application-server-integration-websphere">1.8.1。IBM WebSphere</a></li>
<li><a href="#transaction-application-server-integration-weblogic">1.8.2。Oracle WebLogic服务器</a></li>
</ul>
</li>
<li><a href="#transaction-solutions-to-common-problems">1.9。常见问题的解决方案</a>
<ul class="sectlevel3">
<li><a href="#transaction-solutions-to-common-problems-wrong-ptm">1.9.1。为特定的错误使用交易管理器<code>DataSource</code></a></li>
</ul>
</li>
<li><a href="#transaction-resources">1.10。更多资源</a></li>
</ul>
</li>
<li><a href="#dao">2。DAO支持</a>
<ul class="sectlevel2">
<li><a href="#dao-exceptions">2.1。一致的异常层次结构</a></li>
<li><a href="#dao-annotations">2.2。用于配置DAO或存储库类的注释</a></li>
</ul>
</li>
<li><a href="#jdbc">3。使用JDBC进行数据访问</a>
<ul class="sectlevel2">
<li><a href="#jdbc-choose-style">3.1。选择一种用于JDBC数据库访问的方法</a></li>
<li><a href="#jdbc-packages">3.2。包层次结构</a></li>
<li><a href="#jdbc-core">3.3。使用JDBC核心类控制基本JDBC处理和错误处理</a>
<ul class="sectlevel3">
<li><a href="#jdbc-JdbcTemplate">3.3.1。使用<code>JdbcTemplate</code></a>
<ul class="sectlevel4">
<li><a href="#jdbc-JdbcTemplate-examples-query">查询（ <code>SELECT</code> ）</a></li>
<li><a href="#jdbc-JdbcTemplate-examples-update">更新（ <code>INSERT</code> ， <code>UPDATE</code>和<code>DELETE</code> ）与<code>JdbcTemplate</code></a></li>
<li><a href="#jdbc-JdbcTemplate-examples-other">其他<code>JdbcTemplate</code>运作方式</a></li>
<li><a href="#jdbc-JdbcTemplate-idioms"><code>JdbcTemplate</code>最佳实践</a></li>
</ul>
</li>
<li><a href="#jdbc-NamedParameterJdbcTemplate">3.3.2。使用<code>NamedParameterJdbcTemplate</code></a></li>
<li><a href="#jdbc-SQLExceptionTranslator">3.3.3。使用<code>SQLExceptionTranslator</code></a></li>
<li><a href="#jdbc-statements-executing">3.3.4。运行声明</a></li>
<li><a href="#jdbc-statements-querying">3.3.5。运行查询</a></li>
<li><a href="#jdbc-updates">3.3.6。更新数据库</a></li>
<li><a href="#jdbc-auto-generated-keys">3.3.7。检索自动生成的密钥</a></li>
</ul>
</li>
<li><a href="#jdbc-connections">3.4。控制数据库连接</a>
<ul class="sectlevel3">
<li><a href="#jdbc-datasource">3.4.1。使用<code>DataSource</code></a></li>
<li><a href="#jdbc-DataSourceUtils">3.4.2。使用<code>DataSourceUtils</code></a></li>
<li><a href="#jdbc-SmartDataSource">3.4.3。实施中<code>SmartDataSource</code></a></li>
<li><a href="#jdbc-AbstractDataSource">3.4.4。延伸<code>AbstractDataSource</code></a></li>
<li><a href="#jdbc-SingleConnectionDataSource">3.4.5。使用<code>SingleConnectionDataSource</code></a></li>
<li><a href="#jdbc-DriverManagerDataSource">3.4.6。使用<code>DriverManagerDataSource</code></a></li>
<li><a href="#jdbc-TransactionAwareDataSourceProxy">3.4.7。使用<code>TransactionAwareDataSourceProxy</code></a></li>
<li><a href="#jdbc-DataSourceTransactionManager">3.4.8。使用<code>DataSourceTransactionManager</code></a></li>
</ul>
</li>
<li><a href="#jdbc-advanced-jdbc">3.5。JDBC批处理操作</a>
<ul class="sectlevel3">
<li><a href="#jdbc-batch-classic">3.5.1。基本批处理操作<code>JdbcTemplate</code></a></li>
<li><a href="#jdbc-batch-list">3.5.2。具有对象列表的批处理操作</a></li>
<li><a href="#jdbc-batch-multi">3.5.3。具有多个批次的批次操作</a></li>
</ul>
</li>
<li><a href="#jdbc-simple-jdbc">3.6。使用简化JDBC操作<code>SimpleJdbc</code>班级</a>
<ul class="sectlevel3">
<li><a href="#jdbc-simple-jdbc-insert-1">3.6.1。使用插入数据<code>SimpleJdbcInsert</code></a></li>
<li><a href="#jdbc-simple-jdbc-insert-2">3.6.2。通过使用检索自动生成的密钥<code>SimpleJdbcInsert</code></a></li>
<li><a href="#jdbc-simple-jdbc-insert-3">3.6.3。指定一个列<code>SimpleJdbcInsert</code></a></li>
<li><a href="#jdbc-simple-jdbc-parameters">3.6.4。使用<code>SqlParameterSource</code>提供参数值</a></li>
<li><a href="#jdbc-simple-jdbc-call-1">3.6.5。使用以下命令调用存储过程<code>SimpleJdbcCall</code></a></li>
<li><a href="#jdbc-simple-jdbc-call-2">3.6.6。明确声明要用于的参数<code>SimpleJdbcCall</code></a></li>
<li><a href="#jdbc-params">3.6.7。如何定义<code>SqlParameters</code></a></li>
<li><a href="#jdbc-simple-jdbc-call-3">3.6.8。通过使用调用存储的函数<code>SimpleJdbcCall</code></a></li>
<li><a href="#jdbc-simple-jdbc-call-4">3.6.9。返回一个<code>ResultSet</code>或来自<code>SimpleJdbcCall</code></a></li>
</ul>
</li>
<li><a href="#jdbc-object">3.7。将JDBC操作建模为Java对象</a>
<ul class="sectlevel3">
<li><a href="#jdbc-SqlQuery">3.7.1。理解<code>SqlQuery</code></a></li>
<li><a href="#jdbc-MappingSqlQuery">3.7.2。使用<code>MappingSqlQuery</code></a></li>
<li><a href="#jdbc-SqlUpdate">3.7.3。使用<code>SqlUpdate</code></a></li>
<li><a href="#jdbc-StoredProcedure">3.7.4。使用<code>StoredProcedure</code></a></li>
</ul>
</li>
<li><a href="#jdbc-parameter-handling">3.8。参数和数据值处理的常见问题</a>
<ul class="sectlevel3">
<li><a href="#jdbc-type-information">3.8.1。提供参数的SQL类型信息</a></li>
<li><a href="#jdbc-lob">3.8.2。处理BLOB和CLOB对象</a></li>
<li><a href="#jdbc-in-clause">3.8.3。传入IN子句的值列表</a></li>
<li><a href="#jdbc-complex-types">3.8.4。处理存储过程调用的复杂类型</a></li>
</ul>
</li>
<li><a href="#jdbc-embedded-database-support">3.9。嵌入式数据库支持</a>
<ul class="sectlevel3">
<li><a href="#jdbc-why-embedded-database">3.9.1。为什么要使用嵌入式数据库？</a></li>
<li><a href="#jdbc-embedded-database-xml">3.9.2。使用Spring XML创建嵌入式数据库</a></li>
<li><a href="#jdbc-embedded-database-java">3.9.3。以编程方式创建嵌入式数据库</a></li>
<li><a href="#jdbc-embedded-database-types">3.9.4。选择嵌入式数据库类型</a>
<ul class="sectlevel4">
<li><a href="#jdbc-embedded-database-using-HSQL">使用HSQL</a></li>
<li><a href="#jdbc-embedded-database-using-H2">使用H2</a></li>
<li><a href="#jdbc-embedded-database-using-Derby">使用德比</a></li>
</ul>
</li>
<li><a href="#jdbc-embedded-database-dao-testing">3.9.5。使用嵌入式数据库测试数据访问逻辑</a></li>
<li><a href="#jdbc-embedded-database-unique-names">3.9.6。为嵌入式数据库生成唯一名称</a></li>
<li><a href="#jdbc-embedded-database-extension">3.9.7。扩展嵌入式数据库支持</a></li>
</ul>
</li>
<li><a href="#jdbc-initializing-datasource">3.10。初始化一个<code>DataSource</code></a>
<ul class="sectlevel3">
<li><a href="#jdbc-initializing-datasource-xml">3.10.1。使用Spring XML初始化数据库</a>
<ul class="sectlevel4">
<li><a href="#jdbc-client-component-initialization">初始化依赖于数据库的其他组件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orm">4。对象关系映射（ORM）数据访问</a>
<ul class="sectlevel2">
<li><a href="#orm-introduction">4.1。Spring ORM简介</a></li>
<li><a href="#orm-general">4.2。ORM集成的一般注意事项</a>
<ul class="sectlevel3">
<li><a href="#orm-resource-mngmnt">4.2.1。资源与交易管理</a></li>
<li><a href="#orm-exception-translation">4.2.2。例外翻译</a></li>
</ul>
</li>
<li><a href="#orm-hibernate">4.3。冬眠</a>
<ul class="sectlevel3">
<li><a href="#orm-session-factory-setup">4.3.1。 <code>SessionFactory</code> 在Spring容器中设置</a></li>
<li><a href="#orm-hibernate-straight">4.3.2。基于Plain Hibernate API实现DAO</a></li>
<li><a href="#orm-hibernate-tx-declarative">4.3.3。声明式事务划分</a></li>
<li><a href="#orm-hibernate-tx-programmatic">4.3.4。程序化交易划分</a></li>
<li><a href="#orm-hibernate-tx-strategies">4.3.5。交易管理策略</a></li>
<li><a href="#orm-hibernate-resources">4.3.6。比较容器管理的资源和本地定义的资源</a></li>
<li><a href="#orm-hibernate-invalid-jdbc-access-error">4.3.7。Hibernate虚假的应用程序服务器警告</a></li>
</ul>
</li>
<li><a href="#orm-jpa">4.4。JPA</a>
<ul class="sectlevel3">
<li><a href="#orm-jpa-setup">4.4.1。在Spring环境中设置JPA的三个选项</a>
<ul class="sectlevel4">
<li><a href="#orm-jpa-setup-lemfb">使用<code>LocalEntityManagerFactoryBean</code></a></li>
<li><a href="#orm-jpa-setup-jndi">从JNDI获取EntityManagerFactory</a></li>
<li><a href="#orm-jpa-setup-lcemfb">使用<code>LocalContainerEntityManagerFactoryBean</code></a></li>
<li><a href="#orm-jpa-setup-multiple">处理多个持久性单元</a></li>
<li><a href="#orm-jpa-setup-background">后台引导</a></li>
</ul>
</li>
<li><a href="#orm-jpa-dao">4.4.2。基于JPA实施DAO： <code>EntityManagerFactory</code>和<code>EntityManager</code></a></li>
<li><a href="#orm-jpa-tx">4.4.3。春季驱动的JPA交易</a></li>
<li><a href="#orm-jpa-dialect">4.4.4。理解<code>JpaDialect</code>和<code>JpaVendorAdapter</code></a></li>
<li><a href="#orm-jpa-jta">4.4.5。使用JTA事务管理设置JPA</a></li>
<li><a href="#orm-jpa-hibernate">4.4.6。JPA交互的本机Hibernate设置和本机Hibernate事务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oxm">5，使用对象XML映射器编组XML</a>
<ul class="sectlevel2">
<li><a href="#oxm-introduction">5.1。介绍</a>
<ul class="sectlevel3">
<li><a href="#oxm-ease-of-configuration">5.1.1。易于配置</a></li>
<li><a href="#oxm-consistent-interfaces">5.1.2。一致的接口</a></li>
<li><a href="#oxm-consistent-exception-hierarchy">5.1.3。一致的异常层次结构</a></li>
</ul>
</li>
<li><a href="#oxm-marshaller-unmarshaller">5.2。 <code>Marshaller</code>和<code>Unmarshaller</code></a>
<ul class="sectlevel3">
<li><a href="#oxm-marshaller">5.2.1。理解<code>Marshaller</code></a></li>
<li><a href="#oxm-unmarshaller">5.2.2。理解<code>Unmarshaller</code></a></li>
<li><a href="#oxm-xmlmappingexception">5.2.3。理解<code>XmlMappingException</code></a></li>
</ul>
</li>
<li><a href="#oxm-usage">5.3。使用<code>Marshaller</code>和<code>Unmarshaller</code></a></li>
<li><a href="#oxm-schema-based-config">5.4。XML配置命名空间</a></li>
<li><a href="#oxm-jaxb">5.5。杰克斯</a>
<ul class="sectlevel3">
<li><a href="#oxm-jaxb2">5.5.1。使用<code>Jaxb2Marshaller</code></a>
<ul class="sectlevel4">
<li><a href="#oxm-jaxb2-xsd">XML配置命名空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oxm-jibx">5.6。吉宝</a>
<ul class="sectlevel3">
<li><a href="#oxm-jibx-marshaller">5.6.1。使用<code>JibxMarshaller</code></a>
<ul class="sectlevel4">
<li><a href="#oxm-jibx-xsd">XML配置命名空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oxm-xstream">5.7。XStream的</a>
<ul class="sectlevel3">
<li><a href="#oxm-xstream-marshaller">5.7.1。使用<code>XStreamMarshaller</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix">6。附录</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">6.1。XML模式</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-tx">6.1.1。的<code>tx</code>架构图</a></li>
<li><a href="#xsd-schemas-jdbc">6.1.2。的<code>jdbc</code>架构图</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>参考文档的这一部分涉及数据访问以及数据访问层与业务或服务层之间的交互。</p>
</div>
<div class="paragraph">
<p>详细介绍了Spring全面的事务管理支持，然后全面介绍了Spring框架所集成的各种数据访问框架和技术。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transaction"><a class="anchor" href="#transaction"></a> 1。交易管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>全面的事务支持是使用Spring Framework的最令人信服的原因之一。Spring框架为事务管理提供了一致的抽象，具有以下优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跨不同事务API（例如Java事务API（JTA），JDBC，Hibernate和Java Persistence API（JPA））的一致编程模型。</p>
</li>
<li>
<p>支持<a href="#transaction-declarative">声明式事务管理</a> 。</p>
</li>
<li>
<p>与诸如JTA之类的复杂事务API相比，用于<a href="#transaction-programmatic">程序化</a>事务管理的API更简单。</p>
</li>
<li>
<p>与Spring的数据访问抽象的出色集成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下各节描述了Spring Framework的事务功能和技术：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#transaction-motivation">Spring Framework的事务支持模型的优点</a>描述了为什么您将使用Spring Framework的事务抽象而不是EJB容器管理的事务（CMT）或选择通过诸如Hibernate之类的专有API驱动本地事务的原因。</p>
</li>
<li>
<p><a href="#transaction-strategies">了解Spring Framework事务抽象</a>概述了核心类并描述了如何配置和获取<code>DataSource</code>来自各种来源的实例。</p>
</li>
<li>
<p><a href="#tx-resource-synchronization">将资源与事务同步</a>描述了应用程序代码如何确保正确创建，重用和清理资源。</p>
</li>
<li>
<p><a href="#transaction-declarative">声明式事务管理</a>描述了对声明式事务管理的支持。</p>
</li>
<li>
<p><a href="#transaction-programmatic">程序化事务管理</a>涵盖对程序化（即，显式编码）事务管理的支持。</p>
</li>
<li>
<p><a href="#transaction-event">事务绑定事件</a>描述了如何在事务中使用应用程序事件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章还讨论了最佳实践， <a href="#transaction-application-server-integration">应用程序服务器集成</a>以及<a href="#transaction-solutions-to-common-problems">常见问题的解决方案</a> 。</p>
</div>
<div class="sect2">
<h3 id="transaction-motivation"><a class="anchor" href="#transaction-motivation"></a> 1.1。Spring框架的事务支持模型的优点</h3>
<div class="paragraph">
<p>传统上，Java EE开发人员在事务管理中有两种选择：全局或本地事务，这两者都有很大的局限性。下两节将回顾全局和本地事务管理，然后讨论Spring框架的事务管理支持如何解决全局和本地事务模型的局限性。</p>
</div>
<div class="sect3">
<h4 id="transaction-global"><a class="anchor" href="#transaction-global"></a> 1.1.1。全球交易</h4>
<div class="paragraph">
<p>全局事务使您可以使用多个事务资源，通常是关系数据库和消息队列。应用服务器通过JTA管理全局事务，该JTA是一个繁琐的API（部分是由于其异常模型）。此外，JTA <code>UserTransaction</code>通常需要从JNDI中获取资源，这意味着您还需要使用JNDI才能使用JTA。全局事务的使用限制了应用程序代码的任何潜在重用，因为JTA通常仅在应用程序服务器环境中可用。</p>
</div>
<div class="paragraph">
<p>以前，使用全局事务的首选方法是通过EJB CMT（容器管理的事务）。CMT是声明式事务管理的一种形式（与程序性事务管理不同）。尽管使用EJB本身必须使用JNDI，但是EJB CMT消除了与事务相关的JNDI查找的需要。它消除了大多数（但不是全部）编写Java代码来控制事务的需求。重大缺点是CMT与JTA和应用程序服务器环境相关联。而且，仅当选择在EJB中（或至少在事务性EJB幕后之后）实现业务逻辑时，此功能才可用。通常，EJB的负面影响是如此之大，以至于这不是一个有吸引力的主张，尤其是面对声明式事务管理的强制选择时。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-local"><a class="anchor" href="#transaction-local"></a> 1.1.2。本地交易</h4>
<div class="paragraph">
<p>本地事务是特定于资源的，例如与JDBC连接关联的事务。本地事务可能更易于使用，但有一个明显的缺点：它们不能跨多个事务资源工作。例如，使用JDBC连接管理事务的代码不能在全局JTA事务中运行。由于应用程序服务器不参与事务管理，因此它无法帮助确保多个资源之间的正确性。（值得注意的是，大多数应用程序使用单个事务资源。）另一个缺点是本地事务对编程模型具有侵入性。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-programming-model"><a class="anchor" href="#transaction-programming-model"></a> 1.1.3。Spring框架的一致编程模型</h4>
<div class="paragraph">
<p>Spring解决了全球和本地交易的弊端。它使应用程序开发人员可以在任何环境中使用一致的编程模型。您只需编写一次代码，即可在不同环境中受益于不同的事务管理策略。Spring框架提供了声明式和程序化事务管理。大多数用户喜欢声明式事务管理，在大多数情况下我们建议这样做。</p>
</div>
<div class="paragraph">
<p>使用程序化事务管理，开发人员可以使用Spring Framework事务抽象，该抽象可以在任何基础事务基础架构上运行。使用首选的声明性模型，开发人员通常只需编写很少或没有编写与事务管理相关的代码，因此不依赖于Spring Framework事务API或任何其他事务API。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">您需要用于事务管理的应用程序服务器吗？</div>
<div class="paragraph">
<p>Spring Framework的事务管理支持更改了有关企业Java应用程序何时需要应用程序服务器的传统规则。</p>
</div>
<div class="paragraph">
<p>特别是，您不需要纯粹用于通过EJB进行声明式事务的应用程序服务器。实际上，即使您的应用服务器具有强大的JTA功能，您也可以决定Spring框架的声明式事务比EJB CMT提供更多的功能和更高效的编程模型。</p>
</div>
<div class="paragraph">
<p>通常，仅当您的应用程序需要处理跨多个资源的事务时才需要应用程序服务器的JTA功能，而这并不是许多应用程序所必需的。许多高端应用程序都使用单个高度可扩展的数据库（例如Oracle RAC）。独立事务管理器（例如<a href="https://www.atomikos.com/">Atomikos Transactions</a>和<a href="http://jotm.objectweb.org/">JOTM</a> ）是其他选择。当然，您可能需要其他应用程序服务器功能，例如Java消息服务（JMS）和Java EE连接器体系结构（JCA）。</p>
</div>
<div class="paragraph">
<p>Spring Framework使您可以选择何时将应用程序扩展到完全加载的应用程序服务器。不再使用EJB CMT或JTA的唯一选择是使用本地事务（例如JDBC连接上的事务）编写代码，并且如果您需要该代码在全局的，容器管理的事务中运行，则面临大量的返工。使用Spring Framework，仅需要更改配置文件中的某些Bean定义（而不是代码）。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-strategies"><a class="anchor" href="#transaction-strategies"></a> 1.2。了解Spring框架事务抽象</h3>
<div class="paragraph">
<p>Spring事务抽象的关键是事务策略的概念。交易策略由<code>org.springframework.transaction.PlatformTransactionManager</code>界面，如下清单所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface PlatformTransactionManager {

    @Throws(TransactionException::class)
    fun getTransaction(definition: TransactionDefinition): TransactionStatus

    @Throws(TransactionException::class)
    fun commit(status: TransactionStatus)

    @Throws(TransactionException::class)
    fun rollback(status: TransactionStatus)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管您可以从应用程序代码中以<a href="#transaction-programmatic-ptm">编程</a>方式使用它，但它主要是一个服务提供商接口（SPI）。因为<code>PlatformTransactionManager</code>是一个接口，可以根据需要轻松对其进行嘲笑或存根。它与诸如JNDI之类的查找策略无关。 <code>PlatformTransactionManager</code>实现的定义与Spring Framework IoC容器中的任何其他对象（或bean）一样。单独使用此好处，即使使用JTA，Spring框架事务也成为有价值的抽象。与直接使用JTA相比，您可以更轻松地测试事务代码。</p>
</div>
<div class="paragraph">
<p>同样，根据Spring的哲学， <code>TransactionException</code>可以被任何<code>PlatformTransactionManager</code>接口的方法未选中（也就是说，它扩展了<code>java.lang.RuntimeException</code>类）。事务基础架构故障几乎总是致命的。在极少数情况下，应用程序代码实际上可以从事务失败中恢复，应用程序开发人员仍然可以选择捕获并处理<code>TransactionException</code> 。突出的一点是，开发人员没有<em>被迫</em>这样做。</p>
</div>
<div class="paragraph">
<p>的<code>getTransaction(..)</code>方法返回一个<code>TransactionStatus</code>对象，取决于<code>TransactionDefinition</code>参数。返回的<code>TransactionStatus</code>如果当前调用堆栈中存在匹配的事务，则可能代表一个新事务或可能代表一个现有事务。后一种情况的含义是，与Java EE事务上下文一样， <code>TransactionStatus</code>与执行线程相关联。</p>
</div>
<div class="paragraph">
<p>的<code>TransactionDefinition</code>接口指定：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>传播：通常，在事务范围内执行的所有代码都在该事务中运行。但是，如果在已存在事务上下文的情况下执行事务方法，则可以指定行为。例如，代码可以在现有事务中继续运行（常见情况），或者可以暂停现有事务并创建新事务。Spring提供了EJB CMT熟悉的所有事务传播选项。要了解有关Spring中事务传播的语义的信息，请参阅<a href="#tx-propagation">事务传播</a> 。</p>
</li>
<li>
<p>隔离度：此事务与其他事务的工作隔离的程度。例如，此事务能否看到其他事务未提交的写入？</p>
</li>
<li>
<p>超时：超时之前该事务运行了多长时间，并被基础事务基础结构自动回滚。</p>
</li>
<li>
<p>只读状态：当代码读取但不修改数据时，可以使用只读事务。在某些情况下，例如使用Hibernate时，只读事务可能是有用的优化。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些设置反映了标准的交易概念。如有必要，请参考讨论事务隔离级别和其他核心事务概念的资源。了解这些概念对于使用Spring Framework或任何事务管理解决方案至关重要。</p>
</div>
<div class="paragraph">
<p>的<code>TransactionStatus</code>界面为事务代码提供了一种控制事务执行和查询事务状态的简单方法。这些概念应该很熟悉，因为它们对于所有事务API都是通用的。以下清单显示了<code>TransactionStatus</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface TransactionStatus extends SavepointManager {

    boolean isNewTransaction();

    boolean hasSavepoint();

    void setRollbackOnly();

    boolean isRollbackOnly();

    void flush();

    boolean isCompleted();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface TransactionStatus : SavepointManager {

    fun isNewTransaction(): Boolean

    fun hasSavepoint(): Boolean

    fun setRollbackOnly()

    fun isRollbackOnly(): Boolean

    fun flush()

    fun isCompleted(): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论您在Spring中选择声明式还是程序化事务管理，都必须定义正确的<code>PlatformTransactionManager</code>实施是绝对必要的。通常，您可以通过依赖注入来定义此实现。</p>
</div>
<div class="paragraph">
<p><code>PlatformTransactionManager</code>实现通常需要了解其工作环境：JDBC，JTA，Hibernate等。以下示例显示了如何定义本地<code>PlatformTransactionManager</code>实现（在这种情况下，使用纯JDBC。）</p>
</div>
<div class="paragraph">
<p>您可以定义一个JDBC <code>DataSource</code>通过创建类似于以下内容的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}" /&gt;
    &lt;property name="url" value="${jdbc.url}" /&gt;
    &lt;property name="username" value="${jdbc.username}" /&gt;
    &lt;property name="password" value="${jdbc.password}" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>相关的<code>PlatformTransactionManager</code>然后，bean定义引用了<code>DataSource</code>定义。它应类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在Java EE容器中使用JTA，则使用容器<code>DataSource</code> ，是通过JNDI与Spring的<code>JtaTransactionManager</code> 。以下示例显示了JTA和JNDI查找版本的外观：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        https://www.springframework.org/schema/jee/spring-jee.xsd"&gt;

    &lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/&gt;

    &lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" /&gt;

    &lt;!-- other &lt;bean/&gt; definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>JtaTransactionManager</code>不需要了解<code>DataSource</code> （或任何其他特定资源），因为它使用了容器的全局事务管理基础结构。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的定义<code>dataSource</code>豆使用<code><jndi-lookup/></code>来自的标签<code>jee</code>命名空间。有关更多信息，请参见<a href="integration.html#xsd-schemas-jee">JEE Schema</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以轻松使用Hibernate本地事务，如以下示例所示。在这种情况下，您需要定义一个休眠模式<code>LocalSessionFactoryBean</code> ，您的应用程序代码可用于获取Hibernate <code>Session</code>实例。</p>
</div>
<div class="paragraph">
<p>的<code>DataSource</code> bean定义与前面显示的本地JDBC示例相似，因此在以下示例中未显示。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果<code>DataSource</code> （由任何非JTA事务管理器使用）（由任何非JTA事务管理器使用）通过JNDI查找并由Java EE容器进行管理，它应该是非事务性的，因为Spring框架（而不是Java EE容器）管理事务。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>txManager</code>在这种情况下，bean是<code>HibernateTransactionManager</code>类型。以与<code>DataSourceTransactionManager</code>需要参考<code>DataSource</code> ， <code>HibernateTransactionManager</code>需要参考<code>SessionFactory</code> 。以下示例声明<code>sessionFactory</code>和<code>txManager</code>豆子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="mappingResources"&gt;
        &lt;list&gt;
            &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
        &lt;value&gt;
            hibernate.dialect=${hibernate.dialect}
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用Hibernate和Java EE容器管理的JTA事务，则应使用相同的方法<code>JtaTransactionManager</code>如前面的JDBC JTA示例所示，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果使用JTA，则无论使用哪种数据访问技术（无论是JDBC，Hibernate JPA或任何其他受支持的技术），事务管理器定义都应该看起来相同。这是由于JTA事务是全局事务，它可以征用任何事务资源。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在所有这些情况下，无需更改应用程序代码。您可以仅通过更改配置来更改事务的管理方式，即使更改意味着从本地事务转移到全局事务，反之亦然。</p>
</div>
</div>
<div class="sect2">
<h3 id="tx-resource-synchronization"><a class="anchor" href="#tx-resource-synchronization"></a> 1.3。将资源与事务同步</h3>
<div class="paragraph">
<p>如何创建不同的事务管理器，以及如何将它们链接到需要与事务同步的相关资源（例如， <code>DataSourceTransactionManager</code>到JDBC <code>DataSource</code> ， <code>HibernateTransactionManager</code>进入冬眠<code>SessionFactory</code> ，依此类推）现在应该清楚了。本节描述应用程序代码如何（通过使用诸如JDBC，Hibernate或JPA之类的持久性API直接或间接）确保正确创建，重用和清理这些资源。本节还讨论了如何通过相关的（可选）触发事务同步<code>PlatformTransactionManager</code> 。</p>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-high"><a class="anchor" href="#tx-resource-synchronization-high"></a> 1.3.1。高级同步方法</h4>
<div class="paragraph">
<p>首选方法是使用Spring基于最高级别模板的持久性集成API或将本机ORM API与具有事务感知功能的工厂bean或代理一起使用，以管理本机资源工厂。这些支持事务的解决方案在内部处理资源的创建和重用，清理，资源的可选事务同步以及异常映射。因此，用户数据访问代码不必解决这些任务，而可以完全专注于非样板持久性逻辑。通常，您可以使用本机ORM API或采用模板方法来访问JDBC，方法是使用<code>JdbcTemplate</code> 。这些解决方案将在本参考文档的后续章节中详细介绍。</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-low"><a class="anchor" href="#tx-resource-synchronization-low"></a> 1.3.2。低级同步方法</h4>
<div class="paragraph">
<p>诸如此类<code>DataSourceUtils</code> （对于JDBC）， <code>EntityManagerFactoryUtils</code> （对于JPA）， <code>SessionFactoryUtils</code> （对于Hibernate），以此类推。当您希望应用程序代码直接处理本机持久性API的资源类型时，可以使用这些类来确保获得正确的Spring Framework管理的实例，（可选）同步事务以及处理过程中发生的异常。正确映射到一致的API。</p>
</div>
<div class="paragraph">
<p>例如，对于JDBC，不是使用传统的JDBC方法调用<code>getConnection()</code>上的方法<code>DataSource</code> ，您可以改用Spring的<code>org.springframework.jdbc.datasource.DataSourceUtils</code>类，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Connection conn = DataSourceUtils.getConnection(dataSource);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果现有事务已经有一个同步（链接）的连接，则返回该实例。否则，方法调用将触发新连接的创建，该连接（可选）同步到任何现有事务，并可供该同一事务中的后续重用使用。如前所述，任何<code>SQLException</code>包装在Spring框架中<code>CannotGetJdbcConnectionException</code> ，是Spring框架的未检查层次结构之一<code>DataAccessException</code>类型。这种方法为您提供的信息比从中轻松获得的信息要多。 <code>SQLException</code>并确保跨数据库甚至跨不同持久性技术的可移植性。</p>
</div>
<div class="paragraph">
<p>这种方法在没有Spring事务管理的情况下也可以使用（事务同步是可选的），因此无论是否使用Spring进行事务管理，都可以使用它。</p>
</div>
<div class="paragraph">
<p>当然，一旦使用了Spring的JDBC支持，JPA支持或Hibernate支持，通常就不要使用<code>DataSourceUtils</code>或其他帮助程序类，因为与直接使用相关API相比，通过Spring抽象进行工作要快乐得多。例如，如果您使用Spring <code>JdbcTemplate</code>要么<code>jdbc.object</code>软件包以简化JDBC的使用，在后台进行正确的连接检索，您无需编写任何特殊代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="tx-resource-synchronization-tadsp"><a class="anchor" href="#tx-resource-synchronization-tadsp"></a> 1.3.3。<code>TransactionAwareDataSourceProxy</code></h4>
<div class="paragraph">
<p>在最低级别存在<code>TransactionAwareDataSourceProxy</code>类。这是目标的代理<code>DataSource</code> ，它包装了目标<code>DataSource</code>增强对Spring管理的交易的认识。在这方面，它类似于事务性JNDI <code>DataSource</code> ，由Java EE服务器提供。</p>
</div>
<div class="paragraph">
<p>您几乎永远不需要或不想使用此类，除非必须调用现有代码并传递标准JDBC时<code>DataSource</code>接口实现。在这种情况下，该代码可能可用，但参与了Spring管理的事务。您可以使用前面提到的高级抽象来编写新代码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-declarative"><a class="anchor" href="#transaction-declarative"></a> 1.4。声明式交易管理</h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">大多数Spring Framework用户选择声明式事务管理。此选项对应用程序代码的影响最小，因此与无创轻量级容器的理想状态最一致。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring框架的声明式事务管理通过Spring面向切面的编程（AOP）成为可能。但是，由于事务方面的代码随Spring框架发行版一起提供并且可以以样板方式使用，因此通常不必理解AOP概念即可有效地使用此代码。</p>
</div>
<div class="paragraph">
<p>Spring框架的声明式事务管理与EJB CMT相似，因为您可以指定事务行为（或缺少它）到单个方法级别。你可以做一个<code>setRollbackOnly()</code>如有必要，在事务上下文中调用。两种类型的事务管理之间的区别是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与绑定到JTA的EJB CMT不同，Spring框架的声明式事务管理可在任何环境中工作。通过调整配置文件，它可以使用JDBC，JPA或Hibernate来处理JTA事务或本地事务。</p>
</li>
<li>
<p>您可以将Spring Framework声明式事务管理应用于任何类，而不仅限于诸如EJB之类的特殊类。</p>
</li>
<li>
<p>Spring框架提供了声明性<a href="#transaction-declarative-rolling-back">回滚规则</a> ，这是没有EJB等效项的功能。提供了对回滚规则的编程和声明性支持。</p>
</li>
<li>
<p>Spring Framework允许您使用AOP自定义事务行为。例如，在事务回滚的情况下，您可以插入自定义行为。您还可以添加任意建议以及事务建议。使用EJB CMT，您不能影响容器的事务管理，除非使用<code>setRollbackOnly()</code> 。</p>
</li>
<li>
<p>Spring框架不像高端应用程序服务器那样支持跨远程调用传播事务上下文。如果需要此功能，建议您使用EJB。但是，在使用这种功能之前，请仔细考虑，因为通常情况下，您不希望事务跨越远程调用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>回滚规则的概念很重要。它们让您指定哪些异常（和可抛出对象）应引起自动回滚。您可以在配置中而不是在Java代码中以声明方式指定。因此，尽管您仍然可以打电话<code>setRollbackOnly()</code>在<code>TransactionStatus</code>对象以回滚当前事务，通常您可以指定一个规则<code>MyApplicationException</code>必须始终导致回滚。此选项的主要优点是业务对象不依赖于事务基础结构。例如，他们通常不需要导入Spring事务API或其他Spring API。</p>
</div>
<div class="paragraph">
<p>尽管EJB容器的默认行为会在系统异常（通常是运行时异常）时自动回滚事务，但是EJB CMT不会在应用程序异常（即检查到的异常除外）自动回滚事务。 <code>java.rmi.RemoteException</code> ）。尽管Spring声明式事务管理的默认行为遵循EJB约定（仅针对未检查的异常会自动回滚），但自定义此行为通常很有用。</p>
</div>
<div class="sect3">
<h4 id="tx-decl-explained"><a class="anchor" href="#tx-decl-explained"></a> 1.4.1。了解Spring框架的声明式事务实现</h4>
<div class="paragraph">
<p>仅告诉您用注释您的班级是不够的<code>@Transactional</code>注释，添加<code>@EnableTransactionManagement</code>您的配置，并希望您了解其工作原理。为了提供更深入的理解，本节介绍了在发生与事务相关的问题时，Spring框架的声明式事务基础结构的内部工作方式。</p>
</div>
<div class="paragraph">
<p>关于Spring框架的声明式事务支持，要把握的最重要的概念是<a href="core.html#aop-understanding-aop-proxies">通过AOP代理</a>启用此支持，并且事务建议由元数据（当前基于XML或基于注释）驱动。AOP与事务性元数据的组合产生了一个AOP代理，该代理使用<code>TransactionInterceptor</code>与适当的结合<code>PlatformTransactionManager</code>实现以驱动围绕方法调用的事务。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring AOP在<a href="core.html#aop">AOP部分中介绍</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下图显示了在事务代理上调用方法的概念视图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tx.png" alt="发射">
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-first-example"><a class="anchor" href="#transaction-declarative-first-example"></a> 1.4.2。声明式事务实现示例</h4>
<div class="paragraph">
<p>考虑以下接口及其附带的实现。这个例子使用<code>Foo</code>和<code>Bar</code>类作为占位符，这样您就可以专注于事务使用而不关注特定的域模型。就本示例而言， <code>DefaultFooService</code>课堂抛出<code>UnsupportedOperationException</code>每个实现的方法实例中的实例都是好的。该行为使您可以看到已创建事务，然后回滚以响应<code>UnsupportedOperationException</code>实例。以下清单显示了<code>FooService</code>接口：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// the service interface that we want to make transactional

package x.y.service;

public interface FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// the service interface that we want to make transactional

package x.y.service

interface FooService {

    fun getFoo(fooName: String): Foo

    fun getFoo(fooName: String, barName: String): Foo

    fun insertFoo(foo: Foo)

    fun updateFoo(foo: Foo)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了上述接口的实现：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package x.y.service;

public class DefaultFooService implements FooService {

    @Override
    public Foo getFoo(String fooName) {
        // ...
    }

    @Override
    public Foo getFoo(String fooName, String barName) {
        // ...
    }

    @Override
    public void insertFoo(Foo foo) {
        // ...
    }

    @Override
    public void updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">package x.y.service

class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Foo {
        // ...
    }

    override fun getFoo(fooName: String, barName: String): Foo {
        // ...
    }

    override fun insertFoo(foo: Foo) {
        // ...
    }

    override fun updateFoo(foo: Foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设前两种方法<code>FooService</code>接口， <code>getFoo(String)</code>和<code>getFoo(String, String)</code> ，必须在具有只读语义的事务上下文中执行，并且其他方法， <code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code> ，必须在具有读写语义的事务上下文中执行。以下几节将详细说明以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- from the file 'context.xml' --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- this is the service object that we want to make transactional --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/&gt; bean below) --&gt;
    &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
        &lt;!-- the transactional semantics... --&gt;
        &lt;tx:attributes&gt;
            &lt;!-- all methods starting with 'get' are read-only --&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;!-- other methods use the default transaction settings (see below) --&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- ensure that the above transactional advice runs for any execution
        of an operation defined by the FooService interface --&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt;
        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt;
    &lt;/aop:config&gt;

    &lt;!-- don't forget the DataSource --&gt;
    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
        &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
        &lt;property name="username" value="scott"/&gt;
        &lt;property name="password" value="tiger"/&gt;
    &lt;/bean&gt;

    &lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;
    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- other &lt;bean/&gt; definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查前面的配置。它假定您要创建服务对象， <code>fooService</code>豆，事务性的。要应用的事务语义封装在<code><tx:advice/></code>定义。的<code><tx:advice/></code>定义读为“所有方法，从<code>get</code> ，将在只读事务的上下文中执行，而所有其他方法将以默认事务语义执行。的<code>transaction-manager</code>的属性<code><tx:advice/></code>标签设置为<code>PlatformTransactionManager</code>将驱动交易的Bean（在这种情况下， <code>txManager</code>豆）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以省略<code>transaction-manager</code>交易建议中的属性（ <code><tx:advice/></code> ）如果是<code>PlatformTransactionManager</code>您要连接的名称<code>transactionManager</code> 。如果<code>PlatformTransactionManager</code>您要连接的Bean有任何其他名称，您必须使用<code>transaction-manager</code>如前面的示例中所示，显式指定属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code><aop:config/></code>定义可确保由<code>txAdvice</code> bean在程序中的适当位置执行。首先，您定义一个切入点，该切入点与执行<code>FooService</code>介面（ <code>fooServiceOperation</code> ）。然后将切入点与<code>txAdvice</code>通过使用顾问。结果表明，在执行<code>fooServiceOperation</code> ，由<code>txAdvice</code>运行。</p>
</div>
<div class="paragraph">
<p>内定义的表达式<code><aop:pointcut/></code> element是一个AspectJ切入点表达式。有关Spring中切入点表达式的更多详细信息，请参见<a href="core.html#aop">AOP部分</a> 。</p>
</div>
<div class="paragraph">
<p>一个普遍的要求是使整个服务层具有事务性。最好的方法是更改切入点表达式以匹配服务层中的任何操作。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;aop:config&gt;
    &lt;aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在前面的示例中，假设您的所有服务接口都在<code>x.y.service</code>包。有关更多详细信息，请参见<a href="core.html#aop">AOP部分</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在我们已经分析了配置，您可能会问自己：“所有这些配置实际上是做什么的？”</p>
</div>
<div class="paragraph">
<p>前面显示的配置用于围绕从对象创建的对象创建事务代理。 <code>fooService</code> Bean定义。代理配置有事务建议，以便在代理上调用适当的方法时，根据与该方法相关联的事务配置，事务将被启动，挂起，标记为只读等。考虑下面的程序，该程序测试驱动前面显示的配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
        FooService fooService = (FooService) ctx.getBean("fooService");
        fooService.insertFoo (new Foo());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = ClassPathXmlApplicationContext("context.xml")
    val fooService = ctx.getBean&lt;FooService&gt;("fooService")
    fooService.insertFoo(Foo())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行前面程序的输出应类似于以下内容（为清晰起见，Log4J输出和由DefaultFooService类的insertFoo（..）方法抛出的UnsupportedOperationException的堆栈跟踪已被截断）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- the Spring container is starting up... --&gt;
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean 'fooService' with 0 common interceptors and 1 specific interceptors

&lt;!-- the DefaultFooService is actually proxied --&gt;
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;
[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo

&lt;!-- the transactional advice kicks in here... --&gt;
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]

&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread "main" java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;
at $Proxy0.insertFoo(Unknown Source)
at Boot.main(Boot.java:11)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-rolling-back"><a class="anchor" href="#transaction-declarative-rolling-back"></a> 1.4.3。回滚声明式事务</h4>
<div class="paragraph">
<p>上一节概述了如何在应用程序中声明性地指定类（通常是服务层类）的事务性设置的基础。本节介绍如何以简单的声明方式控制事务的回滚。</p>
</div>
<div class="paragraph">
<p>向Spring框架的事务基础结构指示要回滚事务的建议方法是抛出一个<code>Exception</code>来自当前在事务上下文中执行的代码。Spring框架的事务基础结构代码捕获任何未处理的<code>Exception</code>因为它使调用栈冒泡，并确定是否将事务标记为回滚。</p>
</div>
<div class="paragraph">
<p>在其默认配置中，Spring Framework的事务基础结构代码仅在运行时未经检查的异常情况下将事务标记为回滚。也就是说，当抛出的异常是的实例或子类时<code>RuntimeException</code> 。（ <code>Error</code>默认情况下，实例也会导致回滚）。从事务方法引发的检查异常不会导致默认配置中的回滚。</p>
</div>
<div class="paragraph">
<p>您可以准确配置<code>Exception</code>类型将事务标记为回滚，包括已检查的异常。以下XML代码段演示了如何为已检查的，特定于应用程序的配置回滚<code>Exception</code>类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
    &lt;tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/&gt;
    &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不希望在引发异常时回滚事务，则还可以指定“无回滚规则”。下面的示例告诉Spring框架的事务基础结构即使在未处理的情况下也要提交伴随的事务<code>InstrumentNotFoundException</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
    &lt;tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/&gt;
    &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当Spring Framework的事务基础结构捕获到异常并咨询已配置的回滚规则以确定是否将事务标记为回滚时，最强的匹配规则获胜。因此，在以下配置的情况下，除<code>InstrumentNotFoundException</code>导致附带事务的回滚：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
    &lt;tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过编程方式指示所需的回滚。尽管很简单，但此过程具有很大的侵入性，并将您的代码紧密耦合到Spring Framework的事务基础结构。下面的示例演示如何以编程方式指示所需的回滚：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void resolvePosition() {
    try {
        // some business logic...
    } catch (NoProductInStockException ex) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun resolvePosition() {
    try {
        // some business logic...
    } catch (ex: NoProductInStockException) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>强烈建议您尽可能使用声明性方法进行回滚。如果您绝对需要它，则可以使用程序化回滚，但是面对实现基于POJO的干净体系结构时，它的用法就不那么理想了。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-diff-tx"><a class="anchor" href="#transaction-declarative-diff-tx"></a> 1.4.4。为不同的Bean配置不同的事务语义</h4>
<div class="paragraph">
<p>考虑以下场景：您有多个服务层对象，并且您希望对每个对象应用完全不同的事务配置。您可以通过定义不同<code><aop:advisor/></code>具有不同元素<code>pointcut</code>和<code>advice-ref</code>属性值。</p>
</div>
<div class="paragraph">
<p>作为比较点，首先假定所有服务层类都在根目录中定义<code>x.y.service</code>包。使所有在该程序包（或子程序包）中定义的类实例成为实例且名称以<code>Service</code>具有默认的事务配置，您可以编写以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;aop:config&gt;

        &lt;aop:pointcut id="serviceOperation"
                expression="execution(* x.y.service..*Service.*(..))"/&gt;

        &lt;aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/&gt;

    &lt;/aop:config&gt;

    &lt;!-- these two beans will be transactional... --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;
    &lt;bean id="barService" class="x.y.service.extras.SimpleBarService"/&gt;

    &lt;!-- ... and these two beans won't --&gt;
    &lt;bean id="anotherService" class="org.xyz.SomeService"/&gt; &lt;!-- (not in the right package) --&gt;
    &lt;bean id="barManager" class="x.y.service.SimpleBarManager"/&gt; &lt;!-- (doesn't end in 'Service') --&gt;

    &lt;tx:advice id="txAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例说明如何使用完全不同的事务设置配置两个不同的Bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;aop:config&gt;

        &lt;aop:pointcut id="defaultServiceOperation"
                expression="execution(* x.y.service.*Service.*(..))"/&gt;

        &lt;aop:pointcut id="noTxServiceOperation"
                expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/&gt;

        &lt;aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/&gt;

        &lt;aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/&gt;

    &lt;/aop:config&gt;

    &lt;!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;
    &lt;bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/&gt;

    &lt;tx:advice id="defaultTxAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;tx:advice id="noTxAdvice"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="*" propagation="NEVER"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-txadvice-settings"><a class="anchor" href="#transaction-declarative-txadvice-settings"></a> 1.4.5。 <tx:advice></tx:advice> 设定值</h4>
<div class="paragraph">
<p>本节总结了您可以通过使用<code><tx:advice/></code>标签。默认值<code><tx:advice/></code>设置是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#tx-propagation">传播设置</a>为<code>REQUIRED.</code></p>
</li>
<li>
<p>隔离级别为<code>DEFAULT.</code></p>
</li>
<li>
<p>事务是读写的。</p>
</li>
<li>
<p>事务超时默认为基础事务系统的默认超时，如果不支持超时，则默认为无。</p>
</li>
<li>
<p>任何<code>RuntimeException</code>触发回滚，并检查所有<code>Exception</code>才不是。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以更改这些默认设置。下表总结了<code><tx:method/></code>嵌套在其中的标签<code><tx:advice/></code>和<code><tx:attributes/></code>标签：</p>
</div>
<table id="tx-method-settings" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。 <tx:method></tx:method>设定</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">需要？</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与事务属性关联的方法名称。通配符（*）可用于将相同的交易属性设置与多种方法相关联（例如， <code>get*</code> ， <code>handle*</code> ， <code>on*Event</code> ，依此类推）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REQUIRED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务传播行为。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务隔离级别。仅适用于<code>REQUIRED</code>要么<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务超时（秒）。仅适用于传播<code>REQUIRED</code>要么<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>read-only</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读写与只读事务。仅适用于<code>REQUIRED</code>要么<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollback-for</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的逗号分隔列表<code>Exception</code>触发回滚的实例。例如，<code>com.foo.MyBusinessException,ServletException.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>no-rollback-for</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的逗号分隔列表<code>Exception</code>实例不会触发回滚。例如，<code>com.foo.MyBusinessException,ServletException.</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="transaction-declarative-annotations"><a class="anchor" href="#transaction-declarative-annotations"></a> 1.4.6。使用<code>@Transactional</code></h4>
<div class="paragraph">
<p>除了基于XML的声明式方法进行事务配置外，还可以使用基于注释的方法。直接在Java源代码中声明事务语义会使声明更接近受影响的代码。不存在过多耦合的危险，因为原本打算以事务方式使用的代码几乎总是以这种方式部署。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">标准<code>javax.transaction.Transactional</code>还支持使用注解代替Spring自己的注解。请参阅JTA 1.2文档以获取更多详细信息。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过使用<code>@Transactional</code>注释最好通过一个示例来说明，随后的文字对此进行了说明。考虑以下类定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// the service class that we want to make transactional
@Transactional
public class DefaultFooService implements FooService {

    Foo getFoo(String fooName) {
        // ...
    }

    Foo getFoo(String fooName, String barName) {
        // ...
    }

    void insertFoo(Foo foo) {
        // ...
    }

    void updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// the service class that we want to make transactional
@Transactional
class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Foo {
        // ...
    }

    override fun getFoo(fooName: String, barName: String): Foo {
        // ...
    }

    override fun insertFoo(foo: Foo) {
        // ...
    }

    override fun updateFoo(foo: Foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的类级别使用，注释表示声明类（及其子类）的所有方法的默认值。另外，每种方法都可以单独注释。注意，类级别的注释不适用于类层次结构中的祖先类。在这种情况下，需要在本地重新声明方法，以参与子类级别的注释。</p>
</div>
<div class="paragraph">
<p>当一个POJO类（例如上面的一个）在Spring上下文中定义为bean时，您可以通过<code>@EnableTransactionManagement</code>一个中的注释<code>@Configuration</code>类。有关完整详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html">javadoc</a> 。</p>
</div>
<div class="paragraph">
<p>在XML配置中， <code><tx:annotation-driven/></code>标签提供了类似的便利：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- from the file 'context.xml' --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- this is the service object that we want to make transactional --&gt;
    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;
    &lt;tx:annotation-driven transaction-manager="txManager"/&gt;&lt;!-- a PlatformTransactionManager is still required --&gt; <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;!-- (this dependency is defined somewhere else) --&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- other &lt;bean/&gt; definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使bean实例具有事务性的行。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以省略<code>transaction-manager</code>中的属性<code><tx:annotation-driven/></code>标记是否为<code>PlatformTransactionManager</code>您想要连接的名称， <code>transactionManager</code> 。如果<code>PlatformTransactionManager</code>您要依赖注入的bean有任何其他名称，您必须使用<code>transaction-manager</code>属性，如上例所示。
</td>
</tr>
</tbody></table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">方法可见性和<code>@Transactional</code></div>
<div class="paragraph">
<p>使用代理时，您应该应用<code>@Transactional</code>仅对具有公共可见性的方法进行注释。如果您确实使用注释了受保护的，私有的或程序包可见的方法<code>@Transactional</code>注释，不会引发任何错误，但是带注释的方法不会显示已配置的事务设置。如果需要注释非公共方法，请考虑使用AspectJ（稍后描述）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以应用<code>@Transactional</code>接口定义的注释，接口上的方法，类定义或类上的公共方法。但是， <code>@Transactional</code>注释不足以激活交易行为。的<code>@Transactional</code>注释仅仅是元数据，某些运行时基础架构可以使用该元数据<code>@Transactional</code> -Aware，并且可以使用元数据配置具有事务行为的适当Bean。在前面的示例中， <code><tx:annotation-driven/></code>元素打开事务行为。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring小组建议您仅使用<code>@Transactional</code>注释，而不是注释接口。您当然可以将<code>@Transactional</code>接口（或接口方法）上的注释，但是仅在使用基于接口的代理时，此注释才起作用。Java批注不是从接口继承的事实意味着，如果您使用基于类的代理（ <code>proxy-target-class="true"</code> ）或基于编织的方面（ <code>mode="aspectj"</code> ），则代理和编织基础架构无法识别交易设置，并且该对象也不会包装在交易代理中。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在代理模式（默认）下，仅拦截通过代理传入的外部方法调用。这意味着自调用（实际上是目标对象中的方法调用目标对象的另一个方法）在运行时不会导致实际的事务，即使被调用的方法标记为<code>@Transactional</code> 。另外，必须对代理进行完全初始化以提供预期的行为，因此您不应在初始化代码中依赖此功能（即， <code>@PostConstruct</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑使用AspectJ模式（请参阅<code>mode</code>下表中的[属性]。在这种情况下，首先没有代理。相反，将目标类进行编织（即，修改其字节码）以将<code>@Transactional</code>进入任何一种方法的运行时行为。</p>
</div>
<table id="tx-annotation-driven-settings" class="tableblock frame-all grid-all spread">
<caption class="title">表2。注释驱动的事务设置</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">XML属性</th>
<th class="tableblock halign-left valign-top">注释属性</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用（请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html"><code>TransactionManagementConfigurer</code></a> javadoc）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transactionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的事务管理器的名称。仅当事务管理器的名称不是时才需要<code>transactionManager</code> ，如上例所示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认模式（ <code>proxy</code> ）通过使用Spring的AOP框架来处理要注释的bean（遵循代理语义，如前所述，仅适用于通过代理传入的方法调用）。替代模式（ <code>aspectj</code> ）而是将受影响的类与Spring的AspectJ事务方面进行编织，修改目标类的字节码以应用于任何类型的方法调用。AspectJ编织要求<code>spring-aspects.jar</code>在类路径中，以及启用了加载时编织（或编译时编织）。（有关如何设置加载时编织的详细信息，请参见<a href="core.html#aop-aj-ltw-spring">Spring配置</a> 。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy-target-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxyTargetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">适用于<code>proxy</code>仅模式。控制为使用注释的类创建哪种类型的事务代理。 <code>@Transactional</code>注解。如果<code>proxy-target-class</code>属性设置为<code>true</code> ，将创建基于类的代理。如果<code>proxy-target-class</code>是<code>false</code>或者，如果省略了该属性，则将创建基于标准JDK接口的代理。（有关不同代理类型的详细检查，请参见<a href="core.html#aop-proxying">代理机制</a> 。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义应用于带注释的Bean的交易通知的顺序<code>@Transactional</code> 。（有关与AOP通知的订购有关的规则的更多信息，请参阅<a href="core.html#aop-ataspectj-advice-ordering">通知订购</a> 。）没有指定的顺序意味着AOP子系统确定建议的顺序。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">处理的默认建议模式<code>@Transactional</code>注释是<code>proxy</code> ，仅允许通过代理拦截呼叫。同一类内的本地调用无法以这种方式被拦截。要获得更高级的拦截模式，请考虑切换到<code>aspectj</code>模式结合编译时或加载时编织。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>proxy-target-class</code>属性控制为使用注释的类创建哪种类型的事务代理。 <code>@Transactional</code>注解。如果<code>proxy-target-class</code>被设定为<code>true</code> ，将创建基于类的代理。如果<code>proxy-target-class</code>是<code>false</code>或者，如果省略该属性，则创建基于标准JDK接口的代理。（有关不同代理类型的讨论，请参见<a href="#aop-proxying">[aop-proxying]</a> 。）
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@EnableTransactionManagement</code>和<code><tx:annotation-driven/></code>寻找<code>@Transactional</code>仅在定义了它们的相同应用程序上下文中的bean上。这意味着，如果您将注释驱动的配置放在<code>WebApplicationContext</code>为一个<code>DispatcherServlet</code> ，它检查<code>@Transactional</code> bean仅存在于您的控制器中，而不存在于您的服务中。有关更多信息，请参见<a href="web.html#mvc-servlet">MVC</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在评估方法的事务设置时，最派生的位置优先。在以下示例中， <code>DefaultFooService</code>在类级别使用只读事务的设置注释该类，但是<code>@Transactional</code>上的注释<code>updateFoo(Foo)</code>同一类中的方法优先于在类级别定义的事务设置。</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        // ...
    }

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Transactional(readOnly = true)
class DefaultFooService : FooService {

    override fun getFoo(fooName: String): Foo {
        // ...
    }

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    override fun updateFoo(foo: Foo) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="transaction-declarative-attransactional-settings"><a class="anchor" href="#transaction-declarative-attransactional-settings"></a><code>@Transactional</code>设定值</h5>
<div class="paragraph">
<p>的<code>@Transactional</code>批注是元数据，它指定接口，类或方法必须具有事务语义（例如，“在调用此方法时启动一个全新的只读事务，暂停任何现有事务”）。默认值<code>@Transactional</code>设置如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>传播设置为<code>PROPAGATION_REQUIRED.</code></p>
</li>
<li>
<p>隔离级别为<code>ISOLATION_DEFAULT.</code></p>
</li>
<li>
<p>事务是读写的。</p>
</li>
<li>
<p>事务超时默认为基础事务系统的默认超时，如果不支持超时，则默认为无。</p>
</li>
<li>
<p>任何<code>RuntimeException</code>触发回滚，并检查所有<code>Exception</code>才不是。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以更改这些默认设置。下表总结了<code>@Transactional</code>注解：</p>
</div>
<table id="tx-attransactional-properties" class="tableblock frame-all grid-all spread">
<caption class="title">表3。@交易设置</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx-multiple-tx-mgrs-with-attransactional">值</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的限定词，指定要使用的事务管理器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx-propagation">传播</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code> ：<code>Propagation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的传播设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>enum</code> ：<code>Isolation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的隔离级别。仅适用于的传播值<code>REQUIRED</code>要么<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code> （以秒为单位）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的事务超时。仅适用于的传播值<code>REQUIRED</code>要么<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>readOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读写与只读事务。仅适用于<code>REQUIRED</code>要么<code>REQUIRES_NEW</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackFor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组<code>Class</code>对象，这些对象必须源自<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">必须引起回滚的异常类的可选数组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类名数组。这些类必须源自<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">必须引起回滚的异常类名称的可选数组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackFor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组<code>Class</code>对象，这些对象必须源自<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不能导致回滚的异常类的可选数组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noRollbackForClassName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组<code>String</code>类名，必须从<code>Throwable.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不能引起回滚的异常类名称的可选数组。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当前，您不能对事务名称进行显式控制，其中“名称”表示在事务监视器（如果适用）（例如，WebLogic的事务监视器）和日志输出中显示的事务名称。对于声明式交易，交易名称始终是完全合格的类名称+ <code>.</code> +交易建议类的方法名称。例如，如果<code>handlePayment(..)</code>的方法<code>BusinessService</code>类启动了交易，交易的名称为： <code>com.example.BusinessService.handlePayment</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-multiple-tx-mgrs-with-attransactional"><a class="anchor" href="#tx-multiple-tx-mgrs-with-attransactional"></a>多个交易经理<code>@Transactional</code></h5>
<div class="paragraph">
<p>大多数Spring应用程序仅需要一个事务管理器，但是在某些情况下，您可能需要在一个应用程序中使用多个独立的事务管理器。您可以使用<code>value</code>的属性<code>@Transactional</code>注释，以选择性地指定<code>PlatformTransactionManager</code>要使用的。可以是bean名称，也可以是事务管理器bean的限定符值。例如，使用限定符表示法，可以在应用程序上下文中将以下Java代码与以下事务管理器bean声明进行组合：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class TransactionalService {

    @Transactional("order")
    public void setSomething(String name) { ... }

    @Transactional("account")
    public void doSomething() { ... }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class TransactionalService {

    @Transactional("order")
    fun setSomething(name: String) {
        // ...
    }

    @Transactional("account")
    fun doSomething() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了bean声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tx:annotation-driven/&gt;

    &lt;bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        ...
        &lt;qualifier value="order"/&gt;
    &lt;/bean&gt;

    &lt;bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        ...
        &lt;qualifier value="account"/&gt;
    &lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，两种方法<code>TransactionalService</code>在不同的交易管理器下运行，区别在于<code>order</code>和<code>account</code>限定词。默认值<code><tx:annotation-driven></code>目标Bean名称， <code>transactionManager</code> ，如果没有特别限定，仍将使用<code>PlatformTransactionManager</code>豆被发现。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-custom-attributes"><a class="anchor" href="#tx-custom-attributes"></a>自定义快捷方式注释</h5>
<div class="paragraph">
<p>如果发现反复使用相同的属性<code>@Transactional</code>在许多不同的方法上， <a href="core.html#beans-meta-annotations">Spring的元注释支持</a>使您可以为特定用例定义自定义快捷方式注释。例如，考虑以下注释定义：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional("order")
public @interface OrderTx {
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Transactional("account")
public @interface AccountTx {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional("order")
annotation class OrderTx

@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Transactional("account")
annotation class AccountTx</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的注释使我们可以编写上一节中的示例，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class TransactionalService {

    @OrderTx
    public void setSomething(String name) {
        // ...
    }

    @AccountTx
    public void doSomething() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class TransactionalService {

    @OrderTx
    fun setSomething(name: String) {
        // ...
    }

    @AccountTx
    fun doSomething() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们使用了语法来定义事务管理器限定符，但是我们还可以包括传播行为，回滚规则，超时和其他功能。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tx-propagation"><a class="anchor" href="#tx-propagation"></a> 1.4.7。交易传播</h4>
<div class="paragraph">
<p>本节描述了Spring中事务传播的一些语义。请注意，本节不是对事务传播的适当介绍。相反，它详细介绍了有关Spring中事务传播的一些语义。</p>
</div>
<div class="paragraph">
<p>在Spring管理的事务中，请注意物理事务和逻辑事务之间的差异，以及传播设置如何应用于此差异。</p>
</div>
<div class="sect4">
<h5 id="tx-propagation-required"><a class="anchor" href="#tx-propagation-required"></a>理解<code>PROPAGATION_REQUIRED</code></h5>
<div class="imageblock">
<div class="content">
<img src="images/tx_prop_required.png" alt="需要TX道具">
</div>
</div>
<div class="paragraph">
<p><code>PROPAGATION_REQUIRED</code>强制执行物理事务，如果尚不存在当前事务，则在本地为当前范围执行，或参与为较大范围定义的现有“外部”事务。这是同一线程（例如，委派给几个存储库方法的服务立面，所有基础资源都必须参与服务级事务的服务立面）的优良默认设置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，参与的事务会加入外部作用域的特征，而忽略本地隔离级别，超时值或只读标志（如果有）。考虑切换<code>validateExistingTransactions</code>标记为<code>true</code>如果希望在参与具有不同隔离级别的现有事务时拒绝隔离级别声明，请在事务管理器上进行操作。这种非宽容模式还拒绝只读不匹配（即，内部读写事务试图参与只读外部作用域）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当传播设置为<code>PROPAGATION_REQUIRED</code> ，将为应用设置的每种方法创建一个逻辑事务作用域。每个此类逻辑事务作用域可以单独确定仅回滚状态，而外部事务作用域在逻辑上与内部事务作用域无关。在标准的情况下<code>PROPAGATION_REQUIRED</code>行为，所有这些范围都映射到相同的物理事务。因此，内部事务范围中设置的仅回滚标记确实会影响外部事务实际提交的机会。</p>
</div>
<div class="paragraph">
<p>但是，在内部事务范围设置仅回滚标记的情况下，外部事务尚未决定回滚本身，因此回滚（由内部事务范围默默触发）是意外的。对应的<code>UnexpectedRollbackException</code>在这一点上抛出。这是预期的行为，因此永远不会误导事务的调用方以假定在确实未执行提交的情况下执行该提交。因此，如果内部事务（外部调用者不知道）将事务无提示地标记为仅回滚，则外部调用者仍会调用commit。外线呼叫者需要接收一个<code>UnexpectedRollbackException</code>明确表示已执行回滚。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-propagation-requires_new"><a class="anchor" href="#tx-propagation-requires_new"></a>理解<code>PROPAGATION_REQUIRES_NEW</code></h5>
<div class="imageblock">
<div class="content">
<img src="images/tx_prop_requires_new.png" alt="发射道具需要新的">
</div>
</div>
<div class="paragraph">
<p><code>PROPAGATION_REQUIRES_NEW</code> ，与<code>PROPAGATION_REQUIRED</code> ，始终为每个受影响的事务范围使用独立的物理事务，而不参与外部范围的现有事务。在这种安排中，基础资源事务是不同的，因此可以独立地提交或回滚，而外部事务不受内部事务的回滚状态的影响，并且内部事务的锁在完成后立即释放。这样一个独立的内部事务也可以声明其自己的隔离级别，超时和只读设置，而不继承外部事务的特征。</p>
</div>
</div>
<div class="sect4">
<h5 id="tx-propagation-nested"><a class="anchor" href="#tx-propagation-nested"></a>理解<code>PROPAGATION_NESTED</code></h5>
<div class="paragraph">
<p><code>PROPAGATION_NESTED</code>使用具有多个可还原到的保存点的单个物理事务。这种部分回滚使内部事务范围触发其范围的回滚，尽管某些操作已回滚，但外部事务仍能够继续物理事务。此设置通常映射到JDBC保存点，因此仅适用于JDBC资源事务。见春天的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html"><code>DataSourceTransactionManager</code></a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-applying-more-than-just-tx-advice"><a class="anchor" href="#transaction-declarative-applying-more-than-just-tx-advice"></a> 1.4.8。交易事务咨询</h4>
<div class="paragraph">
<p>假设您要执行事务性操作和一些基本的配置建议。您如何在以下情况下实现这一目标<code><tx:annotation-driven/></code> ？</p>
</div>
<div class="paragraph">
<p>当您调用<code>updateFoo(Foo)</code>方法，您想查看以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置的外观方面开始。</p>
</li>
<li>
<p>交易建议执行。</p>
</li>
<li>
<p>建议对象上的方法执行。</p>
</li>
<li>
<p>事务提交。</p>
</li>
<li>
<p>分析方面报告整个事务方法调用的确切持续时间。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本章不涉及任何详细的AOP解释（除非它适用于事务）。有关<a href="core.html#aop">AOP</a>配置和AOP的详细介绍，请参见<a href="core.html#aop">AOP</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下代码显示了前面讨论的简单配置方面：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

    private int order;

    // allows us to control the ordering of advice
    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    // this method is the around advice
    public Object profile(ProceedingJoinPoint call) throws Throwable {
        Object returnValue;
        StopWatch clock = new StopWatch(getClass().getName());
        try {
            clock.start(call.toShortString());
            returnValue = call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
        return returnValue;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleProfiler : Ordered {

    private var order: Int = 0

    // allows us to control the ordering of advice
    override fun getOrder(): Int {
        return this.order
    }

    fun setOrder(order: Int) {
        this.order = order
    }

    // this method is the around advice
    fun profile(call: ProceedingJoinPoint): Any {
        var returnValue: Any
        val clock = StopWatch(javaClass.name)
        try {
            clock.start(call.toShortString())
            returnValue = call.proceed()
        } finally {
            clock.stop()
            println(clock.prettyPrint())
        }
        return returnValue
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>建议的顺序是通过<code>Ordered</code>接口。有关建议订购的完整详细信息，请参阅<a href="core.html#aop-ataspectj-advice-ordering">建议订购</a> 。</p>
</div>
<div class="paragraph">
<p>以下配置创建一个<code>fooService</code>以所需顺序对其应用了概要分析和事务方面的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- this is the aspect --&gt;
    &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;
        &lt;property name="order" value="1"/&gt;
    &lt;/bean&gt;

    &lt;tx:annotation-driven transaction-manager="txManager" order="200"/&gt;

    &lt;aop:config&gt;
            &lt;!-- this advice will execute around the transactional advice --&gt;
            &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
                &lt;aop:pointcut id="serviceMethodWithReturnValue"
                        expression="execution(!void x.y..*Service.*(..))"/&gt;
                &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
            &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
        &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
        &lt;property name="username" value="scott"/&gt;
        &lt;property name="password" value="tiger"/&gt;
    &lt;/bean&gt;

    &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以类似的方式配置任意数量的其他方面。</p>
</div>
<div class="paragraph">
<p>下面的示例创建与前两个示例相同的设置，但是使用纯XML声明性方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

    &lt;!-- the profiling advice --&gt;
    &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;
        &lt;property name="order" value="1"/&gt;
    &lt;/bean&gt;

    &lt;aop:config&gt;
        &lt;aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/&gt;
        &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;

        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="entryPointMethod" order="2"/&gt;
        &lt;!-- order value is higher than the profiling aspect --&gt;

        &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
            &lt;aop:pointcut id="serviceMethodWithReturnValue"
                    expression="execution(!void x.y..*Service.*(..))"/&gt;
            &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
        &lt;/aop:aspect&gt;

    &lt;/aop:config&gt;

    &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name="get*" read-only="true"/&gt;
            &lt;tx:method name="*"/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>先前配置的结果是<code>fooService</code>按顺序将性能分析和事务处理方面应用到它的bean。如果您希望性能分析建议在进来的事务处理建议之后和之后的事务处理建议之前执行，则可以交换性能分析方面Bean的值<code>order</code>属性，使其高于交易建议的订单价值。</p>
</div>
<div class="paragraph">
<p>您可以以类似方式配置其他方面。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-declarative-aspectj"><a class="anchor" href="#transaction-declarative-aspectj"></a> 1.4.9。使用<code>@Transactional</code>使用AspectJ</h4>
<div class="paragraph">
<p>您也可以使用Spring Framework的<code>@Transactional</code>通过AspectJ方面在Spring容器外部提供支持。为此，请先使用注释您的类（以及可选的类的方法） <code>@Transactional</code>注释，然后将您的应用程序与<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>在定义<code>spring-aspects.jar</code>文件。您还必须使用事务管理器配置方面。您可以使用Spring Framework的IoC容器来进行依赖注入方面。配置事务管理方面的最简单方法是使用<code><tx:annotation-driven/></code>元素并指定<code>mode</code>归因于<code>aspectj</code>如<a href="#transaction-declarative-annotations">使用中所述<code>@Transactional</code></a> 。因为这里我们专注于在Spring容器之外运行的应用程序，所以我们向您展示如何以编程方式进行操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在继续之前，您可能需要阅读<a href="#transaction-declarative-annotations">使用<code>@Transactional</code></a>和<a href="core.html#aop">AOP</a>分别。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何创建事务管理器并配置<code>AnnotationTransactionAspect</code>使用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// construct an appropriate transaction manager
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// construct an appropriate transaction manager
val txManager = DataSourceTransactionManager(getDataSource())

// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
AnnotationTransactionAspect.aspectOf().transactionManager = txManager</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用此方面时，必须注释实现类（或该类中的方法或两者），而不是注释该类所实现的接口（如果有）。AspectJ遵循Java的规则，即不继承接口上的注释。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>@Transactional</code>类上的注释指定用于执行该类中任何公共方法的默认事务语义。</p>
</div>
<div class="paragraph">
<p>的<code>@Transactional</code>类内方法的注解会覆盖类注解（如果存在）给出的默认事务语义。您可以注释任何方法，而不管可见性如何。</p>
</div>
<div class="paragraph">
<p>要使用<code>AnnotationTransactionAspect</code> ，您必须使用AspectJ构建应用程序（请参阅<a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html">AspectJ开发指南</a> ）或使用加载时编织。有关<a href="core.html#aop-aj-ltw">使用AspectJ进行加载时编织</a>的讨论，请参见<a href="core.html#aop-aj-ltw">Spring框架中使用AspectJ</a>进行加载时编织。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-programmatic"><a class="anchor" href="#transaction-programmatic"></a> 1.5。程序化交易管理</h3>
<div class="paragraph">
<p>Spring框架通过使用以下两种方式提供程序化事务管理的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>TransactionTemplate</code> 。</p>
</li>
<li>
<p>一种<code>PlatformTransactionManager</code>直接实施。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring团队通常建议<code>TransactionTemplate</code>用于程序化交易管理。第二种方法类似于使用JTA <code>UserTransaction</code> API，尽管异常处理不那么麻烦。</p>
</div>
<div class="sect3">
<h4 id="tx-prog-template"><a class="anchor" href="#tx-prog-template"></a> 1.5.1。使用<code>TransactionTemplate</code></h4>
<div class="paragraph">
<p>的<code>TransactionTemplate</code>采用与其他Spring模板相同的方法，例如<code>JdbcTemplate</code> 。它使用回调方法（使应用程序代码不必进行样板获取和释放事务性资源），并生成意向驱动的代码，因为您的代码仅专注于您要执行的操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如下例所示，使用<code>TransactionTemplate</code>绝对使您与Spring的事务基础结构和API耦合。程序化事务管理是否适合您的开发需求是您必须自己做的决定。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>必须在事务上下文中执行并且显式使用<code>TransactionTemplate</code>类似于下一个示例。作为应用程序开发人员，您可以编写<code>TransactionCallback</code>实现（通常表示为匿名内部类），其中包含您需要在事务上下文中执行的代码。然后，您可以传递自定义实例<code>TransactionCallback</code>到<code>execute(..)</code>方法暴露在<code>TransactionTemplate</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleService implements Service {

    // single TransactionTemplate shared amongst all methods in this instance
    private final TransactionTemplate transactionTemplate;

    // use constructor-injection to supply the PlatformTransactionManager
    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public Object someServiceMethod() {
        return transactionTemplate.execute(new TransactionCallback() {
            // the code in this method executes in a transactional context
            public Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                return resultOfUpdateOperation2();
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// use constructor-injection to supply the PlatformTransactionManager
class SimpleService(transactionManager: PlatformTransactionManager) : Service {

    // single TransactionTemplate shared amongst all methods in this instance
    private val transactionTemplate = TransactionTemplate(transactionManager)

    fun someServiceMethod() = transactionTemplate.execute&lt;Any?&gt; {
        updateOperation1()
        resultOfUpdateOperation2()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有返回值，可以使用方便<code>TransactionCallbackWithoutResult</code>带有匿名类的类，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">transactionTemplate.execute(object : TransactionCallbackWithoutResult() {
    override fun doInTransactionWithoutResult(status: TransactionStatus) {
        updateOperation1()
        updateOperation2()
    }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>回调中的代码可以通过调用<code>setRollbackOnly()</code>提供的方法<code>TransactionStatus</code>对象，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">transactionTemplate.execute(new TransactionCallbackWithoutResult() {

    protected void doInTransactionWithoutResult(TransactionStatus status) {
        try {
            updateOperation1();
            updateOperation2();
        } catch (SomeBusinessException ex) {
            status.setRollbackOnly();
        }
    }
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">transactionTemplate.execute(object : TransactionCallbackWithoutResult() {

    override fun doInTransactionWithoutResult(status: TransactionStatus) {
        try {
            updateOperation1()
            updateOperation2()
        } catch (ex: SomeBusinessException) {
            status.setRollbackOnly()
        }
    }
})</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="tx-prog-template-settings"><a class="anchor" href="#tx-prog-template-settings"></a>指定交易设置</h5>
<div class="paragraph">
<p>您可以在服务器上指定事务设置（例如传播模式，隔离级别，超时等）。 <code>TransactionTemplate</code>以编程方式或配置方式。默认， <code>TransactionTemplate</code>实例具有<a href="#transaction-declarative-txadvice-settings">默认的事务设置</a> 。以下示例显示了针对特定交易设置的编程自定义<code>TransactionTemplate:</code></p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleService implements Service {

    private final TransactionTemplate transactionTemplate;

    public SimpleService(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);

        // the transaction settings can be set here explicitly if so desired
        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        this.transactionTemplate.setTimeout(30); // 30 seconds
        // and so forth...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SimpleService(transactionManager: PlatformTransactionManager) : Service {

    private val transactionTemplate = TransactionTemplate(transactionManager).apply {
        // the transaction settings can be set here explicitly if so desired
        isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED
        timeout = 30 // 30 seconds
        // and so forth...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例定义了<code>TransactionTemplate</code>通过使用Spring XML配置使用一些自定义事务设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="sharedTransactionTemplate"
        class="org.springframework.transaction.support.TransactionTemplate"&gt;
    &lt;property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/&gt;
    &lt;property name="timeout" value="30"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以注入<code>sharedTransactionTemplate</code>提供所需的尽可能多的服务。</p>
</div>
<div class="paragraph">
<p>最后， <code>TransactionTemplate</code>类是线程安全的，在这种情况下，实例不保持任何对话状态。 <code>TransactionTemplate</code>但是，实例确实保持配置状态。因此，尽管许多类可能共享一个<code>TransactionTemplate</code> ，如果一个班级需要使用<code>TransactionTemplate</code>使用不同的设置（例如，不同的隔离级别），您需要创建两个不同的<code>TransactionTemplate</code>实例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transaction-programmatic-ptm"><a class="anchor" href="#transaction-programmatic-ptm"></a> 1.5.2。使用<code>PlatformTransactionManager</code></h4>
<div class="paragraph">
<p>您也可以使用<code>org.springframework.transaction.PlatformTransactionManager</code>直接管理您的交易。为此，请通过<code>PlatformTransactionManager</code>您可以通过bean引用来使用bean。然后，使用<code>TransactionDefinition</code>和<code>TransactionStatus</code>对象，则可以启动事务，回滚和提交。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // execute your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val def = DefaultTransactionDefinition()
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName")
def.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED

val status = txManager.getTransaction(def)
try {
    // execute your business logic here
} catch (ex: MyException) {
    txManager.rollback(status)
    throw ex
}

txManager.commit(status)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx-decl-vs-prog"><a class="anchor" href="#tx-decl-vs-prog"></a> 1.6。在程序性和声明性事务管理之间进行选择</h3>
<div class="paragraph">
<p>仅当您执行少量事务操作时，程序事务管理通常是一个好主意。例如，如果您的Web应用程序仅要求对某些更新操作进行事务处理，则可能不希望使用Spring或任何其他技术来设置事务代理。在这种情况下，使用<code>TransactionTemplate</code>可能是个好方法。能够显式设置事务名称也是只能通过使用编程方法进行事务管理来完成的事情。</p>
</div>
<div class="paragraph">
<p>另一方面，如果您的应用程序具有大量事务操作，则声明式事务管理通常是值得的。它使事务管理脱离业务逻辑，并且不难配置。当使用Spring框架而不是EJB CMT时，声明式事务管理的配置成本大大降低了。</p>
</div>
</div>
<div class="sect2">
<h3 id="transaction-event"><a class="anchor" href="#transaction-event"></a> 1.7。交易绑定事件</h3>
<div class="paragraph">
<p>从Spring 4.2开始，事件的侦听器可以绑定到事务的某个阶段。典型的示例是在事务成功完成后处理事件。这样，当当前事务的结果实际上对侦听器很重要时，便可以更加灵活地使用事件。</p>
</div>
<div class="paragraph">
<p>您可以使用来注册常规事件监听器<code>@EventListener</code>注解。如果需要将其绑定到事务，请使用<code>@TransactionalEventListener</code> 。这样做时，默认情况下，侦听器绑定到事务的提交阶段。</p>
</div>
<div class="paragraph">
<p>下一个示例显示了此概念。假设组件发布了一个订单创建的事件，并且我们想要定义一个侦听器，该侦听器仅在发布了该事件的事务成功提交后才处理该事件。以下示例设置了此类事件侦听器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyComponent {

    @TransactionalEventListener
    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class MyComponent {

    @TransactionalEventListener
    fun handleOrderCreatedEvent(creationEvent: CreationEvent&lt;Order&gt;) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@TransactionalEventListener</code>注释暴露了一个<code>phase</code>该属性使您可以自定义应将侦听器绑定到的事务的阶段。有效阶段是<code>BEFORE_COMMIT</code> ， <code>AFTER_COMMIT</code> （默认）， <code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code>汇总交易完成（无论是提交还是回滚）。</p>
</div>
<div class="paragraph">
<p>如果没有事务在运行，则根本不会调用侦听器，因为我们无法遵守所需的语义。但是，您可以通过设置<code>fallbackExecution</code>注释的属性<code>true</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="transaction-application-server-integration"><a class="anchor" href="#transaction-application-server-integration"></a> 1.8。应用服务器特定的集成</h3>
<div class="paragraph">
<p>Spring的事务抽象通常与应用程序服务器无关。另外，春天的<code>JtaTransactionManager</code>类（可以选择对JTA执行JNDI查找<code>UserTransaction</code>和<code>TransactionManager</code>对象）自动检测后一个对象的位置，该位置随应用程序服务器的不同而不同。可以使用JTA <code>TransactionManager</code>允许增强的事务语义-特别是支持事务挂起。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/transaction/jta/JtaTransactionManager.html"><code>JtaTransactionManager</code></a>有关详细信息，请参见javadoc。</p>
</div>
<div class="paragraph">
<p>春天的<code>JtaTransactionManager</code>是在Java EE应用程序服务器上运行的标准选择，并且已知可以在所有常见服务器上运行。诸如事务挂起之类的高级功能也可以在许多服务器（包括GlassFish，JBoss和Geronimo）上运行，而无需任何特殊配置。但是，对于完全支持的事务挂起和进一步的高级集成，Spring包括用于WebLogic Server和WebSphere的特殊适配器。以下各节将讨论这些适配器。</p>
</div>
<div class="paragraph">
<p>对于包括WebLogic Server和WebSphere在内的标准方案，请考虑使用<code><tx:jta-transaction-manager/></code>配置元素。配置后，此元素将自动检测基础服务器，并选择可用于平台的最佳事务管理器。这意味着您无需显式配置服务器特定的适配器类（如以下各节所述）。而是按照标准自动选择<code>JtaTransactionManager</code>作为默认的后备广告。</p>
</div>
<div class="sect3">
<h4 id="transaction-application-server-integration-websphere"><a class="anchor" href="#transaction-application-server-integration-websphere"></a> 1.8.1。IBM WebSphere</h4>
<div class="paragraph">
<p>在WebSphere 6.1.0.9及更高版本上，推荐使用的Spring JTA事务管理器是<code>WebSphereUowTransactionManager</code> 。这个特殊的适配器使用IBM的<code>UOWManager</code> API，在WebSphere Application Server 6.1.0.9和更高版本中可用。使用此适配器，Spring驱动的事务暂停（暂停和恢复由<code>PROPAGATION_REQUIRES_NEW</code> ）得到IBM的正式支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="transaction-application-server-integration-weblogic"><a class="anchor" href="#transaction-application-server-integration-weblogic"></a> 1.8.2。Oracle WebLogic服务器</h4>
<div class="paragraph">
<p>在WebLogic Server 9.0或更高版本上，通常使用<code>WebLogicJtaTransactionManager</code>代替库存<code>JtaTransactionManager</code>类。此特定于WebLogic的特殊子类是常规的<code>JtaTransactionManager</code>除了标准JTA语义之外，在WebLogic管理的事务环境中还支持Spring事务定义的全部功能。功能包括事务名称，每个事务隔离级别以及在所有情况下正确恢复事务。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-solutions-to-common-problems"><a class="anchor" href="#transaction-solutions-to-common-problems"></a> 1.9。常见问题的解决方案</h3>
<div class="paragraph">
<p>本节介绍一些常见问题的解决方案。</p>
</div>
<div class="sect3">
<h4 id="transaction-solutions-to-common-problems-wrong-ptm"><a class="anchor" href="#transaction-solutions-to-common-problems-wrong-ptm"></a> 1.9.1。为特定的错误使用交易管理器<code>DataSource</code></h4>
<div class="paragraph">
<p>使用正确的<code>PlatformTransactionManager</code>根据您选择的交易技术和要求实施。如果使用得当，Spring框架仅提供了直接且可移植的抽象。如果您使用全球交易，则必须使用<code>org.springframework.transaction.jta.JtaTransactionManager</code>类（或其所有<a href="#transaction-application-server-integration">应用程序服务器的子类</a> ）。否则，事务基础结构将尝试对诸如容器之类的资源执行本地事务<code>DataSource</code>实例。这样的本地事务是没有意义的，好的应用服务器会将它们视为错误。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transaction-resources"><a class="anchor" href="#transaction-resources"></a> 1.10。更多资源</h3>
<div class="paragraph">
<p>有关Spring框架的事务支持的更多信息，请参见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html">带有和不带有XA的Spring中的分布式事务</a>是JavaWorld演示，其中Spring的David Syer指导您完成Spring应用程序中的七个分布式事务模式，其中三个带有XA，四个带有XA。</p>
</li>
<li>
<p><a href="https://www.infoq.com/minibooks/JTDS"><em>《 Java事务设计策略》</em></a>是<a href="https://www.infoq.com/">InfoQ</a>提供的一本书，其中提供了有关Java事务的详细介绍。它还包括有关如何通过Spring Framework和EJB3配置和使用事务的并行示例。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dao"><a class="anchor" href="#dao"></a> 2。DAO支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring对数据访问对象（DAO）的支持旨在使以一致的方式轻松使用数据访问技术（例如JDBC，Hibernate或JPA）。这使您可以轻松地在上述持久性技术之间进行切换，还使您无需担心捕获每种技术特有的异常即可进行编码。</p>
</div>
<div class="sect2">
<h3 id="dao-exceptions"><a class="anchor" href="#dao-exceptions"></a> 2.1。一致的异常层次结构</h3>
<div class="paragraph">
<p>Spring提供了对特定于技术的异常的便捷转换，例如<code>SQLException</code>到自己的异常类层次结构<code>DataAccessException</code>作为根本的例外。这些异常包装了原始异常，因此您永远不会丢失任何可能出错的信息。</p>
</div>
<div class="paragraph">
<p>除了JDBC异常，Spring还可以包装JPA和Hibernate特定的异常，将它们转换为一组集中的运行时异常。这样，您就可以仅在适当的层中处理大多数不可恢复的持久性异常，而不必在DAO中使用烦人的样板捕获和抛出块以及异常声明。（尽管如此，您仍然可以在任何需要的地方捕获和处理异常。）如上所述，JDBC异常（包括特定于数据库的方言）也被转换为相同的层次结构，这意味着您可以在一致的编程模型中使用JDBC执行某些操作。</p>
</div>
<div class="paragraph">
<p>在Spring对各种ORM框架的支持中，上述讨论对于各种模板类均适用。如果使用基于拦截器的类，则应用程序必须注意处理<code>HibernateExceptions</code>和<code>PersistenceExceptions</code>本身，最好是委派给<code>convertHibernateAccessException(..)</code>要么<code>convertJpaAccessException()</code>分别的方法<code>SessionFactoryUtils</code> 。这些方法将异常转换为与<code>org.springframework.dao</code>异常层次结构。如<code>PersistenceExceptions</code>如果没有检查，它们也可能被抛出（不过，在异常方面牺牲了通用的DAO抽象）。</p>
</div>
<div class="paragraph">
<p>下图显示了Spring提供的异常层次结构。（请注意，图像中详细说明的类层次结构仅显示整个<code>DataAccessException</code>层次结构。）</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/DataAccessException.png" alt="DataAccessException">
</div>
</div>
</div>
<div class="sect2">
<h3 id="dao-annotations"><a class="anchor" href="#dao-annotations"></a> 2.2。用于配置DAO或存储库类的注释</h3>
<div class="paragraph">
<p>确保您的数据访问对象（DAO）或存储库提供异常翻译的最佳方法是使用<code>@Repository</code>注解。此注释还使组件扫描支持可以查找和配置DAO和存储库，而不必为其提供XML配置条目。以下示例显示了如何使用<code>@Repository</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
public class SomeMovieFinder implements MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Repository</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
class SomeMovieFinder : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>@Repository</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>任何DAO或存储库实现都需要访问持久性资源，具体取决于所使用的持久性技术。例如，基于JDBC的存储库需要访问JDBC <code>DataSource</code> ，并且基于JPA的存储库需要访问<code>EntityManager</code> 。完成此操作的最简单方法是使用以下方法之一注入此资源依赖项： <code>@Autowired</code> ， <code>@Inject</code> ， <code>@Resource</code>要么<code>@PersistenceContext</code>注释。以下示例适用于JPA存储库：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public class JpaMovieFinder implements MovieFinder {

    @PersistenceContext
    private EntityManager entityManager;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository
class JpaMovieFinder : MovieFinder {

    @PersistenceContext
    private lateinit var entityManager: EntityManager

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用经典的Hibernate API，则可以注入<code>SessionFactory</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public class HibernateMovieFinder implements MovieFinder {

    private SessionFactory sessionFactory;

    @Autowired
    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository
class HibernateMovieFinder(private val sessionFactory: SessionFactory) : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在此显示的最后一个示例是典型的JDBC支持。你可以有<code>DataSource</code>注入初始化方法或构造函数中，您将在其中创建一个<code>JdbcTemplate</code>和其他数据访问支持类（例如<code>SimpleJdbcCall</code>和其他）使用此<code>DataSource</code> 。以下示例自动接线<code>DataSource</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public class JdbcMovieFinder implements MovieFinder {

    private JdbcTemplate jdbcTemplate;

    @Autowired
    public void init(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository
class JdbcMovieFinder(dataSource: DataSource) : MovieFinder {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关如何配置应用程序上下文以利用这些注释的详细信息，请参见每种持久性技术的特定介绍。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jdbc"><a class="anchor" href="#jdbc"></a> 3。使用JDBC进行数据访问</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下表中概述的操作序列可能最好地显示了Spring Framework JDBC抽象提供的值。该表显示了Spring负责哪些操作以及哪些操作是您的责任。</p>
</div>
<table id="jdbc-who-does-what" class="tableblock frame-all grid-all spread">
<caption class="title">表4。Spring JDBC-谁做什么？</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">行动</th>
<th class="tableblock halign-left valign-top">弹簧</th>
<th class="tableblock halign-left valign-top">您</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义连接参数。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">打开连接。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定SQL语句。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明参数并提供参数值</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">准备并执行该语句。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置循环以遍历结果（如果有）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">进行每次迭代的工作。</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理任何异常。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理交易。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">关闭连接，语句和结果集。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring框架负责所有可能使JDBC成为乏味的API的低级细节。</p>
</div>
<div class="sect2">
<h3 id="jdbc-choose-style"><a class="anchor" href="#jdbc-choose-style"></a> 3.1。选择一种用于JDBC数据库访问的方法</h3>
<div class="paragraph">
<p>您可以选择几种方法来构成JDBC数据库访问的基础。除了三种口味<code>JdbcTemplate</code> ，一个新的<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>这种方法优化了数据库元数据，并且RDBMS Object样式采用了一种更加面向对象的方法，类似于JDO Query设计。一旦开始使用这些方法之一，您仍然可以混合搭配以包含来自其他方法的功能。所有方法都需要兼容JDBC 2.0的驱动程序，某些高级功能需要JDBC 3.0驱动程序。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JdbcTemplate</code>是经典且最受欢迎的Spring JDBC方法。这种“最低级别”的方法以及其他所有方法都在后台使用了JdbcTemplate。</p>
</li>
<li>
<p><code>NamedParameterJdbcTemplate</code>包装一个<code>JdbcTemplate</code>提供命名参数而不是传统的JDBC <code>?</code>占位符。当您有多个SQL语句参数时，此方法可提供更好的文档编制和易用性。</p>
</li>
<li>
<p><code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>优化数据库元数据以限制必要的配置数量。这种方法简化了编码，因此您只需要提供表或过程的名称，并提供与列名称匹配的参数映射即可。仅当数据库提供足够的元数据时，此方法才有效。如果数据库不提供此元数据，则必须提供参数的显式配置。</p>
</li>
<li>
<p>RDBMS对象，包括<code>MappingSqlQuery</code> ， <code>SqlUpdate</code>和<code>StoredProcedure</code> ，要求您在数据访问层初始化期间创建可重用且线程安全的对象。此方法以JDO Query为模型，其中您定义查询字符串，声明参数并编译查询。完成后，可以使用各种参数值多次调用execute方法。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-packages"><a class="anchor" href="#jdbc-packages"></a> 3.2。包层次结构</h3>
<div class="paragraph">
<p>Spring框架的JDBC抽象框架由四个不同的软件包组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>core</code> ： <code>org.springframework.jdbc.core</code>包装中包含<code>JdbcTemplate</code>类及其各种回调接口，以及各种相关类。名为的子包<code>org.springframework.jdbc.core.simple</code>包含<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>类。另一个名为<code>org.springframework.jdbc.core.namedparam</code>包含<code>NamedParameterJdbcTemplate</code>类和相关的支持类。请参见<a href="#jdbc-core">使用JDBC核心类控制基本JDBC处理和错误处理</a> ， <a href="#jdbc-advanced-jdbc">JDBC批处理操作</a>和使用<a href="#jdbc-simple-jdbc">简化JDBC操作。 <code>SimpleJdbc</code>类</a> 。</p>
</li>
<li>
<p><code>datasource</code> ： <code>org.springframework.jdbc.datasource</code>软件包中包含一个实用程序类，可轻松实现<code>DataSource</code>访问和各种简单<code>DataSource</code>可用于在Java EE容器外部测试和运行未修改的JDBC代码的实现。名为的子包<code>org.springfamework.jdbc.datasource.embedded</code>提供了使用Java数据库引擎（例如HSQL，H2和Derby）创建嵌入式数据库的支持。请参见<a href="#jdbc-connections">控制数据库连接</a>和<a href="#jdbc-embedded-database-support">嵌入式数据库支持</a> 。</p>
</li>
<li>
<p><code>object</code> ： <code>org.springframework.jdbc.object</code>软件包包含将RDBMS查询，更新和存储过程表示为线程安全，可重用对象的类。请参阅将<a href="#jdbc-object">JDBC操作建模为Java对象</a> 。尽管查询返回的对象自然会与数据库断开连接，但此方法由JDO建模。较高级别的JDBC抽象取决于应用程序中较低级别的抽象。 <code>org.springframework.jdbc.core</code>包。</p>
</li>
<li>
<p><code>support</code> ： <code>org.springframework.jdbc.support</code>套餐提供<code>SQLException</code>翻译功能和一些实用程序类。JDBC处理期间引发的异常将转换为<code>org.springframework.dao</code>包。这意味着使用Spring JDBC抽象层的代码不需要实现JDBC或RDBMS特定的错误处理。所有翻译的异常均未选中，这使您可以选择捕获可从中恢复的异常，同时将其他异常传播到调用方。请参阅<a href="#jdbc-SQLExceptionTranslator">使用<code>SQLExceptionTranslator</code></a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-core"><a class="anchor" href="#jdbc-core"></a> 3.3。使用JDBC核心类控制基本JDBC处理和错误处理</h3>
<div class="paragraph">
<p>本节介绍如何使用JDBC核心类来控制基本的JDBC处理，包括错误处理。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-JdbcTemplate">使用<code>JdbcTemplate</code></a></p>
</li>
<li>
<p><a href="#jdbc-NamedParameterJdbcTemplate">使用<code>NamedParameterJdbcTemplate</code></a></p>
</li>
<li>
<p><a href="#jdbc-SQLExceptionTranslator">使用<code>SQLExceptionTranslator</code></a></p>
</li>
<li>
<p><a href="#jdbc-statements-executing">运行声明</a></p>
</li>
<li>
<p><a href="#jdbc-statements-querying">运行查询</a></p>
</li>
<li>
<p><a href="#jdbc-updates">更新数据库</a></p>
</li>
<li>
<p><a href="#jdbc-auto-generated-keys">检索自动生成的密钥</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jdbc-JdbcTemplate"><a class="anchor" href="#jdbc-JdbcTemplate"></a> 3.3.1。使用<code>JdbcTemplate</code></h4>
<div class="paragraph">
<p><code>JdbcTemplate</code>是JDBC核心软件包中的中心类。它处理资源的创建和释放，这有助于您避免常见的错误，例如忘记关闭连接。它执行核心JDBC工作流程的基本任务（例如，语句创建和执行），而保留应用程序代码来提供SQL和提取结果。的<code>JdbcTemplate</code>类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>运行SQL查询</p>
</li>
<li>
<p>更新语句和存储过程调用</p>
</li>
<li>
<p>执行迭代<code>ResultSet</code>实例和返回参数值的提取。</p>
</li>
<li>
<p>捕获JDBC异常，并将其转换为在<code>org.springframework.dao</code>包。（请参见<a href="#dao-exceptions">一致的异常层次结构</a> 。）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您使用<code>JdbcTemplate</code>对于您的代码，您只需实现回调接口，即可为它们明确定义合同。给定一个<code>Connection</code>由...提供<code>JdbcTemplate</code>类， <code>PreparedStatementCreator</code>回调接口创建一个准备好的语句，提供SQL和任何必要的参数。对于<code>CallableStatementCreator</code>接口，它创建可调用的语句。的<code>RowCallbackHandler</code>接口从a的每一行提取值<code>ResultSet</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>JdbcTemplate</code>在DAO实施中通过直接实例化<code>DataSource</code>参考，或者您可以在Spring IoC容器中对其进行配置，并将其作为Bean参考提供给DAO。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>DataSource</code>应该始终在Spring IoC容器中配置为bean。在第一种情况下，bean被直接提供给服务。在第二种情况下，将其提供给准备好的模板。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此类发出的所有SQL都记录在<code>DEBUG</code>与模板实例的标准类名相对应的类别下的级别（通常为<code>JdbcTemplate</code> ，但是如果您使用的自定义子类，则可能会有所不同<code>JdbcTemplate</code>类）。</p>
</div>
<div class="paragraph">
<p>以下各节提供了一些示例<code>JdbcTemplate</code>用法。这些示例并不详尽地列出了Microsoft公开的所有功能。 <code>JdbcTemplate</code> 。请参阅附带的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html">javadoc</a> 。</p>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples-query"><a class="anchor" href="#jdbc-JdbcTemplate-examples-query"></a>查询（ <code>SELECT</code> ）</h5>
<div class="paragraph">
<p>以下查询获取关系中的行数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val rowCount = jdbcTemplate.queryForObject&lt;Int&gt;("select count(*) from t_actor")!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下查询使用绑定变量：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(
        "select count(*) from t_actor where first_name = ?", Integer.class, "Joe");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val countOfActorsNamedJoe = jdbcTemplate.queryForObject&lt;Int&gt;(
        "select count(*) from t_actor where first_name = ?", arrayOf("Joe"))!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下查询查找<code>String</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String lastName = this.jdbcTemplate.queryForObject(
        "select last_name from t_actor where id = ?",
        new Object[]{1212L}, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val lastName = this.jdbcTemplate.queryForObject&lt;String&gt;(
        "select last_name from t_actor where id = ?",
        arrayOf(1212L))!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下查询查找并填充单个域对象：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Actor actor = this.jdbcTemplate.queryForObject(
        "select first_name, last_name from t_actor where id = ?",
        new Object[]{1212L},
        new RowMapper&lt;Actor&gt;() {
            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
                Actor actor = new Actor();
                actor.setFirstName(rs.getString("first_name"));
                actor.setLastName(rs.getString("last_name"));
                return actor;
            }
        });</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val actor = jdbcTemplate.queryForObject(
            "select first_name, last_name from t_actor where id = ?",
            arrayOf(1212L)) { rs, _ -&gt;
        Actor(rs.getString("first_name"), rs.getString("last_name"))
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下查询查找并填充许多域对象：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">List&lt;Actor&gt; actors = this.jdbcTemplate.query(
        "select first_name, last_name from t_actor",
        new RowMapper&lt;Actor&gt;() {
            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
                Actor actor = new Actor();
                actor.setFirstName(rs.getString("first_name"));
                actor.setLastName(rs.getString("last_name"));
                return actor;
            }
        });</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val actors = jdbcTemplate.query("select first_name, last_name from t_actor") { rs, _ -&gt;
        Actor(rs.getString("first_name"), rs.getString("last_name"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果最后两个代码段确实存在于同一应用程序中，则删除两个代码段中存在的重复是有意义的<code>RowMapper</code>匿名内部类并将其提取到单个类中（通常是<code>static</code>嵌套类），然后可以根据需要由DAO方法引用。例如，最好编写如下的代码片段：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public List&lt;Actor&gt; findAllActors() {
    return this.jdbcTemplate.query( "select first_name, last_name from t_actor", new ActorMapper());
}

private static final class ActorMapper implements RowMapper&lt;Actor&gt; {

    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
        Actor actor = new Actor();
        actor.setFirstName(rs.getString("first_name"));
        actor.setLastName(rs.getString("last_name"));
        return actor;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun findAllActors(): List&lt;Actor&gt; {
    return jdbcTemplate.query("select first_name, last_name from t_actor", ActorMapper())
}

class ActorMapper : RowMapper&lt;Actor&gt; {

    override fun mapRow(rs: ResultSet, rowNum: Int) = Actor(
            rs.getString("first_name"),
            rs.getString("last_name"))
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples-update"><a class="anchor" href="#jdbc-JdbcTemplate-examples-update"></a>更新（ <code>INSERT</code> ， <code>UPDATE</code>和<code>DELETE</code> ）与<code>JdbcTemplate</code></h5>
<div class="paragraph">
<p>您可以使用<code>update(..)</code>执行插入，更新和删除操作的方法。参数值通常作为变量参数提供，或者作为对象数组提供。</p>
</div>
<div class="paragraph">
<p>下面的示例插入一个新条目：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">this.jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">jdbcTemplate.update(
        "insert into t_actor (first_name, last_name) values (?, ?)",
        "Leonor", "Watling")</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例更新现有条目：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">this.jdbcTemplate.update(
        "update t_actor set last_name = ? where id = ?",
        "Banjo", 5276L);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">jdbcTemplate.update(
        "update t_actor set last_name = ? where id = ?",
        "Banjo", 5276L)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例删除一个条目：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">this.jdbcTemplate.update(
        "delete from actor where id = ?",
        Long.valueOf(actorId));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">jdbcTemplate.update("delete from actor where id = ?", actorId.toLong())</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-examples-other"><a class="anchor" href="#jdbc-JdbcTemplate-examples-other"></a>其他<code>JdbcTemplate</code>运作方式</h5>
<div class="paragraph">
<p>您可以使用<code>execute(..)</code>运行任意SQL的方法。因此，该方法通常用于DDL语句。带有回调接口，绑定变量数组等的变体极大地超载了它。以下示例创建一个表：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">jdbcTemplate.execute("create table mytable (id integer, name varchar(100))")</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例调用一个存储过程：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">this.jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        Long.valueOf(unionId));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
        unionId.toLong())</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#jdbc-StoredProcedure">稍后</a>将<a href="#jdbc-StoredProcedure">介绍</a>更复杂的存储过程支持。</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-JdbcTemplate-idioms"><a class="anchor" href="#jdbc-JdbcTemplate-idioms"></a><code>JdbcTemplate</code>最佳实践</h5>
<div class="paragraph">
<p>的实例<code>JdbcTemplate</code>类一旦配置便是线程安全的。这很重要，因为这意味着您可以配置一个实例<code>JdbcTemplate</code>然后将该共享引用安全地注入到多个DAO（或存储库）中。的<code>JdbcTemplate</code>是有状态的，因为它保持了对<code>DataSource</code> ，但此状态不是会话状态。</p>
</div>
<div class="paragraph">
<p>使用时的常见做法<code>JdbcTemplate</code>类（以及相关的<a href="#jdbc-NamedParameterJdbcTemplate"><code>NamedParameterJdbcTemplate</code></a>类）是配置一个<code>DataSource</code>在您的Spring配置文件中，然后依赖注入该共享<code>DataSource</code> bean放入您的DAO类中。的<code>JdbcTemplate</code>在设置器中为<code>DataSource</code> 。这导致类似于以下内容的DAO：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location="jdbc.properties"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>显式配置的替代方法是使用组件扫描和注释支持进行依赖项注入。在这种情况下，您可以使用<code>@Repository</code> （这使其成为组件扫描的候选对象）并注释<code>DataSource</code> setter方法<code>@Autowired</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    @Autowired <i class="conum" data-value="2"></i><b>(2)</b>
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注释类<code>@Repository</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>注释<code>DataSource</code> setter方法<code>@Autowired</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个新的<code>JdbcTemplate</code>与<code>DataSource</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao { <i class="conum" data-value="2"></i><b>(2)</b>

    private val jdbcTemplate = JdbcTemplate(dataSource) <i class="conum" data-value="3"></i><b>(3)</b>

    // JDBC-backed implementations of the methods on the CorporateEventDao follow...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注释类<code>@Repository</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>构造函数的注入<code>DataSource</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>创建一个新的<code>JdbcTemplate</code>与<code>DataSource</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了相应的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- Scans within the base package of the application for @Component classes to configure as beans --&gt;
    &lt;context:component-scan base-package="org.springframework.docs.test" /&gt;

    &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

    &lt;context:property-placeholder location="jdbc.properties"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用Spring的<code>JdbcDaoSupport</code>类和您的各种JDBC支持的DAO类从中扩展，您的子类继承了<code>setDataSource(..)</code>的方法<code>JdbcDaoSupport</code>类。您可以选择是否从此类继承。的<code>JdbcDaoSupport</code>提供类仅是为了方便。</p>
</div>
<div class="paragraph">
<p>无论您选择使用（或不使用）以上哪种模板初始化样式，都几乎不必创建新的<code>JdbcTemplate</code>每次您要运行SQL时都要上课。配置完成后， <code>JdbcTemplate</code>实例是线程安全的。如果您的应用程序访问多个数据库，则可能需要多个数据库<code>JdbcTemplate</code>实例，需要多个<code>DataSources</code>以及随后的多个不同配置<code>JdbcTemplate</code>实例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-NamedParameterJdbcTemplate"><a class="anchor" href="#jdbc-NamedParameterJdbcTemplate"></a> 3.3.2。使用<code>NamedParameterJdbcTemplate</code></h4>
<div class="paragraph">
<p>的<code>NamedParameterJdbcTemplate</code>与使用仅经典占位符（ <code>'?'</code> ）参数。的<code>NamedParameterJdbcTemplate</code>类包装一个<code>JdbcTemplate</code>和代表包装<code>JdbcTemplate</code>做很多工作。本节仅介绍<code>NamedParameterJdbcTemplate</code>不同于<code>JdbcTemplate</code>本身-即使用命名参数对JDBC语句进行编程。以下示例显示了如何使用<code>NamedParameterJdbcTemplate</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

fun countOfActorsByFirstName(firstName: String): Int {
    val sql = "select count(*) from T_ACTOR where first_name = :first_name"
    val namedParameters = MapSqlParameterSource("first_name", firstName)
    return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在分配给的值中使用了命名参数符号<code>sql</code>变量以及插入到<code>namedParameters</code>变量（类型<code>MapSqlParameterSource</code> ）。</p>
</div>
<div class="paragraph">
<p>另外，您可以将命名参数及其对应的值传递给<code>NamedParameterJdbcTemplate</code>通过使用<code>Map</code>风格。其余方法暴露<code>NamedParameterJdbcOperations</code>并由<code>NamedParameterJdbcTemplate</code>类遵循类似的模式，此处不涉及。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>Map</code>基于样式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(*) from T_ACTOR where first_name = :first_name";

    Map&lt;String, String&gt; namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// some JDBC-backed DAO class...
private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

fun countOfActorsByFirstName(firstName: String): Int {
    val sql = "select count(*) from T_ACTOR where first_name = :first_name"
    val namedParameters = mapOf("first_name" to firstName)
    return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一项与<code>NamedParameterJdbcTemplate</code> （并且存在于同一Java包中）是<code>SqlParameterSource</code>接口。您已经在之前的代码片段之一（ <code>MapSqlParameterSource</code>类）。一个<code>SqlParameterSource</code>是命名参数值的来源<code>NamedParameterJdbcTemplate</code> 。的<code>MapSqlParameterSource</code>类是一个简单的实现，它是围绕<code>java.util.Map</code> ，其中键是参数名称，值是参数值。</p>
</div>
<div class="paragraph">
<p>另一个<code>SqlParameterSource</code>实现是<code>BeanPropertySqlParameterSource</code>类。此类包装任意JavaBean（即，遵循<a href="https://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">JavaBean约定</a>的类的实例），并将包装的JavaBean的属性用作命名参数值的源。</p>
</div>
<div class="paragraph">
<p>以下示例显示了典型的JavaBean：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Actor {

    private Long id;
    private String firstName;
    private String lastName;

    public String getFirstName() {
        return this.firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public Long getId() {
        return this.id;
    }

    // setters omitted...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">data class Actor(val id: Long, val firstName: String, val lastName: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例使用<code>NamedParameterJdbcTemplate</code>返回上例所示的类成员的数量：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// some JDBC-backed DAO class...
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    // notice how the named parameters match the properties of the above 'Actor' class
    String sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// some JDBC-backed DAO class...
private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

fun countOfActors(exampleActor: Actor): Int {
    // notice how the named parameters match the properties of the above 'Actor' class
    val sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName"
    val namedParameters = BeanPropertySqlParameterSource(exampleActor)
    return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住<code>NamedParameterJdbcTemplate</code>类包装经典<code>JdbcTemplate</code>模板。如果您需要访问包装好的<code>JdbcTemplate</code>实例访问仅存在于<code>JdbcTemplate</code>类，您可以使用<code>getJdbcOperations()</code>访问包装的方法<code>JdbcTemplate</code>通过<code>JdbcOperations</code>接口。</p>
</div>
<div class="paragraph">
<p>也可以看看<a href="#jdbc-JdbcTemplate-idioms"><code>JdbcTemplate</code>最佳实践</a>的指导方针上使用<code>NamedParameterJdbcTemplate</code>应用程序上下文中的class。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SQLExceptionTranslator"><a class="anchor" href="#jdbc-SQLExceptionTranslator"></a> 3.3.3。使用<code>SQLExceptionTranslator</code></h4>
<div class="paragraph">
<p><code>SQLExceptionTranslator</code>是要由可以在<code>SQLExceptions</code>和春天自己的<code>org.springframework.dao.DataAccessException</code> ，与数据访问策略无关。为了提高精度，实现可以是通用的（例如，使用SQLState代码用于JDBC）或专有的（例如，使用Oracle错误代码）。</p>
</div>
<div class="paragraph">
<p><code>SQLErrorCodeSQLExceptionTranslator</code>是执行<code>SQLExceptionTranslator</code>默认情况下使用。此实现使用特定的供应商代码。它比<code>SQLState</code>实施。错误代码转换基于JavaBean类型类（称为JavaBean）中保存的代码。 <code>SQLErrorCodes</code> 。此类由创建并填充<code>SQLErrorCodesFactory</code> ，（顾名思义）这是一个用于创建的工厂<code>SQLErrorCodes</code>基于名为的配置文件的内容<code>sql-error-codes.xml</code> 。该文件填充有供应商代码，并且基于<code>DatabaseProductName</code>取自<code>DatabaseMetaData</code> 。使用您正在使用的实际数据库的代码。</p>
</div>
<div class="paragraph">
<p>的<code>SQLErrorCodeSQLExceptionTranslator</code>按以下顺序应用匹配规则：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>子类实现的任何自定义转换。通常情况下，提供的混凝土<code>SQLErrorCodeSQLExceptionTranslator</code>使用，因此该规则不适用。仅当您确实提供了子类实现时，它才适用。</p>
</li>
<li>
<p>的任何自定义实现<code>SQLExceptionTranslator</code>作为提供的接口<code>customSqlExceptionTranslator</code>的属性<code>SQLErrorCodes</code>类。</p>
</li>
<li>
<p>实例列表<code>CustomSQLErrorCodesTranslation</code>类（为<code>customTranslations</code>的属性<code>SQLErrorCodes</code>类别）搜索匹配项。</p>
</li>
<li>
<p>错误代码匹配被应用。</p>
</li>
<li>
<p>使用后备翻译器。 <code>SQLExceptionSubclassTranslator</code>是默认的后备翻译器。如果此翻译不可用，则下一个后备翻译器是<code>SQLStateSQLExceptionTranslator</code> 。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>SQLErrorCodesFactory</code>默认情况下用于定义<code>Error</code>代码和自定义异常翻译。在名为的文件中查找它们<code>sql-error-codes.xml</code>从类路径，以及匹配<code>SQLErrorCodes</code>实例基于使用中数据库的数据库元数据中的数据库名称进行定位。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>你可以扩展<code>SQLErrorCodeSQLExceptionTranslator</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {
        if (sqlEx.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlEx);
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class CustomSQLErrorCodesTranslator : SQLErrorCodeSQLExceptionTranslator() {

    override fun customTranslate(task: String, sql: String?, sqlEx: SQLException): DataAccessException? {
        if (sqlEx.errorCode == -12345) {
                return DeadlockLoserDataAccessException(task, sqlEx)
            }
            return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，特定的错误代码（ <code>-12345</code> ）进行翻译，而其他错误则由默认翻译器实现来翻译。要使用此自定义翻译器，您必须将其传递给<code>JdbcTemplate</code>通过方法<code>setExceptionTranslator</code> ，并且您必须使用此<code>JdbcTemplate</code>用于需要此转换器的所有数据访问处理。以下示例显示了如何使用此自定义转换器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {

    // create a JdbcTemplate and set data source
    this.jdbcTemplate = new JdbcTemplate();
    this.jdbcTemplate.setDataSource(dataSource);

    // create a custom translator and set the DataSource for the default translation lookup
    CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
    tr.setDataSource(dataSource);
    this.jdbcTemplate.setExceptionTranslator(tr);

}

public void updateShippingCharge(long orderId, long pct) {
    // use the prepared JdbcTemplate for this update
    this.jdbcTemplate.update("update orders" +
        " set shipping_charge = shipping_charge * ? / 100" +
        " where id = ?", pct, orderId);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// create a JdbcTemplate and set data source
private val jdbcTemplate = JdbcTemplate(dataSource).apply {
    // create a custom translator and set the DataSource for the default translation lookup
    exceptionTranslator = CustomSQLErrorCodesTranslator().apply {
        this.dataSource = dataSource
    }
}

fun updateShippingCharge(orderId: Long, pct: Long) {
    // use the prepared JdbcTemplate for this update
    this.jdbcTemplate!!.update("update orders" +
            " set shipping_charge = shipping_charge * ? / 100" +
            " where id = ?", pct, orderId)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义转换器会传递一个数据源，以便在其中查找错误代码<code>sql-error-codes.xml</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-statements-executing"><a class="anchor" href="#jdbc-statements-executing"></a> 3.3.4。运行声明</h4>
<div class="paragraph">
<p>运行SQL语句需要很少的代码。你需要一个<code>DataSource</code>和一个<code>JdbcTemplate</code> ，包括随附的便捷方法<code>JdbcTemplate</code> 。下面的示例显示了创建一个新表的最小但功能齐全的类需要包含的内容：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void doExecute() {
        this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class ExecuteAStatement(dataSource: DataSource) {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun doExecute() {
        jdbcTemplate.execute("create table mytable (id integer, name varchar(100))")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-statements-querying"><a class="anchor" href="#jdbc-statements-querying"></a> 3.3.5。运行查询</h4>
<div class="paragraph">
<p>一些查询方法返回单个值。要从一行中检索计数或特定值，请使用<code>queryForObject(..)</code> 。后者转换返回的JDBC <code>Type</code>传递给作为参数传入的Java类。如果类型转换无效，则<code>InvalidDataAccessApiUsageException</code>被抛出。以下示例包含两种查询方法，一种用于<code>int</code>和一个查询一个<code>String</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int getCount() {
        return this.jdbcTemplate.queryForObject("select count(*) from mytable", Integer.class);
    }

    public String getName() {
        return this.jdbcTemplate.queryForObject("select name from mytable", String.class);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class RunAQuery(dataSource: DataSource) {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    val count: Int
        get() = jdbcTemplate.queryForObject("select count(*) from mytable")!!

    val name: String?
        get() = jdbcTemplate.queryForObject("select name from mytable")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了单个结果查询方法外，还有几种方法返回一个列表，其中包含查询返回的每一行的条目。最通用的方法是<code>queryForList(..)</code> ，它返回一个<code>List</code>每个元素是一个<code>Map</code>每列包含一个条目，使用列名称作为键。如果在前面的示例中添加一种方法来检索所有行的列表，则可能如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List&lt;Map&lt;String, Object&gt;&gt; getList() {
    return this.jdbcTemplate.queryForList("select * from mytable");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">private val jdbcTemplate = JdbcTemplate(dataSource)

fun getList(): List&lt;Map&lt;String, Any&gt;&gt; {
    return jdbcTemplate.queryForList("select * from mytable")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的列表类似于以下内容：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[{name=Bob, id=1}, {name=Mary, id=2}]</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-updates"><a class="anchor" href="#jdbc-updates"></a> 3.3.6。更新数据库</h4>
<div class="paragraph">
<p>下面的示例更新某个主键的列：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void setName(int id, String name) {
        this.jdbcTemplate.update("update mytable set name = ? where id = ?", name, id);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class ExecuteAnUpdate(dataSource: DataSource) {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun setName(id: Int, name: String) {
        jdbcTemplate.update("update mytable set name = ? where id = ?", name, id)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，SQL语句具有用于行参数的占位符。您可以将参数值作为varargs或作为对象数组传递。因此，您应该在原语包装器类中显式包装原语，或者应该使用自动装箱。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-auto-generated-keys"><a class="anchor" href="#jdbc-auto-generated-keys"></a> 3.3.7。检索自动生成的密钥</h4>
<div class="paragraph">
<p>一个<code>update()</code>便捷方法支持检索数据库生成的主键。此支持是JDBC 3.0标准的一部分。有关详细信息，请参见规范的第13.6章。该方法需要<code>PreparedStatementCreator</code>作为其第一个参数，这就是指定所需插入语句的方式。另一个参数是<code>KeyHolder</code> ，其中包含从更新成功返回时生成的密钥。没有标准的单一方法来创建合适的<code>PreparedStatement</code> （这说明了为什么方法签名就是这样）。以下示例在Oracle上有效，但在其他平台上可能不适用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
    new PreparedStatementCreator() {
        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] {"id"});
            ps.setString(1, name);
            return ps;
        }
    },
    keyHolder);

// keyHolder.getKey() now contains the generated key</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val INSERT_SQL = "insert into my_test (name) values(?)"
val name = "Rob"

val keyHolder = GeneratedKeyHolder()
jdbcTemplate.update({
    it.prepareStatement (INSERT_SQL, arrayOf("id")).apply { setString(1, name) }
}, keyHolder)

// keyHolder.getKey() now contains the generated key</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-connections"><a class="anchor" href="#jdbc-connections"></a> 3.4。控制数据库连接</h3>
<div class="paragraph">
<p>本节内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-datasource">使用<code>DataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-DataSourceUtils">使用<code>DataSourceUtils</code></a></p>
</li>
<li>
<p><a href="#jdbc-SmartDataSource">实施中<code>SmartDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-AbstractDataSource">延伸<code>AbstractDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-SingleConnectionDataSource">使用<code>SingleConnectionDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-DriverManagerDataSource">使用<code>DriverManagerDataSource</code></a></p>
</li>
<li>
<p><a href="#jdbc-TransactionAwareDataSourceProxy">使用<code>TransactionAwareDataSourceProxy</code></a></p>
</li>
<li>
<p><a href="#jdbc-DataSourceTransactionManager">使用<code>DataSourceTransactionManager</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jdbc-datasource"><a class="anchor" href="#jdbc-datasource"></a> 3.4.1。使用<code>DataSource</code></h4>
<div class="paragraph">
<p>Spring通过以下方式获取与数据库的连接<code>DataSource</code> 。一种<code>DataSource</code>是JDBC规范的一部分，是通用的连接工厂。它允许容器或框架从应用程序代码中隐藏连接池和事务管理问题。作为开发人员，您无需了解有关如何连接到数据库的详细信息。这是设置数据源的管理员的责任。您很可能在开发和测试代码时同时担当这两个角色，但是不必一定要知道如何配置生产数据源。</p>
</div>
<div class="paragraph">
<p>使用Spring的JDBC层时，您可以从JNDI获取数据源，也可以使用第三方提供的连接池实现来配置自己的数据源。流行的实现是Apache Jakarta Commons DBCP和C3P0。Spring发行版中的实现仅用于测试目的，不提供池化。</p>
</div>
<div class="paragraph">
<p>本节使用Spring的<code>DriverManagerDataSource</code>实施，稍后将介绍其他几种实施。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您应该使用<code>DriverManagerDataSource</code>类仅用于测试目的，因为它不提供缓冲池，并且在发出多个连接请求时性能不佳。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置一个<code>DriverManagerDataSource</code> ：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>获得与<code>DriverManagerDataSource</code>通常会获得JDBC连接。</p>
</li>
<li>
<p>指定JDBC驱动程序的标准类名，以便<code>DriverManager</code>可以加载驱动程序类。</p>
</li>
<li>
<p>提供在JDBC驱动程序之间变化的URL。（有关正确的值，请参阅驱动程序的文档。）</p>
</li>
<li>
<p>提供用户名和密码以连接到数据库。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置<code>DriverManagerDataSource</code>在Java中：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername("sa");
dataSource.setPassword("");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val dataSource = DriverManagerDataSource().apply {
    setDriverClassName("org.hsqldb.jdbcDriver")
    url = "jdbc:hsqldb:hsql://localhost:"
    username = "sa"
    password = ""
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了相应的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来的两个示例显示了DBCP和C3P0的基本连接和配置。要了解更多有助于控制池功能的选项，请参阅相应连接池实现的产品文档。</p>
</div>
<div class="paragraph">
<p>以下示例显示了DBCP配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了C3P0配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt;
    &lt;property name="driverClass" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="jdbcUrl" value="${jdbc.url}"/&gt;
    &lt;property name="user" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location="jdbc.properties"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DataSourceUtils"><a class="anchor" href="#jdbc-DataSourceUtils"></a> 3.4.2。使用<code>DataSourceUtils</code></h4>
<div class="paragraph">
<p>的<code>DataSourceUtils</code>类是一种方便而强大的帮助程序类，它提供了<code>static</code>从JNDI获取连接并在必要时关闭连接的方法。它支持线程绑定的连接，例如， <code>DataSourceTransactionManager</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SmartDataSource"><a class="anchor" href="#jdbc-SmartDataSource"></a> 3.4.3。实施中<code>SmartDataSource</code></h4>
<div class="paragraph">
<p>的<code>SmartDataSource</code>接口应该由可以提供与关系数据库的连接的类实现。它扩展了<code>DataSource</code>接口，让使用它的类查询给定操作后是否应关闭连接。当您知道需要重用连接时，这种用法很有效。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-AbstractDataSource"><a class="anchor" href="#jdbc-AbstractDataSource"></a> 3.4.4。延伸<code>AbstractDataSource</code></h4>
<div class="paragraph">
<p><code>AbstractDataSource</code>是一个<code>abstract</code> Spring的基类<code>DataSource</code>实现。它实现了所有人都通用的代码<code>DataSource</code>实现。您应该扩展<code>AbstractDataSource</code>如果你自己写课<code>DataSource</code>实施。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SingleConnectionDataSource"><a class="anchor" href="#jdbc-SingleConnectionDataSource"></a> 3.4.5。使用<code>SingleConnectionDataSource</code></h4>
<div class="paragraph">
<p>的<code>SingleConnectionDataSource</code>类是<code>SmartDataSource</code>包装单个的接口<code>Connection</code>每次使用后都不会关闭。这不是多线程功能。</p>
</div>
<div class="paragraph">
<p>如果有任何客户代码调用<code>close</code>在假设存在连接池的情况下（如使用持久性工具时），您应该设置<code>suppressClose</code>财产<code>true</code> 。此设置将返回用于封装物理连接的封闭代理。请注意，您不能再将其转换为本地Oracle <code>Connection</code>或类似的对象。</p>
</div>
<div class="paragraph">
<p><code>SingleConnectionDataSource</code>主要是测试课程。例如，它结合简单的JNDI环境，可以在应用服务器外部轻松测试代码。与之相反<code>DriverManagerDataSource</code> ，它会一直重复使用同一连接，从而避免过多创建物理连接。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DriverManagerDataSource"><a class="anchor" href="#jdbc-DriverManagerDataSource"></a> 3.4.6。使用<code>DriverManagerDataSource</code></h4>
<div class="paragraph">
<p>的<code>DriverManagerDataSource</code>类是标准的实现<code>DataSource</code>接口，通过bean属性配置纯JDBC驱动程序并返回新的接口<code>Connection</code>每次。</p>
</div>
<div class="paragraph">
<p>此实现对于Java EE容器外部的测试和独立环境非常有用，可以作为<code>DataSource</code> Spring IoC容器中的bean或与简单的JNDI环境结合使用。池假设<code>Connection.close()</code>呼叫会关闭连接，因此<code>DataSource</code>感知的持久性代码应该起作用。但是，使用JavaBean风格的连接池（例如<code>commons-dbcp</code> ）非常容易，即使在测试环境中，也总是总是首选使用这样的连接池<code>DriverManagerDataSource</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-TransactionAwareDataSourceProxy"><a class="anchor" href="#jdbc-TransactionAwareDataSourceProxy"></a> 3.4.7。使用<code>TransactionAwareDataSourceProxy</code></h4>
<div class="paragraph">
<p><code>TransactionAwareDataSourceProxy</code>是目标的代理<code>DataSource</code> 。代理包装该目标<code>DataSource</code>增强对Spring管理的交易的认识。在这方面，它类似于事务性JNDI <code>DataSource</code> ，由Java EE服务器提供。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">很少需要使用此类，除非必须调用已经存在的代码并通过标准JDBC进行传递<code>DataSource</code>接口实现。在这种情况下，您仍然可以使该代码可用，同时使该代码参与Spring托管的事务。通常最好使用更高级别的资源管理抽象来编写自己的新代码，例如<code>JdbcTemplate</code>要么<code>DataSourceUtils</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.html"><code>TransactionAwareDataSourceProxy</code></a>有关更多详细信息，请参见javadoc。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-DataSourceTransactionManager"><a class="anchor" href="#jdbc-DataSourceTransactionManager"></a> 3.4.8。使用<code>DataSourceTransactionManager</code></h4>
<div class="paragraph">
<p>的<code>DataSourceTransactionManager</code>类是一个<code>PlatformTransactionManager</code>单个JDBC数据源的实现。它将JDBC连接从指定的数据源绑定到当前正在执行的线程，可能允许每个数据源一个线程连接。</p>
</div>
<div class="paragraph">
<p>需要应用程序代码才能通过以下方式检索JDBC连接<code>DataSourceUtils.getConnection(DataSource)</code>代替Java EE的标准<code>DataSource.getConnection</code> 。它不受限制地抛出<code>org.springframework.dao</code>例外而不是检查<code>SQLExceptions</code> 。所有框架类（例如<code>JdbcTemplate</code> ）隐式使用此策略。如果不与该事务管理器一起使用，则查找策略的行为与普通策略完全相同。因此，可以在任何情况下使用它。</p>
</div>
<div class="paragraph">
<p>的<code>DataSourceTransactionManager</code>类支持自定义隔离级别和超时，这些隔离级别和超时将作为适当的JDBC语句查询超时应用。为了支持后者，应用程序代码必须使用<code>JdbcTemplate</code>或致电<code>DataSourceUtils.applyTransactionTimeout(..)</code>每个创建的语句的方法。</p>
</div>
<div class="paragraph">
<p>您可以使用此实现代替<code>JtaTransactionManager</code>在单资源情况下，因为它不需要容器支持JTA。只要您坚持要求的连接查找模式，就可以在两者之间进行切换只是配置问题。JTA不支持自定义隔离级别。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-advanced-jdbc"><a class="anchor" href="#jdbc-advanced-jdbc"></a> 3.5。JDBC批处理操作</h3>
<div class="paragraph">
<p>如果将多个调用批处理到同一条准备好的语句，则大多数JDBC驱动程序都会提高性能。通过将更新分组，可以限制到数据库的往返次数。</p>
</div>
<div class="sect3">
<h4 id="jdbc-batch-classic"><a class="anchor" href="#jdbc-batch-classic"></a> 3.5.1。基本批处理操作<code>JdbcTemplate</code></h4>
<div class="paragraph">
<p>你完成<code>JdbcTemplate</code>通过实现特殊接口的两种方法进行批处理， <code>BatchPreparedStatementSetter</code> ，并将该实现作为第二个参数传递给您<code>batchUpdate</code>方法调用。您可以使用<code>getBatchSize</code>提供当前批次大小的方法。您可以使用<code>setValues</code>设置准备好的语句的参数值的方法。此方法称为您在<code>getBatchSize</code>呼叫。以下示例更新了<code>actor</code>表基于列表中的条目，整个列表用作批处理：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        return this.jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                new BatchPreparedStatementSetter() {
                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                        ps.setString(1, actors.get(i).getFirstName());
                        ps.setString(2, actors.get(i).getLastName());
                        ps.setLong(3, actors.get(i).getId().longValue());
                    }
                    public int getBatchSize() {
                        return actors.size();
                    }
                });
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): IntArray {
        return jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                object: BatchPreparedStatementSetter {
                    override fun setValues(ps: PreparedStatement, i: Int) {
                        ps.setString(1, actors[i].firstName)
                        ps.setString(2, actors[i].lastName)
                        ps.setLong(3, actors[i].id)
                    }

                    override fun getBatchSize() = actors.size
                })
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您处理更新流或从文件中读取文件，则可能具有首选的批处理大小，但最后一批可能没有该数量的条目。在这种情况下，您可以使用<code>InterruptibleBatchPreparedStatementSetter</code>界面，一旦输入源耗尽，您就可以中断批次。的<code>isBatchExhausted</code>方法可让您发出批处理结束的信号。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-batch-list"><a class="anchor" href="#jdbc-batch-list"></a> 3.5.2。具有对象列表的批处理操作</h4>
<div class="paragraph">
<p>这俩<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>提供了提供批处理更新的另一种方法。无需实现特殊的批处理接口，而是将调用中的所有参数值作为列表提供。框架遍历这些值并使用内部的准备好的语句设置器。API会有所不同，具体取决于您是否使用命名参数。对于命名参数，您需要提供一个数组<code>SqlParameterSource</code> ，该批次的每个成员都有一个条目。您可以使用<code>SqlParameterSourceUtils.createBatch</code>创建此数组的便捷方法，传入一个bean样式的对象数组（带有与参数对应的getter方法）， <code>String</code>键<code>Map</code>实例（包含相应的参数作为值），或两者的混合。</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用命名参数的批量更新：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private NamedParameterTemplate namedParameterJdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
    }

    public int[] batchUpdate(List&lt;Actor&gt; actors) {
        return this.namedParameterJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                SqlParameterSourceUtils.createBatch(actors));
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): IntArray {
        return this.namedParameterJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                SqlParameterSourceUtils.createBatch(actors));
    }

        // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于使用经典SQL语句<code>?</code>占位符，则传入包含包含更新值的对象数组的列表。该对象数组必须在SQL语句中的每个占位符处都有一个条目，并且它们的顺序必须与SQL语句中定义的顺序相同。</p>
</div>
<div class="paragraph">
<p>下面的示例与前面的示例相同，不同之处在于它使用经典的JDBC <code>?</code>占位符：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        List&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;();
        for (Actor actor : actors) {
            Object[] values = new Object[] {
                    actor.getFirstName(), actor.getLastName(), actor.getId()};
            batch.add(values);
        }
        return this.jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                batch);
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): IntArray {
        val batch = mutableListOf&lt;Array&lt;Any&gt;&gt;()
        for (actor in actors) {
            batch.add(arrayOf(actor.firstName, actor.lastName, actor.id))
        }
        return jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?", batch)
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们前面介绍的所有批处理更新方法都返回一个<code>int</code>包含每个批处理条目的受影响行数的数组。此计数由JDBC驱动程序报告。如果该计数不可用，则JDBC驱动程序将返回值<code>-2</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在这种情况下，通过自动设置基础值<code>PreparedStatement</code> ，需要从给定的Java类型派生每个值的对应JDBC类型。尽管这通常效果很好，但存在潜在的问题（例如，包含Map <code>null</code>值）。默认情况下，Spring调用<code>ParameterMetaData.getParameterType</code>在这种情况下，使用JDBC驱动程序可能会很昂贵。您应该使用最新的驱动程序版本，并考虑设置<code>spring.jdbc.getParameterType.ignore</code>财产<code>true</code> （作为JVM系统属性或<code>spring.properties</code>如果遇到性能问题（例如，Oracle 12c（SPR-16139）上的报告），请在类路径的根目录中找到该文件。</p>
</div>
<div class="paragraph">
<p>或者，您可以考虑通过“ BatchPreparedStatementSetter”（如前所示），通过给<object[]>基于</object[]> “ List <object[]>”的调用</object[]>的显式类型数组<object[]>，通过在自定义“ MapSqlParameterSource”实例上的“ registerSqlType”调用</object[]>来显式指定相应的JDBC类型。 <object[]>，或者通过'BeanPropertySqlParameterSource'从Java声明的属性类型派生SQL类型，即使对于null值也是如此。</object[]></p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-batch-multi"><a class="anchor" href="#jdbc-batch-multi"></a> 3.5.3。具有多个批次的批次操作</h4>
<div class="paragraph">
<p>前面的批处理更新示例处理的批处理太大，以至于您想将它们分成几个较小的批处理。您可以使用前面提到的方法，通过多次调用<code>batchUpdate</code>方法，但是现在有一种更方便的方法。除SQL语句外，此方法还需要<code>Collection</code>包含参数的对象，每个批次要进行的更新数量以及<code>ParameterizedPreparedStatementSetter</code>设置准备好的语句的参数值。框架遍历提供的值，并将更新调用分成指定大小的批处理。</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用100的批量大小的批量更新：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[][] batchUpdate(final Collection&lt;Actor&gt; actors) {
        int[][] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                actors,
                100,
                new ParameterizedPreparedStatementSetter&lt;Actor&gt;() {
                    public void setValues(PreparedStatement ps, Actor argument) throws SQLException {
                        ps.setString(1, argument.getFirstName());
                        ps.setString(2, argument.getLastName());
                        ps.setLong(3, argument.getId().longValue());
                    }
                });
        return updateCounts;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)

    fun batchUpdate(actors: List&lt;Actor&gt;): Array&lt;IntArray&gt; {
        return jdbcTemplate.batchUpdate(
                    "update t_actor set first_name = ?, last_name = ? where id = ?",
                    actors, 100) { ps, argument -&gt;
            ps.setString(1, argument.firstName)
            ps.setString(2, argument.lastName)
            ps.setLong(3, argument.id)
        }
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此调用的批处理更新方法返回一个数组<code>int</code>包含每个批处理的数组条目的数组，以及每个更新受影响的行数的数组。顶级数组的长度指示已执行的批处理数，第二级数组的长度指示该批处理中的更新数。每个批次中的更新数量应该是为所有批次提供的批次大小（最后一个可能更少），这取决于所提供的更新对象的总数。每个更新语句的更新计数是JDBC驱动程序报告的计数。如果该计数不可用，则JDBC驱动程序将返回值<code>-2</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-simple-jdbc"><a class="anchor" href="#jdbc-simple-jdbc"></a> 3.6。使用简化JDBC操作<code>SimpleJdbc</code>班级</h3>
<div class="paragraph">
<p>的<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>通过利用可通过JDBC驱动程序检索的数据库元数据，类提供了简化的配置。这意味着您可以更少地进行前期配置，但是如果您希望在代码中提供所有详细信息，则可以覆盖或关闭元数据处理。</p>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-insert-1"><a class="anchor" href="#jdbc-simple-jdbc-insert-1"></a> 3.6.1。使用插入数据<code>SimpleJdbcInsert</code></h4>
<div class="paragraph">
<p>我们先来看一下<code>SimpleJdbcInsert</code>类，使用最少的配置选项。您应该实例化<code>SimpleJdbcInsert</code>在数据访问层的初始化方法中。在此示例中，初始化方法是<code>setDataSource</code>方法。您不需要子类化<code>SimpleJdbcInsert</code>类。相反，您可以创建一个新实例并通过使用<code>withTableName</code>方法。此类的配置方法遵循<code>fluid</code>返回实例的样式<code>SimpleJdbcInsert</code> ，它使您可以链接所有配置方法。以下示例仅使用一种配置方法（我们稍后将显示多种方法的示例）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3);
        parameters.put("id", actor.getId());
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        insertActor.execute(parameters);
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val insertActor = SimpleJdbcInsert(dataSource).withTableName("t_actor")

    fun add(actor: Actor) {
        val parameters = mutableMapOf&lt;String, Any&gt;()
        parameters["id"] = actor.id
        parameters["first_name"] = actor.firstName
        parameters["last_name"] = actor.lastName
        insertActor.execute(parameters)
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>execute</code>这里使用的方法很简单<code>java.util.Map</code>作为其唯一参数。这里要注意的重要事项是用于<code>Map</code>必须与数据库中定义的表的列名匹配。这是因为我们读取元数据来构造实际的insert语句。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-insert-2"><a class="anchor" href="#jdbc-simple-jdbc-insert-2"></a> 3.6.2。通过使用检索自动生成的密钥<code>SimpleJdbcInsert</code></h4>
<div class="paragraph">
<p>下一个示例使用与前面的示例相同的插入内容，但是不传递<code>id</code> ，它会检索自动生成的密钥并将其设置在新的<code>Actor</code>宾语。当它创建<code>SimpleJdbcInsert</code> ，除了指定表名外，还使用<code>usingGeneratedKeyColumns</code>方法。以下清单显示了它的工作方式：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor").usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = mapOf(
                "first_name" to actor.firstName,
                "last_name" to actor.lastName)
        val newId = insertActor.executeAndReturnKey(parameters);
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用第二种方法运行插入时的主要区别在于，您不添加<code>id</code>到<code>Map</code> ，然后您将<code>executeAndReturnKey</code>方法。这返回一个<code>java.lang.Number</code>您可以使用该对象创建域类中使用的数字类型的实例。您不能依赖所有数据库在这里返回特定的Java类。 <code>java.lang.Number</code>是您可以依赖的基类。如果您有多个自动生成的列，或者生成的值是非数字的，则可以使用<code>KeyHolder</code>从<code>executeAndReturnKeyHolder</code>方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-insert-3"><a class="anchor" href="#jdbc-simple-jdbc-insert-3"></a> 3.6.3。指定一个列<code>SimpleJdbcInsert</code></h4>
<div class="paragraph">
<p>您可以通过指定列名列表来限制插入的列<code>usingColumns</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingColumns("first_name", "last_name")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor")
            .usingColumns("first_name", "last_name")
            .usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = mapOf(
                "first_name" to actor.firstName,
                "last_name" to actor.lastName)
        val newId = insertActor.executeAndReturnKey(parameters);
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>插入的执行与依靠元数据确定要使用的列的执行相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-parameters"><a class="anchor" href="#jdbc-simple-jdbc-parameters"></a> 3.6.4。使用<code>SqlParameterSource</code>提供参数值</h4>
<div class="paragraph">
<p>用一个<code>Map</code>提供参数值可以很好地工作，但这不是最方便使用的类。Spring提供了一些实现<code>SqlParameterSource</code>您可以改用的界面。第一个是<code>BeanPropertySqlParameterSource</code> ，如果您有一个包含值的JavaBean兼容类，这是一个非常方便的类。它使用相应的getter方法提取参数值。以下示例显示了如何使用<code>BeanPropertySqlParameterSource</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor")
            .usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = BeanPropertySqlParameterSource(actor)
        val newId = insertActor.executeAndReturnKey(parameters)
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种选择是<code>MapSqlParameterSource</code>类似于<code>Map</code>但是提供了更方便<code>addValue</code>可以链接的方法。以下示例显示了如何使用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.insertActor = new SimpleJdbcInsert(dataSource)
                .withTableName("t_actor")
                .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("first_name", actor.getFirstName())
                .addValue("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val insertActor = SimpleJdbcInsert(dataSource)
            .withTableName("t_actor")
            .usingGeneratedKeyColumns("id")

    fun add(actor: Actor): Actor {
        val parameters = MapSqlParameterSource()
                    .addValue("first_name", actor.firstName)
                    .addValue("last_name", actor.lastName)
        val newId = insertActor.executeAndReturnKey(parameters)
        return actor.copy(id = newId.toLong())
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，配置是相同的。只有执行代码才能更改为使用这些替代输入类。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-1"><a class="anchor" href="#jdbc-simple-jdbc-call-1"></a> 3.6.5。使用以下命令调用存储过程<code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>的<code>SimpleJdbcCall</code>类使用数据库中的元数据来查找名称<code>in</code>和<code>out</code>参数，这样您就不必显式声明它们。如果愿意，可以声明参数，也可以声明参数（例如<code>ARRAY</code>要么<code>STRUCT</code> ）没有自动映射到Java类的功能。第一个示例显示了一个简单的过程，该过程仅返回标量值<code>VARCHAR</code>和<code>DATE</code>从MySQL数据库格式化。示例过程读取指定的actor条目并返回<code>first_name</code> ， <code>last_name</code>和<code>birth_date</code>列的形式<code>out</code>参数。以下清单显示了第一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql" data-lang="sql">CREATE PROCEDURE read_actor (
    IN in_id INTEGER,
    OUT out_first_name VARCHAR(100),
    OUT out_last_name VARCHAR(100),
    OUT out_birth_date DATE)
BEGIN
    SELECT first_name, last_name, birth_date
    INTO out_first_name, out_last_name, out_birth_date
    FROM t_actor where id = in_id;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>in_id</code>参数包含<code>id</code>您正在查找的演员的形象。的<code>out</code>参数返回从表中读取的数据。</p>
</div>
<div class="paragraph">
<p>您可以声明<code>SimpleJdbcCall</code>以类似于声明的方式<code>SimpleJdbcInsert</code> 。您应该在数据访问层的初始化方法中实例化并配置该类。相比<code>StoredProcedure</code>类，则无需创建子类，也无需声明可在数据库元数据中查找的参数。以下示例<code>SimpleJdbcCall</code>配置使用前面的存储过程（唯一的配置选项，除了<code>DataSource</code> ，是存储过程的名称）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.procReadActor = new SimpleJdbcCall(dataSource)
                .withProcedureName("read_actor");
    }

    public Actor readActor(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        Map out = procReadActor.execute(in);
        Actor actor = new Actor();
        actor.setId(id);
        actor.setFirstName((String) out.get("out_first_name"));
        actor.setLastName((String) out.get("out_last_name"));
        actor.setBirthDate((Date) out.get("out_birth_date"));
        return actor;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource)
    private val procReadActor = SimpleJdbcCall(dataSource)
            .withProcedureName("read_actor")


    fun readActor(id: Long): Actor {
        val source = MapSqlParameterSource().addValue("in_id", id)
        val output = procReadActor.execute(source)
        return Actor(
                id,
                output["out_first_name"] as String,
                output["out_last_name"] as String,
                output["out_birth_date"] as Date)
    }

        // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您为执行调用编写的代码涉及创建一个<code>SqlParameterSource</code>包含IN参数。您必须为输入值提供的名称与存储过程中声明的参数名称的名称匹配。大小写不必匹配，因为您使用元数据来确定在存储过程中应如何引用数据库对象。源中为存储过程指定的内容不一定是存储过程在数据库中存储的方式。一些数据库将名称转换为全部大写，而其他数据库则使用小写或指定的大小写。</p>
</div>
<div class="paragraph">
<p>的<code>execute</code>方法采用IN参数并返回<code>Map</code>包含任何<code>out</code>由名称键入的参数，如存储过程中所指定。在这种情况下，它们是<code>out_first_name</code> ， <code>out_last_name</code>和<code>out_birth_date</code> 。</p>
</div>
<div class="paragraph">
<p>最后一部分<code>execute</code>方法创建一个<code>Actor</code>用于返回检索到的数据的实例。同样，重要的是使用<code>out</code>在存储过程中声明的参数。另外，名称中的大小写<code>out</code>结果图中存储的参数与<code>out</code>数据库中的参数名称，在数据库之间可能有所不同。为了使代码更具可移植性，您应该执行不区分大小写的查找或指示Spring使用<code>LinkedCaseInsensitiveMap</code> 。为此，您可以创建自己的<code>JdbcTemplate</code>并设置<code>setResultsMapCaseInsensitive</code>财产<code>true</code> 。然后你可以通过这个定制<code>JdbcTemplate</code>实例到您的构造函数中<code>SimpleJdbcCall</code> 。以下示例显示了此配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_actor");
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private var procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
        isResultsMapCaseInsensitive = true
    }).withProcedureName("read_actor")

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过执行此操作，可以避免在用于返回的名称的情况下发生冲突<code>out</code>参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-2"><a class="anchor" href="#jdbc-simple-jdbc-call-2"></a> 3.6.6。明确声明要用于的参数<code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>在本章的前面，我们描述了如何从元数据推导出参数，但是如果需要，可以显式声明它们。您可以通过创建和配置来实现<code>SimpleJdbcCall</code>与<code>declareParameters</code>方法，它需要可变数量的<code>SqlParameter</code>对象作为输入。有关如何定义广告代码的详细信息，请参见<a href="#jdbc-params">下一部分</a> <code>SqlParameter</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用的数据库不是Spring支持的数据库，则必须进行显式声明。当前，Spring支持针对以下数据库的存储过程调用的元数据查找：Apache Derby，DB2，MySQL，Microsoft SQL Server，Oracle和Sybase。我们还支持MySQL，Microsoft SQL Server和Oracle存储功能的元数据查找。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以选择显式声明一个，一些或所有参数。在未显式声明参数的地方，仍使用参数元数据。要绕过对潜在参数的元数据查找的所有处理并仅使用声明的参数，可以调用该方法<code>withoutProcedureColumnMetaDataAccess</code>作为声明的一部分。假设您为数据库函数声明了两个或多个不同的调用签名。在这种情况下，您致电<code>useInParameterNames</code>指定要包含给定签名的IN参数名称的列表。</p>
</div>
<div class="paragraph">
<p>下面的示例显示一个完全声明的过程调用，并使用前面示例中的信息：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_actor")
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames("in_id")
                .declareParameters(
                        new SqlParameter("in_id", Types.NUMERIC),
                        new SqlOutParameter("out_first_name", Types.VARCHAR),
                        new SqlOutParameter("out_last_name", Types.VARCHAR),
                        new SqlOutParameter("out_birth_date", Types.DATE)
                );
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

        private val procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
            isResultsMapCaseInsensitive = true
        }).withProcedureName("read_actor")
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames("in_id")
                .declareParameters(
                        SqlParameter("in_id", Types.NUMERIC),
                        SqlOutParameter("out_first_name", Types.VARCHAR),
                        SqlOutParameter("out_last_name", Types.VARCHAR),
                        SqlOutParameter("out_birth_date", Types.DATE)
    )

        // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个示例的执行和最终结果相同。第二个示例明确指定所有详细信息，而不是依赖于元数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-params"><a class="anchor" href="#jdbc-params"></a> 3.6.7。如何定义<code>SqlParameters</code></h4>
<div class="paragraph">
<p>定义参数<code>SimpleJdbc</code>您可以使用类以及RDBMS操作类（在<a href="#jdbc-object">JDBC操作建模为Java对象中发现</a> ）中使用<code>SqlParameter</code>或其子类别之一。为此，通常在构造函数中指定参数名称和SQL类型。通过使用指定SQL类型<code>java.sql.Types</code>常数。在本章的前面，我们看到了类似于以下内容的声明：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">new SqlParameter("in_id", Types.NUMERIC),
new SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">SqlParameter("in_id", Types.NUMERIC),
SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行<code>SqlParameter</code>声明一个IN参数。您可以使用IN参数来进行存储过程调用和查询。 <code>SqlQuery</code>及其子类（在<a href="#jdbc-SqlQuery">理解中找到<code>SqlQuery</code></a> ）。</p>
</div>
<div class="paragraph">
<p>第二行（带有<code>SqlOutParameter</code> ）声明<code>out</code>存储过程调用中使用的参数。还有一个<code>SqlInOutParameter</code>对于<code>InOut</code>参数（为过程提供IN值并返回值的参数）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">仅将参数声明为<code>SqlParameter</code>和<code>SqlInOutParameter</code>用于提供输入值。这不同于<code>StoredProcedure</code>类（出于向后兼容的原因），它允许为声明为的参数提供输入值<code>SqlOutParameter</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于IN参数，除了名称和SQL类型之外，还可以为数字数据指定小数位，或者为自定义数据库类型指定类型名。对于<code>out</code>参数，您可以提供<code>RowMapper</code>处理从a返回的行的映射<code>REF</code>光标。另一种选择是指定一个<code>SqlReturnType</code>这提供了定义返回值的自定义处理的机会。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-3"><a class="anchor" href="#jdbc-simple-jdbc-call-3"></a> 3.6.8。通过使用调用存储的函数<code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>可以使用与调用存储过程几乎相同的方式来调用存储函数，除了提供函数名而不是过程名。您使用<code>withFunctionName</code>方法作为配置的一部分，以指示您要调用函数，并生成函数调用的相应字符串。专门的执行调用（ <code>executeFunction</code> ）用于执行函数，它以指定类型的对象的形式返回函数的返回值，这意味着您不必从结果图中检索返回值。一种类似的便捷方法（命名为<code>executeObject</code> ）也可用于只有一个<code>out</code>参数。以下示例（对于MySQL）基于名为的存储函数<code>get_actor_name</code>返回演员的全名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql" data-lang="sql">CREATE FUNCTION get_actor_name (in_id INTEGER)
RETURNS VARCHAR(200) READS SQL DATA
BEGIN
    DECLARE out_name VARCHAR(200);
    SELECT concat(first_name, ' ', last_name)
        INTO out_name
        FROM t_actor where id = in_id;
    RETURN out_name;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要调用此函数，我们再次创建一个<code>SimpleJdbcCall</code>在初始化方法中，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private JdbcTemplate jdbcTemplate;
    private SimpleJdbcCall funcGetActorName;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)
                .withFunctionName("get_actor_name");
    }

    public String getActorName(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id);
        String name = funcGetActorName.executeFunction(String.class, in);
        return name;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

    private val jdbcTemplate = JdbcTemplate(dataSource).apply {
        isResultsMapCaseInsensitive = true
    }
    private val funcGetActorName = SimpleJdbcCall(jdbcTemplate)
            .withFunctionName("get_actor_name")

    fun getActorName(id: Long): String {
        val source = MapSqlParameterSource().addValue("in_id", id)
        return funcGetActorName.executeFunction(String::class.java, source)
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>executeFunction</code>使用的方法返回一个<code>String</code>包含函数调用的返回值。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-simple-jdbc-call-4"><a class="anchor" href="#jdbc-simple-jdbc-call-4"></a> 3.6.9。返回一个<code>ResultSet</code>或来自<code>SimpleJdbcCall</code></h4>
<div class="paragraph">
<p>调用返回结果集的存储过程或函数有点棘手。一些数据库在JDBC结果处理期间返回结果集，而另一些则需要显式注册<code>out</code>特定类型的参数。两种方法都需要进行额外的处理才能遍历结果集并处理返回的行。随着<code>SimpleJdbcCall</code> ，您可以使用<code>returningResultSet</code>方法并声明一个<code>RowMapper</code>用于特定参数的实现。如果在结果处理过程中返回了结果集，则没有定义名称，因此返回的结果必须与您声明结果的顺序匹配。 <code>RowMapper</code>实现。指定的名称仍用于将处理后的结果列表存储在从<code>execute</code>声明。</p>
</div>
<div class="paragraph">
<p>下一个示例（对于MySQL）使用存储过程，该存储过程不使用IN参数，并从<code>t_actor</code>表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql" data-lang="sql">CREATE PROCEDURE read_all_actors()
BEGIN
 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要调用此过程，您可以声明<code>RowMapper</code> 。因为您要映射到的类遵循JavaBean规则，所以可以使用<code>BeanPropertyRowMapper</code>通过传入所需的类以映射到<code>newInstance</code>方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class JdbcActorDao implements ActorDao {

    private SimpleJdbcCall procReadAllActors;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("read_all_actors")
                .returningResultSet("actors",
                BeanPropertyRowMapper.newInstance(Actor.class));
    }

    public List getActorsList() {
        Map m = procReadAllActors.execute(new HashMap&lt;String, Object&gt;(0));
        return (List) m.get("actors");
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class JdbcActorDao(dataSource: DataSource) : ActorDao {

        private val procReadAllActors = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
            isResultsMapCaseInsensitive = true
        }).withProcedureName("read_all_actors")
                .returningResultSet("actors",
                        BeanPropertyRowMapper.newInstance(Actor::class.java))

    fun getActorsList(): List&lt;Actor&gt; {
        val m = procReadAllActors.execute(mapOf&lt;String, Any&gt;())
        return m["actors"] as List&lt;Actor&gt;
    }

    // ... additional methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>execute</code>来电传空<code>Map</code> ，因为此调用没有任何参数。然后从结果图中检索参与者列表，并将其返回给调用者。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-object"><a class="anchor" href="#jdbc-object"></a> 3.7。将JDBC操作建模为Java对象</h3>
<div class="paragraph">
<p>的<code>org.springframework.jdbc.object</code>软件包包含一些类，这些类使您可以以更加面向对象的方式访问数据库。例如，您可以执行查询并以包含业务对象的列表的形式返回结果，这些业务对象的关系列数据映射到业务对象的属性。您还可以运行存储过程并运行update，delete和insert语句。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>许多Spring开发人员认为，以下所述的各种RDBMS操作类（ <a href="#jdbc-StoredProcedure"><code>StoredProcedure</code></a>类）通常可以用直<code>JdbcTemplate</code>电话。通常，编写一个DAO方法会比较简单，该方法会在<code>JdbcTemplate</code>直接（而不是将查询封装为完整的类）。</p>
</div>
<div class="paragraph">
<p>但是，如果您通过使用RDBMS操作类获得可测量的价值，则应继续使用这些类。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="jdbc-SqlQuery"><a class="anchor" href="#jdbc-SqlQuery"></a> 3.7.1。理解<code>SqlQuery</code></h4>
<div class="paragraph">
<p><code>SqlQuery</code>是封装SQL查询的可重用，线程安全的类。子类必须实现<code>newRowMapper(..)</code>提供一个方法<code>RowMapper</code>实例，该实例可以通过迭代遍历而获得的每行创建一个对象<code>ResultSet</code>在执行查询期间创建的代码。的<code>SqlQuery</code>该类很少直接使用，因为<code>MappingSqlQuery</code>子类为将行映射到Java类提供了更为方便的实现。扩展的其他实现<code>SqlQuery</code>是<code>MappingSqlQueryWithParameters</code>和<code>UpdatableSqlQuery</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-MappingSqlQuery"><a class="anchor" href="#jdbc-MappingSqlQuery"></a> 3.7.2。使用<code>MappingSqlQuery</code></h4>
<div class="paragraph">
<p><code>MappingSqlQuery</code>是可重用的查询，其中具体子类必须实现抽象<code>mapRow(..)</code>转换提供的每一行的方法<code>ResultSet</code>放入指定类型的对象中。以下示例显示了一个自定义查询，该查询映射了来自<code>t_actor</code>与实例的关系<code>Actor</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ActorMappingQuery extends MappingSqlQuery&lt;Actor&gt; {

    public ActorMappingQuery(DataSource ds) {
        super(ds, "select id, first_name, last_name from t_actor where id = ?");
        declareParameter(new SqlParameter("id", Types.INTEGER));
        compile();
    }

    @Override
    protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {
        Actor actor = new Actor();
        actor.setId(rs.getLong("id"));
        actor.setFirstName(rs.getString("first_name"));
        actor.setLastName(rs.getString("last_name"));
        return actor;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ActorMappingQuery(ds: DataSource) : MappingSqlQuery&lt;Actor&gt;(ds, "select id, first_name, last_name from t_actor where id = ?") {

    init {
        declareParameter(SqlParameter("id", Types.INTEGER))
        compile()
    }

    override fun mapRow(rs: ResultSet, rowNumber: Int) = Actor(
            rs.getLong("id"),
            rs.getString("first_name"),
            rs.getString("last_name")
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>全班延伸<code>MappingSqlQuery</code>用参数化<code>Actor</code>类型。此客户查询的构造函数采用<code>DataSource</code>作为唯一参数。在此构造函数中，您可以使用<code>DataSource</code>以及应执行以检索此查询行的SQL。该SQL用于创建一个<code>PreparedStatement</code> ，因此它可能包含在执行期间要传递的任何参数的占位符。您必须使用<code>declareParameter</code>方法传递<code>SqlParameter</code> 。的<code>SqlParameter</code>具有名称，并且JDBC类型如<code>java.sql.Types</code> 。定义所有参数后，您可以调用<code>compile()</code>方法，以便可以准备语句并在以后运行。此类在编译后是线程安全的，因此，只要在初始化DAO时创建这些实例，就可以将它们保留为实例变量并可以重用。下面的示例演示如何定义此类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private ActorMappingQuery actorMappingQuery;

@Autowired
public void setDataSource(DataSource dataSource) {
    this.actorMappingQuery = new ActorMappingQuery(dataSource);
}

public Customer getCustomer(Long id) {
    return actorMappingQuery.findObject(id);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">private val actorMappingQuery = ActorMappingQuery(dataSource)

fun getCustomer(id: Long) = actorMappingQuery.findObject(id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的方法使用<code>id</code>作为唯一参数传入。由于我们只希望返回一个对象，因此我们将<code>findObject</code>方便的方法<code>id</code>作为参数。如果我们有一个返回对象列表并采用其他参数的查询，则可以使用其中一个<code>execute</code>接受以varargs形式传递的参数值数组的方法。以下示例显示了这种方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public List&lt;Actor&gt; searchForActors(int age, String namePattern) {
    List&lt;Actor&gt; actors = actorSearchMappingQuery.execute(age, namePattern);
    return actors;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">fun searchForActors(age: Int, namePattern: String) =
            actorSearchMappingQuery.execute(age, namePattern)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-SqlUpdate"><a class="anchor" href="#jdbc-SqlUpdate"></a> 3.7.3。使用<code>SqlUpdate</code></h4>
<div class="paragraph">
<p>的<code>SqlUpdate</code>类封装了SQL更新。与查询一样，更新对象是可重用的，并且与所有对象一样<code>RdbmsOperation</code>类，更新可以具有参数，并且在SQL中定义。此类提供了许多<code>update(..)</code>类似于<code>execute(..)</code>查询对象的方法。的<code>SQLUpdate</code>课堂是具体的。可以将其子类化-例如，添加自定义更新方法。但是，您不必继承<code>SqlUpdate</code>类，因为可以通过设置SQL和声明参数来轻松地对其进行参数化。以下示例创建一个名为的自定义更新方法<code>execute</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.sql.Types;
import javax.sql.DataSource;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating extends SqlUpdate {

    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter("creditRating", Types.NUMERIC));
        declareParameter(new SqlParameter("id", Types.NUMERIC));
        compile();
    }

    /**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */
    public int execute(int id, int rating) {
        return update(rating, id);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import java.sql.Types
import javax.sql.DataSource
import org.springframework.jdbc.core.SqlParameter
import org.springframework.jdbc.<code>object</code>.SqlUpdate

class UpdateCreditRating(ds: DataSource) : SqlUpdate() {

    init {
        setDataSource(ds)
        sql = "update customer set credit_rating = ? where id = ?"
        declareParameter(SqlParameter("creditRating", Types.NUMERIC))
        declareParameter(SqlParameter("id", Types.NUMERIC))
        compile()
    }

    /**
    * @param id for the Customer to be updated
    * @param rating the new value for credit rating
    * @return number of rows updated
    */
    fun execute(id: Int, rating: Int): Int {
        return update(rating, id)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-StoredProcedure"><a class="anchor" href="#jdbc-StoredProcedure"></a> 3.7.4。使用<code>StoredProcedure</code></h4>
<div class="paragraph">
<p>的<code>StoredProcedure</code> class是RDBMS存储过程的对象抽象的超类。这个班是<code>abstract</code> ，以及各种<code>execute(..)</code>方法有<code>protected</code>访问，防止通过除提供更严格的输入的子类之外的其他方式使用。</p>
</div>
<div class="paragraph">
<p>继承的<code>sql</code> property是RDBMS中存储过程的名称。</p>
</div>
<div class="paragraph">
<p>定义参数<code>StoredProcedure</code>类，您可以使用<code>SqlParameter</code>或其子类别之一。您必须在构造函数中指定参数名称和SQL类型，如以下代码片段所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">new SqlParameter("in_id", Types.NUMERIC),
new SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">SqlParameter("in_id", Types.NUMERIC),
SqlOutParameter("out_first_name", Types.VARCHAR),</code></pre>
</div>
</div>
<div class="paragraph">
<p>SQL类型是使用<code>java.sql.Types</code>常数。</p>
</div>
<div class="paragraph">
<p>第一行（带有<code>SqlParameter</code> ）声明一个IN参数。您可以将IN参数用于存储过程调用和使用<code>SqlQuery</code>及其子类（在<a href="#jdbc-SqlQuery">理解中找到<code>SqlQuery</code></a> ）。</p>
</div>
<div class="paragraph">
<p>第二行（带有<code>SqlOutParameter</code> ）声明<code>out</code>存储过程调用中使用的参数。还有一个<code>SqlInOutParameter</code>对于<code>InOut</code>参数（提供<code>in</code>值并返回一个值）。</p>
</div>
<div class="paragraph">
<p>对于<code>in</code>参数，除了名称和SQL类型外，还可以为数字数据指定小数位，或者为自定义数据库类型指定类型名。对于<code>out</code>参数，您可以提供<code>RowMapper</code>处理从a返回的行的映射<code>REF</code>光标。另一种选择是指定一个<code>SqlReturnType</code>使您可以定义返回值的自定义处理。</p>
</div>
<div class="paragraph">
<p>下一个简单DAO的示例使用<code>StoredProcedure</code>调用一个函数（ <code>sysdate()</code> ），这是任何Oracle数据库随附的。要使用存储过程功能，您必须创建一个扩展<code>StoredProcedure</code> 。在此示例中， <code>StoredProcedure</code>类是内部类。但是，如果您需要重用<code>StoredProcedure</code> ，您可以将其声明为顶级类。此示例没有输入参数，但是通过使用输出参数将输出参数声明为日期类型。 <code>SqlOutParameter</code>类。的<code>execute()</code>方法运行过程并从结果中提取返回的日期<code>Map</code> 。结果<code>Map</code>通过使用参数名称作为键，每个声明的输出参数（在本例中只有一个）都有一个条目。以下清单显示了我们的自定义StoredProcedure类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.sql.DataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class StoredProcedureDao {

    private GetSysdateProcedure getSysdate;

    @Autowired
    public void init(DataSource dataSource) {
        this.getSysdate = new GetSysdateProcedure(dataSource);
    }

    public Date getSysdate() {
        return getSysdate.execute();
    }

    private class GetSysdateProcedure extends StoredProcedure {

        private static final String SQL = "sysdate";

        public GetSysdateProcedure(DataSource dataSource) {
            setDataSource(dataSource);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Date execute() {
            // the 'sysdate' sproc has no input parameters, so an empty Map is supplied...
            Map&lt;String, Object&gt; results = execute(new HashMap&lt;String, Object&gt;());
            Date sysdate = (Date) results.get("date");
            return sysdate;
        }
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import java.sql.Types
import java.util.Date
import java.util.Map
import javax.sql.DataSource
import org.springframework.jdbc.core.SqlOutParameter
import org.springframework.jdbc.object.StoredProcedure

class StoredProcedureDao(dataSource: DataSource) {

    private val SQL = "sysdate"

    private val getSysdate = GetSysdateProcedure(dataSource)

    val sysdate: Date
        get() = getSysdate.execute()

    private inner class GetSysdateProcedure(dataSource: DataSource) : StoredProcedure() {

        init {
            setDataSource(dataSource)
            isFunction = true
            sql = SQL
            declareParameter(SqlOutParameter("date", Types.DATE))
            compile()
        }

        fun execute(): Date {
            // the 'sysdate' sproc has no input parameters, so an empty Map is supplied...
            val results = execute(mutableMapOf&lt;String, Any&gt;())
            return results["date"] as Date
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例<code>StoredProcedure</code>有两个输出参数（在本例中为Oracle REF游标）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.util.HashMap;
import java.util.Map;
import javax.sql.DataSource;
import oracle.jdbc.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class TitlesAndGenresStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "AllTitlesAndGenres";

    public TitlesAndGenresStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
        compile();
    }

    public Map&lt;String, Object&gt; execute() {
        // again, this sproc has no input parameters, so an empty Map is supplied
        return super.execute(new HashMap&lt;String, Object&gt;());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import java.util.HashMap
import javax.sql.DataSource
import oracle.jdbc.OracleTypes
import org.springframework.jdbc.core.SqlOutParameter
import org.springframework.jdbc.<code>object</code>.StoredProcedure

class TitlesAndGenresStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {

    companion object {
        private const val SPROC_NAME = "AllTitlesAndGenres"
    }

    init {
        declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
        declareParameter(SqlOutParameter("genres", OracleTypes.CURSOR, GenreMapper()))
        compile()
    }

    fun execute(): Map&lt;String, Any&gt; {
        // again, this sproc has no input parameters, so an empty Map is supplied
        return super.execute(HashMap&lt;String, Any&gt;())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>declareParameter(..)</code>在<code>TitlesAndGenresStoredProcedure</code>构造函数被传递<code>RowMapper</code>实现实例。这是重用现有功能的非常方便且强大的方法。接下来的两个示例提供了这两个代码<code>RowMapper</code>实现。</p>
</div>
<div class="paragraph">
<p>的<code>TitleMapper</code>类映射<code>ResultSet</code>到一个<code>Title</code>提供的每一行的域对象<code>ResultSet</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.sql.ResultSet;
import java.sql.SQLException;
import com.foo.domain.Title;
import org.springframework.jdbc.core.RowMapper;

public final class TitleMapper implements RowMapper&lt;Title&gt; {

    public Title mapRow(ResultSet rs, int rowNum) throws SQLException {
        Title title = new Title();
        title.setId(rs.getLong("id"));
        title.setName(rs.getString("name"));
        return title;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import java.sql.ResultSet
import com.foo.domain.Title
import org.springframework.jdbc.core.RowMapper

class TitleMapper : RowMapper&lt;Title&gt; {

    override fun mapRow(rs: ResultSet, rowNum: Int) =
            Title(rs.getLong("id"), rs.getString("name"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>GenreMapper</code>类映射<code>ResultSet</code>到一个<code>Genre</code>提供的每一行的域对象<code>ResultSet</code> ， 如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.sql.ResultSet;
import java.sql.SQLException;
import com.foo.domain.Genre;
import org.springframework.jdbc.core.RowMapper;

public final class GenreMapper implements RowMapper&lt;Genre&gt; {

    public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Genre(rs.getString("name"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import java.sql.ResultSet
import com.foo.domain.Genre
import org.springframework.jdbc.core.RowMapper

class GenreMapper : RowMapper&lt;Genre&gt; {

    override fun mapRow(rs: ResultSet, rowNum: Int): Genre {
        return Genre(rs.getString("name"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将参数传递到RDBMS定义中具有一个或多个输入参数的存储过程，可以编写一个强类型代码<code>execute(..)</code>委托给无类型的方法<code>execute(Map)</code>超类中的方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.sql.Types;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.sql.DataSource;
import oracle.jdbc.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.StoredProcedure;

public class TitlesAfterDateStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "TitlesAfterDate";
    private static final String CUTOFF_DATE_PARAM = "cutoffDate";

    public TitlesAfterDateStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        compile();
    }

    public Map&lt;String, Object&gt; execute(Date cutoffDate) {
        Map&lt;String, Object&gt; inputs = new HashMap&lt;String, Object&gt;();
        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
        return super.execute(inputs);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import java.sql.Types
import java.util.Date
import javax.sql.DataSource
import oracle.jdbc.OracleTypes
import org.springframework.jdbc.core.SqlOutParameter
import org.springframework.jdbc.core.SqlParameter
import org.springframework.jdbc.<code>object</code>.StoredProcedure

class TitlesAfterDateStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {

    companion object {
        private const val SPROC_NAME = "TitlesAfterDate"
        private const val CUTOFF_DATE_PARAM = "cutoffDate"
    }

    init {
        declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types.DATE))
        declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
        compile()
    }

    fun execute(cutoffDate: Date) = super.execute(
            mapOf&lt;String, Any&gt;(CUTOFF_DATE_PARAM to cutoffDate))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-parameter-handling"><a class="anchor" href="#jdbc-parameter-handling"></a> 3.8。参数和数据值处理的常见问题</h3>
<div class="paragraph">
<p>Spring Framework的JDBC支持提供的不同方法中存在参数和数据值的常见问题。本节介绍如何解决它们。</p>
</div>
<div class="sect3">
<h4 id="jdbc-type-information"><a class="anchor" href="#jdbc-type-information"></a> 3.8.1。提供参数的SQL类型信息</h4>
<div class="paragraph">
<p>通常，Spring根据传入的参数类型确定参数的SQL类型。可以明确提供设置参数值时要使用的SQL类型。有时需要正确设置<code>NULL</code>价值观。</p>
</div>
<div class="paragraph">
<p>您可以通过几种方式提供SQL类型信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>许多更新和查询方法<code>JdbcTemplate</code>采取形式为<code>int</code>数组。该数组用于通过使用来自的常量值来指示相应参数的SQL类型。 <code>java.sql.Types</code>类。为每个参数提供一个条目。</p>
</li>
<li>
<p>您可以使用<code>SqlParameterValue</code>类包装需要此附加信息的参数值。为此，请为每个值创建一个新实例，然后在构造函数中传入SQL类型和参数值。您还可以为数字值提供可选的比例参数。</p>
</li>
<li>
<p>对于使用命名参数的方法，您可以使用<code>SqlParameterSource</code>类， <code>BeanPropertySqlParameterSource</code>要么<code>MapSqlParameterSource</code> 。它们都具有用于为任何命名参数值注册SQL类型的方法。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-lob"><a class="anchor" href="#jdbc-lob"></a> 3.8.2。处理BLOB和CLOB对象</h4>
<div class="paragraph">
<p>您可以在数据库中存储图像，其他二进制数据和大块文本。这些大对象称为二进制数据的BLOB（二进制大型对象），而字符数据称为CLOB（字符大型对象）。在Spring中，您可以使用<code>JdbcTemplate</code>直接使用RDBMS对象和RDBMS对象提供的更高抽象<code>SimpleJdbc</code>类。所有这些方法都使用了<code>LobHandler</code>用于实际管理LOB（大对象）数据的接口。
<code>LobHandler</code>提供对<code>LobCreator</code>类，通过<code>getLobCreator</code>方法，用于创建要插入的新LOB对象。</p>
</div>
<div class="paragraph">
<p><code>LobCreator</code>和<code>LobHandler</code>为LOB输入和输出提供以下支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BLOB</p>
<div class="ulist">
<ul>
<li>
<p><code>byte[]</code> ： <code>getBlobAsBytes</code>和<code>setBlobAsBytes</code></p>
</li>
<li>
<p><code>InputStream</code> ： <code>getBlobAsBinaryStream</code>和<code>setBlobAsBinaryStream</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>CLOB</p>
<div class="ulist">
<ul>
<li>
<p><code>String</code> ： <code>getClobAsString</code>和<code>setClobAsString</code></p>
</li>
<li>
<p><code>InputStream</code> ： <code>getClobAsAsciiStream</code>和<code>setClobAsAsciiStream</code></p>
</li>
<li>
<p><code>Reader</code> ： <code>getClobAsCharacterStream</code>和<code>setClobAsCharacterStream</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一个示例显示了如何创建和插入BLOB。稍后我们展示如何从数据库中读取它。</p>
</div>
<div class="paragraph">
<p>本示例使用<code>JdbcTemplate</code>以及<code>AbstractLobCreatingPreparedStatementCallback</code> 。它实现了一种方法， <code>setValues</code> 。此方法提供了<code>LobCreator</code>我们用来设置SQL插入语句中的LOB列的值。</p>
</div>
<div class="paragraph">
<p>在此示例中，我们假设存在一个变量， <code>lobHandler</code> ，即已设置为的实例<code>DefaultLobHandler</code> 。通常，您可以通过依赖注入来设置此值。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何创建和插入BLOB：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">final File blobIn = new File("spring2004.jpg");
final InputStream blobIs = new FileInputStream(blobIn);
final File clobIn = new File("large.txt");
final InputStream clobIs = new FileInputStream(clobIn);
final InputStreamReader clobReader = new InputStreamReader(clobIs);

jdbcTemplate.execute(
    "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
    new AbstractLobCreatingPreparedStatementCallback(lobHandler) {  <i class="conum" data-value="1"></i><b>(1)</b>
        protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
            ps.setLong(1, 1L);
            lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  <i class="conum" data-value="2"></i><b>(2)</b>
            lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
);

blobIs.close();
clobReader.close();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>传递<code>lobHandler</code> （在此示例中）是简单的<code>DefaultLobHandler</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用方法<code>setClobAsCharacterStream</code>传递CLOB的内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用方法<code>setBlobAsBinaryStream</code>传递BLOB的内容。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val blobIn = File("spring2004.jpg")
val blobIs = FileInputStream(blobIn)
val clobIn = File("large.txt")
val clobIs = FileInputStream(clobIn)
val clobReader = InputStreamReader(clobIs)

jdbcTemplate.execute(
        "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
        object: AbstractLobCreatingPreparedStatementCallback(lobHandler) {  <i class="conum" data-value="1"></i><b>(1)</b>
            override fun setValues(ps: PreparedStatement, lobCreator: LobCreator) {
                ps.setLong(1, 1L)
                lobCreator.setClobAsCharacterStream(ps, 2, clobReader, clobIn.length().toInt())  <i class="conum" data-value="2"></i><b>(2)</b>
                lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, blobIn.length().toInt())  <i class="conum" data-value="3"></i><b>(3)</b>
            }
        }
)
blobIs.close()
clobReader.close()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>传递<code>lobHandler</code> （在此示例中）是简单的<code>DefaultLobHandler</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用方法<code>setClobAsCharacterStream</code>传递CLOB的内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用方法<code>setBlobAsBinaryStream</code>传递BLOB的内容。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您调用<code>setBlobAsBinaryStream</code> ， <code>setClobAsAsciiStream</code> ， 要么<code>setClobAsCharacterStream</code>上的方法<code>LobCreator</code>从返回<code>DefaultLobHandler.getLobCreator()</code> ，您可以选择将负值指定为<code>contentLength</code>论点。如果指定的内容长度为负，则<code>DefaultLobHandler</code>使用不带长度参数的set-stream方法的JDBC 4.0变体。否则，它将指定的长度传递给驱动程序。</p>
</div>
<div class="paragraph">
<p>请参阅有关JDBC驱动程序的文档，以用于验证它是否支持流式LOB而不提供内容长度。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在是时候从数据库中读取LOB数据了。同样，您使用<code>JdbcTemplate</code>具有相同的实例变量<code>lobHandler</code>以及对<code>DefaultLobHandler</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">List&lt;Map&lt;String, Object&gt;&gt; l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
    new RowMapper&lt;Map&lt;String, Object&gt;&gt;() {
        public Map&lt;String, Object&gt; mapRow(ResultSet rs, int i) throws SQLException {
            Map&lt;String, Object&gt; results = new HashMap&lt;String, Object&gt;();
            String clobText = lobHandler.getClobAsString(rs, "a_clob");  <i class="conum" data-value="1"></i><b>(1)</b>
            results.put("CLOB", clobText);
            byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");  <i class="conum" data-value="2"></i><b>(2)</b>
            results.put("BLOB", blobBytes);
            return results;
        }
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用方法<code>getClobAsString</code>检索CLOB的内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用方法<code>getBlobAsBytes</code>检索BLOB的内容。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table") { rs, _ -&gt;
    val clobText = lobHandler.getClobAsString(rs, "a_clob")  <i class="conum" data-value="1"></i><b>(1)</b>
    val blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob")  <i class="conum" data-value="2"></i><b>(2)</b>
    mapOf("CLOB" to clobText, "BLOB" to blobBytes)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用方法<code>getClobAsString</code>检索CLOB的内容。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用方法<code>getBlobAsBytes</code>检索BLOB的内容。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-in-clause"><a class="anchor" href="#jdbc-in-clause"></a> 3.8.3。传入IN子句的值列表</h4>
<div class="paragraph">
<p>SQL标准允许基于包含变量值列表的表达式选择行。一个典型的例子是<code>select * from T_ACTOR where id in (1, 2, 3)</code> 。JDBC标准不直接为准备好的语句支持此变量列表。您不能声明可变数量的占位符。您需要准备好所需数量的占位符，然后进行多种变体，或者一旦知道需要多少个占位符，就需要动态生成SQL字符串。在中提供的命名参数支持<code>NamedParameterJdbcTemplate</code>和<code>JdbcTemplate</code>采用后一种方法。您可以将值作为<code>java.util.List</code>原始对象。此列表用于插入所需的占位符，并在语句执行期间传递值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">传递许多值时要小心。JDBC标准不保证您可以使用100个以上的值<code>in</code>表达式列表。各种数据库都超过了这个数目，但是它们通常对允许多少个值有硬性限制。例如，Oracle的限制为1000。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了值列表中的原始值，您还可以创建一个<code>java.util.List</code>对象数组。此列表可以支持为<code>in</code>子句，例如<code>select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2, 'Harrop'\))</code> 。当然，这要求您的数据库支持此语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-complex-types"><a class="anchor" href="#jdbc-complex-types"></a> 3.8.4。处理存储过程调用的复杂类型</h4>
<div class="paragraph">
<p>调用存储过程时，有时可以使用特定于数据库的复杂类型。为了适应这些类型，Spring提供了一个<code>SqlReturnType</code>用于从存储过程调用中返回它们时处理它们，并且<code>SqlTypeValue</code>当它们作为参数传递给存储过程时。</p>
</div>
<div class="paragraph">
<p>的<code>SqlReturnType</code>接口具有单个方法（名为<code>getTypeValue</code> ）必须执行。该接口用作声明的一部分<code>SqlOutParameter</code> 。以下示例显示了返回Oracle的值<code>STRUCT</code>用户声明类型的对象<code>ITEM_TYPE</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class TestItemStoredProcedure extends StoredProcedure {

    public TestItemStoredProcedure(DataSource dataSource) {
        // ...
        declareParameter(new SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE",
            new SqlReturnType() {
                public Object getTypeValue(CallableStatement cs, int colIndx, int sqlType, String   ) throws SQLException {
                    STRUCT struct = (STRUCT) cs.getObject(colIndx);
                    Object[] attr = struct.getAttributes();
                    TestItem item = new TestItem();
                    item.setId(((Number) attr[0]).longValue());
                    item.setDescription((String) attr[1]);
                    item.setExpirationDate((java.util.Date) attr[2]);
                    return item;
                }
            }));
        // ...
    }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() {

    init {
        // ...
        declareParameter(SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE") { cs, colIndx, sqlType, typeName -&gt;
            val struct = cs.getObject(colIndx) as STRUCT
            val attr = struct.getAttributes()
            TestItem((attr[0] as Long, attr[1] as String, attr[2] as Date)
        })
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>SqlTypeValue</code>传递Java对象的值（例如<code>TestItem</code> ）存储过程。的<code>SqlTypeValue</code>接口具有单个方法（名为<code>createTypeValue</code> ），您必须实施。活动连接被传入，您可以使用它来创建特定于数据库的对象，例如<code>StructDescriptor</code>实例或<code>ArrayDescriptor</code>实例。以下示例创建了一个<code>StructDescriptor</code>实例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">final TestItem testItem = new TestItem(123L, "A test item",
        new SimpleDateFormat("yyyy-M-d").parse("2010-12-31"));

SqlTypeValue value = new AbstractSqlTypeValue() {
    protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
        StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn);
        Struct item = new STRUCT(itemDescriptor, conn,
        new Object[] {
            testItem.getId(),
            testItem.getDescription(),
            new java.sql.Date(testItem.getExpirationDate().getTime())
        });
        return item;
    }
};</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val (id, description, expirationDate) = TestItem(123L, "A test item",
        SimpleDateFormat("yyyy-M-d").parse("2010-12-31"))

val value = object : AbstractSqlTypeValue() {
    override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?): Any {
        val itemDescriptor = StructDescriptor(typeName, conn)
        return STRUCT(itemDescriptor, conn,
                arrayOf(id, description, java.sql.Date(expirationDate.time)))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您现在可以添加此<code>SqlTypeValue</code>到<code>Map</code>包含用于<code>execute</code>存储过程的调用。</p>
</div>
<div class="paragraph">
<p>的另一种用途<code>SqlTypeValue</code>正在将值数组传递给Oracle存储过程。甲骨文拥有自己的内部<code>ARRAY</code>在这种情况下必须使用的类，您可以使用<code>SqlTypeValue</code>创建Oracle的实例<code>ARRAY</code>并用Java中的值填充<code>ARRAY</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">final Long[] ids = new Long[] {1L, 2L};

SqlTypeValue value = new AbstractSqlTypeValue() {
    protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
        ArrayDescriptor arrayDescriptor = new ArrayDescriptor(typeName, conn);
        ARRAY idArray = new ARRAY(arrayDescriptor, conn, ids);
        return idArray;
    }
};</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() {

    init {
        val ids = arrayOf(1L, 2L)
        val value = object : AbstractSqlTypeValue() {
            override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?): Any {
                val arrayDescriptor = ArrayDescriptor(typeName, conn)
                return ARRAY(arrayDescriptor, conn, ids)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-embedded-database-support"><a class="anchor" href="#jdbc-embedded-database-support"></a> 3.9。嵌入式数据库支持</h3>
<div class="paragraph">
<p>的<code>org.springframework.jdbc.datasource.embedded</code>软件包提供对嵌入式Java数据库引擎的支持。本地提供对<a href="http://www.hsqldb.org">HSQL</a> ， <a href="https://www.h2database.com">H2</a>和<a href="https://db.apache.org/derby">Derby的</a>支持。您还可以使用可扩展的API插入新的嵌入式数据库类型，并<code>DataSource</code>实现。</p>
</div>
<div class="sect3">
<h4 id="jdbc-why-embedded-database"><a class="anchor" href="#jdbc-why-embedded-database"></a> 3.9.1。为什么要使用嵌入式数据库？</h4>
<div class="paragraph">
<p>嵌入式数据库由于其轻量级的特性，因此在项目的开发阶段可能会很有用。好处包括易于配置，快速启动时间，可测试性以及在开发过程中快速演化SQL的能力。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-xml"><a class="anchor" href="#jdbc-embedded-database-xml"></a> 3.9.2。使用Spring XML创建嵌入式数据库</h4>
<div class="paragraph">
<p>如果要在Spring中将嵌入式数据库实例公开为Bean <code>ApplicationContext</code> ，您可以使用<code>embedded-database</code>标记在<code>spring-jdbc</code>命名空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jdbc:embedded-database id="dataSource" generate-name="true"&gt;
    &lt;jdbc:script location="classpath:schema.sql"/&gt;
    &lt;jdbc:script location="classpath:test-data.sql"/&gt;
&lt;/jdbc:embedded-database&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的配置创建了一个嵌入式HSQL数据库，该数据库中填充了来自<code>schema.sql</code>和<code>test-data.sql</code>类路径根目录中的资源。另外，作为最佳实践，将为嵌入式数据库分配一个唯一生成的名称。嵌入式数据库以类型为Bean的形式可供Spring容器使用<code>javax.sql.DataSource</code>然后可以根据需要将其注入到数据访问对象中。</p>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-java"><a class="anchor" href="#jdbc-embedded-database-java"></a> 3.9.3。以编程方式创建嵌入式数据库</h4>
<div class="paragraph">
<p>的<code>EmbeddedDatabaseBuilder</code>类提供了一种流畅的API，可用于以编程方式构造嵌入式数据库。当您需要在独立环境或独立集成测试中创建嵌入式数据库时，可以使用此方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">EmbeddedDatabase db = new EmbeddedDatabaseBuilder()
        .generateUniqueName(true)
        .setType(H2)
        .setScriptEncoding("UTF-8")
        .ignoreFailedDrops(true)
        .addScript("schema.sql")
        .addScripts("user_data.sql", "country_data.sql")
        .build();

// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

db.shutdown()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val db = EmbeddedDatabaseBuilder()
        .generateUniqueName(true)
        .setType(H2)
        .setScriptEncoding("UTF-8")
        .ignoreFailedDrops(true)
        .addScript("schema.sql")
        .addScripts("user_data.sql", "country_data.sql")
        .build()

// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

db.shutdown()</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html">javadoc <code>EmbeddedDatabaseBuilder</code></a>有关所有受支持选项的更多详细信息。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>EmbeddedDatabaseBuilder</code>通过使用Java配置来创建嵌入式数据库，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .setType(H2)
                .setScriptEncoding("UTF-8")
                .ignoreFailedDrops(true)
                .addScript("schema.sql")
                .addScripts("user_data.sql", "country_data.sql")
                .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class DataSourceConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .setType(H2)
                .setScriptEncoding("UTF-8")
                .ignoreFailedDrops(true)
                .addScript("schema.sql")
                .addScripts("user_data.sql", "country_data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-types"><a class="anchor" href="#jdbc-embedded-database-types"></a> 3.9.4。选择嵌入式数据库类型</h4>
<div class="paragraph">
<p>本节介绍如何选择Spring支持的三个嵌入式数据库之一。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jdbc-embedded-database-using-HSQL">使用HSQL</a></p>
</li>
<li>
<p><a href="#jdbc-embedded-database-using-H2">使用H2</a></p>
</li>
<li>
<p><a href="#jdbc-embedded-database-using-Derby">使用德比</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="jdbc-embedded-database-using-HSQL"><a class="anchor" href="#jdbc-embedded-database-using-HSQL"></a>使用HSQL</h5>
<div class="paragraph">
<p>Spring支持HSQL 1.8.0及更高版本。如果未明确指定类型，则HSQL是默认的嵌入式数据库。要明确指定HSQL，请设置<code>type</code>的属性<code>embedded-database</code>标记到<code>HSQL</code> 。如果您使用构建器API，请调用<code>setType(EmbeddedDatabaseType)</code>方法<code>EmbeddedDatabaseType.HSQL</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-embedded-database-using-H2"><a class="anchor" href="#jdbc-embedded-database-using-H2"></a>使用H2</h5>
<div class="paragraph">
<p>Spring支持H2数据库。要启用H2，请设置<code>type</code>的属性<code>embedded-database</code>标记到<code>H2</code> 。如果您使用构建器API，请调用<code>setType(EmbeddedDatabaseType)</code>方法<code>EmbeddedDatabaseType.H2</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-embedded-database-using-Derby"><a class="anchor" href="#jdbc-embedded-database-using-Derby"></a>使用德比</h5>
<div class="paragraph">
<p>Spring支持Apache Derby 10.5及更高版本。要启用Derby，请设置<code>type</code>的属性<code>embedded-database</code>标记到<code>DERBY</code> 。如果您使用构建器API，请调用<code>setType(EmbeddedDatabaseType)</code>方法<code>EmbeddedDatabaseType.DERBY</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-dao-testing"><a class="anchor" href="#jdbc-embedded-database-dao-testing"></a> 3.9.5。使用嵌入式数据库测试数据访问逻辑</h4>
<div class="paragraph">
<p>嵌入式数据库提供了一种轻量级的方法来测试数据访问代码。下一个示例是使用嵌入式数据库的数据访问集成测试模板。当嵌入式数据库不需要在测试类之间重用时，使用这种模板可以一次性使用。但是，如果您希望创建在测试套件中共享的嵌入式数据库，请考虑使用<a href="testing.html#testcontext-framework">Spring TestContext Framework</a>并将嵌入式数据库配置为Spring中的Bean。 <code>ApplicationContext</code>如<a href="#jdbc-embedded-database-xml">使用Spring XML</a> <a href="#jdbc-embedded-database-java">创建嵌入式数据库</a>和<a href="#jdbc-embedded-database-java">以编程方式创建嵌入式数据库中所述</a> 。以下清单显示了测试模板：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DataAccessIntegrationTestTemplate {

    private EmbeddedDatabase db;

    @BeforeEach
    public void setUp() {
        // creates an HSQL in-memory database populated from default scripts
        // classpath:schema.sql and classpath:data.sql
        db = new EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .addDefaultScripts()
                .build();
    }

    @Test
    public void testDataAccess() {
        JdbcTemplate template = new JdbcTemplate(db);
        template.query( /* ... */ );
    }

    @AfterEach
    public void tearDown() {
        db.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class DataAccessIntegrationTestTemplate {

    private lateinit var db: EmbeddedDatabase

    @BeforeEach
    fun setUp() {
        // creates an HSQL in-memory database populated from default scripts
        // classpath:schema.sql and classpath:data.sql
        db = EmbeddedDatabaseBuilder()
                .generateUniqueName(true)
                .addDefaultScripts()
                .build()
    }

    @Test
    fun testDataAccess() {
        val template = JdbcTemplate(db)
        template.query( /* ... */)
    }

    @AfterEach
    fun tearDown() {
        db.shutdown()
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-unique-names"><a class="anchor" href="#jdbc-embedded-database-unique-names"></a> 3.9.6。为嵌入式数据库生成唯一名称</h4>
<div class="paragraph">
<p>如果开发团队的测试套件无意间尝试重新创建同一数据库的其他实例，则开发团队经常会遇到错误。如果使用XML配置文件或<code>@Configuration</code>类负责创建嵌入式数据库，然后在同一测试套件（即，在同一JVM进程中）的多个测试场景中重用相应的配置-例如，针对嵌入式数据库的集成测试<code>ApplicationContext</code>配置仅在哪些bean定义配置文件处于活动状态方面有所不同。</p>
</div>
<div class="paragraph">
<p>此类错误的根本原因是，Spring的<code>EmbeddedDatabaseFactory</code> （由内部<code><jdbc:embedded-database></code> XML名称空间元素和<code>EmbeddedDatabaseBuilder</code> （对于Java配置）将嵌入式数据库的名称设置为<code>testdb</code>如果没有另外指定。对于<code><jdbc:embedded-database></code> ，通常为嵌入式数据库分配的名称等于Bean的名称<code>id</code> （通常，类似<code>dataSource</code> ）。因此，随后创建嵌入式数据库的尝试不会产生新的数据库。取而代之的是，相同的JDBC连接URL被重用，并且尝试创建新的嵌入式数据库实际上指向的是从相同配置创建的现有嵌入式数据库。</p>
</div>
<div class="paragraph">
<p>为了解决这个常见问题，Spring Framework 4.2提供了对生成嵌入式数据库的唯一名称的支持。要启用使用生成的名称，请使用以下选项之一。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()</code></p>
</li>
<li>
<p><code>EmbeddedDatabaseBuilder.generateUniqueName()</code></p>
</li>
<li>
<p><code><jdbc:embedded-database generate-name="true" …​ ></code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="jdbc-embedded-database-extension"><a class="anchor" href="#jdbc-embedded-database-extension"></a> 3.9.7。扩展嵌入式数据库支持</h4>
<div class="paragraph">
<p>您可以通过两种方式扩展Spring JDBC嵌入式数据库的支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实行<code>EmbeddedDatabaseConfigurer</code>支持新的嵌入式数据库类型。</p>
</li>
<li>
<p>实行<code>DataSourceFactory</code>支持一个新的<code>DataSource</code>实现，例如用于管理嵌入式数据库连接的连接池。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们鼓励您在<a href="https://github.com/spring-projects/spring-framework/issues">GitHub Issues</a>上为Spring社区贡献扩展。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jdbc-initializing-datasource"><a class="anchor" href="#jdbc-initializing-datasource"></a> 3.10。初始化一个<code>DataSource</code></h3>
<div class="paragraph">
<p>的<code>org.springframework.jdbc.datasource.init</code>软件包提供了对现有的初始化的支持<code>DataSource</code> 。嵌入式数据库支持提供了一种用于创建和初始化数据库的选项。 <code>DataSource</code>申请。但是，有时您可能需要初始化在某处的服务器上运行的实例。</p>
</div>
<div class="sect3">
<h4 id="jdbc-initializing-datasource-xml"><a class="anchor" href="#jdbc-initializing-datasource-xml"></a> 3.10.1。使用Spring XML初始化数据库</h4>
<div class="paragraph">
<p>如果要初始化数据库，可以提供对数据库的引用。 <code>DataSource</code>豆，您可以使用<code>initialize-database</code>标记在<code>spring-jdbc</code>命名空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jdbc:initialize-database data-source="dataSource"&gt;
    &lt;jdbc:script location="classpath:com/foo/sql/db-schema.sql"/&gt;
    &lt;jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例对数据库运行两个指定的脚本。第一个脚本创建模式，第二个脚本用测试数据集填充表。脚本位置也可以是带有通配符的模式，该通配符具有用于Spring中资源的常用Ant样式（例如， <code>classpath*:/com/foo/**/sql/*-data.sql</code> ）。如果使用模式，则脚本以其URL或文件名的词法顺序运行。</p>
</div>
<div class="paragraph">
<p>数据库初始化程序的默认行为是无条件运行所提供的脚本。这可能并不总是您想要的-例如，如果您对已经有测试数据的数据库运行脚本。通过遵循先创建表然后插入数据的通用模式（如前所示），可以减少意外删除数据的可能性。如果表已经存在，则第一步失败。</p>
</div>
<div class="paragraph">
<p>但是，为了更好地控制现有数据的创建和删除，XML名称空间提供了一些其他选项。第一个是用于打开和关闭初始化的标志。您可以根据环境进行设置（例如，从系统属性或环境Bean中提取布尔值）。以下示例从系统属性获取值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jdbc:initialize-database data-source="dataSource"
    enabled="#{systemProperties.INITIALIZE_DATABASE}"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;jdbc:script location="..."/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>enabled</code>从一个名为<code>INITIALIZE_DATABASE</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>控制现有数据会发生什么的第二种选择是更加容忍失败。为此，您可以控制初始化程序忽略脚本执行的SQL中某些错误的能力，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jdbc:initialize-database data-source="dataSource" ignore-failures="DROPS"&gt;
    &lt;jdbc:script location="..."/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们说我们期望有时脚本是针对空数据库运行的，其中有些<code>DROP</code>因此，脚本中的语句将失败。所以失败的SQL <code>DROP</code>语句将被忽略，但其他失败将导致异常。如果您的SQL方言不支持，这将很有用<code>DROP …​ IF EXISTS</code> （或类似），但您想在重新创建之前无条件删除所有测试数据。在这种情况下，第一个脚本通常是一组<code>DROP</code>语句，然后是一组<code>CREATE</code>陈述。</p>
</div>
<div class="paragraph">
<p>的<code>ignore-failures</code>选项可以设置为<code>NONE</code> （默认）， <code>DROPS</code> （忽略失败的液滴），或<code>ALL</code> （忽略所有失败）。</p>
</div>
<div class="paragraph">
<p>每个语句应以<code>;</code>或换行，如果<code>;</code>脚本中根本没有字符。您可以全局控制该脚本，也可以按脚本控制，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jdbc:initialize-database data-source="dataSource" separator="@@"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;jdbc:script location="classpath:com/myapp/sql/db-schema.sql" separator=";"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;jdbc:script location="classpath:com/myapp/sql/db-test-data-1.sql"/&gt;
    &lt;jdbc:script location="classpath:com/myapp/sql/db-test-data-2.sql"/&gt;
&lt;/jdbc:initialize-database&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>将分隔符脚本设置为<code>@@</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>设置分隔符<code>db-schema.sql</code>至<code>;</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在此示例中，两个<code>test-data</code>脚本使用<code>@@</code>作为语句分隔符，只有<code>db-schema.sql</code>用途<code>;</code> 。此配置指定默认分隔符为<code>@@</code>并覆盖默认值<code>db-schema</code>脚本。</p>
</div>
<div class="paragraph">
<p>如果您需要的控制权超过从XML名称空间获得的控制权，则可以使用<code>DataSourceInitializer</code>直接将其定义为应用程序中的组件。</p>
</div>
<div class="sect4">
<h5 id="jdbc-client-component-initialization"><a class="anchor" href="#jdbc-client-component-initialization"></a>初始化依赖于数据库的其他组件</h5>
<div class="paragraph">
<p>大量的应用程序（那些在Spring上下文启动之后才使用数据库的应用程序）可以使用数据库初始化程序，而不会造成更多麻烦。如果您的应用程序不是其中之一，则可能需要阅读本节的其余部分。</p>
</div>
<div class="paragraph">
<p>数据库初始化程序取决于<code>DataSource</code>实例并运行其初始化回调中提供的脚本（类似于<code>init-method</code>在XML bean定义中， <code>@PostConstruct</code>组件中的方法，或者<code>afterPropertiesSet()</code>实现组件的方法<code>InitializingBean</code> ）。如果其他bean依赖于相同的数据源并在初始化回调中使用该数据源，则可能存在问题，因为尚未初始化数据。一个常见的示例是一个高速缓存，它会在应用程序启动时急于初始化并从数据库加载数据。</p>
</div>
<div class="paragraph">
<p>要解决此问题，您有两个选择：将高速缓存初始化策略更改为以后的阶段，或者确保首先初始化数据库初始化程序。</p>
</div>
<div class="paragraph">
<p>如果应用程序在您的控制之下，则更改缓存初始化策略可能很容易，否则就不那么容易。有关如何实现这一点的一些建议包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使高速缓存在首次使用时延迟初始化，从而缩短了应用程序的启动时间。</p>
</li>
<li>
<p>让您的缓存或单独的组件初始化缓存实现<code>Lifecycle</code>要么<code>SmartLifecycle</code> 。当应用程序上下文启动时，您可以自动启动<code>SmartLifecycle</code>通过设置其<code>autoStartup</code>标记，然后您可以手动启动<code>Lifecycle</code>通过打电话<code>ConfigurableApplicationContext.start()</code>在封闭的上下文中。</p>
</li>
<li>
<p>使用弹簧<code>ApplicationEvent</code>或类似的自定义观察者机制来触发缓存初始化。 <code>ContextRefreshedEvent</code>在准备好使用时（在所有bean都初始化之后）总是由上下文发布，因此通常是一个有用的钩子（这就是<code>SmartLifecycle</code>默认情况下有效）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保首先初始化数据库初始化程序也很容易。关于如何实现这一点的一些建议包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>依靠Spring的默认行为<code>BeanFactory</code> ，即按注册顺序初始化bean。您可以通过采用一套通用的做法轻松安排<code><import/></code> XML配置中的元素，这些元素对应用程序模块进行排序，并确保首先列出数据库和数据库初始化。</p>
</li>
<li>
<p>分开<code>DataSource</code>以及使用它并通过将它们分开放置来控制其启动顺序的业务组件<code>ApplicationContext</code>实例（例如，父上下文包含<code>DataSource</code> ，并且子上下文包含业务组件）。这种结构在Spring Web应用程序中很常见，但可以更普遍地应用。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="orm"><a class="anchor" href="#orm"></a> 4。对象关系映射（ORM）数据访问</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍使用对象关系映射（ORM）时的数据访问。</p>
</div>
<div class="sect2">
<h3 id="orm-introduction"><a class="anchor" href="#orm-introduction"></a> 4.1。Spring ORM简介</h3>
<div class="paragraph">
<p>Spring Framework支持与Java Persistence API（JPA）集成，并支持用于资源管理，数据访问对象（DAO）实现和事务策略的本地Hibernate。例如，对于Hibernate，它具有一流的支持以及一些便捷的IoC功能，可解决许多典型的Hibernate集成问题。您可以通过“依赖关系注入”为OR（对象关系）映射工具配置所有受支持的功能。他们可以参与Spring的资源和事务管理，并且符合Spring的通用事务和DAO异常层次结构。推荐的集成样式是针对普通的Hibernate或JPA API编写DAO。</p>
</div>
<div class="paragraph">
<p>当您创建数据访问应用程序时，Spring会为您选择的ORM层显着增强。您可以根据需要利用尽可能多的集成支持，并且应该将此集成工作与内部构建类似基础架构的成本和风险进行比较。不管使用哪种技术，您都可以像使用库一样使用许多ORM支持，因为所有内容都是作为一组可重用的JavaBean设计的。Spring IoC容器中的ORM有助于配置和部署。因此，本节中的大多数示例都显示了Spring容器内部的配置。</p>
</div>
<div class="paragraph">
<p>使用Spring框架创建ORM DAO的好处包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>更容易的测试。</strong> Spring的IoC方法使交换Hibernate的实现和配置位置变得容易<code>SessionFactory</code>实例，JDBC <code>DataSource</code>实例，事务管理器和映射对象实现（如果需要）。反过来，这使得隔离每个与持久性相关的代码片段的测试变得容易得多。</p>
</li>
<li>
<p><strong>常见的数据访问异常。</strong> Spring可以包装您的ORM工具中的异常，将其从专有（可能已检查）异常转换为通用运行时<code>DataAccessException</code>层次结构。通过此功能，您可以仅在适当的层中处理大多数不可恢复的持久性异常，而不会烦人样板捕获，抛出和异常声明。您仍然可以根据需要捕获和处理异常。请记住，JDBC异常（包括特定于DB的方言）也将转换为相同的层次结构，这意味着您可以在一致的编程模型中使用JDBC执行某些操作。</p>
</li>
<li>
<p><strong>常规资源管理。</strong> Spring应用程序上下文可以处理Hibernate的位置和配置<code>SessionFactory</code>实例，JPA <code>EntityManagerFactory</code>实例，JDBC <code>DataSource</code>实例以及其他相关资源。这使得这些值易于管理和更改。Spring提供了对持久性资源的高效，便捷和安全的处理。例如，使用Hibernate的相关代码通常需要使用相同的Hibernate <code>Session</code>以确保效率和适当的交易处理。Spring使创建和绑定对象变得容易<code>Session</code>通过暴露当前<code>Session</code>通过休眠<code>SessionFactory</code> 。因此，对于任何本地或JTA事务环境，Spring都解决了典型的Hibernate使用中的许多长期问题。</p>
</li>
<li>
<p><strong>集成交易管理。</strong> 您可以通过以下方式使用声明性的，面向切面的编程（AOP）风格的方法拦截器包装ORM代码： <code>@Transactional</code>注释或通过在XML配置文件中显式配置事务AOP建议来进行。在这两种情况下，都会为您处理事务语义和异常处理（回滚等）。如<a href="#orm-resource-mngmnt">资源和事务管理中所述</a> ，您还可以交换各种事务管理器，而不会影响与ORM相关的代码。例如，您可以在两种情况下使用相同的完整服务（例如声明性事务）在本地事务和JTA之间进行交换。此外，与JDBC相关的代码可以与您用于执行ORM的代码完全事务集成。这对于不适合ORM（例如批处理和BLOB流）但仍需要与ORM操作共享常见事务的数据访问很有用。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">要获得更全面的ORM支持，包括对替代数据库技术（例如MongoDB）的支持，您可能需要查看<a href="https://projects.spring.io/spring-data/">Spring Data</a>项目套件。如果您是JPA用户，则<a href="https://spring.io" class="bare">https://spring.io的《</a> <a href="https://spring.io/guides/gs/accessing-data-jpa/">使用JPA入门访问数据》</a>指南提供了很好的介绍。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="orm-general"><a class="anchor" href="#orm-general"></a> 4.2。ORM集成的一般注意事项</h3>
<div class="paragraph">
<p>本节重点介绍适用于所有ORM技术的注意事项。<a href="#orm-hibernate">休眠</a>部分提供更多详细信息，并在具体上下文中显示这些功能和配置。</p>
</div>
<div class="paragraph">
<p>Spring ORM集成的主要目标是清晰的应用程序分层（具有任何数据访问和事务技术），以及松散耦合应用程序对象-不再依赖于数据访问或事务处理策略的业务服务依赖性，不再需要硬编码的资源查找，更多难以替换的单例，不再需要自定义服务注册表。目标是采用一种简单且一致的方法来连接应用程序对象，以使它们尽可能可重用，并且不受容器依赖。所有单独的数据访问功能都可以单独使用，但可以与Spring的应用程序上下文概念很好地集成，从而提供基于XML的配置和对不需要Spring感知的纯JavaBean实例的交叉引用。在典型的Spring应用程序中，许多重要的对象是JavaBean：数据访问模板，数据访问对象，事务管理器，使用数据访问对象和事务管理器的业务服务，Web视图解析器，使用业务服务的Web控制器等等。 。</p>
</div>
<div class="sect3">
<h4 id="orm-resource-mngmnt"><a class="anchor" href="#orm-resource-mngmnt"></a> 4.2.1。资源与交易管理</h4>
<div class="paragraph">
<p>典型的业务应用程序中充斥着重复的资源管理代码。许多项目尝试发明自己的解决方案，有时为了编程方便而牺牲了对故障的正确处理。Spring提倡简单的解决方案来进行适当的资源处理，即在JDBC情况下通过模板化为IoC以及为ORM技术应用AOP拦截器。</p>
</div>
<div class="paragraph">
<p>基础结构提供适当的资源处理，并将特定的API异常适当地转换为未经检查的基础结构异常层次结构。Spring引入了DAO异常层次结构，适用于任何数据访问策略。对于直接JDBC， <code>JdbcTemplate</code> <a href="#jdbc-JdbcTemplate">上一节中</a>提到的类提供了连接处理和适当的转换<code>SQLException</code>到<code>DataAccessException</code>层次结构，包括将特定于数据库的SQL错误代码转换为有意义的异常类。对于ORM技术，请参阅<a href="#orm-exception-translation">下一节</a>以了解如何获得相同的异常转换好处。</p>
</div>
<div class="paragraph">
<p>对于交易管理， <code>JdbcTemplate</code>类通过各自的Spring事务管理器挂接到Spring事务支持并支持JTA和JDBC事务。对于受支持的ORM技术，Spring通过Hibernate和JPA事务管理器提供了Hibernate和JPA支持以及JTA支持。有关事务支持的详细信息，请参见<a href="#transaction">事务管理</a>一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-exception-translation"><a class="anchor" href="#orm-exception-translation"></a> 4.2.2。例外翻译</h4>
<div class="paragraph">
<p>在DAO中使用Hibernate或JPA时，必须决定如何处理持久性技术的本机异常类。DAO抛出a的子类<code>HibernateException</code>要么<code>PersistenceException</code> ，具体取决于技术。这些异常都是运行时异常，不必声明或捕获。您可能还需要处理<code>IllegalArgumentException</code>和<code>IllegalStateException</code> 。这意味着调用者只能将异常视为一般致命的，除非他们希望依赖于持久性技术自身的异常结构。如果不将调用者与实现策略联系在一起，则无法捕获特定原因（例如乐观锁定失败）。这种权衡可能对于基于ORM的应用程序或不需要任何特殊异常处理（或两者都使用）的应用程序是可接受的。但是，Spring允许通过<code>@Repository</code>注解。以下示例（一个用于Java配置，一个用于XML配置）显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Repository
public class ProductDaoImpl implements ProductDao {

    // class body here...

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Repository
class ProductDaoImpl : ProductDao {
    // class body here...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;!-- Exception translation bean post processor --&gt;
    &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>后处理器自动查找所有异常翻译器（ <code>PersistenceExceptionTranslator</code>界面），并建议所有标有<code>@Repository</code>注释，以便发现的翻译人员可以拦截抛出的异常并将其应用于抛出的异常。</p>
</div>
<div class="paragraph">
<p>总之，您可以基于纯持久性技术的API和注释来实现DAO，同时仍可以从Spring管理的事务，依赖项注入和对Spring的自定义异常层次结构的透明异常转换（如果需要）中受益。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="orm-hibernate"><a class="anchor" href="#orm-hibernate"></a> 4.3。冬眠</h3>
<div class="paragraph">
<p>我们从对Spring环境中的<a href="https://hibernate.org/">Hibernate 5</a>的介绍开始，用它来演示Spring用来集成OR映射器的方法。本节详细讨论了许多问题，并展示了DAO实现和事务划分的不同变体。这些模式中的大多数都可以直接转换为所有其他受支持的ORM工具。然后，本章后面的部分将介绍其他ORM技术，并显示一些简短的示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring Framework 5.0开始，Spring需要Hibernate ORM 4.3或更高版本才能提供JPA支持，甚至需要Hibernate ORM 5.0+才能针对本地Hibernate Session API进行编程。请注意，Hibernate团队不再维护5.1之前的任何版本，并且可能很快会专注于5.3+。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="orm-session-factory-setup"><a class="anchor" href="#orm-session-factory-setup"></a> 4.3.1。 <code>SessionFactory</code> 在Spring容器中设置</h4>
<div class="paragraph">
<p>为避免将应用程序对象与硬编码的资源查找绑定在一起，可以定义资源（例如JDBC）。 <code>DataSource</code>或休眠<code>SessionFactory</code> ）作为Spring容器中的bean。需要访问资源的应用程序对象通过bean引用接收对此类预定义实例的引用，如<a href="#orm-hibernate-straight">下一节</a>中的DAO定义所示。</p>
</div>
<div class="paragraph">
<p>以下XML应用程序上下文定义摘录显示了如何设置JDBC <code>DataSource</code>和一个冬眠<code>SessionFactory</code>在它的上面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
        &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
        &lt;property name="username" value="sa"/&gt;
        &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;

    &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="myDataSource"/&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;product.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;value&gt;
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从本地Jakarta Commons DBCP切换<code>BasicDataSource</code>到位于JNDI的位置<code>DataSource</code> （通常由应用程序服务器管理）仅是配置问题，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以访问位于JNDI的<code>SessionFactory</code> ，使用Spring的<code>JndiObjectFactoryBean</code> / <code><jee:jndi-lookup></code>检索并公开它。但是，这通常在EJB上下文之外并不常见。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring还提供了<code>LocalSessionFactoryBuilder</code>变体，与<code>@Bean</code>样式配置和程序设置（否<code>FactoryBean</code>参与）。</p>
</div>
<div class="paragraph">
<p>都<code>LocalSessionFactoryBean</code>和<code>LocalSessionFactoryBuilder</code>支持后台引导，Hibernate初始化与给定引导执行程序上的应用程序引导线程并行运行（例如<code>SimpleAsyncTaskExecutor</code> ）。上<code>LocalSessionFactoryBean</code> ，这可以通过<code>bootstrapExecutor</code>属性。关于程序化<code>LocalSessionFactoryBuilder</code> ，有一个超载<code>buildSessionFactory</code>带有引导执行程序参数的方法。</p>
</div>
<div class="paragraph">
<p>从Spring Framework 5.1开始，这样的本地Hibernate设置也可以公开JPA <code>EntityManagerFactory</code>在本地Hibernate访问旁边进行标准JPA交互。有关详细信息，请参见<a href="#orm-jpa-hibernate">JPA的本机休眠设置</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-straight"><a class="anchor" href="#orm-hibernate-straight"></a> 4.3.2。基于Plain Hibernate API实现DAO</h4>
<div class="paragraph">
<p>Hibernate具有称为上下文会话的功能，其中，Hibernate本身管理一个当前会话。 <code>Session</code>每笔交易。这大致相当于Spring对一个Hibernate的同步<code>Session</code>每笔交易。基于普通的Hibernate API，相应的DAO实现类似于以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ProductDaoImpl(private val sessionFactory: SessionFactory) : ProductDao {

    fun loadProductsByCategory(category: String): Collection&lt;*&gt; {
        return sessionFactory.currentSession
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该样式类似于Hibernate参考文档和示例，除了保留<code>SessionFactory</code>在实例变量中。我们强烈建议在旧版本上使用基于实例的设置<code>static</code><code>HibernateUtil</code> Hibernate的CaveatEmptor示例应用程序中的类。（通常，请勿将任何资源<code>static</code>变量，除非绝对必要。）</p>
</div>
<div class="paragraph">
<p>前面的DAO示例遵循依赖项注入模式。它很好地适合于Spring IoC容器，就像针对Spring的代码进行编码一样<code>HibernateTemplate</code> 。您还可以在纯Java中设置这种DAO（例如，在单元测试中）。为此，将其实例化并调用<code>setSessionFactory(..)</code>与所需的工厂参考。作为Spring bean的定义，DAO类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种DAO样式的主要优点是它仅依赖于Hibernate API。不需要导入任何Spring类。从非侵入性的角度来看，这很有吸引力，并且对于Hibernate开发人员而言可能更自然。</p>
</div>
<div class="paragraph">
<p>但是，DAO却很简单<code>HibernateException</code> （这是未经检查的，因此不必声明或捕获），这意味着调用者只能将异常视为一般致命的-除非他们希望依赖于Hibernate自己的异常层次结构。如果不将调用者与实现策略联系在一起，则无法捕获特定原因（例如乐观锁定失败）。这种权衡对于基于Hibernate的应用程序，不需要任何特殊异常处理或两者都可以接受。</p>
</div>
<div class="paragraph">
<p>幸运的是，春天的<code>LocalSessionFactoryBean</code>支持Hibernate的<code>SessionFactory.getCurrentSession()</code>任何Spring交易策略的方法，返回当前Spring管理的交易对象<code>Session</code> ， 即使<code>HibernateTransactionManager</code> 。该方法的标准行为仍然是返回当前<code>Session</code>与正在进行的JTA交易相关联（如果有）。无论您是否使用Spring的<code>JtaTransactionManager</code> ，EJB容器管理的事务（CMT）或JTA。</p>
</div>
<div class="paragraph">
<p>总之，您可以基于普通的Hibernate API实现DAO，同时仍然可以参与Spring管理的事务。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-tx-declarative"><a class="anchor" href="#orm-hibernate-tx-declarative"></a> 4.3.3。声明式事务划分</h4>
<div class="paragraph">
<p>我们建议您使用Spring的声明式事务支持，该支持使您可以用AOP事务拦截器替换Java代码中的显式事务划分API调用。您可以使用Java批注或XML在Spring容器中配置此事务拦截器。这种声明式事务处理功能使您可以使业务服务摆脱重复的事务划分代码，并专注于添加业务逻辑，这是应用程序的真正价值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在继续之前，强烈建议您阅读<a href="#transaction-declarative">声明式事务管理（</a>如果您尚未阅读的话）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用以下注释服务层<code>@Transactional</code>注释，并指示Spring容器找到这些注释并为这些带注释的方法提供事务性语义。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    @Transactional
    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDao.loadProductsByCategory(category);
        // ...
    }

    @Transactional(readOnly = true)
    public List&lt;Product&gt; findAllProducts() {
        return this.productDao.findAllProducts();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ProductServiceImpl(private val productDao: ProductDao) : ProductService {

    @Transactional
    fun increasePriceOfAllProductsInCategory(category: String) {
        val productsToChange = productDao.loadProductsByCategory(category)
        // ...
    }

    @Transactional(readOnly = true)
    fun findAllProducts() = productDao.findAllProducts()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在容器中，您需要设置<code>PlatformTransactionManager</code>实现（作为bean）和<code><tx:annotation-driven/></code>进入，选择加入<code>@Transactional</code>在运行时进行处理。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- SessionFactory, DataSource, etc. omitted --&gt;

    &lt;bean id="transactionManager"
            class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;tx:annotation-driven/&gt;

    &lt;bean id="myProductService" class="product.SimpleProductService"&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-tx-programmatic"><a class="anchor" href="#orm-hibernate-tx-programmatic"></a> 4.3.4。程序化交易划分</h4>
<div class="paragraph">
<p>您可以在应用程序的更高级别中划分事务，在跨越任意数量的操作的较低级别数据访问服务之上。对周围业务服务的实施也没有限制。它只需要一个春天<code>PlatformTransactionManager</code> 。同样，后者可以来自任何地方，但最好通过<code>setTransactionManager(..)</code>方法。另外， <code>productDAO</code>应该由<code>setProductDao(..)</code>方法。以下几对代码片段显示了Spring应用程序上下文中的事务管理器和业务服务定义，以及业务方法实现的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="myTxManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
        &lt;property name="transactionManager" ref="myTxManager"/&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ProductServiceImpl implements ProductService {

    private TransactionTemplate transactionTemplate;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            public void doInTransactionWithoutResult(TransactionStatus status) {
                List productsToChange = this.productDao.loadProductsByCategory(category);
                // do the price increase...
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ProductServiceImpl(transactionManager: PlatformTransactionManager,
                        private val productDao: ProductDao) : ProductService {

    private val transactionTemplate = TransactionTemplate(transactionManager)

    fun increasePriceOfAllProductsInCategory(category: String) {
        transactionTemplate.execute {
            val productsToChange = productDao.loadProductsByCategory(category)
            // do the price increase...
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>春天的<code>TransactionInterceptor</code>让所有检查过的应用程序异常与回调代码一起抛出，而<code>TransactionTemplate</code>仅限于回调中未经检查的异常。 <code>TransactionTemplate</code>在未检查的应用程序异常或应用程序将事务标记为仅回滚的情况下触发回滚（通过设置<code>TransactionStatus</code> ）。默认， <code>TransactionInterceptor</code>行为相同，但是允许每种方法配置可回滚策略。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-tx-strategies"><a class="anchor" href="#orm-hibernate-tx-strategies"></a> 4.3.5。交易管理策略</h4>
<div class="paragraph">
<p>都<code>TransactionTemplate</code>和<code>TransactionInterceptor</code>将实际的交易处理委托给<code>PlatformTransactionManager</code>实例（可以是<code>HibernateTransactionManager</code> （对于单个休眠<code>SessionFactory</code> ）使用<code>ThreadLocal</code><code>Session</code>在引擎盖下）或<code>JtaTransactionManager</code> （委托给容器的JTA子系统）用于Hibernate应用程序。您甚至可以使用自定义<code>PlatformTransactionManager</code>实施。从本机Hibernate事务管理切换到JTA（例如，当面对某些应用程序部署的分布式事务要求时）仅是配置问题。您可以用Spring的JTA事务实现替换Hibernate事务管理器。事务划分和数据访问代码都无需更改即可工作，因为它们使用通用的事务管理API。</p>
</div>
<div class="paragraph">
<p>对于跨多个Hibernate会话工厂的分布式事务，可以结合使用<code>JtaTransactionManager</code>作为具有多个交易策略<code>LocalSessionFactoryBean</code>定义。然后每个DAO都有一个特定的<code>SessionFactory</code>引用传递到其相应的bean属性中。如果所有基础JDBC数据源都是事务性容器数据源，则业务服务可以跨任意数量的DAO和任意数量的会话工厂划分事务，而无需特别注意，只要它使用<code>JtaTransactionManager</code>作为策略。</p>
</div>
<div class="paragraph">
<p>都<code>HibernateTransactionManager</code>和<code>JtaTransactionManager</code>允许使用Hibernate进行正确的JVM级别的缓存处理，而无需特定于容器的事务管理器查找或JCA连接器（如果您不使用EJB来初始化事务）。</p>
</div>
<div class="paragraph">
<p><code>HibernateTransactionManager</code>可以导出Hibernate JDBC <code>Connection</code>特定的普通JDBC访问代码<code>DataSource</code> 。此功能允许使用混合的Hibernate和JDBC数据访问进行高级事务划分，而完全无需JTA，前提是您仅访问一个数据库。 <code>HibernateTransactionManager</code>如果已设置传入的，则自动将Hibernate事务公开为JDBC事务<code>SessionFactory</code>与一个<code>DataSource</code>通过<code>dataSource</code>的属性<code>LocalSessionFactoryBean</code>类。或者，您可以明确指定<code>DataSource</code>对于这些交易，应该通过<code>dataSource</code>的属性<code>HibernateTransactionManager</code>类。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-resources"><a class="anchor" href="#orm-hibernate-resources"></a> 4.3.6。比较容器管理的资源和本地定义的资源</h4>
<div class="paragraph">
<p>您可以在容器管理的JNDI之间切换<code>SessionFactory</code>和本地定义的代码，而无需更改任何一行应用程序代码。将资源定义保留在容器中还是在应用程序中本地保留，主要取决于您使用的事务策略。与Spring定义的本地相比<code>SessionFactory</code> ，手动注册的JNDI <code>SessionFactory</code>没有提供任何好处。部署<code>SessionFactory</code>通过Hibernate的JCA连接器提供了参与Java EE服务器的管理基础架构的附加值，但没有增加附加值。</p>
</div>
<div class="paragraph">
<p>Spring的事务支持未绑定到容器。当使用除JTA之外的任何其他策略配置时，事务支持还可以在独立或测试环境中工作。尤其是在单数据库事务的典型情况下，Spring的单资源本地事务支持是JTA的轻量级功能强大的替代方案。当您使用本地EJB无状态会话Bean驱动事务时，即使您仅访问单个数据库并且仅使用无状态会话Bean通过容器管理的事务来提供声明性事务，也要依赖EJB容器和JTA。以编程方式直接使用JTA还需要Java EE环境。就JTA本身和JNDI而言，JTA不仅仅涉及容器依赖项<code>DataSource</code>实例。对于非Spring的，由JTA驱动的Hibernate事务，您必须将Hibernate JCA连接器或额外的Hibernate事务代码与<code>TransactionManagerLookup</code>配置为正确的JVM级别的缓存。</p>
</div>
<div class="paragraph">
<p>Spring驱动的事务可以与本地定义的Hibernate一起工作<code>SessionFactory</code>就像使用本地JDBC一样<code>DataSource</code> （前提是他们访问单个数据库）。因此，当您具有分布式事务需求时，仅需要使用Spring的JTA事务策略。JCA连接器需要特定于容器的部署步骤，并且首先需要（显然）JCA支持。与部署具有本地资源定义和Spring驱动的事务的简单Web应用程序相比，此配置需要更多的工作。另外，如果使用的是WebLogic Express，则通常需要使用容器的企业版，而WebLogic Express不提供JCA。具有跨单个数据库的本地资源和事务的Spring应用程序可以在任何Java EE Web容器（没有JTA，JCA或EJB）中工作，例如Tomcat，Resin甚至是普通Jetty。此外，您可以轻松地在桌面应用程序或测试套件中重用这样的中间层。</p>
</div>
<div class="paragraph">
<p>考虑到所有问题，如果不使用EJB，请坚持使用local <code>SessionFactory</code>设置和Spring的<code>HibernateTransactionManager</code>要么<code>JtaTransactionManager</code> 。您将获得所有好处，包括适当的事务性JVM级别的缓存和分布式事务，而不会给容器部署带来不便。休眠的JNDI注册<code>SessionFactory</code>仅当与EJB结合使用时，通过JCA连接器才能增加价值。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-hibernate-invalid-jdbc-access-error"><a class="anchor" href="#orm-hibernate-invalid-jdbc-access-error"></a> 4.3.7。Hibernate虚假的应用程序服务器警告</h4>
<div class="paragraph">
<p>在某些JTA环境中非常严格<code>XADataSource</code>在不考虑JTA的情况下配置Hibernate时的实现（当前仅某些WebLogic Server和WebSphere版本） <code>PlatformTransactionManager</code>该环境的对象，虚假警告或异常可能会显示在应用程序服务器日志中。这些警告或异常指示正在访问的连接不再有效或JDBC访问不再有效，这可能是因为事务不再有效。例如，这是WebLogic的实际异常：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java.sql.SQLException: The transaction is no longer active - status: 'Committed'. No
further JDBC access is allowed within this transaction.</pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过使Hibernate知道JTA来解决此警告。 <code>PlatformTransactionManager</code>实例（与Spring同步）。您可以通过以下两种方式执行此操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果在您的应用程序上下文中，您已经直接获得了JTA <code>PlatformTransactionManager</code>对象（大概是从JNDI通过<code>JndiObjectFactoryBean</code>要么<code><jee:jndi-lookup></code> ）并将其输入例如Spring的<code>JtaTransactionManager</code> ，最简单的方法是指定对定义此JTA的bean的引用<code>PlatformTransactionManager</code>实例作为<code>jtaTransactionManager</code>的财产<code>LocalSessionFactoryBean.</code>然后，Spring使对象可用于Hibernate。</p>
</li>
<li>
<p>您更有可能没有JTA <code>PlatformTransactionManager</code>例如，因为春天的<code>JtaTransactionManager</code>可以找到它本身。因此，您需要配置Hibernate来查找JTA <code>PlatformTransactionManager</code>直。通过配置特定于应用程序服务器来执行此操作<code>TransactionManagerLookup</code> Hibernate配置中的类，如Hibernate手册中所述。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节的其余部分描述了在Hibernate不了解JTA的情况下发生的事件的顺序。 <code>PlatformTransactionManager</code> 。</p>
</div>
<div class="paragraph">
<p>当未对HTA进行JTA意识时<code>PlatformTransactionManager</code> ，在JTA事务提交时发生以下事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JTA事务提交。</p>
</li>
<li>
<p>春天的<code>JtaTransactionManager</code>已同步到JTA事务，因此通过<code>afterCompletion</code> JTA事务管理器回调。</p>
</li>
<li>
<p>除其他活动外，这种同步还可以触发Spring通过Hibernate的回调到Hibernate <code>afterTransactionCompletion</code>回调（用于清除Hibernate缓存），后跟显式<code>close()</code>调用Hibernate会话，这会导致Hibernate尝试<code>close()</code> JDBC连接。</p>
</li>
<li>
<p>在某些环境中<code>Connection.close()</code>然后调用会触发警告或错误，因为应用程序服务器不再考虑<code>Connection</code>之所以可以使用，是因为交易已经提交。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当Hibernate配置为具有JTA意识时<code>PlatformTransactionManager</code> ，在JTA事务提交时发生以下事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JTA事务已准备好提交。</p>
</li>
<li>
<p>春天的<code>JtaTransactionManager</code>已同步到JTA事务，因此通过<code>beforeCompletion</code> JTA事务管理器回调。</p>
</li>
<li>
<p>Spring意识到，Hibernate本身已同步到JTA事务，并且其行为与以前的场景不同。假设休眠<code>Session</code>需要完全关闭，Spring现在关闭了。</p>
</li>
<li>
<p>JTA事务提交。</p>
</li>
<li>
<p>Hibernate已同步到JTA事务，因此该事务通过<code>afterCompletion</code>由JTA事务管理器回调，并且可以正确清除其缓存。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="orm-jpa"><a class="anchor" href="#orm-jpa"></a> 4.4。JPA</h3>
<div class="paragraph">
<p>Spring JPA，可在<code>org.springframework.orm.jpa</code>软件包以类似于与Hibernate集成的方式提供对<a href="https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html">Java Persistence API的</a>全面支持，同时了解底层实现以便提供附加功能。</p>
</div>
<div class="sect3">
<h4 id="orm-jpa-setup"><a class="anchor" href="#orm-jpa-setup"></a> 4.4.1。在Spring环境中设置JPA的三个选项</h4>
<div class="paragraph">
<p>Spring JPA支持提供了三种设置JPA的方法<code>EntityManagerFactory</code>应用程序使用它来获取实体管理器。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#orm-jpa-setup-lemfb">使用<code>LocalEntityManagerFactoryBean</code></a></p>
</li>
<li>
<p><a href="#orm-jpa-setup-jndi">从JNDI获取EntityManagerFactory</a></p>
</li>
<li>
<p><a href="#orm-jpa-setup-lcemfb">使用<code>LocalContainerEntityManagerFactoryBean</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-lemfb"><a class="anchor" href="#orm-jpa-setup-lemfb"></a>使用<code>LocalEntityManagerFactoryBean</code></h5>
<div class="paragraph">
<p>您只能在简单的部署环境（例如独立应用程序和集成测试）中使用此选项。</p>
</div>
<div class="paragraph">
<p>的<code>LocalEntityManagerFactoryBean</code>创建一个<code>EntityManagerFactory</code>适用于应用程序仅使用JPA进行数据访问的简单部署环境。工厂bean使用JPA <code>PersistenceProvider</code>自动检测机制（根据JPA的Java SE自举），并且在大多数情况下，只需要您指定持久性单元名称即可。以下XML示例配置了这样的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceUnitName" value="myPersistenceUnit"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种形式的JPA部署是最简单和最有限的。您不能引用现有的JDBC <code>DataSource</code> bean定义，不存在对全局事务的支持。此外，持久类的编织（字节码转换）是特定于提供程序的，通常需要在启动时指定特定的JVM代理。该选项仅对于设计了JPA规范的独立应用程序和测试环境就足够了。</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-jndi"><a class="anchor" href="#orm-jpa-setup-jndi"></a>从JNDI获取EntityManagerFactory</h5>
<div class="paragraph">
<p>部署到Java EE服务器时，可以使用此选项。查看服务器的文档，以了解如何将自定义JPA提供程序部署到服务器中，从而允许使用不同于服务器默认值的提供程序。</p>
</div>
<div class="paragraph">
<p>获得一个<code>EntityManagerFactory</code>从JNDI（例如，在Java EE环境中），可以更改XML配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此操作假定标准Java EE引导。Java EE服务器自动检测持久性单元（实际上， <code>META-INF/persistence.xml</code>应用程序jar中的文件）和<code>persistence-unit-ref</code> Java EE部署描述符中的条目（例如， <code>web.xml</code> ），并为这些持久性单元定义环境命名上下文位置。</p>
</div>
<div class="paragraph">
<p>在这种情况下，整个持久性单元部署，包括持久性类的编织（字节码转换），都取决于Java EE服务器。JDBC <code>DataSource</code>是通过JNDI位置中的<code>META-INF/persistence.xml</code>文件。
<code>EntityManager</code>事务与服务器的JTA子系统集成在一起。Spring仅使用获得的<code>EntityManagerFactory</code> ，通过依赖性注入将其传递给应用程序对象，并管理持久性单元的事务（通常通过<code>JtaTransactionManager</code> ）。</p>
</div>
<div class="paragraph">
<p>如果在同一应用程序中使用多个持久性单元，则此类JNDI检索的持久性单元的bean名称应与应用程序用来引用它们的持久性单元名称匹配（例如，在<code>@PersistenceUnit</code>和<code>@PersistenceContext</code>注释）。</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-lcemfb"><a class="anchor" href="#orm-jpa-setup-lcemfb"></a>使用<code>LocalContainerEntityManagerFactoryBean</code></h5>
<div class="paragraph">
<p>您可以在基于Spring的应用程序环境中将此选项用于完整的JPA功能。这包括Web容器（例如Tomcat），独立应用程序以及具有复杂持久性要求的集成测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果要专门配置Hibernate设置，则直接的替代方法是使用Hibernate 5.2或5.3并设置本机Hibernate <code>LocalSessionFactoryBean</code>而不是普通的JPA <code>LocalContainerEntityManagerFactoryBean</code> ，使其与JPA访问代码以及本机Hibernate访问代码进行交互。有关详细信息，请参见<a href="#orm-jpa-hibernate">用于JPA交互的本机Hibernate设置</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>LocalContainerEntityManagerFactoryBean</code>完全控制<code>EntityManagerFactory</code>配置，适用于需要细粒度自定义的环境。的<code>LocalContainerEntityManagerFactoryBean</code>创建一个<code>PersistenceUnitInfo</code>实例基于<code>persistence.xml</code>文件，提供<code>dataSourceLookup</code>策略，并指定<code>loadTimeWeaver</code> 。因此，可以在JNDI之外使用自定义数据源并控制编织过程。以下示例显示了针对<code>LocalContainerEntityManagerFactoryBean</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="dataSource" ref="someDataSource"/&gt;
        &lt;property name="loadTimeWeaver"&gt;
            &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了一个典型的<code>persistence.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0"&gt;
    &lt;persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;mapping-file&gt;META-INF/orm.xml&lt;/mapping-file&gt;
        &lt;exclude-unlisted-classes/&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code><exclude-unlisted-classes/></code>快捷方式指示不应对带注释的实体类进行扫描。明确的“真实”值（ <code><exclude-unlisted-classes>true</exclude-unlisted-classes/></code> ）也表示不进行扫描。
<code><exclude-unlisted-classes>false</exclude-unlisted-classes/></code>确实会触发扫描。但是，我们建议省略<code>exclude-unlisted-classes</code>元素，如果要进行实体类扫描。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用<code>LocalContainerEntityManagerFactoryBean</code>是最强大的JPA设置选项，允许在应用程序内进行灵活的本地配置。它支持到现有JDBC的链接<code>DataSource</code> ，同时支持本地和全局事务，等等。但是，这也对运行时环境提出了要求，例如，如果持久性提供程序需要字节码转换，则具有可编织类加载器的可用性。</p>
</div>
<div class="paragraph">
<p>此选项可能与Java EE服务器的内置JPA功能冲突。在完整的Java EE环境中，请考虑获取您的<code>EntityManagerFactory</code>来自JNDI。或者，指定一个自定义<code>persistenceXmlLocation</code>在你的<code>LocalContainerEntityManagerFactoryBean</code>定义（例如，META-INF / my-persistence.xml），并且在应用程序jar文件中仅包含具有该名称的描述符。因为Java EE服务器仅查找默认值<code>META-INF/persistence.xml</code>文件，它会忽略此类自定义持久性单元，因此避免了与Spring预先驱动的JPA设置产生冲突。（例如，这适用于Resin 3.1。）</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">什么时候需要加载时编织？</div>
<div class="paragraph">
<p>并非所有的JPA提供程序都需要JVM代理。休眠是一个没有的例子。如果您的提供程序不需要代理，或者您还有其他选择，例如在构建时通过自定义编译器或Ant任务应用增强功能，则不应使用加载时织布器。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>LoadTimeWeaver</code>接口是Spring提供的类，可让JPA <code>ClassTransformer</code>根据环境是Web容器还是应用程序服务器，以特定方式插入实例。挂钩<code>ClassTransformers</code>通过<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理</a>通常效率不高。代理针对整个虚拟机工作，并检查每个已加载的类，这在生产服务器环境中通常是不希望的。</p>
</div>
<div class="paragraph">
<p>Spring提供了一些<code>LoadTimeWeaver</code>各种环境的实现，让<code>ClassTransformer</code>实例仅应用于每个类加载器，而不应用于每个VM。</p>
</div>
<div class="paragraph">
<p>请参阅AOP章节中的<a href="core.html#aop-aj-ltw-spring">Spring配置</a> ，以获取有关<code>LoadTimeWeaver</code>各种平台（例如Tomcat，JBoss和WebSphere）通用的或定制的实现及其设置。</p>
</div>
<div class="paragraph">
<p>如<a href="core.html#aop-aj-ltw-spring">Spring配置中所述</a> ，您可以配置上下文范围<code>LoadTimeWeaver</code>通过使用<code>@EnableLoadTimeWeaving</code>的注释<code>context:load-time-weaver</code> XML元素。所有JPA都会自动选择这样的全局编织者<code>LocalContainerEntityManagerFactoryBean</code>实例。下面的示例显示了设置加载时间编织器，传递对平台的自动检测（例如Tomcat的具有编织功能的类加载器或Spring的JVM代理）以及将编织器自动传播到所有可感知编织器的bean的首选方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context:load-time-weaver/&gt;
&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您可以根据需要手动指定专用的织布工<code>loadTimeWeaver</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="loadTimeWeaver"&gt;
        &lt;bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论LTW的配置方式如何，通过使用此技术，依赖于检测的JPA应用程序都可以在目标平台（例如Tomcat）中运行，而无需代理。当托管应用程序依赖于不同的JPA实现时，这一点尤其重要，因为JPA转换器仅在类加载器级别应用，因此彼此隔离。</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-multiple"><a class="anchor" href="#orm-jpa-setup-multiple"></a>处理多个持久性单元</h5>
<div class="paragraph">
<p>对于依赖多个持久性单元位置的应用程序（例如，存储在类路径中的各种JARS中），Spring提供了<code>PersistenceUnitManager</code>充当中央存储库并避免持久性单元发现过程，这可能是昂贵的。默认实现允许指定多个位置。解析这些位置，然后通过持久性单元名称进行检索。（默认情况下，搜索类路径<code>META-INF/persistence.xml</code>文件。）以下示例配置多个位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"&gt;
    &lt;property name="persistenceXmlLocations"&gt;
        &lt;list&gt;
            &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;
            &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;
            &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="dataSources"&gt;
        &lt;map&gt;
            &lt;entry key="localDataSource" value-ref="local-db"/&gt;
            &lt;entry key="remoteDataSource" value-ref="remote-db"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- if no datasource is specified, use this one --&gt;
    &lt;property name="defaultDataSource" ref="remoteDataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="persistenceUnitManager" ref="pum"/&gt;
    &lt;property name="persistenceUnitName" value="myCustomUnit"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认实现允许自定义<code>PersistenceUnitInfo</code>实例（在将它们提供给JPA提供者之前）是声明式的（通过其影响所有托管单元的属性）或以编程方式（通过<code>PersistenceUnitPostProcessor</code> ，这允许选择持久性单元）。如果不<code>PersistenceUnitManager</code>指定，一个由内部创建和使用<code>LocalContainerEntityManagerFactoryBean</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="orm-jpa-setup-background"><a class="anchor" href="#orm-jpa-setup-background"></a>后台引导</h5>
<div class="paragraph">
<p><code>LocalContainerEntityManagerFactoryBean</code>支持通过<code>bootstrapExecutor</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    &lt;property name="bootstrapExecutor"&gt;
        &lt;bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际的JPA提供程序引导将移交给指定的执行程序，然后并行运行到应用程序引导线程。暴露的<code>EntityManagerFactory</code>代理可以注入到其他应用程序组件中，甚至能够响应<code>EntityManagerFactoryInfo</code>配置检查。但是，一旦其他组件访问了实际的JPA提供程序（例如，调用<code>createEntityManager</code> ），这些调用将一直阻塞，直到后台引导完成为止。特别是，当您使用Spring Data JPA时，请确保还为其存储库设置了延迟引导。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-dao"><a class="anchor" href="#orm-jpa-dao"></a> 4.4.2。基于JPA实施DAO： <code>EntityManagerFactory</code>和<code>EntityManager</code></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">虽然<code>EntityManagerFactory</code>实例是线程安全的， <code>EntityManager</code>实例不是。注入的JPA <code>EntityManager</code>表现得像<code>EntityManager</code>从应用程序服务器的JNDI环境中获取，该环境由JPA规范定义。它将所有呼叫委托给当前事务<code>EntityManager</code> （如果有）。否则，它会退回到新创建的<code>EntityManager</code>每个操作，实际上使它的使用成为线程安全的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过使用注入，可以在没有任何Spring依赖的情况下针对普通JPA编写代码<code>EntityManagerFactory</code>要么<code>EntityManager</code> 。春天可以理解了<code>@PersistenceUnit</code>和<code>@PersistenceContext</code>如果是，则在字段和方法级别都注释<code>PersistenceAnnotationBeanPostProcessor</code>已启用。以下示例显示了一个简单的JPA DAO实现，该实现使用<code>@PersistenceUnit</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        try (EntityManager em = this.emf.createEntityManager()) {
            Query query = em.createQuery("from Product as p where p.category = ?1");
            query.setParameter(1, category);
            return query.getResultList();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ProductDaoImpl : ProductDao {

    private lateinit var emf: EntityManagerFactory

    @PersistenceUnit
    fun setEntityManagerFactory(emf: EntityManagerFactory) {
        this.emf = emf
    }

    fun loadProductsByCategory(category: String): Collection&lt;*&gt; {
        val em = this.emf.createEntityManager()
        val query = em.createQuery("from Product as p where p.category = ?1");
        query.setParameter(1, category);
        return query.resultList;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的DAO不依赖于Spring，并且仍然非常适合Spring应用程序上下文。此外，DAO利用注释来要求注入默认值<code>EntityManagerFactory</code> ，如以下示例Bean定义所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;!-- bean post-processor for JPA annotations --&gt;
    &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为显式定义a的替代方法<code>PersistenceAnnotationBeanPostProcessor</code> ，考虑使用Spring <code>context:annotation-config</code>应用程序上下文配置中的XML元素。这样做会自动注册所有Spring标准后处理器以进行基于注释的配置，包括<code>CommonAnnotationBeanPostProcessor</code>等等。</p>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;!-- post-processors for all standard config annotations --&gt;
    &lt;context:annotation-config/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种DAO的主要问题在于，它总是会创建一个新的<code>EntityManager</code>通过工厂。您可以通过请求交易来避免这种情况<code>EntityManager</code> （也称为“共享的EntityManager”，因为它是实际事务EntityManager的共享的线程安全代理）将被注入而不是工厂。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
        Query query = em.createQuery("from Product as p where p.category = :category");
        query.setParameter("category", category);
        return query.getResultList();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class ProductDaoImpl : ProductDao {

    @PersistenceContext
    private lateinit var em: EntityManager

    fun loadProductsByCategory(category: String): Collection&lt;*&gt; {
        val query = em.createQuery("from Product as p where p.category = :category")
        query.setParameter("category", category)
        return query.resultList
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@PersistenceContext</code>注释具有一个称为的可选属性<code>type</code> ，默认为<code>PersistenceContextType.TRANSACTION</code> 。您可以使用此默认设置来接收共享<code>EntityManager</code>代理。替代方案<code>PersistenceContextType.EXTENDED</code> ，是完全不同的事情。这导致所谓的扩展<code>EntityManager</code> ，它不是线程安全的，因此，不能在并发访问的组件（例如，Spring管理的Singleton Bean）中使用。扩展的<code>EntityManager</code>实例仅应在有状态组件中使用，例如，存在于会话中的状态组件具有<code>EntityManager</code>不依赖于当前事务，而是完全取决于应用程序。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">方法级和现场级进样</div>
<div class="paragraph">
<p>您可以应用指示依赖项注入的注释（例如<code>@PersistenceUnit</code>和<code>@PersistenceContext</code> ）或类中的字段或方法-因此表述为“方法级注入”和“字段级注入”。字段级注释简洁明了，易于使用，而方法级注释则允许对注入的依赖项进行进一步处理。在这两种情况下，成员的可见性（公共，受保护或私有）都无关紧要。</p>
</div>
<div class="paragraph">
<p>那类级别的注释呢？</p>
</div>
<div class="paragraph">
<p>在Java EE平台上，它们用于依赖性声明，而不用于资源注入。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>注入<code>EntityManager</code>由Spring管理（知道正在进行的事务）。即使新的DAO实现使用了方法级别的<code>EntityManager</code>而不是<code>EntityManagerFactory</code> ，由于使用了注释，因此无需更改应用程序上下文XML。</p>
</div>
<div class="paragraph">
<p>这种DAO样式的主要优点是它仅取决于Java Persistence API。不需要导入任何Spring类。此外，由于可以理解JPA批注，因此Spring容器会自动应用注入。从非侵入性的角度来看，这是有吸引力的，并且对于JPA开发人员而言，感觉会更自然。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-tx"><a class="anchor" href="#orm-jpa-tx"></a> 4.4.3。春季驱动的JPA交易</h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">强烈建议您阅读<a href="#transaction-declarative">声明式事务管理</a> ，如果您还没有阅读过的话，可以更详细地介绍Spring的声明式事务支持。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>JPA推荐的策略是通过JPA的本机事务支持进行本地事务。春天的<code>JpaTransactionManager</code>针对任何常规JDBC连接池（无需XA要求），它提供了许多本地JDBC事务已知的功能（例如，特定于事务的隔离级别和资源级别的只读优化）。</p>
</div>
<div class="paragraph">
<p>Spring JPA还允许配置<code>JpaTransactionManager</code>将JPA事务公开给访问相同访问权限的JDBC访问代码<code>DataSource</code> ，前提是已注册<code>JpaDialect</code>支持检索基础JDBC <code>Connection</code> 。Spring为EclipseLink和Hibernate JPA实现提供了方言。请参阅<a href="#orm-jpa-dialect">下一部分，</a>以获取有关<code>JpaDialect</code>机制。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">作为直接替代，Spring的本地人<code>HibernateTransactionManager</code>能够与Spring Framework 5.1和Hibernate 5.2 / 5.3以及更高版本的JPA访问代码进行交互，以适应多种Hibernate规范并提供JDBC交互。这与结合使用特别有意义<code>LocalSessionFactoryBean</code>设定。有关详细信息，请参见<a href="#orm-jpa-hibernate">用于JPA交互的本机休眠设置</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-dialect"><a class="anchor" href="#orm-jpa-dialect"></a> 4.4.4。理解<code>JpaDialect</code>和<code>JpaVendorAdapter</code></h4>
<div class="paragraph">
<p>作为一项高级功能， <code>JpaTransactionManager</code>和的子类<code>AbstractEntityManagerFactoryBean</code>允许自定义<code>JpaDialect</code>被传递到<code>jpaDialect</code> bean属性。一种<code>JpaDialect</code>实现通常可以以特定于供应商的方式启用Spring支持的以下高级功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>应用特定的事务语义（例如自定义隔离级别或事务超时）</p>
</li>
<li>
<p>检索事务性JDBC <code>Connection</code> （用于公开基于JDBC的DAO）</p>
</li>
<li>
<p>的高级翻译<code>PersistenceExceptions</code>到春天<code>DataAccessExceptions</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这对于特殊的事务语义和异常的高级翻译特别有价值。默认实现（ <code>DefaultJpaDialect</code> ）不提供任何特殊功能，如果需要前面列出的功能，则必须指定适当的方言。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">作为更广泛的提供商适应工具，主要针对Spring的全功能<code>LocalContainerEntityManagerFactoryBean</code>设定， <code>JpaVendorAdapter</code>结合了以下功能<code>JpaDialect</code>以及其他提供商特定的默认设置。指定一个<code>HibernateJpaVendorAdapter</code>要么<code>EclipseLinkJpaVendorAdapter</code>是自动配置<code>EntityManagerFactory</code>分别为Hibernate或EclipseLink进行设置。请注意，这些提供程序适配器主要设计用于与Spring驱动的事务管理一起使用（即，与<code>JpaTransactionManager</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaDialect.html"><code>JpaDialect</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaVendorAdapter.html"><code>JpaVendorAdapter</code></a>有关Javadoc的操作以及如何在Spring的JPA支持中使用它们的更多详细信息，请参见javadoc。</p>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-jta"><a class="anchor" href="#orm-jpa-jta"></a> 4.4.5。使用JTA事务管理设置JPA</h4>
<div class="paragraph">
<p>作为替代<code>JpaTransactionManager</code> ，Spring还允许在Java EE环境中或通过独立的事务协调器（例如Atomikos）通过JTA进行多资源事务协调。除了选择Spring的<code>JtaTransactionManager</code>代替<code>JpaTransactionManager</code> ，您需要采取其他一些步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>底层的JDBC连接池必须具有XA功能，并与事务协调器集成。在Java EE环境中，这通常很简单，它公开了另一种<code>DataSource</code>通过JNDI。有关详细信息，请参见您的应用程序服务器文档。类似地，独立的事务协调器通常带有特殊的XA集成<code>DataSource</code>实现。再次，检查其文档。</p>
</li>
<li>
<p>JPA <code>EntityManagerFactory</code>需要为JTA配置安装程序。这是特定于提供程序的，通常通过将特殊属性指定为<code>jpaProperties</code>上<code>LocalContainerEntityManagerFactoryBean</code> 。对于Hibernate，这些属性甚至是特定于版本的。有关详细信息，请参见Hibernate文档。</p>
</li>
<li>
<p>春天的<code>HibernateJpaVendorAdapter</code>强制执行某些面向Spring的默认设置，例如连接释放模式， <code>on-close</code> ，它与Hibernate 5.0中Hibernate自己的默认值匹配，但在5.1 / 5.2中不再匹配。对于JTA设置，不要声明<code>HibernateJpaVendorAdapter</code>开始或关闭它<code>prepareConnection</code>旗。另外，设置Hibernate 5.2 <code>hibernate.connection.handling_mode</code>财产<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT</code>恢复Hibernate自己的默认值。有关WebLogic的相关说明，请参见<a href="#orm-hibernate-invalid-jdbc-access-error">带有Hibernate的Spurious Application Server警告</a> 。</p>
</li>
<li>
<p>或者，考虑获得<code>EntityManagerFactory</code>从您的应用程序服务器本身（即通过JNDI查找而不是本地声明） <code>LocalContainerEntityManagerFactoryBean</code> ）。服务器提供<code>EntityManagerFactory</code>在服务器配置中可能需要特殊定义（使部署的便携性降低），但是是针对服务器的JTA环境设置的。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="orm-jpa-hibernate"><a class="anchor" href="#orm-jpa-hibernate"></a> 4.4.6。JPA交互的本机Hibernate设置和本机Hibernate事务</h4>
<div class="paragraph">
<p>从Spring Framework 5.1和Hibernate 5.2 / 5.3开始，本机<code>LocalSessionFactoryBean</code>结合设置<code>HibernateTransactionManager</code>允许与<code>@PersistenceContext</code>和其他JPA访问代码。冬眠<code>SessionFactory</code>本机实现JPA <code>EntityManagerFactory</code>现在界面和一个休眠<code>Session</code>本机处理是JPA <code>EntityManager</code> 。Spring的JPA支持工具会自动检测本地Hibernate会话。</p>
</div>
<div class="paragraph">
<p>因此，这种本地Hibernate设置可以代替标准JPA <code>LocalContainerEntityManagerFactoryBean</code>和<code>JpaTransactionManager</code>在许多情况下都可以组合使用，从而可以与<code>SessionFactory.getCurrentSession()</code> （并且<code>HibernateTemplate</code> ） 旁边的<code>@PersistenceContext EntityManager</code>在同一本地交易中。这样的设置还提供了更强大的Hibernate集成和更大的配置灵活性，因为它不受JPA引导合同的约束。</p>
</div>
<div class="paragraph">
<p>你不需要<code>HibernateJpaVendorAdapter</code>在这种情况下进行配置，因为Spring的本机Hibernate设置提供了更多功能（例如，自定义Hibernate Integrator设置，Hibernate 5.3 Bean容器集成以及对只读事务的更强优化）。最后但并非最不重要的一点是，您还可以通过以下方式表达本机Hibernate设置<code>LocalSessionFactoryBuilder</code> ，与<code>@Bean</code>样式配置（否<code>FactoryBean</code>参与）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>LocalSessionFactoryBean</code>和<code>LocalSessionFactoryBuilder</code>支持后台引导，就像JPA一样<code>LocalContainerEntityManagerFactoryBean</code>做。有关简介，请参见<a href="#orm-jpa-setup-background">后台引导</a> 。</p>
</div>
<div class="paragraph">
<p>上<code>LocalSessionFactoryBean</code> ，这可以通过<code>bootstrapExecutor</code>属性。关于程序化<code>LocalSessionFactoryBuilder</code> ，超载<code>buildSessionFactory</code>方法采用引导执行程序参数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="oxm"><a class="anchor" href="#oxm"></a> 5，使用对象XML映射器编组XML</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="oxm-introduction"><a class="anchor" href="#oxm-introduction"></a> 5.1。介绍</h3>
<div class="paragraph">
<p>本章描述了Spring的Object-XML Mapping支持。对象XML映射（简称OX映射）是将XML文档与对象进行相互转换的动作。此转换过程也称为XML编组或XML序列化。本章可以互换使用这些术语。</p>
</div>
<div class="paragraph">
<p>在OX映射的领域内，编组负责将对象（图形）序列化为XML。以类似的方式，解组器将XML反序列化为对象图。该XML可以采用DOM文档，输入或输出流或SAX处理程序的形式。</p>
</div>
<div class="paragraph">
<p>使用Spring满足O / X映射需求的一些好处是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oxm-ease-of-configuration">易于配置</a></p>
</li>
<li>
<p><a href="#oxm-consistent-interfaces">一致的接口</a></p>
</li>
<li>
<p><a href="#oxm-consistent-exception-hierarchy">一致的异常层次结构</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oxm-ease-of-configuration"><a class="anchor" href="#oxm-ease-of-configuration"></a> 5.1.1。易于配置</h4>
<div class="paragraph">
<p>Spring的bean工厂使配置封送程序变得容易，而无需构造JAXB上下文，JiBX绑定工厂等。您可以像在应用程序上下文中配置任何其他bean一样配置编组器。此外，许多编组人员都可以使用基于XML名称空间的配置，从而使配置更加简单。</p>
</div>
</div>
<div class="sect3">
<h4 id="oxm-consistent-interfaces"><a class="anchor" href="#oxm-consistent-interfaces"></a> 5.1.2。一致的接口</h4>
<div class="paragraph">
<p>Spring的OX映射通过两个全局接口运行： <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/oxm/Marshaller.html"><code>Marshaller</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/oxm/Unmarshaller.html"><code>Unmarshaller</code></a> 。这些抽象使您可以相对轻松地切换OX映射框架，而对进行编组的类几乎不需要更改。这种方法的另一个好处是，可以以非介入方式使用混合匹配方法（例如，一些使用JAXB执行的编组和某些通过XStream进行的编组）进行XML编组，从而使您可以利用每种方法的优势技术。</p>
</div>
</div>
<div class="sect3">
<h4 id="oxm-consistent-exception-hierarchy"><a class="anchor" href="#oxm-consistent-exception-hierarchy"></a> 5.1.3。一致的异常层次结构</h4>
<div class="paragraph">
<p>Spring提供了从基础OX映射工具的异常到其自己的异常层次结构的转换， <code>XmlMappingException</code>作为根本的例外。这些运行时异常包装原始异常，因此不会丢失任何信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-marshaller-unmarshaller"><a class="anchor" href="#oxm-marshaller-unmarshaller"></a> 5.2。 <code>Marshaller</code>和<code>Unmarshaller</code></h3>
<div class="paragraph">
<p>如<a href="#oxm-introduction">引言</a>中所述，编组器将对象序列化为XML，解组器将XML流反序列化为对象。本节描述了用于此目的的两个Spring接口。</p>
</div>
<div class="sect3">
<h4 id="oxm-marshaller"><a class="anchor" href="#oxm-marshaller"></a> 5.2.1。理解<code>Marshaller</code></h4>
<div class="paragraph">
<p>Spring摘录了后面的所有编组操作<code>org.springframework.oxm.Marshaller</code>界面，其主要方法如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Marshaller {

    /**
     * Marshal the object graph with the given root into the provided Result.
     */
    void marshal(Object graph, Result result) throws XmlMappingException, IOException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Marshaller {

    /**
    * Marshal the object graph with the given root into the provided Result.
    */
    @Throws(XmlMappingException::class, IOException::class)
    fun marshal(
            graph: Any,
            result: Result
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Marshaller</code>接口具有一个主要方法，该方法将给定对象编组到给定<code>javax.xml.transform.Result</code> 。结果是一个标记接口，该接口基本上表示XML输出抽象。如下表所示，具体的实现包装了各种XML表示形式：</p>
</div>
<table id="oxm-marshller-tbl" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">结果执行</th>
<th class="tableblock halign-left valign-top">包装XML表示形式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOMResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.w3c.dom.Node</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SAXResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.xml.sax.ContentHandler</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.File</code> ， <code>java.io.OutputStream</code> ， 要么<code>java.io.Writer</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">虽然<code>marshal()</code>方法接受一个普通对象作为其第一个参数，大多数<code>Marshaller</code>实现不能处理任意对象。相反，必须将对象类映射到映射文件中，用注释标记，在编组器中注册或具有公共基类。请参阅本章后面的部分，以确定您的OX技术如何对此进行管理。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="oxm-unmarshaller"><a class="anchor" href="#oxm-unmarshaller"></a> 5.2.2。理解<code>Unmarshaller</code></h4>
<div class="paragraph">
<p>类似于<code>Marshaller</code> ，我们有<code>org.springframework.oxm.Unmarshaller</code>界面，如下清单所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Unmarshaller {

    /**
     * Unmarshal the given provided Source into an object graph.
     */
    Object unmarshal(Source source) throws XmlMappingException, IOException;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">interface Unmarshaller {

    /**
    * Unmarshal the given provided Source into an object graph.
    */
    @Throws(XmlMappingException::class, IOException::class)
    fun unmarshal(source: Source): Any
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该接口还有一个方法，该方法从给定的<code>javax.xml.transform.Source</code> （XML输入抽象）并返回读取的对象。与<code>Result</code> ， <code>Source</code>是具有三个具体实现的标记接口。每个表都包装了不同的XML表示形式，如下表所示：</p>
</div>
<table id="oxm-unmarshller-tbl" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">源实现</th>
<th class="tableblock halign-left valign-top">包装XML表示形式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DOMSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.w3c.dom.Node</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SAXSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.xml.sax.InputSource</code>和<code>org.xml.sax.XMLReader</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamSource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.File</code> ， <code>java.io.InputStream</code> ， 要么<code>java.io.Reader</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>即使有两个单独的编组接口（ <code>Marshaller</code>和<code>Unmarshaller</code> ），Spring-WS中的所有实现都在一个类中实现。这意味着您可以连接一个编组类，并在您的编组中将其称为编组和解组<code>applicationContext.xml</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="oxm-xmlmappingexception"><a class="anchor" href="#oxm-xmlmappingexception"></a> 5.2.3。理解<code>XmlMappingException</code></h4>
<div class="paragraph">
<p>Spring使用以下命令将异常从基础OX映射工具转换为它自己的异常层次结构<code>XmlMappingException</code>作为根本的例外。这些运行时异常包装了原始异常，因此不会丢失任何信息。</p>
</div>
<div class="paragraph">
<p>此外， <code>MarshallingFailureException</code>和<code>UnmarshallingFailureException</code>即使底层的OX映射工具没有这样做，也提供了编组和解组操作之间的区别。</p>
</div>
<div class="paragraph">
<p>OX Mapping异常层次结构如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oxm-exceptions.png" alt="OXM例外">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-usage"><a class="anchor" href="#oxm-usage"></a> 5.3。使用<code>Marshaller</code>和<code>Unmarshaller</code></h3>
<div class="paragraph">
<p>您可以在多种情况下使用Spring的OXM。在下面的示例中，我们使用它来将Spring托管应用程序的设置作为XML文件进行编组。在下面的示例中，我们使用一个简单的JavaBean来表示设置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Settings {

    private boolean fooEnabled;

    public boolean isFooEnabled() {
        return fooEnabled;
    }

    public void setFooEnabled(boolean fooEnabled) {
        this.fooEnabled = fooEnabled;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Settings {
    var isFooEnabled: Boolean = false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用程序类使用此bean存储其设置。除了主要方法外，该类还有两个方法： <code>saveSettings()</code>将设置bean保存到名为<code>settings.xml</code>和<code>loadSettings()</code>再次加载这些设置。下列<code>main()</code>方法构造一个Spring应用程序上下文并调用以下两个方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.Unmarshaller;

public class Application {

    private static final String FILE_NAME = "settings.xml";
    private Settings settings = new Settings();
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;

    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }

    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }

    public void saveSettings() throws IOException {
        try (FileOutputStream os = new FileOutputStream(FILE_NAME)) {
            this.marshaller.marshal(settings, new StreamResult(os));
        }
    }

    public void loadSettings() throws IOException {
        try (FileInputStream is = new FileInputStream(FILE_NAME)) {
            this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));
        }
    }

    public static void main(String[] args) throws IOException {
        ApplicationContext appContext =
                new ClassPathXmlApplicationContext("applicationContext.xml");
        Application application = (Application) appContext.getBean("application");
        application.saveSettings();
        application.loadSettings();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Application {

    lateinit var marshaller: Marshaller

    lateinit var unmarshaller: Unmarshaller

    fun saveSettings() {
        FileOutputStream(FILE_NAME).use { outputStream -&gt; marshaller.marshal(settings, StreamResult(outputStream)) }
    }

    fun loadSettings() {
        FileInputStream(FILE_NAME).use { inputStream -&gt; settings = unmarshaller.unmarshal(StreamSource(inputStream)) as Settings }
    }
}

private const val FILE_NAME = "settings.xml"

fun main(args: Array&lt;String&gt;) {
    val appContext = ClassPathXmlApplicationContext("applicationContext.xml")
    val application = appContext.getBean("application") as Application
    application.saveSettings()
    application.loadSettings()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Application</code>都需要<code>marshaller</code>和<code>unmarshaller</code>要设置的属性。我们可以使用以下方法做到这一点<code>applicationContext.xml</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="application" class="Application"&gt;
        &lt;property name="marshaller" ref="xstreamMarshaller" /&gt;
        &lt;property name="unmarshaller" ref="xstreamMarshaller" /&gt;
    &lt;/bean&gt;
    &lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该应用程序上下文使用XStream，但我们可以使用本章后面介绍的任何其他编组实例。注意，默认情况下，XStream不需要任何进一步的配置，因此bean的定义非常简单。另请注意<code>XStreamMarshaller</code>同时实现<code>Marshaller</code>和<code>Unmarshaller</code> ，因此我们可以参考<code>xstreamMarshaller</code>在两个豆<code>marshaller</code>和<code>unmarshaller</code>应用程序的属性。</p>
</div>
<div class="paragraph">
<p>该示例应用程序产生以下内容<code>settings.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;settings foo-enabled="false"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-schema-based-config"><a class="anchor" href="#oxm-schema-based-config"></a> 5.4。XML配置命名空间</h3>
<div class="paragraph">
<p>您可以使用OXM名称空间中的标签来更简洁地配置编组器。要使这些标签可用，您必须首先在XML配置文件的序言中引用适当的架构。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:oxm="http://www.springframework.org/schema/oxm" <i class="conum" data-value="1"></i><b>(1)</b>
xsi:schemaLocation="http://www.springframework.org/schema/beans
  https://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/oxm https://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>参考<code>oxm</code>模式。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>指定<code>oxm</code>模式位置。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该架构使以下元素可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oxm-jaxb2-xsd"><code>jaxb2-marshaller</code></a></p>
</li>
<li>
<p><a href="#oxm-jibx-xsd"><code>jibx-marshaller</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个标签在其各自的编组部分中进行了说明。但是，作为示例，JAXB2编组器的配置可能类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-jaxb"><a class="anchor" href="#oxm-jaxb"></a> 5.5。杰克斯</h3>
<div class="paragraph">
<p>JAXB绑定编译器将W3C XML Schema转换为一个或多个Java类， <code>jaxb.properties</code>文件，可能还有一些资源文件。JAXB还提供了一种从带注释的Java类生成模式的方法。</p>
</div>
<div class="paragraph">
<p>按照以下说明，Spring支持将JAXB 2.0 API作为XML编组策略。 <code>Marshaller</code>和<code>Unmarshaller</code>介面中所述<a href="#oxm-marshaller-unmarshaller"><code>Marshaller</code>和<code>Unmarshaller</code></a> 。相应的集成类位于<code>org.springframework.oxm.jaxb</code>包。</p>
</div>
<div class="sect3">
<h4 id="oxm-jaxb2"><a class="anchor" href="#oxm-jaxb2"></a> 5.5.1。使用<code>Jaxb2Marshaller</code></h4>
<div class="paragraph">
<p>的<code>Jaxb2Marshaller</code>类实现了Spring的<code>Marshaller</code>和<code>Unmarshaller</code>接口。它需要上下文路径才能运行。您可以通过设置<code>contextPath</code>属性。上下文路径是冒号分隔的Java程序包名称的列表，其中包含模式派生的类。它还提供了<code>classesToBeBound</code>属性，该属性使您可以设置编组支持的类的数组。通过向Bean指定一个或多个模式资源来执行模式验证，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="jaxb2Marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt;
        &lt;property name="classesToBeBound"&gt;
            &lt;list&gt;
                &lt;value&gt;org.springframework.oxm.jaxb.Flight&lt;/value&gt;
                &lt;value&gt;org.springframework.oxm.jaxb.Flights&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="schema" value="classpath:org/springframework/oxm/schema.xsd"/&gt;
    &lt;/bean&gt;

    ...

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="oxm-jaxb2-xsd"><a class="anchor" href="#oxm-jaxb2-xsd"></a> XML配置命名空间</h5>
<div class="paragraph">
<p>的<code>jaxb2-marshaller</code>元素配置一个<code>org.springframework.oxm.jaxb.Jaxb2Marshaller</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用以下命令提供要绑定到编组的类的列表<code>class-to-be-bound</code>子元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;oxm:jaxb2-marshaller id="marshaller"&gt;
    &lt;oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Airport"/&gt;
    &lt;oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Flight"/&gt;
    ...
&lt;/oxm:jaxb2-marshaller&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了可用的属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">需要</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编组的ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextPath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAXB上下文路径</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-jibx"><a class="anchor" href="#oxm-jibx"></a> 5.6。吉宝</h3>
<div class="paragraph">
<p>JiBX框架提供了与Hibernate为ORM提供的解决方案类似的解决方案：绑定定义定义了Java对象如何与XML相互转换的规则。在准备好绑定并编译了类之后，JiBX绑定编译器将增强类文件并添加代码以处理将类实例从XML转换为XML的过程。</p>
</div>
<div class="paragraph">
<p>有关JiBX的更多信息，请参见<a href="http://jibx.sourceforge.net/">JiBX网站</a> 。Spring集成类位于<code>org.springframework.oxm.jibx</code>包。</p>
</div>
<div class="sect3">
<h4 id="oxm-jibx-marshaller"><a class="anchor" href="#oxm-jibx-marshaller"></a> 5.6.1。使用<code>JibxMarshaller</code></h4>
<div class="paragraph">
<p>的<code>JibxMarshaller</code>类同时实现<code>Marshaller</code>和<code>Unmarshaller</code>接口。要进行操作，需要输入要编组的类的名称，您可以使用<code>targetClass</code>属性。（可选）您可以通过设置<code>bindingName</code>属性。在以下示例中，我们将<code>Flights</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="jibxFlightsMarshaller" class="org.springframework.oxm.jibx.JibxMarshaller"&gt;
        &lt;property name="targetClass"&gt;org.springframework.oxm.jibx.Flights&lt;/property&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种<code>JibxMarshaller</code>为单个类配置。如果要封送多个类，则必须配置多个<code>JibxMarshaller</code>具有不同实例<code>targetClass</code>属性值。</p>
</div>
<div class="sect4">
<h5 id="oxm-jibx-xsd"><a class="anchor" href="#oxm-jibx-xsd"></a> XML配置命名空间</h5>
<div class="paragraph">
<p>的<code>jibx-marshaller</code>标签配置一个<code>org.springframework.oxm.jibx.JibxMarshaller</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;oxm:jibx-marshaller id="marshaller" target-class="org.springframework.ws.samples.airline.schema.Flight"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了可用的属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">需要</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编组的ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该编组的目标类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bindingName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该编组器使用的绑定名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oxm-xstream"><a class="anchor" href="#oxm-xstream"></a> 5.7。XStream的</h3>
<div class="paragraph">
<p>XStream是一个简单的库，用于将对象序列化为XML并再次返回。它不需要任何映射并生成干净的XML。</p>
</div>
<div class="paragraph">
<p>有关XStream的更多信息，请参见<a href="https://x-stream.github.io/">XStream网站</a> 。Spring集成类位于<code>org.springframework.oxm.xstream</code>包。</p>
</div>
<div class="sect3">
<h4 id="oxm-xstream-marshaller"><a class="anchor" href="#oxm-xstream-marshaller"></a> 5.7.1。使用<code>XStreamMarshaller</code></h4>
<div class="paragraph">
<p>的<code>XStreamMarshaller</code>不需要任何配置，可以直接在应用程序上下文中进行配置。为了进一步自定义XML，可以设置一个别名映射，该映射由映射到类的字符串别名组成，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
        &lt;property name="aliases"&gt;
            &lt;props&gt;
                &lt;prop key="Flight"&gt;org.springframework.oxm.xstream.Flight&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，XStream允许将任意类取消编组，这可能导致不安全的Java序列化效果。因此，我们不建议您使用<code>XStreamMarshaller</code>从外部资源（即Web）解组XML，因为这可能导致安全漏洞。</p>
</div>
<div class="paragraph">
<p>如果您选择使用<code>XStreamMarshaller</code>要从外部源解组XML，请设置<code>supportedClasses</code>财产<code>XStreamMarshaller</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"&gt;
    &lt;property name="supportedClasses" value="org.springframework.oxm.xstream.Flight"/&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做可以确保只有注册的班级才有资格进行编组。</p>
</div>
<div class="paragraph">
<p>此外，您可以注册<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher%E2%80%A6%E2%80%8B)">自定义转换器</a> ，以确保只能解组受支持的类。您可能要添加一个<code>CatchAllConverter</code>作为列表中的最后一个转换器，除了明确支持应支持的域类的转换器之外。结果，不会调用具有较低优先级和可能的安全漏洞的默认XStream转换器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，XStream是XML序列化库，而不是数据绑定库。因此，它具有有限的名称空间支持。结果，它非常不适合在Web服务中使用。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a> 6。附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a> 6.1。XML模式</h3>
<div class="paragraph">
<p>附录的此部分列出了用于数据访问的XML模式，包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#xsd-schemas-tx">的<code>tx</code>架构图</a></p>
</li>
<li>
<p><a href="#xsd-schemas-jdbc">的<code>jdbc</code>架构图</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="xsd-schemas-tx"><a class="anchor" href="#xsd-schemas-tx"></a> 6.1.1。的<code>tx</code>架构图</h4>
<div class="paragraph">
<p>的<code>tx</code>标签在Spring对事务的全面支持中涉及配置所有这些bean。在标题为“ <a href="#transaction">事务管理”</a>的章节中介绍了这些标签。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们强烈建议您查看<code>'spring-tx.xsd'</code> Spring发行版附带的文件。该文件包含Spring事务配置的XML模式，并涵盖了XML中的所有各个元素。 <code>tx</code>名称空间，包括属性默认值和类似信息。该文件已内联记录，因此，出于遵守DRY（请勿重复自己）的原则，此处不再重复信息。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了完整起见，请在<code>tx</code>模式，您需要在Spring XML配置文件的顶部具有以下序言。以下代码段中的文本引用了正确的架构，因此<code>tx</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx" <i class="conum" data-value="1"></i><b>(1)</b>
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd <i class="conum" data-value="2"></i><b>(2)</b>
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明使用<code>tx</code>命名空间。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>指定位置（以及其他架构位置）。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通常，当您使用<code>tx</code>命名空间，您还使用了<code>aop</code>名称空间（由于使用AOP实现了Spring中的声明式事务支持）。前面的XML代码段包含引用<code>aop</code>模式，以便<code>aop</code>命名空间可供您使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jdbc"><a class="anchor" href="#xsd-schemas-jdbc"></a> 6.1.2。的<code>jdbc</code>架构图</h4>
<div class="paragraph">
<p>的<code>jdbc</code>元素使您可以快速配置嵌入式数据库或初始化现有数据源。这些元素分别记录在“ <a href="#jdbc-embedded-database-support">嵌入式数据库支持”</a>和“ <a href="#jdbc-initializing-datasource">初始化数据源”中</a> 。</p>
</div>
<div class="paragraph">
<p>要使用<code>jdbc</code>模式，您需要在Spring XML配置文件的顶部具有以下序言。以下代码段中的文本引用了正确的架构，因此<code>jdbc</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc" <i class="conum" data-value="1"></i><b>(1)</b>
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd"&gt; <i class="conum" data-value="2"></i><b>(2)</b>

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>声明使用<code>jdbc</code>命名空间。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>指定位置（以及其他架构位置）。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:51 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>