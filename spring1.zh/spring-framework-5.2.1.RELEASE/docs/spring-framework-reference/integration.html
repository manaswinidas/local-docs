<html lang="zh-Hans" ><head></head><body id="spring-integration" class="book toc2 toc-left" >
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>积分</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



<div id="header">
<h1>积分</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#remoting">1。远程处理和Web服务</a>
<ul class="sectlevel2">
<li><a href="#remoting-rmi">1.1。RMI</a>
<ul class="sectlevel3">
<li><a href="#remoting-rmi-server">1.1.1。通过使用导出服务<code>RmiServiceExporter</code></a></li>
<li><a href="#remoting-rmi-client">1.1.2。在客户端链接服务</a></li>
</ul>
</li>
<li><a href="#remoting-caucho-protocols">1.2。使用Hessian通过HTTP远程调用服务</a>
<ul class="sectlevel3">
<li><a href="#remoting-caucho-protocols-hessian">1.2.1。黑森州</a></li>
<li><a href="#remoting-caucho-protocols-hessian-server">1.2.2。使用公开您的豆子<code>HessianServiceExporter</code></a></li>
<li><a href="#remoting-caucho-protocols-hessian-client">1.2.3。在客户端上链接服务</a></li>
<li><a href="#remoting-caucho-protocols-security">1.2.4。将HTTP基本身份验证应用于通过Hessian公开的服务</a></li>
</ul>
</li>
<li><a href="#remoting-httpinvoker">1.3。Spring HTTP调用程序</a>
<ul class="sectlevel3">
<li><a href="#remoting-httpinvoker-server">1.3.1。公开服务对象</a></li>
<li><a href="#remoting-httpinvoker-client">1.3.2。在客户端链接服务</a></li>
</ul>
</li>
<li><a href="#remoting-web-services">1.4。Java Web服务</a>
<ul class="sectlevel3">
<li><a href="#remoting-web-services-jaxws-export-servlet">1.4.1。使用JAX-WS公开基于Servlet的Web服务</a></li>
<li><a href="#remoting-web-services-jaxws-export-standalone">1.4.2。使用JAX-WS导出独立的Web服务</a></li>
<li><a href="#remoting-web-services-jaxws-export-ri">1.4.3。使用JAX-WS RI的Spring支持导出Web服务</a></li>
<li><a href="#remoting-web-services-jaxws-access">1.4.4。使用JAX-WS访问Web服务</a></li>
</ul>
</li>
<li><a href="#remoting-jms">1.5。JMS</a>
<ul class="sectlevel3">
<li><a href="#remoting-jms-server">1.5.1。服务器端配置</a></li>
<li><a href="#remoting-jms-client">1.5.2。客户端配置</a></li>
</ul>
</li>
<li><a href="#remoting-amqp">1.6。AMQP</a></li>
<li><a href="#remoting-considerations">1.7。选择技术时的注意事项</a></li>
<li><a href="#rest-client-access">1.8。REST端点</a>
<ul class="sectlevel3">
<li><a href="#rest-resttemplate">1.8.1。<code>RestTemplate</code></a>
<ul class="sectlevel4">
<li><a href="#rest-resttemplate-create">初始化</a></li>
<li><a href="#rest-resttemplate-uri">URIs</a></li>
<li><a href="#rest-template-headers">标头</a></li>
<li><a href="#rest-template-body">身体</a></li>
<li><a href="#rest-message-conversion">讯息转换</a></li>
<li><a href="#rest-template-jsonview">杰克逊JSON视图</a></li>
<li><a href="#rest-template-multipart">多部分</a></li>
</ul>
</li>
<li><a href="#rest-async-resttemplate">1.8.2。使用<code>AsyncRestTemplate</code> （已弃用）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ejb">2。企业JavaBeans（EJB）集成</a>
<ul class="sectlevel2">
<li><a href="#ejb-access">2.1。访问EJB</a>
<ul class="sectlevel3">
<li><a href="#ejb-access-concepts">2.1.1。概念</a></li>
<li><a href="#ejb-access-local">2.1.2。访问本地SLSB</a></li>
<li><a href="#ejb-access-remote">2.1.3。访问远程SLSB</a></li>
<li><a href="#ejb-access-ejb2-ejb3">2.1.4。访问EJB 2.x SLSB与EJB 3 SLSB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jms">3。JMS（Java消息服务）</a>
<ul class="sectlevel2">
<li><a href="#jms-using">3.1。使用Spring JMS</a>
<ul class="sectlevel3">
<li><a href="#jms-jmstemplate">3.1.1。使用<code>JmsTemplate</code></a></li>
<li><a href="#jms-connections">3.1.2。连接数</a>
<ul class="sectlevel4">
<li><a href="#jms-caching-resources">缓存消息资源</a></li>
<li><a href="#jms-connection-factory">使用<code>SingleConnectionFactory</code></a></li>
<li><a href="#jdbc-connection-factory-caching">使用<code>CachingConnectionFactory</code></a></li>
</ul>
</li>
<li><a href="#jms-destinations">3.1.3。目的地管理</a></li>
<li><a href="#jms-mdp">3.1.4。消息侦听器容器</a>
<ul class="sectlevel4">
<li><a href="#jms-mdp-simple">使用<code>SimpleMessageListenerContainer</code></a></li>
<li><a href="#jms-mdp-default">使用<code>DefaultMessageListenerContainer</code></a></li>
</ul>
</li>
<li><a href="#jms-tx">3.1.5。交易管理</a></li>
</ul>
</li>
<li><a href="#jms-sending">3.2。发送信息</a>
<ul class="sectlevel3">
<li><a href="#jms-msg-conversion">3.2.1。使用消息转换器</a></li>
<li><a href="#jms-callbacks">3.2.2。使用<code>SessionCallback</code>和<code>ProducerCallback</code></a></li>
</ul>
</li>
<li><a href="#jms-receiving">3.3。接收讯息</a>
<ul class="sectlevel3">
<li><a href="#jms-receiving-sync">3.3.1。同步接收</a></li>
<li><a href="#jms-receiving-async">3.3.2。异步接收：消息驱动的POJO</a></li>
<li><a href="#jms-receiving-async-session-aware-message-listener">3.3.3。使用<code>SessionAwareMessageListener</code>接口</a></li>
<li><a href="#jms-receiving-async-message-listener-adapter">3.3.4。使用<code>MessageListenerAdapter</code></a></li>
<li><a href="#jms-tx-participation">3.3.5。处理事务中的消息</a></li>
</ul>
</li>
<li><a href="#jms-jca-message-endpoint-manager">3.4。支持JCA消息端点</a></li>
<li><a href="#jms-annotated">3.5。注释驱动的侦听器端点</a>
<ul class="sectlevel3">
<li><a href="#jms-annotated-support">3.5.1。启用侦听器端点注释</a></li>
<li><a href="#jms-annotated-programmatic-registration">3.5.2。程序化端点注册</a></li>
<li><a href="#jms-annotated-method-signature">3.5.3。带注释的端点方法签名</a></li>
<li><a href="#jms-annotated-response">3.5.4。反应管理</a></li>
</ul>
</li>
<li><a href="#jms-namespace">3.6。JMS命名空间支持</a></li>
</ul>
</li>
<li><a href="#jmx">4。JMX</a>
<ul class="sectlevel2">
<li><a href="#jmx-exporting">4.1。将您的Bean导出到JMX</a>
<ul class="sectlevel3">
<li><a href="#jmx-exporting-mbeanserver">4.1.1。创建一个MBeanServer</a></li>
<li><a href="#jmx-mbean-server">4.1.2。重用现有的<code>MBeanServer</code></a></li>
<li><a href="#jmx-exporting-lazy">4.1.3。延迟初始化的MBean</a></li>
<li><a href="#jmx-exporting-auto">4.1.4。自动注册MBean</a></li>
<li><a href="#jmx-exporting-registration-behavior">4.1.5。控制注册行为</a></li>
</ul>
</li>
<li><a href="#jmx-interface">4.2。控制Bean的管理接口</a>
<ul class="sectlevel3">
<li><a href="#jmx-interface-assembler">4.2.1。使用<code>MBeanInfoAssembler</code>接口</a></li>
<li><a href="#jmx-interface-metadata">4.2.2。使用源级元数据：Java注释</a></li>
<li><a href="#jmx-interface-metadata-types">4.2.3。源级元数据类型</a></li>
<li><a href="#jmx-interface-autodetect">4.2.4。使用<code>AutodetectCapableMBeanInfoAssembler</code>接口</a></li>
<li><a href="#jmx-interface-java">4.2.5。使用Java接口定义管理接口</a></li>
<li><a href="#jmx-interface-methodnames">4.2.6。使用<code>MethodNameBasedMBeanInfoAssembler</code></a></li>
</ul>
</li>
<li><a href="#jmx-naming">4.3。控制性<code>ObjectName</code> Bean的实例</a>
<ul class="sectlevel3">
<li><a href="#jmx-naming-properties">4.3.1。阅读<code>ObjectName</code>来自属性的实例</a></li>
<li><a href="#jmx-naming-metadata">4.3.2。使用<code>MetadataNamingStrategy</code></a></li>
<li><a href="#jmx-context-mbeanexport">4.3.3。配置基于注释的MBean导出</a></li>
</ul>
</li>
<li><a href="#jmx-jsr160">4.4。使用JSR-160连接器</a>
<ul class="sectlevel3">
<li><a href="#jmx-jsr160-server">4.4.1。服务器端连接器</a></li>
<li><a href="#jmx-jsr160-client">4.4.2。客户端连接器</a></li>
<li><a href="#jmx-jsr160-protocols">4.4.3。通过Hessian或SOAP的JMX</a></li>
</ul>
</li>
<li><a href="#jmx-proxy">4.5。通过代理访问MBean</a></li>
<li><a href="#jmx-notifications">4.6。通知事项</a>
<ul class="sectlevel3">
<li><a href="#jmx-notifications-listeners">4.6.1。注册侦听器以接收通知</a></li>
<li><a href="#jmx-notifications-publishing">4.6.2。发布通知</a></li>
</ul>
</li>
<li><a href="#jmx-resources">4.7。更多资源</a></li>
</ul>
</li>
<li><a href="#cci">5，JCA CCI</a>
<ul class="sectlevel2">
<li><a href="#cci-config">5.1。配置CCI</a>
<ul class="sectlevel3">
<li><a href="#cci-config-connector">5.1.1。连接器配置</a></li>
<li><a href="#cci-config-connectionfactory">5.1.2。 <code>ConnectionFactory</code> 春季配置</a></li>
<li><a href="#cci-config-cci-connections">5.1.3。配置CCI连接</a></li>
<li><a href="#cci-config-single-connection">5.1.4。使用单个CCI连接</a></li>
</ul>
</li>
<li><a href="#cci-using">5.2。使用Spring的CCI访问支持</a>
<ul class="sectlevel3">
<li><a href="#cci-record-creator">5.2.1。记录转换</a></li>
<li><a href="#cci-using-template">5.2.2。使用<code>CciTemplate</code></a></li>
<li><a href="#cci-using-dao">5.2.3。使用DAO支持</a></li>
<li><a href="#automatic-output-generation">5.2.4。自动输出记录生成</a></li>
<li><a href="#template-summary">5.2.5。 <code>CciTemplate</code><code>Interaction</code> 摘要</a></li>
<li><a href="#cci-straight">5.2.6。直接使用CCI连接和交互</a></li>
<li><a href="#cci-template-example">5.2.7。例子<code>CciTemplate</code>用法</a></li>
</ul>
</li>
<li><a href="#cci-object">5.3。将CCI访问建模为操作对象</a>
<ul class="sectlevel3">
<li><a href="#cci-object-mapping-record">5.3.1。使用<code>MappingRecordOperation</code></a></li>
<li><a href="#cci-object-mapping-comm-area">5.3.2。使用<code>MappingCommAreaOperation</code></a></li>
<li><a href="#cci-automatic-record-gen">5.3.3。自动输出记录生成</a></li>
<li><a href="#cci-object-summary">5.3.4。摘要</a></li>
<li><a href="#cci-objects-mappring-record-example">5.3.5。例子<code>MappingRecordOperation</code>用法</a></li>
<li><a href="#cci-objects-mapping-comm-area-example">5.3.6。例子<code>MappingCommAreaOperation</code>用法</a></li>
</ul>
</li>
<li><a href="#cci-tx">5.4。交易次数</a></li>
</ul>
</li>
<li><a href="#mail">6。电子邮件</a>
<ul class="sectlevel2">
<li><a href="#mail-usage">6.1。用法</a>
<ul class="sectlevel3">
<li><a href="#mail-usage-simple">6.1.1。基本的<code>MailSender</code>和<code>SimpleMailMessage</code>用法</a></li>
<li><a href="#mail-usage-mime">6.1.2。使用<code>JavaMailSender</code>和<code>MimeMessagePreparator</code></a></li>
</ul>
</li>
<li><a href="#mail-javamail-mime">6.2。使用JavaMail <code>MimeMessageHelper</code></a>
<ul class="sectlevel3">
<li><a href="#mail-javamail-mime-attachments">6.2.1。发送附件和内联资源</a>
<ul class="sectlevel4">
<li><a href="#mail-javamail-mime-attachments-attachment">附件</a></li>
<li><a href="#mail-javamail-mime-attachments-inline">内联资源</a></li>
</ul>
</li>
<li><a href="#mail-templates">6.2.2。使用模板库创建电子邮件内容</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#scheduling">7。任务执行和计划</a>
<ul class="sectlevel2">
<li><a href="#scheduling-task-executor">7.1。春天<code>TaskExecutor</code>抽象化</a>
<ul class="sectlevel3">
<li><a href="#scheduling-task-executor-types">7.1.1。 <code>TaskExecutor</code> 种类</a></li>
<li><a href="#scheduling-task-executor-usage">7.1.2。用一个<code>TaskExecutor</code></a></li>
</ul>
</li>
<li><a href="#scheduling-task-scheduler">7.2。春天<code>TaskScheduler</code>抽象化</a>
<ul class="sectlevel3">
<li><a href="#scheduling-trigger-interface">7.2.1。 <code>Trigger</code> 接口</a></li>
<li><a href="#scheduling-trigger-implementations">7.2.2。 <code>Trigger</code> 实作</a></li>
<li><a href="#scheduling-task-scheduler-implementations">7.2.3。 <code>TaskScheduler</code>实作</a></li>
</ul>
</li>
<li><a href="#scheduling-annotation-support">7.3。计划和异步执行的注释支持</a>
<ul class="sectlevel3">
<li><a href="#scheduling-enable-annotation-support">7.3.1。启用计划注释</a></li>
<li><a href="#scheduling-annotation-support-scheduled">7.3.2。的<code>@Scheduled</code>注解</a></li>
<li><a href="#scheduling-annotation-support-async">7.3.3。的<code>@Async</code>注解</a></li>
<li><a href="#scheduling-annotation-support-qualification">7.3.4。执行者资格<code>@Async</code></a></li>
<li><a href="#scheduling-annotation-support-exception">7.3.5。异常管理<code>@Async</code></a></li>
</ul>
</li>
<li><a href="#scheduling-task-namespace">7.4。的<code>task</code>命名空间</a>
<ul class="sectlevel3">
<li><a href="#scheduling-task-namespace-scheduler">7.4.1。“调度程序”元素</a></li>
<li><a href="#scheduling-task-namespace-executor">7.4.2。的<code>executor</code>元件</a></li>
<li><a href="#scheduling-task-namespace-scheduled-tasks">7.4.3。“计划任务”元素</a></li>
</ul>
</li>
<li><a href="#scheduling-quartz">7.5。使用Quartz Scheduler</a>
<ul class="sectlevel3">
<li><a href="#scheduling-quartz-jobdetail">7.5.1。使用<code>JobDetailFactoryBean</code></a></li>
<li><a href="#scheduling-quartz-method-invoking-job">7.5.2。使用<code>MethodInvokingJobDetailFactoryBean</code></a></li>
<li><a href="#scheduling-quartz-cron">7.5.3。使用触发器和<code>SchedulerFactoryBean</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cache">8。缓存抽象</a>
<ul class="sectlevel2">
<li><a href="#cache-strategies">8.1。了解缓存抽象</a></li>
<li><a href="#cache-annotations">8.2。基于声明式注释的缓存</a>
<ul class="sectlevel3">
<li><a href="#cache-annotations-cacheable">8.2.1。的<code>@Cacheable</code>注解</a>
<ul class="sectlevel4">
<li><a href="#cache-annotations-cacheable-default-key">默认密钥生成</a></li>
<li><a href="#cache-annotations-cacheable-key">自定义密钥生成声明</a></li>
<li><a href="#cache-annotations-cacheable-default-cache-resolver">默认缓存分辨率</a></li>
<li><a href="#cache-annotations-cacheable-cache-resolver">自定义缓存解析</a></li>
<li><a href="#cache-annotations-cacheable-synchronized">同步缓存</a></li>
<li><a href="#cache-annotations-cacheable-condition">条件缓存</a></li>
<li><a href="#cache-spel-context">可用的缓存SpEL评估上下文</a></li>
</ul>
</li>
<li><a href="#cache-annotations-put">8.2.2。的<code>@CachePut</code>注解</a></li>
<li><a href="#cache-annotations-evict">8.2.3。的<code>@CacheEvict</code>注解</a></li>
<li><a href="#cache-annotations-caching">8.2.4。的<code>@Caching</code>注解</a></li>
<li><a href="#cache-annotations-config">8.2.5。的<code>@CacheConfig</code>注解</a></li>
<li><a href="#cache-annotation-enable">8.2.6。启用缓存注释</a></li>
<li><a href="#cache-annotation-stereotype">8.2.7。使用自定义注释</a></li>
</ul>
</li>
<li><a href="#cache-jsr-107">8.3。JCache（JSR-107）批注</a>
<ul class="sectlevel3">
<li><a href="#cache-jsr-107-summary">8.3.1。功能摘要</a></li>
<li><a href="#enabling-jsr-107-support">8.3.2。启用JSR-107支持</a></li>
</ul>
</li>
<li><a href="#cache-declarative-xml">8.4。基于声明式XML的缓存</a></li>
<li><a href="#cache-store-configuration">8.5。配置缓存存储</a>
<ul class="sectlevel3">
<li><a href="#cache-store-configuration-jdk">8.5.1。JDK <code>ConcurrentMap</code>基于缓存</a></li>
<li><a href="#cache-store-configuration-ehcache">8.5.2。基于Ehcache的缓存</a></li>
<li><a href="#cache-store-configuration-caffeine">8.5.3。咖啡因缓存</a></li>
<li><a href="#cache-store-configuration-gemfire">8.5.4。基于GemFire的缓存</a></li>
<li><a href="#cache-store-configuration-jsr107">8.5.5。JSR-107缓存</a></li>
<li><a href="#cache-store-configuration-noop">8.5.6。在没有后备存储的情况下处理缓存</a></li>
</ul>
</li>
<li><a href="#cache-plug">8.6。插入不同的后端缓存</a></li>
<li><a href="#cache-specific-config">8.7。如何设置TTL / TTI /驱逐策略/ XXX功能？</a></li>
</ul>
</li>
<li><a href="#appendix">9。附录</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">9.1。XML模式</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-jee">9.1.1。的<code>jee</code>架构图</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-jee-jndi-lookup"><jee:jndi-lookup></jee:jndi-lookup> （简单）</a></li>
<li><a href="#xsd-schemas-jee-jndi-lookup-environment-single"><code><jee:jndi-lookup/></code> （具有单个JNDI环境设置）</a></li>
<li><a href="#xsd-schemas-jee-jndi-lookup-evironment-multiple"><code><jee:jndi-lookup/></code> （具有多个JNDI环境设置）</a></li>
<li><a href="#xsd-schemas-jee-jndi-lookup-complex"><code><jee:jndi-lookup/></code> （复杂）</a></li>
<li><a href="#xsd-schemas-jee-local-slsb"><code><jee:local-slsb/></code> （简单）</a></li>
<li><a href="#xsd-schemas-jee-local-slsb-complex"><code><jee:local-slsb/></code> （复杂）</a></li>
<li><a href="#xsd-schemas-jee-remote-slsb"><jee:remote-slsb></jee:remote-slsb></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-jms">9.1.2。的<code>jms</code>架构图</a></li>
<li><a href="#xsd-schemas-context-mbe">9.1.3。使用<code><context:mbean-export/></code></a></li>
<li><a href="#xsd-schemas-cache">9.1.4。的<code>cache</code>架构图</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>参考文档的这一部分涵盖了Spring Framework与许多Java EE（及相关）技术的集成。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="remoting"><a class="anchor" href="#remoting"></a> 1。远程处理和Web服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring提供了使用各种技术进行远程处理的支持。远程支持简化了通过Java接口和对象作为输入和输出实现的启用远程服务的开发。当前，Spring支持以下远程技术：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#remoting-rmi">远程方法调用（RMI）</a> ：通过使用<code>RmiProxyFactoryBean</code>和<code>RmiServiceExporter</code> ，Spring同时支持传统的RMI（ <code>java.rmi.Remote</code>接口和<code>java.rmi.RemoteException</code> ）和通过RMI调用程序（具有任何Java接口）的透明远程处理。</p>
</li>
<li>
<p><a href="#remoting-httpinvoker">Spring HTTP Invoker</a> ：Spring提供了一种特殊的远程处理策略，该策略允许通过HTTP进行Java序列化，从而支持任何Java接口（就像RMI调用程序一样）。相应的支持类别是<code>HttpInvokerProxyFactoryBean</code>和<code>HttpInvokerServiceExporter</code> 。</p>
</li>
<li>
<p><a href="#remoting-caucho-protocols-hessian">粗麻布</a> ：使用Spring的<code>HessianProxyFactoryBean</code>和<code>HessianServiceExporter</code> ，您可以通过Caucho提供的基于HTTP的轻量级二进制协议透明地公开服务。</p>
</li>
<li>
<p><a href="#remoting-web-services">Java Web服务</a> ：Spring通过JAX-WS提供对Web服务的远程支持。</p>
</li>
<li>
<p><a href="#remoting-jms">JMS</a> ：通过JMS进行远程处理，因为通过<code>JmsInvokerServiceExporter</code>和<code>JmsInvokerProxyFactoryBean</code>中的课程<code>spring-jms</code>模块。</p>
</li>
<li>
<p><a href="#remoting-amqp">AMQP</a> ：单独的Spring AMQP项目支持通过AMQP作为基础协议进行远程处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在讨论Spring的远程功能时，我们使用以下域模型和相应的服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Account implements Serializable{

    private String name;

    public String getName(){
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface AccountService {

    public void insertAccount(Account account);

    public List&lt;Account&gt; getAccounts(String name);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// the implementation doing nothing at the moment
public class AccountServiceImpl implements AccountService {

    public void insertAccount(Account acc) {
        // do something...
    }

    public List&lt;Account&gt; getAccounts(String name) {
        // do something...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>本节首先使用RMI将服务公开给远程客户端，然后再谈谈使用RMI的缺点。然后继续以使用Hessian作为协议的示例。</p>
</div>
<div class="sect2">
<h3 id="remoting-rmi"><a class="anchor" href="#remoting-rmi"></a> 1.1。RMI</h3>
<div class="paragraph">
<p>通过使用Spring对RMI的支持，您可以通过RMI基础结构透明地公开服务。进行了此设置之后，除了不存在对安全上下文传播或远程事务传播的标准支持这一事实之外，您基本上具有与远程EJB相似的配置。当您使用RMI调用程序时，Spring确实为此类附加调用上下文提供了挂钩，因此，例如，您可以插入安全框架或自定义安全凭证。</p>
</div>
<div class="sect3">
<h4 id="remoting-rmi-server"><a class="anchor" href="#remoting-rmi-server"></a> 1.1.1。通过使用导出服务<code>RmiServiceExporter</code></h4>
<div class="paragraph">
<p>使用<code>RmiServiceExporter</code> ，我们可以将AccountService对象的接口公开为RMI对象。该接口可以通过使用来访问<code>RmiProxyFactoryBean</code> ，或者在传统RMI服务的情况下，通过普通RMI。的<code>RmiServiceExporter</code>明确支持通过RMI调用程序公开任何非RMI服务。</p>
</div>
<div class="paragraph">
<p>我们首先必须在Spring容器中设置服务。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们必须使用公开我们的服务<code>RmiServiceExporter</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
    &lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    &lt;!-- defaults to 1099 --&gt;
    &lt;property name="registryPort" value="1199"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们覆盖了RMI注册表的端口。通常，您的应用服务器还维护一个RMI注册表，因此最好不要干涉该注册表。此外，服务名称用于绑定服务。因此，在前面的示例中，服务绑定在<code>'rmi://HOST:1199/AccountService'</code> 。我们稍后将使用此URL来链接客户端的服务。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>servicePort</code>属性已被省略（默认为0）。这意味着将使用匿名端口与服务进行通信。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="remoting-rmi-client"><a class="anchor" href="#remoting-rmi-client"></a> 1.1.2。在客户端链接服务</h4>
<div class="paragraph">
<p>我们的客户是一个使用<code>AccountService</code>如以下示例所示，用于管理帐户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SimpleObject {

    private AccountService accountService;

    public void setAccountService(AccountService accountService) {
        this.accountService = accountService;
    }

    // additional methods using the accountService
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在客户端上链接服务，我们创建了一个单独的Spring容器，其中包含以下简单对象和服务链接配置位：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="rmi://HOST:1199/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是我们要在客户端上支持远程帐户服务所需要做的一切。Spring透明地创建一个调用程序，并通过远程启用帐户服务<code>RmiServiceExporter</code> 。在客户处，我们使用<code>RmiProxyFactoryBean</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-caucho-protocols"><a class="anchor" href="#remoting-caucho-protocols"></a> 1.2。使用Hessian通过HTTP远程调用服务</h3>
<div class="paragraph">
<p>Hessian提供了一个基于HTTP的二进制远程协议。它由Caucho开发，您可以在<a href="https://www.caucho.com/" class="bare">https://www.caucho.com/上</a>找到有关Hessian本身的更多信息。</p>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian"><a class="anchor" href="#remoting-caucho-protocols-hessian"></a> 1.2.1。黑森州</h4>
<div class="paragraph">
<p>Hessian通过HTTP进行通信，并通过使用自定义servlet进行通信。通过使用Spring的<code>DispatcherServlet</code>原理（请参阅<a href="webmvc.html#mvc-servlet">[webmvc＃mvc-servlet]</a> ），我们可以连接此类servlet来公开您的服务。首先，我们必须在应用程序中创建一个新的servlet，如以下摘录所示： <code>web.xml</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您熟悉Spring的<code>DispatcherServlet</code>原理，您可能知道现在必须创建一个名为<code>remoting-servlet.xml</code> （在Servlet名称之后） <code>WEB-INF</code>目录。下一节将使用应用程序上下文。</p>
</div>
<div class="paragraph">
<p>或者，考虑使用Spring更简单的方法<code>HttpRequestHandlerServlet</code> 。这样一来，您就可以将远程导出程序定义嵌入到根应用程序上下文中（默认情况下， <code>WEB-INF/applicationContext.xml</code> ），以及指向特定导出器bean的各个servlet定义。在这种情况下，每个servlet名称都需要与其目标导出器的bean名称相匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian-server"><a class="anchor" href="#remoting-caucho-protocols-hessian-server"></a> 1.2.2。使用公开您的豆子<code>HessianServiceExporter</code></h4>
<div class="paragraph">
<p>在新创建的应用程序上下文中称为<code>remoting-servlet.xml</code> ，我们创建一个<code>HessianServiceExporter</code>导出我们的服务，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;

&lt;bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们准备在客户端链接服务。没有指定显式处理程序映射（将请求URL映射到服务），因此我们使用<code>BeanNameUrlHandlerMapping</code>用过的。因此，该服务将导出到包含以下内容的通过其bean名称指示的URL： <code>DispatcherServlet</code>实例的映射（如先前定义）： <code><a href="https://HOST:8080/remoting/AccountService" class="bare">https://HOST:8080/remoting/AccountService</a></code> 。</p>
</div>
<div class="paragraph">
<p>或者，您可以创建一个<code>HessianServiceExporter</code>在您的根应用程序上下文中（例如，在<code>WEB-INF/applicationContext.xml</code> ），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean name="accountExporter" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在后一种情况下，您应该为此出口商定义一个相应的servlet， <code>web.xml</code> ，最终结果相同：导出器映射到位于的请求路径<code>/remoting/AccountService</code> 。注意，servlet名称需要与目标导出器的bean名称匹配。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-hessian-client"><a class="anchor" href="#remoting-caucho-protocols-hessian-client"></a> 1.2.3。在客户端上链接服务</h4>
<div class="paragraph">
<p>通过使用<code>HessianProxyFactoryBean</code> ，我们可以在客户端链接服务。与RMI示例相同的原理适用。我们创建了一个单独的bean工厂或应用程序上下文，并在以下bean中提到了<code>SimpleObject</code>是通过使用<code>AccountService</code>如以下示例所示，用于管理帐户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-caucho-protocols-security"><a class="anchor" href="#remoting-caucho-protocols-security"></a> 1.2.4。将HTTP基本身份验证应用于通过Hessian公开的服务</h4>
<div class="paragraph">
<p>Hessian的优点之一是我们可以轻松地应用HTTP基本身份验证，因为这两种协议都是基于HTTP的。您可以使用以下命令来应用常规的HTTP服务器安全机制： <code>web.xml</code>安全功能，例如。通常，您无需在此处使用每个用户的安全凭证。相反，您可以使用您在<code>HessianProxyFactoryBean</code>级别（类似于JDBC <code>DataSource</code> ），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;
    &lt;property name="interceptors" ref="authorizationInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="authorizationInterceptor"
        class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor"&gt;
    &lt;property name="authorizedRoles" value="administrator,operator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们明确提到了<code>BeanNameUrlHandlerMapping</code>并设置一个拦截器，仅允许管理员和操作员调用此应用程序上下文中提到的bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的示例未显示灵活的安全基础结构。有关安全性的更多选项，请参阅<a href="https://projects.spring.io/spring-security/" class="bare">https://projects.spring.io/spring-security/</a>上的Spring Security项目。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-httpinvoker"><a class="anchor" href="#remoting-httpinvoker"></a> 1.3。Spring HTTP调用程序</h3>
<div class="paragraph">
<p>与Hessian相对，Spring HTTP调用程序都是轻量级协议，它们使用自己的苗条序列化机制，并使用标准Java序列化机制通过HTTP公开服务。如果您的参数和返回类型是无法通过使用Hessian使用的序列化机制进行序列化的复杂类型，则这将具有巨大的优势（选择远程处理技术时，请参阅下一节以获得更多注意事项）。</p>
</div>
<div class="paragraph">
<p>在幕后，Spring使用JDK或Apache提供的标准设施<code>HttpComponents</code>执行HTTP调用。如果您需要更高级且更易于使用的功能，请使用后者。有关更多信息，请参见<a href="https://hc.apache.org/httpcomponents-client-ga/">hc.apache.org/httpcomponents-client-ga/</a> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意由于不安全的Java反序列化而导致的漏洞：在反序列化步骤中，操纵的输入流可能导致服务器上有害的代码执行。因此，请勿将HTTP调用者终结点暴露给不受信任的客户端。而是仅在您自己的服务之间公开它们。通常，强烈建议您改用其他任何消息格式（例如JSON）。</p>
</div>
<div class="paragraph">
<p>如果您担心由Java序列化引起的安全漏洞，请考虑在核心JVM级别上使用通用序列化筛选器机制，该机制最初是为JDK 9开发的，但同时又移植到了JDK 8、7和6。参见<a href="https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a" class="bare">https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a</a>和<a href="https://openjdk.java.net/jeps/290" class="bare">https://openjdk.java.net/jeps/290</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="remoting-httpinvoker-server"><a class="anchor" href="#remoting-httpinvoker-server"></a> 1.3.1。公开服务对象</h4>
<div class="paragraph">
<p>为服务对象设置HTTP调用程序基础结构与使用Hessian进行操作的方式非常相似。正如黑森州的支持所提供的<code>HessianServiceExporter</code> ，Spring的HttpInvoker支持提供了<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code> 。</p>
</div>
<div class="paragraph">
<p>揭露<code>AccountService</code> （在前面提到）在Spring Web MVC中<code>DispatcherServlet</code> ，则需要在调度程序的应用程序上下文中进行以下配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean name="/AccountService" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的出口商定义是通过<code>DispatcherServlet</code>实例的标准映射工具，如<a href="#remoting-caucho-protocols">有关Hessian的部分所述</a> 。</p>
</div>
<div class="paragraph">
<p>或者，您可以创建一个<code>HttpInvokerServiceExporter</code>在您的根应用程序上下文中（例如，在<code>'WEB-INF/applicationContext.xml'</code> ），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean name="accountExporter" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，您可以在以下位置为此出口商定义相应的servlet： <code>web.xml</code> ，其中Servlet名称与目标导出器的Bean名称匹配，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-httpinvoker-client"><a class="anchor" href="#remoting-httpinvoker-client"></a> 1.3.2。在客户端链接服务</h4>
<div class="paragraph">
<p>同样，从客户端链接服务与使用Hessian时的方式非常相似。通过使用代理，Spring可以将对HTTP POST请求的调用转换为指向导出服务的URL。以下示例显示如何配置此安排：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="httpInvokerProxy" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，您可以选择要使用的HTTP客户端。默认情况下， <code>HttpInvokerProxy</code>使用JDK的HTTP功能，但是您也可以使用Apache <code>HttpComponents</code>通过设置客户端<code>httpInvokerRequestExecutor</code>属性。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;property name="httpInvokerRequestExecutor"&gt;
    &lt;bean class="org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"/&gt;
&lt;/property&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-web-services"><a class="anchor" href="#remoting-web-services"></a> 1.4。Java Web服务</h3>
<div class="paragraph">
<p>Spring提供了对标准Java Web服务API的全面支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用JAX-WS公开Web服务</p>
</li>
<li>
<p>使用JAX-WS访问Web服务</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了在Spring Core中对JAX-WS的库存支持之外，Spring产品组合还具有<a href="http://www.springframework.org/spring-ws">Spring Web Services</a> ，它是合同优先，文档驱动的Web服务的解决方案-强烈建议用于构建现代的，面向未来的Web服务。</p>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-servlet"><a class="anchor" href="#remoting-web-services-jaxws-export-servlet"></a> 1.4.1。使用JAX-WS公开基于Servlet的Web服务</h4>
<div class="paragraph">
<p>Spring为JAX-WS servlet端点实现提供了一个方便的基类： <code>SpringBeanAutowiringSupport</code> 。揭露我们的<code>AccountService</code> ，我们扩展Spring的<code>SpringBeanAutowiringSupport</code>在这里分类并实现我们的业务逻辑，通常将调用委派给业务层。我们用Spring的<code>@Autowired</code>注释，以表示对Spring托管Bean的此类依赖性。以下示例显示了扩展的类<code>SpringBeanAutowiringSupport</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">/**
 * JAX-WS compliant AccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-WS requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through
 * the @Autowired annotation) is the simplest JAX-WS compliant way.
 *
 * This is the class registered with the server-side JAX-WS implementation.
 * In the case of a Java EE server, this would simply be defined as a servlet
 * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting
 * accordingly. The servlet name usually needs to match the specified WS service name.
 *
 * The web service engine manages the lifecycle of instances of this class.
 * Spring bean references will just be wired in here.
 */
import org.springframework.web.context.support.SpringBeanAutowiringSupport;

@WebService(serviceName="AccountService")
public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
        biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
        return biz.getAccounts(name);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的<code>AccountServiceEndpoint</code>需要在与Spring上下文相同的Web应用程序中运行，以允许访问Spring的设施。在Java EE环境中，默认情况下是这种情况，它使用用于JAX-WS servlet端点部署的标准协定。有关详细信息，请参见各种Java EE Web服务教程。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-standalone"><a class="anchor" href="#remoting-web-services-jaxws-export-standalone"></a> 1.4.2。使用JAX-WS导出独立的Web服务</h4>
<div class="paragraph">
<p>Oracle JDK随附的内置JAX-WS提供程序通过使用JDK中也包含的内置HTTP服务器来支持Web服务公开。春天的<code>SimpleJaxWsServiceExporter</code>检测全部<code>@WebService</code> -在Spring应用程序上下文中带有注释的Bean，并通过默认的JAX-WS服务器（JDK HTTP服务器）导出它们。</p>
</div>
<div class="paragraph">
<p>在这种情况下，端点实例被定义和管理为Spring bean本身。它们是使用JAX-WS引擎注册的，但是它们的生命周期取决于Spring应用程序上下文。这意味着您可以将Spring功能（例如显式依赖项注入）应用于端点实例。通过注释驱动的注入<code>@Autowired</code>也可以。以下示例显示了如何定义这些bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"&gt;
    &lt;property name="baseAddress" value="http://localhost:8080/"/&gt;
&lt;/bean&gt;

&lt;bean id="accountServiceEndpoint" class="example.AccountServiceEndpoint"&gt;
    ...
&lt;/bean&gt;

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>AccountServiceEndpoint</code>可以但不必源自Spring的<code>SpringBeanAutowiringSupport</code> ，因为此示例中的端点是完全由Spring管理的Bean。这意味着端点实现可以如下所示（不声明任何超类，而Spring的<code>@Autowired</code>配置注释仍然被接受）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@WebService(serviceName="AccountService")
public class AccountServiceEndpoint {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
        biz.insertAccount(acc);
    }

    @WebMethod
    public List&lt;Account&gt; getAccounts(String name) {
        return biz.getAccounts(name);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-export-ri"><a class="anchor" href="#remoting-web-services-jaxws-export-ri"></a> 1.4.3。使用JAX-WS RI的Spring支持导出Web服务</h4>
<div class="paragraph">
<p>作为GlassFish项目的一部分开发的Oracle JAX-WS RI，将Spring支持作为其JAX-WS Commons项目的一部分。这允许将JAX-WS端点定义为Spring管理的Bean，类似于上<a href="#remoting-web-services-jaxws-export-standalone">一节中</a>讨论的独立模式-但这次是在Servlet环境中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这在Java EE环境中不可移植。它主要用于将JAX-WS RI嵌入为Web应用程序一部分的非EE环境，例如Tomcat。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>与导出基于servlet的端点的标准样式的不同之处在于，端点实例本身的生命周期由Spring管理，并且在其中仅定义了一个JAX-WS servlet。 <code>web.xml</code> 。使用标准的Java EE样式（如前所示），每个服务端点都有一个servlet定义，每个端点通常都委派给Spring Bean（通过使用<code>@Autowired</code> ，如前所示）。</p>
</div>
<div class="paragraph">
<p>有关设置和使用样式的详细信息，请参见<a href="https://jax-ws-commons.java.net/spring/">https://jax-ws-commons.java.net/spring/</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoting-web-services-jaxws-access"><a class="anchor" href="#remoting-web-services-jaxws-access"></a> 1.4.4。使用JAX-WS访问Web服务</h4>
<div class="paragraph">
<p>Spring提供了两个工厂bean来创建JAX-WS Web服务代理，分别是<code>LocalJaxWsServiceFactoryBean</code>和<code>JaxWsPortProxyFactoryBean</code> 。前者只能返回一个JAX-WS服务类供我们使用。后者是完整版本，可以返回实现我们的业务服务接口的代理。在以下示例中，我们使用<code>JaxWsPortProxyFactoryBean</code>为创建代理<code>AccountService</code>端点（再次）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;property name="wsdlDocumentUrl" value="http://localhost:8888/AccountServiceEndpoint?WSDL"/&gt;
    &lt;property name="namespaceUri" value="https://example/"/&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="portName" value="AccountServiceEndpointPort"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>哪里<code>serviceInterface</code>是客户使用的我们的业务界面。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>wsdlDocumentUrl</code>是WSDL文件的URL。Spring在启动时需要使用它来创建JAX-WS服务。 <code>namespaceUri</code>对应于<code>targetNamespace</code>在.wsdl文件中。 <code>serviceName</code>对应于.wsdl文件中的服务名称。<code>portName</code>对应于.wsdl文件中的端口名称。</p>
</div>
<div class="paragraph">
<p>访问Web服务很容易，因为我们有一个供其使用的bean工厂，它将它公开为一个名为<code>AccountService</code> 。以下示例显示了如何在Spring中进行连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="client" class="example.AccountClientImpl"&gt;
    ...
    &lt;property name="service" ref="accountWebService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从客户端代码中，我们可以像访问普通类一样访问Web服务，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class AccountClientImpl {

    private AccountService service;

    public void setService(AccountService service) {
        this.service = service;
    }

    public void foo() {
        service.insertAccount(...);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">上面的内容略有简化，因为JAX-WS要求端点接口和实现类使用注释<code>@WebService</code> ， <code>@SOAPBinding</code>等注释。这意味着您不能（轻松地）将纯Java接口和实现类用作JAX-WS端点工件。您需要先对其进行相应注释。查看JAX-WS文档以获取有关这些需求的详细信息。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-jms"><a class="anchor" href="#remoting-jms"></a> 1.5。JMS</h3>
<div class="paragraph">
<p>您还可以通过使用JMS作为基础通信协议来透明地公开服务。Spring框架中的JMS远程支持非常基本。它在<code>same thread</code>并且在同一非交易中<code>Session</code> 。结果，吞吐量取决于实现。请注意，这些单线程和非事务性约束仅适用于Spring的JMS远程支持。请参阅<a href="#jms">JMS（Java消息服务）</a>以获取有关Spring对基于JMS的消息传递的丰富支持的信息。</p>
</div>
<div class="paragraph">
<p>服务器和客户端均使用以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

public interface CheckingAccountService {

    public void cancelAccount(Long accountId);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在服务器端使用上述接口的以下简单实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

public class SimpleCheckingAccountService implements CheckingAccountService {

    public void cancelAccount(Long accountId) {
        System.out.println("Cancelling account [" + accountId + "]");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下配置文件包含在客户机和服务器上共享的JMS基础结构Bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://ep-t43:61616"/&gt;
    &lt;/bean&gt;

    &lt;bean id="queue" class="org.apache.activemq.command.ActiveMQQueue"&gt;
        &lt;constructor-arg value="mmm"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="remoting-jms-server"><a class="anchor" href="#remoting-jms-server"></a> 1.5.1。服务器端配置</h4>
<div class="paragraph">
<p>在服务器上，您需要公开使用<code>JmsInvokerServiceExporter</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="checkingAccountService"
            class="org.springframework.jms.remoting.JmsInvokerServiceExporter"&gt;
        &lt;property name="serviceInterface" value="com.foo.CheckingAccountService"/&gt;
        &lt;property name="service"&gt;
            &lt;bean class="com.foo.SimpleCheckingAccountService"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;property name="destination" ref="queue"/&gt;
        &lt;property name="concurrentConsumers" value="3"/&gt;
        &lt;property name="messageListener" ref="checkingAccountService"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Server {

    public static void main(String[] args) throws Exception {
        new ClassPathXmlApplicationContext("com/foo/server.xml", "com/foo/jms.xml");
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remoting-jms-client"><a class="anchor" href="#remoting-jms-client"></a> 1.5.2。客户端配置</h4>
<div class="paragraph">
<p>客户端只需要创建一个客户端代理即可实现协议接口（ <code>CheckingAccountService</code> ）。</p>
</div>
<div class="paragraph">
<p>以下示例定义了可以注入到其他客户端对象中的Bean（代理负责通过JMS将调用转发到服务器端对象）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="checkingAccountService"
            class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"&gt;
        &lt;property name="serviceInterface" value="com.foo.CheckingAccountService"/&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;property name="queue" ref="queue"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.foo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Client {

    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("com/foo/client.xml", "com/foo/jms.xml");
        CheckingAccountService service = (CheckingAccountService) ctx.getBean("checkingAccountService");
        service.cancelAccount(new Long(10));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="remoting-amqp"><a class="anchor" href="#remoting-amqp"></a> 1.6。AMQP</h3>
<div class="paragraph">
<p>Spring AMQP项目支持通过AMQP作为基础协议进行远程处理。有关更多详细信息，请访问Spring AMQP参考中的<a href="https://docs.spring.io/spring-amqp/docs/current/reference/html/#remoting">Spring Remoting</a>部分。</p>
</div>
<div id="remoting-autodection-remote-interfaces" class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>远程接口未实现自动检测</p>
</div>
<div class="paragraph">
<p>对于远程接口，不会自动检测已实现接口的主要原因是为了避免为远程呼叫者打开太多门。目标对象可能实现内部回调接口，例如<code>InitializingBean</code>要么<code>DisposableBean</code>谁不想暴露给呼叫者。</p>
</div>
<div class="paragraph">
<p>在本地情况下，提供具有目标所实现的所有接口的代理通常无关紧要。但是，在导出远程服务时，应公开特定的服务接口，以及用于远程使用的特定操作。除了内部回调接口之外，目标还可以实现多个业务接口，其中只有一个用于远程公开。由于这些原因，我们需要指定这样的服务接口。</p>
</div>
<div class="paragraph">
<p>这是配置便利性与内部方法意外暴露的风险之间的折衷方案。始终指定服务接口并不会花费太多精力，这使您可以安全地控制特定方法的使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="remoting-considerations"><a class="anchor" href="#remoting-considerations"></a> 1.7。选择技术时的注意事项</h3>
<div class="paragraph">
<p>这里介绍的每种技术都有其缺点。选择一种技术时，应仔细考虑您的需求，公开的服务以及通过网络发送的对象。</p>
</div>
<div class="paragraph">
<p>使用RMI时，除非通过隧道传送RMI流量，否则无法通过HTTP协议访问对象。RMI是一个重量级协议，因为它支持全对象序列化，当您使用需要通过网络进行序列化的复杂数据模型时，RMI非常重要。但是，RMI-JRMP绑定到Java客户端。它是Java到Java的远程解决方案。</p>
</div>
<div class="paragraph">
<p>如果您需要基于HTTP的远程处理而且还依赖Java序列化，那么Spring的HTTP调用程序是一个不错的选择。它与RMI调用程序共享基本的基础结构，但使用HTTP作为传输。请注意，HTTP调用程序不仅限于Java到Java远程处理，还不仅限于客户端和服务器端的Spring。（后者也适用于非RMI接口的Spring RMI调用程序。）</p>
</div>
<div class="paragraph">
<p>在异类环境中运行时，Hessian可能会提供重要的价值，因为它们明确允许使用非Java客户端。但是，非Java支持仍然有限。已知的问题包括Hibernate对象的序列化以及延迟初始化的集合。如果您有这样的数据模型，请考虑使用RMI或HTTP调用程序而不是Hessian。</p>
</div>
<div class="paragraph">
<p>JMS可用于提供服务群集，并让JMS代理负责负载平衡，发现和自动故障转移。默认情况下，Java序列化用于JMS远程处理，但是JMS提供程序可以使用其他机制进行线路格式化，例如XStream，以使服务器可以用其他技术实现。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的一点是，EJB具有优于RMI的优势，因为它支持基于标准角色的身份验证和授权以及远程事务传播。尽管核心Spring并没有提供RMI调用程序或HTTP调用程序来支持安全上下文传播，但也有可能。Spring仅提供适当的挂钩来插入第三方或自定义解决方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="rest-client-access"><a class="anchor" href="#rest-client-access"></a> 1.8。REST端点</h3>
<div class="paragraph">
<p>Spring框架提供了两种选择来调用REST端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rest-resttemplate"><code>RestTemplate</code></a> ：具有同步模板方法API的原始Spring REST客户端。</p>
</li>
<li>
<p><a href="web-reactive.html#webflux-client">WebClient</a> ：一种无阻塞的，反应性的替代方案，它支持同步和异步以及流方案。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.0开始，非阻塞式，反应式<code>WebClient</code>提供了现代的替代方案<code>RestTemplate</code>有效支持同步和异步以及流方案。的<code>RestTemplate</code>将在以后的版本中弃用，并且以后不会添加任何主要的新功能。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="rest-resttemplate"><a class="anchor" href="#rest-resttemplate"></a> 1.8.1。<code>RestTemplate</code></h4>
<div class="paragraph">
<p>的<code>RestTemplate</code>通过HTTP客户端库提供了更高级别的API。它使在一行中轻松调用REST端点变得容易。它公开了以下几组重载方法：</p>
</div>
<table id="rest-overview-of-resttemplate-methods-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。RestTemplate方法</caption>
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法组</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过GET检索表示形式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getForEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检索一个<code>ResponseEntity</code> （即状态，标头和正文）（使用GET）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>headForHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用HEAD检索资源的所有标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用POST创建新资源并返回<code>Location</code>响应中的标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用POST创建新资源，并从响应中返回表示形式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postForEntity</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用POST创建新资源，并从响应中返回表示形式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>put</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用PUT创建或更新资源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>patchForObject</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用PATCH更新资源，并从响应中返回表示形式。注意，JDK <code>HttpURLConnection</code>不支持<code>PATCH</code> ，但Apache HttpComponents和其他人可以。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用DELETE删除指定URI处的资源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optionsForAllow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过使用ALLOW检索资源的允许的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">前述方法的通用性强（且不那么固执）版本，可在需要时提供额外的灵活性。它接受一个<code>RequestEntity</code> （包括HTTP方法，URL，标头和正文作为输入），并返回一个<code>ResponseEntity</code> 。
</p><p class="tableblock">这些方法允许使用<code>ParameterizedTypeReference</code>代替<code>Class</code>用泛型指定响应类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>execute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行请求的最通用方法，完全控制通过回调接口进行的请求准备和响应提取。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="rest-resttemplate-create"><a class="anchor" href="#rest-resttemplate-create"></a>初始化</h5>
<div class="paragraph">
<p>默认构造函数使用<code>java.net.HttpURLConnection</code>执行请求。您可以使用以下实现切换到其他HTTP库<code>ClientHttpRequestFactory</code> 。内置支持以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache HttpComponents</p>
</li>
<li>
<p>净额</p>
</li>
<li>
<p>OkHttp</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，要切换到Apache HttpComponents，可以使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RestTemplate template = new RestTemplate(new HttpComponentsClientHttpRequestFactory());</code></pre>
</div>
</div>
<div class="paragraph">
<p>每<code>ClientHttpRequestFactory</code>公开特定于基础HTTP客户端库的配置选项-例如，用于凭据，连接池和其他详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">请注意<code>java.net</code>访问表示错误的响应状态（例如401）时，HTTP请求的实现可能引发异常。如果这是一个问题，请切换到另一个HTTP客户端库。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="rest-resttemplate-uri"><a class="anchor" href="#rest-resttemplate-uri"></a> URIs</h5>
<div class="paragraph">
<p>许多<code>RestTemplate</code>方法接受URI模板和URI模板变量，作为<code>String</code>可变参数，或为<code>Map<String,String></code> 。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>String</code>可变参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String result = restTemplate.getForObject(
        "https://example.com/hotels/{hotel}/bookings/{booking}", String.class, "42", "21");</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例使用<code>Map<String, String></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Map&lt;String, String&gt; vars = Collections.singletonMap("hotel", "42");

String result = restTemplate.getForObject(
        "https://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，URI模板是自动编码的，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">restTemplate.getForObject("https://example.com/hotel list", String.class);

// Results in request to "https://example.com/hotel%20list"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>uriTemplateHandler</code>的财产<code>RestTemplate</code>自定义URI的编码方式。或者，您可以准备一个<code>java.net.URI</code>并将其传递给<code>RestTemplate</code>接受一个的方法<code>URI</code> 。</p>
</div>
<div class="paragraph">
<p>有关使用和编码URI的更多详细信息，请参阅<a href="web.html#mvc-uri-building">URI链接</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-headers"><a class="anchor" href="#rest-template-headers"></a>标头</h5>
<div class="paragraph">
<p>您可以使用<code>exchange()</code>指定请求标头的方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String uriTemplate = "https://example.com/hotels/{hotel}";
URI uri = UriComponentsBuilder.fromUriString(uriTemplate).build(42);

RequestEntity&lt;Void&gt; requestEntity = RequestEntity.get(uri)
        .header(("MyRequestHeader", "MyValue")
        .build();

ResponseEntity&lt;String&gt; response = template.exchange(requestEntity, String.class);

String responseHeader = response.getHeaders().getFirst("MyResponseHeader");
String body = response.getBody();</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过许多方法获取响应头<code>RestTemplate</code>返回的方法变体<code>ResponseEntity</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-body"><a class="anchor" href="#rest-template-body"></a>身体</h5>
<div class="paragraph">
<p>传入和传出对象<code>RestTemplate</code>方法在原始内容的帮助下转换为原始内容<code>HttpMessageConverter</code> 。</p>
</div>
<div class="paragraph">
<p>在POST上，输入对象被序列化到请求主体，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>URI location = template.postForLocation("https://example.com/people", person);</pre>
</div>
</div>
<div class="paragraph">
<p>您无需显式设置请求的Content-Type标头。在大多数情况下，您可以根据来源找到兼容的消息转换器<code>Object</code>类型，然后所选的消息转换器将相应地设置内容类型。如有必要，您可以使用<code>exchange</code>明确提供<code>Content-Type</code>请求标头，进而影响选择哪个消息转换器。</p>
</div>
<div class="paragraph">
<p>在GET上，响应主体反序列化为输出<code>Object</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Person person = restTemplate.getForObject("https://example.com/people/{id}", Person.class, 42);</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Accept</code>不需要显式设置请求的标头。在大多数情况下，可以根据预期的响应类型找到兼容的消息转换器，这有助于填充<code>Accept</code>标头。如有必要，您可以使用<code>exchange</code>提供方法<code>Accept</code>标头。</p>
</div>
<div class="paragraph">
<p>默认， <code>RestTemplate</code>注册所有内置<a href="#rest-message-conversion">消息转换器</a> ，具体取决于类路径检查，这些检查有助于确定存在哪些可选转换库。您还可以将消息转换器设置为显式使用。</p>
</div>
</div>
<div class="sect4">
<h5 id="rest-message-conversion"><a class="anchor" href="#rest-message-conversion"></a>讯息转换</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>spring-web</code>模块包含<code>HttpMessageConverter</code>通过以下协议读写HTTP请求和响应的主体<code>InputStream</code>和<code>OutputStream</code> 。
<code>HttpMessageConverter</code>实例用于客户端（例如， <code>RestTemplate</code> ）和服务器端（例如，在Spring MVC REST控制器中）。</p>
</div>
<div class="paragraph">
<p>框架中提供了主要媒体（MIME）类型的具体实现，并且默认情况下已向<code>RestTemplate</code>在客户端和<code>RequestMethodHandlerAdapter</code>在服务器端（请参阅<a href="web.html#mvc-config-message-converters">配置消息转换器</a> ）。</p>
</div>
<div class="paragraph">
<p>的实现<code>HttpMessageConverter</code>在以下各节中进行介绍。对于所有转换器，都使用默认媒体类型，但是您可以通过设置默认媒体类型来覆盖它<code>supportedMediaTypes</code> bean属性。下表描述了每种实现：</p>
</div>
<table id="rest-message-converters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表2。HttpMessageConverter实现</caption>
<colgroup>
<col style="width:25%">
<col style="width:75%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">消息转换器</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以读写的实现<code>String</code> HTTP请求和响应的实例。默认情况下，此转换器支持所有文本媒体类型（ <code>text/*</code> ）并用<code>Content-Type</code>的<code>text/plain</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FormHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以从HTTP请求和响应中读取和写入表单数据的实现。默认情况下，此转换器读取和写入<code>application/x-www-form-urlencoded</code>媒体类型。表单数据可从中读取并写入<code>MultiValueMap<String, String></code> 。转换器还可以写入（但不能读取）从存储器读取的多部分数据。 <code>MultiValueMap<String, Object></code> 。默认， <code>multipart/form-data</code>支持。从Spring Framework 5.2开始，可以支持其他多部分子类型来编写表单数据。请向javadoc咨询<code>FormHttpMessageConverter</code>有关更多详细信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以从HTTP请求和响应读取和写入字节数组的实现。默认情况下，此转换器支持所有媒体类型（ <code>*/*</code> ）并用<code>Content-Type</code>的<code>application/octet-stream</code> 。您可以通过设置<code>supportedMediaTypes</code>财产和压倒一切<code>getContentType(byte[])</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MarshallingHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以通过使用Spring的读写XML的实现<code>Marshaller</code>和<code>Unmarshaller</code>来自的抽象<code>org.springframework.oxm</code>包。此转换器需要一个<code>Marshaller</code>和<code>Unmarshaller</code>在可以使用之前。您可以通过构造函数或bean属性注入它们。默认情况下，此转换器支持<code>text/xml</code>和<code>application/xml</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingJackson2HttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以使用Jackson读取和写入JSON的实现<code>ObjectMapper</code> 。您可以根据需要使用Jackson提供的注释来自定义JSON映射。当您需要进一步控制时（对于需要为特定类型提供自定义JSON序列化器/反序列化器的情况），可以注入自定义<code>ObjectMapper</code>通过<code>ObjectMapper</code>属性。默认情况下，此转换器支持<code>application/json</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingJackson2XmlHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以通过使用<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML</a>扩展名读取和写入XML的实现<code>XmlMapper</code> 。您可以根据需要通过使用JAXB或Jackson提供的注释来自定义XML映射。当您需要进一步控制时（对于需要为特定类型提供自定义XML序列化器/反序列化器的情况），可以注入自定义<code>XmlMapper</code>通过<code>ObjectMapper</code>属性。默认情况下，此转换器支持<code>application/xml</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SourceHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以读写的实现<code>javax.xml.transform.Source</code>从HTTP请求和响应。只要<code>DOMSource</code> ， <code>SAXSource</code>和<code>StreamSource</code>支持。默认情况下，此转换器支持<code>text/xml</code>和<code>application/xml</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BufferedImageHttpMessageConverter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个<code>HttpMessageConverter</code>可以读写的实现<code>java.awt.image.BufferedImage</code>从HTTP请求和响应。该转换器读取和写入Java I / O API支持的媒体类型。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="rest-template-jsonview"><a class="anchor" href="#rest-template-jsonview"></a>杰克逊JSON视图</h5>
<div class="paragraph">
<p>您可以指定<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson JSON视图</a>以仅序列化对象属性的一部分，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MappingJacksonValue value = new MappingJacksonValue(new User("eric", "7!jd#h23"));
value.setSerializationView(User.WithoutPasswordView.class);

RequestEntity&lt;MappingJacksonValue&gt; requestEntity =
    RequestEntity.post(new URI("https://example.com/user")).body(value);

ResponseEntity&lt;String&gt; response = template.exchange(requestEntity, String.class);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rest-template-multipart"><a class="anchor" href="#rest-template-multipart"></a>多部分</h5>
<div class="paragraph">
<p>要发送多部分数据，您需要提供一个<code>MultiValueMap<String, Object></code>其值可能是<code>Object</code>对于零件内容， <code>Resource</code>对于文件部分，或者<code>HttpEntity</code>带标题的零件内容。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    MultiValueMap&lt;String, Object&gt; parts = new LinkedMultiValueMap&lt;&gt;();

    parts.add("fieldPart", "fieldValue");
    parts.add("filePart", new FileSystemResource("...logo.png"));
    parts.add("jsonPart", new Person("Jason"));

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_XML);
    parts.add("xmlPart", new HttpEntity&lt;&gt;(myBean, headers));</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下，您不必指定<code>Content-Type</code>每个部分。内容类型是根据<code>HttpMessageConverter</code>选择序列化它，或者如果是<code>Resource</code>基于文件扩展名。如有必要，您可以明确提供<code>MediaType</code>带着<code>HttpEntity</code>包装纸。</p>
</div>
<div class="paragraph">
<p>一旦<code>MultiValueMap</code>准备好了，您可以将其传递给<code>RestTemplate</code> ，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    MultiValueMap&lt;String, Object&gt; parts = ...;
    template.postForObject("https://example.com/upload", parts, Void.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>MultiValueMap</code>包含至少一个非<code>String</code>价值， <code>Content-Type</code>被设定为<code>multipart/form-data</code>由<code>FormHttpMessageConverter</code> 。如果<code>MultiValueMap</code>拥有<code>String</code>重视<code>Content-Type</code>默认为<code>application/x-www-form-urlencoded</code> 。如有必要<code>Content-Type</code>也可以明确设置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rest-async-resttemplate"><a class="anchor" href="#rest-async-resttemplate"></a> 1.8.2。使用<code>AsyncRestTemplate</code> （已弃用）</h4>
<div class="paragraph">
<p>的<code>AsyncRestTemplate</code>不推荐使用。对于所有您可能考虑使用的用例<code>AsyncRestTemplate</code> ，请改用<a href="web-reactive.html#webflux-client">WebClient</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ejb"><a class="anchor" href="#ejb"></a> 2。企业JavaBeans（EJB）集成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为轻量级容器，Spring通常被认为是EJB的替代品。我们确实相信，对于许多（即使不是大多数）应用程序和用例，Spring作为一个容器，结合其在事务，ORM和JDBC访问方面的丰富支持功能，比通过EJB实现等效功能是更好的选择。容器和EJB。</p>
</div>
<div class="paragraph">
<p>但是，请务必注意，使用Spring不会阻止您使用EJB。实际上，Spring使访问EJB以及在其中实现EJB和功能变得更加容易。此外，使用Spring访问EJB提供的服务可以使这些服务的实现稍后在本地EJB，远程EJB或POJO（普通的Java对象）变体之间透明切换，而不必更改客户端代码。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将研究Spring如何帮助您访问和实现EJB。当访问无状态会话Bean（SLSB）时，Spring提供了特殊的价值，因此我们从讨论此主题开始。</p>
</div>
<div class="sect2">
<h3 id="ejb-access"><a class="anchor" href="#ejb-access"></a> 2.1。访问EJB</h3>
<div class="paragraph">
<p>本节介绍如何访问EJB。</p>
</div>
<div class="sect3">
<h4 id="ejb-access-concepts"><a class="anchor" href="#ejb-access-concepts"></a> 2.1.1。概念</h4>
<div class="paragraph">
<p>要在本地或远程无状态会话Bean上调用方法，客户端代码通常必须执行JNDI查找以获得（本地或远程）EJB Home对象，然后使用<code>create</code>该对象上的方法调用以获得实际的（本地或远程）EJB对象。然后在EJB上调用一种或多种方法。</p>
</div>
<div class="paragraph">
<p>为了避免重复的低级代码，许多EJB应用程序都使用服务定位器和业务委托模式。这些比在整个客户端代码中喷射JNDI查找要好，但是它们的常规实现有很多缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常，使用EJB的代码取决于Service Locator或Business Delegate单例，因此很难进行测试。</p>
</li>
<li>
<p>在不使用业务委托的情况下使用服务定位器模式的情况下，应用程序代码仍然最终必须调用<code>create()</code> EJB Home上的方法并处理所产生的异常。因此，它仍然与EJB API和EJB编程模型的复杂性联系在一起。</p>
</li>
<li>
<p>实现业务委托模式通常会导致大量的代码重复，我们必须编写许多在EJB上调用相同方法的方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring的方法是允许创建和使用代理对象（通常在Spring容器内配置），这些代理对象充当无代码的业务委托。除非您在此类代码中实际添加了实际价值，否则您无需在手动编码的业务委托中编写另一个Service Locator，另一个JNDI查找或重复方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-local"><a class="anchor" href="#ejb-access-local"></a> 2.1.2。访问本地SLSB</h4>
<div class="paragraph">
<p>假设我们有一个需要使用本地EJB的Web控制器。我们遵循最佳实践，并使用EJB业务方法接口模式，以便EJB的本地接口扩展了非EJB特定的业务方法接口。我们称这种业务方法为接口<code>MyComponent</code> 。以下示例显示了这样的接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface MyComponent {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用业务方法接口模式的主要原因之一是确保本地接口中的方法签名与bean实现类之间的同步是自动的。另一个原因是，如果有必要的话，以后可以使我们更轻松地切换到服务的POJO（普通旧Java对象）实现。我们还需要实现本地home接口，并提供一个实现类<code>SessionBean</code>和<code>MyComponent</code>业务方法界面。现在，将Web层控制器连接到EJB实现所需要做的唯一Java编码是公开类型的setter方法。 <code>MyComponent</code>在控制器上。这会将引用另存为控制器中的实例变量。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private MyComponent myComponent;

public void setMyComponent(MyComponent myComponent) {
    this.myComponent = myComponent;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>随后，我们可以在控制器中的任何业务方法中使用此实例变量。现在，假设我们从Spring容器中获取控制器对象，则可以（在相同上下文中）配置一个<code>LocalStatelessSessionProxyFactoryBean</code>实例，它是EJB代理对象。我们配置代理并设置<code>myComponent</code>带有以下配置条目的控制器的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myComponent"
        class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/myBean"/&gt;
    &lt;property name="businessInterface" value="com.mycom.MyComponent"/&gt;
&lt;/bean&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
    &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管没有强迫您使用AOP概念来欣赏结果，但仍要依靠Spring AOP框架在幕后进行大量工作。的<code>myComponent</code> bean定义为EJB创建代理，该代理实现业务方法接口。EJB本地主目录在启动时被缓存，因此只有一个JNDI查找。每次调用EJB时，代理都会调用<code>classname</code>本地EJB上的方法，并在EJB上调用相应的业务方法。</p>
</div>
<div class="paragraph">
<p>的<code>myController</code> Bean定义设置<code>myComponent</code>控制器类对EJB代理的属性。</p>
</div>
<div class="paragraph">
<p>另外（最好是在有许多此类代理定义的情况下），请考虑使用<code><jee:local-slsb></code> Spring的“ jee”名称空间中的配置元素。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:local-slsb id="myComponent" jndi-name="ejb/myBean"
        business-interface="com.mycom.MyComponent"/&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
    &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种EJB访问机制极大地简化了应用程序代码。Web层代码（或其他EJB客户端代码）与EJB的使用无关。要用POJO或模拟对象或其他测试存根替换该EJB引用，我们可以更改<code>myComponent</code> bean定义而无需更改Java代码行。此外，作为应用程序的一部分，我们不必编写任何一行JNDI查找或其他EJB管道代码。</p>
</div>
<div class="paragraph">
<p>实际应用中的基准和经验表明，这种方法的性能开销（涉及目标EJB的反射调用）是最小的，并且在常规使用中是无法检测到的。请记住，我们无论如何都不希望对EJB进行细粒度的调用，因为与应用程序服务器中的EJB基础结构相关联的成本很高。</p>
</div>
<div class="paragraph">
<p>关于JNDI查找有一个警告。在bean容器中，此类通常最好用作单例（没有理由使其成为原型）。但是，如果该bean容器预先实例化了单例（各种XML也是如此） <code>ApplicationContext</code>变体），如果在EJB容器加载目标EJB之前加载了bean容器，则可能会有问题。这是因为JNDI查找是在<code>init()</code>此类的方法，然后将其缓存，但是尚未在目标位置绑定EJB。解决方案是不预先实例化该工厂对象，而是让它在首次使用时创建。在XML容器中，您可以使用<code>lazy-init</code>属性。</p>
</div>
<div class="paragraph">
<p>尽管大多数Spring用户都不感兴趣，但是那些使用EJB进行程序化AOP的人可能希望了解一下<code>LocalSlsbInvokerInterceptor</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-remote"><a class="anchor" href="#ejb-access-remote"></a> 2.1.3。访问远程SLSB</h4>
<div class="paragraph">
<p>访问远程EJB与访问本地EJB基本相同，除了<code>SimpleRemoteStatelessSessionProxyFactoryBean</code>要么<code><jee:remote-slsb></code>使用配置元素。当然，无论是否使用Spring，远程调用语义都适用：调用另一台计算机上另一台VM中的对象上的方法时，有时在使用情况和故障处理方面必须区别对待。</p>
</div>
<div class="paragraph">
<p>与非Spring方法相比，Spring的EJB客户端支持增加了另一优势。通常，在本地或远程调用EJB之间轻松地来回切换EJB客户端代码是有问题的。这是因为远程接口方法必须声明它们抛出<code>RemoteException</code> ，并且客户端代码必须处理此问题，而本地接口方法则不需要。通常需要修改为需要移动到远程EJB的本地EJB编写的客户端代码，以增加对远程异常的处理，为需要移动到本地EJB的远程EJB编写的客户端代码可以保持不变，但可以执行以下操作：许多不必要的远程异常处理，或进行修改以删除该代码。使用Spring远程EJB代理，您可以声明不抛出任何异常<code>RemoteException</code>在您的业务方法接口和实现EJB代码中，有一个相同的远程接口（除了它确实抛出<code>RemoteException</code> ），并依靠代理将两个接口视为相同来动态对待。也就是说，客户端代码不必处理已检查的<code>RemoteException</code>类。任何实际<code>RemoteException</code>在EJB调用期间抛出的异常将重新抛出为非选中状态<code>RemoteAccessException</code>类，它是<code>RuntimeException</code> 。然后，您可以在本地EJB或远程EJB（甚至纯Java对象）实现之间随意切换目标服务，而无需了解或关心客户端代码。当然，这是可选的：没有什么可以阻止您声明<code>RemoteException</code>在您的业务界面中。</p>
</div>
</div>
<div class="sect3">
<h4 id="ejb-access-ejb2-ejb3"><a class="anchor" href="#ejb-access-ejb2-ejb3"></a> 2.1.4。访问EJB 2.x SLSB与EJB 3 SLSB</h4>
<div class="paragraph">
<p>通过Spring访问EJB 2.x会话Bean和EJB 3会话Bean在很大程度上是透明的。Spring的EJB访问器，包括<code><jee:local-slsb></code>和<code><jee:remote-slsb></code>工具，在运行时透明地适应实际组件。它们处理Home接口（如果找到）（EJB 2.x样式），或者在没有可用Home接口（EJB 3样式）的情况下执行直接组件调用。</p>
</div>
<div class="paragraph">
<p>注意：对于EJB 3会话Bean，您可以有效地使用<code>JndiObjectFactoryBean</code> / <code><jee:jndi-lookup></code>同样，由于公开了完全可用的组件引用，以便在那里进行普通的JNDI查找。明确定义<code><jee:local-slsb></code>要么<code><jee:remote-slsb></code>查找提供一致且更明确的EJB访问配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jms"><a class="anchor" href="#jms"></a> 3。JMS（Java消息服务）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring提供了一个JMS集成框架，该框架简化了JMS API的使用，就像Spring对JDBC API的集成一样。</p>
</div>
<div class="paragraph">
<p>JMS可以大致分为两个功能区域，即消息的产生和使用。的<code>JmsTemplate</code>类用于消息生成和同步消息接收。对于类似于Java EE的消息驱动bean样式的异步接收，Spring提供了许多消息侦听器容器，可用于创建消息驱动POJO（MDP）。Spring还提供了一种声明式方法来创建消息侦听器。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.jms.core</code>软件包提供了使用JMS的核心功能。它包含JMS模板类，该类通过处理资源的创建和释放来简化JMS的使用，就像<code>JdbcTemplate</code>为JDBC做。 Spring模板类共有的设计原则是提供辅助方法来执行常见的操作，并且对于更复杂的用法，将处理任务的本质委托给用户实现的回调接口。JMS模板遵循相同的设计。这些类提供了各种便利的方法，用于发送消息，同步使用消息以及向用户公开JMS会话和消息生成器。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.jms.support</code>套餐提供<code>JMSException</code>翻译功能。翻译会转换选中的<code>JMSException</code>层次结构到未检查异常的镜像层次结构。如果选中了任何提供程序特定的子类<code>javax.jms.JMSException</code>存在，此异常包装在未检查的<code>UncategorizedJmsException</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.jms.support.converter</code>包提供了<code>MessageConverter</code> Java对象和JMS消息之间进行转换的抽象。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.jms.support.destination</code>软件包提供了用于管理JMS目的地的各种策略，例如为JNDI中存储的目的地提供服务定位器。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.jms.annotation</code>软件包提供了必要的基础结构，以通过使用来支持注释驱动的侦听器端点<code>@JmsListener</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.jms.config</code>软件包提供了解析器的实现<code>jms</code>命名空间以及java config支持，用于配置侦听器容器和创建侦听器端点。</p>
</div>
<div class="paragraph">
<p>最后， <code>org.springframework.jms.connection</code>软件包提供了<code>ConnectionFactory</code>适用于独立应用程序。它还包含Spring的实现<code>PlatformTransactionManager</code>对于JMS（狡猾的名字<code>JmsTransactionManager</code> ）。这允许将JMS作为事务资源无缝集成到Spring的事务管理机制中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 5开始，Spring的JMS软件包完全支持JMS 2.0，并要求在运行时提供JMS 2.0 API。我们建议使用JMS 2.0兼容的提供程序。</p>
</div>
<div class="paragraph">
<p>如果您碰巧在系统中使用较旧的消息代理，则可以尝试为现有的代理生成升级到JMS 2.0兼容驱动程序。另外，您也可以尝试在基于JMS 1.1的驱动程序上运行，只需将JMS 2.0 API jar放在类路径上，而仅对驱动程序使用兼容JMS 1.1的API。Spring的JMS支持默认情况下遵守JMS 1.1约定，因此通过相应的配置，它确实支持这种情况。但是，请仅在过渡方案中考虑这一点。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="jms-using"><a class="anchor" href="#jms-using"></a> 3.1。使用Spring JMS</h3>
<div class="paragraph">
<p>本节描述如何使用Spring的JMS组件。</p>
</div>
<div class="sect3">
<h4 id="jms-jmstemplate"><a class="anchor" href="#jms-jmstemplate"></a> 3.1.1。使用<code>JmsTemplate</code></h4>
<div class="paragraph">
<p>的<code>JmsTemplate</code> class是JMS核心软件包中的中心类。由于它在发送或同步接收消息时处理资源的创建和释放，因此它简化了JMS的使用。</p>
</div>
<div class="paragraph">
<p>使用的代码<code>JmsTemplate</code>只需要实现回调接口即可为它们提供明确定义的高级合同。的<code>MessageCreator</code>回调接口在给定一个<code>Session</code>由调用代码提供<code>JmsTemplate</code> 。为了允许更复杂地使用JMS API， <code>SessionCallback</code>提供JMS会话，以及<code>ProducerCallback</code>暴露一个<code>Session</code>和<code>MessageProducer</code>对。</p>
</div>
<div class="paragraph">
<p>JMS API公开了两种类型的发送方法，一种采用交付模式，优先级和生存时间作为服务质量（QOS）参数，另一种不采用QOS参数并使用默认值。以来<code>JmsTemplate</code>有许多发送方法，设置QOS参数已作为bean属性公开，以避免重复发送方法。同样，同步接收呼叫的超时值是通过使用<code>setReceiveTimeout</code>属性。</p>
</div>
<div class="paragraph">
<p>一些JMS提供程序允许通过配置以下命令来管理性地设置默认QOS值： <code>ConnectionFactory</code> 。其结果是调用<code>MessageProducer</code>实例的<code>send</code>方法 （ <code>send(Destination destination, Message message)</code> ）使用与JMS规范中指定的值不同的QOS默认值。为了提供一致的QOS值管理， <code>JmsTemplate</code>因此，必须通过设置boolean属性来专门启用其使用自己的QOS值<code>isExplicitQosEnabled</code>至<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>为了方便， <code>JmsTemplate</code>还公开了基本的请求-答复操作，该操作允许发送消息并等待作为该操作一部分而创建的临时队列的答复。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">的实例<code>JmsTemplate</code>类一旦配置便是线程安全的。这很重要，因为这意味着您可以配置一个实例<code>JmsTemplate</code>然后安全地将此共享引用注入多个协作者。要明确的是， <code>JmsTemplate</code>是有状态的，因为它保持了对<code>ConnectionFactory</code> ，但此状态不是会话状态。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从Spring Framework 4.1开始， <code>JmsMessagingTemplate</code>建立在<code>JmsTemplate</code>并提供了与消息传递抽象的集成-即， <code>org.springframework.messaging.Message</code> 。这使您可以创建以通用方式发送的消息。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-connections"><a class="anchor" href="#jms-connections"></a> 3.1.2。连接数</h4>
<div class="paragraph">
<p>的<code>JmsTemplate</code>需要参考<code>ConnectionFactory</code> 。的<code>ConnectionFactory</code>是JMS规范的一部分，并且是使用JMS的切入点。客户端应用程序将其用作工厂以创建与JMS提供程序的连接，并封装各种配置参数，其中许多是特定于供应商的，例如SSL配置选项。</p>
</div>
<div class="paragraph">
<p>当在EJB中使用JMS时，供应商提供JMS接口的实现，以便它们可以参与声明式事务管理并执行连接和会话的池化。为了使用此实现，Java EE容器通常要求您将JMS连接工厂声明为<code>resource-ref</code> EJB或servlet部署描述符中。为了确保将这些功能与<code>JmsTemplate</code>在EJB中，客户端应用程序应确保它引用了EJB的托管实现。 <code>ConnectionFactory</code> 。</p>
</div>
<div class="sect4">
<h5 id="jms-caching-resources"><a class="anchor" href="#jms-caching-resources"></a>缓存消息资源</h5>
<div class="paragraph">
<p>标准API涉及创建许多中间对象。要发送消息，请执行以下“ API”遍历：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send</pre>
</div>
</div>
<div class="paragraph">
<p>在。。之间<code>ConnectionFactory</code>和<code>Send</code>操作中，创建并销毁了三个中间对象。为了优化资源使用并提高性能，Spring提供了两种实现<code>ConnectionFactory</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="jms-connection-factory"><a class="anchor" href="#jms-connection-factory"></a>使用<code>SingleConnectionFactory</code></h5>
<div class="paragraph">
<p>Spring提供了一个实现<code>ConnectionFactory</code>接口， <code>SingleConnectionFactory</code> ，返回相同<code>Connection</code>所有<code>createConnection()</code>呼叫并忽略对的呼叫<code>close()</code> 。这对于测试和独立环境非常有用，因此同一连接可用于多个<code>JmsTemplate</code>可能涵盖任何数量的交易的呼叫。<code>SingleConnectionFactory</code>参考标准<code>ConnectionFactory</code>通常来自JNDI。</p>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-connection-factory-caching"><a class="anchor" href="#jdbc-connection-factory-caching"></a>使用<code>CachingConnectionFactory</code></h5>
<div class="paragraph">
<p>的<code>CachingConnectionFactory</code>扩展功能<code>SingleConnectionFactory</code>并添加了缓存<code>Session</code> ， <code>MessageProducer</code>和<code>MessageConsumer</code>实例。初始缓存大小设置为<code>1</code> 。您可以使用<code>sessionCacheSize</code>属性以增加缓存的会话数。请注意，由于根据会话的确认模式缓存会话，因此实际缓存的会话数大于该数量，因此在以下情况下最多可以有四个缓存的会话实例（每个确认模式一个） <code>sessionCacheSize</code>设置为1。 <code>MessageProducer</code>和<code>MessageConsumer</code>实例在其自己的会话中缓存，并且在缓存时还要考虑生产者和使用者的独特属性。MessageProducers将根据其目的地进行缓存。基于由目标，选择器，noLocal传递标志和持久订阅名称（如果创建持久使用者）组成的键来缓存MessageConsumers。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-destinations"><a class="anchor" href="#jms-destinations"></a> 3.1.3。目的地管理</h4>
<div class="paragraph">
<p>目的地，如<code>ConnectionFactory</code>实例是可以在JNDI中存储和检索的JMS管理对象。在配置Spring应用程序上下文时，可以使用JNDI <code>JndiObjectFactoryBean</code>工厂级或<code><jee:jndi-lookup></code>对对象对JMS目标的引用执行依赖项注入。但是，如果应用程序中有大量目标，或者JMS提供程序具有独特的高级目标管理功能，则此策略通常很麻烦。这种高级目标管理的示例包括动态目标的创建或对目标的分层名称空间的支持。的<code>JmsTemplate</code>将目标名称的解析委托给实现该目标名称的JMS目标对象<code>DestinationResolver</code>接口。 <code>DynamicDestinationResolver</code>是由...使用的默认实现<code>JmsTemplate</code>并适应动态目的地。一种<code>JndiDestinationResolver</code>还提供用作JNDI中包含的目的地的服务定位器，并且可以选择回退到JNDI中包含的行为。 <code>DynamicDestinationResolver</code> 。</p>
</div>
<div class="paragraph">
<p>通常，仅在运行时才知道JMS应用程序中使用的目的地，因此，在部署应用程序时无法通过管理方式创建。这通常是因为在交互的系统组件之间存在共享的应用程序逻辑，这些组件根据众所周知的命名约定在运行时创建目标。即使创建动态目标不属于JMS规范的一部分，但大多数供应商都提供了此功能。动态目标是使用用户定义的名称创建的，该名称将它们与临时目标区分开来，并且通常未在JNDI中注册。各个提供者之间用于创建动态目的地的API有所不同，因为与目的地关联的属性是特定于供应商的。但是，供应商有时会做出一个简单的实现选择，就是忽略JMS规范中的警告并使用该方法。 <code>TopicSession</code><code>createTopic(String topicName)</code>或者<code>QueueSession</code><code>createQueue(String queueName)</code>使用默认目标属性创建新目标的方法。根据供应商的实现， <code>DynamicDestinationResolver</code>然后还可以创建一个物理目标，而不是仅解决一个目标。</p>
</div>
<div class="paragraph">
<p>布尔属性<code>pubSubDomain</code>用于配置<code>JmsTemplate</code>了解正在使用哪个JMS域。默认情况下，此属性的值为false，表示点对点域， <code>Queues</code> ，将被使用。此属性（由<code>JmsTemplate</code> ）通过以下方式的实施来确定动态目标解析的行为<code>DestinationResolver</code>接口。</p>
</div>
<div class="paragraph">
<p>您还可以配置<code>JmsTemplate</code>通过属性使用默认目的地<code>defaultDestination</code> 。默认目标是带有不引用特定目标的发送和接收操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-mdp"><a class="anchor" href="#jms-mdp"></a> 3.1.4。消息侦听器容器</h4>
<div class="paragraph">
<p>在EJB世界中，JMS消息最常见的用途之一就是驱动消息驱动的bean（MDB）。Spring提供了一种解决方案，以不将用户绑定到EJB容器的方式创建消息驱动的POJO（MDP）。（请参阅<a href="#jms-receiving-async">异步接收：消息驱动的POJO，</a>以详细了解Spring的MDP支持。）从Spring Framework 4.1开始，可以使用以下方法注释端点方法<code>@JmsListener</code> —有关更多详细信息，请参见<a href="#jms-annotated">注释驱动的侦听器端点</a> 。</p>
</div>
<div class="paragraph">
<p>消息侦听器容器用于从JMS消息队列接收消息并驱动<code>MessageListener</code>注入其中。侦听器容器负责消息接收的所有线程，并分派到侦听器中进行处理。消息侦听器容器是MDP与消息传递提供程序之间的中介，并负责注册接收消息，参与事务，资源获取和释放，异常转换等。这使您可以编写与接收消息（并可能响应消息）相关的（可能很复杂的）业务逻辑，并将样板JMS基础结构问题委托给框架。</p>
</div>
<div class="paragraph">
<p>Spring附带了两个标准的JMS消息侦听器容器，每个容器都有其专门的功能集。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jms-mdp-simple"><code>SimpleMessageListenerContainer</code></a></p>
</li>
<li>
<p><a href="#jms-mdp-default"><code>DefaultMessageListenerContainer</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="jms-mdp-simple"><a class="anchor" href="#jms-mdp-simple"></a>使用<code>SimpleMessageListenerContainer</code></h5>
<div class="paragraph">
<p>此消息侦听器容器是两种标准样式中的简单容器。它在启动时创建固定数量的JMS会话和使用者，并使用标准JMS注册侦听器<code>MessageConsumer.setMessageListener()</code>方法，并将其留给JMS提供者来执行侦听器回调。此变体不允许动态适应运行时需求或参与外部管理的事务。在兼容性方面，它非常接近独立JMS规范的精神，但通常与Java EE的JMS限制不兼容。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">而<code>SimpleMessageListenerContainer</code>不允许参与外部管理的事务，它确实支持本机JMS事务。要启用此功能，您可以切换<code>sessionTransacted</code>标记为<code>true</code>或者，在XML名称空间中，设置<code>acknowledge</code>归因于<code>transacted</code> 。然后，从您的侦听器抛出的异常会导致回滚，并重新传递消息。或者，考虑使用<code>CLIENT_ACKNOWLEDGE</code>模式，在出现异常的情况下也可以重新交付，但不使用交易<code>Session</code>实例，因此不包括任何其他实例<code>Session</code>交易协议中的操作（例如发送响应消息）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">默认值<code>AUTO_ACKNOWLEDGE</code>模式不能提供适当的可靠性保证。当侦听器执行失败时（由于提供者在侦听器调用后会自动确认每条消息，并且没有异常要传播到提供者），或者在侦听器容器关闭时，消息可能会丢失（可以通过设置<code>acceptMessagesWhileStopping</code>旗）。确保出于可靠性需求（例如，为了可靠的队列处理和持久的主题订阅）使用事务处理的会话。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="jms-mdp-default"><a class="anchor" href="#jms-mdp-default"></a>使用<code>DefaultMessageListenerContainer</code></h5>
<div class="paragraph">
<p>大多数情况下使用此消息侦听器容器。与之相反<code>SimpleMessageListenerContainer</code> ，此容器变体允许动态适应运行时需求，并且能够参与外部管理的事务。当每个接收到的消息配置为<code>JtaTransactionManager</code> 。结果，处理可以利用XA事务语义。该侦听器容器在JMS提供程序的低要求，高级功能（例如参与外部管理的事务）以及与Java EE环境的兼容性之间取得了良好的平衡。</p>
</div>
<div class="paragraph">
<p>您可以自定义容器的缓存级别。请注意，当未启用缓存时，将为每个消息接收创建一个新的连接和一个新的会话。将其与具有高负载的非持久订阅结合使用可能会导致消息丢失。在这种情况下，请确保使用适当的缓存级别。</p>
</div>
<div class="paragraph">
<p>当代理关闭时，此容器还具有可恢复的功能。默认情况下， <code>BackOff</code>实施每五秒钟重试一次。您可以指定一个自定义<code>BackOff</code>实现更细粒度的恢复选项。参见api-spring-framework / util / backoff / ExponentialBackOff.html [ <code>ExponentialBackOff</code> ]为例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">就像它的兄弟姐妹（ <a href="#jms-mdp-simple"><code>SimpleMessageListenerContainer</code></a> ）， <code>DefaultMessageListenerContainer</code>支持本机JMS事务，并允许自定义确认模式。如果适合您的方案，则强烈建议在外部管理的事务上使用此方法，也就是说，如果JVM死亡，您可以偶尔接收重复的消息。业务逻辑中的自定义重复消息检测步骤可以解决这种情况，例如，以业务实体存在检查或协议表检查的形式。任何此类安排都比其他安排更为有效：通过XA交易包装整个流程（通过配置您的<code>DefaultMessageListenerContainer</code>带着<code>JtaTransactionManager</code> ），以涵盖JMS消息的接收以及消息侦听器中业务逻辑的执行（包括数据库操作等）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">默认值<code>AUTO_ACKNOWLEDGE</code>模式不能提供适当的可靠性保证。当侦听器执行失败时（由于提供者在侦听器调用后会自动确认每条消息，并且没有异常要传播到提供者），或者在侦听器容器关闭时，消息可能会丢失（可以通过设置<code>acceptMessagesWhileStopping</code>旗）。确保出于可靠性需求（例如，为了可靠的队列处理和持久的主题订阅）使用事务处理的会话。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-tx"><a class="anchor" href="#jms-tx"></a> 3.1.5。交易管理</h4>
<div class="paragraph">
<p>春天提供了<code>JmsTransactionManager</code>管理单个JMS的事务<code>ConnectionFactory</code> 。如<a href="data-access.html#transaction">“数据访问”一章的“事务管理”部分</a>所述，这使JMS应用程序能够利用Spring的托管事务功能。的<code>JmsTransactionManager</code>执行本地资源事务，从指定的绑定JMS连接/会话对<code>ConnectionFactory</code>到线程。
<code>JmsTemplate</code>自动检测此类交易资源并对其进行相应操作。</p>
</div>
<div class="paragraph">
<p>在Java EE环境中， <code>ConnectionFactory</code>池连接和会话实例，因此这些资源可在事务之间有效地重用。在独立环境中，使用Spring的<code>SingleConnectionFactory</code>导致共享JMS <code>Connection</code> ，每个交易都有自己独立的<code>Session</code> 。或者，考虑使用提供程序专用的池适配器，例如ActiveMQ <code>PooledConnectionFactory</code>类。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>JmsTemplate</code>与<code>JtaTransactionManager</code>和具有XA功能的JMS <code>ConnectionFactory</code>执行分布式交易。请注意，这需要使用JTA事务管理器以及正确的XA配置的ConnectionFactory。（检查您的Java EE服务器或JMS提供程序的文档。）</p>
</div>
<div class="paragraph">
<p>使用JMS API创建托管代码时，在托管和非托管事务环境中重用代码可能会造成混淆。 <code>Session</code>从一个<code>Connection</code> 。这是因为JMS API只有一种工厂方法可以创建一个<code>Session</code> ，并且需要交易和确认模式的值。在托管环境中，设置这些值是环境的事务基础结构的责任，因此，供应商对JMS Connection的包装将忽略这些值。当您使用<code>JmsTemplate</code>在非托管环境中，您可以通过使用属性来指定这些值<code>sessionTransacted</code>和<code>sessionAcknowledgeMode</code> 。当您使用<code>PlatformTransactionManager</code>与<code>JmsTemplate</code> ，模板总是被赋予一个事务性的JMS <code>Session</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-sending"><a class="anchor" href="#jms-sending"></a> 3.2。发送信息</h3>
<div class="paragraph">
<p>的<code>JmsTemplate</code>包含许多发送消息的便捷方法。发送方法通过使用<code>javax.jms.Destination</code>对象，其他对象使用<code>String</code>在JNDI查找中。的<code>send</code>不带目标参数的方法使用默认目标。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>MessageCreator</code>回调以根据提供的内容创建短信<code>Session</code>宾语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;

public class JmsQueueSender {

    private JmsTemplate jmsTemplate;
    private Queue queue;

    public void setConnectionFactory(ConnectionFactory cf) {
        this.jmsTemplate = new JmsTemplate(cf);
    }

    public void setQueue(Queue queue) {
        this.queue = queue;
    }

    public void simpleSend() {
        this.jmsTemplate.send(this.queue, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage("hello queue world");
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>JmsTemplate</code>通过将引用传递给<code>ConnectionFactory</code> 。作为替代，零参数构造函数和<code>connectionFactory</code>提供并可以用于以JavaBean样式构造实例（使用<code>BeanFactory</code>或纯Java代码）。或者，考虑从Spring的<code>JmsGatewaySupport</code>便捷基类，它为JMS配置提供了预构建的bean属性。</p>
</div>
<div class="paragraph">
<p>的<code>send(String destinationName, MessageCreator creator)</code>方法使您可以使用目标的字符串名称发送消息。如果这些名称已在JNDI中注册，则应设置<code>destinationResolver</code>模板的实例属性<code>JndiDestinationResolver</code> 。</p>
</div>
<div class="paragraph">
<p>如果您创建了<code>JmsTemplate</code>并指定了默认目标<code>send(MessageCreator c)</code>向该目的地发送消息。</p>
</div>
<div class="sect3">
<h4 id="jms-msg-conversion"><a class="anchor" href="#jms-msg-conversion"></a> 3.2.1。使用消息转换器</h4>
<div class="paragraph">
<p>为了方便域模型对象的发送， <code>JmsTemplate</code>有各种发送方法，这些方法将Java对象作为消息数据内容的参数。重载方法<code>convertAndSend()</code>和<code>receiveAndConvert()</code>方法中<code>JmsTemplate</code>将转换过程委托给的实例<code>MessageConverter</code>接口。该接口定义了一个简单的协定，可以在Java对象和JMS消息之间进行转换。默认实现（ <code>SimpleMessageConverter</code> ）支持之间的转换<code>String</code>和<code>TextMessage</code> ， <code>byte[]</code>和<code>BytesMesssage</code>和<code>java.util.Map</code>和<code>MapMessage</code> 。通过使用转换器，您和您的应用程序代码可以专注于通过JMS发送或接收的业务对象，而不必担心如何将其表示为JMS消息。</p>
</div>
<div class="paragraph">
<p>沙箱目前包含一个<code>MapMessageConverter</code> ，它使用反射在JavaBean和<code>MapMessage</code> 。您可能会自己实现的其他流行的实现选择是使用现有XML编组程序包（例如JAXB或XStream）创建转换器的转换器。 <code>TextMessage</code>代表对象。</p>
</div>
<div class="paragraph">
<p>为了适应消息属性，标头和正文的设置，这些设置通常不能封装在转换器类中，因此， <code>MessagePostProcessor</code>介面可让您在邮件转换后但发送之前访问它。以下示例显示了如何在消息头之后修改消息头和属性。 <code>java.util.Map</code>转换为消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public void sendWithConversion() {
    Map map = new HashMap();
    map.put("Name", "Mark");
    map.put("Age", new Integer(47));
    jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
        public Message postProcessMessage(Message message) throws JMSException {
            message.setIntProperty("AccountID", 1234);
            message.setJMSCorrelationID("123-00001");
            return message;
        }
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将导致以下形式的消息：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>MapMessage={
    Header={
        ... standard headers ...
        CorrelationID={123-00001}
    }
    Properties={
        AccountID={Integer:1234}
    }
    Fields={
        Name={String:Mark}
        Age={Integer:47}
    }
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-callbacks"><a class="anchor" href="#jms-callbacks"></a> 3.2.2。使用<code>SessionCallback</code>和<code>ProducerCallback</code></h4>
<div class="paragraph">
<p>尽管发送操作涵盖了许多常见的使用场景，但是您有时可能希望在JMS上执行多项操作<code>Session</code>要么<code>MessageProducer</code> 。的<code>SessionCallback</code>和<code>ProducerCallback</code>公开JMS <code>Session</code>和<code>Session</code> / <code>MessageProducer</code>对。的<code>execute()</code>方法<code>JmsTemplate</code>执行这些回调方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-receiving"><a class="anchor" href="#jms-receiving"></a> 3.3。接收讯息</h3>
<div class="paragraph">
<p>这描述了如何在Spring中使用JMS接收消息。</p>
</div>
<div class="sect3">
<h4 id="jms-receiving-sync"><a class="anchor" href="#jms-receiving-sync"></a> 3.3.1。同步接收</h4>
<div class="paragraph">
<p>虽然JMS通常与异步处理相关联，但是您可以同步使用消息。超载<code>receive(..)</code>方法提供此功能。在同步接收期间，调用线程将阻塞，直到消息可用为止。这可能是危险的操作，因为调用线程可能会无限期地被阻塞。的<code>receiveTimeout</code>属性指定接收者在放弃等待消息之前应等待的时间。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async"><a class="anchor" href="#jms-receiving-async"></a> 3.3.2。异步接收：消息驱动的POJO</h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过使用，Spring还支持带注释的侦听器端点<code>@JmsListener</code>注释并提供开放的基础结构来以编程方式注册端点。到目前为止，这是设置异步接收器的最便捷方法。有关更多详细信息，请参见<a href="#jms-annotated-support">启用侦听器端点注释</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>消息驱动POJO（MDP）以类似于EJB世界中的消息驱动Bean（MDB）的方式充当JMS消息的接收者。一个限制（但请参见<a href="#jms-receiving-async-message-listener-adapter">使用<code>MessageListenerAdapter</code></a> ）在MDP上是它必须实施<code>javax.jms.MessageListener</code>接口。请注意，如果您的POJO在多个线程上接收消息，则重要的是要确保您的实现是线程安全的。</p>
</div>
<div class="paragraph">
<p>以下示例显示了MDP的简单实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

    public void onMessage(Message message) {
        if (message instanceof TextMessage) {
            try {
                System.out.println(((TextMessage) message).getText());
            }
            catch (JMSException ex) {
                throw new RuntimeException(ex);
            }
        }
        else {
            throw new IllegalArgumentException("Message must be of type TextMessage");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦实施了<code>MessageListener</code> ，是时候创建消息侦听器容器了。</p>
</div>
<div class="paragraph">
<p>以下示例说明了如何定义和配置Spring附带的消息侦听器容器（在这种情况下， <code>DefaultMessageListenerContainer</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- this is the Message Driven POJO (MDP) --&gt;
&lt;bean id="messageListener" class="jmsexample.ExampleListener"/&gt;

&lt;!-- and this is the message listener container --&gt;
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关每个实现所支持的功能的完整说明，请参见各种消息侦听器容器的Spring javadoc（所有这些都实现了<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/listener/MessageListenerContainer.html">MessageListenerContainer</a> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async-session-aware-message-listener"><a class="anchor" href="#jms-receiving-async-session-aware-message-listener"></a> 3.3.3。使用<code>SessionAwareMessageListener</code>接口</h4>
<div class="paragraph">
<p>的<code>SessionAwareMessageListener</code>接口是特定于Spring的接口，提供与JMS类似的协定<code>MessageListener</code>接口，但还使消息处理方法可以访问JMS <code>Session</code>从中<code>Message</code>收到了。以下清单显示了<code>SessionAwareMessageListener</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

    void onMessage(Message message, Session session) throws JMSException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以选择让您的MDP实现此接口（优先于标准JMS <code>MessageListener</code>界面）（如果您希望MDP能够响应任何收到的消息）（通过使用<code>Session</code>在提供<code>onMessage(Message, Session)</code>方法）。Spring附带的所有消息侦听器容器实现都支持实现以下任一功能的MDP： <code>MessageListener</code>要么<code>SessionAwareMessageListener</code>接口。实现<code>SessionAwareMessageListener</code>需要注意的是，它们然后通过接口绑定到Spring。是否使用它的选择完全由您作为应用程序开发人员或架构师来决定。</p>
</div>
<div class="paragraph">
<p>请注意<code>onMessage(..)</code>的方法<code>SessionAwareMessageListener</code>界面抛出<code>JMSException</code> 。与标准JMS相反<code>MessageListener</code>界面，当使用<code>SessionAwareMessageListener</code>接口，客户端代码负责处理任何引发的异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-receiving-async-message-listener-adapter"><a class="anchor" href="#jms-receiving-async-message-listener-adapter"></a> 3.3.4。使用<code>MessageListenerAdapter</code></h4>
<div class="paragraph">
<p>的<code>MessageListenerAdapter</code>类是Spring异步消息传递支持中的最后一个组件。简而言之，它使您几乎可以将任何类公开为MDP（尽管存在一些约束）。</p>
</div>
<div class="paragraph">
<p>考虑以下接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface MessageDelegate {

    void handleMessage(String message);

    void handleMessage(Map message);

    void handleMessage(byte[] message);

    void handleMessage(Serializable message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，尽管接口没有扩展<code>MessageListener</code>也不是<code>SessionAwareMessageListener</code>界面，您仍然可以通过以下方式将其用作MDP： <code>MessageListenerAdapter</code>类。还请注意，如何根据各种消息的内容对各种消息处理方法进行强类型化<code>Message</code>他们可以接收和处理的类型。</p>
</div>
<div class="paragraph">
<p>现在考虑以下的实现<code>MessageDelegate</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DefaultMessageDelegate implements MessageDelegate {
    // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特别要注意的是， <code>MessageDelegate</code>接口（ <code>DefaultMessageDelegate</code>类）完全没有JMS依赖项。这确实是一个POJO，我们可以通过以下配置将其制作为MDP：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- this is the Message Driven POJO (MDP) --&gt;
&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;!-- and this is the message listener container... --&gt;
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例显示了另一个只能处理接收JMS的MDP <code>TextMessage</code>消息。注意实际上如何调用消息处理方法<code>receive</code> （邮件处理方法的名称<code>MessageListenerAdapter</code>默认为<code>handleMessage</code> ），但它是可配置的（如本节后面所述）。还要注意<code>receive(..)</code>强类型化方法以仅接收和响应JMS <code>TextMessage</code>消息。以下清单显示了<code>TextMessageDelegate</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface TextMessageDelegate {

    void receive(TextMessage message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了一个实现<code>TextMessageDelegate</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DefaultTextMessageDelegate implements TextMessageDelegate {
    // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>话务员的配置<code>MessageListenerAdapter</code>然后将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultTextMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
    &lt;property name="defaultListenerMethod" value="receive"/&gt;
    &lt;!-- we don't want automatic message context extraction --&gt;
    &lt;property name="messageConverter"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果<code>messageListener</code>收到一个JMS <code>Message</code>类型不是<code>TextMessage</code> ， <code>IllegalStateException</code>被扔（随后被吞下）。另一个功能<code>MessageListenerAdapter</code>类是自动发送回响应的能力<code>Message</code>如果处理程序方法返回非空值。考虑以下接口和类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ResponsiveTextMessageDelegate {

    // notice the return type...
    String receive(TextMessage message);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
    // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>DefaultResponsiveTextMessageDelegate</code>结合<code>MessageListenerAdapter</code> ，从执行中返回的任何非null值<code>'receive(..)'</code>方法（在默认配置中）转换为<code>TextMessage</code> 。所结果的<code>TextMessage</code>然后发送到<code>Destination</code> （如果存在）在JMS中定义<code>Reply-To</code>原物的财产<code>Message</code>或默认<code>Destination</code>设置在<code>MessageListenerAdapter</code> （如果已配置）。如果不<code>Destination</code>被发现， <code>InvalidDestinationException</code>引发（请注意，该异常不会被吞没，并且会在调用堆栈中传播）。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-tx-participation"><a class="anchor" href="#jms-tx-participation"></a> 3.3.5。处理事务中的消息</h4>
<div class="paragraph">
<p>在事务中调用消息侦听器仅需要重新配置侦听器容器。</p>
</div>
<div class="paragraph">
<p>您可以通过以下方式激活本地资源交易<code>sessionTransacted</code>侦听器容器定义上的标志。然后，每个消息侦听器调用都在活动的JMS事务内运行，并且在侦听器执行失败的情况下回退消息接收。发送响应消息（通过<code>SessionAwareMessageListener</code> ）是同一本地事务的一部分，但任何其他资源操作（例如数据库访问）都是独立运行的。这通常需要在侦听器实现中进行重复消息检测，以解决数据库处理已提交但消息处理未能提交的情况。</p>
</div>
<div class="paragraph">
<p>考虑以下bean定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    &lt;property name="sessionTransacted" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要参与外部管理的交易，您需要配置一个事务管理器并使用支持外部管理的交易的侦听器容器（通常， <code>DefaultMessageListenerContainer</code> ）。</p>
</div>
<div class="paragraph">
<p>要为XA事务参与配置消息侦听器容器，您需要配置一个<code>JtaTransactionManager</code> （默认情况下，它委托给Java EE服务器的事务子系统）。注意底层的JMS <code>ConnectionFactory</code>需要具有XA功能，并已向您的JTA交易协调员正确注册。（检查您的Java EE服务器的JNDI资源配置。）这使消息接收和（例如）数据库访问成为同一事务的一部分（具有统一的提交语义，但以XA事务日志开销为代价）。</p>
</div>
<div class="paragraph">
<p>以下bean定义创建一个事务管理器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们需要将其添加到我们之前的容器配置中。容器负责其余的工作。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    &lt;property name="transactionManager" ref="transactionManager"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们的交易经理。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-jca-message-endpoint-manager"><a class="anchor" href="#jms-jca-message-endpoint-manager"></a> 3.4。支持JCA消息端点</h3>
<div class="paragraph">
<p>从2.5版开始，Spring还提供了对基于JCA的支持<code>MessageListener</code>容器。的<code>JmsMessageEndpointManager</code>尝试自动确定<code>ActivationSpec</code>提供者的类别名称<code>ResourceAdapter</code>班级名称。因此，通常可以提供Spring的泛型<code>JmsActivationSpecConfig</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"&gt;
    &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
    &lt;property name="activationSpecConfig"&gt;
        &lt;bean class="org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"&gt;
            &lt;property name="destinationName" value="myQueue"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="messageListener" ref="myMessageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以设置一个<code>JmsMessageEndpointManager</code>给定的<code>ActivationSpec</code>宾语。的<code>ActivationSpec</code>对象也可能来自JNDI查找（使用<code><jee:jndi-lookup></code> ）。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"&gt;
    &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
    &lt;property name="activationSpec"&gt;
        &lt;bean class="org.apache.activemq.ra.ActiveMQActivationSpec"&gt;
            &lt;property name="destination" value="myQueue"/&gt;
            &lt;property name="destinationType" value="javax.jms.Queue"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="messageListener" ref="myMessageListener"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Spring的<code>ResourceAdapterFactoryBean</code> ，您可以配置目标<code>ResourceAdapter</code>在本地，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="resourceAdapter" class="org.springframework.jca.support.ResourceAdapterFactoryBean"&gt;
    &lt;property name="resourceAdapter"&gt;
        &lt;bean class="org.apache.activemq.ra.ActiveMQResourceAdapter"&gt;
            &lt;property name="serverUrl" value="tcp://localhost:61616"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="workManager"&gt;
        &lt;bean class="org.springframework.jca.work.SimpleTaskWorkManager"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>指定的<code>WorkManager</code>也可以指向特定于环境的线程池-通常通过<code>SimpleTaskWorkManager</code>实例的<code>asyncTaskExecutor</code>属性。考虑为您的所有对象定义一个共享线程池<code>ResourceAdapter</code>实例，如果您碰巧使用多个适配器。</p>
</div>
<div class="paragraph">
<p>在某些环境（例如WebLogic 9或更高版本）中，您可以获取整个<code>ResourceAdapter</code>来自JNDI的对象（通过使用<code><jee:jndi-lookup></code> ）。然后，基于Spring的消息侦听器可以与服务器托管的消息进行交互<code>ResourceAdapter</code> ，它也使用服务器的内置<code>WorkManager</code> 。</p>
</div>
<div class="paragraph">
<p>参见javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsMessageEndpointManager.html"><code>JmsMessageEndpointManager</code></a> ， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsActivationSpecConfig.html"><code>JmsActivationSpecConfig</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jca/support/ResourceAdapterFactoryBean.html"><code>ResourceAdapterFactoryBean</code></a>更多细节。</p>
</div>
<div class="paragraph">
<p>Spring还提供了与JMS无关的通用JCA消息端点管理器： <code>org.springframework.jca.endpoint.GenericMessageEndpointManager</code> 。该组件允许使用任何消息侦听器类型（例如CCI <code>MessageListener</code> ）以及任何特定于提供商的<code>ActivationSpec</code>宾语。请参阅您的JCA提供者的文档，以了解连接器的实际功能，并参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jca/endpoint/GenericMessageEndpointManager.html"><code>GenericMessageEndpointManager</code></a>有关春季特定配置的javadoc。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">基于JCA的消息端点管理与EJB 2.1消息驱动Bean非常相似。它使用相同的基础资源提供者合同。与EJB 2.1 MDB一样，您也可以在Spring上下文中使用JCA提供程序支持的任何消息侦听器接口。但是，由于JMS是与JCA端点管理协定一起使用的最常见的端点API，因此Spring为JMS提供了显式的“便利”支持。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="jms-annotated"><a class="anchor" href="#jms-annotated"></a> 3.5。注释驱动的侦听器端点</h3>
<div class="paragraph">
<p>异步接收消息的最简单方法是使用带注释的侦听器端点基础结构。简而言之，它使您可以将托管Bean的方法公开为JMS侦听器端点。以下示例显示了如何使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyService {

    @JmsListener(destination = "myDestination")
    public void processOrder(String data) { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上例的想法是，只要<code>javax.jms.Destination</code><code>myDestination</code> ， <code>processOrder</code>相应地调用方法（在这种情况下，使用JMS消息的内容，类似于<a href="#jms-receiving-async-message-listener-adapter"><code>MessageListenerAdapter</code></a>提供）。</p>
</div>
<div class="paragraph">
<p>带注释的端点基础结构通过使用以下命令为每种带注释的方法在幕后创建一个消息侦听器容器。 <code>JmsListenerContainerFactory</code> 。此类容器未针对应用程序上下文进行注册，但可以通过使用<code>JmsListenerEndpointRegistry</code>豆。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>@JmsListener</code>是Java 8上的可重复注释，因此您可以通过添加其他附加JMS目标与同一方法关联<code>@JmsListener</code>声明。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="jms-annotated-support"><a class="anchor" href="#jms-annotated-support"></a> 3.5.1。启用侦听器端点注释</h4>
<div class="paragraph">
<p>启用对<code>@JmsListener</code>注释，您可以添加<code>@EnableJms</code>给你的一个<code>@Configuration</code>类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJms
public class AppConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setDestinationResolver(destinationResolver());
        factory.setSessionTransacted(true);
        factory.setConcurrency("3-10");
        return factory;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，基础架构会寻找一个名为<code>jmsListenerContainerFactory</code>作为工厂用来创建消息侦听器容器的源。在这种情况下（并且忽略了JMS基础结构设置），您可以调用<code>processOrder</code>核心轮询大小为三个线程，最大池大小为十个线程的方法。</p>
</div>
<div class="paragraph">
<p>您可以自定义用于每个注释的侦听器容器工厂，也可以通过实现<code>JmsListenerConfigurer</code>接口。仅当至少一个端点在没有特定容器工厂的情况下注册时，才需要使用默认值。请参阅实现的类的javadoc <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/annotation/JmsListenerConfigurer.html"><code>JmsListenerConfigurer</code></a>有关详细信息和示例。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢<a href="#jms-namespace">XML配置</a> ，则可以使用<code><jms:annotation-driven></code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jms:annotation-driven/&gt;

&lt;bean id="jmsListenerContainerFactory"
        class="org.springframework.jms.config.DefaultJmsListenerContainerFactory"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destinationResolver" ref="destinationResolver"/&gt;
    &lt;property name="sessionTransacted" value="true"/&gt;
    &lt;property name="concurrency" value="3-10"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-programmatic-registration"><a class="anchor" href="#jms-annotated-programmatic-registration"></a> 3.5.2。程序化端点注册</h4>
<div class="paragraph">
<p><code>JmsListenerEndpoint</code>提供JMS端点的模型，并负责为该模型配置容器。通过基础架构，您可以通过编程方式配置端点所检测到的端点。 <code>JmsListener</code>注解。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
        endpoint.setId("myJmsEndpoint");
        endpoint.setDestination("anotherQueue");
        endpoint.setMessageListener(message -&gt; {
            // processing
        });
        registrar.registerEndpoint(endpoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们使用了<code>SimpleJmsListenerEndpoint</code> ，它提供了实际的<code>MessageListener</code>调用。但是，您也可以构建自己的端点变体来描述自定义调用机制。</p>
</div>
<div class="paragraph">
<p>请注意，您可以跳过使用<code>@JmsListener</code>总共以编程方式仅通过以下方式注册您的端点<code>JmsListenerConfigurer</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-method-signature"><a class="anchor" href="#jms-annotated-method-signature"></a> 3.5.3。带注释的端点方法签名</h4>
<div class="paragraph">
<p>到目前为止，我们一直在注入一种简单的方法<code>String</code>在我们的端点中，但实际上它可以具有非常灵活的方法签名。在以下示例中，我们将其重写为注入<code>Order</code>具有自定义标头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyService {

    @JmsListener(destination = "myDestination")
    public void processOrder(Order order, @Header("order_type") String orderType) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在JMS侦听器端点中注入的主要元素如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>原始的<code>javax.jms.Message</code>或其任何子类（前提是它与传入的消息类型匹配）。</p>
</li>
<li>
<p>的<code>javax.jms.Session</code>用于对本机JMS API的可选访问（例如，用于发送自定义回复）。</p>
</li>
<li>
<p>的<code>org.springframework.messaging.Message</code>表示传入的JMS消息。请注意，此消息同时包含自定义标头和标准标头（由<code>JmsHeaders</code> ）。</p>
</li>
<li>
<p><code>@Header</code> -带注释的方法参数以提取特定的标头值，包括标准的JMS标头。</p>
</li>
<li>
<p>一种<code>@Headers</code>注释的参数，也必须可分配给<code>java.util.Map</code>用于访问所有标题。</p>
</li>
<li>
<p>非注释元素，不是受支持的类型之一（ <code>Message</code>要么<code>Session</code> ）被视为有效负载。您可以通过使用<code>@Payload</code> 。您还可以通过添加额外的内容来启用验证<code>@Valid</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>注入Spring的能力<code>Message</code>抽象对于受益于存储在特定于传输的消息中的所有信息而无需依赖特定于传输的API尤其有用。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@JmsListener(destination = "myDestination")
public void processOrder(Message&lt;Order&gt; order) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法参数的处理由提供<code>DefaultMessageHandlerMethodFactory</code> ，您可以进一步对其进行自定义以支持其他方法参数。您也可以在那里自定义转换和验证支持。</p>
</div>
<div class="paragraph">
<p>例如，如果我们要确保<code>Order</code>在处理之前是有效的，我们可以用<code>@Valid</code>并配置必要的验证器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());
    }

    @Bean
    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
        factory.setValidator(myValidator());
        return factory;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jms-annotated-response"><a class="anchor" href="#jms-annotated-response"></a> 3.5.4。反应管理</h4>
<div class="paragraph">
<p>现有支持<a href="#jms-receiving-async-message-listener-adapter"><code>MessageListenerAdapter</code></a>已经让您的方法具有非<code>void</code>返回类型。在这种情况下，调用结果封装在一个<code>javax.jms.Message</code> ，在指定的目的地中发送<code>JMSReplyTo</code>原始消息的标题或在侦听器上配置的默认目标中。现在，您可以使用<code>@SendTo</code>消息传递抽象的注释。</p>
</div>
<div class="paragraph">
<p>假设我们<code>processOrder</code>方法现在应该返回<code>OrderStatus</code> ，我们可以将其编写为自动发送响应，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@JmsListener(destination = "myDestination")
@SendTo("status")
public OrderStatus processOrder(Order order) {
    // order processing
    return status;
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果你有几个<code>@JmsListener</code> -带注释的方法，也可以将<code>@SendTo</code>类级别的注释，以共享默认答复目的地。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要以与传输无关的方式设置其他标头，则可以返回<code>Message</code>而是使用类似于以下内容的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@JmsListener(destination = "myDestination")
@SendTo("status")
public Message&lt;OrderStatus&gt; processOrder(Order order) {
    // order processing
    return MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要在运行时计算响应目标，则可以将响应封装在<code>JmsResponse</code>实例，该实例还提供了在运行时使用的目的地。我们可以如下重写前一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@JmsListener(destination = "myDestination")
public JmsResponse&lt;Message&lt;OrderStatus&gt;&gt; processOrder(Order order) {
    // order processing
    Message&lt;OrderStatus&gt; response = MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
    return JmsResponse.forQueue(response, "status");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果您需要为响应指定一些QoS值，例如优先级或生存时间，则可以配置<code>JmsListenerContainerFactory</code>因此，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJms
public class AppConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        QosSettings replyQosSettings = new QosSettings();
        replyQosSettings.setPriority(2);
        replyQosSettings.setTimeToLive(10000);
        factory.setReplyQosSettings(replyQosSettings);
        return factory;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jms-namespace"><a class="anchor" href="#jms-namespace"></a> 3.6。JMS命名空间支持</h3>
<div class="paragraph">
<p>Spring提供了用于简化JMS配置的XML名称空间。要使用JMS命名空间元素，您需要引用JMS模式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:jms="http://www.springframework.org/schema/jms" <i class="conum" data-value="1"></i><b>(1)</b>
        xsi:schemaLocation="
            http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>引用JMS模式。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>命名空间由三个顶级元素组成： <code><annotation-driven/></code> ， <code><listener-container/></code>和<code><jca-listener-container/></code> 。 <code><annotation-driven/></code>启用<a href="#jms-annotated">注释驱动的侦听器端点的使用</a> 。 <code><listener-container/></code>和<code><jca-listener-container/></code>定义共享的侦听器容器配置，并且可以包含<code><listener/></code>子元素。以下示例显示了两个侦听器的基本配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jms:listener-container&gt;

    &lt;jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/&gt;

    &lt;jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/&gt;

&lt;/jms:listener-container&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例等效于创建两个不同的侦听器容器Bean定义和两个不同的侦听器容器Bean定义。 <code>MessageListenerAdapter</code> bean定义，如<a href="#jms-receiving-async-message-listener-adapter">使用中</a>所示<a href="#jms-receiving-async-message-listener-adapter"><code>MessageListenerAdapter</code></a> 。除了前面示例中显示的属性外， <code>listener</code>元素可以包含几个可选的元素。下表描述了所有可用属性：</p>
</div>
<table id="jms-namespace-listener-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表3。JMS <listener>元素的</listener>属性</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">托管侦听器容器的Bean名称。如果未指定，将自动生成Bean名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination</code> （需要）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的目标名称，通过<code>DestinationResolver</code>战略。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ref</code> （需要）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理程序对象的bean名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要调用的处理程序方法的名称。如果<code>ref</code>属性指向<code>MessageListener</code>或春天<code>SessionAwareMessageListener</code> ，您可以忽略此属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>response-destination</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">向其发送响应消息的默认响应目标的名称。如果请求消息中不包含<code>JMSReplyTo</code>领域。此目标的类型由侦听器容器的<code>response-destination-type</code>属性。请注意，这仅适用于具有返回值的侦听器方法，为此，每个结果对象都将转换为响应消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>subscription</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">持久订阅的名称（如果有）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>selector</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的可选消息选择器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concurrency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要启动此侦听器的并发会话或使用者的数量。此值可以是表示最大数量的简单数字（例如， <code>5</code> ）或指示上下限的范围（例如， <code>3-5</code> ）。请注意，指定的最小值仅是一个提示，在运行时可能会被忽略。默认值为容器提供的值。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>的<code><listener-container/></code>元素还接受几个可选属性。这样可以自定义各种策略（例如， <code>taskExecutor</code>和<code>destinationResolver</code> ）以及基本的JMS设置和资源参考。通过使用这些属性，您可以定义高度自定义的侦听器容器，同时仍然受益于命名空间的便利性。</p>
</div>
<div class="paragraph">
<p>您可以将这些设置自动显示为<code>JmsListenerContainerFactory</code>通过指定<code>id</code>通过<code>factory-id</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jms:listener-container connection-factory="myConnectionFactory"
        task-executor="myTaskExecutor"
        destination-resolver="myDestinationResolver"
        transaction-manager="myTransactionManager"
        concurrency="10"&gt;

    &lt;jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/&gt;

    &lt;jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/&gt;

&lt;/jms:listener-container&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了所有可用的属性。请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/listener/AbstractMessageListenerContainer.html"><code>AbstractMessageListenerContainer</code></a>及其具体的子类，以获取有关各个属性的更多详细信息。Javadoc还提供了有关事务选择和消息重新交付方案的讨论。</p>
</div>
<table id="jms-namespace-listener-container-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表4。JMS <listener-container>元素的</listener-container>属性</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>container-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器容器的类型。可用的选项是<code>default</code> ， <code>simple</code> ， <code>default102</code> ， 要么<code>simple102</code> （默认选项是<code>default</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>container-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自定义侦听器容器实现类，作为完全限定的类名。默认是Spring的标准<code>DefaultMessageListenerContainer</code>要么<code>SimpleMessageListenerContainer</code> ，根据<code>container-type</code>属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>factory-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将此元素定义的设置公开为<code>JmsListenerContainerFactory</code>与指定<code>id</code>以便它们可以与其他端点重用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connection-factory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对JMS的引用<code>ConnectionFactory</code> bean（默认的bean名称是<code>connectionFactory</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>task-executor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对春天的参考<code>TaskExecutor</code> JMS侦听器调用程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-resolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对的参考<code>DestinationResolver</code>解决JMS的策略<code>Destination</code>实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message-converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对的参考<code>MessageConverter</code>将JMS消息转换为侦听器方法参数的策略。默认为<code>SimpleMessageConverter</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-handler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对一个参考<code>ErrorHandler</code>处理在执行过程中可能发生的任何未捕获异常的策略<code>MessageListener</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的JMS目标类型： <code>queue</code> ， <code>topic</code> ， <code>durableTopic</code> ， <code>sharedTopic</code> ， 要么<code>sharedDurableTopic</code> 。这可能使<code>pubSubDomain</code> ， <code>subscriptionDurable</code>和<code>subscriptionShared</code>容器的属性。默认是<code>queue</code> （这将禁用这三个属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>response-destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的JMS目标类型： <code>queue</code>要么<code>topic</code> 。默认值为<code>destination-type</code>属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器容器的JMS客户端ID。使用持久订阅时必须指定它。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JMS资源的缓存级别： <code>none</code> ， <code>connection</code> ， <code>session</code> ， <code>consumer</code> ， 要么<code>auto</code> 。默认 （ <code>auto</code> ），缓存级别有效<code>consumer</code> ，除非指定了外部交易管理器，否则有效的默认值为<code>none</code> （假设Java EE风格的事务管理，其中给定的ConnectionFactory是可识别XA的池）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acknowledge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本机JMS确认模式： <code>auto</code> ， <code>client</code> ， <code>dups-ok</code> ， 要么<code>transacted</code> 。值<code>transacted</code>激活本地交易<code>Session</code> 。或者，您可以指定<code>transaction-manager</code>属性，稍后在表中进行介绍。默认是<code>auto</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对外部的引用<code>PlatformTransactionManager</code> （通常是基于XA的交易协调器，例如Spring的<code>JtaTransactionManager</code> ）。如果未指定，则使用本机确认（请参阅<code>acknowledge</code>属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concurrency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个侦听器启动的并发会话或使用者的数量。它可以是表示最大数量的简单数字（例如， <code>5</code> ）或指示上下限的范围（例如， <code>3-5</code> ）。请注意，指定的最小值只是一个提示，在运行时可能会被忽略。默认是<code>1</code> 。您应将并发限制为<code>1</code>如果是主题侦听器或队列顺序很重要。考虑将其提高为一般队列。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prefetch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加载到单个会话中的最大消息数。请注意，增加此数字可能会导致并发消费者饥饿。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>receive-timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于接听电话的超时时间（以毫秒为单位）。默认是<code>1000</code> （一秒）。 <code>-1</code>表示没有超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>back-off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定<code>BackOff</code>实例以计算两次恢复尝试之间的间隔。如果<code>BackOffExecution</code>实施回报<code>BackOffExecution#STOP</code> ，侦听器容器不会进一步尝试恢复。的<code>recovery-interval</code>设置此属性时，将忽略该值。默认为<code>FixedBackOff</code>间隔为5000毫秒（即5秒）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>recovery-interval</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定两次恢复尝试之间的时间间隔（以毫秒为单位）。它提供了一种方便的方法来创建<code>FixedBackOff</code>以指定的间隔。有关更多恢复选项，请考虑指定一个<code>BackOff</code>实例代替。缺省值为5000毫秒（即5秒）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>phase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此容器应在其中启动和停止的生命周期阶段。值越低，此容器启动越早，而其停止越晚。默认是<code>Integer.MAX_VALUE</code> ，表示该容器尽可能早地启动，并尽快停止。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用以下命令配置基于JCA的侦听器容器<code>jms</code>模式支持非常相似，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jms:jca-listener-container resource-adapter="myResourceAdapter"
        destination-resolver="myDestinationResolver"
        transaction-manager="myTransactionManager"
        concurrency="10"&gt;

    &lt;jms:listener destination="queue.orders" ref="myMessageListener"/&gt;

&lt;/jms:jca-listener-container&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了JCA变体的可用配置选项：</p>
</div>
<table id="jms-namespace-jca-listener-container-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表5。JMS的属性<jca-listener-container></jca-listener-container>元件</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>factory-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将此元素定义的设置公开为<code>JmsListenerContainerFactory</code>与指定<code>id</code>以便它们可以与其他端点重用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>resource-adapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对JCA的引用<code>ResourceAdapter</code> bean（默认的bean名称是<code>resourceAdapter</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>activation-spec-factory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对的参考<code>JmsActivationSpecFactory</code> 。默认是自动检测JMS提供程序及其<code>ActivationSpec</code>类（请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactory.html"><code>DefaultJmsActivationSpecFactory</code></a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-resolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对的参考<code>DestinationResolver</code>解决JMS的策略<code>Destinations</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message-converter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对的参考<code>MessageConverter</code>将JMS消息转换为侦听器方法参数的策略。默认是<code>SimpleMessageConverter</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器的JMS目标类型： <code>queue</code> ， <code>topic</code> ， <code>durableTopic</code> ， <code>sharedTopic</code> 。要么<code>sharedDurableTopic</code> 。这可能使<code>pubSubDomain</code> ， <code>subscriptionDurable</code>和<code>subscriptionShared</code>容器的属性。默认是<code>queue</code> （这将禁用这三个属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>response-destination-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的JMS目标类型： <code>queue</code>要么<code>topic</code> 。默认值为<code>destination-type</code>属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此侦听器容器的JMS客户端ID。使用持久订阅时需要指定它。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acknowledge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本机JMS确认模式： <code>auto</code> ， <code>client</code> ， <code>dups-ok</code> ， 要么<code>transacted</code> 。值<code>transacted</code>激活本地交易<code>Session</code> 。或者，您可以指定<code>transaction-manager</code>属性稍后说明。默认是<code>auto</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对弹簧的引用<code>JtaTransactionManager</code>或一个<code>javax.transaction.TransactionManager</code>为每个传入消息启动XA事务。如果未指定，则使用本机确认（请参阅<code>acknowledge</code>属性）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concurrency</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个侦听器启动的并发会话或使用者的数量。它可以是表示最大数量的简单数字（例如<code>5</code> ）或指示上下限的范围（例如， <code>3-5</code> ）。请注意，指定的最小值仅是一个提示，通常在运行时使用JCA侦听器容器时将被忽略。预设值为1。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prefetch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加载到单个会话中的最大消息数。请注意，增加此数字可能会导致并发消费者饥饿。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jmx"><a class="anchor" href="#jmx"></a> 4。JMX</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring中的JMX（Java管理扩展）支持提供的功能使您可以轻松，透明地将Spring应用程序集成到JMX基础结构中。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">JMX？</div>
<div class="paragraph">
<p>本章不是JMX的介绍。它没有试图解释为什么您可能要使用JMX。如果您不熟悉JMX，请参阅本章末尾的<a href="#jmx-resources">其他资源</a> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>具体来说，Spring的JMX支持提供了四个核心功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将任何Spring bean自动注册为JMX MBean。</p>
</li>
<li>
<p>用于控制bean的管理界面的灵活机制。</p>
</li>
<li>
<p>通过远程JSR-160连接器以声明方式公开MBean。</p>
</li>
<li>
<p>本地和远程MBean资源的简单代理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些功能旨在在不将应用程序组件耦合到Spring或JMX接口和类的情况下工作。实际上，在大多数情况下，您的应用程序类无需了解Spring或JMX即可利用Spring JMX功能。</p>
</div>
<div class="sect2">
<h3 id="jmx-exporting"><a class="anchor" href="#jmx-exporting"></a> 4.1。将您的Bean导出到JMX</h3>
<div class="paragraph">
<p>Spring的JMX框架的核心类是<code>MBeanExporter</code> 。此类负责获取您的Spring bean并向JMX注册它们<code>MBeanServer</code> 。例如，考虑以下类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;
    private int age;
    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将此Bean的属性和方法公开为MBean的属性和操作，可以配置MBean的实例。 <code>MBeanExporter</code>类在您的配置文件中并传入Bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;!-- this bean must not be lazily initialized if the exporting is to happen --&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter" lazy-init="false"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面配置片段中的相关bean定义是<code>exporter</code>豆。的<code>beans</code>属性告诉<code>MBeanExporter</code>确切地说，您必须将哪个bean导出到JMX <code>MBeanServer</code> 。在默认配置中， <code>beans</code><code>Map</code>用作<code>ObjectName</code>用于由相应条目值引用的bean。您可以更改此行为，如<a href="#jmx-naming">控制中所述<code>ObjectName</code> Bean的实例</a> 。</p>
</div>
<div class="paragraph">
<p>使用此配置， <code>testBean</code> Bean在MBean下暴露为MBean <code>ObjectName</code><code>bean:name=testBean1</code> 。默认情况下，所有<code>public</code> Bean的属性作为属性公开，所有<code>public</code>方法（从继承的方法除外<code>Object</code>类）作为操作公开。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>MBeanExporter</code>是一个<code>Lifecycle</code> bean（请参阅<a href="core.html#beans-factory-lifecycle-processor">启动和关闭回调</a> ）。默认情况下，MBean在应用程序生命周期中尽可能晚地导出。您可以配置<code>phase</code>设置导出时会发生导出或禁用自动注册<code>autoStartup</code>旗。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="jmx-exporting-mbeanserver"><a class="anchor" href="#jmx-exporting-mbeanserver"></a> 4.1.1。创建一个MBeanServer</h4>
<div class="paragraph">
<p>上<a href="#jmx-exporting">一节中</a>显示的配置假定该应用程序在一个（只有一个）环境中运行。 <code>MBeanServer</code>已经运行。在这种情况下，Spring尝试找到正在运行的<code>MBeanServer</code>并在该服务器上注册您的bean（如果有）。当您的应用程序在具有自己的容器（例如Tomcat或IBM WebSphere）中运行时，此行为很有用<code>MBeanServer</code> 。</p>
</div>
<div class="paragraph">
<p>但是，这种方法在独立环境中或在不提供容器功能的容器中运行时无用。 <code>MBeanServer</code> 。要解决此问题，您可以创建一个<code>MBeanServer</code>通过添加一个实例来声明式地<code>org.springframework.jmx.support.MBeanServerFactoryBean</code>类到您的配置。您还可以确保<code>MBeanServer</code>通过设置<code>MBeanExporter</code>实例的<code>server</code>财产<code>MBeanServer</code>由返回的值<code>MBeanServerFactoryBean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/&gt;

    &lt;!--
    this bean needs to be eagerly pre-instantiated in order for the exporting to occur;
    this means that it must not be marked as lazily initialized
    --&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="server" ref="mbeanServer"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>MBeanServer</code>由创建<code>MBeanServerFactoryBean</code>并提供给<code>MBeanExporter</code>通过<code>server</code>属性。当您提供自己的<code>MBeanServer</code>例如， <code>MBeanExporter</code>不会尝试找到正在运行的<code>MBeanServer</code>并使用提供的<code>MBeanServer</code>实例。为了使其正常工作，您必须在类路径上具有JMX实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-mbean-server"><a class="anchor" href="#jmx-mbean-server"></a> 4.1.2。重用现有的<code>MBeanServer</code></h4>
<div class="paragraph">
<p>如果未指定服务器，则<code>MBeanExporter</code>尝试自动检测运行<code>MBeanServer</code> 。这适用于大多数环境，其中只有一个<code>MBeanServer</code>使用实例。但是，当存在多个实例时，导出器可能选择了错误的服务器。在这种情况下，您应该使用<code>MBeanServer</code><code>agentId</code>指示要使用的实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
        &lt;!-- indicate to first look for a server --&gt;
        &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
        &lt;!-- search for the MBeanServer instance with the given agentId --&gt;
        &lt;property name="agentId" value="MBeanServer_instance_agentId&gt;"/&gt;
    &lt;/bean&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="server" ref="mbeanServer"/&gt;
        ...
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>适用于现有平台或案例<code>MBeanServer</code>具有动态（或未知） <code>agentId</code>通过查找方法检索的结果，应使用<a href="core.html#beans-factory-class-static-factory-method">factory-method</a> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="server"&gt;
            &lt;!-- Custom MBeanServerLocator --&gt;
            &lt;bean class="platform.package.MBeanServerLocator" factory-method="locateMBeanServer"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- other beans here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-lazy"><a class="anchor" href="#jmx-exporting-lazy"></a> 4.1.3。延迟初始化的MBean</h4>
<div class="paragraph">
<p>如果您使用<code>MBeanExporter</code>也配置为延迟初始化， <code>MBeanExporter</code>不会违反此合同，并且避免实例化bean。相反，它会向<code>MBeanServer</code>并从容器中获取Bean，直到对代理进行第一次调用为止。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-auto"><a class="anchor" href="#jmx-exporting-auto"></a> 4.1.4。自动注册MBean</h4>
<div class="paragraph">
<p>通过<code>MBeanExporter</code>并且已经有效的MBean已按原样注册到<code>MBeanServer</code>无需Spring的进一步干预。您可以使MBean自动被MBean检测到。 <code>MBeanExporter</code>通过设置<code>autodetect</code>财产<code>true</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="autodetect" value="true"/&gt;
&lt;/bean&gt;

&lt;bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，bean名为<code>spring:mbean=true</code>已经是有效的JMX MBean，并由Spring自动注册。默认情况下，自动检测到JMX注册的bean的bean名称用作<code>ObjectName</code> 。您可以覆盖此行为，如<a href="#jmx-naming">控制中所述<code>ObjectName</code> Bean的实例</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-exporting-registration-behavior"><a class="anchor" href="#jmx-exporting-registration-behavior"></a> 4.1.5。控制注册行为</h4>
<div class="paragraph">
<p>考虑一下春季的情况<code>MBeanExporter</code>尝试注册<code>MBean</code>带着<code>MBeanServer</code>通过使用<code>ObjectName</code><code>bean:name=testBean1</code> 。如果<code>MBean</code>实例已经在该实例下注册<code>ObjectName</code> ，默认行为是失败（并抛出<code>InstanceAlreadyExistsException</code> ）。</p>
</div>
<div class="paragraph">
<p>您可以精确控制当<code>MBean</code>已向<code>MBeanServer</code> 。Spring的JMX支持允许三种不同的注册行为来控制注册过程，当注册过程发现一个<code>MBean</code>已经在同一个下注册<code>ObjectName</code> 。下表总结了这些注册行为：</p>
</div>
<table id="jmx-registration-behaviors" class="tableblock frame-all grid-all spread">
<caption class="title">表6。注册行为</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注册行为</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FAIL_ON_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是默认的注册行为。如果<code>MBean</code>实例已在同一实例下注册<code>ObjectName</code> ， <code>MBean</code>正在注册的未注册，并且<code>InstanceAlreadyExistsException</code>被抛出。现有的<code>MBean</code>不受影响。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IGNORE_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果<code>MBean</code>实例已在同一实例下注册<code>ObjectName</code> ， <code>MBean</code>正在注册的未注册。现有的<code>MBean</code>不受影响，并且没有<code>Exception</code>被抛出。这在多个应用程序想要共享一个公用程序的设置中很有用<code>MBean</code>在共享中<code>MBeanServer</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REPLACE_EXISTING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果<code>MBean</code>实例已在同一实例下注册<code>ObjectName</code> ，现有<code>MBean</code>先前已注册的已注销，而新的<code>MBean</code>已在其位置注册（新<code>MBean</code>有效地替换了先前的实例）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>上表中的值被定义为<code>RegistrationPolicy</code>类。如果要更改默认注册行为，则需要设置<code>registrationPolicy</code>您的财产<code>MBeanExporter</code>定义为这些值之一。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何从默认注册行为更改为<code>REPLACE_EXISTING</code>行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="registrationPolicy" value="REPLACE_EXISTING"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-interface"><a class="anchor" href="#jmx-interface"></a> 4.2。控制Bean的管理接口</h3>
<div class="paragraph">
<p>在上<a href="#jmx-exporting-registration-behavior">一节</a>的示例中，您几乎无法控制bean的管理接口。全部<code>public</code>每个导出bean的属性和方法分别作为JMX属性和操作公开。为了对已导出的bean的哪些属性和方法实际作为JMX属性和操作公开进行更细粒度的控制，Spring JMX提供了一种全面且可扩展的机制来控制bean的管理接口。</p>
</div>
<div class="sect3">
<h4 id="jmx-interface-assembler"><a class="anchor" href="#jmx-interface-assembler"></a> 4.2.1。使用<code>MBeanInfoAssembler</code>接口</h4>
<div class="paragraph">
<p>在幕后， <code>MBeanExporter</code>代表执行<code>org.springframework.jmx.export.assembler.MBeanInfoAssembler</code>接口，负责定义每个公开的bean的管理接口。默认实现<code>org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</code>定义了一个管理接口，该接口公开了所有公共属性和方法（如前几节中的示例所示）。Spring提供了两个额外的实现<code>MBeanInfoAssembler</code>接口，您可以使用源级元数据或任何任意接口来控制生成的管理接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-metadata"><a class="anchor" href="#jmx-interface-metadata"></a> 4.2.2。使用源级元数据：Java注释</h4>
<div class="paragraph">
<p>通过使用<code>MetadataMBeanInfoAssembler</code> ，您可以使用源级元数据为bean定义管理界面。元数据的读取由<code>org.springframework.jmx.export.metadata.JmxAttributeSource</code>接口。Spring JMX提供了一个使用Java注释的默认实现，即<code>org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</code> 。您必须配置<code>MetadataMBeanInfoAssembler</code>与的实现实例<code>JmxAttributeSource</code>接口以使其正常运行（没有默认值）。</p>
</div>
<div class="paragraph">
<p>要标记要导出到JMX的Bean，应使用注释该Bean类。 <code>ManagedResource</code>注解。您必须使用标记要作为操作公开的每个方法<code>ManagedOperation</code>注释并标记您希望使用的每个属性<code>ManagedAttribute</code>注解。标记属性时，可以省略getter或setter的注释，以分别创建只写或只读属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">一种<code>ManagedResource</code> -带注释的Bean必须是公共的，公开操作或属性的方法也必须是公共的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了带注释的版本<code>JmxTestBean</code>在<a href="#jmx-exporting-mbeanserver">创建MBeanServer中</a>使用的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(
        objectName="bean:name=testBean4",
        description="My Managed Bean",
        log=true,
        logFile="jmx.log",
        currencyTimeLimit=15,
        persistPolicy="OnUpdate",
        persistPeriod=200,
        persistLocation="foo",
        persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

    private String name;
    private int age;

    @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @ManagedAttribute(description="The Name Attribute",
            currencyTimeLimit=20,
            defaultValue="bar",
            persistPolicy="OnUpdate")
    public void setName(String name) {
        this.name = name;
    }

    @ManagedAttribute(defaultValue="foo", persistPeriod=300)
    public String getName() {
        return name;
    }

    @ManagedOperation(description="Add two numbers")
    @ManagedOperationParameters({
        @ManagedOperationParameter(name = "x", description = "The first number"),
        @ManagedOperationParameter(name = "y", description = "The second number")})
    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以看到<code>JmxTestBean</code>班级标有<code>ManagedResource</code>注释和这个<code>ManagedResource</code>批注配置了一组属性。这些属性可用于配置由MBean生成的MBean的各个方面。 <code>MBeanExporter</code>稍后将在“ <a href="#jmx-interface-metadata-types">源级元数据类型”中进行</a>详细说明。</p>
</div>
<div class="paragraph">
<p>这俩<code>age</code>和<code>name</code>属性用<code>ManagedAttribute</code>注释，但是，对于<code>age</code>属性，只有吸气剂被标记。这导致这两个属性都作为属性包含在管理界面中，但是<code>age</code>属性是只读的。</p>
</div>
<div class="paragraph">
<p>最后， <code>add(int, int)</code>方法标有<code>ManagedOperation</code>属性，而<code>dontExposeMe()</code>方法不是。这将导致管理界面仅包含一个操作（ <code>add(int, int)</code> ），当您使用<code>MetadataMBeanInfoAssembler</code> 。</p>
</div>
<div class="paragraph">
<p>以下配置说明了如何配置<code>MBeanExporter</code>使用<code>MetadataMBeanInfoAssembler</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="assembler" ref="assembler"/&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
        &lt;property name="autodetect" value="true"/&gt;
    &lt;/bean&gt;

    &lt;bean id="jmxAttributeSource"
            class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

    &lt;!-- will create management interface using annotation metadata --&gt;
    &lt;bean id="assembler"
            class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;!-- will pick up the ObjectName from the annotation --&gt;
    &lt;bean id="namingStrategy"
            class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.AnnotationTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>MetadataMBeanInfoAssembler</code> Bean已配置了的实例<code>AnnotationJmxAttributeSource</code>类并传递给<code>MBeanExporter</code>通过汇编程序属性。这是利用Spring公开的MBean的元数据驱动的管理接口所需要的全部。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-metadata-types"><a class="anchor" href="#jmx-interface-metadata-types"></a> 4.2.3。源级元数据类型</h4>
<div class="paragraph">
<p>下表描述了可在Spring JMX中使用的源级别元数据类型：</p>
</div>
<table id="jmx-metadata-types" class="tableblock frame-all grid-all spread">
<caption class="title">表7。源级元数据类型</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">目的</th>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">注释类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记一个的所有实例<code>Class</code>作为JMX托管资源。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedResource</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">将方法标记为JMX操作。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedOperation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">将一个getter或setter标记为JMX属性的一半。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法（仅getter和setter）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义操作参数的描述。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ManagedOperationParameter</code>和<code>@ManagedOperationParameters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下表描述了可在这些源级元数据类型上使用的配置参数：</p>
</div>
<table id="jmx-metadata-parameters" class="tableblock frame-all grid-all spread">
<caption class="title">表8。源级元数据参数</caption>
<colgroup>
<col style="width:20%">
<col style="width:60%">
<col style="width:20%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">适用于</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ObjectName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用者<code>MetadataNamingStrategy</code>确定<code>ObjectName</code>托管资源。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置资源，属性或操作的友好描述。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code> ， <code>ManagedAttribute</code> ， <code>ManagedOperation</code> ， 要么<code>ManagedOperationParameter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>currencyTimeLimit</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>currencyTimeLimit</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code>要么<code>ManagedAttribute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>defaultValue</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedAttribute</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>log</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logFile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>logFile</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>persistPolicy</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistPeriod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>persistPeriod</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>persistLocation</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>persistName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置的值<code>persistName</code>描述符字段。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedResource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置操作参数的显示名称。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedOperationParameter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置操作参数的索引。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ManagedOperationParameter</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="jmx-interface-autodetect"><a class="anchor" href="#jmx-interface-autodetect"></a> 4.2.4。使用<code>AutodetectCapableMBeanInfoAssembler</code>接口</h4>
<div class="paragraph">
<p>为了进一步简化配置，Spring提供了<code>AutodetectCapableMBeanInfoAssembler</code>接口，扩展了<code>MBeanInfoAssembler</code>接口以添加对自动检测MBean资源的支持。如果您配置<code>MBeanExporter</code>与一个实例<code>AutodetectCapableMBeanInfoAssembler</code> ，就可以对包含JMX的bean进行“投票”。</p>
</div>
<div class="paragraph">
<p>唯一的实现<code>AutodetectCapableMBeanInfo</code>接口是<code>MetadataMBeanInfoAssembler</code> ，该投票将包括所有标记有<code>ManagedResource</code>属性。在这种情况下，默认方法是使用Bean名称作为<code>ObjectName</code> ，其结果类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;!-- notice how no 'beans' are explicitly configured here --&gt;
        &lt;property name="autodetect" value="true"/&gt;
        &lt;property name="assembler" ref="assembler"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
        &lt;property name="attributeSource"&gt;
            &lt;bean class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在上述配置中，没有将任何bean传递给<code>MBeanExporter</code> 。然而<code>JmxTestBean</code>仍然注册，因为它标有<code>ManagedResource</code>属性和<code>MetadataMBeanInfoAssembler</code>检测到并投票将其包括在内。这种方法的唯一问题是<code>JmxTestBean</code>现在具有业务意义。您可以通过更改以下内容的默认行为来解决此问题： <code>ObjectName</code> <a href="#jmx-naming">控制中</a>定义的创建<a href="#jmx-naming"><code>ObjectName</code> Bean的实例</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-java"><a class="anchor" href="#jmx-interface-java"></a> 4.2.5。使用Java接口定义管理接口</h4>
<div class="paragraph">
<p>除了<code>MetadataMBeanInfoAssembler</code> ，Spring还包括<code>InterfaceBasedMBeanInfoAssembler</code> ，它使您可以基于一组接口中定义的方法来约束公开的方法和属性。</p>
</div>
<div class="paragraph">
<p>尽管公开MBean的标准机制是使用接口和简单的命名方案， <code>InterfaceBasedMBeanInfoAssembler</code>通过消除对命名约定的需要，允许您使用多个接口以及消除使您的bean实现MBean接口的需要，扩展了此功能。</p>
</div>
<div class="paragraph">
<p>考虑以下接口，该接口用于为管理接口定义管理接口。 <code>JmxTestBean</code>我们之前显示的课程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface IJmxTestBean {

    public int add(int x, int y);

    public long myOperation();

    public int getAge();

    public void setAge(int age);

    public void setName(String name);

    public String getName();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此接口定义在JMX MBean上作为操作和属性公开的方法和属性。以下代码显示了如何配置Spring JMX以使用此接口作为管理接口的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean5" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="assembler"&gt;
            &lt;bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"&gt;
                &lt;property name="managedInterfaces"&gt;
                    &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>InterfaceBasedMBeanInfoAssembler</code>配置为使用<code>IJmxTestBean</code>为任何bean构造管理接口时的接口。重要的是要了解由<code>InterfaceBasedMBeanInfoAssembler</code>不需要实现用于生成JMX管理接口的接口。</p>
</div>
<div class="paragraph">
<p>在上述情况下， <code>IJmxTestBean</code> interface用于为所有bean构造所有管理接口。在许多情况下，这不是理想的行为，并且您可能希望对不同的bean使用不同的接口。在这种情况下，您可以通过<code>InterfaceBasedMBeanInfoAssembler</code>一种<code>Properties</code>通过实例<code>interfaceMappings</code>属性，其中每个条目的键是Bean名称，每个条目的值是用于该Bean的接口名称的逗号分隔列表。</p>
</div>
<div class="paragraph">
<p>如果没有通过任何一个指定管理接口<code>managedInterfaces</code>要么<code>interfaceMappings</code>属性， <code>InterfaceBasedMBeanInfoAssembler</code>反映在bean上，并使用该bean实现的所有接口来创建管理接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-interface-methodnames"><a class="anchor" href="#jmx-interface-methodnames"></a> 4.2.6。使用<code>MethodNameBasedMBeanInfoAssembler</code></h4>
<div class="paragraph">
<p><code>MethodNameBasedMBeanInfoAssembler</code>使您可以指定作为属性和操作公开给JMX的方法名称的列表。以下代码显示了示例配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
        &lt;map&gt;
            &lt;entry key="bean:name=testBean5" value-ref="testBean"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
        &lt;bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"&gt;
            &lt;property name="managedMethods"&gt;
                &lt;value&gt;add,myOperation,getName,setName,getAge&lt;/value&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以看到<code>add</code>和<code>myOperation</code>方法作为JMX操作公开，并且<code>getName()</code> ， <code>setName(String)</code>和<code>getAge()</code>被公开为JMX属性的适当部分。在前面的代码中，方法映射适用于公开给JMX的bean。要逐个控制方法暴露，可以使用<code>methodMappings</code>的财产<code>MethodNameMBeanInfoAssembler</code>将bean名称映射到方法名称列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-naming"><a class="anchor" href="#jmx-naming"></a> 4.3。控制性<code>ObjectName</code> Bean的实例</h3>
<div class="paragraph">
<p>在幕后， <code>MBeanExporter</code>代表执行<code>ObjectNamingStrategy</code>获得一个<code>ObjectName</code>它注册的每个bean的实例。默认情况下，默认实现<code>KeyNamingStrategy</code>使用的键<code>beans</code><code>Map</code>作为<code>ObjectName</code> 。除此之外<code>KeyNamingStrategy</code>可以映射<code>beans</code><code>Map</code>到一个<code>Properties</code>文件（或多个文件）来解决<code>ObjectName</code> 。除了<code>KeyNamingStrategy</code> ，Spring提供了另外两个<code>ObjectNamingStrategy</code>实现： <code>IdentityNamingStrategy</code> （这会建立一个<code>ObjectName</code>基于bean的JVM身份）和<code>MetadataNamingStrategy</code> （它使用源级别的元数据来获取<code>ObjectName</code> ）。</p>
</div>
<div class="sect3">
<h4 id="jmx-naming-properties"><a class="anchor" href="#jmx-naming-properties"></a> 4.3.1。阅读<code>ObjectName</code>来自属性的实例</h4>
<div class="paragraph">
<p>您可以配置自己的<code>KeyNamingStrategy</code>实例并将其配置为读取<code>ObjectName</code>来自的实例<code>Properties</code>实例而不是使用Bean键。的<code>KeyNamingStrategy</code>尝试在<code>Properties</code>与对应于Bean密钥的密钥。如果找不到条目，或者<code>Properties</code>实例是<code>null</code> ，则使用bean密钥本身。</p>
</div>
<div class="paragraph">
<p>以下代码显示了<code>KeyNamingStrategy</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="testBean" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="testBean"&gt;bean:name=testBean1&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="mappingLocations"&gt;
            &lt;value&gt;names1.properties,names2.properties&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例配置了一个实例<code>KeyNamingStrategy</code>与一个<code>Properties</code>从合并的实例<code>Properties</code>由mapping属性定义的实例，以及位于mappings属性定义的路径中的属性文件。在此配置中， <code>testBean</code>给豆一个<code>ObjectName</code>的<code>bean:name=testBean1</code> ，因为这是<code>Properties</code>具有与bean密钥相对应的密钥的实例。</p>
</div>
<div class="paragraph">
<p>如果没有输入<code>Properties</code>可以找到实例，bean键名用作<code>ObjectName</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-naming-metadata"><a class="anchor" href="#jmx-naming-metadata"></a> 4.3.2。使用<code>MetadataNamingStrategy</code></h4>
<div class="paragraph">
<p><code>MetadataNamingStrategy</code>使用<code>objectName</code>的属性<code>ManagedResource</code>每个bean上的属性来创建<code>ObjectName</code> 。以下代码显示了<code>MetadataNamingStrategy</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="testBean" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
        &lt;property name="attributeSource" ref="attributeSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="attributeSource"
            class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不<code>objectName</code>已提供给<code>ManagedResource</code>属性， <code>ObjectName</code>使用以下格式创建： <em>[完全合格的软件包名称]：type = [short-classname]，name = [bean-name]</em> 。例如，生成的<code>ObjectName</code>因为下面的豆是<code>com.example:type=MyClass,name=myBean</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="myBean" class="com.example.MyClass"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-context-mbeanexport"><a class="anchor" href="#jmx-context-mbeanexport"></a> 4.3.3。配置基于注释的MBean导出</h4>
<div class="paragraph">
<p>如果您更喜欢使用<a href="#jmx-interface-metadata">基于注释的方法</a>来定义您的管理界面，则可以使用以下便捷子类<code>MBeanExporter</code>可用： <code>AnnotationMBeanExporter</code> 。在定义此子类的实例时，您不再需要<code>namingStrategy</code> ， <code>assembler</code>和<code>attributeSource</code>配置，因为它始终使用标准的基于Java注释的元数据（也始终启用自动检测）。实际上，与其定义一个<code>MBeanExporter</code> Bean，甚至支持更简单的语法<code>@EnableMBeanExport</code><code>@Configuration</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableMBeanExport
public class AppConfig {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您喜欢基于XML的配置，则<code><context:mbean-export/></code>元素具有相同的作用，并在下面的清单中显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context:mbean-export/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如有必要，可以提供对特定MBean的引用<code>server</code>和<code>defaultDomain</code>属性（的属性<code>AnnotationMBeanExporter</code> ）接受生成的MBean的替代值<code>ObjectName</code>域。如上例中的<a href="#jmx-naming-metadata">MetadataNamingStrategy</a>所述，使用它代替完全合格的程序包名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableMBeanExport(server="myMBeanServer", defaultDomain="myDomain")
@Configuration
ContextConfiguration {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与上述基于注释的示例等效的XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context:mbean-export server="myMBeanServer" default-domain="myDomain"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">请勿将基于接口的AOP代理与bean类中的JMX注释的自动检测结合使用。基于接口的代理“隐藏”目标类，这也隐藏了JMX管理的资源注释。因此，在这种情况下，您应该使用目标类代理（通过将'proxy-target-class'标志设置为<code><aop:config/></code> ， <code><tx:annotation-driven/></code>等等）。否则，启动时可能会静默忽略您的JMX bean。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-jsr160"><a class="anchor" href="#jmx-jsr160"></a> 4.4。使用JSR-160连接器</h3>
<div class="paragraph">
<p>对于远程访问，Spring JMX模块提供了两个<code>FactoryBean</code>内部的实现<code>org.springframework.jmx.support</code>用于创建服务器和客户端连接器的软件包。</p>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-server"><a class="anchor" href="#jmx-jsr160-server"></a> 4.4.1。服务器端连接器</h4>
<div class="paragraph">
<p>要让Spring JMX创建，启动和公开JSR-160 <code>JMXConnectorServer</code> ，您可以使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>ConnectorServerFactoryBean</code>创建一个<code>JMXConnectorServer</code>势必<code>service:jmx:jmxmp://localhost:9875</code> 。的<code>serverConnector</code>因此，bean暴露了本地<code>MBeanServer</code>通过本地主机端口9875上的JMXMP协议连接到客户端。请注意，JMX 160规范将JMXMP协议标记为可选。当前，主要的开源JMX实现MX4J和JDK附带的实现不支持JMXMP。</p>
</div>
<div class="paragraph">
<p>要指定其他网址并注册<code>JMXConnectorServer</code>本身与<code>MBeanServer</code> ，您可以使用<code>serviceUrl</code>和<code>ObjectName</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serverConnector"
        class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName" value="connector:name=rmi"/&gt;
    &lt;property name="serviceUrl"
            value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>ObjectName</code>设置了属性后，Spring会自动向<code>MBeanServer</code>在那之下<code>ObjectName</code> 。以下示例显示了您可以传递给<code>ConnectorServerFactoryBean</code>当创建一个<code>JMXConnector</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serverConnector"
        class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName" value="connector:name=iiop"/&gt;
    &lt;property name="serviceUrl"
        value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/&gt;
    &lt;property name="threaded" value="true"/&gt;
    &lt;property name="daemon" value="true"/&gt;
    &lt;property name="environment"&gt;
        &lt;map&gt;
            &lt;entry key="someKey" value="someValue"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在使用基于RMI的连接器时，您需要查找服务（ <code>tnameserv</code>要么<code>rmiregistry</code> ），以便完成名称注册。如果您使用Spring通过RMI为您导出远程服务，则Spring已经构造了一个RMI注册表。如果没有，您可以使用以下配置片段轻松启动注册表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean"&gt;
    &lt;property name="port" value="1099"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-client"><a class="anchor" href="#jmx-jsr160-client"></a> 4.4.2。客户端连接器</h4>
<div class="paragraph">
<p>创建一个<code>MBeanServerConnection</code>到启用了JSR-160的远程<code>MBeanServer</code> ，您可以使用<code>MBeanServerConnectionFactoryBean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
    &lt;property name="serviceUrl" value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jmx-jsr160-protocols"><a class="anchor" href="#jmx-jsr160-protocols"></a> 4.4.3。通过Hessian或SOAP的JMX</h4>
<div class="paragraph">
<p>JSR-160允许扩展客户端和服务器之间进行通信的方式。前面各节中显示的示例使用JSR-160规范（IIOP和JRMP）和（可选）JMXMP所需的基于RMI的强制实现。通过使用其他提供程序或JMX实现（例如<a href="http://mx4j.sourceforge.net">MX4J</a> ），可以通过简单的HTTP或SSL以及其他协议利用SOAP或Hessian等协议，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
    &lt;property name="objectName" value="connector:name=burlap"/&gt;
    &lt;property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们使用了MX4J 3.0.0。有关更多信息，请参见官方MX4J文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-proxy"><a class="anchor" href="#jmx-proxy"></a> 4.5。通过代理访问MBean</h3>
<div class="paragraph">
<p>Spring JMX使您可以创建代理，以将调用重新路由到在本地或远程注册的MBean <code>MBeanServer</code> 。这些代理为您提供了一个标准的Java接口，您可以通过该接口与MBean进行交互。以下代码显示如何为在本地运行的MBean配置代理<code>MBeanServer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName" value="bean:name=testBean"/&gt;
    &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以看到为在MBean下注册的MBean创建了代理。 <code>ObjectName</code>的<code>bean:name=testBean</code> 。代理实现的接口集由<code>proxyInterfaces</code>属性，以及将这些接口上的方法和属性映射到MBean上的操作和属性的规则与<code>InterfaceBasedMBeanInfoAssembler</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>MBeanProxyFactoryBean</code>可以创建可通过以下方式访问的任何MBean的代理： <code>MBeanServerConnection</code> 。默认情况下，本地<code>MBeanServer</code>被定位和使用，但是您可以覆盖它并提供<code>MBeanServerConnection</code>指向远程<code>MBeanServer</code>迎合指向远程MBean的代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="clientConnector"
        class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
    &lt;property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/&gt;
&lt;/bean&gt;

&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName" value="bean:name=testBean"/&gt;
    &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
    &lt;property name="server" ref="clientConnector"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们创建了一个<code>MBeanServerConnection</code>指向使用<code>MBeanServerConnectionFactoryBean</code> 。这个<code>MBeanServerConnection</code>然后传递给<code>MBeanProxyFactoryBean</code>通过<code>server</code>属性。创建的代理将所有调用转发到<code>MBeanServer</code>通过这个<code>MBeanServerConnection</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="jmx-notifications"><a class="anchor" href="#jmx-notifications"></a> 4.6。通知事项</h3>
<div class="paragraph">
<p>Spring的JMX产品包括对JMX通知的全面支持。</p>
</div>
<div class="sect3">
<h4 id="jmx-notifications-listeners"><a class="anchor" href="#jmx-notifications-listeners"></a> 4.6.1。注册侦听器以接收通知</h4>
<div class="paragraph">
<p>Spring的JMX支持使注册任意数量的<code>NotificationListeners</code>带有任意数量的MBean（包括Spring的MBean导出的MBean） <code>MBeanExporter</code>以及通过其他机制注册的MBean）。例如，考虑一种情况，即一个人希望被告知（通过一个<code>Notification</code> ），每次目标MBean的属性发生变化。以下示例将通知写入控制台：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import javax.management.AttributeChangeNotification;
import javax.management.Notification;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;

public class ConsoleLoggingNotificationListener
        implements NotificationListener, NotificationFilter {

    public void handleNotification(Notification notification, Object handback) {
        System.out.println(notification);
        System.out.println(handback);
    }

    public boolean isNotificationEnabled(Notification notification) {
        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例添加<code>ConsoleLoggingNotificationListener</code> （在前面的示例中定义）为<code>notificationListenerMappings</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListenerMappings"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1"&gt;
                    &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了上述配置，每次JMX <code>Notification</code>从目标MBean广播（ <code>bean:name=testBean1</code> ）， <code>ConsoleLoggingNotificationListener</code>通过以下方式注册为侦听器的Bean： <code>notificationListenerMappings</code>通知财产。的<code>ConsoleLoggingNotificationListener</code>然后，bean可以采取它认为适当的任何措施来响应<code>Notification</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以使用纯bean名称作为导出的bean与侦听器之间的链接，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListenerMappings"&gt;
            &lt;map&gt;
                &lt;entry key="<em>testBean</em>"&gt;
                    &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="<em>testBean</em>" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想注册一个<code>NotificationListener</code>包含的所有bean的实例<code>MBeanExporter</code>导出，您可以使用特殊的通配符（ <code>*</code> ）作为条目中的键<code>notificationListenerMappings</code>属性图，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;property name="notificationListenerMappings"&gt;
    &lt;map&gt;
        &lt;entry key="*"&gt;
            &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
&lt;/property&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要进行相反操作（也就是说，针对MBean注册许多不同的侦听器），则必须改用<code>notificationListeners</code>列表属性（优先于<code>notificationListenerMappings</code>属性）。这次，不用配置<code>NotificationListener</code>对于单个MBean，我们配置<code>NotificationListenerBean</code>实例。一种<code>NotificationListenerBean</code>封装一个<code>NotificationListener</code>和<code>ObjectName</code> （要么<code>ObjectNames</code> ）须在<code>MBeanServer</code> 。的<code>NotificationListenerBean</code>还封装了许多其他属性，例如<code>NotificationFilter</code>以及可以在高级JMX通知方案中使用的任意回切对象。</p>
</div>
<div class="paragraph">
<p>使用时的配置<code>NotificationListenerBean</code>实例与前面介绍的实例没有很大不同，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListeners"&gt;
            &lt;list&gt;
                &lt;bean class="org.springframework.jmx.export.NotificationListenerBean"&gt;
                    &lt;constructor-arg&gt;
                        &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                    &lt;/constructor-arg&gt;
                    &lt;property name="mappedObjectNames"&gt;
                        &lt;list&gt;
                            &lt;value&gt;bean:name=testBean1&lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例等效于第一个通知示例。那么，假设我们想在每次<code>Notification</code>被提出，我们也想过滤掉无关的<code>Notifications</code>通过提供一个<code>NotificationFilter</code> 。以下示例实现了这些目标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean1"/&gt;
                &lt;entry key="bean:name=testBean2" value-ref="testBean2"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="notificationListeners"&gt;
            &lt;list&gt;
                &lt;bean class="org.springframework.jmx.export.NotificationListenerBean"&gt;
                    &lt;constructor-arg ref="customerNotificationListener"/&gt;
                    &lt;property name="mappedObjectNames"&gt;
                        &lt;list&gt;
                            &lt;!-- handles notifications from two distinct MBeans --&gt;
                            &lt;value&gt;bean:name=testBean1&lt;/value&gt;
                            &lt;value&gt;bean:name=testBean2&lt;/value&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                    &lt;property name="handback"&gt;
                        &lt;bean class="java.lang.String"&gt;
                            &lt;constructor-arg value="This could be anything..."/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                    &lt;property name="notificationFilter" ref="customerNotificationListener"/&gt;
                &lt;/bean&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!-- implements both the NotificationListener and NotificationFilter interfaces --&gt;
    &lt;bean id="customerNotificationListener" class="com.example.ConsoleLoggingNotificationListener"/&gt;

    &lt;bean id="testBean1" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean2" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="ANOTHER TEST"/&gt;
        &lt;property name="age" value="200"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>（要全面讨论什么是递归对象，实际上是什么<code>NotificationFilter</code>是，请参见JMX规范（1.2）中名为“ JMX通知模型”的部分。）</p>
</div>
</div>
<div class="sect3">
<h4 id="jmx-notifications-publishing"><a class="anchor" href="#jmx-notifications-publishing"></a> 4.6.2。发布通知</h4>
<div class="paragraph">
<p>Spring不仅为注册接收提供支持<code>Notifications</code>还可以发布<code>Notifications</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本部分实际上仅与已经通过MBean公开为MBean的Spring托管Bean有关。 <code>MBeanExporter</code> 。任何现有的用户定义MBean都应使用标准JMX API进行通知发布。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring的JMX通知发布支持中的关键接口是<code>NotificationPublisher</code>接口（在<code>org.springframework.jmx.export.notification</code>包）。任何将通过MBean导出为MBean的bean <code>MBeanExporter</code>实例可以实现相关<code>NotificationPublisherAware</code>界面访问<code>NotificationPublisher</code>实例。的<code>NotificationPublisherAware</code>接口提供一个实例<code>NotificationPublisher</code>通过简单的setter方法访问实现中的bean，然后可以使用bean来发布该方法<code>Notifications</code> 。</p>
</div>
<div class="paragraph">
<p>如Javadoc中所述<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jmx/export/notification/NotificationPublisher.html"><code>NotificationPublisher</code></a>界面，通过<code>NotificationPublisher</code>机制不负责通知侦听器的状态管理。Spring的JMX支持负责处理所有JMX基础结构问题。作为应用程序开发人员，您需要做的就是实现<code>NotificationPublisherAware</code>界面并使用提供的内容开始发布事件<code>NotificationPublisher</code>实例。请注意<code>NotificationPublisher</code>在托管Bean已向<code>MBeanServer</code> 。</p>
</div>
<div class="paragraph">
<p>用一个<code>NotificationPublisher</code>实例非常简单。您创建一个JMX <code>Notification</code>实例（或适当实例） <code>Notification</code>子类），使用与要发布的事件相关的数据填充通知，并调用<code>sendNotification(Notification)</code>在<code>NotificationPublisher</code>例如，传入<code>Notification</code> 。</p>
</div>
<div class="paragraph">
<p>在以下示例中，导出的实例<code>JmxTestBean</code>发布一个<code>NotificationEvent</code>每次<code>add(int, int)</code>操作被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.jmx;

import org.springframework.jmx.export.notification.NotificationPublisherAware;
import org.springframework.jmx.export.notification.NotificationPublisher;
import javax.management.Notification;

public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {

    private String name;
    private int age;
    private boolean isSuperman;
    private NotificationPublisher publisher;

    // other getters and setters omitted for clarity

    public int add(int x, int y) {
        int answer = x + y;
        this.publisher.sendNotification(new Notification("add", this, 0));
        return answer;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

    public void setNotificationPublisher(NotificationPublisher notificationPublisher) {
        this.publisher = notificationPublisher;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>NotificationPublisher</code>界面和使一切正常运行的机制是Spring JMX支持的更好的功能之一。但是，它确实带有将类耦合到Spring和JMX的代价。和往常一样，这里的建议要务实。如果您需要<code>NotificationPublisher</code>并且您可以接受Spring和JMX的耦合，然后这样做。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jmx-resources"><a class="anchor" href="#jmx-resources"></a> 4.7。更多资源</h3>
<div class="paragraph">
<p>本部分包含有关JMX的更多资源的链接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Oracle的<a href="https://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX主页</a> 。</p>
</li>
<li>
<p><a href="https://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html">JMX规范</a> （JSR-000003）。</p>
</li>
<li>
<p><a href="https://jcp.org/aboutJava/communityprocess/final/jsr160/index.html">JMX远程API规范</a> （JSR-000160）。</p>
</li>
<li>
<p><a href="http://mx4j.sourceforge.net/">MX4J主页</a> 。（MX4J是各种JMX规范的开源实现。）</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cci"><a class="anchor" href="#cci"></a> 5，JCA CCI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java EE提供了一个规范来标准化对企业信息系统（EIS）的访问：JCA（Java EE连接器体系结构）。该规范分为两个不同的部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>连接器提供程序必须实现的SPI（服务提供程序接口）。这些接口构成了可以部署在Java EE应用程序服务器上的资源适配器。在这种情况下，服务器将管理连接池，事务和安全性（托管模式）。应用服务器还负责管理配置，该配置保存在客户端应用程序外部。连接器也可以在没有应用程序服务器的情况下使用。在这种情况下，应用程序必须直接对其进行配置（非托管模式）。</p>
</li>
<li>
<p>应用程序可用于与连接器进行交互并由此与EIS通信的CCI（通用客户端接口）。还提供了用于本地事务划分的API。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring CCI支持的目的是使用Spring Framework的常规资源和事务管理工具，提供类以典型的Spring样式访问CCI连接器。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">连接器的客户端并不总是使用CCI。某些连接器公开了自己的API，提供了JCA资源适配器以使用Java EE容器的系统协定（连接池，全局事务和安全性）。Spring不为此类特定于连接器的API提供特殊支持。</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="cci-config"><a class="anchor" href="#cci-config"></a> 5.1。配置CCI</h3>
<div class="paragraph">
<p>本节介绍如何配置公共客户端接口（CCI）。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cci-config-connector">连接器配置</a></p>
</li>
<li>
<p><a href="#cci-config-connectionfactory"><code>ConnectionFactory</code>春季配置</a></p>
</li>
<li>
<p><a href="#cci-config-cci-connections">配置CCI连接</a></p>
</li>
<li>
<p><a href="#cci-config-single-connection">使用单个CCI连接</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="cci-config-connector"><a class="anchor" href="#cci-config-connector"></a> 5.1.1。连接器配置</h4>
<div class="paragraph">
<p>使用JCA CCI的基本资源是<code>ConnectionFactory</code>接口。您使用的连接器必须提供此接口的实现。</p>
</div>
<div class="paragraph">
<p>要使用连接器，您可以将其部署在应用程序服务器上并获取<code>ConnectionFactory</code>从服务器的JNDI环境（托管模式）。连接器必须打包为RAR文件（资源适配器档案），并包含一个<code>ra.xml</code>文件描述其部署特征。资源的实际名称是在部署时指定的。要在Spring中访问它，您可以使用Spring的<code>JndiObjectFactoryBean</code>要么<code><jee:jndi-lookup></code>以其JNDI名称获取工厂。</p>
</div>
<div class="paragraph">
<p>使用连接器的另一种方法是将其嵌入到您的应用程序中（非托管模式），而不使用应用程序服务器来部署和配置它。Spring提供了通过以下方式将连接器配置为bean的可能性： <code>FactoryBean</code>实现称为（ <code>LocalConnectionFactoryBean</code> ）。这样，您只需要在类路径中使用连接器库（无需RAR文件，无需<code>ra.xml</code>描述符）。如有必要，必须从连接器的RAR文件中提取该库。</p>
</div>
<div class="paragraph">
<p>一旦您可以访问<code>ConnectionFactory</code>例如，您可以将其注入到组件中。这些组件可以根据普通的CCI API进行编码，也可以使用Spring的支持类进行CCI访问（例如<code>CciTemplate</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在非托管模式下使用连接器时，不能使用全局事务，因为资源永远不会在当前线程的当前全局事务中被征用或除名。该资源不知道任何可能正在运行的全局Java EE事务。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="cci-config-connectionfactory"><a class="anchor" href="#cci-config-connectionfactory"></a> 5.1.2。 <code>ConnectionFactory</code> 春季配置</h4>
<div class="paragraph">
<p>要连接到EIS，您需要获取一个<code>ConnectionFactory</code>从应用程序服务器（如果处于托管模式）或直接从Spring（如果处于非托管模式）。</p>
</div>
<div class="paragraph">
<p>在托管模式下，您可以访问<code>ConnectionFactory</code>来自JNDI。其属性在应用程序服务器中配置。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在非托管模式下，您必须配置<code>ConnectionFactory</code>您想在Spring中将其配置为JavaBean。的<code>LocalConnectionFactoryBean</code>此类提供了这种设置样式， <code>ManagedConnectionFactory</code>连接器的实现，公开应用程序级CCI <code>ConnectionFactory</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="eciManagedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
    &lt;property name="serverName" value="TXSERIES"/&gt;
    &lt;property name="connectionURL" value="tcp://localhost/"/&gt;
    &lt;property name="portNumber" value="2006"/&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
    &lt;property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您不能直接实例化特定对象<code>ConnectionFactory</code> 。您需要经历相应的实现<code>ManagedConnectionFactory</code>连接器的接口。该接口是JCA SPI规范的一部分。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="cci-config-cci-connections"><a class="anchor" href="#cci-config-cci-connections"></a> 5.1.3。配置CCI连接</h4>
<div class="paragraph">
<p>通过JCA CCI，您可以使用以下命令配置与EIS的连接： <code>ConnectionSpec</code>连接器的实现。要配置其属性，您需要使用专用适配器包装目标连接工厂， <code>ConnectionSpecConnectionFactoryAdapter</code> 。您可以配置专用<code>ConnectionSpec</code>与<code>connectionSpec</code>属性（作为内部bean）。</p>
</div>
<div class="paragraph">
<p>此属性不是强制性的，因为CCI <code>ConnectionFactory</code>接口定义了两种不同的方法来获取CCI连接。您通常可以配置一些<code>ConnectionSpec</code>应用程序服务器（在托管模式下）或相应本地计算机上的属性<code>ManagedConnectionFactory</code>实施。以下清单显示了<code>ConnectionFactory</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ConnectionFactory implements Serializable, Referenceable {
    ...
    Connection getConnection() throws ResourceException;
    Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>春天提供了<code>ConnectionSpecConnectionFactoryAdapter</code>让您指定一个<code>ConnectionSpec</code>用于给定工厂的所有操作的实例。如果适配器的<code>connectionSpec</code>指定了属性，适配器使用<code>getConnection</code>与的变体<code>ConnectionSpec</code>论点。否则，适配器将使用不带该参数的变量。以下示例显示了如何配置<code>ConnectionSpecConnectionFactoryAdapter</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="managedConnectionFactory"
        class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
    &lt;property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="driverName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
        class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
    &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
        class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
    &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
    &lt;property name="connectionSpec"&gt;
        &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
            &lt;property name="user" value="sa"/&gt;
            &lt;property name="password" value=""/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-config-single-connection"><a class="anchor" href="#cci-config-single-connection"></a> 5.1.4。使用单个CCI连接</h4>
<div class="paragraph">
<p>如果您要使用单个CCI连接，Spring会提供更多<code>ConnectionFactory</code>适配器来管理这个。的<code>SingleConnectionFactory</code>适配器类延迟打开单个连接，并在应用程序关闭时销毁该bean时将其关闭。这堂课暴露出特殊之处<code>Connection</code>行为相应的代理，都共享相同的基础物理连接。以下示例显示了如何使用<code>SingleConnectionFactory</code>适配器类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="eciManagedConnectionFactory"
        class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
    &lt;property name="serverName" value="TEST"/&gt;
    &lt;property name="connectionURL" value="tcp://localhost/"/&gt;
    &lt;property name="portNumber" value="2006"/&gt;
&lt;/bean&gt;

&lt;bean id="targetEciConnectionFactory"
        class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
    &lt;property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory"
        class="org.springframework.jca.cci.connection.SingleConnectionFactory"&gt;
    &lt;property name="targetConnectionFactory" ref="targetEciConnectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这个<code>ConnectionFactory</code>适配器不能直接使用<code>ConnectionSpec</code> 。您可以使用中介<code>ConnectionSpecConnectionFactoryAdapter</code>那<code>SingleConnectionFactory</code>询问是否需要特定连接的单个连接<code>ConnectionSpec</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cci-using"><a class="anchor" href="#cci-using"></a> 5.2。使用Spring的CCI访问支持</h3>
<div class="paragraph">
<p>本节描述如何使用Spring对CCI的支持来实现各种目的。它包括以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#cci-record-creator">记录转换</a></p>
</li>
<li>
<p><a href="#cci-using-template">使用<code>CciTemplate</code></a></p>
</li>
<li>
<p><a href="#cci-using-dao">使用DAO支持</a></p>
</li>
<li>
<p><a href="#automatic-output-generation">自动输出记录生成</a></p>
</li>
<li>
<p><a href="#template-summary"><code>CciTemplate</code><code>Interaction</code>摘要</a></p>
</li>
<li>
<p><a href="#cci-straight">直接使用CCI连接和交互</a></p>
</li>
<li>
<p><a href="#cci-template-example">例子<code>CciTemplate</code>用法</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="cci-record-creator"><a class="anchor" href="#cci-record-creator"></a> 5.2.1。记录转换</h4>
<div class="paragraph">
<p>Spring的JCA CCI支持的目的之一是为处理CCI记录提供便利的设施。您可以指定创建记录并从记录中提取数据的策略，以用于Spring的<code>CciTemplate</code> 。如果您不想直接在应用程序中使用记录，本节中描述的接口将策略配置为使用输入和输出记录。</p>
</div>
<div class="paragraph">
<p>创建输入<code>Record</code> ，您可以使用专用的实现<code>RecordCreator</code>接口。以下清单显示了<code>RecordCreator</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface RecordCreator {

    Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>createRecord(..)</code>方法收到一个<code>RecordFactory</code>实例作为参数，对应于<code>RecordFactory</code>的<code>ConnectionFactory</code>用过的。您可以使用此参考来创建<code>IndexedRecord</code>要么<code>MappedRecord</code>实例。以下示例显示了如何使用<code>RecordCreator</code>接口和索引或映射记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyRecordCreator implements RecordCreator {

    public Record createRecord(RecordFactory recordFactory) throws ResourceException {
        IndexedRecord input = recordFactory.createIndexedRecord("input");
        input.add(new Integer(id));
        return input;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用输出<code>Record</code>接收从EIS返回的数据。因此，您可以通过特定的实现<code>RecordExtractor</code>与Spring的接口<code>CciTemplate</code>从输出中提取数据<code>Record</code> 。以下清单显示了<code>RecordExtractor</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface RecordExtractor {

    Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>RecordExtractor</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyRecordExtractor implements RecordExtractor {

    public Object extractData(Record record) throws ResourceException {
        CommAreaRecord commAreaRecord = (CommAreaRecord) record;
        String str = new String(commAreaRecord.toByteArray());
        String field1 = string.substring(0,6);
        String field2 = string.substring(6,1);
        return new OutputObject(Long.parseLong(field1), field2);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-using-template"><a class="anchor" href="#cci-using-template"></a> 5.2.2。使用<code>CciTemplate</code></h4>
<div class="paragraph">
<p>的<code>CciTemplate</code>是核心CCI支持包的核心类（ <code>org.springframework.jca.cci.core</code> ）。因为它处理资源的创建和释放，所以它简化了CCI的使用。这有助于避免常见的错误，例如忘记始终关闭连接。它关心连接和交互对象的生命周期，让应用程序代码专注于从应用程序数据生成输入记录并从输出记录提取应用程序数据。</p>
</div>
<div class="paragraph">
<p>JCA CCI规范定义了两种不同的方法来调用EIS上的操作。 CCI <code>Interaction</code>界面提供了两个execute方法签名，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface javax.resource.cci.Interaction {

    ...

    boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;

    Record execute(InteractionSpec spec, Record input) throws ResourceException;

    ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据所调用的模板方法， <code>CciTemplate</code>知道哪个<code>execute</code>调用交互的方法。无论如何，正确初始化<code>InteractionSpec</code>实例是强制性的。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>CciTemplate.execute(..)</code>有两种方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>带直接<code>Record</code>论点。在这种情况下，您需要传递CCI输入记录，并且返回的对象是相应的CCI输出记录。</p>
</li>
<li>
<p>对于应用程序对象，通过使用记录映射。在这种情况下，您需要提供相应的<code>RecordCreator</code>和<code>RecordExtractor</code>实例。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>采用第一种方法时，以下方法（直接对应于<code>Interaction</code>介面）的范本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CciTemplate implements CciOperations {

    public Record execute(InteractionSpec spec, Record inputRecord)
            throws DataAccessException { ... }

    public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
            throws DataAccessException { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用第二种方法，我们需要指定记录创建和记录提取策略作为参数。使用的接口是<a href="#cci-record-creator">上一部分有关记录转换的接口</a> 。以下清单显示了对应的<code>CciTemplate</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CciTemplate implements CciOperations {

    public Record execute(InteractionSpec spec,
            RecordCreator inputCreator) throws DataAccessException {
        // ...
    }

    public Object execute(InteractionSpec spec, Record inputRecord,
            RecordExtractor outputExtractor) throws DataAccessException {
        // ...
    }

    public Object execute(InteractionSpec spec, RecordCreator creator,
            RecordExtractor extractor) throws DataAccessException {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非<code>outputRecordCreator</code>属性是在模板上设置的（请参见以下部分），每个方法都调用相应的<code>execute</code> CCI方法<code>Interaction</code>有两个参数： <code>InteractionSpec</code>和输入<code>Record</code> 。它接收输出<code>Record</code>作为其返回值。</p>
</div>
<div class="paragraph">
<p><code>CciTemplate</code>还提供了创建方法<code>IndexRecord</code>和<code>MappedRecord</code>外面<code>RecordCreator</code>通过其实施<code>createIndexRecord(..)</code>和<code>createMappedRecord(..)</code>方法。您可以在DAO实现中使用它来创建<code>Record</code>实例传递到相应<code>CciTemplate.execute(..)</code>方法。以下清单显示了<code>CciTemplate</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CciTemplate implements CciOperations {

    public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }

    public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-using-dao"><a class="anchor" href="#cci-using-dao"></a> 5.2.3。使用DAO支持</h4>
<div class="paragraph">
<p>Spring的CCI支持为DAO提供了抽象类，支持注入<code>ConnectionFactory</code>或一个<code>CciTemplate</code>实例。班级的名字是<code>CciDaoSupport</code> 。它提供了简单<code>setConnectionFactory</code>和<code>setCciTemplate</code>方法。在内部，此类创建了一个<code>CciTemplate</code>传入实例<code>ConnectionFactory</code> ，将其暴露给子类中的具体数据访问实现。以下示例显示了如何使用<code>CciDaoSupport</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class CciDaoSupport {

    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        // ...
    }

    public ConnectionFactory getConnectionFactory() {
        // ...
    }

    public void setCciTemplate(CciTemplate cciTemplate) {
        // ...
    }

    public CciTemplate getCciTemplate() {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="automatic-output-generation"><a class="anchor" href="#automatic-output-generation"></a> 5.2.4。自动输出记录生成</h4>
<div class="paragraph">
<p>如果您使用的连接器仅支持<code>Interaction.execute(..)</code>将输入和输出记录作为参数的方法（也就是说，它需要传递所需的输出记录，而不是返回适当的输出记录），您可以设置<code>outputRecordCreator</code>的属性<code>CciTemplate</code>接收到响应后，将自动生成输出记录，以供JCA连接器填充。然后将该记录返回给模板的调用者。</p>
</div>
<div class="paragraph">
<p>该属性保存了<a href="#cci-record-creator"><code>RecordCreator</code> interface</a> ，用于该目的。您必须直接指定<code>outputRecordCreator</code>财产<code>CciTemplate</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，（在这种情况下，我们建议使用这种方法）在Spring配置中，如果<code>CciTemplate</code>被配置为专用bean实例，您可以按照以下方式定义bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="eciOutputRecordCreator" class="eci.EciOutputRecordCreator"/&gt;

&lt;bean id="cciTemplate" class="org.springframework.jca.cci.core.CciTemplate"&gt;
    &lt;property name="connectionFactory" ref="eciConnectionFactory"/&gt;
    &lt;property name="outputRecordCreator" ref="eciOutputRecordCreator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">作为<code>CciTemplate</code> class是线程安全的，通常将其配置为共享实例。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="template-summary"><a class="anchor" href="#template-summary"></a> 5.2.5。 <code>CciTemplate</code><code>Interaction</code> 摘要</h4>
<div class="paragraph">
<p>下表总结了<code>CciTemplate</code>类和在CCI上调用的相应方法<code>Interaction</code>接口：</p>
</div>
<table id="cci-interaction-execute-methods" class="tableblock frame-all grid-all spread">
<caption class="title">表9。交互执行方法的用法</caption>
<colgroup>
<col style="width:42.8571%">
<col style="width:14.2857%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>CciTemplate</code>方法签名</th>
<th class="tableblock halign-left valign-top"><code>CciTemplate</code><code>outputRecordCreator</code>属性</th>
<th class="tableblock halign-left valign-top"><code>execute</code> CCI交互上调用的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean execute(InteractionSpec, Record, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">无效执行（InteractionSpec，记录，记录）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无效执行（InteractionSpec，记录，记录）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void execute(InteractionSpec, Record, Record)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void execute(InteractionSpec, Record, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, RecordCreator)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, RecordCreator)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void execute(InteractionSpec, Record, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record, RecordExtractor)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record, RecordExtractor)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void execute(InteractionSpec, Record, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, RecordCreator, RecordExtractor)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, RecordCreator, RecordExtractor)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void execute(InteractionSpec, Record, Record)</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="cci-straight"><a class="anchor" href="#cci-straight"></a> 5.2.6。直接使用CCI连接和交互</h4>
<div class="paragraph">
<p><code>CciTemplate</code>还可以让您以与以下方式相同的方式直接处理CCI连接和交互<code>JdbcTemplate</code>和<code>JmsTemplate</code> 。例如，当您想对CCI连接或交互执行多个操作时，此功能很有用。</p>
</div>
<div class="paragraph">
<p>的<code>ConnectionCallback</code>接口提供CCI <code>Connection</code>作为参数（对其执行自定义操作）以及CCI <code>ConnectionFactory</code>与之<code>Connection</code>已创建。后者可能很有用（例如，获取关联的<code>RecordFactory</code>实例并创建索引/映射记录）。以下清单显示了<code>ConnectionCallback</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface ConnectionCallback {

    Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
            throws ResourceException, SQLException, DataAccessException;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>InteractionCallback</code>接口提供CCI <code>Interaction</code> （以对其执行自定义操作）以及相应的CCI <code>ConnectionFactory</code> 。以下清单显示了<code>InteractionCallback</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface InteractionCallback {

    Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
        throws ResourceException, SQLException, DataAccessException;

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>InteractionSpec</code>对象可以在多个模板调用之间共享，也可以在每个回调方法中重新创建。这完全取决于DAO的实现。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="cci-template-example"><a class="anchor" href="#cci-template-example"></a> 5.2.7。例子<code>CciTemplate</code>用法</h4>
<div class="paragraph">
<p>在本节中，我们将展示<code>CciTemplate</code>使用IBM CICS ECI连接器以ECI模式访问CICS。</p>
</div>
<div class="paragraph">
<p>首先，我们必须在CCI上进行一些初始化<code>InteractionSpec</code>指定要访问的CICS程序以及如何与之交互，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ECIInteractionSpec interactionSpec = new ECIInteractionSpec();
interactionSpec.setFunctionName("MYPROG");
interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后程序可以通过Spring的模板使用CCI并指定自定义对象和CCI之间的映射<code>Records</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public OutputObject getData(InputObject input) {
        ECIInteractionSpec interactionSpec = ...;

    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
        new RecordCreator() {
            public Record createRecord(RecordFactory recordFactory) throws ResourceException {
                return new CommAreaRecord(input.toString().getBytes());
            }
        },
        new RecordExtractor() {
            public Object extractData(Record record) throws ResourceException {
                CommAreaRecord commAreaRecord = (CommAreaRecord)record;
                String str = new String(commAreaRecord.toByteArray());
                String field1 = string.substring(0,6);
                String field2 = string.substring(6,1);
                return new OutputObject(Long.parseLong(field1), field2);
            }
        });

        return output;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，您可以使用回调直接在CCI连接或交互上工作。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public OutputObject getData(InputObject input) {
        ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
            new ConnectionCallback() {
                public Object doInConnection(Connection connection,
                        ConnectionFactory factory) throws ResourceException {

                    // do something...

                }
            });
        }
        return output;
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">用<code>ConnectionCallback</code> ， <code>Connection</code>使用的是由<code>CciTemplate</code> ，但回调实现必须管理在连接上创建的所有交互。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于更具体的回调，您可以实现<code>InteractionCallback</code> 。如果这样做，传入的<code>Interaction</code>由...管理和关闭<code>CciTemplate</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public String getData(String input) {
        ECIInteractionSpec interactionSpec = ...;
        String output = (String) getCciTemplate().execute(interactionSpec,
            new InteractionCallback() {
                public Object doInInteraction(Interaction interaction,
                        ConnectionFactory factory) throws ResourceException {
                    Record input = new CommAreaRecord(inputString.getBytes());
                    Record output = new CommAreaRecord();
                    interaction.execute(holder.getInteractionSpec(), input, output);
                    return new String(output.toByteArray());
                }
            });
        return output;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于前面的示例，在非托管模式下，所涉及的Spring Bean的相应配置可能类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
    &lt;property name="serverName" value="TXSERIES"/&gt;
    &lt;property name="connectionURL" value="local:"/&gt;
    &lt;property name="userName" value="CICSUSER"/&gt;
    &lt;property name="password" value="CICS"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
    &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="mypackage.MyDaoImpl"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在托管模式下（即，在Java EE环境中），配置可能类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cci-object"><a class="anchor" href="#cci-object"></a> 5.3。将CCI访问建模为操作对象</h3>
<div class="paragraph">
<p>的<code>org.springframework.jca.cci.object</code>软件包包含支持类，这些支持类使您可以以不同的方式访问EIS：通过可重用的操作对象，类似于Spring的JDBC操作对象（请参阅<a href="data-access.html#jdbc">“数据访问”一章</a>的<a href="data-access.html#jdbc">JDBC部分</a> ）。这通常封装了CCI API。将应用程序级输入对象传递给操作对象，因此它可以构造输入记录，然后将接收到的记录数据转换为应用程序级输出对象并返回它。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这种方法在内部基于<code>CciTemplate</code>类和<code>RecordCreator</code>要么<code>RecordExtractor</code>接口，重用Spring核心CCI支持的机制。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="cci-object-mapping-record"><a class="anchor" href="#cci-object-mapping-record"></a> 5.3.1。使用<code>MappingRecordOperation</code></h4>
<div class="paragraph">
<p><code>MappingRecordOperation</code>基本上执行与<code>CciTemplate</code>但将特定的，预先配置的操作表示为对象。它提供了两种模板方法来指定如何将输入对象转换为输入记录以及如何将输出记录转换为输出对象（记录映射）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>createInputRecord(..)</code> ：指定如何将输入对象转换为输入<code>Record</code></p>
</li>
<li>
<p><code>extractOutputData(..)</code> ：指定如何从输出中提取输出对象<code>Record</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下清单显示了这些方法的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class MappingRecordOperation extends EisOperation {

    ...

    protected abstract Record createInputRecord(RecordFactory recordFactory,
            Object inputObject) throws ResourceException, DataAccessException {
        // ...
    }

    protected abstract Object extractOutputData(Record outputRecord)
            throws ResourceException, SQLException, DataAccessException {
        // ...
    }

    ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，要执行EIS操作，您需要使用一个<code>execute</code>方法，传入应用程序级输入对象并接收应用程序级输出对象作为结果。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class MappingRecordOperation extends EisOperation {

    ...

    public Object execute(Object inputObject) throws DataAccessException {
    }

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与...相反<code>CciTemplate</code>这个班<code>execute(..)</code>方法没有<code>InteractionSpec</code>作为争论。相反， <code>InteractionSpec</code>对操作而言是全局的。您必须使用以下构造函数以特定的方式实例化操作对象<code>InteractionSpec</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">InteractionSpec spec = ...;
MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-object-mapping-comm-area"><a class="anchor" href="#cci-object-mapping-comm-area"></a> 5.3.2。使用<code>MappingCommAreaOperation</code></h4>
<div class="paragraph">
<p>某些连接器使用基于COMMAREA的记录，该记录表示一个字节数组，其中包含要发送到EIS的参数以及它返回的数据。Spring提供了一个特殊的操作类，可以直接在COMMAREA上工作而不是在记录上工作。的<code>MappingCommAreaOperation</code>类扩展了<code>MappingRecordOperation</code>类提供此特殊的COMMAREA支持。它隐式使用<code>CommAreaRecord</code>类作为输入和输出记录类型，并提供了两种新方法将输入对象转换为输入COMMAREA并将输出COMMAREA转换为输出对象。以下清单显示了相关的方法签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class MappingCommAreaOperation extends MappingRecordOperation {

    ...

    protected abstract byte[] objectToBytes(Object inObject)
            throws IOException, DataAccessException;

    protected abstract Object bytesToObject(byte[] bytes)
        throws IOException, DataAccessException;

    ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-automatic-record-gen"><a class="anchor" href="#cci-automatic-record-gen"></a> 5.3.3。自动输出记录生成</h4>
<div class="paragraph">
<p>作为每个<code>MappingRecordOperation</code>子类内部基于CciTemplate，与自动生成输出记录的方式相同<code>CciTemplate</code>可用。每个操作对象都提供一个对应的<code>setOutputRecordCreator(..)</code>方法。有关更多信息，请参见<a href="#automatic-output-generation">自动输出记录生成</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cci-object-summary"><a class="anchor" href="#cci-object-summary"></a> 5.3.4。摘要</h4>
<div class="paragraph">
<p>操作对象方法使用记录的方式与<code>CciTemplate</code>类。</p>
</div>
<table id="cci-interaction-methods" class="tableblock frame-all grid-all spread">
<caption class="title">表10。交互执行方法的用法</caption>
<colgroup>
<col style="width:42.8571%">
<col style="width:14.2857%">
<col style="width:42.8572%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>MappingRecordOperation</code>方法签名</th>
<th class="tableblock halign-left valign-top"><code>MappingRecordOperation</code><code>outputRecordCreator</code>属性</th>
<th class="tableblock halign-left valign-top"><code>execute</code> CCI交互上调用的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object execute(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Record execute(InteractionSpec, Record)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object execute(Object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean execute(InteractionSpec, Record, Record)</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="cci-objects-mappring-record-example"><a class="anchor" href="#cci-objects-mappring-record-example"></a> 5.3.5。例子<code>MappingRecordOperation</code>用法</h4>
<div class="paragraph">
<p>在本节中，我们展示如何使用<code>MappingRecordOperation</code>使用Blackbox CCI连接器访问数据库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该连接器的原始版本由Java EE SDK（1.3版）提供，可以从Oracle获得。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>首先，您必须在CCI上进行一些初始化<code>InteractionSpec</code>指定要执行的SQL请求。在下面的示例中，我们直接定义将请求的参数转换为CCI记录的方法以及将CCI结果记录转换为CCI实例的方法。 <code>Person</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonMappingOperation extends MappingRecordOperation {

    public PersonMappingOperation(ConnectionFactory connectionFactory) {
        setConnectionFactory(connectionFactory);
        CciInteractionSpec interactionSpec = new CciConnectionSpec();
        interactionSpec.setSql("select * from person where person_id=?");
        setInteractionSpec(interactionSpec);
    }

    protected Record createInputRecord(RecordFactory recordFactory,
            Object inputObject) throws ResourceException {
        Integer id = (Integer) inputObject;
        IndexedRecord input = recordFactory.createIndexedRecord("input");
        input.add(new Integer(id));
        return input;
    }

    protected Object extractOutputData(Record outputRecord)
            throws ResourceException, SQLException {
        ResultSet rs = (ResultSet) outputRecord;
        Person person = null;
        if (rs.next()) {
            Person person = new Person();
            person.setId(rs.getInt("person_id"));
            person.setLastName(rs.getString("person_last_name"));
            person.setFirstName(rs.getString("person_first_name"));
        }
        return person;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，应用程序可以使用人员标识符作为参数来执行操作对象。请注意，您可以将操作对象设置为共享实例，因为它是线程安全的。下面以人员标识符作为参数执行操作对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public Person getPerson(int id) {
        PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());
        Person person = (Person) query.execute(new Integer(id));
        return person;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在非托管模式下，Spring Bean的相应配置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="managedConnectionFactory"
        class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
    &lt;property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="driverName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
        class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
    &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
        class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
    &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
    &lt;property name="connectionSpec"&gt;
        &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
            &lt;property name="user" value="sa"/&gt;
            &lt;property name="password" value=""/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在托管模式下（即，在Java EE环境中），配置可以如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="targetConnectionFactory" jndi-name="eis/blackbox"/&gt;

&lt;bean id="connectionFactory"
        class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
    &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
    &lt;property name="connectionSpec"&gt;
        &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
            &lt;property name="user" value="sa"/&gt;
            &lt;property name="password" value=""/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cci-objects-mapping-comm-area-example"><a class="anchor" href="#cci-objects-mapping-comm-area-example"></a> 5.3.6。例子<code>MappingCommAreaOperation</code>用法</h4>
<div class="paragraph">
<p>在本节中，我们将展示如何使用<code>MappingCommAreaOperation</code>使用IBM CICS ECI连接器以ECI模式访问CICS。</p>
</div>
<div class="paragraph">
<p>首先，我们需要初始化CCI <code>InteractionSpec</code>指定要访问的CICS程序以及如何与之交互，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public abstract class EciMappingOperation extends MappingCommAreaOperation {

    public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
        setConnectionFactory(connectionFactory);
        ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),
        interactionSpec.setFunctionName(programName);
        interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
        interactionSpec.setCommareaLength(30);
        setInteractionSpec(interactionSpec);
        setOutputRecordCreator(new EciOutputRecordCreator());
    }

    private static class EciOutputRecordCreator implements RecordCreator {
        public Record createRecord(RecordFactory recordFactory) throws ResourceException {
            return new CommAreaRecord();
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以将抽象子类化<code>EciMappingOperation</code>类，用于指定自定义对象和<code>Records</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public OutputObject getData(Integer id) {
        EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), "MYPROG") {

            protected abstract byte[] objectToBytes(Object inObject) throws IOException {
                Integer id = (Integer) inObject;
                return String.valueOf(id);
            }

            protected abstract Object bytesToObject(byte[] bytes) throws IOException;
                String str = new String(bytes);
                String field1 = str.substring(0,6);
                String field2 = str.substring(6,1);
                String field3 = str.substring(7,1);
                return new OutputObject(field1, field2, field3);
            }
        });

        return (OutputObject) query.execute(new Integer(id));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在非托管模式下，Spring Bean的相应配置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
    &lt;property name="serverName" value="TXSERIES"/&gt;
    &lt;property name="connectionURL" value="local:"/&gt;
    &lt;property name="userName" value="CICSUSER"/&gt;
    &lt;property name="password" value="CICS"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
    &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在托管模式下（即，在Java EE环境中），配置可以如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cci-tx"><a class="anchor" href="#cci-tx"></a> 5.4。交易次数</h3>
<div class="paragraph">
<p>JCA为资源适配器指定了多个级别的事务支持。资源适配器支持的事务类型在其资源适配器中指定<code>ra.xml</code>文件。基本上有三个选项：无（例如，使用CICS EPI连接器），本地事务（例如，使用CICS ECI连接器）和全局事务（例如，使用IMS连接器）。以下示例配置了全局选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;connector&gt;
    &lt;resourceadapter&gt;
        &lt;!-- &lt;transaction-support&gt;NoTransaction&lt;/transaction-support&gt; --&gt;
        &lt;!-- &lt;transaction-support&gt;LocalTransaction&lt;/transaction-support&gt; --&gt;
        &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;
    &lt;resourceadapter&gt;
&lt;connector&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于全局事务，可以使用Spring的通用事务基础结构来划分事务， <code>JtaTransactionManager</code>作为后端（代理到下面的Java EE服务器的分布式事务处理协调器）。</p>
</div>
<div class="paragraph">
<p>对于单个CCI上的本地交易<code>ConnectionFactory</code> ，Spring为CCI提供了一种特定的交易管理策略，类似于<code>DataSourceTransactionManager</code>用于JDBC。 CCI API定义了本地事务对象和相应的本地事务划分方法。春天的<code>CciLocalTransactionManager</code>以完全符合Spring通用标准的方式执行此类本地CCI交易<code>PlatformTransactionManager</code>抽象。以下示例配置了一个<code>CciLocalTransactionManager</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/&gt;

&lt;bean id="eciTransactionManager"
        class="org.springframework.jca.cci.connection.CciLocalTransactionManager"&gt;
    &lt;property name="connectionFactory" ref="eciConnectionFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在Spring的任何事务划分工具中使用这两种事务策略，无论是声明式还是程序式。这是Spring通用的结果<code>PlatformTransactionManager</code>抽象，它使事务划分与实际执行策略脱钩。您可以在<code>JtaTransactionManager</code>和<code>CciLocalTransactionManager</code>根据需要，保持交易分界不变。</p>
</div>
<div class="paragraph">
<p>有关Spring交易功能的更多信息，请参见<a href="data-access.html#transaction">交易管理</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mail"><a class="anchor" href="#mail"></a> 6。电子邮件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍如何使用Spring Framework发送电子邮件。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">库依赖</div>
<div class="paragraph">
<p>为了使用Spring Framework的电子邮件库，以下JAR必须位于应用程序的类路径中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://javaee.github.io/javamail/">JavaMail</a>库</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该库可在网络上免费使用-例如，在Maven Central中， <code>com.sun.mail:javax.mail</code> 。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring框架提供了一个有用的实用程序库，用于发送电子邮件，使您不受底层邮件系统的限制，并负责代表客户端进行低级资源处理。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.mail</code> package是Spring框架的电子邮件支持的根级包。发送电子邮件的中央界面是<code>MailSender</code>接口。一个简单值对象，它封装了简单邮件的属性，例如<code>from</code>和<code>to</code> （加上许多其他）是<code>SimpleMailMessage</code>类。此程序包还包含已检查异常的层次结构，该层次结构提供了比较低级别的邮件系统异常更高级别的抽象，而根异常为<code>MailException</code> 。有关富邮件异常层次结构的更多信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/mail/MailException.html">javadoc</a> 。</p>
</div>
<div class="paragraph">
<p>的<code>org.springframework.mail.javamail.JavaMailSender</code>介面将专用的JavaMail功能（例如MIME讯息支援）新增至<code>MailSender</code>接口（从中继承）。 <code>JavaMailSender</code>还提供了一个名为<code>org.springframework.mail.javamail.MimeMessagePreparator</code>准备一个<code>MimeMessage</code> 。</p>
</div>
<div class="sect2">
<h3 id="mail-usage"><a class="anchor" href="#mail-usage"></a> 6.1。用法</h3>
<div class="paragraph">
<p>假设我们有一个名为<code>OrderManager</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface OrderManager {

    void placeOrder(Order order);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>进一步假设我们有一项要求，说明需要生成带有订单号的电子邮件消息并将其发送给下订单的客户。</p>
</div>
<div class="sect3">
<h4 id="mail-usage-simple"><a class="anchor" href="#mail-usage-simple"></a> 6.1.1。基本的<code>MailSender</code>和<code>SimpleMailMessage</code>用法</h4>
<div class="paragraph">
<p>以下示例显示了如何使用<code>MailSender</code>和<code>SimpleMailMessage</code>在某人下订单时发送电子邮件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class SimpleOrderManager implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage templateMessage;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setTemplateMessage(SimpleMailMessage templateMessage) {
        this.templateMessage = templateMessage;
    }

    public void placeOrder(Order order) {

        // Do the business calculations...

        // Call the collaborators to persist the order...

        // Create a thread safe "copy" of the template message and customize it
        SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear " + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            this.mailSender.send(msg);
        }
        catch (MailException ex) {
            // simply log it and go on...
            System.err.println(ex.getMessage());
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了上述代码的bean定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
    &lt;property name="host" value="mail.mycompany.example"/&gt;
&lt;/bean&gt;

&lt;!-- this is a template message that we can pre-load with default state --&gt;
&lt;bean id="templateMessage" class="org.springframework.mail.SimpleMailMessage"&gt;
    &lt;property name="from" value="customerservice@mycompany.example"/&gt;
    &lt;property name="subject" value="Your order"/&gt;
&lt;/bean&gt;

&lt;bean id="orderManager" class="com.mycompany.businessapp.support.SimpleOrderManager"&gt;
    &lt;property name="mailSender" ref="mailSender"/&gt;
    &lt;property name="templateMessage" ref="templateMessage"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-usage-mime"><a class="anchor" href="#mail-usage-mime"></a> 6.1.2。使用<code>JavaMailSender</code>和<code>MimeMessagePreparator</code></h4>
<div class="paragraph">
<p>本节介绍了<code>OrderManager</code>使用<code>MimeMessagePreparator</code>回调接口。在以下示例中， <code>mailSender</code>属性类型<code>JavaMailSender</code>这样我们就可以使用JavaMail <code>MimeMessage</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;

public class SimpleOrderManager implements OrderManager {

    private JavaMailSender mailSender;

    public void setMailSender(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void placeOrder(final Order order) {
        // Do the business calculations...
        // Call the collaborators to persist the order...

        MimeMessagePreparator preparator = new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws Exception {
                mimeMessage.setRecipient(Message.RecipientType.TO,
                        new InternetAddress(order.getCustomer().getEmailAddress()));
                mimeMessage.setFrom(new InternetAddress("mail@mycompany.example"));
                mimeMessage.setText("Dear " + order.getCustomer().getFirstName() + " " +
                        order.getCustomer().getLastName() + ", thanks for your order. " +
                        "Your order number is " + order.getOrderNumber() + ".");
            }
        };

        try {
            this.mailSender.send(preparator);
        }
        catch (MailException ex) {
            // simply log it and go on...
            System.err.println(ex.getMessage());
        }
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">邮件代码是一个横切关注点，很可能是将其重构为<a href="core.html#aop">自定义Spring AOP方面</a>的候选项，然后可以在相应的连接点上执行该代码。 <code>OrderManager</code>目标。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Framework的邮件支持随附于标准JavaMail实现。有关更多信息，请参见相关的Javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mail-javamail-mime"><a class="anchor" href="#mail-javamail-mime"></a> 6.2。使用JavaMail<code>MimeMessageHelper</code></h3>
<div class="paragraph">
<p>处理JavaMail消息时非常方便的类是<code>org.springframework.mail.javamail.MimeMessageHelper</code> ，使您不必使用冗长的JavaMail API。使用<code>MimeMessageHelper</code> ，创建一个很容易<code>MimeMessage</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// of course you would use DI in any real-world cases
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message);
helper.setTo("test@host.com");
helper.setText("Thank you for ordering!");

sender.send(message);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="mail-javamail-mime-attachments"><a class="anchor" href="#mail-javamail-mime-attachments"></a> 6.2.1。发送附件和内联资源</h4>
<div class="paragraph">
<p>多部分电子邮件同时允许附件和内联资源。内联资源的示例包括您要在邮件中使用但不希望显示为附件的图像或样式表。</p>
</div>
<div class="sect4">
<h5 id="mail-javamail-mime-attachments-attachment"><a class="anchor" href="#mail-javamail-mime-attachments-attachment"></a>附件</h5>
<div class="paragraph">
<p>以下示例显示了如何使用<code>MimeMessageHelper</code>发送带有单个JPEG图像附件的电子邮件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

// use the true flag to indicate you need a multipart message
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

helper.setText("Check out this image!");

// let's attach the infamous windows Sample file (this time copied to c:/)
FileSystemResource file = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addAttachment("CoolImage.jpg", file);

sender.send(message);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mail-javamail-mime-attachments-inline"><a class="anchor" href="#mail-javamail-mime-attachments-inline"></a>内联资源</h5>
<div class="paragraph">
<p>以下示例显示了如何使用<code>MimeMessageHelper</code>发送带有嵌入式图像的电子邮件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

// use the true flag to indicate you need a multipart message
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

// use the true flag to indicate the text included is HTML
helper.setText("&lt;html&gt;&lt;body&gt;&lt;img src='cid:identifier1234'&gt;&lt;/body&gt;&lt;/html&gt;", true);

// let's include the infamous windows Sample file (this time copied to c:/)
FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addInline("identifier1234", res);

sender.send(message);</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">内联资源已添加到<code>MimeMessage</code>通过使用指定的<code>Content-ID</code> （ <code>identifier1234</code>在上面的示例中）。添加文本和资源的顺序非常重要。确保首先添加文本，然后添加资源。如果您正相反进行操作，则此操作无效。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mail-templates"><a class="anchor" href="#mail-templates"></a> 6.2.2。使用模板库创建电子邮件内容</h4>
<div class="paragraph">
<p>上一节中显示的示例中的代码通过使用以下方法调用来显式创建电子邮件的内容： <code>message.setText(..)</code> 。这对于简单的情况很好，并且在上述示例的上下文中也可以，其目的是向您展示API的基本知识。</p>
</div>
<div class="paragraph">
<p>但是，在典型的企业应用程序中，由于多种原因，开发人员通常不使用以前显示的方法来创建电子邮件的内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用Java代码创建基于HTML的电子邮件内容很繁琐且容易出错。</p>
</li>
<li>
<p>显示逻辑和业务逻辑之间没有明确区分。</p>
</li>
<li>
<p>更改电子邮件内容的显示结构需要编写Java代码，重新编译，重新部署等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，解决这些问题的方法是使用模板库（例如FreeMarker）来定义电子邮件内容的显示结构。这使您的代码只能执行创建要在电子邮件模板中呈现的数据并发送电子邮件的任务。当您的电子邮件的内容变得相当复杂时，这绝对是最佳实践，而且，借助Spring Framework的FreeMarker支持类，它变得非常容易实现。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scheduling"><a class="anchor" href="#scheduling"></a> 7。任务执行和计划</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring框架为任务的异步执行和计划提供了抽象。 <code>TaskExecutor</code>和<code>TaskScheduler</code>接口。Spring还提供了那些接口的实现，这些接口在应用程序服务器环境中支持线程池或委托给CommonJ。最终，在公共接口后面使用这些实现可以抽象化Java SE 5，Java SE 6和Java EE环境之间的差异。</p>
</div>
<div class="paragraph">
<p>Spring还具有集成类，以支持与<code>Timer</code> （从1.3开始成为JDK的一部分）和Quartz Scheduler（ <a href="https://www.quartz-scheduler.org/" class="bare">https://www.quartz-scheduler.org/</a> ）。您可以使用<code>FactoryBean</code>可选引用<code>Timer</code>要么<code>Trigger</code>实例。此外，Quartz Scheduler和<code>Timer</code>可用于调用现有目标对象的方法（类似于普通对象<code>MethodInvokingFactoryBean</code>操作）。</p>
</div>
<div class="sect2">
<h3 id="scheduling-task-executor"><a class="anchor" href="#scheduling-task-executor"></a> 7.1。春天<code>TaskExecutor</code>抽象化</h3>
<div class="paragraph">
<p>执行程序是线程池概念的JDK名称。“执行程序”的命名是由于无法保证基础实现实际上是一个池。执行程序可能是单线程的，甚至是同步的。Spring的抽象隐藏了Java SE和Java EE环境之间的实现细节。</p>
</div>
<div class="paragraph">
<p>春天的<code>TaskExecutor</code>界面与<code>java.util.concurrent.Executor</code>接口。实际上，最初，其存在的主要原因是在使用线程池时抽象出对Java 5的需求。该接口具有单一方法（ <code>execute(Runnable task)</code> ），该线程根据线程池的语义和配置接受要执行的任务。</p>
</div>
<div class="paragraph">
<p>的<code>TaskExecutor</code>最初创建是为了在需要时为其他Spring组件提供线程池的抽象。诸如<code>ApplicationEventMulticaster</code> ，JMS的<code>AbstractMessageListenerContainer</code>和Quartz集成都使用<code>TaskExecutor</code>池线程的抽象。但是，如果您的bean需要线程池行为，则也可以根据自己的需要使用此抽象。</p>
</div>
<div class="sect3">
<h4 id="scheduling-task-executor-types"><a class="anchor" href="#scheduling-task-executor-types"></a> 7.1.1。 <code>TaskExecutor</code> 种类</h4>
<div class="paragraph">
<p>Spring包含许多预先构建的实现<code>TaskExecutor</code> 。您极有可能无需实现自己的方法。Spring提供的变体如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SyncTaskExecutor</code> ：此实现不会异步执行调用。而是，每个调用都在调用线程中进行。它主要用于不需要多线程的情况下，例如在简单的测试案例中。</p>
</li>
<li>
<p><code>SimpleAsyncTaskExecutor</code>注意：此实现不重用任何线程。而是，它为每次调用启动一个新线程。但是，它确实支持并发限制，该限制会阻止超出限制的所有调用，直到释放插槽为止。如果您正在寻找真正的池，请参阅<code>ThreadPoolTaskExecutor</code> ，在此列表的后面。</p>
</li>
<li>
<p><code>ConcurrentTaskExecutor</code> ：此实现是针对<code>java.util.concurrent.Executor</code>实例。还有一种选择（ <code>ThreadPoolTaskExecutor</code> ） <code>Executor</code>配置参数作为bean属性。很少需要使用<code>ConcurrentTaskExecutor</code>直。但是，如果<code>ThreadPoolTaskExecutor</code>不够灵活，无法满足您的需求， <code>ConcurrentTaskExecutor</code>是另一种选择。</p>
</li>
<li>
<p><code>ThreadPoolTaskExecutor</code> ：此实现是最常用的。它公开了用于配置<code>java.util.concurrent.ThreadPoolExecutor</code>并包裹在一个<code>TaskExecutor</code> 。如果您需要适应另一种<code>java.util.concurrent.Executor</code> ，我们建议您使用<code>ConcurrentTaskExecutor</code>代替。</p>
</li>
<li>
<p><code>WorkManagerTaskExecutor</code> ：此实现使用CommonJ <code>WorkManager</code>作为其支持服务提供者，并且是在Spring应用程序上下文中的WebLogic或WebSphere上设置基于CommonJ的线程池集成的中央便利类。</p>
</li>
<li>
<p><code>DefaultManagedTaskExecutor</code> ：此实现使用JNDI获得<code>ManagedExecutorService</code>在与JSR-236兼容的运行时环境（例如Java EE 7+应用程序服务器）中，为此目的替换了CommonJ WorkManager。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-executor-usage"><a class="anchor" href="#scheduling-task-executor-usage"></a> 7.1.2。用一个<code>TaskExecutor</code></h4>
<div class="paragraph">
<p>春天的<code>TaskExecutor</code>实现用作简单的JavaBean。在以下示例中，我们定义了一个使用<code>ThreadPoolTaskExecutor</code>异步打印出一组消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.core.task.TaskExecutor;

public class TaskExecutorExample {

    private class MessagePrinterTask implements Runnable {

        private String message;

        public MessagePrinterTask(String message) {
            this.message = message;
        }

        public void run() {
            System.out.println(message);
        }
    }

    private TaskExecutor taskExecutor;

    public TaskExecutorExample(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    public void printMessages() {
        for(int i = 0; i &lt; 25; i++) {
            taskExecutor.execute(new MessagePrinterTask("Message" + i));
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，您添加了自己的代码，而不是从池中检索线程并自己执行它<code>Runnable</code>排队。然后<code>TaskExecutor</code>使用其内部规则来决定何时执行任务。</p>
</div>
<div class="paragraph">
<p>要配置的规则<code>TaskExecutor</code>用途，我们公开了简单的bean属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
    &lt;property name="corePoolSize" value="5"/&gt;
    &lt;property name="maxPoolSize" value="10"/&gt;
    &lt;property name="queueCapacity" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="taskExecutorExample" class="TaskExecutorExample"&gt;
    &lt;constructor-arg ref="taskExecutor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-scheduler"><a class="anchor" href="#scheduling-task-scheduler"></a> 7.2。春天<code>TaskScheduler</code>抽象化</h3>
<div class="paragraph">
<p>除了<code>TaskExecutor</code>抽象，Spring 3.0引入了<code>TaskScheduler</code>使用多种方法来计划任务在将来某个时间点运行。以下清单显示了<code>TaskScheduler</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface TaskScheduler {

    ScheduledFuture schedule(Runnable task, Trigger trigger);

    ScheduledFuture schedule(Runnable task, Instant startTime);

    ScheduledFuture schedule(Runnable task, Date startTime);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最简单的方法是命名为<code>schedule</code>只需要一个<code>Runnable</code>和一个<code>Date</code> 。这将导致任务在指定时间后运行一次。所有其他方法都可以安排任务重复运行。固定速率和固定延迟方法是用于简单，定期执行的，但是接受<code>Trigger</code>更灵活。</p>
</div>
<div class="sect3">
<h4 id="scheduling-trigger-interface"><a class="anchor" href="#scheduling-trigger-interface"></a> 7.2.1。 <code>Trigger</code> 接口</h4>
<div class="paragraph">
<p>的<code>Trigger</code>接口本质上是受JSR-236（从Spring 3.0开始尚未正式实现）的启发。的基本思想<code>Trigger</code>可以根据过去的执行结果甚至任意条件来确定执行时间。如果这些确定确实考虑了先前执行的结果，则该信息可在<code>TriggerContext</code> 。的<code>Trigger</code>界面本身非常简单，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Trigger {

    Date nextExecutionTime(TriggerContext triggerContext);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>TriggerContext</code>是最重要的部分。它封装了所有相关数据，并在将来必要时开放以进行扩展。的<code>TriggerContext</code>是一个接口（一个<code>SimpleTriggerContext</code>默认情况下使用实现）。以下清单显示了可用的方法<code>Trigger</code>实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface TriggerContext {

    Date lastScheduledExecutionTime();

    Date lastActualExecutionTime();

    Date lastCompletionTime();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-trigger-implementations"><a class="anchor" href="#scheduling-trigger-implementations"></a> 7.2.2。 <code>Trigger</code> 实作</h4>
<div class="paragraph">
<p>Spring提供了两种实现<code>Trigger</code>接口。最有趣的是<code>CronTrigger</code> 。它启用了基于cron表达式的任务调度。例如，以下任务计划在每小时的15分钟后运行，但仅在工作日的9到5个“工作时间”内运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">scheduler.schedule(task, new CronTrigger("0 15 9-17 * * MON-FRI"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种实现是<code>PeriodicTrigger</code>接受一个固定周期，一个可选的初始延迟值和一个布尔值，以指示该周期是应解释为固定速率还是固定延迟。自从<code>TaskScheduler</code>接口已经定义了以固定速率或固定延迟计划任务的方法，这些方法应尽可能直接使用。的价值<code>PeriodicTrigger</code>实现是您可以在依赖于<code>Trigger</code>抽象。例如，允许定期触发器，基于cron的触发器，甚至是自定义触发器实现可互换使用可能很方便。这样的组件可以利用依赖注入的优势，以便您可以配置<code>Triggers</code>外部，因此，可以轻松修改或扩展它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-scheduler-implementations"><a class="anchor" href="#scheduling-task-scheduler-implementations"></a> 7.2.3。 <code>TaskScheduler</code>实作</h4>
<div class="paragraph">
<p>就像春天的<code>TaskExecutor</code>抽象，它的主要好处<code>TaskScheduler</code>安排是将应用程序的调度需求与部署环境分离。当部署到不应由应用程序本身直接创建线程的应用程序服务器环境时，此抽象级别特别重要。对于这种情况，Spring提供了一个<code>TimerManagerTaskScheduler</code>委托给CommonJ <code>TimerManager</code>在WebLogic或WebSphere以及更新版本中<code>DefaultManagedTaskScheduler</code>委托给JSR-236 <code>ManagedScheduledExecutorService</code>在Java EE 7+环境中。两者通常都配置有JNDI查找。</p>
</div>
<div class="paragraph">
<p>每当不需要外部线程管理时，更简单的选择是本地<code>ScheduledExecutorService</code>在应用程序中进行设置，可以通过Spring的<code>ConcurrentTaskScheduler</code> 。为了方便起见，Spring还提供了一个<code>ThreadPoolTaskScheduler</code> ，在内部将其委派给<code>ScheduledExecutorService</code>按照以下方式提供通用的bean样式配置<code>ThreadPoolTaskExecutor</code> 。这些变体也适用于宽松的应用程序服务器环境中的本地嵌入式线程池设置，尤其是在Tomcat和Jetty上。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-annotation-support"><a class="anchor" href="#scheduling-annotation-support"></a> 7.3。计划和异步执行的注释支持</h3>
<div class="paragraph">
<p>Spring为任务调度和异步方法执行提供注释支持。</p>
</div>
<div class="sect3">
<h4 id="scheduling-enable-annotation-support"><a class="anchor" href="#scheduling-enable-annotation-support"></a> 7.3.1。启用计划注释</h4>
<div class="paragraph">
<p>启用对<code>@Scheduled</code>和<code>@Async</code>注释，您可以添加<code>@EnableScheduling</code>和<code>@EnableAsync</code>给你的一个<code>@Configuration</code>类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableAsync
@EnableScheduling
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以选择与您的应用程序相关的注释。例如，如果您只需要支持<code>@Scheduled</code> ，您可以省略<code>@EnableAsync</code> 。要进行更细粒度的控制，您可以另外实施<code>SchedulingConfigurer</code>界面<code>AsyncConfigurer</code>界面，或两者兼而有之。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html"><code>SchedulingConfigurer</code></a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html"><code>AsyncConfigurer</code></a>有关详细信息，请参见javadoc。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢XML配置，则可以使用<code><task:annotation-driven></code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:annotation-driven executor="myExecutor" scheduler="myScheduler"/&gt;
&lt;task:executor id="myExecutor" pool-size="5"/&gt;
&lt;task:scheduler id="myScheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在上述XML中，提供了执行程序参考，用于处理与带有方法的方法相对应的任务。 <code>@Async</code>注释，并且提供了调度程序参考来管理那些使用注释的方法<code>@Scheduled</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">处理的默认建议模式<code>@Async</code>注释是<code>proxy</code>仅允许通过代理拦截呼叫。同一类内的本地调用无法以这种方式被拦截。要获得更高级的拦截模式，请考虑切换到<code>aspectj</code>模式结合编译时或加载时编织。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-scheduled"><a class="anchor" href="#scheduling-annotation-support-scheduled"></a> 7.3.2。的<code>@Scheduled</code>注解</h4>
<div class="paragraph">
<p>您可以添加<code>@Scheduled</code>方法的注释以及触发器元数据。例如，以下方法每隔五秒钟以固定的延迟被调用一次，这意味着该时间段是从每个先前调用的完成时间开始计算的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Scheduled(fixedDelay=5000)
public void doSomething() {
    // something that should execute periodically
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要固定汇率执行，则可以更改注释中指定的属性名称。每五秒钟调用一次以下方法（在每次调用的连续开始时间之间测量）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Scheduled(fixedRate=5000)
public void doSomething() {
    // something that should execute periodically
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于固定延迟和固定速率的任务，可以通过指示在第一次执行该方法之前要等待的毫秒数来指定初始延迟，如下所示<code>fixedRate</code>示例显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Scheduled(initialDelay=1000, fixedRate=5000)
public void doSomething() {
    // something that should execute periodically
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果简单的定期调度不足以表现出来，则可以提供cron表达式。例如，以下仅在工作日执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Scheduled(cron="*/5 * * * * MON-FRI")
public void doSomething() {
    // something that should execute on weekdays only
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您也可以使用<code>zone</code>属性，用于指定在其中解析cron表达式的时区。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，要调度的方法必须具有空返回值，并且不能期望任何参数。如果该方法需要与应用程序上下文中的其他对象进行交互，则通常将通过依赖项注入来提供这些对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.3开始， <code>@Scheduled</code>任何范围的bean都支持这些方法。</p>
</div>
<div class="paragraph">
<p>确保您没有初始化同一实例的多个实例<code>@Scheduled</code>注释类在运行时，除非您确实希望为每个此类实例安排回调。与此相关，请确保您不使用<code>@Configurable</code>在用注释的bean类上<code>@Scheduled</code>并在容器中注册为常规Spring Bean。否则，您将获得双重初始化（一次通过容器，一次通过<code>@Configurable</code>方面），各有其结果<code>@Scheduled</code>方法被调用两次。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-async"><a class="anchor" href="#scheduling-annotation-support-async"></a> 7.3.3。的<code>@Async</code>注解</h4>
<div class="paragraph">
<p>您可以提供<code>@Async</code>在方法上添加注释，以便异步调用该方法。换句话说，调用者在调用时立即返回，而方法的实际执行发生在已提交给Spring的任务中<code>TaskExecutor</code> 。在最简单的情况下，您可以将注释应用于返回的方法<code>void</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Async
void doSomething() {
    // this will be executed asynchronously
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与方法注释不同<code>@Scheduled</code>注释中，这些方法可以使用参数，因为它们是在运行时由调用方以“常规”方式调用的，而不是从容器管理的计划任务中调用的。例如，以下代码是<code>@Async</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Async
void doSomething(String s) {
    // this will be executed asynchronously
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使返回值的方法也可以异步调用。但是，此类方法必须具有<code>Future</code>类型的返回值。这仍然提供了异步执行的好处，因此调用者可以在调用之前执行其他任务<code>get()</code>在那<code>Future</code> 。以下示例显示了如何使用<code>@Async</code>在返回值的方法上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Async
Future&lt;String&gt; returnSomething(int i) {
    // this will be executed asynchronously
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>@Async</code>方法不仅可以声明一个常规<code>java.util.concurrent.Future</code>返回类型，但也有Spring的<code>org.springframework.util.concurrent.ListenableFuture</code>或者，从Spring 4.2开始，JDK 8 <code>java.util.concurrent.CompletableFuture</code> ，以便与异步任务进行更丰富的交互，并通过进一步的处理步骤立即进行合成。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>你不能使用<code>@Async</code>结合生命周期回调，例如<code>@PostConstruct</code> 。要异步初始化Spring Bean，当前必须使用单独的初始化Spring Bean，然后再调用<code>@Async</code>目标上的带注释的方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SampleBeanImpl implements SampleBean {

    @Async
    void doSomething() {
        // ...
    }

}

public class SampleBeanInitializer {

    private final SampleBean bean;

    public SampleBeanInitializer(SampleBean bean) {
        this.bean = bean;
    }

    @PostConstruct
    public void initialize() {
        bean.doSomething();
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">没有与之等效的直接XML <code>@Async</code> ，因为此类方法应首先设计用于异步执行，而不是在外部重新声明为异步。但是，您可以手动设置Spring的<code>AsyncExecutionInterceptor</code>与Spring AOP结合使用，以及自定义切入点。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-qualification"><a class="anchor" href="#scheduling-annotation-support-qualification"></a> 7.3.4。执行者资格<code>@Async</code></h4>
<div class="paragraph">
<p>默认情况下，当指定<code>@Async</code>在一种方法上，使用的执行程序是<a href="#scheduling-enable-annotation-support">启用异步支持时配置</a>的执行程序，即，如果您使用的是XML或<code>AsyncConfigurer</code>实施（如果有）。但是，您可以使用<code>value</code>的属性<code>@Async</code>注释，当您需要指示在执行给定方法时应使用默认值以外的执行器时。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Async("otherExecutor")
void doSomething(String s) {
    // this will be executed asynchronously by "otherExecutor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>"otherExecutor"</code>可以是任何名称<code>Executor</code> Spring容器中的bean，或者它可能是与任何容器关联的限定符的名称<code>Executor</code> （例如，根据<code><qualifier></code>元素或春天的<code>@Qualifier</code>注解）。</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-annotation-support-exception"><a class="anchor" href="#scheduling-annotation-support-exception"></a> 7.3.5。异常管理<code>@Async</code></h4>
<div class="paragraph">
<p>当一个<code>@Async</code>方法有一个<code>Future</code>类型的返回值，很容易管理在方法执行期间引发的异常，因为在调用时会引发此异常<code>get</code>在<code>Future</code>结果。用<code>void</code>返回类型，但是，未捕获到异常，无法将其发送。您可以提供<code>AsyncUncaughtExceptionHandler</code>处理此类异常。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        // handle exception
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，仅记录异常。您可以定义一个自定义<code>AsyncUncaughtExceptionHandler</code>通过使用<code>AsyncConfigurer</code>或者<code><task:annotation-driven/></code> XML元素。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-task-namespace"><a class="anchor" href="#scheduling-task-namespace"></a> 7.4。的<code>task</code>命名空间</h3>
<div class="paragraph">
<p>从3.0版开始，Spring包含用于配置的XML名称空间<code>TaskExecutor</code>和<code>TaskScheduler</code>实例。它还提供了一种方便的方法来配置要通过触发器安排的任务。</p>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-scheduler"><a class="anchor" href="#scheduling-task-namespace-scheduler"></a> 7.4.1。“调度程序”元素</h4>
<div class="paragraph">
<p>以下元素创建一个<code>ThreadPoolTaskScheduler</code>具有指定线程池大小的实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:scheduler id="scheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供给<code>id</code>属性用作池中线程名称的前缀。的<code>scheduler</code>元素相对简单。如果您不提供<code>pool-size</code>属性，默认线程池只有一个线程。调度程序没有其他配置选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-executor"><a class="anchor" href="#scheduling-task-namespace-executor"></a> 7.4.2。的<code>executor</code>元件</h4>
<div class="paragraph">
<p>以下创建一个<code>ThreadPoolTaskExecutor</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:executor id="executor" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>与<a href="#scheduling-task-namespace-scheduler">上一节中</a>显示的调度程序一样，为<code>id</code>属性用作池中线程名称的前缀。就池的大小而言， <code>executor</code>元素支持的配置选项比<code>scheduler</code>元件。一方面，一个线程池<code>ThreadPoolTaskExecutor</code>本身更具可配置性。执行者的线程池不仅可以具有单个大小，而且可以具有不同的核心和最大大小值。如果提供单个值，则执行程序具有固定大小的线程池（核心大小和最大大小相同）。然而<code>executor</code>元素的<code>pool-size</code>属性还接受以下形式的范围<code>min-max</code> 。以下示例将最小值设置为<code>5</code>和最大值<code>25</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:executor
        id="executorWithPoolSizeRange"
        pool-size="5-25"
        queue-capacity="100"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述配置中， <code>queue-capacity</code>还提供了价值。还应根据执行者的队列容量来考虑线程池的配置。有关池大小和队列容量之间关系的完整说明，请参阅有关以下内容的文档： <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html"><code>ThreadPoolExecutor</code></a> 。主要思想是，在提交任务时，如果活动线程数当前小于核心大小，则执行程序首先尝试使用空闲线程。如果已达到核心大小，则只要尚未达到其容量，就将任务添加到队列中。只有这样，如果达到队列的容量，执行程序才创建超出核心大小的新线程。如果还达到了最大大小，那么执行者将拒绝该任务。</p>
</div>
<div class="paragraph">
<p>默认情况下，队列是无界的，但这很少是所需的配置，因为它可能导致<code>OutOfMemoryErrors</code>如果在所有池线程繁忙时将足够的任务添加到该队列。此外，如果队列是无界的，则最大大小完全无效。由于执行程序总是在创建超出核心大小的新线程之前尝试队列，因此队列必须具有有限的容量，线程池才能超出核心大小（这就是为什么使用固定大小的池是唯一明智的情况无限队列）。</p>
</div>
<div class="paragraph">
<p>如上所述，考虑拒绝任务的情况。默认情况下，当任务被拒绝时，线程池执行程序会抛出一个<code>TaskRejectedException</code> 。但是，拒绝策略实际上是可配置的。使用默认拒绝策略（即<code>AbortPolicy</code>实施。对于在高负载下可以跳过某些任务的应用程序，您可以配置<code>DiscardPolicy</code>要么<code>DiscardOldestPolicy</code> 。对于需要在重负载下限制提交的任务的应用程序来说，另一个很好的选择是<code>CallerRunsPolicy</code> 。该策略不会引发异常或放弃任务，而是强制调用提交方法的线程运行任务本身。想法是，这样的调用者在运行该任务时很忙，无法立即提交其他任务。因此，它提供了一种在保持线程池和队列限制的同时限制传入负载的简单方法。通常，这允许执行者“赶上”它正在处理的任务，从而释放队列，池中或两者中的某些容量。您可以从可用于<code>rejection-policy</code>的属性<code>executor</code>元件。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>executor</code>元素，具有许多用于指定各种行为的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:executor
        id="executorWithCallerRunsPolicy"
        pool-size="5-25"
        queue-capacity="100"
        rejection-policy="CALLER_RUNS"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后， <code>keep-alive</code>设置确定线程在终止之前可以保持空闲状态的时间限制（以秒为单位）。如果当前池中的线程数超过核心数，则在等待此时间而不处理任务之后，多余的线程将被终止。时间值为零会导致多余的线程在执行任务后立即终止，而不会在任务队列中保留后续工作。以下示例设置了<code>keep-alive</code>价值两分钟：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:executor
        id="executorWithKeepAlive"
        pool-size="5-25"
        keep-alive="120"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-task-namespace-scheduled-tasks"><a class="anchor" href="#scheduling-task-namespace-scheduled-tasks"></a> 7.4.3。“计划任务”元素</h4>
<div class="paragraph">
<p>Spring任务名称空间最强大的功能是支持配置要在Spring Application Context中调度的任务。这遵循类似于Spring中其他“方法调用者”的方法，例如JMS命名空间提供的用于配置消息驱动的POJO的方法。基本上，一个<code>ref</code>属性可以指向任何Spring管理的对象，并且<code>method</code>属性提供要在该对象上调用的方法的名称。以下清单显示了一个简单的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:scheduled-tasks scheduler="myScheduler"&gt;
    &lt;task:scheduled ref="beanA" method="methodA" fixed-delay="5000"/&gt;
&lt;/task:scheduled-tasks&gt;

&lt;task:scheduler id="myScheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>调度程序由外部元素引用，并且每个单独的任务都包括其触发元数据的配置。在前面的示例中，该元数据定义了一个具有固定延迟的周期性触发器，该延迟指示了每个任务执行完成后要等待的毫秒数。另一种选择是<code>fixed-rate</code> ，指示该方法应多久执行一次，而不管先前的执行需要多长时间。此外，对于两者<code>fixed-delay</code>和<code>fixed-rate</code>任务，您可以指定一个“ initial-delay”参数，指示首次执行该方法之前要等待的毫秒数。要获得更多控制权，您可以提供一个<code>cron</code>属性。以下示例显示了这些其他选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;task:scheduled-tasks scheduler="myScheduler"&gt;
    &lt;task:scheduled ref="beanA" method="methodA" fixed-delay="5000" initial-delay="1000"/&gt;
    &lt;task:scheduled ref="beanB" method="methodB" fixed-rate="5000"/&gt;
    &lt;task:scheduled ref="beanC" method="methodC" cron="*/5 * * * * MON-FRI"/&gt;
&lt;/task:scheduled-tasks&gt;

&lt;task:scheduler id="myScheduler" pool-size="10"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scheduling-quartz"><a class="anchor" href="#scheduling-quartz"></a> 7.5。使用Quartz Scheduler</h3>
<div class="paragraph">
<p>石英用途<code>Trigger</code> ， <code>Job</code>和<code>JobDetail</code>对象以实现各种作业的调度。有关Quartz的基本概念，请参见<a href="https://www.quartz-scheduler.org/" class="bare">https://www.quartz-scheduler.org/</a> 。为了方便起见，Spring提供了两个类，这些类简化了在基于Spring的应用程序中使用Quartz的过程。</p>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-jobdetail"><a class="anchor" href="#scheduling-quartz-jobdetail"></a> 7.5.1。使用<code>JobDetailFactoryBean</code></h4>
<div class="paragraph">
<p>石英<code>JobDetail</code>对象包含运行作业所需的所有信息。春天提供了<code>JobDetailFactoryBean</code> ，它提供用于XML配置目的的bean样式属性。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"&gt;
    &lt;property name="jobClass" value="example.ExampleJob"/&gt;
    &lt;property name="jobDataAsMap"&gt;
        &lt;map&gt;
            &lt;entry key="timeout" value="5"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>作业详细信息配置包含运行作业所需的所有信息（ <code>ExampleJob</code> ）。超时在作业数据映射中指定。作业数据图可通过<code>JobExecutionContext</code> （在执行时传递给您），但是<code>JobDetail</code>还从映射到作业实例属性的作业数据获取其属性。因此，在以下示例中， <code>ExampleJob</code>包含一个名为<code>timeout</code>和<code>JobDetail</code>是否自动应用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package example;

public class ExampleJob extends QuartzJobBean {

    private int timeout;

    /**
     * Setter called after the ExampleJob is instantiated
     * with the value from the JobDetailFactoryBean (5)
     */
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
        // do the actual work
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用作业数据映射中的所有其他属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过使用<code>name</code>和<code>group</code>属性，您可以分别修改作业的名称和组。默认情况下，作业的名称与<code>JobDetailFactoryBean</code> （ <code>exampleJob</code>在上面的示例中）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-method-invoking-job"><a class="anchor" href="#scheduling-quartz-method-invoking-job"></a> 7.5.2。使用<code>MethodInvokingJobDetailFactoryBean</code></h4>
<div class="paragraph">
<p>通常，您只需要在特定对象上调用方法。通过使用<code>MethodInvokingJobDetailFactoryBean</code> ，您可以完全做到这一点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
    &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
    &lt;property name="targetMethod" value="doIt"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例导致<code>doIt</code>被调用的方法<code>exampleBusinessObject</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ExampleBusinessObject {

    // properties and collaborators

    public void doIt() {
        // do the actual work
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用<code>MethodInvokingJobDetailFactoryBean</code> ，您无需创建仅调用方法的单行作业。您只需要创建实际的业务对象并连接详细对象即可。</p>
</div>
<div class="paragraph">
<p>缺省情况下，Quartz Jobs是无状态的，从而导致作业相互干扰的可能性。如果您为同一触发器指定两个触发器<code>JobDetail</code> ，则有可能在第一个工作完成之前，第二个工作开始了。如果<code>JobDetail</code>类实现<code>Stateful</code>接口，这不会发生。在第一个作业完成之前，第二个作业没有开始。使工作产生于<code>MethodInvokingJobDetailFactoryBean</code>不同步，设置<code>concurrent</code>标记为<code>false</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
    &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
    &lt;property name="targetMethod" value="doIt"/&gt;
    &lt;property name="concurrent" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，作业将以并发方式运行。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-quartz-cron"><a class="anchor" href="#scheduling-quartz-cron"></a> 7.5.3。使用触发器和<code>SchedulerFactoryBean</code></h4>
<div class="paragraph">
<p>我们已经创建了工作详细信息和工作。我们还回顾了便捷bean，该bean使您可以在特定对象上调用方法。当然，我们仍然需要自己安排工作。这是通过使用触发器和<code>SchedulerFactoryBean</code> 。Quartz中提供了几种触发器，Spring提供了两个Quartz <code>FactoryBean</code>具有便捷默认值的实现： <code>CronTriggerFactoryBean</code>和<code>SimpleTriggerFactoryBean</code> 。</p>
</div>
<div class="paragraph">
<p>触发器需要安排。春天提供了<code>SchedulerFactoryBean</code>公开要设置为属性的触发器。 <code>SchedulerFactoryBean</code>通过这些触发器计划实际的作业。</p>
</div>
<div class="paragraph">
<p>以下清单同时使用了<code>SimpleTriggerFactoryBean</code>和一个<code>CronTriggerFactoryBean</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt;
    &lt;!-- see the example of method invoking job above --&gt;
    &lt;property name="jobDetail" ref="jobDetail"/&gt;
    &lt;!-- 10 seconds --&gt;
    &lt;property name="startDelay" value="10000"/&gt;
    &lt;!-- repeat every 50 seconds --&gt;
    &lt;property name="repeatInterval" value="50000"/&gt;
&lt;/bean&gt;

&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt;
    &lt;property name="jobDetail" ref="exampleJob"/&gt;
    &lt;!-- run every morning at 6 AM --&gt;
    &lt;property name="cronExpression" value="0 0 6 * * ?"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例设置了两个触发器，一个触发器每隔50秒运行一次，启动延迟为10秒，另一个触发器每天清晨6点运行。要完成所有工作，我们需要设置<code>SchedulerFactoryBean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
    &lt;property name="triggers"&gt;
        &lt;list&gt;
            &lt;ref bean="cronTrigger"/&gt;
            &lt;ref bean="simpleTrigger"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多属性可用于<code>SchedulerFactoryBean</code> ，例如工作详细信息所使用的日历，用于自定义Quartz的属性等。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html"><code>SchedulerFactoryBean</code></a>有关更多信息，请参见javadoc。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cache"><a class="anchor" href="#cache"></a> 8。缓存抽象</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从3.1版开始，Spring框架提供了对将缓存透明添加到现有Spring应用程序的支持。与<a href="data-access.html#transaction">事务</a>支持类似，缓存抽象允许一致使用各种缓存解决方案，而对代码的影响最小。</p>
</div>
<div class="paragraph">
<p>从Spring 4.1开始，通过支持<a href="#cache-jsr-107">JSR-107注释</a>和更多自定义选项，对缓存抽象进行了显着扩展。</p>
</div>
<div class="sect2">
<h3 id="cache-strategies"><a class="anchor" href="#cache-strategies"></a> 8.1。了解缓存抽象</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">缓存与缓冲区</div>
<div class="paragraph">
<p>术语“缓冲区”和“缓存”倾向于互换使用。但是请注意，它们代表不同的事物。传统上，缓冲区用作快速实体和慢速实体之间的数据的中间临时存储。由于一方必须等待另一方（这会影响性能），因此缓冲区允许一次移动整个数据块而不是小块数据来缓解这种情况。数据只能从缓冲区写入和读取一次。此外，缓冲区对于至少一个知道缓冲区的一方是可见的。</p>
</div>
<div class="paragraph">
<p>另一方面，根据定义，缓存是隐藏的，任何一方都不知道发生了缓存。它还可以提高性能，但可以通过快速读取多次相同数据来实现。</p>
</div>
<div class="paragraph">
<p>您可以<a href="https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache">在此处</a>找到有关缓冲区和缓存之间差异的进一步说明。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>缓存抽象的核心是将缓存应用于Java方法，从而根据缓存中可用的信息减少执行次数。也就是说，每次调用目标方法时，抽象都会应用缓存行为，该行为检查给定参数是否已经执行了该方法。如果已执行，则返回缓存的结果，而不必执行实际的方法。如果尚未执行该方法，则将执行该方法，并将结果缓存并返回给用户，以便下次调用该方法时，将返回缓存的结果。这样，对于给定的一组参数，昂贵的方法（无论是受CPU限制还是与IO绑定）只能执行一次，结果可以重复使用，而不必再次实际执行该方法。缓存逻辑是透明应用的，不会对调用方造成任何干扰。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">该方法仅适用于保证无论给定输入（或参数）执行多少次都返回相同输出（结果）的方法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>缓存抽象提供了其他与缓存相关的操作，例如更新缓存内容或删除一个或所有条目的能力。如果高速缓存处理在应用程序过程中可能更改的数据，则这些功能很有用。</p>
</div>
<div class="paragraph">
<p>与Spring Framework中的其他服务一样，缓存服务是一种抽象（不是缓存实现），并且需要使用实际的存储来存储缓存数据-也就是说，抽象使您不必编写缓存逻辑，但是没有提供实际的数据存储。这种抽象是由<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口。</p>
</div>
<div class="paragraph">
<p>Spring提供<a href="#cache-store-configuration">了</a>该抽象<a href="#cache-store-configuration">的一些实现</a> ：JDK <code>java.util.concurrent.ConcurrentMap</code>基于<a href="https://www.ehcache.org/">Ehcache 2.x</a>的缓存，Gemfire缓存， <a href="https://github.com/ben-manes/caffeine/wiki">Caffeine</a>和符合JSR-107的缓存（例如Ehcache 3.x）。有关<a href="#cache-plug">插入</a>其他缓存存储区和提供程序的更多信息，请参见<a href="#cache-plug">插入不同的后端缓存</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">对于多线程和多进程环境，缓存抽象没有特殊处理，因为此类功能由缓存实现处理。 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您具有多进程环境（即，一个应用程序部署在多个节点上），则需要相应地配置缓存提供程序。根据您的用例，在几个节点上复制相同数据就足够了。但是，如果在应用程序过程中更改数据，则可能需要启用其他传播机制。</p>
</div>
<div class="paragraph">
<p>高速缓存特定项直接等同于通过程序化高速缓存交互找到的典型“如果找不到，然后继续进行并放入”代码块。没有应用锁，几个线程可能会尝试同时加载同一项目。驱逐同样如此。如果多个线程试图同时更新或逐出数据，则可以使用陈旧数据。某些缓存提供程序在该区域提供高级功能。有关更多详细信息，请参见缓存提供程序的文档。</p>
</div>
<div class="paragraph">
<p>要使用缓存抽象，您需要注意两个方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>缓存声明：确定需要缓存的方法及其策略。</p>
</li>
<li>
<p>缓存配置：数据存储和读取的后备缓存。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="cache-annotations"><a class="anchor" href="#cache-annotations"></a> 8.2。基于声明式注释的缓存</h3>
<div class="paragraph">
<p>对于缓存声明，Spring的缓存抽象提供了一组Java注释：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Cacheable</code> ：触发缓存填充。</p>
</li>
<li>
<p><code>@CacheEvict</code> ：触发逐出缓存。</p>
</li>
<li>
<p><code>@CachePut</code> ：更新缓存，而不会干扰方法的执行。</p>
</li>
<li>
<p><code>@Caching</code> ：重新组合要在一个方法上应用的多个缓存操作。</p>
</li>
<li>
<p><code>@CacheConfig</code> ：在类级别共享一些与缓存相关的常见设置。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="cache-annotations-cacheable"><a class="anchor" href="#cache-annotations-cacheable"></a> 8.2.1。的<code>@Cacheable</code>注解</h4>
<div class="paragraph">
<p>顾名思义，您可以使用<code>@Cacheable</code>划定可缓存的方法的范围，即将结果存储在缓存中的方法，以便在后续调用（具有相同参数）时，无需实际执行该方法即可返回缓存中的值。注释声明以最简单的形式要求与带注释的方法关联的缓存名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable("books")
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的代码段中， <code>findBook</code>方法与名为的缓存相关联<code>books</code> 。每次调用该方法时，都会检查缓存以查看调用是否已经执行并且不必重复。尽管在大多数情况下，仅声明一个缓存，但注释可指定多个名称，以便使用多个缓存。在这种情况下，在执行该方法之前会检查每个缓存-如果命中了至少一个缓存，则返回关联的值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">即使未实际执行缓存的方法，所有其他不包含该值的缓存也会被更新。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例使用<code>@Cacheable</code>在<code>findBook</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable({"books", "isbns"})
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-default-key"><a class="anchor" href="#cache-annotations-cacheable-default-key"></a>默认密钥生成</h5>
<div class="paragraph">
<p>由于缓存本质上是键值存储，因此每次调用缓存方法都需要转换为适合缓存访问的键。缓存抽象使用一个简单的<code>KeyGenerator</code>基于以下算法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果没有给出参数，则返回<code>SimpleKey.EMPTY</code> 。</p>
</li>
<li>
<p>如果仅给出一个参数，则返回该实例。</p>
</li>
<li>
<p>如果给出多个参数，则返回一个<code>SimpleKey</code>包含所有参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只要参数具有自然键并实现有效，这种方法就适用于大多数用例<code>hashCode()</code>和<code>equals()</code>方法。如果不是这种情况，则需要更改策略。</p>
</div>
<div class="paragraph">
<p>要提供其他默认密钥生成器，您需要实施<code>org.springframework.cache.interceptor.KeyGenerator</code>接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>随着Spring 4.0的发布，默认密钥生成策略发生了变化。Spring的早期版本使用了密钥生成策略，该策略针对多个关键参数仅考虑了<code>hashCode()</code>参数而不是<code>equals()</code> 。这可能会导致意外的键冲突（有关背景，请参阅<a href="https://jira.spring.io/browse/SPR-10237">SPR-10237</a> ）。新的<code>SimpleKeyGenerator</code>在这种情况下使用复合键。</p>
</div>
<div class="paragraph">
<p>如果要继续使用以前的关键策略，则可以配置已弃用的<code>org.springframework.cache.interceptor.DefaultKeyGenerator</code>类或创建基于哈希的自定义<code>KeyGenerator</code>实施。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-key"><a class="anchor" href="#cache-annotations-cacheable-key"></a>自定义密钥生成声明</h5>
<div class="paragraph">
<p>由于缓存是通用的，因此目标方法很可能具有各种签名，这些签名无法轻易映射到缓存结构的顶部。当目标方法具有多个参数时，只有其中一些参数适合缓存（而其余参数仅由方法逻辑使用），这往往变得很明显。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable("books")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>乍一看，而两者<code>boolean</code>参数会影响书籍的查找方式，它们对缓存没有用处。此外，如果两者中只有一个重要而另一个不重要怎么办？</p>
</div>
<div class="paragraph">
<p>在这种情况下， <code>@Cacheable</code>注释使您可以指定如何通过密钥生成密钥<code>key</code>属性。您可以使用<a href="core.html#expressions">SpEL</a>选择感兴趣的参数（或其嵌套属性），执行操作，甚至调用任意方法，而无需编写任何代码或实现任何接口。这是<a href="#cache-annotations-cacheable-default-key">默认生成器</a>之上的推荐方法，因为随着代码库的增长，签名中的方法往往会大不相同。虽然默认策略可能适用于某些方法，但很少适用于所有方法。</p>
</div>
<div class="paragraph">
<p>以下示例是各种SpEL声明（如果您不熟悉SpEL，请帮忙并阅读<a href="core.html#expressions">Spring Expression Language</a> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="#isbn.rawNumber")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="T(someType).hash(#isbn)")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码片段显示了选择某个参数，其属性之一甚至是任意（静态）方法是多么容易。</p>
</div>
<div class="paragraph">
<p>如果负责生成密钥的算法过于具体或需要共享，则可以定义一个自定义<code>keyGenerator</code>在操作上。为此，请指定<code>KeyGenerator</code>要使用的bean实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="books", keyGenerator="myKeyGenerator")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>key</code>和<code>keyGenerator</code>参数是互斥的，并且同时指定这两个参数的操作将导致异常。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-default-cache-resolver"><a class="anchor" href="#cache-annotations-cacheable-default-cache-resolver"></a>默认缓存分辨率</h5>
<div class="paragraph">
<p>缓存抽象使用一个简单的<code>CacheResolver</code>通过使用已配置的配置来检索在操作级别定义的缓存<code>CacheManager</code> 。</p>
</div>
<div class="paragraph">
<p>要提供其他默认缓存解析器，您需要实施<code>org.springframework.cache.interceptor.CacheResolver</code>接口。</p>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-cache-resolver"><a class="anchor" href="#cache-annotations-cacheable-cache-resolver"></a>自定义缓存解析</h5>
<div class="paragraph">
<p>默认的缓存分辨率非常适合于使用单个缓存的应用程序。 <code>CacheManager</code>并且没有复杂的缓存分辨率要求。</p>
</div>
<div class="paragraph">
<p>对于使用多个缓存管理器的应用程序，您可以设置<code>cacheManager</code>用于每个操作，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="books", cacheManager="anotherCacheManager") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定<code>anotherCacheManager</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您也可以更换<code>CacheResolver</code>完全以类似于替换<a href="#cache-annotations-cacheable-key">密钥生成的方式进行</a> 。对于每个缓存操作，都需要解决该问题，让实现实际上可以根据运行时参数来解析要使用的缓存。以下示例显示了如何指定<code>CacheResolver</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheResolver="runtimeCacheResolver") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(ISBN isbn) {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定<code>CacheResolver</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring 4.1开始， <code>value</code>缓存注释的属性不再是必需的，因为此特定信息可以由<code>CacheResolver</code>不管注释的内容如何。</p>
</div>
<div class="paragraph">
<p>类似于<code>key</code>和<code>keyGenerator</code> ， <code>cacheManager</code>和<code>cacheResolver</code>参数是互斥的，并且同时指定这两个参数的操作将导致异常。作为习俗<code>CacheManager</code>被忽略<code>CacheResolver</code>实施。这可能不是您所期望的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-synchronized"><a class="anchor" href="#cache-annotations-cacheable-synchronized"></a>同步缓存</h5>
<div class="paragraph">
<p>在多线程环境中，可能会为同一参数同时调用某些操作（通常在启动时）。默认情况下，缓存抽象不会锁定任何内容，并且可能会多次计算相同的值，从而破坏了缓存的目的。</p>
</div>
<div class="paragraph">
<p>对于这些特殊情况，您可以使用<code>sync</code>属性，指示基础缓存提供程序在计算值时锁定缓存条目。结果，只有一个线程正在忙于计算该值，而其他线程则被阻塞，直到在缓存中更新该条目为止。以下示例显示了如何使用<code>sync</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="foos", sync=true) <i class="conum" data-value="1"></i><b>(1)</b>
public Foo executeExpensiveOperation(String id) {...}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>sync</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是一项可选功能，您最喜欢的缓存库可能不支持它。所有<code>CacheManager</code>核心框架提供的实现支持它。有关更多详细信息，请参见缓存提供程序的文档。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="cache-annotations-cacheable-condition"><a class="anchor" href="#cache-annotations-cacheable-condition"></a>条件缓存</h5>
<div class="paragraph">
<p>有时，一种方法可能并不总是适合缓存（例如，它可能取决于给定的参数）。缓存注释通过<code>condition</code>参数，需要一个<code>SpEL</code>表达式被评估为<code>true</code>要么<code>false</code> 。如果<code>true</code> ，方法被缓存。如果不是，它的行为就好像未缓存该方法（也就是说，无论缓存中使用什么值或使用什么参数，每次都执行该方法）。例如，仅当参数为<code>name</code>长度小于32：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="book", condition="#name.length() &lt; 32") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(String name)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置条件<code>@Cacheable</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了<code>condition</code>参数，您可以使用<code>unless</code>参数否决将值添加到缓存。不像<code>condition</code> ， <code>unless</code>在调用方法后对表达式进行求值。为了扩展前面的示例，也许我们只想缓存平装书，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="book", condition="#name.length() &lt; 32", unless="#result.hardback") <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(String name)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>unless</code>属性以阻止精装本。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>缓存抽象支持<code>java.util.Optional</code> ，仅在存在时才将其内容用作缓存的值。 <code>#result</code>总是指业务实体，而不是受支持的包装器，因此可以将以下示例重写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="book", condition="#name.length() &lt; 32", unless="#result?.hardback")
public Optional&lt;Book&gt; findBook(String name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>result</code>仍然指<code>Book</code>并不是<code>Optional</code> 。可能是<code>null</code> ，我们应该使用安全的导航操作符。</p>
</div>
</div>
<div class="sect4">
<h5 id="cache-spel-context"><a class="anchor" href="#cache-spel-context"></a>可用的缓存SpEL评估上下文</h5>
<div class="paragraph">
<p>每<code>SpEL</code>表达式针对专用<a href="core.html#expressions-language-ref"><code>context</code></a> 。除了内置参数外，该框架还提供了与缓存相关的专用元数据，例如参数名称。下表描述了可用于上下文的项目，以便您可以将其用于键和条件计算：</p>
</div>
<table id="cache-spel-context-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表11。缓存SpEL可用元数据</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">地点</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>methodName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被调用方法的名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.methodName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被调用的方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.method.name</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被调用的目标对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.target</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>targetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被调用目标的类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.targetClass</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>args</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于调用目标的参数（作为数组）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args[0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>caches</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行当前方法的缓存的集合</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.caches[0].name</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估背景</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何方法参数的名称。如果名称不可用（可能是由于没有调试信息），则参数名称在<code>#a<#arg></code>哪里<code>#arg</code>代表参数索引（从<code>0</code> ）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#iban</code>要么<code>#a0</code> （您也可以使用<code>#p0</code>要么<code>#p<#arg></code>符号作为别名）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>result</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估背景</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法调用的结果（要缓存的值）。仅在<code>unless</code>表达式， <code>cache put</code>表达式（用于计算<code>key</code> ）， 要么<code>cache evict</code>表达式（当<code>beforeInvocation</code>是<code>false</code> ）。对于受支持的包装器（例如<code>Optional</code> ）， <code>#result</code>指的是实际对象，而不是包装器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#result</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-put"><a class="anchor" href="#cache-annotations-put"></a> 8.2.2。的<code>@CachePut</code>注解</h4>
<div class="paragraph">
<p>当需要在不影响方法执行的情况下更新缓存时，可以使用<code>@CachePut</code>注解。也就是说，该方法始终执行并将其结果放入缓存中（根据<code>@CachePut</code>选项）。它支持与以下选项相同的选项<code>@Cacheable</code>并且应用于缓存填充，而不是方法流优化。以下示例使用<code>@CachePut</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CachePut(cacheNames="book", key="#isbn")
public Book updateBook(ISBN isbn, BookDescriptor descriptor)</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">使用<code>@CachePut</code>和<code>@Cacheable</code>通常强烈建议不要使用同一方法的注释，因为它们具有不同的行为。后者导致通过使用缓存跳过方法执行，而前者则强制执行以便执行缓存更新。这会导致意外的行为，并且，除了特定的极端情况（例如具有相互排斥条件的注释）外，应避免此类声明。另请注意，此类条件不应依赖于结果对象（即<code>#result</code>变量），因为这些已预先验证以确认排除在外。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-evict"><a class="anchor" href="#cache-annotations-evict"></a> 8.2.3。的<code>@CacheEvict</code>注解</h4>
<div class="paragraph">
<p>缓存抽象不仅允许缓存存储的填充，还允许逐出。此过程对于从缓存中删除陈旧或未使用的数据很有用。相对于<code>@Cacheable</code> ， <code>@CacheEvict</code>划分执行高速缓存逐出的方法（即，用作触发从高速缓存中删除数据的触发器的方法）。与其兄弟姐妹一样， <code>@CacheEvict</code>需要指定一个或多个受操作影响的缓存，允许指定自定义缓存和键解析或条件，并具有额外的参数（ <code>allEntries</code> ），指示是否需要执行整个缓存范围的驱逐，而不仅仅是条目驱逐（基于密钥）。以下示例将所有条目逐出<code>books</code>快取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CacheEvict(cacheNames="books", allEntries=true) <i class="conum" data-value="1"></i><b>(1)</b>
public void loadBooks(InputStream batch)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>allEntries</code>属性从缓存中逐出所有条目。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当需要清除整个缓存区域时，此选项非常有用。如前面的示例所示，而不是逐出每个条目（这会花费很长时间，因为效率很低），而是一次操作删除所有条目。请注意，该框架会忽略此方案中指定的任何键，因为它不适用（整个高速缓存被驱逐，而不仅仅是一个条目）。</p>
</div>
<div class="paragraph">
<p>您还可以通过使用来指示驱逐应该在（默认）之后还是在方法执行之前发生<code>beforeInvocation</code>属性。前者提供与其余批注相同的语义：方法成功完成后，将对缓存执行操作（在这种情况下为逐出）。如果该方法未执行（可能已被缓存）或引发了异常，则不会发生驱逐。后者 （ <code>beforeInvocation=true</code> ）导致逐出总是在调用方法之前发生。在不需要将逐出与方法结果联系在一起的情况下，这很有用。</p>
</div>
<div class="paragraph">
<p>注意<code>void</code>方法可以与<code>@CacheEvict</code> -当方法充当触发器时，返回值将被忽略（因为它们不与缓存交互）。事实并非如此<code>@Cacheable</code>它将数据添加或更新到缓存中，因此需要结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-caching"><a class="anchor" href="#cache-annotations-caching"></a> 8.2.4。的<code>@Caching</code>注解</h4>
<div class="paragraph">
<p>有时，多个相同类型的注释（例如<code>@CacheEvict</code>要么<code>@CachePut</code> ）需要指定-例如，因为条件或键表达式在不同的缓存之间是不同的。 <code>@Caching</code>让多个嵌套<code>@Cacheable</code> ， <code>@CachePut</code>和<code>@CacheEvict</code>注释可用于同一方法。以下示例使用两个<code>@CacheEvict</code>注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })
public Book importBooks(String deposit, Date date)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotations-config"><a class="anchor" href="#cache-annotations-config"></a> 8.2.5。的<code>@CacheConfig</code>注解</h4>
<div class="paragraph">
<p>到目前为止，我们已经看到缓存操作提供了许多自定义选项，并且您可以为每个操作设置这些选项。但是，如果某些自定义选项适用于该类的所有操作，那么配置它们可能很繁琐。例如，指定用于类的每个高速缓存操作的高速缓存的名称可以由单个类级别的定义代替。这是哪里<code>@CacheConfig</code>发挥作用。以下示例使用<code>@CacheConfig</code>设置缓存的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CacheConfig("books") <i class="conum" data-value="1"></i><b>(1)</b>
public class BookRepositoryImpl implements BookRepository {

    @Cacheable
    public Book findBook(ISBN isbn) {...}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@CacheConfig</code>设置缓存的名称。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>@CacheConfig</code>是一个类级注释，允许共享缓存名称，自定义<code>KeyGenerator</code> ，风俗<code>CacheManager</code> ，以及自定义<code>CacheResolver</code> 。将此注释放在类上不会打开任何缓存操作。</p>
</div>
<div class="paragraph">
<p>操作级别的自定义始终会覆盖在上设置的自定义<code>@CacheConfig</code> 。因此，这为每个高速缓存操作提供了三个定制级别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>全局配置，可用于<code>CacheManager</code> ， <code>KeyGenerator</code> 。</p>
</li>
<li>
<p>在课堂上，使用<code>@CacheConfig</code> 。</p>
</li>
<li>
<p>在操作级别。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotation-enable"><a class="anchor" href="#cache-annotation-enable"></a> 8.2.6。启用缓存注释</h4>
<div class="paragraph">
<p>重要的是要注意，即使声明缓存注释并不会自动触发它们的动作-像Spring中的许多事情一样，必须声明性地启用该功能（这意味着如果您怀疑应该归因于缓存，则可以通过删除来禁用它仅一个配置行，而不是代码中的所有注释）。</p>
</div>
<div class="paragraph">
<p>要启用缓存注释，请添加注释<code>@EnableCaching</code>给你的一个<code>@Configuration</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableCaching
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，对于XML配置，您可以使用<code>cache:annotation-driven</code>元件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:cache="http://www.springframework.org/schema/cache"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd"&gt;

        &lt;cache:annotation-driven/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这俩<code>cache:annotation-driven</code>元素和<code>@EnableCaching</code>批注允许您指定各种选项，这些选项会影响通过AOP将缓存行为添加到应用程序的方式。该配置故意与<a href="data-access.html#tx-annotation-driven-settings"><code>@Transactional</code></a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">处理缓存注释的默认建议模式是<code>proxy</code> ，仅允许通过代理拦截呼叫。同一类内的本地调用无法以这种方式被拦截。要获得更高级的拦截模式，请考虑切换到<code>aspectj</code>模式结合编译时或加载时编织。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关实施所需的高级定制（使用Java配置）的更多详细信息<code>CachingConfigurer</code> ，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">javadoc</a> 。
</td>
</tr>
</tbody></table>
</div>
<table id="cache-annotation-driven-settings" class="tableblock frame-all grid-all spread">
<caption class="title">表12。缓存注释设置</caption>
<colgroup>
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:50.0002%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">XML属性</th>
<th class="tableblock halign-left valign-top">注释属性</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cache-manager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用（请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cacheManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的缓存管理器的名称。默认值<code>CacheResolver</code>使用此缓存管理器在后台初始化（或<code>cacheManager</code>如果未设置）。为了更精细地管理缓存分辨率，请考虑设置“ cache-resolver”属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cache-resolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用（请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种<code>SimpleCacheResolver</code>使用配置<code>cacheManager</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用来解析后备缓存的CacheResolver的bean名称。此属性不是必需的，仅需指定为“ cache-manager”属性的替代方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>key-generator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用（请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleKeyGenerator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的定制密钥生成器的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error-handler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用（请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> javadoc）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleCacheErrorHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的自定义缓存错误处理程序的名称。默认情况下，在与缓存相关的操作期间抛出的所有异常都将返回给客户端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认模式（ <code>proxy</code> ）通过使用Spring的AOP框架来处理要注释的bean（遵循代理语义，如前所述，仅适用于通过代理传入的方法调用）。替代模式（ <code>aspectj</code> ）而是使用Spring的AspectJ缓存方面编织受影响的类，修改目标类字节码以应用于任何类型的方法调用。AspectJ编织要求<code>spring-aspects.jar</code>在类路径中启用了加载时编织（或编译时编织）。（有关如何设置加载时编织的详细信息，请参见<a href="core.html#aop-aj-ltw-spring">Spring配置</a> 。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy-target-class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxyTargetClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅适用于代理模式。控制为使用注释的类创建哪种类型的缓存代理。 <code>@Cacheable</code>要么<code>@CacheEvict</code>注释。如果<code>proxy-target-class</code>属性设置为<code>true</code> ，将创建基于类的代理。如果<code>proxy-target-class</code>是<code>false</code>或者，如果省略该属性，则创建基于标准JDK接口的代理。（有关不同代理类型的详细检查，请参见<a href="core.html#aop-proxying">代理机制</a> 。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">订购了。LOWEST_PRECEDENCE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义应用于带注释的bean的缓存建议的顺序<code>@Cacheable</code>要么<code>@CacheEvict</code> 。（有关与订购AOP建议有关的规则的更多信息，请参阅<a href="core.html#aop-ataspectj-advice-ordering">建议订购</a> 。）没有指定的顺序意味着AOP子系统确定建议的顺序。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code><cache:annotation-driven/></code>寻找<code>@Cacheable/@CachePut/@CacheEvict/@Caching</code>仅在定义了它的相同应用程序上下文中的bean上。这意味着，如果您把<code><cache:annotation-driven/></code>在一个<code>WebApplicationContext</code>为一个<code>DispatcherServlet</code> ，它仅在控制器中检查bean，而不在服务中检查bean。有关更多信息，请参见<a href="web.html#mvc-servlet">MVC部分</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">方法可见性和缓存注释</div>
<div class="paragraph">
<p>使用代理时，应仅将缓存注释应用于具有公共可见性的方法。如果使用这些注释对受保护的，私有的或程序包可见的方法进行注释，则不会引发任何错误，但是带注释的方法不会显示已配置的缓存设置。如果您需要注释非公共方法，请考虑使用AspectJ（请参阅本节的其余部分），因为它会更改字节码本身。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring建议您仅使用来注释具体的类（以及具体的类的方法）。 <code>@Cache*</code>注释，而不是注释接口。您当然可以将<code>@Cache*</code>接口（或接口方法）上的注释，但是仅在使用基于接口的代理时，此注释才起作用。Java批注不是从接口继承的事实意味着，如果您使用基于类的代理（ <code>proxy-target-class="true"</code> ）或基于编织的方面（ <code>mode="aspectj"</code> ），则代理和编织基础架构无法识别缓存设置，并且该对象也不会包装在缓存代理中。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在代理模式（默认）下，仅拦截通过代理传入的外部方法调用。这意味着自调用（实际上是目标对象中的一个方法调用了目标对象的另一种方法）即使在调用的方法标记为的情况下，也不会在运行时导致实际的缓存。 <code>@Cacheable</code> 。考虑使用<code>aspectj</code>模式在这种情况下。另外，必须对代理进行完全初始化以提供预期的行为，因此您不应在初始化代码中依赖此功能（即， <code>@PostConstruct</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="cache-annotation-stereotype"><a class="anchor" href="#cache-annotation-stereotype"></a> 8.2.7。使用自定义注释</h4>
<div class="sidebarblock">
<div class="content">
<div class="title">自定义注释和AspectJ</div>
<div class="paragraph">
<p>该功能仅适用于基于代理的方法，但可以通过使用AspectJ进行一些额外的工作来启用。</p>
</div>
<div class="paragraph">
<p>的<code>spring-aspects</code>模块仅为标准注释定义一个方面。如果定义了自己的注释，则还需要为其定义一个方面。校验<code>AnnotationCacheAspect</code>举个例子</p>
</div>
</div>
</div>
<div class="paragraph">
<p>缓存抽象使您可以使用自己的注释来标识触发缓存填充或逐出的方法。作为模板机制，这非常方便，因为它消除了重复缓存注释声明的需求，如果指定了键或条件或外部导入（ <code>org.springframework</code> ）在您的代码库中是不允许的。与其余的<a href="core.html#beans-stereotype-annotations">构造型</a>注释类似，您可以使用<code>@Cacheable</code> ， <code>@CachePut</code> ， <code>@CacheEvict</code>和<code>@CacheConfig</code>作为<a href="core.html#beans-meta-annotations">元注释</a> （即可以注释其他注释的注释）。在下面的示例中，我们替换了一个常见的<code>@Cacheable</code>具有我们自己的自定义注释的声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Cacheable(cacheNames="books", key="#isbn")
public @interface SlowService {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们定义了自己的<code>SlowService</code>注释，其本身带有注释<code>@Cacheable</code> 。现在我们可以替换以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了自定义批注，我们可以用其替换前面的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SlowService
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使<code>@SlowService</code>不是Spring注释，容器会在运行时自动获取其声明并了解其含义。请注意， <a href="#cache-annotation-enable">如前所述</a> ，需要启用注释驱动的行为。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-jsr-107"><a class="anchor" href="#cache-jsr-107"></a> 8.3。JCache（JSR-107）批注</h3>
<div class="paragraph">
<p>从4.1版开始，Spring的缓存抽象完全支持JCache标准注释： <code>@CacheResult</code> ， <code>@CachePut</code> ， <code>@CacheRemove</code>和<code>@CacheRemoveAll</code>以及<code>@CacheDefaults</code> ， <code>@CacheKey</code>和<code>@CacheValue</code>同伴。您甚至可以在不将缓存存储迁移到JSR-107的情况下使用这些注释。内部实现使用Spring的缓存抽象并提供默认值<code>CacheResolver</code>和<code>KeyGenerator</code>符合规范的实现。换句话说，如果您已经在使用Spring的缓存抽象，则可以切换到这些标准注释，而无需更改缓存存储（或配置）。</p>
</div>
<div class="sect3">
<h4 id="cache-jsr-107-summary"><a class="anchor" href="#cache-jsr-107-summary"></a> 8.3.1。功能摘要</h4>
<div class="paragraph">
<p>对于那些熟悉Spring缓存注释的人，下表描述了Spring注释与JSR-107副本之间的主要区别：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表13。Spring与JSR-107缓存注释</caption>
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:60%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">弹簧</th>
<th class="tableblock halign-left valign-top">JSR-107</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Cacheable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">相当相似。 <code>@CacheResult</code>可以缓存特定的异常并强制执行该方法，而不管缓存的内容如何。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CachePut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CachePut</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当Spring使用方法调用的结果更新缓存时，JCache要求将其作为带有参数注释的参数传递给它。 <code>@CacheValue</code> 。由于存在这种差异，JCache允许在实际方法调用之前或之后更新缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheEvict</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheRemove</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">相当相似。 <code>@CacheRemove</code>当方法调用导致异常时，支持有条件驱逐。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheEvict(allEntries=true)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheRemoveAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">看到<code>@CacheRemove</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CacheDefaults</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">让您以类似的方式配置相同的概念。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>JCache的概念是<code>javax.cache.annotation.CacheResolver</code> ，与春季的<code>CacheResolver</code>接口，除了JCache仅支持单个缓存。默认情况下，一个简单的实现根据注释中声明的名称检索要使用的缓存。应该注意的是，如果注释中未指定缓存名称，则会自动生成一个默认值。见的javadoc <code>@CacheResult#cacheName()</code>想要查询更多的信息。</p>
</div>
<div class="paragraph">
<p><code>CacheResolver</code>实例由<code>CacheResolverFactory</code> 。可以为每个缓存操作自定义工厂，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CacheResult(cacheNames="books", cacheResolverFactory=MyCacheResolverFactory.class) <i class="conum" data-value="1"></i><b>(1)</b>
public Book findBook(ISBN isbn)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>为此操作定制工厂。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于所有引用的类，Spring尝试查找具有给定类型的bean。如果存在多个匹配项，那么将创建一个新实例，并可以使用常规bean生命周期回调，例如依赖项注入。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>密钥由<code>javax.cache.annotation.CacheKeyGenerator</code>与Spring的目的相同<code>KeyGenerator</code> 。默认情况下，将考虑所有方法参数，除非至少一个参数用注释<code>@CacheKey</code> 。这类似于Spring的<a href="#cache-annotations-cacheable-key">自定义密钥生成声明</a> 。例如，以下是相同的操作，一个使用Spring的抽象，另一个使用JCache：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@CacheResult(cacheName="books")
public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以指定<code>CacheKeyResolver</code>在操作上，类似于如何指定<code>CacheResolverFactory</code> 。</p>
</div>
<div class="paragraph">
<p>JCache可以管理带注释的方法引发的异常。这样可以防止更新缓存，但是也可以将异常缓存为失败的指示，而不必再次调用该方法。假使，假设<code>InvalidIsbnNotFoundException</code>如果ISBN的结构无效，则抛出该异常。这是一个永久性的失败（使用这样的参数无法检索任何书籍）。以下内容缓存该异常，以便使用相同的无效ISBN进行的进一步调用直接引发该缓存的异常，而不是再次调用该方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CacheResult(cacheName="books", exceptionCacheName="failures"
            cachedExceptions = InvalidIsbnNotFoundException.class)
public Book findBook(ISBN isbn)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enabling-jsr-107-support"><a class="anchor" href="#enabling-jsr-107-support"></a> 8.3.2。启用JSR-107支持</h4>
<div class="paragraph">
<p>除了启用Spring的声明性注释支持外，您无需执行任何其他操作即可启用JSR-107支持。都<code>@EnableCaching</code>和<code>cache:annotation-driven</code>如果JSR-107 API和<code>spring-context-support</code>模块存在于类路径中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">根据您的用例，选择基本上是您的选择。您甚至可以通过在某些服务器上使用JSR-107 API并在其他服务器上使用Spring自己的注释来混合和匹配服务。但是，如果这些服务影响相同的缓存，则应使用一致且相同的密钥生成实现。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-declarative-xml"><a class="anchor" href="#cache-declarative-xml"></a> 8.4。基于声明式XML的缓存</h3>
<div class="paragraph">
<p>如果不能使用注释（可能是由于无法访问源代码或没有外部代码），则可以使用XML进行声明式缓存。因此，您可以从外部指定目标方法和缓存指令，而不是注释用于缓存的方法（类似于声明式事务管理<a href="data-access.html#transaction-declarative-first-example">建议</a> ）。上一节中的示例可以转换为以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- the service we want to make cacheable --&gt;
&lt;bean id="bookService" class="x.y.service.DefaultBookService"/&gt;

&lt;!-- cache definitions --&gt;
&lt;cache:advice id="cacheAdvice" cache-manager="cacheManager"&gt;
    &lt;cache:caching cache="books"&gt;
        &lt;cache:cacheable method="findBook" key="#isbn"/&gt;
        &lt;cache:cache-evict method="loadBooks" all-entries="true"/&gt;
    &lt;/cache:caching&gt;
&lt;/cache:advice&gt;

&lt;!-- apply the cacheable behavior to all BookService interfaces --&gt;
&lt;aop:config&gt;
    &lt;aop:advisor advice-ref="cacheAdvice" pointcut="execution(* x.y.BookService.*(..))"/&gt;
&lt;/aop:config&gt;

&lt;!-- cache manager definition omitted --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述配置中， <code>bookService</code>使其可缓存。要应用的缓存语义封装在<code>cache:advice</code>定义，导致<code>findBooks</code>用于将数据放入缓存的方法<code>loadBooks</code>驱逐数据的方法。两种定义都违反了<code>books</code>缓存。</p>
</div>
<div class="paragraph">
<p>的<code>aop:config</code>定义通过使用AspectJ切入点表达式将缓存建议应用于程序中的适当点（有关更多信息，请参见<a href="core.html#aop">Spring面向方面的编程</a> ）。在前面的示例中， <code>BookService</code>被考虑并将缓存建议应用于它们。</p>
</div>
<div class="paragraph">
<p>声明式XML缓存支持所有基于注释的模型，因此在两者之间移动应该相当容易。此外，两者都可以在同一应用程序内使用。基于XML的方法不会涉及目标代码。但是，它本质上比较冗长。当处理具有针对缓存的重载方法的类时，确定适当的方法确实需要付出额外的努力，因为<code>method</code>论点不是一个很好的判别器。在这些情况下，您可以使用AspectJ切入点来挑选目标方法并应用适当的缓存功能。但是，通过XML，更容易应用程序包或组或接口范围的缓存（同样，由于AspectJ切入点的缘故）和创建类似模板的定义（如我们在前面的示例中那样，通过<code>cache:definitions</code><code>cache</code>属性）。</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-store-configuration"><a class="anchor" href="#cache-store-configuration"></a> 8.5。配置缓存存储</h3>
<div class="paragraph">
<p>缓存抽象提供了几个存储集成选项。要使用它们，您需要声明一个适当的<code>CacheManager</code> （控制和管理的实体<code>Cache</code>实例，可用于检索这些实例进行存储）。</p>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-jdk"><a class="anchor" href="#cache-store-configuration-jdk"></a> 8.5.1。JDK <code>ConcurrentMap</code>基于缓存</h4>
<div class="paragraph">
<p>基于JDK <code>Cache</code>实现位于<code>org.springframework.cache.concurrent</code>包。它可以让您使用<code>ConcurrentHashMap</code>作为支持<code>Cache</code>商店。以下示例显示了如何配置两个缓存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- simple cache manager --&gt;
&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/&gt;
            &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="books"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码段使用<code>SimpleCacheManager</code>创建一个<code>CacheManager</code>对于两个嵌套<code>ConcurrentMapCache</code>实例命名<code>default</code>和<code>books</code> 。请注意，名称是直接为每个缓存配置的。</p>
</div>
<div class="paragraph">
<p>由于缓存是由应用程序创建的，因此绑定到其生命周期，使其适合于基本用例，测试或简单的应用程序。缓存可以很好地扩展并且非常快，但是它不提供任何管理，持久性功能或驱逐合同。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-ehcache"><a class="anchor" href="#cache-store-configuration-ehcache"></a> 8.5.2。基于Ehcache的缓存</h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Ehcache 3.x完全符合JSR-107，并且不需要专用支持。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ehcache 2.x实现位于<code>org.springframework.cache.ehcache</code>包。同样，要使用它，您需要声明适当的<code>CacheManager</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="cacheManager"
        class="org.springframework.cache.ehcache.EhCacheCacheManager" p:cache-manager-ref="ehcache"/&gt;

&lt;!-- EhCache library setup --&gt;
&lt;bean id="ehcache"
        class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:config-location="ehcache.xml"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此设置引导Spring IoC内部的ehcache库（通过<code>ehcache</code> bean），然后将其连接到专用<code>CacheManager</code>实施。请注意，整个特定于Ehcache的配置是从<code>ehcache.xml</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-caffeine"><a class="anchor" href="#cache-store-configuration-caffeine"></a> 8.5.3。咖啡因缓存</h4>
<div class="paragraph">
<p>Caffeine是Java 8重写的Guava缓存，其实现位于<code>org.springframework.cache.caffeine</code>包，并提供对咖啡因几种功能的访问。</p>
</div>
<div class="paragraph">
<p>以下示例配置了一个<code>CacheManager</code>按需创建缓存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="cacheManager"
        class="org.springframework.cache.caffeine.CaffeineCacheManager"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以提供要显式使用的缓存。在这种情况下，经理只能提供那些。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="cacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager"&gt;
    &lt;property name="caches"&gt;
        &lt;set&gt;
            &lt;value&gt;default&lt;/value&gt;
            &lt;value&gt;books&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>咖啡因<code>CacheManager</code>还支持自定义<code>Caffeine</code>和<code>CacheLoader</code> 。有关这些的更多信息，请参见<a href="https://github.com/ben-manes/caffeine/wiki">Caffeine文档</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-gemfire"><a class="anchor" href="#cache-store-configuration-gemfire"></a> 8.5.4。基于GemFire的缓存</h4>
<div class="paragraph">
<p>GemFire是面向内存，磁盘支持，弹性可伸缩，连续可用，活动（具有内置的基于模式的订阅通知），全局复制的数据库，并提供功能齐全的边缘缓存。有关如何将GemFire用作<code>CacheManager</code> （以及更多），请参阅<a href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/">Spring Data GemFire参考文档</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-jsr107"><a class="anchor" href="#cache-store-configuration-jsr107"></a> 8.5.5。JSR-107缓存</h4>
<div class="paragraph">
<p>Spring的缓存抽象也可以使用符合JSR-107的缓存。JCache实现位于<code>org.springframework.cache.jcache</code>包。</p>
</div>
<div class="paragraph">
<p>同样，要使用它，您需要声明适当的<code>CacheManager</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="cacheManager"
        class="org.springframework.cache.jcache.JCacheCacheManager"
        p:cache-manager-ref="jCacheManager"/&gt;

&lt;!-- JSR-107 cache manager setup  --&gt;
&lt;bean id="jCacheManager" .../&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cache-store-configuration-noop"><a class="anchor" href="#cache-store-configuration-noop"></a> 8.5.6。在没有后备存储的情况下处理缓存</h4>
<div class="paragraph">
<p>有时，在切换环境或进行测试时，您可能具有缓存声明而未配置实际的后备缓存。由于这是无效的配置，因此在运行时将引发异常，因为缓存基础结构无法找到合适的存储。在这种情况下，您可以插入一个不执行缓存的简单虚拟缓存，而不是删除缓存声明（这可能会很乏味），也就是说，它将强制每次执行缓存的方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="cacheManager" class="org.springframework.cache.support.CompositeCacheManager"&gt;
    &lt;property name="cacheManagers"&gt;
        &lt;list&gt;
            &lt;ref bean="jdkCache"/&gt;
            &lt;ref bean="gemfireCache"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="fallbackToNoOpCache" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>CompositeCacheManager</code>在前面的链中多个<code>CacheManager</code>实例，并通过<code>fallbackToNoOpCache</code>标志，为未配置的缓存管理器处理的所有定义添加一个无操作缓存。也就是说，在任何一个缓存定义中都找不到<code>jdkCache</code>要么<code>gemfireCache</code> （在示例中较早配置）（由示例操作）由无操作缓存处理，该缓存不存储任何信息，从而导致每次执行目标方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cache-plug"><a class="anchor" href="#cache-plug"></a> 8.6。插入不同的后端缓存</h3>
<div class="paragraph">
<p>显然，有很多缓存产品可以用作后备存储。要插入它们，您需要提供一个<code>CacheManager</code>和一个<code>Cache</code>实施，因为不幸的是，没有可用的替代标准。这听起来可能比实际要难，因为在实践中，这些类通常是简单的<a href="https://en.wikipedia.org/wiki/Adapter_pattern">适配器</a> ，可以将缓存抽象框架映射到存储API的顶部，因为<code>ehcache</code>类。最<code>CacheManager</code>类可以使用<code>org.springframework.cache.support</code>包（例如<code>AbstractCacheManager</code>它会处理样板代码，只保留实际的映射）。我们希望，及时提供与Spring集成的库可以弥补这一小的配置空白。</p>
</div>
</div>
<div class="sect2">
<h3 id="cache-specific-config"><a class="anchor" href="#cache-specific-config"></a> 8.7。如何设置TTL / TTI /驱逐策略/ XXX功能？</h3>
<div class="paragraph">
<p>直接通过您的缓存提供程序。缓存抽象是一种抽象，而不是缓存实现。您使用的解决方案可能支持其他解决方案不支持的各种数据策略和不同的拓扑（例如，JDK <code>ConcurrentHashMap</code> —在缓存中公开抽象是没有用的，因为没有后备支持）。此类功能应通过后备缓存（配置时）或通过其本机API直接控制。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a> 9。附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a> 9.1。XML模式</h3>
<div class="paragraph">
<p>附录的此部分列出了与集成技术有关的XML模式。</p>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jee"><a class="anchor" href="#xsd-schemas-jee"></a> 9.1.1。的<code>jee</code>架构图</h4>
<div class="paragraph">
<p>的<code>jee</code>元素处理与Java EE（Java企业版）配置有关的问题，例如查找JNDI对象和定义EJB引用。</p>
</div>
<div class="paragraph">
<p>要使用<code>jee</code>模式，您需要在Spring XML配置文件的顶部具有以下序言。以下代码段中的文本引用了正确的架构，因此<code>jee</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee https://www.springframework.org/schema/jee/spring-jee.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup"></a><jee:jndi-lookup></jee:jndi-lookup> （简单）</h5>
<div class="paragraph">
<p>以下示例显示了如何使用JNDI查找数据源，而无需<code>jee</code>模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
&lt;/bean&gt;
&lt;bean id="userDao" class="com.foo.JdbcUserDao"&gt;
    &lt;!-- Spring will do the cast automatically (as usual) --&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用JNDI通过以下方式查找数据源： <code>jee</code>模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/MyDataSource"/&gt;

&lt;bean id="userDao" class="com.foo.JdbcUserDao"&gt;
    &lt;!-- Spring will do the cast automatically (as usual) --&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-environment-single"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-environment-single"></a><code><jee:jndi-lookup/></code> （具有单个JNDI环境设置）</h5>
<div class="paragraph">
<p>下面的示例演示如何使用JNDI查找环境变量而无需<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="jndiEnvironment"&gt;
        &lt;props&gt;
            &lt;prop key="ping"&gt;pong&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何使用JNDI通过以下命令查找环境变量<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="simple" jndi-name="jdbc/MyDataSource"&gt;
    &lt;jee:environment&gt;ping=pong&lt;/jee:environment&gt;
&lt;/jee:jndi-lookup&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-evironment-multiple"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-evironment-multiple"></a><code><jee:jndi-lookup/></code> （具有多个JNDI环境设置）</h5>
<div class="paragraph">
<p>下面的示例演示如何使用JNDI查找多个环境变量而无需<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="jndiEnvironment"&gt;
        &lt;props&gt;
            &lt;prop key="sing"&gt;song&lt;/prop&gt;
            &lt;prop key="ping"&gt;pong&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例说明如何使用JNDI通过以下方式查找多个环境变量<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="simple" jndi-name="jdbc/MyDataSource"&gt;
    &lt;!-- newline-separated, key-value pairs for the environment (standard Properties format) --&gt;
    &lt;jee:environment&gt;
        sing=song
        ping=pong
    &lt;/jee:environment&gt;
&lt;/jee:jndi-lookup&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-jndi-lookup-complex"><a class="anchor" href="#xsd-schemas-jee-jndi-lookup-complex"></a><code><jee:jndi-lookup/></code> （复杂）</h5>
<div class="paragraph">
<p>下面的示例演示如何使用JNDI查找数据源和许多不同的属性，而无需<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="cache" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
    &lt;property name="lookupOnStartup" value="false"/&gt;
    &lt;property name="expectedType" value="com.myapp.DefaultThing"/&gt;
    &lt;property name="proxyInterface" value="com.myapp.Thing"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用JNDI查找数据源以及许多不同的属性，包括<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:jndi-lookup id="simple"
        jndi-name="jdbc/MyDataSource"
        cache="true"
        resource-ref="true"
        lookup-on-startup="false"
        expected-type="com.myapp.DefaultThing"
        proxy-interface="com.myapp.Thing"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-local-slsb"><a class="anchor" href="#xsd-schemas-jee-local-slsb"></a><code><jee:local-slsb/></code> （简单）</h5>
<div class="paragraph">
<p>的<code><jee:local-slsb/></code>元素配置对本地EJB无状态会话Bean的引用。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置对本地EJB Stateless Session Bean的引用，而无需<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="simple"
        class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/RentalServiceBean"/&gt;
    &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例说明如何使用以下命令配置对本地EJB无状态会话Bean的引用<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:local-slsb id="simpleSlsb" jndi-name="ejb/RentalServiceBean"
        business-interface="com.foo.service.RentalService"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-local-slsb-complex"><a class="anchor" href="#xsd-schemas-jee-local-slsb-complex"></a><code><jee:local-slsb/></code> （复杂）</h5>
<div class="paragraph">
<p>的<code><jee:local-slsb/></code>元素配置对本地EJB无状态会话Bean的引用。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何配置对本地EJB Stateless Session Bean的引用以及许多不带属性的属性<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="complexLocalEjb"
        class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/RentalServiceBean"/&gt;
    &lt;property name="businessInterface" value="com.example.service.RentalService"/&gt;
    &lt;property name="cacheHome" value="true"/&gt;
    &lt;property name="lookupHomeOnStartup" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示如何配置对本地EJB Stateless Session Bean的引用以及带有<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:local-slsb id="complexLocalEjb"
        jndi-name="ejb/RentalServiceBean"
        business-interface="com.foo.service.RentalService"
        cache-home="true"
        lookup-home-on-startup="true"
        resource-ref="true"&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-jee-remote-slsb"><a class="anchor" href="#xsd-schemas-jee-remote-slsb"></a><jee:remote-slsb></jee:remote-slsb></h5>
<div class="paragraph">
<p>的<code><jee:remote-slsb/></code>元素配置对<code>remote</code> EJB无状态会话Bean。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置对远程EJB无状态会话Bean的引用，而无需<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="complexRemoteEjb"
        class="org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean"&gt;
    &lt;property name="jndiName" value="ejb/MyRemoteBean"/&gt;
    &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
    &lt;property name="cacheHome" value="true"/&gt;
    &lt;property name="lookupHomeOnStartup" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
    &lt;property name="homeInterface" value="com.foo.service.RentalService"/&gt;
    &lt;property name="refreshHomeOnConnectFailure" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例说明如何使用以下命令配置对远程EJB无状态会话Bean的引用<code>jee</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;jee:remote-slsb id="complexRemoteEjb"
        jndi-name="ejb/MyRemoteBean"
        business-interface="com.foo.service.RentalService"
        cache-home="true"
        lookup-home-on-startup="true"
        resource-ref="true"
        home-interface="com.foo.service.RentalService"
        refresh-home-on-connect-failure="true"&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-jms"><a class="anchor" href="#xsd-schemas-jms"></a> 9.1.2。的<code>jms</code>架构图</h4>
<div class="paragraph">
<p>的<code>jms</code>元素处理与JMS相关的bean的配置，例如Spring的<a href="#jms-mdp">Message Listener Containers</a> 。这些元素在<a href="#jms">JMS章节</a>标题为“ <a href="#jms-namespace">JMS命名空间支持</a> ”的部分中进行了详细<a href="#jms">介绍</a> 。有关该支持以及<code>jms</code>元素本身。</p>
</div>
<div class="paragraph">
<p>为了完整起见，请在<code>jms</code>模式，您需要在Spring XML配置文件的顶部具有以下序言。以下代码段中的文本引用了正确的架构，因此<code>jms</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jms="http://www.springframework.org/schema/jms"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a> 9.1.3。使用<code><context:mbean-export/></code></h4>
<div class="paragraph">
<p><a href="#jmx-context-mbeanexport">配置基于注释的MBean导出中</a>详细介绍了此元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-cache"><a class="anchor" href="#xsd-schemas-cache"></a> 9.1.4。的<code>cache</code>架构图</h4>
<div class="paragraph">
<p>您可以使用<code>cache</code>支持Spring的元素<code>@CacheEvict</code> ， <code>@CachePut</code>和<code>@Caching</code>注释。它还支持基于声明式XML的缓存。有关详细信息，请参见<a href="#cache-annotation-enable">启用缓存注释</a>和<a href="#cache-declarative-xml">基于声明式XML的缓存</a> 。</p>
</div>
<div class="paragraph">
<p>要使用<code>cache</code>模式，您需要在Spring XML配置文件的顶部具有以下序言。以下代码段中的文本引用了正确的架构，因此<code>cache</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:cache="http://www.springframework.org/schema/cache"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:52 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>