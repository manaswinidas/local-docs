<html lang="zh-Hans" ><head></head><body id="languages" class="book toc2 toc-left" >﻿
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>语言支援</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



<div id="header">
<h1>语言支援</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#kotlin">1。科特林</a>
<ul class="sectlevel2">
<li><a href="#kotlin-requirements">1.1。要求</a></li>
<li><a href="#kotlin-extensions">1.2。扩展名</a></li>
<li><a href="#kotlin-null-safety">1.3。零安全</a></li>
<li><a href="#kotlin-classes-interfaces">1.4。类和接口</a></li>
<li><a href="#kotlin-annotations">1.5。注解</a></li>
<li><a href="#kotlin-bean-definition-dsl">1.6。Bean定义DSL</a></li>
<li><a href="#kotlin-web">1.7。网页</a>
<ul class="sectlevel3">
<li><a href="#router-dsl">1.7.1。路由器DSL</a></li>
<li><a href="#mockmvc-dsl">1.7.2。MockMvc DSL</a></li>
<li><a href="#kotlin-script-templates">1.7.3。Kotlin脚本模板</a></li>
</ul>
</li>
<li><a href="#coroutines">1.8。协程</a>
<ul class="sectlevel3">
<li><a href="#dependencies">1.8.1。依存关系</a></li>
<li><a href="#how-reactive-translates-to-coroutines">1.8.2。反应性如何转换为协程？</a></li>
<li><a href="#controllers">1.8.3。控制器</a></li>
<li><a href="#webflux-fn">1.8.4。WebFlux.fn</a></li>
<li><a href="#transactions">1.8.5。交易次数</a></li>
</ul>
</li>
<li><a href="#kotlin-spring-projects-in-kotlin">1.9。科特林的春季项目</a>
<ul class="sectlevel3">
<li><a href="#final-by-default">1.9.1。默认为最终</a></li>
<li><a href="#using-immutable-class-instances-for-persistence">1.9.2。使用不可变的类实例进行持久化</a></li>
<li><a href="#injecting-dependencies">1.9.3。注入依赖</a></li>
<li><a href="#injecting-configuration-properties">1.9.4。注入配置属性</a></li>
<li><a href="#checked-exceptions">1.9.5。检查异常</a></li>
<li><a href="#annotation-array-attributes">1.9.6。注释数组属性</a></li>
<li><a href="#testing">1.9.7。测试中</a>
<ul class="sectlevel4">
<li><a href="#constructor-injection">构造器注入</a></li>
<li><a href="#code-per_class-code-lifecycle"><code>PER_CLASS</code>生命周期</a></li>
<li><a href="#specification-like-tests">规范式测试</a></li>
<li><a href="#kotlin-webtestclient-issue"><code>WebTestClient</code> Kotlin中的类型推断问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#kotlin-getting-started">1.10。入门</a>
<ul class="sectlevel3">
<li><a href="#code-start-spring-io-code">1.10.1。<code>start.spring.io</code></a></li>
<li><a href="#choosing-the-web-flavor">1.10.2。选择网络风味</a></li>
</ul>
</li>
<li><a href="#kotlin-resources">1.11。资源资源</a>
<ul class="sectlevel3">
<li><a href="#examples">1.11.1。例子</a></li>
<li><a href="#issues">1.11.2。问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#groovy">2。Apache Groovy</a></li>
<li><a href="#dynamic-language">3。动态语言支持</a>
<ul class="sectlevel2">
<li><a href="#dynamic-language-a-first-example">3.1。第一个例子</a></li>
<li><a href="#dynamic-language-beans">3.2。定义由动态语言支持的Bean</a>
<ul class="sectlevel3">
<li><a href="#dynamic-language-beans-concepts">3.2.1。共同概念</a>
<ul class="sectlevel4">
<li><a href="#dynamic-language-beans-concepts-xml-language-element">的<lang:language></lang:language>元件</a></li>
<li><a href="#dynamic-language-refreshable-beans">鲜豆</a></li>
<li><a href="#dynamic-language-beans-inline">内联动态语言源文件</a></li>
<li><a href="#dynamic-language-beans-ctor-injection">在动态语言支持的Bean上下文中了解构造函数注入</a></li>
</ul>
</li>
<li><a href="#dynamic-language-beans-groovy">3.2.2。杂色豆</a>
<ul class="sectlevel4">
<li><a href="#dynamic-language-beans-groovy-customizer">通过使用回调自定义Groovy对象</a></li>
</ul>
</li>
<li><a href="#dynamic-language-beans-bsh">3.2.3。BeanShell豆</a></li>
</ul>
</li>
<li><a href="#dynamic-language-scenarios">3.3。情境</a>
<ul class="sectlevel3">
<li><a href="#dynamic-language-scenarios-controllers">3.3.1。脚本化Spring MVC控制器</a></li>
<li><a href="#dynamic-language-scenarios-validators">3.3.2。脚本验证器</a></li>
</ul>
</li>
<li><a href="#dynamic-language-final-notes">3.4。额外细节</a>
<ul class="sectlevel3">
<li><a href="#dynamic-language-final-notes-aop">3.4.1。AOP —为脚本豆提供建议</a></li>
<li><a href="#dynamic-language-final-notes-scopes">3.4.2。范围界定</a></li>
<li><a href="#xsd-schemas-lang">3.4.3。的<code>lang</code> XML模式</a></li>
</ul>
</li>
<li><a href="#dynamic-language-resources">3.5。更多资源</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a> 1。科特林</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a>是针对JVM（和其他平台）的静态类型语言，它允许编写简洁明了的代码，同时提供与Java编写的现有库的良好<a href="https://kotlinlang.org/docs/reference/java-interop.html">互操作性</a> 。</p>
</div>
<div class="paragraph">
<p>Spring框架为Kotlin提供了一流的支持，并且使开发人员几乎可以将Spring框架当作原生Kotlin框架来编写Kotlin应用程序。</p>
</div>
<div class="paragraph">
<p>用Kotlin构建Spring应用程序的最简单方法是利用Spring Boot及其<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html">专用的Kotlin支持</a> 。
<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">这个全面的教程</a>将教您如何使用<a href="https://start.spring.io/#!language=kotlin&type=gradle-project">start.spring.io</a>使用Kotlin构建Spring Boot应用程序。</p>
</div>
<div class="paragraph">
<p>从Spring Framework 5.2开始，除了Java之外，Kotlin还提供了参考文档的大多数代码示例。</p>
</div>
<div class="paragraph">
<p>随时加入<a href="https://slack.kotlinlang.org/">Kotlin Slack</a>的#spring频道，或与<code>spring</code>和<code>kotlin</code>如果需要支持，请在<a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stackoverflow</a>上将其作为标签。</p>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a> 1.1。要求</h3>
<div class="paragraph">
<p>Spring Framework支持Kotlin 1.3并要求<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib"><code>kotlin-stdlib</code></a> （或其一种变体，例如<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jdk8"><code>kotlin-stdlib-jdk8</code></a> ）和<a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-reflect"><code>kotlin-reflect</code></a>存在于类路径中。如果您在<a href="https://start.spring.io/#!language=kotlin&type=gradle-project">start.spring.io</a>上引导Kotlin项目， <a href="https://start.spring.io/#!language=kotlin&type=gradle-project">则</a>默认情况下会提供它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a> 1.2。扩展名</h3>
<div class="paragraph">
<p>Kotlin <a href="https://kotlinlang.org/docs/reference/extensions.html">扩展</a>提供了使用其他功能扩展现有类的功能。Spring Framework Kotlin API使用这些扩展为现有的Spring API添加了新的Kotlin特定的便利。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/">Spring Framework KDoc API</a>列出并记录了所有可用的Kotlin扩展和DSL。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请记住，必须导入Kotlin扩展才能使用。例如，这意味着<code>GenericApplicationContext.registerBean</code> Kotlin扩展仅在以下情况下可用<code>org.springframework.context.support.registerBean</code>是进口的。就是说，类似于静态导入，在大多数情况下，IDE应该自动建议导入。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如， <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin修饰的类型参数</a>为JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">泛型类型擦除</a>提供了一种解决方法，而Spring Framework提供了一些扩展以利用此功能。这样可以提供更好的Kotlin API <code>RestTemplate</code> ，对于新<code>WebClient</code>来自Spring WebFlux，以及其他各种API。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">其他库，例如Reactor和Spring Data，也为其API提供了Kotlin扩展，因此总体上提供了更好的Kotlin开发经验。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>检索列表<code>User</code> Java中的对象，通常应编写以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;User&gt; users  = client.get().retrieve().bodyToFlux(User.class)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Kotlin和Spring Framework扩展，您可以编写以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val users = client.get().retrieve().bodyToFlux&lt;User&gt;()
// or (both are equivalent)
val users : Flux&lt;User&gt; = client.get().retrieve().bodyToFlux()</code></pre>
</div>
</div>
<div class="paragraph">
<p>与Java中一样， <code>users</code> Kotlin中的Int是强类型的，但是Kotlin的聪明类型推断允许使用较短的语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a> 1.3。零安全</h3>
<div class="paragraph">
<p>Kotlin的主要功能之一是<a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a> ，它可以干净地处理<code>null</code>编译时的值，而不是碰到著名的<code>NullPointerException</code>在运行时。这样可以通过可空声明和表示“值或无值”的语义来使应用程序更安全，而无需支付包装程序的费用，例如<code>Optional</code> 。（Kotlin允许使用具有可为空值的功能结构。请参阅有关<a href="https://www.baeldung.com/kotlin-null-safety">Kotlin空安全性的综合指南</a> 。）</p>
</div>
<div class="paragraph">
<p>尽管Java不允许您在其类型系统中表示null安全<a href="core.html#null-safety">性，但是Spring Framework</a>通过在工具包中声明的对工具友好的注释来提供<a href="core.html#null-safety">整个Spring Framework API的null安全性。</a> <code>org.springframework.lang</code>包。默认情况下，Kotlin中使用的Java API中的<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">类型</a>被识别为<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">平台类型</a> ，对于它们，放宽了空检查。
<a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">Kotlin对JSR-305注释</a>和Spring可空性注释的<a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">支持为</a> Kotlin开发人员提供了整个Spring Framework API的空安全性，其优势在于<code>null</code>相关的问题，在编译时。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">诸如Reactor或Spring Data之类的库提供了空安全API，以利用此功能。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以通过添加以下内容来配置JSR-305检查： <code>-Xjsr305</code>具有以下选项的编译器标志： <code>-Xjsr305={strict|warn|ignore}</code> 。</p>
</div>
<div class="paragraph">
<p>对于Kotlin 1.1+版本，默认行为与<code>-Xjsr305=warn</code> 。的<code>strict</code>从Spring API推断得出的Kotlin类型中需要考虑到Spring Framework API的空安全性，但必须使用此值，但应使用该知识，即使在较小的发行版之间，Spring API的空性声明也可能会演变，并且将来可能会添加更多检查。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尚不支持泛型类型参数，varargs和数组元素的可空性，但应在即将发布的版本中。请参阅<a href="https://github.com/Kotlin/KEEP/issues/79">此讨论</a>以获取最新信息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-classes-interfaces"><a class="anchor" href="#kotlin-classes-interfaces"></a> 1.4。类和接口</h3>
<div class="paragraph">
<p>Spring框架支持各种Kotlin构造，例如通过主构造函数实例化Kotlin类，不可变的类数据绑定以及使用默认值对可选参数进行功能化。</p>
</div>
<div class="paragraph">
<p>Kotlin参数名称通过专用的识别<code>KotlinReflectionParameterNameDiscoverer</code> ，它允许查找接口方法参数名称而无需Java 8 <code>-parameters</code>编译期间要启用的编译器标志。</p>
</div>
<div class="paragraph">
<p>在类路径中找到序列化或反序列化JSON数据所需的<a href="https://github.com/FasterXML/jackson-module-kotlin">Jackson Kotlin模块</a>时，会自动注册该<a href="https://github.com/FasterXML/jackson-module-kotlin">模块</a> ，如果在没有Jackson Jackson Kotlin模块存在的情况下检测到Jackson和Kotlin，则会记录一条警告消息。</p>
</div>
<div class="paragraph">
<p>您可以将配置类声明为<a href="https://kotlinlang.org/docs/reference/nested-classes.html">顶级或嵌套的，但不能</a>声明为<a href="https://kotlinlang.org/docs/reference/nested-classes.html">内部的</a> ，因为后者需要引用外部类。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-annotations"><a class="anchor" href="#kotlin-annotations"></a> 1.5。注解</h3>
<div class="paragraph">
<p>Spring框架还利用<a href="https://kotlinlang.org/docs/reference/null-safety.html">Kotlin空安全性</a>来确定是否需要HTTP参数，而不必显式定义<code>required</code>属性。那意味着<code>@RequestParam name: String?</code>被视为不需要，反之， <code>@RequestParam name: String</code>被视为必填项。Spring Messaging也支持此功能<code>@Header</code>注解。</p>
</div>
<div class="paragraph">
<p>用类似的方式，春豆注射液<code>@Autowired</code> ， <code>@Bean</code> ， 要么<code>@Inject</code>使用此信息来确定是否需要bean。</p>
</div>
<div class="paragraph">
<p>例如， <code>@Autowired lateinit var thing: Thing</code>表示一个类型的bean <code>Thing</code>必须在应用程序上下文中注册，而<code>@Autowired lateinit var thing: Thing?</code>如果此类bean不存在，则不会引发错误。</p>
</div>
<div class="paragraph">
<p>遵循相同的原则， <code>@Bean fun play(toy: Toy, car: Car?) = Baz(toy, Car)</code>表示一个类型的bean <code>Toy</code>必须在应用程序上下文中注册，而类型为的Bean <code>Car</code>可能存在或可能不存在。相同的行为适用于自动装配的构造函数参数。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果对具有属性或主要构造函数参数的类使用Bean验证，则可能需要使用<a href="https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets">注解use-site目标</a> ，例如<code>@field:NotNull</code>要么<code>@get:Size(min=5, max=15)</code> ，如<a href="https://stackoverflow.com/a/35853200/1092077">本堆栈溢出响应中所述</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-bean-definition-dsl"><a class="anchor" href="#kotlin-bean-definition-dsl"></a> 1.6。Bean定义DSL</h3>
<div class="paragraph">
<p>Spring框架通过使用lambda作为XML或Java配置的替代方法来支持以功能性方式注册bean（ <code>@Configuration</code>和<code>@Bean</code> ）。简而言之，它使您可以使用充当<code>FactoryBean</code> 。此机制非常有效，因为它不需要任何反射或CGLIB代理。</p>
</div>
<div class="paragraph">
<p>在Java中，您可以例如编写以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class Foo {}

class Bar {
    private final Foo foo;
    public Bar(Foo foo) {
        this.foo = foo;
    }
}

GenericApplicationContext context = new GenericApplicationContext();
context.registerBean(Foo.class);
context.registerBean(Bar.class, () -&gt; new Bar(context.getBean(Foo.class)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Kotlin中，使用类型化参数和<code>GenericApplicationContext</code> Kotlin扩展，您可以改写以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Foo

class Bar(private val foo: Foo)

val context = GenericApplicationContext().apply {
    registerBean&lt;Foo&gt;()
    registerBean { Bar(it.getBean()) }
}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>什么时候上课<code>Bar</code>有一个单一的构造函数，您甚至可以只指定bean类，构造函数的参数将按类型自动装配：</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context = GenericApplicationContext().apply {
    registerBean&lt;Foo&gt;()
    registerBean&lt;Bar&gt;()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了提供更具声明性的方法和更<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.context.support/-bean-definition-dsl/">简洁的</a>语法，Spring Framework提供了<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.context.support/-bean-definition-dsl/">Kotlin bean定义DSL</a> 。 <code>ApplicationContextInitializer</code>通过一个干净的声明性API，该API可让您处理配置文件和<code>Environment</code>用于自定义Bean的注册方式。</p>
</div>
<div class="paragraph">
<p>在以下示例中注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型推断通常可以避免为Bean引用指定类型，例如<code>ref("bazBean")</code></p>
</li>
<li>
<p>可以使用Kotlin顶级函数通过可调用的引用（例如， <code>bean(::myRouter)</code>在这个例子中</p>
</li>
<li>
<p>指定时<code>bean<Bar>()</code>要么<code>bean(::myRouter)</code> ，参数按类型自动接线</p>
</li>
<li>
<p>的<code>FooBar</code>只有当<code>foobar</code>个人资料已激活</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Foo
class Bar(private val foo: Foo)
class Baz(var message: String = "")
class FooBar(private val baz: Baz)

val myBeans = beans {
    bean&lt;Foo&gt;()
    bean&lt;Bar&gt;()
    bean("bazBean") {
        Baz().apply {
            message = "Hello world"
        }
    }
    profile("foobar") {
        bean { FooBar(ref("bazBean")) }
    }
    bean(::myRouter)
}

fun myRouter(foo: Foo, bar: Bar, baz: Baz) = router {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此DSL是程序化的，这意味着它允许通过<code>if</code>表达，一个<code>for</code>循环或其他任何Kotlin构造。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后您可以使用此<code>beans()</code>用于在应用程序上下文中注册bean的函数，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val context = GenericApplicationContext().apply {
    myBeans.initialize(this)
    refresh()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot是基于JavaConfig的， <a href="https://github.com/spring-projects/spring-boot/issues/8115">尚未提供对功能Bean定义的特定支持</a> ，但是您可以通过Spring Boot的实验性地使用功能Bean定义。 <code>ApplicationContextInitializer</code>支持。有关更多详细信息和最新信息，请参<a href="https://stackoverflow.com/questions/45935931/how-to-use-functional-bean-definition-kotlin-dsl-with-spring-boot-and-spring-w/46033685#46033685">见此堆栈溢出答案</a> 。另请参阅在<a href="https://github.com/spring-projects/spring-fu">Spring Fu培养箱中</a>开发的实验性Kofu DSL。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-web"><a class="anchor" href="#kotlin-web"></a> 1.7。网页</h3>
<div class="sect3">
<h4 id="router-dsl"><a class="anchor" href="#router-dsl"></a> 1.7.1。路由器DSL</h4>
<div class="paragraph">
<p>Spring Framework随附有3种口味的Kotlin路由器DSL：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>带<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.servlet.function/router.html">路由器{}的</a> WebMvc.fn DSL</p>
</li>
<li>
<p>WebFlux.fn带有<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/router.html">路由器{}的</a> <a href="web-reactive.html#webflux-fn">反应性</a> DSL</p>
</li>
<li>
<p>WebFlux.fn与<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/co-router.html">coRouter {}</a>协<a href="#coroutines">程</a> DSL</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些DSL可以让您编写干净且惯用的Kotlin代码来构建一个<code>RouterFunction</code>实例如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class RouterRouterConfiguration {

    @Bean
    fun mainRouter(userHandler: UserHandler) = router {
        accept(TEXT_HTML).nest {
            GET("/") { ok().render("index") }
            GET("/sse") { ok().render("sse") }
            GET("/users", userHandler::findAllView)
        }
        "/api".nest {
            accept(APPLICATION_JSON).nest {
                GET("/users", userHandler::findAll)
            }
            accept(TEXT_EVENT_STREAM).nest {
                GET("/users", userHandler::stream)
            }
        }
        resources("/**", ClassPathResource("static/"))
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此DSL是程序化的，这意味着它允许通过<code>if</code>表达，一个<code>for</code>循环或其他任何Kotlin构造。当您需要根据动态数据（例如，来自数据库）注册路由时，这很有用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关具体示例，请参见<a href="https://github.com/mixitconf/mixit/">MiXiT项目</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mockmvc-dsl"><a class="anchor" href="#mockmvc-dsl"></a> 1.7.2。MockMvc DSL</h4>
<div class="paragraph">
<p>通过提供Kotlin DSL <code>MockMvc</code> Kotlin扩展是为了提供更加惯用的Kotlin API并允许更好的发现性（不使用静态方法）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val mockMvc: MockMvc = ...
mockMvc.get("/person/{name}", "Lee") {
    secure = true
    accept = APPLICATION_JSON
    headers {
        contentLanguage = Locale.FRANCE
    }
    principal = Principal { "foo" }
}.andExpect {
    status { isOk }
    content { contentType(APPLICATION_JSON) }
    jsonPath("$.name") { value("Lee") }
    content { json("""{"someBoolean": false}""", false) }
}.andDo {
    print()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kotlin-script-templates"><a class="anchor" href="#kotlin-script-templates"></a> 1.7.3。Kotlin脚本模板</h4>
<div class="paragraph">
<p>Spring Framework提供了一个<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/view/script/ScriptTemplateView.html"><code>ScriptTemplateView</code></a>它支持<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a>通过使用脚本引擎来呈现模板。</p>
</div>
<div class="paragraph">
<p>通过利用<code>kotlin-script-runtime</code>和<code>scripting-jsr223-embeddable</code>依赖关系，可以使用此类功能通过<a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html</a> DSL或Kotlin多行插值来渲染基于Kotlin的模板<code>String</code> 。</p>
</div>
<div class="paragraph">
<p><code>build.gradle.kts</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    compile("org.jetbrains.kotlin:kotlin-script-runtime:${kotlinVersion}")
    runtime("org.jetbrains.kotlin:kotlin-scripting-jsr223-embeddable:${kotlinVersion}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置通常是通过<code>ScriptTemplateConfigurer</code>和<code>ScriptTemplateViewResolver</code>豆子。</p>
</div>
<div class="paragraph">
<p><code>KotlinScriptConfiguration.kt</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class KotlinScriptConfiguration {

    @Bean
    fun kotlinScriptConfigurer() = ScriptTemplateConfigurer().apply {
        engineName = "kotlin"
        setScripts("scripts/render.kts")
        renderFunction = "render"
        isSharedEngine = false
    }

    @Bean
    fun kotlinScriptViewResolver() = ScriptTemplateViewResolver().apply {
        setPrefix("templates/")
        setSuffix(".kts")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://github.com/sdeleuze/kotlin-script-templating">kotlin-script-templating</a>示例项目。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="coroutines"><a class="anchor" href="#coroutines"></a> 1.8。协程</h3>
<div class="paragraph">
<p>Kotlin <a href="https://kotlinlang.org/docs/reference/coroutines-overview.html">协程</a>是Kotlin轻量级线程，允许以命令式方式编写非阻塞代码。在语言方面，挂起函数为异步操作提供了一种抽象，而在库方面<a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx.coroutines</a>提供了类似的功能<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html"><code>async { }</code></a>和类型<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html"><code>Flow</code></a> 。</p>
</div>
<div class="paragraph">
<p>Spring Framework在以下范围内提供对协程的支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring WebFlux中带注释的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html">Deferred</a>和<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html">Flow</a>返回值支持<code>@Controller</code></p>
</li>
<li>
<p>注释了Spring WebFlux中的暂停功能支持<code>@Controller</code></p>
</li>
<li>
<p>WebFlux <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.client/index.html">客户端</a>和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/index.html">服务器</a>功能API的扩展。</p>
</li>
<li>
<p>WebFlux.fn <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/co-router.html">coRouter {}</a> DSL</p>
</li>
<li>
<p>暂停功能和<code>Flow</code> RSocket中的支持<code>@MessageMapping</code>注释方法</p>
</li>
<li>
<p>扩展<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.messaging.rsocket/index.html"><code>RSocketRequester</code></a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="dependencies"><a class="anchor" href="#dependencies"></a> 1.8.1。依存关系</h4>
<div class="paragraph">
<p>在以下情况下启用协程支持<code>kotlinx-coroutines-core</code>和<code>kotlinx-coroutines-reactor</code>依赖关系在类路径中：</p>
</div>
<div class="paragraph">
<p><code>build.gradle.kts</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {

    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${coroutinesVersion}")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${coroutinesVersion}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>版<code>1.3.0</code>及以上版本受支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-reactive-translates-to-coroutines"><a class="anchor" href="#how-reactive-translates-to-coroutines"></a> 1.8.2。反应性如何转换为协程？</h4>
<div class="paragraph">
<p>对于返回值，以下是从Reactive到Coroutines API的转换：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fun handler(): Mono<Void></code>变成<code>suspend fun handler()</code></p>
</li>
<li>
<p><code>fun handler(): Mono<T></code>变成<code>suspend fun handler(): T</code>要么<code>suspend fun handler(): T?</code>取决于是否<code>Mono</code>可以为空或不为空（具有更多静态类型的优点）</p>
</li>
<li>
<p><code>fun handler(): Flux<T></code>变成<code>fun handler(): Flow<T></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于输入参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果不需要懒惰<code>fun handler(mono: Mono<T>)</code>变成<code>fun handler(value: T)</code>因为可以调用挂起函数来获取value参数。</p>
</li>
<li>
<p>如果需要懒惰， <code>fun handler(mono: Mono<T>)</code>变成<code>fun handler(supplier: suspend () → T)</code>要么<code>fun handler(supplier: suspend () → T?)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html"><code>Flow</code></a>是<code>Flux</code>在协程世界中等效，适用于热流或冷流，有限流或无限流，主要区别如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Flow</code>基于推送，而<code>Flux</code>是推挽混合动力</p>
</li>
<li>
<p>背压通过暂停功能实现</p>
</li>
<li>
<p><code>Flow</code>只有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html">悬浮<code>collect</code>方法</a>和运算符实现为<a href="https://kotlinlang.org/docs/reference/extensions.html">扩展</a></p>
</li>
<li>
<p>借助协程， <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/operators">操作员易于实施</a></p>
</li>
<li>
<p>扩展允许将自定义运算符添加到<code>Flow</code></p>
</li>
<li>
<p>收集操作正在暂停功能</p>
</li>
<li>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html"><code>map</code>操作员</a>支持异步操作（无需<code>flatMap</code> ），因为它需要一个暂停函数参数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>阅读有关<a href="https://spring.io/blog/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow">通过Spring，Coroutines和Kotlin Flow</a>进行<a href="https://spring.io/blog/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow">反应的</a>博客文章，了解更多详细信息，包括如何与Coroutines并发运行代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="controllers"><a class="anchor" href="#controllers"></a> 1.8.3。控制器</h4>
<div class="paragraph">
<p>这是协程的一个例子<code>@RestController</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class CoroutinesRestController(client: WebClient, banner: Banner) {

    @GetMapping("/suspend")
    suspend fun suspendingEndpoint(): Banner {
        delay(10)
        return banner
    }

    @GetMapping("/flow")
    fun flowEndpoint() = flow {
        delay(10)
        emit(banner)
        delay(10)
        emit(banner)
    }

    @GetMapping("/deferred")
    fun deferredEndpoint() = GlobalScope.async {
        delay(10)
        banner
    }

    @GetMapping("/sequential")
    suspend fun sequential(): List&lt;Banner&gt; {
        val banner1 = client
                .get()
                .uri("/suspend")
                .accept(MediaType.APPLICATION_JSON)
                .awaitExchange()
                .awaitBody&lt;Banner&gt;()
        val banner2 = client
                .get()
                .uri("/suspend")
                .accept(MediaType.APPLICATION_JSON)
                .awaitExchange()
                .awaitBody&lt;Banner&gt;()
        return listOf(banner1, banner2)
    }

    @GetMapping("/parallel")
    suspend fun parallel(): List&lt;Banner&gt; = coroutineScope {
        val deferredBanner1: Deferred&lt;Banner&gt; = async {
            client
                    .get()
                    .uri("/suspend")
                    .accept(MediaType.APPLICATION_JSON)
                    .awaitExchange()
                    .awaitBody&lt;Banner&gt;()
        }
        val deferredBanner2: Deferred&lt;Banner&gt; = async {
            client
                    .get()
                    .uri("/suspend")
                    .accept(MediaType.APPLICATION_JSON)
                    .awaitExchange()
                    .awaitBody&lt;Banner&gt;()
        }
        listOf(deferredBanner1.await(), deferredBanner2.await())
    }

    @GetMapping("/error")
    suspend fun error() {
        throw IllegalStateException()
    }

    @GetMapping("/cancel")
    suspend fun cancel() {
        throw CancellationException()
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看渲染<code>@Controller</code>也受支持。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class CoroutinesViewController(banner: Banner) {

    @GetMapping("/")
    suspend fun render(model: Model): String {
        delay(10)
        model["banner"] = banner
        return "index"
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn"><a class="anchor" href="#webflux-fn"></a> 1.8.4。WebFlux.fn</h4>
<div class="paragraph">
<p>这是通过<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/co-router.html">coRouter {}</a> DSL和相关处理程序定义的Coroutines路由器的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class RouterConfiguration {

    @Bean
    fun mainRouter(userHandler: UserHandler) = coRouter {
        GET("/", userHandler::listView)
        GET("/api/user", userHandler::listApi)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class UserHandler(builder: WebClient.Builder) {

    private val client = builder.baseUrl("...").build()

    suspend fun listView(request: ServerRequest): ServerResponse =
            ServerResponse.ok().renderAndAwait("users", mapOf("users" to
            client.get().uri("...").awaitExchange().awaitBody&lt;User&gt;()))

    suspend fun listApi(request: ServerRequest): ServerResponse =
                ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyAndAwait(
                client.get().uri("...").awaitExchange().awaitBody&lt;User&gt;())
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactions"><a class="anchor" href="#transactions"></a> 1.8.5。交易次数</h4>
<div class="paragraph">
<p>从Spring Framework 5.2开始，通过Reactive事务管理的程序化变体支持协同程序上的事务。</p>
</div>
<div class="paragraph">
<p>对于暂停功能， <code>TransactionalOperator.executeAndAwait</code>提供扩展名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.transaction.reactive.executeAndAwait

class PersonRepository(private val operator: TransactionalOperator) {

    suspend fun initDatabase() = operator.executeAndAwait {
        insertPerson1()
        insertPerson2()
    }

    private suspend fun insertPerson1() {
        // INSERT SQL statement
    }

    private suspend fun insertPerson2() {
        // INSERT SQL statement
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于科特林<code>Flow</code> ， 一种<code>Flow<T>.transactional</code>提供扩展名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.transaction.reactive.transactional

class PersonRepository(private val operator: TransactionalOperator) {

    fun updatePeople() = findPeople().map(::updatePerson).transactional(operator)

    private fun findPeople(): Flow&lt;Person&gt; {
        // SELECT SQL statement
    }

    private suspend fun updatePerson(person: Person): Person {
        // UPDATE SQL statement
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-spring-projects-in-kotlin"><a class="anchor" href="#kotlin-spring-projects-in-kotlin"></a> 1.9。科特林的春季项目</h3>
<div class="paragraph">
<p>本节提供了一些值得在Kotlin中开发Spring项目的特定提示和建议。</p>
</div>
<div class="sect3">
<h4 id="final-by-default"><a class="anchor" href="#final-by-default"></a> 1.9.1。默认为最终</h4>
<div class="paragraph">
<p>默认情况下， <a href="https://discuss.kotlinlang.org/t/classes-final-by-default/166">Kotlin中的所有类都是<code>final</code></a> 。的<code>open</code>类上的修饰符与Java的相反<code>final</code> ：它允许其他人从此类继承。这也适用于成员函数，因为它们需要标记为<code>open</code>被覆盖。</p>
</div>
<div class="paragraph">
<p>尽管Kotlin的JVM友好设计通常与Spring毫无冲突，但如果不考虑这一事实，Kotlin的这一特定功能可能会阻止应用程序启动。这是因为春季豆（例如<code>@Configuration</code> CGLIB通常将带注释的类（由于技术原因，默认情况下必须在运行时继承）。解决方法是添加一个<code>open</code>由CGLIB代理的Spring bean的每个类和成员函数上的关键字，这些关键字很快会变得很痛苦，并且违反了保持代码简洁和可预测的Kotlin原则。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">也可以通过使用CGLIB代理来避免配置<code>@Configuration(proxyBeanMethods = false)</code> ，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html#proxyBeanMethods--"><code>proxyBeanMethods</code> Javadoc</a>以获得更多详细信息。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>幸运的是，Kotlin现在提供了<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin"><code>kotlin-spring</code></a>插件（该插件的预配置版本<code>kotlin-allopen</code>插件）会自动打开使用以下批注之一进行批注或元批注的类型的类及其成员函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Component</code></p>
</li>
<li>
<p><code>@Async</code></p>
</li>
<li>
<p><code>@Transactional</code></p>
</li>
<li>
<p><code>@Cacheable</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>元注释支持意味着带有注释的类型<code>@Configuration</code> ， <code>@Controller</code> ， <code>@RestController</code> ， <code>@Service</code> ， 要么<code>@Repository</code>将自动打开这些注释，因为这些注释使用meta注释<code>@Component</code> 。</p>
</div>
<div class="paragraph">
<p><a href="https://start.spring.io/#!language=kotlin&type=gradle-project">start.spring.io</a>默认情况下启用它，因此，实际上，您可以编写Kotlin Bean，而无需任何其他操作<code>open</code>关键字，如Java中一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-immutable-class-instances-for-persistence"><a class="anchor" href="#using-immutable-class-instances-for-persistence"></a> 1.9.2。使用不可变的类实例进行持久化</h4>
<div class="paragraph">
<p>在Kotlin中，在主构造函数中声明只读属性很方便，并且被视为最佳实践，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Person(val name: String, val age: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以选择添加<a href="https://kotlinlang.org/docs/reference/data-classes.html">的<code>data</code></a>使编译器自动从主要构造函数中声明的所有属性派生以下成员的<a href="https://kotlinlang.org/docs/reference/data-classes.html">关键字</a> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>equals()</code>和<code>hashCode()</code></p>
</li>
<li>
<p><code>toString()</code>的形式<code>"User(name=John, age=42)"</code></p>
</li>
<li>
<p><code>componentN()</code>按照声明顺序与属性相对应的函数</p>
</li>
<li>
<p><code>copy()</code>功能</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如以下示例所示，即使在不更改<code>Person</code>属性是只读的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">data class Person(val name: String, val age: Int)

val jack = Person(name = "Jack", age = 1)
val olderJack = jack.copy(age = 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>常见的持久性技术（例如JPA）要求使用默认的构造函数，以防止此类设计。幸运的是，现在这个解决办法<a href="https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-hell">“默认构造函数地狱”</a> ，因为科特林提供<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-jpa-compiler-plugin"><code>kotlin-jpa</code></a>插件，该插件为带有JPA批注的类生成合成的无参数构造函数。</p>
</div>
<div class="paragraph">
<p>如果您需要将这种机制用于其他持久性技术，则可以配置<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#how-to-use-no-arg-plugin"><code>kotlin-noarg</code></a>插入。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Kay发行版开始，Spring Data支持Kotlin不可变类实例，并且不需要<code>kotlin-noarg</code>如果模块使用Spring Data对象映射（例如MongoDB，Redis，Cassandra等），则为插件。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="injecting-dependencies"><a class="anchor" href="#injecting-dependencies"></a> 1.9.3。注入依赖</h4>
<div class="paragraph">
<p>我们的建议是尝试使用<code>val</code>只读（如果可能，则为非空） <a href="https://kotlinlang.org/docs/reference/properties.html">属性</a> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class YourBean(
    private val mongoTemplate: MongoTemplate,
    private val solrClient: SolrClient
)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">具有单个构造函数的类的参数会自动自动关联，因此无需显式<code>@Autowired constructor</code>在上面显示的示例中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您确实需要使用场注入，则可以使用<code>lateinit var</code>构造，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class YourBean {

    @Autowired
    lateinit var mongoTemplate: MongoTemplate

    @Autowired
    lateinit var solrClient: SolrClient
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injecting-configuration-properties"><a class="anchor" href="#injecting-configuration-properties"></a> 1.9.4。注入配置属性</h4>
<div class="paragraph">
<p>在Java中，您可以使用注释（例如， <code>@Value("${property}")</code> ）。但是，在科特林， <code>$</code>是保留字符，用于<a href="https://kotlinlang.org/docs/reference/idioms.html#string-interpolation">字符串插值</a> 。</p>
</div>
<div class="paragraph">
<p>因此，如果您想使用<code>@Value</code> Kotlin中的注释，您需要转义<code>$</code>文字写作<code>@Value("\${property}")</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用Spring Boot，则可能应该使用<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties"><code>@ConfigurationProperties</code></a>代替<code>@Value</code>注释。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>或者，您可以通过声明以下配置Bean来定制属性占位符前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun propertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply {
    setPlaceholderPrefix("%{")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以自定义现有代码（例如Spring Boot执行器或<code>@LocalServerPort</code> ）使用<code>${…​}</code>语法，以及配置Bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun kotlinPropertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply {
    setPlaceholderPrefix("%{")
    setIgnoreUnresolvablePlaceholders(true)
}

@Bean
fun defaultPropertyConfigurer() = PropertySourcesPlaceholderConfigurer()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="checked-exceptions"><a class="anchor" href="#checked-exceptions"></a> 1.9.5。检查异常</h4>
<div class="paragraph">
<p>Java和<a href="https://kotlinlang.org/docs/reference/exceptions.html">Kotlin异常处理</a>非常接近，主要区别在于Kotlin将所有异常视为未经检查的异常。但是，当使用代理对象时（例如，带有注释的类或方法<code>@Transactional</code> ），默认情况下，引发的检查异常将包装在<code>UndeclaredThrowableException</code> 。</p>
</div>
<div class="paragraph">
<p>为了像Java中一样抛出原始异常，方法应使用注释<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-throws/index.html"><code>@Throws</code></a>明确指定抛出的检查异常（例如<code>@Throws(IOException::class)</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="annotation-array-attributes"><a class="anchor" href="#annotation-array-attributes"></a> 1.9.6。注释数组属性</h4>
<div class="paragraph">
<p>Kotlin注释与Java注释大部分相似，但是数组属性（在Spring中广泛使用）的行为有所不同。如<a href="https://kotlinlang.org/docs/reference/annotations.html">Kotlin文档中所述，</a>您可以省略<code>value</code>属性名称，与其他属性不同，将其指定为<code>vararg</code>参数。</p>
</div>
<div class="paragraph">
<p>要了解这意味着什么，请考虑<code>@RequestMapping</code> （这是使用最广泛的Spring注释之一）作为示例。此Java注释声明如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public @interface RequestMapping {

    @AliasFor("path")
    String[] value() default {};

    @AliasFor("value")
    String[] path() default {};

    RequestMethod[] method() default {};

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>典型的用例<code>@RequestMapping</code>是将处理程序方法映射到特定的路径和方法。在Java中，可以为注释数组属性指定一个值，该值将自动转换为数组。</p>
</div>
<div class="paragraph">
<p>这就是为什么可以写<code>@RequestMapping(value = "/toys", method = RequestMethod.GET)</code>要么<code>@RequestMapping(path = "/toys", method = RequestMethod.GET)</code> 。</p>
</div>
<div class="paragraph">
<p>但是，在Kotlin中，您必须编写<code>@RequestMapping("/toys", method = [RequestMethod.GET])</code>要么<code>@RequestMapping(path = ["/toys"], method = [RequestMethod.GET])</code> （方括号必须使用命名数组属性指定）。</p>
</div>
<div class="paragraph">
<p>此特定方法的替代方法<code>method</code>属性（最常见的属性）是使用快捷方式注释，例如<code>@GetMapping</code> ， <code>@PostMapping</code> ， 和别的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">提醒：如果<code>@RequestMapping</code><code>method</code>属性未指定，所有HTTP方法都会匹配，不仅<code>GET</code>一。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="testing"><a class="anchor" href="#testing"></a> 1.9.7。测试中</h4>
<div class="paragraph">
<p>本节介绍结合Kotlin和Spring Framework进行的测试。推荐的测试框架是<a href="https://junit.org/junit5/">JUnit 5</a>以及用于<a href="https://mockk.io/">模拟的Mockk</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用的是Spring Boot，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-kotlin-testing">此相关文档</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="constructor-injection"><a class="anchor" href="#constructor-injection"></a>构造器注入</h5>
<div class="paragraph">
<p>如<a href="testing.html#testcontext-junit-jupiter-di">专用部分所述</a> ，JUnit 5允许构造函数注入bean，这对于Kotlin来说非常有用，以便使用<code>val</code>代替<code>lateinit var</code> 。您可以使用<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/TestConstructor.html"><code>@TestConstructor(autowire = true)</code></a>为所有参数启用自动装配。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@SpringJUnitConfig(TestConfig::class)
@TestConstructor(autowire = true)
class OrderServiceIntegrationTests(val orderService: OrderService,
                                   val customerService: CustomerService) {

    // tests that use the injected OrderService and CustomerService
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="code-per_class-code-lifecycle"><a class="anchor" href="#code-per_class-code-lifecycle"></a><code>PER_CLASS</code>生命周期</h5>
<div class="paragraph">
<p>Kotlin允许您在反引号之间指定有意义的测试函数名称（ <code>`</code> ）。从JUnit 5开始，Kotlin测试类可以使用<code>@TestInstance(TestInstance.Lifecycle.PER_CLASS)</code>注释以启用测试类的单个实例化，从而允许使用<code>@BeforeAll</code>和<code>@AfterAll</code>非静态方法的注释，非常适合Kotlin。</p>
</div>
<div class="paragraph">
<p>您还可以将默认行为更改为<code>PER_CLASS</code>多亏了<code>junit-platform.properties</code>带有一个文件<code>junit.jupiter.testinstance.lifecycle.default = per_class</code>属性。</p>
</div>
<div class="paragraph">
<p>以下示例演示<code>@BeforeAll</code>和<code>@AfterAll</code>非静态方法的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class IntegrationTests {

  val application = Application(8181)
  val client = WebClient.create("http://localhost:8181")

  @BeforeAll
  fun beforeAll() {
    application.start()
  }

  @Test
  fun `Find all users on HTML page`() {
    client.get().uri("/users")
        .accept(TEXT_HTML)
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .test()
        .expectNextMatches { it.contains("Foo") }
        .verifyComplete()
  }

  @AfterAll
  fun afterAll() {
    application.stop()
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specification-like-tests"><a class="anchor" href="#specification-like-tests"></a>规范式测试</h5>
<div class="paragraph">
<p>您可以使用JUnit 5和Kotlin创建类似规范的测试。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SpecificationLikeTests {

  @Nested
  @DisplayName("a calculator")
  inner class Calculator {
     val calculator = SampleCalculator()

     @Test
     fun `should return the result of adding the first number to the second number`() {
        val sum = calculator.sum(2, 4)
        assertEquals(6, sum)
     }

     @Test
     fun `should return the result of subtracting the second number from the first number`() {
        val subtract = calculator.subtract(4, 2)
        assertEquals(2, subtract)
     }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kotlin-webtestclient-issue"><a class="anchor" href="#kotlin-webtestclient-issue"></a><code>WebTestClient</code> Kotlin中的类型推断问题</h5>
<div class="paragraph">
<p>由于<a href="https://youtrack.jetbrains.com/issue/KT-5464">类型推断问题</a> ，您必须使用Kotlin <code>expectBody</code>扩展名（例如<code>.expectBody<String>().isEqualTo("toys")</code> ），因为它为Java API的Kotlin问题提供了解决方法。</p>
</div>
<div class="paragraph">
<p>另请参阅相关的<a href="https://jira.spring.io/browse/SPR-16057">SPR-16057</a>问题。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-getting-started"><a class="anchor" href="#kotlin-getting-started"></a> 1.10。入门</h3>
<div class="paragraph">
<p>学习如何使用Kotlin构建Spring应用程序的最简单方法是遵循<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">专用教程</a> 。</p>
</div>
<div class="sect3">
<h4 id="code-start-spring-io-code"><a class="anchor" href="#code-start-spring-io-code"></a> 1.10.1。<code>start.spring.io</code></h4>
<div class="paragraph">
<p>在Kotlin中启动新Spring框架项目的最简单方法是在<a href="https://start.spring.io/#!language=kotlin&type=gradle-project">start.spring.io</a>上创建新的Spring Boot 2项目。</p>
</div>
</div>
<div class="sect3">
<h4 id="choosing-the-web-flavor"><a class="anchor" href="#choosing-the-web-flavor"></a> 1.10.2。选择网络风味</h4>
<div class="paragraph">
<p>Spring框架现在带有两个不同的Web堆栈： <a href="web.html#mvc">Spring MVC</a>和<a href="web-reactive.html#spring-web-reactive">Spring WebFlux</a> 。</p>
</div>
<div class="paragraph">
<p>如果您要创建处理延迟，长期连接，流传输方案的应用程序，或者要使用网络功能的Kotlin DSL，建议使用Spring WebFlux。</p>
</div>
<div class="paragraph">
<p>对于其他用例，尤其是在使用阻塞技术（例如JPA，Spring MVC及其基于注释的编程模型）的情况下，建议选择。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-resources"><a class="anchor" href="#kotlin-resources"></a> 1.11。资源资源</h3>
<div class="paragraph">
<p>我们建议以下资源供人们学习如何使用Kotlin和Spring框架构建应用程序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/">Kotlin语言参考</a></p>
</li>
<li>
<p><a href="https://slack.kotlinlang.org/">Kotlin Slack</a> （带有专用的#spring频道）</p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stackoverflow，带有<code>spring</code>和<code>kotlin</code>标签</a></p>
</li>
<li>
<p><a href="https://try.kotlinlang.org/">在浏览器中尝试Kotlin</a></p>
</li>
<li>
<p><a href="https://blog.jetbrains.com/kotlin/">Kotlin博客</a></p>
</li>
<li>
<p><a href="https://kotlin.link/">很棒的科特林</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="examples"><a class="anchor" href="#examples"></a> 1.11.1。例子</h4>
<div class="paragraph">
<p>以下Github项目提供了示例，您可以从中学习甚至扩展：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a> ：常规的Spring Boot和Spring Data JPA项目</p>
</li>
<li>
<p><a href="https://github.com/mixitconf/mixit">mixit</a> ：Spring Boot 2，WebFlux和Reactive Spring Data MongoDB</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-functional">spring-kotlin-functional</a> ：独立WebFlux和功能bean定义DSL</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-fullstack">spring-kotlin-fullstack</a> ：WebFlux Kotlin完整示例，其中Kotlin2js用于前端，而不是JavaScript或TypeScript</p>
</li>
<li>
<p><a href="https://github.com/spring-petclinic/spring-petclinic-kotlin">spring-petclinic-kotlin</a> ：Spring PetClinic示例应用程序的Kotlin版本</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-deepdive">spring-kotlin-deepdive</a> ：从Boot 1.0和Java到Boot 2.0和Kotlin的逐步迁移指南</p>
</li>
<li>
<p><a href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-kotlin-samples/spring-cloud-gcp-kotlin-app-sample">spring-cloud-gcp-kotlin-app-sample</a> ：具有Google Cloud Platform Integrations的Spring Boot</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="issues"><a class="anchor" href="#issues"></a> 1.11.2。问题</h4>
<div class="paragraph">
<p>以下列表对与Spring和Kotlin支持有关的未决问题进行了分类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>春季框架</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-framework/issues/20606">无法在Kotlin中将WebTestClient与模拟服务器一起使用</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-framework/issues/20496">在泛型，可变参数和数组元素级别支持空安全性</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>科特林</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-6380">Spring框架支持的父问题</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-5464">Kotlin需要Java不需要的类型推断</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-20283">开放课程的智能演员表回归</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-14984">不可能将并非所有SAM参数都传递为函数</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-15125">通过脚本变量直接支持JSR 223绑定</a></p>
</li>
<li>
<p><a href="https://youtrack.jetbrains.com/issue/KT-6653">Kotlin属性不会覆盖Java样式的getter和setter</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="groovy"><a class="anchor" href="#groovy"></a> 2。Apache Groovy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy是一种功能强大的，可选类型的动态语言，具有静态类型和静态编译功能。它提供了简洁的语法，并且可以与任何现有的Java应用程序顺利集成。</p>
</div>
<div class="paragraph">
<p>Spring框架提供了专用的<code>ApplicationContext</code>支持基于Groovy的Bean定义DSL。有关更多详细信息，请参见<a href="core.html#groovy-bean-definition-dsl">Groovy Bean定义DSL</a> 。</p>
</div>
<div class="paragraph">
<p><a href="#dynamic-language">动态语言支持中</a>提供了对Groovy的进一步支持，包括用Groovy编写的bean，可刷新的脚本bean等。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dynamic-language"><a class="anchor" href="#dynamic-language"></a> 3。动态语言支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring为使用通过Spring使用动态语言（例如Groovy）定义的类和对象提供了全面的支持。这种支持使您可以用受支持的动态语言编写任意数量的类，并使Spring容器透明地实例化，配置和依赖性注入结果对象。</p>
</div>
<div class="paragraph">
<p>Spring的脚本支持主要针对Groovy和BeanShell。除了那些特别受支持的语言之外，还支持JSR-223脚本编制机制与任何支持JSR-223的语言提供程序（从Spring 4.2开始）集成，例如JRuby。</p>
</div>
<div class="paragraph">
<p>您可以找到完全有效的示例，这些示例可以在<a href="#dynamic-language-scenarios">场景中</a>立即使用这种动态语言支持。</p>
</div>
<div class="sect2">
<h3 id="dynamic-language-a-first-example"><a class="anchor" href="#dynamic-language-a-first-example"></a> 3.1。第一个例子</h3>
<div class="paragraph">
<p>本章的大部分内容与详细描述动态语言支持有关。在深入探讨动态语言支持的所有内容之前，我们来看一个使用动态语言定义的bean的简单示例。第一个bean的动态语言是Groovy。（此示例的基础取自Spring测试套件。如果要查看其他任何受支持语言的等效示例，请查看源代码）。</p>
</div>
<div class="paragraph">
<p>下一个示例显示了<code>Messenger</code>接口，Groovy bean将要实现。请注意，此接口是用纯Java定义的。注入的依赖对象引用了<code>Messenger</code>不知道基础实现是Groovy脚本。以下清单显示了<code>Messenger</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例定义了一个依赖于<code>Messenger</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.scripting;

public class DefaultBookingService implements BookingService {

    private Messenger messenger;

    public void setMessenger(Messenger messenger) {
        this.messenger = messenger;
    }

    public void processBooking() {
        // use the injected Messenger object...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例实现了<code>Messenger</code> Groovy中的界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// from the file 'Messenger.groovy'
package org.springframework.scripting.groovy;

// import the Messenger interface (written in Java) that is to be implemented
import org.springframework.scripting.Messenger

// define the implementation in Groovy
class GroovyMessenger implements Messenger {

    String message
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用定制的动态语言标记来定义支持动态语言的Bean，您需要在Spring XML配置文件的顶部具有XML Schema前导。您还需要使用弹簧<code>ApplicationContext</code>实现作为您的IoC容器。将动态语言支持的bean与纯文本一起使用<code>BeanFactory</code>支持实现，但您必须管理Spring内部的管道。</p>
</div>
<div class="paragraph">
<p>有关基于架构的配置的更多信息，请参见<a href="appendix.html#xsd-configuration">基于XML架构的配置</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后，以下示例显示了影响Groovy定义的注入的Bean定义。 <code>Messenger</code>实现成一个实例<code>DefaultBookingService</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;!-- this is the bean definition for the Groovy-backed Messenger implementation --&gt;
    &lt;lang:groovy id="messenger" script-source="classpath:Messenger.groovy"&gt;
        &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
    &lt;/lang:groovy&gt;

    &lt;!-- an otherwise normal bean that will be injected by the Groovy-backed Messenger --&gt;
    &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
        &lt;property name="messenger" ref="messenger" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>bookingService</code>豆（一个<code>DefaultBookingService</code> ）现在可以使用其私有<code>messenger</code>成员变量正常，因为<code>Messenger</code>注入其中的实例是<code>Messenger</code>实例。这里没有什么特别的事情-只是普通的Java和普通的Groovy。</p>
</div>
<div class="paragraph">
<p>希望前面的XML代码段是不言自明的，但是如果不是，请不要过分担心。继续阅读以获取有关先前配置的原因和原因的详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-beans"><a class="anchor" href="#dynamic-language-beans"></a> 3.2。定义由动态语言支持的Bean</h3>
<div class="paragraph">
<p>本节准确地描述了如何使用任何受支持的动态语言来定义Spring托管的bean。</p>
</div>
<div class="paragraph">
<p>注意，本章并不试图解释受支持的动态语言的语法和惯用语。例如，如果您想使用Groovy在应用程序中编写某些类，我们假定您已经了解Groovy。如果您需要有关动态语言本身的更多详细信息，请参阅本章末尾的<a href="#dynamic-language-resources">其他资源</a> 。</p>
</div>
<div class="sect3">
<h4 id="dynamic-language-beans-concepts"><a class="anchor" href="#dynamic-language-beans-concepts"></a> 3.2.1。共同概念</h4>
<div class="paragraph">
<p>使用动态语言支持的bean涉及的步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>自然地为动态语言源代码编写测试。</p>
</li>
<li>
<p>然后编写动态语言源代码本身。</p>
</li>
<li>
<p>通过使用适当的定义动态语言支持的bean <code><lang:language/></code> XML配置中的元素（您可以通过使用Spring API以编程方式定义此类bean，尽管您将必须参考源代码以获取有关如何执行此操作的指导，因为本章不介绍此类高级配置）。请注意，这是一个迭代步骤。每个动态语言源文件至少需要一个bean定义（尽管多个bean定义可以引用同一个动态语言源文件）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>前两个步骤（测试和编写动态语言源文件）超出了本章的范围。有关选择的动态语言，请参见语言规范和参考手册，并继续开发动态语言源文件。不过，您首先要阅读本章的其余部分，因为Spring的动态语言支持确实对动态语言源文件的内容做了一些（小的）假设。</p>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-concepts-xml-language-element"><a class="anchor" href="#dynamic-language-beans-concepts-xml-language-element"></a>的<lang:language></lang:language>元件</h5>
<div class="paragraph">
<p>上<a href="#dynamic-language-beans-concepts">一节中</a>列表的最后一步涉及定义动态语言支持的Bean定义，每个要配置的Bean定义一个（这与常规JavaBean配置没有什么不同）。但是，您可以指定使用容器实例化和配置的类的完全限定类名，而不必指定<code><lang:language/></code>定义动态语言支持bean的元素。</p>
</div>
<div class="paragraph">
<p>每种受支持的语言都有对应的<code><lang:language/></code>元件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><lang:groovy/></code> （时髦）</p>
</li>
<li>
<p><code><lang:bsh/></code> （BeanShell）</p>
</li>
<li>
<p><code><lang:std/></code> （JSR-223，例如与JRuby一起使用）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可用于配置的确切属性和子元素完全取决于定义该bean所使用的语言（本章稍后的特定于语言的部分对此进行了详细说明）。</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-language-refreshable-beans"><a class="anchor" href="#dynamic-language-refreshable-beans"></a>鲜豆</h5>
<div class="paragraph">
<p>Spring对动态语言的支持（也许是唯一）中最引人注目的增值之一就是“可刷新bean”功能。</p>
</div>
<div class="paragraph">
<p>可刷新的bean是动态语言支持的bean。通过少量配置，支持动态语言的Bean可以监视其基础源文件资源中的更改，然后在更改动态语言源文件时重新加载自身（例如，当您在Windows上编辑并保存对文件的更改时）。文件系统）。</p>
</div>
<div class="paragraph">
<p>这使您可以将任何数量的动态语言源文件部署为应用程序的一部分，配置Spring容器以创建由动态语言源文件支持的bean（使用本章中描述的机制），以及（随后，随着需求的变化或其他一些变化）外部因素起作用）编辑动态语言源文件，并使它们所做的任何更改都反映在更改后的动态语言源文件支持的Bean中。无需关闭正在运行的应用程序（或在Web应用程序的情况下重新部署）。如此修订的支持动态语言的Bean从更改后的动态语言源文件中获取了新的状态和逻辑。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，此功能是关闭的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在我们来看一个例子，看看开始使用可刷新bean是多么容易。要启用可刷新bean功能，您必须在<code><lang:language/></code> bean定义的元素。因此，如果我们坚持使用本章前面<a href="#dynamic-language-a-first-example">的示例</a> ，那么以下示例将说明我们将在Spring XML配置中进行哪些更改以实现可刷新的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans&gt;

    &lt;!-- this bean is now 'refreshable' due to the presence of the 'refresh-check-delay' attribute --&gt;
    &lt;lang:groovy id="messenger"
            refresh-check-delay="5000" &lt;!-- switches refreshing on with 5 seconds between checks --&gt;
            script-source="classpath:Messenger.groovy"&gt;
        &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
    &lt;/lang:groovy&gt;

    &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
        &lt;property name="messenger" ref="messenger" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那确实是您要做的。的<code>refresh-check-delay</code>在上定义的属性<code>messenger</code> bean定义是毫秒数，在此毫秒后刷新Bean，并对基础动态语言源文件进行任何更改。您可以通过为负值分配负值来关闭刷新行为<code>refresh-check-delay</code>属性。请记住，默认情况下，刷新行为是禁用的。如果您不希望刷新行为，则不要定义属性。</p>
</div>
<div class="paragraph">
<p>如果然后运行以下应用程序，则可以使用可刷新功能。（请在下一段代码中使用“跳过箍以暂停执行”的恶作剧。）的<code>System.in.read()</code>调用仅存在，以便在您（此情况下的开发人员）离开并编辑基础动态语言源文件时暂停程序的执行，以便在程序恢复执行时在由动态语言支持的bean上触发刷新。</p>
</div>
<div class="paragraph">
<p>以下清单显示了此示例应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger.getMessage());
        // pause execution while I go off and make changes to the source file...
        System.in.read();
        System.out.println(messenger.getMessage());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，出于本示例的目的，假设所有对<code>getMessage()</code>的方法<code>Messenger</code>必须更改实现，以使消息用引号引起来。以下清单显示了您（开发人员）应该对<code>Messenger.groovy</code>程序执行暂停时的源文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.scripting

class GroovyMessenger implements Messenger {

    private String message = "Bingo"

    public String getMessage() {
        // change the implementation to surround the message in quotes
        return "'" + this.message + "'"
    }

    public void setMessage(String message) {
        this.message = message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序运行时，输入暂停之前的输出为<code>I Can Do The Frug</code> 。更改并保存对源文件的更改，并且程序恢复执行后，调用<code>getMessage()</code>动态语言支持的方法<code>Messenger</code>实现是<code>'I Can Do The Frug'</code> （请注意包含其他引号）。</p>
</div>
<div class="paragraph">
<p>如果更改发生在脚本窗口内，则对脚本所做的更改不会触发刷新。 <code>refresh-check-delay</code>值。直到在支持动态语言的bean上调用方法之前，实际上不会进行对脚本的更改。只有在支持动态语言的Bean上调用方法时，它才会检查其基础脚本源是否已更改。与刷新脚本有关的任何异常（例如遇到编译错误或发现脚本文件已被删除）都会导致致命异常传播到调用代码。</p>
</div>
<div class="paragraph">
<p>前面描述的可刷新bean行为不适用于使用定义的动态语言源文件。 <code><lang:inline-script/></code>元素表示法（请参阅<a href="#dynamic-language-beans-inline">内联动态语言源文件</a> ）。此外，它仅适用于实际上可以检测到基础源文件更改的Bean（例如，通过检查文件系统上存在的动态语言源文件的最后修改日期的代码）。</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-inline"><a class="anchor" href="#dynamic-language-beans-inline"></a>内联动态语言源文件</h5>
<div class="paragraph">
<p>动态语言支持还可以迎合直接嵌入在Spring bean定义中的动态语言源文件。更具体地说， <code><lang:inline-script/></code>元素可让您立即在Spring配置文件中定义动态语言源。一个示例可以阐明内联脚本功能的工作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;lang:groovy id="messenger"&gt;
    &lt;lang:inline-script&gt;

package org.springframework.scripting.groovy;

import org.springframework.scripting.Messenger

class GroovyMessenger implements Messenger {
    String message
}

    &lt;/lang:inline-script&gt;
    &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
&lt;/lang:groovy&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将有关在Spring配置文件中定义动态语言源是否是一种好习惯的问题放在一边， <code><lang:inline-script/></code>元素在某些情况下可能很有用。例如，我们可能想快速添加一个Spring <code>Validator</code>实现到Spring MVC <code>Controller</code> 。使用内联源代码只是一时的工作。（有关此类示例，请参见<a href="#dynamic-language-scenarios-validators">脚本验证器</a> 。）</p>
</div>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-ctor-injection"><a class="anchor" href="#dynamic-language-beans-ctor-injection"></a>在动态语言支持的Bean上下文中了解构造函数注入</h5>
<div class="paragraph">
<p>关于Spring的动态语言支持，有一件非常重要的事情要注意。即，您不能（当前）向动态语言支持的bean提供构造函数参数（因此，构造函数注入不适用于动态语言支持的bean）。为了使对构造函数和属性的特殊处理100％清晰，以下代码和配置的混合不起作用：</p>
</div>
<div class="listingblock">
<div class="title">一种行不通的方法</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// from the file 'Messenger.groovy'
package org.springframework.scripting.groovy;

import org.springframework.scripting.Messenger

class GroovyMessenger implements Messenger {

    GroovyMessenger() {}

    // this constructor is not available for Constructor Injection
    GroovyMessenger(String message) {
        this.message = message;
    }

    String message

    String anotherMessage
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;lang:groovy id="badMessenger"
    script-source="classpath:Messenger.groovy"&gt;
    &lt;!-- this next constructor argument will not be injected into the GroovyMessenger --&gt;
    &lt;!-- in fact, this isn't even allowed according to the schema --&gt;
    &lt;constructor-arg value="This will not work" /&gt;

    &lt;!-- only property values are injected into the dynamic-language-backed object --&gt;
    &lt;lang:property name="anotherMessage" value="Passed straight through to the dynamic-language-backed object" /&gt;

&lt;/lang&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在实践中，这种限制并不像它最初出现的那样重要，因为二传手注入是绝大多数开发人员所偏爱的注入方式（我们将讨论是否对另一天来说是一件好事）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-beans-groovy"><a class="anchor" href="#dynamic-language-beans-groovy"></a> 3.2.2。杂色豆</h4>
<div class="paragraph">
<p>本节描述如何在Spring中使用Groovy中定义的bean。</p>
</div>
<div class="paragraph">
<p>Groovy主页包括以下描述：</p>
</div>
<div class="paragraph">
<p>“ Groovy是Java 2平台的一种敏捷动态语言，具有许多人们喜欢的功能，例如Python，Ruby和Smalltalk，使它们可以使用类似Java的语法供Java开发人员使用。”</p>
</div>
<div class="paragraph">
<p>如果您从上至下直接阅读了本章，那么您已经<a href="#dynamic-language-a-first-example">看到</a>了Groovy动态语言支持的bean <a href="#dynamic-language-a-first-example">的示例</a> 。现在考虑另一个示例（再次使用Spring测试套件中的示例）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.scripting;

public interface Calculator {

    int add(int x, int y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例实现了<code>Calculator</code> Groovy中的界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">// from the file 'calculator.groovy'
package org.springframework.scripting.groovy

class GroovyCalculator implements Calculator {

    int add(int x, int y) {
        x + y
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下bean定义使用Groovy中定义的计算器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;-- from the file 'beans.xml' --&gt;
&lt;beans&gt;
    &lt;lang:groovy id="calculator" script-source="classpath:calculator.groovy"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，以下小型应用程序将执行上述配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.scripting;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {

    public static void Main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Calculator calc = (Calculator) ctx.getBean("calculator");
        System.out.println(calc.add(2, 8));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行上述程序的结果输出（毫不奇怪） <code>10</code> 。（有关更多有趣的示例，请参见动态语言展示项目以获得更复杂的示例，或参见本章后面的示例<a href="#dynamic-language-scenarios">场景</a> ）。</p>
</div>
<div class="paragraph">
<p>每个Groovy源文件中定义的类不得超过一个。尽管这在Groovy中是完全合法的，但（可以说）这是一种不好的做法。为了采用一致的方法，您（在Spring小组看来）应该遵守每个源文件一个（公共）类的标准Java约定。</p>
</div>
<div class="sect4">
<h5 id="dynamic-language-beans-groovy-customizer"><a class="anchor" href="#dynamic-language-beans-groovy-customizer"></a>通过使用回调自定义Groovy对象</h5>
<div class="paragraph">
<p>的<code>GroovyObjectCustomizer</code> interface是一个回调，使您可以将其他创建逻辑挂接到创建Groovy支持的bean的过程中。例如，此接口的实现可以调用任何必需的初始化方法，设置一些默认属性值或指定自定义<code>MetaClass</code> 。以下清单显示了<code>GroovyObjectCustomizer</code>接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface GroovyObjectCustomizer {

    void customize(GroovyObject goo);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring框架实例化您的Groovy支持的bean的实例，然后传递创建的<code>GroovyObject</code>到指定的<code>GroovyObjectCustomizer</code> （如果已定义）。您可以使用随附的附件进行任何操作<code>GroovyObject</code>参考。我们希望大多数人都想设置一个自定义<code>MetaClass</code>此回调，下面的示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public final class SimpleMethodTracingCustomizer implements GroovyObjectCustomizer {

    public void customize(GroovyObject goo) {
        DelegatingMetaClass metaClass = new DelegatingMetaClass(goo.getMetaClass()) {

            public Object invokeMethod(Object object, String methodName, Object[] arguments) {
                System.out.println("Invoking '" + methodName + "'.");
                return super.invokeMethod(object, methodName, arguments);
            }
        };
        metaClass.initialize();
        goo.setMetaClass(metaClass);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Groovy中对元编程的完整讨论超出了Spring参考手册的范围。请参阅Groovy参考手册的相关部分，或在线进行搜索。很多文章讨论了这个主题。其实，利用<code>GroovyObjectCustomizer</code>如果使用Spring名称空间支持，则很容易，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- define the GroovyObjectCustomizer just like any other bean --&gt;
&lt;bean id="tracingCustomizer" class="example.SimpleMethodTracingCustomizer"/&gt;

    &lt;!-- ... and plug it into the desired Groovy bean via the 'customizer-ref' attribute --&gt;
    &lt;lang:groovy id="calculator"
        script-source="classpath:org/springframework/scripting/groovy/Calculator.groovy"
        customizer-ref="tracingCustomizer"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不使用Spring名称空间支持，则仍然可以使用<code>GroovyObjectCustomizer</code>功能，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="calculator" class="org.springframework.scripting.groovy.GroovyScriptFactory"&gt;
    &lt;constructor-arg value="classpath:org/springframework/scripting/groovy/Calculator.groovy"/&gt;
    &lt;!-- define the GroovyObjectCustomizer (as an inner bean) --&gt;
    &lt;constructor-arg&gt;
        &lt;bean id="tracingCustomizer" class="example.SimpleMethodTracingCustomizer"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean class="org.springframework.scripting.support.ScriptFactoryPostProcessor"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring Framework 4.3.3开始，您还可以指定Groovy <code>CompilationCustomizer</code> （例如<code>ImportCustomizer</code> ）甚至是完整的Groovy <code>CompilerConfiguration</code>对象与Spring的位置相同<code>GroovyObjectCustomizer</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-beans-bsh"><a class="anchor" href="#dynamic-language-beans-bsh"></a> 3.2.3。BeanShell豆</h4>
<div class="paragraph">
<p>本节描述如何在Spring中使用BeanShell bean。</p>
</div>
<div class="paragraph">
<p>BeanShell主页包含以下描述：{JB}</p>
</div>
<div class="paragraph">
<p>“ BeanShell是一个小型的，免费的，可嵌入的Java源代码解释器，具有动态语言功能，用Java编写。BeanShell动态执行标准Java语法，并通过通用的脚本编写便利进行扩展，例如松散类型，命令和方法闭包（如Perl和JavaScript中的那些）。”</p>
</div>
<div class="paragraph">
<p>与Groovy相比，BeanShell支持的Bean定义需要一些（小的）附加配置。在Spring中实现BeanShell动态语言支持很有趣，因为Spring创建了一个JDK动态代理，该代理实现了在Java中指定的所有接口。 <code>script-interfaces</code>的属性值<code><lang:bsh></code>元素（这就是为什么必须在属性值中至少提供一个接口，并因此在使用BeanShell支持的bean时对接口进行编程的原因）。这意味着对BeanShell支持的对象的每个方法调用都将通过JDK动态代理调用机制进行。</p>
</div>
<div class="paragraph">
<p>现在，我们可以展示一个使用基于BeanShell的Bean的完整工作示例，该Bean实现了<code>Messenger</code>本章前面定义的接口。我们再次显示<code>Messenger</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了BeanShell的“实现”（在此我们宽松地使用术语） <code>Messenger</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String message;

String getMessage() {
    return message;
}

void setMessage(String aMessage) {
    message = aMessage;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了Spring XML，该XML定义了上述“类”的“实例”（同样，在这里我们非常宽松地使用这些术语）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;lang:bsh id="messageService" script-source="classpath:BshMessenger.bsh"
    script-interfaces="org.springframework.scripting.Messenger"&gt;

    &lt;lang:property name="message" value="Hello World!" /&gt;
&lt;/lang:bsh&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关您可能想使用基于BeanShell的bean的某些方案，请参阅<a href="#dynamic-language-scenarios">方案</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-scenarios"><a class="anchor" href="#dynamic-language-scenarios"></a> 3.3。情境</h3>
<div class="paragraph">
<p>用脚本语言定义Spring托管Bean会带来好处的可能方案有很多，而且有很多。本节描述了Spring中对动态语言支持的两种可能的用例。</p>
</div>
<div class="sect3">
<h4 id="dynamic-language-scenarios-controllers"><a class="anchor" href="#dynamic-language-scenarios-controllers"></a> 3.3.1。脚本化Spring MVC控制器</h4>
<div class="paragraph">
<p>可以从使用动态语言支持的bean中受益的一组类是Spring MVC控制器的类。在纯Spring MVC应用程序中，通过Web应用程序的导航流程在很大程度上取决于Spring MVC控制器中封装的代码。由于需要更新Web应用程序的导航流程和其他表示层逻辑以响应支持问题或不断变化的业务需求，因此通过编辑一个或多个动态语言源文件并查看它们，很容易实现任何此类必需的更改。更改立即反映在正在运行的应用程序的状态中。</p>
</div>
<div class="paragraph">
<p>请记住，在像Spring这样的项目所拥护的轻量级架构模型中，您通常旨在拥有一个非常薄的表示层，而应用程序的所有繁琐的业务逻辑都包含在域和服务层类中。通过将Spring MVC控制器开发为动态语言支持的bean，可以通过编辑和保存文本文件来更改表示层逻辑。对此类动态语言源文件的任何更改（取决于配置）都会自动反映在由动态语言源文件支持的Bean中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要对动态语言支持的bean所做的任何更改实现这种自动“提取”，必须启用“ refreshable bean”功能。有关此功能的完整处理，请参见<a href="#dynamic-language-refreshable-beans">Refreshable Beans</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了<code>org.springframework.web.servlet.mvc.Controller</code>使用Groovy动态语言实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// from the file '/WEB-INF/groovy/FortuneController.groovy'
package org.springframework.showcase.fortune.web

import org.springframework.showcase.fortune.service.FortuneService
import org.springframework.showcase.fortune.domain.Fortune
import org.springframework.web.servlet.ModelAndView
import org.springframework.web.servlet.mvc.Controller

import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

class FortuneController implements Controller {

    @Property FortuneService fortuneService

    ModelAndView handleRequest(HttpServletRequest request,
            HttpServletResponse httpServletResponse) {
        return new ModelAndView("tell", "fortune", this.fortuneService.tellFortune())
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;lang:groovy id="fortune"
        refresh-check-delay="3000"
        script-source="/WEB-INF/groovy/FortuneController.groovy"&gt;
    &lt;lang:property name="fortuneService" ref="fortuneService"/&gt;
&lt;/lang:groovy&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-scenarios-validators"><a class="anchor" href="#dynamic-language-scenarios-validators"></a> 3.3.2。脚本验证器</h4>
<div class="paragraph">
<p>Spring可以从动态语言支持的bean提供的灵活性中受益的另一个应用程序开发领域是验证领域。与常规Java相比，使用松散类型的动态语言（可能还支持内联正则表达式）来表达复杂的验证逻辑会更容易。</p>
</div>
<div class="paragraph">
<p>再次，将验证器开发为动态语言支持的bean，使您可以通过编辑和保存简单的文本文件来更改验证逻辑。任何此类更改（取决于配置）都会自动反映在正在运行的应用程序的执行中，而无需重新启动应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要对动态语言支持的bean进行任何更改的自动“提取”，必须启用“ refreshable bean”功能。有关此功能的完整和详细处理，请参见<a href="#dynamic-language-refreshable-beans">Refreshable Beans</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了一个Spring <code>org.springframework.validation.Validator</code>使用Groovy动态语言实现（请参见<a href="core.html#validator">使用Spring的Validator接口</a>进行<a href="core.html#validator">验证</a> ，以获取有关<code>Validator</code>接口）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">import org.springframework.validation.Validator
import org.springframework.validation.Errors
import org.springframework.beans.TestBean

class TestBeanValidator implements Validator {

    boolean supports(Class clazz) {
        return TestBean.class.isAssignableFrom(clazz)
    }

    void validate(Object bean, Errors errors) {
        if(bean.name?.trim()?.size() &gt; 0) {
            return
        }
        errors.reject("whitespace", "Cannot be composed wholly of whitespace.")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-final-notes"><a class="anchor" href="#dynamic-language-final-notes"></a> 3.4。额外细节</h3>
<div class="paragraph">
<p>最后一部分包含与动态语言支持有关的一些其他详细信息。</p>
</div>
<div class="sect3">
<h4 id="dynamic-language-final-notes-aop"><a class="anchor" href="#dynamic-language-final-notes-aop"></a> 3.4.1。AOP —为脚本豆提供建议</h4>
<div class="paragraph">
<p>您可以使用Spring AOP框架来建议脚本化Bean。实际上，Spring AOP框架没有意识到建议使用的Bean可能是脚本Bean，因此您使用（或打算使用）的所有AOP用例和功能都可以与脚本Bean一起使用。当建议脚本豆时，不能使用基于类的代理。您必须使用<a href="core.html#aop-proxying">基于接口的代理</a> 。</p>
</div>
<div class="paragraph">
<p>您不仅限于建议脚本化的bean。您还可以使用受支持的动态语言自己编写方面，并使用此类bean来建议其他Spring bean。不过，这确实是对动态语言支持的高级使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="dynamic-language-final-notes-scopes"><a class="anchor" href="#dynamic-language-final-notes-scopes"></a> 3.4.2。范围界定</h4>
<div class="paragraph">
<p>万一这不是立即显而易见的话，可以以与任何其他Bean相同的方式确定脚本Bean的范围。的<code>scope</code>各种属性<code><lang:language/></code>元素使您可以控制基础脚本化Bean的范围，就像常规Bean一样。（默认范围是<a href="core.html#beans-factory-scopes-singleton">singleton</a> ，与“常规” bean一样。）</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>scope</code>属性定义一个范围为<a href="core.html#beans-factory-scopes-prototype">原型</a>的Groovy bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;lang:groovy id="messenger" script-source="classpath:Messenger.groovy" scope="prototype"&gt;
        &lt;lang:property name="message" value="I Can Do The RoboCop" /&gt;
    &lt;/lang:groovy&gt;

    &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
        &lt;property name="messenger" ref="messenger" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关Spring框架中作用域支持的完整讨论，请参见<a href="core.html#beans">IoC容器</a>中的<a href="core.html#beans-factory-scopes">Bean范围</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-lang"><a class="anchor" href="#xsd-schemas-lang"></a> 3.4.3。的<code>lang</code> XML模式</h4>
<div class="paragraph">
<p>的<code>lang</code> Spring XML配置中的元素处理将以动态语言（例如Groovy或BeanShell）编写的对象暴露为Spring容器中的bean。</p>
</div>
<div class="paragraph">
<p>这些元素（以及动态语言支持）在“ <a href="integration.html#dynamic-language">动态语言支持”</a>中全面介绍。有关该支持以及<code>lang</code>元素。</p>
</div>
<div class="paragraph">
<p>要使用<code>lang</code>模式，您需要在Spring XML配置文件的顶部具有以下序言。以下代码段中的文本引用了正确的架构，因此<code>lang</code>命名空间可供您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-language-resources"><a class="anchor" href="#dynamic-language-resources"></a> 3.5。更多资源</h3>
<div class="paragraph">
<p>以下链接提供了有关本章中引用的各种动态语言的更多资源：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.groovy-lang.org/">Groovy</a>主页</p>
</li>
<li>
<p><a href="http://www.beanshell.org/">BeanShell</a>主页</p>
</li>
<li>
<p><a href="https://www.jruby.org">JRuby</a>主页</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:52 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>