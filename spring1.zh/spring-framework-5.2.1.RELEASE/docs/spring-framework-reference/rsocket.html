<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>插座</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



</head><body id="rsocket" class="book" ><div id="header">
<h1>插座</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了Spring Framework对RSocket协议的支持。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket-overview"><a class="anchor" href="#rsocket-overview"></a> 1。总览</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RSocket是一种应用协议，用于使用以下交互模型之一通过TCP，WebSocket和其他字节流传输进行多路复用，双工通信：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Request-Response</code> —发送一封邮件并收到一封邮件。</p>
</li>
<li>
<p><code>Request-Stream</code> —发送一条消息并接收回消息流。</p>
</li>
<li>
<p><code>Channel</code> —双向发送消息流。</p>
</li>
<li>
<p><code>Fire-and-Forget</code> —发送单向消息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一旦建立了初始连接，由于双方变得对称，并且每一方都可以发起上述交互之一，因此“客户端”与“服务器”的区别将消失。这就是为什么在协议中将参与方称为“请求者”和“响应者”，而将上述交互称为“请求流”或简称为“请求”的原因。</p>
</div>
<div class="paragraph">
<p>这些是RSocket协议的主要功能和优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跨网络边界的<a href="https://www.reactive-streams.org/">反应式流</a>语义-用于流式传输请求，例如<code>Request-Stream</code>和<code>Channel</code> ，背压信号在请求者和响应者之间传播，从而允许请求者从源头放慢响应者的速度，从而减少了对网络层拥塞控制的依赖，并减少了在网络级别或任何级别进行缓冲的需要。</p>
</li>
<li>
<p>请求限制-该功能在<code>LEASE</code>可以从两端发送的帧，以限制给定时间内另一端允许的请求总数。租约会定期更新。</p>
</li>
<li>
<p>会话恢复-这是为断开连接而设计的，需要维护一些状态。状态管理对于应用程序是透明的，并且可以与背压结合使用，从而可以在可能的情况下停止生产者并减少所需的状态量。</p>
</li>
<li>
<p>大邮件的碎片化和重组。</p>
</li>
<li>
<p>Keepalive（心跳）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>RSocket具有多种语言的<a href="https://github.com/rsocket">实现</a> 。<a href="https://github.com/rsocket/rsocket-java">Java库</a>基于<a href="https://projectreactor.io/">Project Reactor</a>和<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>进行传输。这意味着来自应用程序中的Reactive Streams Publishers的信号通过RSocket在网络上透明地传播。</p>
</div>
<div class="sect2">
<h3 id="rsocket-protocol"><a class="anchor" href="#rsocket-protocol"></a> 1.1。协议书</h3>
<div class="paragraph">
<p>RSocket的优点之一是它在线路上具有定义明确的行为，并且易于阅读的<a href="https://rsocket.io/docs/Protocol">规范</a>以及某些协议<a href="https://github.com/rsocket/rsocket/tree/master/Extensions">扩展</a> 。因此，独立于语言实现和更高级别的框架API，阅读规范是一个好主意。本节提供简要概述，以建立一些上下文。</p>
</div>
<div class="paragraph">
<p><strong>连接中</strong></p>
</div>
<div class="paragraph">
<p>最初，客户端通过一些低级流传输（例如TCP或WebSocket）连接到服务器，并发送<code>SETUP</code>框到服务器以设置连接参数。</p>
</div>
<div class="paragraph">
<p>服务器可能拒绝<code>SETUP</code>帧，但是通常在发送（对于客户端）和接收（对于服务器）之后，双方都可以开始发出请求，除非<code>SETUP</code>表示使用租赁语义来限制请求的数量，在这种情况下，双方都必须等待<code>LEASE</code>从另一端开始构架以允许发出请求。</p>
</div>
<div class="paragraph">
<p><strong>发出请求</strong></p>
</div>
<div class="paragraph">
<p>建立连接后，双方都可以通过其中一个框架发起请求<code>REQUEST_RESPONSE</code> ， <code>REQUEST_STREAM</code> ， <code>REQUEST_CHANNEL</code> ， 要么<code>REQUEST_FNF</code> 。这些帧中的每一个都将一条消息从请求者传送到响应者。</p>
</div>
<div class="paragraph">
<p>然后，响应者可以返回<code>PAYLOAD</code>带有响应消息的框架，对于<code>REQUEST_CHANNEL</code>请求者也可以发送<code>PAYLOAD</code>带有更多请求消息的框架。</p>
</div>
<div class="paragraph">
<p>当请求涉及消息流时，例如<code>Request-Stream</code>和<code>Channel</code> ，响应者必须尊重来自请求者的需求信号。需求表示为许多消息。初始需求在<code>REQUEST_STREAM</code>和<code>REQUEST_CHANNEL</code>框架。后续需求通过发出信号<code>REQUEST_N</code>框架。</p>
</div>
<div class="paragraph">
<p>双方还可以通过<code>METADATA_PUSH</code>框架，与任何单个请求无关，而与整个连接有关。</p>
</div>
<div class="paragraph">
<p><strong>讯息格式</strong></p>
</div>
<div class="paragraph">
<p>RSocket消息包含数据和元数据。元数据可用于发送路由，安全令牌等。数据和元数据的格式可以不同。每种类型的Mime类型都在<code>SETUP</code>框架并应用于给定连接上的所有请求。</p>
</div>
<div class="paragraph">
<p>尽管所有消息都可以具有元数据，但是通常每个请求都包含诸如路由之类的元数据，因此仅应请求包含在第一条消息中，即其中一个帧<code>REQUEST_RESPONSE</code> ， <code>REQUEST_STREAM</code> ， <code>REQUEST_CHANNEL</code> ， 要么<code>REQUEST_FNF</code> 。</p>
</div>
<div class="paragraph">
<p>协议扩展定义了用于应用程序的通用元数据格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a> -多个独立格式化的元数据条目。</p>
</li>
<li>
<p><a href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">路由</a> -请求的路由。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-java"><a class="anchor" href="#rsocket-java"></a> 1.2。Java实现</h3>
<div class="paragraph">
<p>RSocket的<a href="https://github.com/rsocket/rsocket-java">Java实现</a>基于<a href="https://projectreactor.io/">Project Reactor</a>构建。TCP和WebSocket的传输基于<a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>构建。作为反应流库，Reactor简化了实现协议的工作。对于应用程序，它自然是适合使用的<code>Flux</code>和<code>Mono</code>具有声明式运算符和透明的背压支持。</p>
</div>
<div class="paragraph">
<p>RSocket Java中的API故意是最小且基本的。它专注于协议功能，而将应用程序编程模型（例如RPC代码生成与其他）作为一个更高级别的独立关注点。</p>
</div>
<div class="paragraph">
<p>主合同<a href="https://github.com/rsocket/rsocket-java/blob/master/rsocket-core/src/main/java/io/rsocket/RSocket.java">机票。RSocket</a>使用以下三种模型对四种请求交互类型进行建模<code>Mono</code>代表对一条消息的承诺， <code>Flux</code>一连串的消息，以及<code>io.rsocket.Payload</code>可以访问数据和元数据作为字节缓冲区的实际消息。的<code>RSocket</code>合同是对称使用的。对于请求，该应用程序具有<code>RSocket</code>执行请求。为了响应，该应用程序实现<code>RSocket</code>处理请求。</p>
</div>
<div class="paragraph">
<p>这并不意味着要进行全面介绍。在大多数情况下，Spring应用程序将不必直接使用其API。但是，独立于Spring查看或试验RSocket可能很重要。RSocket Java存储库包含许多<a href="https://github.com/rsocket/rsocket-java/tree/master/rsocket-examples">示例应用程序</a> ，以演示其API和协议功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-spring"><a class="anchor" href="#rsocket-spring"></a> 1.3。Spring 支持</h3>
<div class="paragraph">
<p>的<code>spring-messaging</code>模块包含以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rsocket-requester">RSocketRequester</a> —流利的API，可以通过<code>io.rsocket.RSocket</code>以及数据和元数据的编码/解码。</p>
</li>
<li>
<p><a href="#rsocket-annot-responders">带注释的响应者</a> — <code>@MessageMapping</code>带注释的处理程序方法进行响应。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>spring-web</code>模块包含<code>Encoder</code>和<code>Decoder</code> RSocket应用程序可能需要的实现，例如Jackson CBOR / JSON和Protobuf。它还包含<code>PathPatternParser</code>可以插入以进行有效的路由匹配。</p>
</div>
<div class="paragraph">
<p>Spring Boot 2.2支持通过TCP或WebSocket站立RSocket服务器，包括在WebFlux服务器中通过WebSocket公开RSocket的选项。还提供了客户端支持和自动配置<code>RSocketRequester.Builder</code>和<code>RSocketStrategies</code> 。有关更多详细信息，请参见Spring Boot参考中的<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-rsocket">RSocket部分</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Security 5.2提供了RSocket支持。</p>
</div>
<div class="paragraph">
<p>Spring Integration 5.2提供了入站和出站网关以与RSocket客户端和服务器进行交互。有关更多详细信息，请参见《 Spring Integration参考手册》。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway支持RSocket连接。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket-requester"><a class="anchor" href="#rsocket-requester"></a> 2。RSocketRequester</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>RSocketRequester</code>提供流利的API来执行RSocket请求，接受和返回数据和元数据的对象，而不是低级数据缓冲区。它可以对称地用于从客户端发出请求和从服务器发出请求。</p>
</div>
<div class="sect2">
<h3 id="rsocket-requester-client"><a class="anchor" href="#rsocket-requester-client"></a> 2.1。客户要求者</h3>
<div class="paragraph">
<p>获得一个<code>RSocketRequester</code>客户端上需要连接到服务器，同时准备并发送初始RSocket <code>SETUP</code>帧。 <code>RSocketRequester</code>为此提供了一个构建器。内部使用RSocket Java <code>RSocketFactory</code> 。</p>
</div>
<div class="paragraph">
<p>这是使用默认设置进行连接的最基本方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
	.connectTcp("localhost", 7000);

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
	.connectWebSocket(URI.create("https://example.org:8080/rsocket"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait
import org.springframework.messaging.rsocket.connectWebSocketAndAwait

val requester = RSocketRequester.builder()
		.connectTcpAndAwait("localhost", 7000)

val requester = RSocketRequester.builder()
		.connectWebSocketAndAwait(URI.create("https://example.org:8080/rsocket"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上是推迟的。实际连接和使用请求者：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Connect asynchronously
RSocketRequester.builder().connectTcp("localhost", 7000)
	.subscribe(requester -&gt; {
		// ...
	});

// Or block
RSocketRequester requester = RSocketRequester.builder()
	.connectTcp("localhost", 7000)
	.block(Duration.ofSeconds(5));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Connect asynchronously
import org.springframework.messaging.rsocket.connectTcpAndAwait

class MyService {

	private var requester: RSocketRequester? = null

	private suspend fun requester() = requester ?:
		RSocketRequester.builder().connectTcpAndAwait("localhost", 7000).also { requester = it }

	suspend fun doSomething() = requester().route(...)
}

// Or block
import org.springframework.messaging.rsocket.connectTcpAndAwait

class MyService {

	private val requester = runBlocking {
		RSocketRequester.builder().connectTcpAndAwait("localhost", 7000)
	}

	suspend fun doSomething() = requester.route(...)
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-requester-client-setup"><a class="anchor" href="#rsocket-requester-client-setup"></a> 2.1.1。连接设置</h4>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code>提供以下内容以自定义初始<code>SETUP</code>帧：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dataMimeType(MimeType)</code> —设置连接数据的mime类型。</p>
</li>
<li>
<p><code>metadataMimeType(MimeType)</code> —设置连接上元数据的mime类型。</p>
</li>
<li>
<p><code>setupData(Object)</code> —要包含在<code>SETUP</code> 。</p>
</li>
<li>
<p><code>setupRoute(String, Object…​)</code> —路由元数据以包含在<code>SETUP</code> 。</p>
</li>
<li>
<p><code>setupMetadata(Object, MimeType)</code> —要包含在其他元数据中<code>SETUP</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于数据，默认的mime类型是从第一个配置的<code>Decoder</code> 。对于元数据，默认的mime类型是<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a> ，它允许每个请求有多个元数据值和mime类型对。通常，两者都不需要更改。</p>
</div>
<div class="paragraph">
<p>数据和元数据<code>SETUP</code>框架是可选的。在服务器端，@ <a href="#rsocket-annot-connectmapping">ConnectMapping</a>方法可用于处理连接的开始以及连接的内容。 <code>SETUP</code>帧。元数据可用于连接级别的安全性。</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-requester-client-strategies"><a class="anchor" href="#rsocket-requester-client-strategies"></a> 2.1.2。策略</h4>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code>接受<code>RSocketStrategies</code>配置请求者。您将需要使用它为数据和元数据值的（反）序列化提供编码器和解码器。默认情况下，仅来自<code>spring-core</code>对于<code>String</code> ， <code>byte[]</code>和<code>ByteBuffer</code>已注册。新增中<code>spring-web</code>提供对可以注册的更多内容的访问，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RSocketStrategies strategies = RSocketStrategies.builder()
	.encoders(encoders -&gt; encoders.add(new Jackson2CborEncoder))
	.decoders(decoders -&gt; decoders.add(new Jackson2CborDecoder))
	.build();

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
	.rsocketStrategies(strategies)
	.connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait

val strategies = RSocketStrategies.builder()
		.encoders { it.add(Jackson2CborEncoder()) }
		.decoders { it.add(Jackson2CborDecoder()) }
		.build()

val requester = RSocketRequester.builder()
		.rsocketStrategies(strategies)
		.connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RSocketStrategies</code>设计为可重复使用。在某些情况下，例如同一应用程序中的客户端和服务器，最好在Spring配置中声明它。</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-requester-client-responder"><a class="anchor" href="#rsocket-requester-client-responder"></a> 2.1.3。客户回应者</h4>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code>可用于将响应者配置为来自服务器的请求。</p>
</div>
<div class="paragraph">
<p>您可以基于服务器上使用的相同基础结构，使用带注释的处理程序进行客户端响应，但是通过编程方式进行了以下注册：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RSocketStrategies strategies = RSocketStrategies.builder()
	.routeMatcher(new PathPatternRouteMatcher())  <i class="conum" data-value="1"></i><b>(1)</b>
	.build();

ClientHandler handler = new ClientHandler(); <i class="conum" data-value="2"></i><b>(2)</b>

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
	.rsocketFactory(RSocketMessageHandler.clientResponder(strategies, handler)) <i class="conum" data-value="3"></i><b>(3)</b>
	.connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>PathPatternRouteMatcher</code>如果<code>spring-web</code>存在，用于有效的路线匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建包含以下内容的响应者<code>@MessageMaping</code>要么<code>@ConnectMapping</code>方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在中使用静态工厂方法<code>RSocketMessageHandler</code>注册一个或多个响应者。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait

val strategies = RSocketStrategies.builder()
		.routeMatcher(PathPatternRouteMatcher())  <i class="conum" data-value="1"></i><b>(1)</b>
		.build()

val handler = ClientHandler() <i class="conum" data-value="2"></i><b>(2)</b>

val requester = RSocketRequester.builder()
		.rsocketFactory(RSocketMessageHandler.clientResponder(strategies, handler)) <i class="conum" data-value="3"></i><b>(3)</b>
		.connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>PathPatternRouteMatcher</code>如果<code>spring-web</code>存在，用于有效的路线匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>创建包含以下内容的响应者<code>@MessageMaping</code>要么<code>@ConnectMapping</code>方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>在中使用静态工厂方法<code>RSocketMessageHandler</code>注册一个或多个响应者。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，以上只是设计用于客户端响应程序的程序化注册的快捷方式。对于替代方案，其中客户端响应者处于Spring配置中，您仍然可以声明<code>RSocketMessageHandler</code>作为Spring bean，然后应用如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
	.rsocketFactory(factory -&gt; factory.acceptor(handler.responder()))
	.connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean
import org.springframework.messaging.rsocket.connectTcpAndAwait

val context: ApplicationContext = ...
val handler = context.getBean&lt;RSocketMessageHandler&gt;()

val requester = RSocketRequester.builder()
		.rsocketFactory { it.acceptor(handler.responder()) }
		.connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于上述情况，您可能还需要使用<code>setHandlerPredicate</code>在<code>RSocketMessageHandler</code>切换到其他检测客户响应者的策略，例如基于自定义注释，例如<code>@RSocketClientResponder</code>与默认<code>@Controller</code> 。在客户端和服务器或同一应用程序中有多个客户端的情况下，这是必需的。</p>
</div>
<div class="paragraph">
<p>有关编程模型的更多信息，请参见带<a href="#rsocket-annot-responders">注释的响应者</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-requester-client-advanced"><a class="anchor" href="#rsocket-requester-client-advanced"></a> 2.1.4。高级</h4>
<div class="paragraph">
<p><code>RSocketRequesterBuilder</code>提供回调以暴露底层<code>ClientRSocketFactory</code>从RSocket Java获得更多关于keepalive间隔，会话恢复，拦截器等的配置选项。您可以按以下方式在该级别上配置选项：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()
	.rsocketFactory(factory -&gt; {
		// ...
	})
	.connectTcp("localhost", 7000);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.connectTcpAndAwait

val requester = RSocketRequester.builder()
		.rsocketFactory {
			//...
		}.connectTcpAndAwait("localhost", 7000)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-requester-server"><a class="anchor" href="#rsocket-requester-server"></a> 2.2。服务器请求者</h3>
<div class="paragraph">
<p>从服务器向连接的客户端发出请求是从服务器获取连接客户端的请求者的问题。</p>
</div>
<div class="paragraph">
<p>在带<a href="#rsocket-annot-responders">注释的响应者中</a> ， <code>@ConnectMapping</code>和<code>@MessageMapping</code>方法支持<code>RSocketRequester</code>论点。使用它来访问连接的请求者。请记住<code>@ConnectMapping</code>方法本质上是<code>SETUP</code>请求开始之前必须处理的框架。因此，必须从一开始就将请求与处理分离。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConnectMapping
Mono&lt;Void&gt; handle(RSocketRequester requester) {
	requester.route("status").data("5")
		.retrieveFlux(StatusReport.class)
		.subscribe(bar -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
			// ...
		});
	return ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>独立于处理，异步启动请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>执行处理并完成退货<code>Mono<Void></code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ConnectMapping
suspend fun handle(requester: RSocketRequester) {
	GlobalScope.launch {
		requester.route("status").data("5").retrieveFlow&lt;StatusReport&gt;().collect { <i class="conum" data-value="1"></i><b>(1)</b>
			// ...
		}
	}
	/// ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>独立于处理，异步启动请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>在挂起功能中执行处理。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-requester-requests"><a class="anchor" href="#rsocket-requester-requests"></a> 2.3。要求</h3>
<div class="paragraph">
<p>有了<a href="#rsocket-requester-client">客户端</a>或<a href="#rsocket-requester-server">服务器</a>请求者后，可以按以下方式发出请求：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ViewBox box = ... ;

Flux&lt;AirportLocation&gt; locations = requester.route("locate.radars.within") <i class="conum" data-value="1"></i><b>(1)</b>
		.data(viewBox) <i class="conum" data-value="2"></i><b>(2)</b>
		.retrieveFlux(AirportLocation.class); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定要包含在请求消息的元数据中的路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>提供请求消息的数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明预期的响应。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val box: ViewBox = ...

val locations = requester.route("locate.radars.within") <i class="conum" data-value="1"></i><b>(1)</b>
		.data(viewBox) <i class="conum" data-value="2"></i><b>(2)</b>
		.retrieveFlow&lt;AirportLocation&gt;() <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>指定要包含在请求消息的元数据中的路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>提供请求消息的数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>声明预期的响应。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>交互类型是根据输入和输出的基数隐式确定的。上面的例子是<code>Request-Stream</code>因为发送了一个值并接收了一个值流。在大多数情况下，只要输入和输出的选择与RSocket交互类型以及响应者期望的输入和输出的类型相匹配，就无需考虑这一点。无效组合的唯一示例是多对一。</p>
</div>
<div class="paragraph">
<p>的<code>data(Object)</code>方法也接受任何反应流<code>Publisher</code> ， 包含<code>Flux</code>和<code>Mono</code> ，以及在<code>ReactiveAdapterRegistry</code> 。对于多值<code>Publisher</code>如<code>Flux</code>产生相同类型的值，请考虑使用重载之一<code>data</code>避免进行类型检查的方法<code>Encoder</code>在每个元素上查找：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">data(Object producer, Class&lt;?&gt; elementClass);
data(Object producer, ParameterizedTypeReference&lt;?&gt; elementTypeRef);</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>data(Object)</code>步骤是可选的。跳过不发送数据的请求：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;AirportLocation&gt; location = requester.route("find.radar.EWR"))
	.retrieveMono(AirportLocation.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.retrieveAndAwait

val location = requester.route("find.radar.EWR")
	.retrieveAndAwait&lt;AirportLocation&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a> （默认设置）并且注册的用户支持这些值，则可以添加额外的元数据值<code>Encoder</code> 。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String securityToken = ... ;
ViewBox viewBox = ... ;
MimeType mimeType = MimeType.valueOf("message/x.rsocket.authentication.bearer.v0");

Flux&lt;AirportLocation&gt; locations = requester.route("locate.radars.within")
		.metadata(securityToken, mimeType)
		.data(viewBox)
		.retrieveFlux(AirportLocation.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.retrieveFlow

val requester: RSocketRequester = ...

val securityToken: String = ...
val viewBox: ViewBox = ...
val mimeType = MimeType.valueOf("message/x.rsocket.authentication.bearer.v0")

val locations = requester.route("locate.radars.within")
		.metadata(securityToken, mimeType)
		.data(viewBox)
		.retrieveFlow&lt;AirportLocation&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于<code>Fire-and-Forget</code>使用<code>send()</code>返回的方法<code>Mono<Void></code> 。请注意<code>Mono</code>仅指示消息已成功发送，而不指示已被处理。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket-annot-responders"><a class="anchor" href="#rsocket-annot-responders"></a> 3。带注释的响应者</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RSocket响应器可以实现为<code>@MessageMapping</code>和<code>@ConnectMapping</code>方法。
<code>@MessageMapping</code>方法处理单个请求，并且<code>@ConnectMapping</code>方法处理连接级事件（设置和元数据推送）。对称地支持带注释的响应者，用于从服务器端响应和从客户端端响应。</p>
</div>
<div class="sect2">
<h3 id="rsocket-annot-responders-server"><a class="anchor" href="#rsocket-annot-responders-server"></a> 3.1。服务器响应者</h3>
<div class="paragraph">
<p>要在服务器端使用带注释的响应者，请添加<code>RSocketMessageHandler</code>到您的Spring配置以检测<code>@Controller</code>豆与<code>@MessageMapping</code>和<code>@ConnectMapping</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
static class ServerConfig {

	@Bean
	public RSocketMessageHandler rsocketMessageHandler() {
		RSocketMessageHandler handler = new RSocketMessageHandler();
		handler.routeMatcher(new PathPatternRouteMatcher());
		return handler;
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class ServerConfig {

	@Bean
	fun rsocketMessageHandler() = RSocketMessageHandler().apply {
		routeMatcher = PathPatternRouteMatcher()
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后通过Java RSocket API启动RSocket服务器并插入<code>RSocketMessageHandler</code>对于响应者，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

CloseableChannel server =
	RSocketFactory.receive()
		.acceptor(handler.responder())
		.transport(TcpServerTransport.create("localhost", 7000))
		.start()
		.block();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.beans.factory.getBean

val context: ApplicationContext = ...
val handler = context.getBean&lt;RSocketMessageHandler&gt;()

val server = RSocketFactory.receive()
		.acceptor(handler.responder())
		.transport(TcpServerTransport.create("localhost", 7000))
		.start().awaitFirst()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RSocketMessageHandler</code>默认情况下支持<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合</a>和<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">路由</a>元数据。如果需要切换到其他mime类型或注册其他元数据mime类型，则可以设置其<a href="#rsocket-metadata-extractor">MetadataExtractor</a> 。</p>
</div>
<div class="paragraph">
<p>您需要设置<code>Encoder</code>和<code>Decoder</code>要支持元数据和数据格式的实例。您可能需要<code>spring-web</code>编解码器实现的模块。</p>
</div>
<div class="paragraph">
<p>默认<code>SimpleRouteMatcher</code>用于通过匹配路线<code>AntPathMatcher</code> 。我们建议插入<code>PathPatternRouteMatcher</code>从<code>spring-web</code>进行有效的路线匹配。RSocket路由可以是分层的，但不是URL路径。两个路由匹配器都配置为使用“。”默认为分隔符，并且没有HTTP网址那样的URL解码。</p>
</div>
<div class="paragraph">
<p><code>RSocketMessageHandler</code>可以通过配置<code>RSocketStrategies</code>如果您需要在同一过程中在客户端和服务器之间共享配置，这可能会很有用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
static class ServerConfig {

	@Bean
	public RSocketMessageHandler rsocketMessageHandler() {
		RSocketMessageHandler handler = new RSocketMessageHandler();
		handler.setRSocketStrategies(rsocketStrategies());
		return handler;
	}

	@Bean
	public RSocketStrategies rsocketStrategies() {
		return RSocketStrategies.builder()
			.encoders(encoders -&gt; encoders.add(new Jackson2CborEncoder))
			.decoders(decoders -&gt; decoders.add(new Jackson2CborDecoder))
			.routeMatcher(new PathPatternRouteMatcher())
			.build();
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class ServerConfig {

	@Bean
	fun rsocketMessageHandler() = RSocketMessageHandler().apply {
		rSocketStrategies = rsocketStrategies()
	}

	@Bean
	fun rsocketStrategies() = RSocketStrategies.builder()
			.encoders { it.add(Jackson2CborEncoder()) }
			.decoders { it.add(Jackson2CborDecoder()) }
			.routeMatcher(PathPatternRouteMatcher())
			.build()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-annot-responders-client"><a class="anchor" href="#rsocket-annot-responders-client"></a> 3.2。客户回应者</h3>
<div class="paragraph">
<p>客户端上的带注释的响应者需要在<code>RSocketRequester.Builder</code> 。有关详细信息，请参阅<a href="#rsocket-requester-client-responder">客户响应者</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-annot-messagemapping"><a class="anchor" href="#rsocket-annot-messagemapping"></a> 3.3。@MessageMapping</h3>
<div class="paragraph">
<p><a href="#rsocket-annot-responders-server">服务器</a>或<a href="#rsocket-annot-responders-client">客户端</a>响应程序配置到位后， <code>@MessageMapping</code>方法可以如下使用：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class RadarsController {

	@MessageMapping("locate.radars.within")
	public Flux&lt;AirportLocation&gt; radars(MapRequest request) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class RadarsController {

	@MessageMapping("locate.radars.within")
	fun radars(request: MapRequest): Flow&lt;AirportLocation&gt; {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您无需显式指定RSocket交互类型。只需声明预期的输入和输出以及路由模式。支持基础架构将适应匹配的请求。</p>
</div>
<div class="paragraph">
<p>支持以下附加参数<code>@MessageMapping</code>方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RSocketRequester</code> —与请求关联的连接的请求者，以向远端提出请求。</p>
</li>
<li>
<p><code>@DestinationVariable</code> —模式中变量的值，例如<code>@MessageMapping("find.radar.{id}")</code> 。</p>
</li>
<li>
<p><code>@Header</code> —访问注册用于提取的元数据值，如<a href="#rsocket-metadata-extractor">MetadataExtractor中所述</a> 。</p>
</li>
<li>
<p><code>@Headers Map<String, Object></code> -访问所有注册用于提取的元数据值，如<a href="#rsocket-metadata-extractor">MetadataExtractor中所述</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-annot-connectmapping"><a class="anchor" href="#rsocket-annot-connectmapping"></a> 3.4。@ConnectMapping</h3>
<div class="paragraph">
<p><code>@ConnectMapping</code>处理<code>SETUP</code> RSocket连接开始时的第一个框架，以及随后通过<code>METADATA_PUSH</code>框架，即<code>metadataPush(Payload)</code>在<code>io.rsocket.RSocket</code> 。</p>
</div>
<div class="paragraph">
<p><code>@ConnectMapping</code>方法支持与<a href="#rsocket-annot-messagemapping">@MessageMapping</a>相同的参数，但是基于来自<code>SETUP</code>和<code>METADATA_PUSH</code>框架。 <code>@ConnectMapping</code>可以有一个模式来将处理范围缩小到在元数据中具有路由的特定连接，或者如果没有声明任何模式，则所有连接都匹配。</p>
</div>
<div class="paragraph">
<p><code>@ConnectMapping</code>方法不能返回数据，必须用声明<code>void</code>要么<code>Mono<Void></code>作为返回值。如果处理为新连接返回错误，则连接被拒绝。不得阻止处理以向<code>RSocketRequester</code>用于连接。有关详细信息，请参见<a href="#rsocket-requester-server">服务器请求</a>程序。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket-metadata-extractor"><a class="anchor" href="#rsocket-metadata-extractor"></a> 4。元数据提取器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>响应者必须解释元数据。
<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a>允许独立格式化的元数据值（例如，用于路由，安全，跟踪），每个元数据值都具有自己的mime类型。应用程序需要一种配置要支持的元数据MIME类型的方法，以及一种访问提取值的方法。</p>
</div>
<div class="paragraph">
<p><code>MetadataExtractor</code>是获取序列化元数据并返回已解码名称/值对的合同，然后可以按名称像标题一样访问该名称/值对，例如，通过<code>@Header</code>在带注释的处理程序方法中。</p>
</div>
<div class="paragraph">
<p><code>DefaultMetadataExtractor</code>可以给<code>Decoder</code>实例以解码元数据。开箱即用，它具有对<a href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">“ message / x.rsocket.routing.v0”的</a>内置支持，并将其解码为<code>String</code>并保存在“路线”键下。对于其他任何哑剧类型，您需要提供一个<code>Decoder</code>并按如下所示注册mime类型：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);
extractor.metadataToExtract(fooMimeType, Foo.class, "foo");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.metadataToExtract

val extractor = DefaultMetadataExtractor(metadataDecoders)
extractor.metadataToExtract&lt;Foo&gt;(fooMimeType, "foo")</code></pre>
</div>
</div>
<div class="paragraph">
<p>复合元数据很好地结合了独立的元数据值。但是，请求者可能不支持复合元数据，或者可以选择不使用它。为了这， <code>DefaultMetadataExtractor</code>可能需要自定义逻辑才能将解码后的值映射到输出映射。这是将JSON用于元数据的示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);
extractor.metadataToExtract(
	MimeType.valueOf("application/vnd.myapp.metadata+json"),
	new ParameterizedTypeReference&lt;Map&lt;String,String&gt;&gt;() {},
	(jsonMap, outputMap) -&gt; {
		outputMap.putAll(jsonMap);
	});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.metadataToExtract

val extractor = DefaultMetadataExtractor(metadataDecoders)
extractor.metadataToExtract&lt;Map&lt;String, String&gt;&gt;(MimeType.valueOf("application/vnd.myapp.metadata+json")) { jsonMap, outputMap -&gt;
	outputMap.putAll(jsonMap)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置时<code>MetadataExtractor</code>通过<code>RSocketStrategies</code> ，您可以让<code>RSocketStrategies.Builder</code>使用配置的解码器创建提取器，然后只需使用回调即可自定义注册，如下所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RSocketStrategies strategies = RSocketStrategies.builder()
	.metadataExtractorRegistry(registry -&gt; {
		registry.metadataToExtract(fooMimeType, Foo.class, "foo");
		// ...
	})
	.build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.messaging.rsocket.metadataToExtract

val strategies = RSocketStrategies.builder()
		.metadataExtractorRegistry { registry: MetadataExtractorRegistry -&gt;
			registry.metadataToExtract&lt;Foo&gt;(fooMimeType, "foo")
			// ...
		}
		.build()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:52 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>