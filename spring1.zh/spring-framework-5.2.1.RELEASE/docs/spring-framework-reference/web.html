<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Web on Servlet堆栈</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>



</head><body id="spring-web" class="book toc2 toc-left" ><div id="header">
<h1>Web on Servlet堆栈</h1>
<div class="details">
<span id="revnumber">版本5.2.1。发布</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#mvc">1。Spring Web MVC</a>
<ul class="sectlevel2">
<li><a href="#mvc-servlet">1.1。分派器</a>
<ul class="sectlevel3">
<li><a href="#mvc-servlet-context-hierarchy">1.1.1。上下文层次</a></li>
<li><a href="#mvc-servlet-special-bean-types">1.1.2。Special bean types</a></li>
<li><a href="#mvc-servlet-config">1.1.3。Web MVC配置</a></li>
<li><a href="#mvc-container-config">1.1.4。Servlet配置</a></li>
<li><a href="#mvc-servlet-sequence">1.1.5。处理中</a></li>
<li><a href="#mvc-handlermapping-interceptor">1.1.6。拦截</a></li>
<li><a href="#mvc-exceptionhandlers">1.1.7。例外情况</a>
<ul class="sectlevel4">
<li><a href="#mvc-excetionhandlers-handling">解析器链</a></li>
<li><a href="#mvc-ann-customer-servlet-container-error-page">容器错误页面</a></li>
</ul>
</li>
<li><a href="#mvc-viewresolver">1.1.8。查看分辨率</a>
<ul class="sectlevel4">
<li><a href="#mvc-viewresolver-handling">处理方式</a></li>
<li><a href="#mvc-redirecting-redirect-prefix">重新导向</a></li>
<li><a href="#mvc-redirecting-forward-prefix">转寄</a></li>
<li><a href="#mvc-multiple-representations">内容协商</a></li>
</ul>
</li>
<li><a href="#mvc-localeresolver">1.1.9。语言环境</a>
<ul class="sectlevel4">
<li><a href="#mvc-timezone">时区</a></li>
<li><a href="#mvc-localeresolver-acceptheader">标头解析器</a></li>
<li><a href="#mvc-localeresolver-cookie">Cookie解析器</a></li>
<li><a href="#mvc-localeresolver-session">会话解析器</a></li>
<li><a href="#mvc-localeresolver-interceptor">区域拦截器</a></li>
</ul>
</li>
<li><a href="#mvc-themeresolver">1.1.10。主题</a>
<ul class="sectlevel4">
<li><a href="#mvc-themeresolver-defining">定义主题</a></li>
<li><a href="#mvc-themeresolver-resolving">解决主题</a></li>
</ul>
</li>
<li><a href="#mvc-multipart">1.1.11。多部分解析器</a>
<ul class="sectlevel4">
<li><a href="#mvc-multipart-resolver-commons">Apache Commons<code>FileUpload</code></a></li>
<li><a href="#mvc-multipart-resolver-standard">Servlet 3.0</a></li>
</ul>
</li>
<li><a href="#mvc-logging">1.1.12。记录中</a>
<ul class="sectlevel4">
<li><a href="#mvc-logging-sensitive-data">敏感数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#filters">1.2。筛选器</a>
<ul class="sectlevel3">
<li><a href="#filters-http-put">1.2.1。表格数据</a></li>
<li><a href="#filters-forwarded-headers">1.2.2。转发的标题</a></li>
<li><a href="#filters-shallow-etag">1.2.3。浅ETag</a></li>
<li><a href="#filters-cors">1.2.4。CORS</a></li>
</ul>
</li>
<li><a href="#mvc-controller">1.3。带注释的控制器</a>
<ul class="sectlevel3">
<li><a href="#mvc-ann-controller">1.3.1。宣言</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-requestmapping-proxying">AOP代理</a></li>
</ul>
</li>
<li><a href="#mvc-ann-requestmapping">1.3.2。请求映射</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-requestmapping-uri-templates">URI模式</a></li>
<li><a href="#mvc-ann-requestmapping-pattern-comparison">模式比较</a></li>
<li><a href="#mvc-ann-requestmapping-suffix-pattern-match">后缀匹配</a></li>
<li><a href="#mvc-ann-requestmapping-rfd">后缀匹配和RFD</a></li>
<li><a href="#mvc-ann-requestmapping-consumes">消耗媒体类型</a></li>
<li><a href="#mvc-ann-requestmapping-produces">可生产的媒体类型</a></li>
<li><a href="#mvc-ann-requestmapping-params-and-headers">参数，标题</a></li>
<li><a href="#mvc-ann-requestmapping-head-options">HTTP HEAD，选项</a></li>
<li><a href="#mvc-ann-requestmapping-composed">自定义注释</a></li>
<li><a href="#mvc-ann-requestmapping-registration">明确注册</a></li>
</ul>
</li>
<li><a href="#mvc-ann-methods">1.3.3。处理程序方法</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-arguments">方法参数</a></li>
<li><a href="#mvc-ann-return-types">返回值</a></li>
<li><a href="#mvc-ann-typeconversion">类型转换</a></li>
<li><a href="#mvc-ann-matrix-variables">矩阵变量</a></li>
<li><a href="#mvc-ann-requestparam"><code>@RequestParam</code></a></li>
<li><a href="#mvc-ann-requestheader"><code>@RequestHeader</code></a></li>
<li><a href="#mvc-ann-cookievalue"><code>@CookieValue</code></a></li>
<li><a href="#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a></li>
<li><a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a></li>
<li><a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a></li>
<li><a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a></li>
<li><a href="#mvc-redirecting-passing-data">重定向属性</a></li>
<li><a href="#mvc-flash-attributes">Flash属性</a></li>
<li><a href="#mvc-multipart-forms">多部分</a></li>
<li><a href="#mvc-ann-requestbody"><code>@RequestBody</code></a></li>
<li><a href="#mvc-ann-httpentity">HttpEntity</a></li>
<li><a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a></li>
<li><a href="#mvc-ann-responseentity">响应实体</a></li>
<li><a href="#mvc-ann-jackson">杰克逊JSON</a></li>
</ul>
</li>
<li><a href="#mvc-ann-modelattrib-methods">1.3.4。模型</a></li>
<li><a href="#mvc-ann-initbinder">1.3.5。<code>DataBinder</code></a></li>
<li><a href="#mvc-ann-exceptionhandler">1.3.6。例外情况</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-exceptionhandler-args">方法参数</a></li>
<li><a href="#mvc-ann-exceptionhandler-return-values">返回值</a></li>
<li><a href="#mvc-ann-rest-exceptions">REST API例外</a></li>
</ul>
</li>
<li><a href="#mvc-ann-controller-advice">1.3.7。控制器建议</a></li>
</ul>
</li>
<li><a href="#webmvc-fn">1.4。功能端点</a>
<ul class="sectlevel3">
<li><a href="#webmvc-fn-overview">1.4.1。总览</a></li>
<li><a href="#webmvc-fn-handler-functions">1.4.2。处理函数</a>
<ul class="sectlevel4">
<li><a href="#webmvc-fn-request"><code>ServerRequest</code></a></li>
<li><a href="#webmvc-fn-response"><code>ServerResponse</code></a></li>
<li><a href="#webmvc-fn-handler-classes">处理程序类</a></li>
<li><a href="#webmvc-fn-handler-validation">验证方式</a></li>
</ul>
</li>
<li><a href="#webmvc-fn-router-functions">1.4.3。<code>RouterFunction</code></a>
<ul class="sectlevel4">
<li><a href="#webmvc-fn-predicates">谓词</a></li>
<li><a href="#webmvc-fn-routes">路线</a></li>
<li><a href="#nested-routes">嵌套路线</a></li>
</ul>
</li>
<li><a href="#webmvc-fn-running">1.4.4。运行服务器</a></li>
<li><a href="#webmvc-fn-handler-filter-function">1.4.5。过滤处理程序功能</a></li>
</ul>
</li>
<li><a href="#mvc-uri-building">1.5。URI链接</a>
<ul class="sectlevel3">
<li><a href="#web-uricomponents">1.5.1。UriComponents</a></li>
<li><a href="#web-uribuilder">1.5.2。UriBuilder</a></li>
<li><a href="#web-uri-encoding">1.5.3。URI编码</a></li>
<li><a href="#mvc-servleturicomponentsbuilder">1.5.4。相对Servlet请求</a></li>
<li><a href="#mvc-links-to-controllers">1.5.5。链接到控制器</a></li>
<li><a href="#mvc-links-to-controllers-from-views">1.5.6。视图中的链接</a></li>
</ul>
</li>
<li><a href="#mvc-ann-async">1.6。异步请求</a>
<ul class="sectlevel3">
<li><a href="#mvc-ann-async-deferredresult">1.6.1。<code>DeferredResult</code></a></li>
<li><a href="#mvc-ann-async-callable">1.6.2。<code>Callable</code></a></li>
<li><a href="#mvc-ann-async-processing">1.6.3。处理中</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-async-exceptions">异常处理</a></li>
<li><a href="#mvc-ann-async-interception">拦截</a></li>
<li><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></li>
</ul>
</li>
<li><a href="#mvc-ann-async-http-streaming">1.6.4。HTTP流</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-async-objects">对象</a></li>
<li><a href="#mvc-ann-async-sse">上证所</a></li>
<li><a href="#mvc-ann-async-output-stream">原始数据</a></li>
</ul>
</li>
<li><a href="#mvc-ann-async-reactive-types">1.6.5。反应类型</a></li>
<li><a href="#mvc-ann-async-disconnects">1.6.6。断开连接</a></li>
<li><a href="#mvc-ann-async-configuration">1.6.7。组态</a>
<ul class="sectlevel4">
<li><a href="#mvc-ann-async-configuration-servlet3">Servlet容器</a></li>
<li><a href="#mvc-ann-async-configuration-spring-mvc">春季MVC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mvc-cors">1.7。CORS</a>
<ul class="sectlevel3">
<li><a href="#mvc-cors-intro">1.7.1。介绍</a></li>
<li><a href="#mvc-cors-processing">1.7.2。处理中</a></li>
<li><a href="#mvc-cors-controller">1.7.3。<code>@CrossOrigin</code></a></li>
<li><a href="#mvc-cors-global">1.7.4。全局配置</a>
<ul class="sectlevel4">
<li><a href="#mvc-cors-global-java">Java配置</a></li>
<li><a href="#mvc-cors-global-xml">XML配置</a></li>
</ul>
</li>
<li><a href="#mvc-cors-filter">1.7.5。CORS过滤器</a></li>
</ul>
</li>
<li><a href="#mvc-web-security">1.8。网络安全</a></li>
<li><a href="#mvc-caching">1.9。HTTP缓存</a>
<ul class="sectlevel3">
<li><a href="#mvc-caching-cachecontrol">1.9.1。<code>CacheControl</code></a></li>
<li><a href="#mvc-caching-etag-lastmodified">1.9.2。控制器</a></li>
<li><a href="#mvc-caching-static-resources">1.9.3。静态资源</a></li>
<li><a href="#mvc-httpcaching-shallowetag">1.9.4。 <code>ETag</code> 过滤</a></li>
</ul>
</li>
<li><a href="#mvc-view">1.10。查看技术</a>
<ul class="sectlevel3">
<li><a href="#mvc-view-thymeleaf">1.10.1。胸腺</a></li>
<li><a href="#mvc-view-freemarker">1.10.2。FreeMarker</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-freemarker-contextconfig">查看配置</a></li>
<li><a href="#mvc-views-freemarker">FreeMarker配置</a></li>
<li><a href="#mvc-view-freemarker-forms">表格处理</a></li>
</ul>
</li>
<li><a href="#mvc-view-groovymarkup">1.10.3。Groovy标记</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-groovymarkup-configuration">组态</a></li>
<li><a href="#mvc-view-groovymarkup-example">例</a></li>
</ul>
</li>
<li><a href="#mvc-view-script">1.10.4。脚本视图</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-script-dependencies">要求</a></li>
<li><a href="#mvc-view-script-integrate">脚本模板</a></li>
</ul>
</li>
<li><a href="#mvc-view-jsp">1.10.5。JSP和JSTL</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-jsp-resolver">查看解析器</a></li>
<li><a href="#mvc-view-jsp-jstl">JSP与JSTL</a></li>
<li><a href="#mvc-view-jsp-tags">Spring的JSP标签库</a></li>
<li><a href="#mvc-view-jsp-formtaglib">Spring的表单标签库</a></li>
</ul>
</li>
<li><a href="#mvc-view-tiles">1.10.6。瓷砖</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-tiles-dependencies">依存关系</a></li>
<li><a href="#mvc-view-tiles-integrate">组态</a></li>
</ul>
</li>
<li><a href="#mvc-view-feeds">1.10.7。RSS和Atom</a></li>
<li><a href="#mvc-view-document">1.10.8。PDF和Excel</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-document-intro">文档视图简介</a></li>
<li><a href="#mvc-view-document-pdf">PDF检视</a></li>
<li><a href="#mvc-view-document-excel">Excel视图</a></li>
</ul>
</li>
<li><a href="#mvc-view-jackson">1.10.9。杰克逊</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-json-mapping">基于Jackson的JSON MVC视图</a></li>
<li><a href="#mvc-view-xml-mapping">基于Jackson的XML视图</a></li>
</ul>
</li>
<li><a href="#mvc-view-xml-marshalling">1.10.10。XML编组</a></li>
<li><a href="#mvc-view-xslt">1.10.11。XSLT视图</a>
<ul class="sectlevel4">
<li><a href="#mvc-view-xslt-beandefs">豆子</a></li>
<li><a href="#mvc-view-xslt-controllercode">控制者</a></li>
<li><a href="#mvc-view-xslt-transforming">转型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mvc-config">1.11。MVC配置</a>
<ul class="sectlevel3">
<li><a href="#mvc-config-enable">1.11.1。启用MVC配置</a></li>
<li><a href="#mvc-config-customize">1.11.2。MVC Config API</a></li>
<li><a href="#mvc-config-conversion">1.11.3。类型转换</a></li>
<li><a href="#mvc-config-validation">1.11.4。验证方式</a></li>
<li><a href="#mvc-config-interceptors">1.11.5。拦截器</a></li>
<li><a href="#mvc-config-content-negotiation">1.11.6。内容类型</a></li>
<li><a href="#mvc-config-message-converters">1.11.7。讯息转换器</a></li>
<li><a href="#mvc-config-view-controller">1.11.8。查看控制器</a></li>
<li><a href="#mvc-config-view-resolvers">1.11.9。查看解析器</a></li>
<li><a href="#mvc-config-static-resources">1.11.10。静态资源</a></li>
<li><a href="#mvc-default-servlet-handler">1.11.11。默认Servlet</a></li>
<li><a href="#mvc-config-path-matching">1.11.12。路径匹配</a></li>
<li><a href="#mvc-config-advanced-java">1.11.13。高级Java配置</a></li>
<li><a href="#mvc-config-advanced-xml">1.11.14。高级XML配置</a></li>
</ul>
</li>
<li><a href="#mvc-http2">1.12。HTTP / 2</a></li>
</ul>
</li>
<li><a href="#webmvc-client">2。REST客户端</a>
<ul class="sectlevel2">
<li><a href="#webmvc-resttemplate">2.1。<code>RestTemplate</code></a></li>
<li><a href="#webmvc-webclient">2.2。<code>WebClient</code></a></li>
</ul>
</li>
<li><a href="#testing">3。测试中</a></li>
<li><a href="#websocket">4。Web套接字</a>
<ul class="sectlevel2">
<li><a href="#websocket-intro">4.1。WebSocket简介</a>
<ul class="sectlevel3">
<li><a href="#websocket-intro-architecture">4.1.1。HTTP与WebSocket</a></li>
<li><a href="#websocket-intro-when-to-use">4.1.2。何时使用WebSockets</a></li>
</ul>
</li>
<li><a href="#websocket-server">4.2。WebSocket API</a>
<ul class="sectlevel3">
<li><a href="#websocket-server-handler">4.2.1。<code>WebSocketHandler</code></a></li>
<li><a href="#websocket-server-handshake">4.2.2。WebSocket握手</a></li>
<li><a href="#websocket-server-deployment">4.2.3。部署方式</a></li>
<li><a href="#websocket-server-runtime-configuration">4.2.4。服务器配置</a></li>
<li><a href="#websocket-server-allowed-origins">4.2.5。允许的来源</a></li>
</ul>
</li>
<li><a href="#websocket-fallback">4.3。SockJS后备</a>
<ul class="sectlevel3">
<li><a href="#websocket-fallback-sockjs-overview">4.3.1。总览</a></li>
<li><a href="#websocket-fallback-sockjs-enable">4.3.2。启用SockJS</a></li>
<li><a href="#websocket-fallback-xhr-vs-iframe">4.3.3。IE 8和9</a></li>
<li><a href="#websocket-fallback-sockjs-heartbeat">4.3.4。心跳</a></li>
<li><a href="#websocket-fallback-sockjs-servlet3-async">4.3.5。客户端断开连接</a></li>
<li><a href="#websocket-fallback-cors">4.3.6。SockJS和CORS</a></li>
<li><a href="#websocket-fallback-sockjs-client">4.3.7。<code>SockJsClient</code></a></li>
</ul>
</li>
<li><a href="#websocket-stomp">4.4。脚踩</a>
<ul class="sectlevel3">
<li><a href="#websocket-stomp-overview">4.4.1。总览</a></li>
<li><a href="#websocket-stomp-benefits">4.4.2。好处</a></li>
<li><a href="#websocket-stomp-enable">4.4.3。启用STOMP</a></li>
<li><a href="#websocket-stomp-server-config">4.4.4。WebSocket服务器</a></li>
<li><a href="#websocket-stomp-message-flow">4.4.5。消息流</a></li>
<li><a href="#websocket-stomp-handle-annotations">4.4.6。带注释的控制器</a>
<ul class="sectlevel4">
<li><a href="#websocket-stomp-message-mapping"><code>@MessageMapping</code></a></li>
<li><a href="#websocket-stomp-subscribe-mapping"><code>@SubscribeMapping</code></a></li>
<li><a href="#websocket-stomp-exception-handler"><code>@MessageExceptionHandler</code></a></li>
</ul>
</li>
<li><a href="#websocket-stomp-handle-send">4.4.7。传送讯息</a></li>
<li><a href="#websocket-stomp-handle-simple-broker">4.4.8。简单经纪人</a></li>
<li><a href="#websocket-stomp-handle-broker-relay">4.4.9。外部经纪人</a></li>
<li><a href="#websocket-stomp-handle-broker-relay-configure">4.4.10。连接到经纪人</a></li>
<li><a href="#websocket-stomp-destination-separator">4.4.11。点作为分隔符</a></li>
<li><a href="#websocket-stomp-authentication">4.4.12。认证方式</a></li>
<li><a href="#websocket-stomp-authentication-token-based">4.4.13。令牌认证</a></li>
<li><a href="#websocket-stomp-user-destination">4.4.14。用户目的地</a></li>
<li><a href="#websocket-stomp-ordered-messages">4.4.15。消息顺序</a></li>
<li><a href="#websocket-stomp-appplication-context-events">4.4.16。大事记</a></li>
<li><a href="#websocket-stomp-interceptors">4.4.17。拦截</a></li>
<li><a href="#websocket-stomp-client">4.4.18。STOMP客户端</a></li>
<li><a href="#websocket-stomp-websocket-scope">4.4.19。WebSocket范围</a></li>
<li><a href="#websocket-stomp-configuration-performance">4.4.20。性能</a></li>
<li><a href="#websocket-stomp-stats">4.4.21。监控方式</a></li>
<li><a href="#websocket-stomp-testing">4.4.22。测试中</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#web-integration">5，其他Web框架</a>
<ul class="sectlevel2">
<li><a href="#web-integration-common">5.1。通用配置</a></li>
<li><a href="#jsf">5.2。JSF</a>
<ul class="sectlevel3">
<li><a href="#jsf-springbeanfaceselresolver">5.2.1。Spring Bean解析器</a></li>
<li><a href="#jsf-facescontextutils">5.2.2。使用<code>FacesContextUtils</code></a></li>
</ul>
</li>
<li><a href="#struts">5.3。Apache Struts 2.x</a></li>
<li><a href="#tapestry">5.4。Apache Tapestry 5.x</a></li>
<li><a href="#web-integration-resources">5.5。更多资源</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>文档的此部分涵盖对基于Servlet API构建并部署到Servlet容器的Servlet堆栈Web应用程序的支持。各个章节包括<a href="#mvc">Spring MVC</a> ， <a href="#mvc-view">View Technologies</a> ， <a href="#mvc-cors">CORS支持</a>和<a href="#websocket">WebSocket支持</a> 。对于无功栈的Web应用程序，请参见<a href="web-reactive.html#spring-web-reactive">网站上无堆栈</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mvc"><a class="anchor" href="#mvc"></a> 1。Spring Web MVC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就已包含在Spring Framework 中。正式名称“ Spring Web MVC”来自其源模块的名称（ <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc"><code>spring-webmvc</code></a> ），但通常称为“ Spring MVC”。</p>
</div>
<div class="paragraph">
<p>与Spring Web MVC并行，Spring Framework 5.0引入了一个反应式堆栈Web框架，其名称“ Spring WebFlux”也基于其源模块（ <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux"><code>spring-webflux</code></a> ）。本节介绍Spring Web MVC。 <a href="web-reactive.html#spring-web-reactive">下一节将</a>介绍Spring WebFlux。</p>
</div>
<div class="paragraph">
<p>有关基线信息以及与Servlet容器和Java EE版本范围的兼容性，请参见Spring Framework <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a> 。</p>
</div>
<div class="sect2">
<h3 id="mvc-servlet"><a class="anchor" href="#mvc-servlet"></a> 1.1。分派器</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-dispatcher-handler">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>与其他许多Web框架一样，Spring MVC围绕前端控制器模式进行设计，其中中央<code>Servlet</code> ， <code>DispatcherServlet</code>提供了一种用于请求处理的共享算法，而实际工作则由可配置的委托组件执行。该模型非常灵活，并支持多种工作流程。</p>
</div>
<div class="paragraph">
<p>的<code>DispatcherServlet</code> ，以及任何<code>Servlet</code> ，需要使用Java配置或在Servlet中根据Servlet规范进行声明和映射。 <code>web.xml</code> 。反过来， <code>DispatcherServlet</code>使用Spring配置文件来发现它需要请求映射，视图解析，异常处理，委托组件<a href="#mvc-servlet-special-bean-types">和更多</a> 。</p>
</div>
<div class="paragraph">
<p>以下Java配置示例注册并初始化了<code>DispatcherServlet</code> ，由Servlet容器自动检测到（请参阅<a href="#mvc-container-config">Servlet Config</a> ）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext servletCxt) {

        // Load Spring web application configuration
        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
        ac.register(AppConfig.class);
        ac.refresh();

        // Create and register the DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(ac);
        ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/app/*");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyWebApplicationInitializer : WebApplicationInitializer {

    override fun onStartup(servletCxt: ServletContext) {

        // Load Spring web application configuration
        val ac = AnnotationConfigWebApplicationContext()
        ac.register(AppConfig::class.java)
        ac.refresh()

        // Create and register the DispatcherServlet
        val servlet = DispatcherServlet(ac)
        val registration = servletCxt.addServlet("app", servlet)
        registration.setLoadOnStartup(1)
        registration.addMapping("/app/*")
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">除了直接使用ServletContext API外，您还可以扩展<code>AbstractAnnotationConfigDispatcherServletInitializer</code>并覆盖特定方法（请参见<a href="#mvc-servlet-context-hierarchy">Context Hierarchy</a>下的示例）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的例子<code>web.xml</code>配置寄存器并初始化<code>DispatcherServlet</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;app&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;app&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot遵循不同的初始化顺序。Spring Boot并没有陷入Servlet容器的生命周期，而是使用Spring配置来引导自身和嵌入式Servlet容器。 <code>Filter</code>和<code>Servlet</code>声明在Spring配置中检测到并注册到Servlet容器中。有关更多详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container">Spring Boot文档</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="mvc-servlet-context-hierarchy"><a class="anchor" href="#mvc-servlet-context-hierarchy"></a> 1.1.1。上下文层次</h4>
<div class="paragraph">
<p><code>DispatcherServlet</code>期望一个<code>WebApplicationContext</code> （平原的延伸<code>ApplicationContext</code> ）进行自己的配置。 <code>WebApplicationContext</code>有一个链接到<code>ServletContext</code>和<code>Servlet</code>与之相关联。它也必然会<code>ServletContext</code>这样应用程序可以在<code>RequestContextUtils</code>查找<code>WebApplicationContext</code>如果他们需要访问它。</p>
</div>
<div class="paragraph">
<p>对于许多应用程序，只有一个<code>WebApplicationContext</code>很简单就足够了。也可能有一个上下文层次结构，其中一个根<code>WebApplicationContext</code>被多个共享<code>DispatcherServlet</code> （或其他<code>Servlet</code> ）实例，每个实例都有自己的孩子<code>WebApplicationContext</code>组态。看到<a href="core.html#context-introduction">的附加功能<code>ApplicationContext</code></a>有关上下文层次结构功能的更多信息。</p>
</div>
<div class="paragraph">
<p>根<code>WebApplicationContext</code>通常包含基础结构Bean，例如需要在多个数据库之间共享的数据存储库和业务服务<code>Servlet</code>实例。这些Bean被有效地继承，并且可以在Servlet特定的子级中重写（即重新声明）。 <code>WebApplicationContext</code> ，通常包含给定本地的bean <code>Servlet</code> 。下图显示了这种关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mvc-context-hierarchy.png" alt="mvc上下文层次结构">
</div>
</div>
<div class="paragraph">
<p>以下示例配置了一个<code>WebApplicationContext</code>层次结构：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class&lt;?&gt;[] { RootConfig.class };
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class&lt;?&gt;[] { App1Config.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/app1/*" };
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

    override fun getRootConfigClasses(): Array&lt;Class&lt;*&gt;&gt; {
        return arrayOf(RootConfig::class.java)
    }

    override fun getServletConfigClasses(): Array&lt;Class&lt;*&gt;&gt; {
        return arrayOf(App1Config::class.java)
    }

    override fun getServletMappings(): Array&lt;String&gt; {
        return arrayOf("/app1/*")
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果不需要应用程序上下文层次结构，则应用程序可以通过以下方式返回所有配置： <code>getRootConfigClasses()</code>和<code>null</code>从<code>getServletConfigClasses()</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了<code>web.xml</code>当量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果不需要应用程序上下文层次结构，则应用程序可以仅配置“根”上下文，并保留<code>contextConfigLocation</code> Servlet参数为空。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-servlet-special-bean-types"><a class="anchor" href="#mvc-servlet-special-bean-types"></a> 1.1.2。Special bean types</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-special-bean-types">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>DispatcherServlet</code>委托特殊bean处理请求并提供适当的响应。所谓“特殊豆”，是指春季管理<code>Object</code>实施框架合同的实例。这些通常带有内置合同，但是您可以自定义它们的属性并扩展或替换它们。</p>
</div>
<div class="paragraph">
<p>下表列出了由<code>DispatcherServlet</code> ：</p>
</div>
<table id="mvc-webappctx-special-beans-tbl" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">豆类</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将请求与<a href="#mvc-handlermapping-interceptor">拦截器</a>列表一起映射到处理程序，以进行预处理和后期处理。映射基于某些条件，其细节因<code>HandlerMapping</code>实施。
</p><p class="tableblock">两个主要<code>HandlerMapping</code>实现是<code>RequestMappingHandlerMapping</code> （支持<code>@RequestMapping</code>带注释的方法）和<code>SimpleUrlHandlerMapping</code> （它将URI路径模式的显式注册维护到处理程序）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">帮助<code>DispatcherServlet</code>调用映射到请求的处理程序，而不管实际如何调用该处理程序。例如，调用带注释的控制器需要解析注释。一个的主要目的<code>HandlerAdapter</code>是为了屏蔽<code>DispatcherServlet</code>从这样的细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决异常的策略，可能将它们映射到处理程序，HTML错误视图或其他目标。请参阅<a href="#mvc-exceptionhandlers">例外</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-viewresolver"><code>ViewResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决逻辑<code>String</code>从处理程序返回到实际的基于视图的视图名称<code>View</code>呈现给响应。请参阅<a href="#mvc-viewresolver">查看分辨率</a>和<a href="#mvc-view">查看技术</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-localeresolver"><code>LocaleResolver</code></a> ， <a href="#mvc-timezone">LocaleContextResolver</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决<code>Locale</code>客户正在使用并可能在其时区使用，以便能够提供国际化的视图。请参阅<a href="#mvc-localeresolver">语言环境</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-themeresolver"><code>ThemeResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决Web应用程序可以使用的主题，例如，提供个性化的布局。请参阅<a href="#mvc-themeresolver">主题</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-multipart"><code>MultipartResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">借助一些多部分解析库来解析多部分请求的抽象（例如，浏览器表单文件上传）。请参见<a href="#mvc-multipart">Multipart Resolver</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#mvc-flash-attributes"><code>FlashMapManager</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储和检索“输入”和“输出” <code>FlashMap</code>通常可用于通过重定向将属性从一个请求传递到另一个请求。请参见<a href="#mvc-flash-attributes">Flash属性</a> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-servlet-config"><a class="anchor" href="#mvc-servlet-config"></a> 1.1.3。Web MVC配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-framework-config">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>应用程序可以声明处理请求所需的<a href="#mvc-servlet-special-bean-types">特殊Bean类型</a>中列出的基础结构<a href="#mvc-servlet-special-bean-types">Bean</a> 。的<code>DispatcherServlet</code>检查<code>WebApplicationContext</code>对于每个特殊的豆。如果没有匹配的Bean类型，它会退回到列在其中的默认类型。 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties"><code>DispatcherServlet.properties</code></a> 。</p>
</div>
<div class="paragraph">
<p>在大多数情况下， <a href="#mvc-config">MVC Config</a>是最佳起点。它使用Java或XML声明所需的bean，并提供更高级别的配置回调API对其进行自定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot依靠MVC Java配置来配置Spring MVC，并提供了许多额外的方便选项。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-container-config"><a class="anchor" href="#mvc-container-config"></a> 1.1.4。Servlet配置</h4>
<div class="paragraph">
<p>在Servlet 3.0以上的环境中，您可以选择以编程方式配置Servlet容器，也可以与<code>web.xml</code>文件。以下示例注册了一个<code>DispatcherServlet</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        XmlWebApplicationContext appContext = new XmlWebApplicationContext();
        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.WebApplicationInitializer

class MyWebApplicationInitializer : WebApplicationInitializer {

    override fun onStartup(container: ServletContext) {
        val appContext = XmlWebApplicationContext()
        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")

        val registration = container.addServlet("dispatcher", DispatcherServlet(appContext))
        registration.setLoadOnStartup(1)
        registration.addMapping("/")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebApplicationInitializer</code>是Spring MVC提供的接口，可确保检测到您的实现并将其自动用于初始化任何Servlet 3容器。的抽象基类实现<code>WebApplicationInitializer</code>命名<code>AbstractDispatcherServletInitializer</code>使注册更容易<code>DispatcherServlet</code>通过重写方法来指定servlet映射和位置<code>DispatcherServlet</code>组态。</p>
</div>
<div class="paragraph">
<p>对于使用基于Java的Spring配置的应用程序，建议这样做，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return null;
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class&lt;?&gt;[] { MyWebConfig.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

    override fun getRootConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
        return null
    }

    override fun getServletConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
        return arrayOf(MyWebConfig::class.java)
    }

    override fun getServletMappings(): Array&lt;String&gt; {
        return arrayOf("/")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用基于XML的Spring配置，则应直接从<code>AbstractDispatcherServletInitializer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }

    @Override
    protected WebApplicationContext createServletApplicationContext() {
        XmlWebApplicationContext cxt = new XmlWebApplicationContext();
        cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
        return cxt;
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

    override fun createRootApplicationContext(): WebApplicationContext? {
        return null
    }

    override fun createServletApplicationContext(): WebApplicationContext {
        return XmlWebApplicationContext().apply {
            setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")
        }
    }

    override fun getServletMappings(): Array&lt;String&gt; {
        return arrayOf("/")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AbstractDispatcherServletInitializer</code>还提供了方便的添加方式<code>Filter</code>实例并将它们自动映射到<code>DispatcherServlet</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

    // ...

    @Override
    protected Filter[] getServletFilters() {
        return new Filter[] {
            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

    // ...

    override fun getServletFilters(): Array&lt;Filter&gt; {
        return arrayOf(HiddenHttpMethodFilter(), CharacterEncodingFilter())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个过滤器都会根据其具体类型添加一个默认名称，并自动映射到<code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>isAsyncSupported</code>受保护的方法<code>AbstractDispatcherServletInitializer</code>提供一个位置来启用异步支持<code>DispatcherServlet</code>并将所有过滤器映射到它。默认情况下，此标志设置为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>最后，如果您需要进一步自定义<code>DispatcherServlet</code>本身，您可以覆盖<code>createDispatcherServlet</code>方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-servlet-sequence"><a class="anchor" href="#mvc-servlet-sequence"></a> 1.1.5。处理中</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-dispatcher-handler-sequence">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>DispatcherServlet</code>处理请求如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>WebApplicationContext</code>在请求中进行搜索并绑定，将其作为控制器和流程中其他元素可以使用的属性。默认情况下， <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>键。</p>
</li>
<li>
<p>语言环境解析器绑定到请求，以使流程中的元素解析在处理请求（呈现视图，准备数据等）时要使用的语言环境。如果不需要语言环境解析，则不需要语言环境解析器。</p>
</li>
<li>
<p>主题解析器绑定到请求，以使诸如视图之类的元素确定要使用的主题。如果不使用主题，则可以将其忽略。</p>
</li>
<li>
<p>如果指定多部分文件解析器，则将检查请求中是否有多部分。如果找到多部分，则将请求包装在<code>MultipartHttpServletRequest</code>用于处理中其他元素的进一步处理。有关<a href="#mvc-multipart">多</a>部分处理的更多信息，请参见<a href="#mvc-multipart">Multipart Resolver</a> 。</p>
</li>
<li>
<p>搜索适当的处理程序。如果找到处理程序，则执行与该处理程序（预处理器，后处理器和控制器）关联的执行链，以准备模型或渲染。或者，对于带注释的控制器，可以呈现响应（在<code>HandlerAdapter</code> ），而不是返回视图。</p>
</li>
<li>
<p>如果返回模型，则呈现视图。如果没有返回任何模型（可能是由于预处理器或后处理器拦截了该请求，可能出于安全原因），则不会呈现任何视图，因为该请求可能已经被满足。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>HandlerExceptionResolver</code>在中声明的豆子<code>WebApplicationContext</code>用于解决在请求处理期间引发的异常。这些异常解析器允许定制逻辑以解决异常。有关更多详细信息，请参见<a href="#mvc-exceptionhandlers">异常</a> 。</p>
</div>
<div class="paragraph">
<p>春天<code>DispatcherServlet</code>也支持归还<code>last-modification-date</code> ，由Servlet API指定。确定特定请求的最后修改日期的过程非常简单： <code>DispatcherServlet</code>查找适当的处理程序映射并测试找到的处理程序是否实现了<code>LastModified</code>接口。如果是这样，则<code>long getLastModified(request)</code>的方法<code>LastModified</code>接口返回给客户端。</p>
</div>
<div class="paragraph">
<p>您可以自定义个人<code>DispatcherServlet</code>实例通过添加Servlet初始化参数（ <code>init-param</code>元素）到Servlet声明中<code>web.xml</code>文件。下表列出了受支持的参数：</p>
</div>
<table id="mvc-disp-servlet-init-params-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表格1。DispatcherServlet初始化参数</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实现的类<code>ConfigurableWebApplicationContext</code> ，由该Servlet实例化和本地配置。默认， <code>XmlWebApplicationContext</code>用来。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contextConfigLocation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传递给上下文实例的字符串（由<code>contextClass</code> ）表示可以在哪里找到上下文。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。对于具有两次定义的bean的多个上下文位置，以最新位置为准。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>namespace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的命名空间<code>WebApplicationContext</code> 。默认为<code>[servlet-name]-servlet</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>throwExceptionIfNoHandlerFound</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否抛出<code>NoHandlerFoundException</code>未找到请求处理程序时。然后可以使用<code>HandlerExceptionResolver</code> （例如，通过使用<code>@ExceptionHandler</code>控制器方法）并按其他方式进行处理。
</p><p class="tableblock">默认情况下，此设置为<code>false</code> ，在这种情况下<code>DispatcherServlet</code>将响应状态设置为404（NOT_FOUND），而不会引发异常。
</p><p class="tableblock">请注意，如果还配置了<a href="#mvc-default-servlet-handler">默认servlet处理</a> ，则始终将未解决的请求转发到默认servlet，并且永远不会引发404。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="mvc-handlermapping-interceptor"><a class="anchor" href="#mvc-handlermapping-interceptor"></a> 1.1.6。拦截</h4>
<div class="paragraph">
<p>所有<code>HandlerMapping</code>实现支持处理程序拦截器，当您要将特定功能应用于某些请求时（例如，检查主体），该处理程序拦截器非常有用。拦截器必须实施<code>HandlerInterceptor</code>来自<code>org.springframework.web.servlet</code>包含三种方法的程序包，这些方法应提供足够的灵活性来执行各种预处理和后处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>preHandle(..)</code> ：执行实际的处理程序之前</p>
</li>
<li>
<p><code>postHandle(..)</code> ：处理程序执行后</p>
</li>
<li>
<p><code>afterCompletion(..)</code> ：完整请求完成后</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>preHandle(..)</code>方法返回布尔值。您可以使用此方法来中断或继续执行链的处理。当此方法返回时<code>true</code> ，处理程序执行链继续。当返回false时， <code>DispatcherServlet</code>假定拦截器本身已经处理了请求（例如，渲染了一个适当的视图），并且没有继续执行其他拦截器和执行链中的实际处理程序。</p>
</div>
<div class="paragraph">
<p>见<a href="#mvc-config-interceptors">拦截</a>在MVC配置一节来配置拦截器如何例子。您也可以使用个人设置工具直接注册<code>HandlerMapping</code>实现。</p>
</div>
<div class="paragraph">
<p>注意<code>postHandle</code>不太有用<code>@ResponseBody</code>和<code>ResponseEntity</code>在其中写入和提交响应的方法<code>HandlerAdapter</code>和之前<code>postHandle</code> 。这意味着对响应进行任何更改为时已晚，例如添加额外的标头。对于这种情况，您可以实施<code>ResponseBodyAdvice</code>并将其声明为<a href="#mvc-ann-controller-advice">Controller Advice</a> Bean或直接在上配置<code>RequestMappingHandlerAdapter</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-exceptionhandlers"><a class="anchor" href="#mvc-exceptionhandlers"></a> 1.1.7。例外情况</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-dispatcher-exceptions">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>如果在请求映射期间发生异常或从请求处理程序引发异常（例如<code>@Controller</code> ）， <code>DispatcherServlet</code>代表链<code>HandlerExceptionResolver</code> bean解决异常并提供替代处理，通常是错误响应。</p>
</div>
<div class="paragraph">
<p>下表列出了可用的<code>HandlerExceptionResolver</code>实现：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">表2。HandlerExceptionResolver实现</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>HandlerExceptionResolver</code></th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SimpleMappingExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异常类名称和错误视图名称之间的映射。对于在浏览器应用程序中呈现错误页面很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决了Spring MVC引发的异常，并将它们映射到HTTP状态代码。另请参阅<code>ResponseEntityExceptionHandler</code>和<a href="#mvc-ann-rest-exceptions">REST API异常</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决带有的异常<code>@ResponseStatus</code>注释，并根据注释中的值将它们映射到HTTP状态代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionHandlerExceptionResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过调用<code>@ExceptionHandler</code>一个方法<code>@Controller</code>或一个<code>@ControllerAdvice</code>类。请参见<a href="#mvc-ann-exceptionhandler">@ExceptionHandler方法</a> 。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="mvc-excetionhandlers-handling"><a class="anchor" href="#mvc-excetionhandlers-handling"></a>解析器链</h5>
<div class="paragraph">
<p>您可以通过声明多个来形成异常解析器链<code>HandlerExceptionResolver</code> Spring配置中设置bean并设置它们<code>order</code>所需的属性。order属性越高，异常解析器的定位就越晚。</p>
</div>
<div class="paragraph">
<p>合同<code>HandlerExceptionResolver</code>指定它可以返回：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>ModelAndView</code>指向错误视图。</p>
</li>
<li>
<p>一个空的<code>ModelAndView</code>如果异常是在解析器中处理的。</p>
</li>
<li>
<p><code>null</code>如果异常未解决，则供后续的解析器尝试；如果异常仍在末尾，则允许其冒泡到Servlet容器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#mvc-config">MVC Config</a>自动为默认的Spring MVC异常声明内置解析器，用于<code>@ResponseStatus</code>带注释的异常，并支持<code>@ExceptionHandler</code>方法。您可以自定义该列表或替换它。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-customer-servlet-container-error-page"><a class="anchor" href="#mvc-ann-customer-servlet-container-error-page"></a>容器错误页面</h5>
<div class="paragraph">
<p>如果任何一个仍然无法解决异常<code>HandlerExceptionResolver</code>因此，如果将响应容器的状态设置为错误状态（即4xx，5xx），则Servlet容器可以使用HTML呈现默认错误页面。要自定义容器的默认错误页面，可以在以下位置声明错误页面映射<code>web.xml</code> 。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;error-page&gt;
    &lt;location&gt;/error&lt;/location&gt;
&lt;/error-page&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定前面的示例，当异常冒出气泡或响应具有错误状态时，Servlet容器在容器内向配置的URL进行ERROR调度（例如， <code>/error</code> ）。然后由<code>DispatcherServlet</code> ，可能将其映射到<code>@Controller</code> ，可以将其实现为返回带有模型的错误视图名称或呈现JSON响应，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class ErrorController {

    @RequestMapping(path = "/error")
    public Map&lt;String, Object&gt; handle(HttpServletRequest request) {
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put("status", request.getAttribute("javax.servlet.error.status_code"));
        map.put("reason", request.getAttribute("javax.servlet.error.message"));
        return map;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class ErrorController {

    @RequestMapping(path = ["/error"])
    fun handle(request: HttpServletRequest): Map&lt;String, Any&gt; {
        val map = HashMap&lt;String, Any&gt;()
        map["status"] = request.getAttribute("javax.servlet.error.status_code")
        map["reason"] = request.getAttribute("javax.servlet.error.message")
        return map
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Servlet API没有提供在Java中创建错误页面映射的方法。但是，您可以同时使用<code>WebApplicationInitializer</code>和最小的<code>web.xml</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-viewresolver"><a class="anchor" href="#mvc-viewresolver"></a> 1.1.8。查看分辨率</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-viewresolution">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC定义了<code>ViewResolver</code>和<code>View</code>介面，可让您在浏览器中呈现模型，而无需将您与特定的视图技术联系在一起。<code>ViewResolver</code>提供视图名称和实际视图之间的映射。 <code>View</code>在移交给特定的视图技术之前，先解决数据准备问题。</p>
</div>
<div class="paragraph">
<p>下表提供了有关<code>ViewResolver</code>层次结构：</p>
</div>
<table id="mvc-view-resolvers-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表3。ViewResolver实现</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ViewResolver</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractCachingViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的子类<code>AbstractCachingViewResolver</code>缓存他们解析的视图实例。缓存可以提高某些视图技术的性能。您可以通过设置<code>cache</code>财产<code>false</code> 。此外，如果您必须在运行时刷新某个视图（例如，修改FreeMarker模板时），则可以使用<code>removeFromCache(String viewName, Locale loc)</code>方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>XmlViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实施<code>ViewResolver</code>接受用XML编写的配置文件，该配置文件具有与Spring的XML bean工厂相同的DTD。默认配置文件是<code>/WEB-INF/views.xml</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceBundleViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实施<code>ViewResolver</code>在一个<code>ResourceBundle</code> ，由包的基本名称指定。对于应该解析的每个视图，它使用属性的值<code>[viewname].(class)</code>作为视图类和属性的值<code>[viewname].url</code>作为视图网址。您可以在<a href="#mvc-view">View Technologies</a>一章中找到示例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UrlBasedViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">简单的实现<code>ViewResolver</code>在没有显式映射定义的情况下会影响将逻辑视图名称直接解析为URL的接口。如果您的逻辑名称以直接的方式与视图资源的名称匹配，而不需要任意映射，则这是适当的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InternalResourceViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方便的子类<code>UrlBasedViewResolver</code>支持<code>InternalResourceView</code> （实际上是Servlet和JSP）和子类，例如<code>JstlView</code>和<code>TilesView</code> 。您可以使用来为此解析器生成的所有视图指定视图类。 <code>setViewClass(..)</code> 。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/UrlBasedViewResolver.html"><code>UrlBasedViewResolver</code></a>有关详细信息，请参见javadoc。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FreeMarkerViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的方便子类<code>UrlBasedViewResolver</code>支持<code>FreeMarkerView</code>以及它们的自定义子类。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContentNegotiatingViewResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实施<code>ViewResolver</code>接口，用于根据请求文件名解析视图或<code>Accept</code>标头。请参阅<a href="#mvc-multiple-representations">内容协商</a> 。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="mvc-viewresolver-handling"><a class="anchor" href="#mvc-viewresolver-handling"></a>处理方式</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-viewresolution-handling">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过声明多个解析器bean来链接视图解析器，并在必要时通过设置<code>order</code>属性以指定顺序。请记住，order属性越高，视图解析器在链中的定位就越晚。</p>
</div>
<div class="paragraph">
<p>一个合同<code>ViewResolver</code>指定它可以返回null以指示找不到该视图。但是，对于JSP和<code>InternalResourceViewResolver</code> ，找出JSP是否存在的唯一方法是通过<code>RequestDispatcher</code> 。因此，您必须始终配置<code>InternalResourceViewResolver</code>在视图解析器的总体顺序中排在最后。</p>
</div>
<div class="paragraph">
<p>配置视图分辨率就像添加一样简单<code>ViewResolver</code> bean到您的Spring配置。<a href="#mvc-config">MVC Config</a>为<a href="#mvc-config-view-resolvers">View解析器</a>和添加无逻辑的<a href="#mvc-config-view-controller">View Controller</a>提供了专用的配置API，这对于无需控制器逻辑的HTML模板呈现非常有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-redirecting-redirect-prefix"><a class="anchor" href="#mvc-redirecting-redirect-prefix"></a>重新导向</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-redirecting-redirect-prefix">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>特别的<code>redirect:</code>视图名称中的前缀可让您执行重定向。的<code>UrlBasedViewResolver</code> （及其子类）将其识别为需要重定向的指令。视图名称的其余部分是重定向URL。</p>
</div>
<div class="paragraph">
<p>最终效果与控制器已返回<code>RedirectView</code> ，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图名称（例如<code>redirect:/myapp/some/resource</code> ）相对于当前Servlet上下文的重定向，而名称例如<code>redirect:https://myhost.com/some/arbitrary/path</code>重定向到绝对URL。</p>
</div>
<div class="paragraph">
<p>请注意，如果控制器方法用<code>@ResponseStatus</code> ，注释值优先于由设置的响应状态<code>RedirectView</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-redirecting-forward-prefix"><a class="anchor" href="#mvc-redirecting-forward-prefix"></a>转寄</h5>
<div class="paragraph">
<p>您也可以使用特殊的<code>forward:</code>最终由解析的视图名称的前缀<code>UrlBasedViewResolver</code>和子类。这创建了一个<code>InternalResourceView</code> ，这会<code>RequestDispatcher.forward()</code> 。因此，此前缀对于<code>InternalResourceViewResolver</code>和<code>InternalResourceView</code> （对于JSP），但是如果您使用另一种视图技术但仍然希望强制转发由Servlet / JSP引擎处理的资源，则可能会有所帮助。请注意，您也可以链接多个视图解析器。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-multiple-representations"><a class="anchor" href="#mvc-multiple-representations"></a>内容协商</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-multiple-representations">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html"><code>ContentNegotiatingViewResolver</code></a>不会解析视图本身，而是委托其他视图解析器，并选择类似于客户端请求的表示形式的视图。可以从<code>Accept</code>标头或来自查询参数（例如， <code>"/path?format=pdf"</code> ）。</p>
</div>
<div class="paragraph">
<p>的<code>ContentNegotiatingViewResolver</code>选择合适的<code>View</code>通过将请求媒体类型与媒体类型（也称为媒体类型）进行比较来处理请求<code>Content-Type</code> ）由<code>View</code>与其每个相关联<code>ViewResolvers</code> 。首先<code>View</code>在具有兼容的列表中<code>Content-Type</code>将表示形式返回给客户端。如果兼容视图无法由<code>ViewResolver</code>链，通过<code>DefaultViews</code>咨询财产。后一个选项适用于单身人士<code>Views</code>无论逻辑视图名称如何，都可以呈现当前资源的适当表示形式。的<code>Accept</code>标头可以包含通配符（例如<code>text/*</code> ），在这种情况下<code>View</code>谁的<code>Content-Type</code>是<code>text/xml</code>是兼容的匹配。</p>
</div>
<div class="paragraph">
<p>有关配置详细信息，请参见<a href="#mvc-config">MVC Config</a>下的<a href="#mvc-config-view-resolvers">查看解析器</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-localeresolver"><a class="anchor" href="#mvc-localeresolver"></a> 1.1.9。语言环境</h4>
<div class="paragraph">
<p>正如Spring Web MVC框架所做的那样，Spring体系结构的大多数部分都支持国际化。 <code>DispatcherServlet</code>使您可以使用客户端的语言环境自动解析消息。这是用<code>LocaleResolver</code>对象。</p>
</div>
<div class="paragraph">
<p>收到请求后， <code>DispatcherServlet</code>查找语言环境解析器，如果找到它，则尝试使用它来设置语言环境。通过使用<code>RequestContext.getLocale()</code>方法，您始终可以检索由语言环境解析器解析的语言环境。</p>
</div>
<div class="paragraph">
<p>除了自动的语言环境解析之外，您还可以在处理程序映射上附加一个拦截器（有关处理程序映射拦截<a href="#mvc-handlermapping-interceptor">器</a>的更多信息，请参见<a href="#mvc-handlermapping-interceptor">侦听</a> ），以在特定情况下（例如，基于请求中的参数）更改语言环境。</p>
</div>
<div class="paragraph">
<p>语言环境解析器和拦截器在<code>org.springframework.web.servlet.i18n</code>打包并以常规方式在您的应用程序上下文中配置。Spring包含以下选择的语言环境解析器。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-timezone">时区</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-acceptheader">标头解析器</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-cookie">Cookie解析器</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-session">会话解析器</a></p>
</li>
<li>
<p><a href="#mvc-localeresolver-interceptor">区域拦截器</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="mvc-timezone"><a class="anchor" href="#mvc-timezone"></a>时区</h5>
<div class="paragraph">
<p>除了获取客户端的语言环境之外，了解其时区通常也很有用。的<code>LocaleContextResolver</code>介面提供了对<code>LocaleResolver</code>让解析器提供更丰富的<code>LocaleContext</code> ，其中可能包含时区信息。</p>
</div>
<div class="paragraph">
<p>如果可用，用户的<code>TimeZone</code>可以通过使用<code>RequestContext.getTimeZone()</code>方法。任何日期/时间都会自动使用时区信息<code>Converter</code>和<code>Formatter</code>在Spring的注册对象<code>ConversionService</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-acceptheader"><a class="anchor" href="#mvc-localeresolver-acceptheader"></a>标头解析器</h5>
<div class="paragraph">
<p>此语言环境解析器检查<code>accept-language</code>客户端（例如，Web浏览器）发送的请求中的标头。通常，此头字段包含客户端操作系统的语言环境。请注意，此解析器不支持时区信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-cookie"><a class="anchor" href="#mvc-localeresolver-cookie"></a> Cookie解析器</h5>
<div class="paragraph">
<p>该语言环境解析器检查<code>Cookie</code>可能存在于客户端上以查看是否<code>Locale</code>要么<code>TimeZone</code>已指定。如果是这样，它将使用指定的详细信息。通过使用此语言环境解析器的属性，可以指定Cookie的名称以及最长期限。以下示例定义了<code>CookieLocaleResolver</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;

    &lt;property name="cookieName" value="clientlanguage"/&gt;

    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
    &lt;property name="cookieMaxAge" value="100000"/&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了属性<code>CookieLocaleResolver</code> ：</p>
</div>
<table id="mvc-cookie-locale-resolver-props-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表4。CookieLocaleResolver属性</caption>
<colgroup>
<col style="width:16.6666%">
<col style="width:16.6666%">
<col style="width:66.6668%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookieName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类名+ LOCALE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cookie的名称</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookieMaxAge</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet容器默认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cookie在客户端上保留的最长时间。如果<code>-1</code>指定后，cookie将不会保留。它仅在客户端关闭浏览器之前可用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cookiePath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Cookie的可见性限制为网站的特定部分。什么时候<code>cookiePath</code>如果指定，则cookie仅对该路径及其下方的路径可见。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-session"><a class="anchor" href="#mvc-localeresolver-session"></a>会话解析器</h5>
<div class="paragraph">
<p>的<code>SessionLocaleResolver</code>让您找回<code>Locale</code>和<code>TimeZone</code>从可能与用户请求相关联的会话中。与之相反<code>CookieLocaleResolver</code> ，此策略会将本地选择的语言环境设置存储在Servlet容器的<code>HttpSession</code> 。结果，这些设置对于每个会话都是临时的，因此在每个会话终止时会丢失。</p>
</div>
<div class="paragraph">
<p>请注意，与外部会话管理机制（例如Spring Session项目）没有直接关系。这个<code>SessionLocaleResolver</code>评估并修改相应的<code>HttpSession</code>针对当前的属性<code>HttpServletRequest</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-localeresolver-interceptor"><a class="anchor" href="#mvc-localeresolver-interceptor"></a>区域拦截器</h5>
<div class="paragraph">
<p>您可以通过添加以下内容来启用语言环境更改： <code>LocaleChangeInterceptor</code>到其中之一<code>HandlerMapping</code>定义。它检测到请求中的参数并相应地更改语言环境，从而调用<code>setLocale</code>上的方法<code>LocaleResolver</code>在调度程序的应用程序上下文中。下一个示例显示了对所有<code>*.view</code>包含名为的参数的资源<code>siteLanguage</code>现在更改语言环境。因此，例如，对URL的请求， <code><a href="https://www.sf.net/home.view?siteLanguage=nl" class="bare">https://www.sf.net/home.view?siteLanguage=nl</a></code> ，将网站语言更改为荷兰语。以下示例显示如何拦截语言环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="localeChangeInterceptor"
        class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName" value="siteLanguage"/&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
        class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;value&gt;/**/*.view=someController&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-themeresolver"><a class="anchor" href="#mvc-themeresolver"></a> 1.1.10。主题</h4>
<div class="paragraph">
<p>您可以应用Spring Web MVC框架主题来设置应用程序的整体外观，从而增强用户体验。主题是静态资源的集合，通常影响样式表和图像，这些样式表和图像会影响应用程序的视觉样式。</p>
</div>
<div class="sect4">
<h5 id="mvc-themeresolver-defining"><a class="anchor" href="#mvc-themeresolver-defining"></a>定义主题</h5>
<div class="paragraph">
<p>要在您的Web应用程序中使用主题，您必须设置<code>org.springframework.ui.context.ThemeSource</code>接口。的<code>WebApplicationContext</code>接口扩展<code>ThemeSource</code>但将其职责委托给专门的实施。默认情况下，委托是<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>从类路径的根加载属性文件的实现。使用自定义<code>ThemeSource</code>实现或配置的基本名称前缀<code>ResourceBundleThemeSource</code> ，您可以使用保留名称在应用程序上下文中注册Bean， <code>themeSource</code> 。Web应用程序上下文会自动检测到具有该名称的bean并使用它。</p>
</div>
<div class="paragraph">
<p>当您使用<code>ResourceBundleThemeSource</code> ，主题是在简单的属性文件中定义的。属性文件列出了组成主题的资源，如以下示例所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg</pre>
</div>
</div>
<div class="paragraph">
<p>属性的键是从视图代码引用主题元素的名称。对于JSP，通常使用<code>spring:theme</code>自定义标签，与<code>spring:message</code>标签。以下JSP片段使用上一个示例中定义的主题来自定义外观：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;
    &lt;/head&gt;
    &lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;
        ...
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>ResourceBundleThemeSource</code>使用空的基本名称前缀。结果，从类路径的根加载属性文件。因此，您将<code>cool.properties</code>主题定义位于类路径的根目录下（例如，在<code>/WEB-INF/classes</code> ）。的<code>ResourceBundleThemeSource</code>使用标准的Java资源束加载机制，允许主题的完全国际化。例如，我们可以有一个<code>/WEB-INF/classes/cool_nl.properties</code>引用带有荷兰文字的特殊背景图片。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-themeresolver-resolving"><a class="anchor" href="#mvc-themeresolver-resolving"></a>解决主题</h5>
<div class="paragraph">
<p>定义主题后，如上<a href="#mvc-themeresolver-defining">一节所述</a> ，您可以决定使用哪个主题。的<code>DispatcherServlet</code>寻找一个名为<code>themeResolver</code>找出哪个<code>ThemeResolver</code>实施使用。主题解析器的工作方式与<code>LocaleResolver</code> 。它可以检测用于特定请求的主题，还可以更改请求的主题。下表描述了Spring提供的主题解析器：</p>
</div>
<table id="mvc-theme-resolver-impls-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表5。ThemeResolver实现</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FixedThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择一个固定的主题，通过使用<code>defaultThemeName</code>属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主题在用户的HTTP会话中维护。每个会话只需设置一次，但在会话之间不会保留。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CookieThemeResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所选主题存储在客户端的cookie中。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring还提供了<code>ThemeChangeInterceptor</code>通过简单的request参数，可以在每个请求上更改主题。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-multipart"><a class="anchor" href="#mvc-multipart"></a> 1.1.11。多部分解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-multipart">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>MultipartResolver</code>来自<code>org.springframework.web.multipart</code>包是一种用于分析包括文件上传在内的多部分请求的策略。有一种基于<a href="https://jakarta.apache.org/commons/fileupload">Commons FileUpload的实现</a> ，另一种基于Servlet 3.0多部分请求解析。</p>
</div>
<div class="paragraph">
<p>要启用多部分处理，您需要声明一个<code>MultipartResolver</code>豆在你<code>DispatcherServlet</code> Spring配置，名称为<code>multipartResolver</code> 。的<code>DispatcherServlet</code>检测到它并将其应用于传入的请求。当POST的内容类型为<code>multipart/form-data</code>收到解析器解析内容并包装当前内容<code>HttpServletRequest</code>如<code>MultipartHttpServletRequest</code>除了将其作为请求参数公开之外，还提供对已分解零件的访问。</p>
</div>
<div class="sect4">
<h5 id="mvc-multipart-resolver-commons"><a class="anchor" href="#mvc-multipart-resolver-commons"></a> Apache Commons<code>FileUpload</code></h5>
<div class="paragraph">
<p>使用Apache Commons <code>FileUpload</code> ，您可以配置类型的Bean <code>CommonsMultipartResolver</code>名称为<code>multipartResolver</code> 。您还需要<code>commons-fileupload</code>作为对您的类路径的依赖。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-multipart-resolver-standard"><a class="anchor" href="#mvc-multipart-resolver-standard"></a> Servlet 3.0</h5>
<div class="paragraph">
<p>需要通过Servlet容器配置启用Servlet 3.0多部分解析。为此：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在Java中，设置一个<code>MultipartConfigElement</code>在Servlet上注册。</p>
</li>
<li>
<p>在<code>web.xml</code> ，添加一个<code>"<multipart-config>"</code> servlet声明部分。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了如何设置<code>MultipartConfigElement</code>在Servlet上注册：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    // ...

    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {

        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
        registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class AppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

    // ...

    override fun customizeRegistration(registration: ServletRegistration.Dynamic) {

        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
        registration.setMultipartConfig(MultipartConfigElement("/tmp"))
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Servlet 3.0配置到位后，您可以添加Bean类型的<code>StandardServletMultipartResolver</code>名称为<code>multipartResolver</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-logging"><a class="anchor" href="#mvc-logging"></a> 1.1.12。记录中</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-logging">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC中的DEBUG级别的日志被设计为紧凑，最少且人性化的。它侧重于一遍又一遍有用的高价值信息，而其他信息仅在调试特定问题时才有用。</p>
</div>
<div class="paragraph">
<p>TRACE级别的日志记录通常遵循与DEBUG相同的原理（例如，也不应是消防水带），但可用于调试任何问题。此外，某些日志消息在TRACE和DEBUG上可能显示不同级别的详细信息。</p>
</div>
<div class="paragraph">
<p>良好的日志记录来自使用日志的经验。如果您发现任何不符合既定目标的东西，请告诉我们。</p>
</div>
<div class="sect4">
<h5 id="mvc-logging-sensitive-data"><a class="anchor" href="#mvc-logging-sensitive-data"></a>敏感数据</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-logging-sensitive-data">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>调试和跟踪日志记录可能会记录敏感信息。这就是默认情况下屏蔽请求参数和标头，并且必须通过<code>enableLoggingRequestDetails</code>财产<code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何通过使用Java配置来执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyInitializer
        extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return ... ;
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return ... ;
    }

    @Override
    protected String[] getServletMappings() {
        return ... ;
    }

    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {
        registration.setInitParameter("enableLoggingRequestDetails", "true");
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

    override fun getRootConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
        return ...
    }

    override fun getServletConfigClasses(): Array&lt;Class&lt;*&gt;&gt;? {
        return ...
    }

    override fun getServletMappings(): Array&lt;String&gt; {
        return ...
    }

    override fun customizeRegistration(registration: ServletRegistration.Dynamic) {
        registration.setInitParameter("enableLoggingRequestDetails", "true")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="filters"><a class="anchor" href="#filters"></a> 1.2。筛选器</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-filters">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>spring-web</code>模块提供了一些有用的过滤器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#filters-http-put">表格数据</a></p>
</li>
<li>
<p><a href="#filters-forwarded-headers">转发的标题</a></p>
</li>
<li>
<p><a href="#filters-shallow-etag">浅ETag</a></p>
</li>
<li>
<p><a href="#filters-cors">CORS</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="filters-http-put"><a class="anchor" href="#filters-http-put"></a> 1.2.1。表格数据</h4>
<div class="paragraph">
<p>浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户端也可以使用HTTP PUT，PATCH和DELETE。 Servlet API要求<code>ServletRequest.getParameter*()</code>仅支持HTTP POST支持表单字段访问的方法。</p>
</div>
<div class="paragraph">
<p>的<code>spring-web</code>模块提供<code>FormContentFilter</code>截取内容类型为HTTP的HTTP PUT，PATCH和DELETE请求<code>application/x-www-form-urlencoded</code> ，从请求的正文中读取表单数据，然后包装<code>ServletRequest</code>使表单数据可通过<code>ServletRequest.getParameter*()</code>方法族。</p>
</div>
</div>
<div class="sect3">
<h4 id="filters-forwarded-headers"><a class="anchor" href="#filters-forwarded-headers"></a> 1.2.2。转发的标题</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-forwarded-headers">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>当请求通过代理（例如负载平衡器）进行处理时，主机，端口和方案可能会更改，因此从客户端的角度来看，创建指向正确的主机，端口和方案的链接将是一个挑战。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了<code>Forwarded</code>代理可以用来提供有关原始请求的信息的HTTP标头。还有其他非标准标头，包括<code>X-Forwarded-Host</code> ， <code>X-Forwarded-Port</code> ， <code>X-Forwarded-Proto</code> ， <code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code> 。</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderFilter</code>是一个Servlet过滤器，它基于以下内容修改请求的主机，端口和方案： <code>Forwarded</code>标头，然后删除那些标头。</p>
</div>
<div class="paragraph">
<p>对于转发的标头，出于安全方面的考虑，因为应用程序无法知道标头是由代理添加的，还是由恶意客户端添加的。这就是为什么应该配置信任边界上的代理以删除不信任的原因<code>Forwarded</code>来自外部的标头。您还可以配置<code>ForwardedHeaderFilter</code>与<code>removeOnly=true</code> ，在这种情况下，它将删除但不使用标题。</p>
</div>
</div>
<div class="sect3">
<h4 id="filters-shallow-etag"><a class="anchor" href="#filters-shallow-etag"></a> 1.2.3。浅ETag</h4>
<div class="paragraph">
<p>的<code>ShallowEtagHeaderFilter</code>筛选器通过缓存写入响应的内容并从中计算MD5哈希值来创建“浅” ETag。客户端下一次发送时，会执行相同的操作，但还会将计算出的值与<code>If-None-Match</code>请求标头，如果两者相等，则返回304（NOT_MODIFIED）。</p>
</div>
<div class="paragraph">
<p>此策略可节省网络带宽，但不会节省CPU，因为必须为每个请求计算完整响应。如前所述，控制器级别的其他策略可以避免计算。请参阅<a href="#mvc-caching">HTTP缓存</a> 。</p>
</div>
<div class="paragraph">
<p>此过滤器有一个<code>writeWeakETag</code>配置过滤器以写入弱ETag的参数，类似于以下内容： <code>W/"02a2d595e6ed9a0b24f027f2b63b134d6"</code> （如<a href="https://tools.ietf.org/html/rfc7232#section-2.3">RFC 7232第2.3节中</a>所定义）。</p>
</div>
</div>
<div class="sect3">
<h4 id="filters-cors"><a class="anchor" href="#filters-cors"></a> 1.2.4。CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-filters-cors">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC通过控制器上的注释为CORS配置提供了细粒度的支持。但是，当与Spring Security一起使用时，我们建议您依赖内置<code>CorsFilter</code>必须在Spring Security的过滤器链之前订购。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见有关<a href="#mvc-cors">CORS</a>和<a href="#mvc-cors-filter">CORS过滤器</a>的部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-controller"><a class="anchor" href="#mvc-controller"></a> 1.3。带注释的控制器</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-controller">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC提供了一个基于注释的编程模型，其中<code>@Controller</code>和<code>@RestController</code>组件使用注释来表达请求映射，请求输入，异常处理等。带注释的控制器具有灵活的方法签名，无需扩展基类或实现特定的接口。以下示例显示了由注释定义的控制器：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class HelloController {

    @GetMapping("/hello")
    public String handle(Model model) {
        model.addAttribute("message", "Hello World!");
        return "index";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.ui.set

@Controller
class HelloController {

    @GetMapping("/hello")
    fun handle(model: Model): String {
        model["message"] = "Hello World!"
        return "index"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，该方法接受<code>Model</code>并返回视图名称作为<code>String</code> ，但是还存在许多其他选项，本章稍后将对其进行说明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content"><a href="https://spring.io/guides">spring.io</a>上的指南和教程使用本节中描述的基于注释的编程模型。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="mvc-ann-controller"><a class="anchor" href="#mvc-ann-controller"></a> 1.3.1。宣言</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-controller">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用Servlet的标准Spring bean定义来定义控制器bean。 <code>WebApplicationContext</code> 。的<code>@Controller</code>原型允许自动检测，与Spring常规检测支持一致<code>@Component</code>类路径中的类，并为其自动注册Bean定义。它还充当带注释类的构造型，表明其作为Web组件的作用。</p>
</div>
<div class="paragraph">
<p>启用此类自动检测<code>@Controller</code> Bean，您可以将组件扫描添加到Java配置中，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan("org.example.web")
public class WebConfig {

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@ComponentScan("org.example.web")
class WebConfig {

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="org.example.web"/&gt;

    &lt;!-- ... --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@RestController</code>是一个<a href="core.html#beans-meta-annotations">组合注释</a> ，其本身使用元注释<code>@Controller</code>和<code>@ResponseBody</code>指示其每个方法都继承类型级别的控制器<code>@ResponseBody</code>注释，因此直接将其写入响应主体，而不是视图分辨率和使用HTML模板进行渲染。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-proxying"><a class="anchor" href="#mvc-ann-requestmapping-proxying"></a> AOP代理</h5>
<div class="paragraph">
<p>在某些情况下，您可能需要在运行时用AOP代理装饰控制器。一个例子是，如果您选择拥有<code>@Transactional</code>注释直接在控制器上。在这种情况下，特别是对于控制器，我们建议使用基于类的代理。这通常是控制器的默认选择。但是，如果控制器必须实现不是Spring Context回调的接口（例如<code>InitializingBean</code> ， <code>*Aware</code> ，以及其他），您可能需要显式配置基于类的代理。例如， <code><tx:annotation-driven/></code>您可以更改为<code><tx:annotation-driven proxy-target-class="true"/></code> ， 与<code>@EnableTransactionManagement</code>您可以更改为<code>@EnableTransactionManagement(proxyTargetClass = true)</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-requestmapping"><a class="anchor" href="#mvc-ann-requestmapping"></a> 1.3.2。请求映射</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestMapping</code>批注将请求映射到控制器方法。它具有各种属性，可以通过URL，HTTP方法，请求参数，标头和媒体类型进行匹配。您可以在类级别使用它来表示共享的映射，也可以在方法级别使用它来缩小到特定的端点映射。</p>
</div>
<div class="paragraph">
<p>也有HTTP方法特定的快捷方式变体<code>@RequestMapping</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>快捷方式是提供的“ <a href="#mvc-ann-requestmapping-composed">自定义注释”</a> ，因为可以说，大多数控制器方法应映射到特定的HTTP方法，而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。同时， <code>@RequestMapping</code>在类级别仍需要表达共享映射。</p>
</div>
<div class="paragraph">
<p>以下示例具有类型和方法级别的映射：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    fun getPerson(@PathVariable id: Long): Person {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    fun add(@RequestBody person: Person) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-uri-templates"><a class="anchor" href="#mvc-ann-requestmapping-uri-templates"></a> URI模式</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-uri-templates">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用以下全局模式和通配符来映射请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code>匹配一个字符</p>
</li>
<li>
<p><code>*</code>匹配路径段中的零个或多个字符</p>
</li>
<li>
<p><code>**</code>匹配零个或多个路径段</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以声明URI变量并使用以下命令访问它们的值<code>@PathVariable</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在类和方法级别声明URI变量，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/owners/{ownerId}")
public class OwnerController {

    @GetMapping("/pets/{petId}")
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@RequestMapping("/owners/{ownerId}")
class OwnerController {

    @GetMapping("/pets/{petId}")
    fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI变量会自动转换为适当的类型，或者<code>TypeMismatchException</code>被提出。简单类型（ <code>int</code> ， <code>long</code> ， <code>Date</code> ，等等）默认情况下受支持，您可以注册对任何其他数据类型的支持。请参阅<a href="#mvc-ann-typeconversion">类型转换</a>和<a href="#mvc-ann-initbinder"><code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>您可以明确命名URI变量（例如， <code>@PathVariable("customId")</code> ），但如果名称相同且您的代码是使用调试信息或使用<code>-parameters</code> Java 8上的编译器标志。</p>
</div>
<div class="paragraph">
<p>语法<code>{varName:regex}</code>使用正则表达式声明URI变量，其语法为<code>{varName:regex}</code> 。例如，给定的URL <code>"/spring-web-3.0.5 .jar"</code> ，以下方法提取名称，版本和文件扩展名：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
fun handle(@PathVariable version: String, @PathVariable ext: String) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI路径模式也可以嵌入<code>${…​}</code>在启动时使用解析的占位符<code>PropertyPlaceHolderConfigurer</code>针对本地，系统，环境和其他财产来源。例如，您可以使用它来基于某些外部配置参数化基本URL。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring MVC使用<code>PathMatcher</code>合同与<code>AntPathMatcher</code>从实施<code>spring-core</code>用于URI路径匹配。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-pattern-comparison"><a class="anchor" href="#mvc-ann-requestmapping-pattern-comparison"></a>模式比较</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-pattern-comparison">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>当多个模式与URL匹配时，必须将它们进行比较以找到最佳匹配。这是通过使用<code>AntPathMatcher.getPatternComparator(String path)</code> ，查找更具体的模式。</p>
</div>
<div class="paragraph">
<p>如果模式的URI变量（计数为1），单通配符（计数为1）和双通配符（计数为2）的数量较少，则模式的含义不太明确。给定相等的分数，则选择更长的模式。给定相同的分数和长度，将选择URI变量多于通配符的模式。</p>
</div>
<div class="paragraph">
<p>默认的映射模式（ <code>/**</code> ）从得分中排除，始终排在最后。另外，前缀模式（例如<code>/public/**</code> ）被认为比没有双通配符的其他模式不太具体。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html"><code>AntPatternComparator</code></a>在<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html"><code>AntPathMatcher</code></a>并且请记住，您可以自定义<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html"><code>PathMatcher</code></a>实施。请参阅配置部分中的<a href="#mvc-config-path-matching">路径匹配</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-suffix-pattern-match"><a class="anchor" href="#mvc-ann-requestmapping-suffix-pattern-match"></a>后缀匹配</h5>
<div class="paragraph">
<p>默认情况下，Spring MVC执行<code>.*</code>后缀模式匹配，以便将控制器映射到<code>/person</code>也隐式映射到<code>/person.*</code> 。然后，文件扩展名用于解释请求的内容类型以用于响应（即， <code>Accept</code>标头）-例如， <code>/person.pdf</code> ， <code>/person.xml</code> ， 和别的。</p>
</div>
<div class="paragraph">
<p>当浏览器过去用于发送文件时，必须以这种方式使用文件扩展名<code>Accept</code>难以一致解释的标题。目前，这已不再是必须的，使用<code>Accept</code>标头应该是首选。</p>
</div>
<div class="paragraph">
<p>随着时间的流逝，文件扩展名的使用已经以各种方式证明是有问题的。当使用URI变量，路径参数和URI编码进行覆盖时，可能会引起歧义。关于基于URL的授权和安全性的推理（请参阅下一部分以了解更多详细信息）也变得更加困难。</p>
</div>
<div class="paragraph">
<p>若要完全禁用文件扩展名，必须设置以下两项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>useSuffixPatternMatching(false)</code> ，请参阅<a href="#mvc-config-path-matching">PathMatchConfigurer</a></p>
</li>
<li>
<p><code>favorPathExtension(false)</code> ，请参阅<a href="#mvc-config-content-negotiation">ContentNegotiationConfigurer</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>基于URL的内容协商仍然有用（例如，在浏览器中键入URL时）。为此，我们建议使用基于查询参数的策略，以避免文件扩展名附带的大多数问题。另外，如果您必须使用文件扩展名，请考虑通过扩展名将它们限制为显式注册的扩展名列表。 <code>mediaTypes</code> <a href="#mvc-config-content-negotiation">ContentNegotiationConfigurer的</a>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-rfd"><a class="anchor" href="#mvc-ann-requestmapping-rfd"></a>后缀匹配和RFD</h5>
<div class="paragraph">
<p>反射文件下载（RFD）攻击与XSS相似，它依赖于响应中反映的请求输入（例如，查询参数和URI变量）。但是，RFD攻击不是将JavaScript插入HTML，而是依靠浏览器切换来执行下载，并在以后双击时将响应视为可执行脚本。</p>
</div>
<div class="paragraph">
<p>在Spring MVC中， <code>@ResponseBody</code>和<code>ResponseEntity</code>方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展请求这些内容类型。禁用后缀模式匹配并使用路径扩展进行内容协商可以降低风险，但不足以防止RFD攻击。</p>
</div>
<div class="paragraph">
<p>为了防止RFD攻击，Spring MVC在呈现响应主体之前添加了一个<code>Content-Disposition:inline;filename=f.txt</code>标头，建议一个固定且安全的下载文件。仅当URL路径包含既未列入白名单也未明确注册用于内容协商的文件扩展名时，才执行此操作。但是，当直接在浏览器中键入URL时，它可能会产生副作用。</p>
</div>
<div class="paragraph">
<p>默认情况下，许多常见的路径扩展名都被列入白名单。定制应用<code>HttpMessageConverter</code>实现可以显式注册文件扩展名以进行内容协商，以避免出现<code>Content-Disposition</code>为这些扩展名添加了标头。请参阅<a href="#mvc-config-content-negotiation">内容类型</a> 。</p>
</div>
<div class="paragraph">
<p>有关RFD的其他建议，请参见<a href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-consumes"><a class="anchor" href="#mvc-ann-requestmapping-consumes"></a>消耗媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-consumes">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据<code>Content-Type</code>如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping(path = "/pets", consumes = "application/json") <i class="conum" data-value="1"></i><b>(1)</b>
public void addPet(@RequestBody Pet pet) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>consumes</code>属性以按内容类型缩小映射。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/pets", consumes = ["application/json"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun addPet(@RequestBody pet: Pet) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>consumes</code>属性以按内容类型缩小映射。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>consumes</code>属性还支持否定表达式-例如， <code>!text/plain</code>表示除以下内容以外的任何内容类型<code>text/plain</code> 。</p>
</div>
<div class="paragraph">
<p>您可以声明共享<code>consumes</code>类级别的属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>consumes</code>属性覆盖而不是扩展类级别的声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>提供常用媒体类型的常量，例如<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-produces"><a class="anchor" href="#mvc-ann-requestmapping-produces"></a>可生产的媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-produces">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", produces = "application/json") <i class="conum" data-value="1"></i><b>(1)</b>
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>produces</code>属性以按内容类型缩小映射。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/pets/{petId}", produces = ["application/json"]) <i class="conum" data-value="1"></i><b>(1)</b>
@ResponseBody
fun getPet(@PathVariable petId: String): Pet {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>produces</code>属性以按内容类型缩小映射。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>媒体类型可以指定字符集。支持否定表达式-例如， <code>!text/plain</code>表示除“文本/纯文本”以外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>您可以声明共享<code>produces</code>类级别的属性。但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别<code>produces</code>属性覆盖而不是扩展类级别的声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>MediaType</code>提供常用媒体类型的常量，例如<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-params-and-headers"><a class="anchor" href="#mvc-ann-requestmapping-params-and-headers"></a>参数，标题</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-params-and-headers">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以根据请求参数条件来缩小请求映射。您可以测试是否存在请求参数（ <code>myParam</code> ），如果没有一个（ <code>!myParam</code> ）或特定值（ <code>myParam=myValue</code> ）。以下示例显示如何测试特定值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>测试是否<code>myParam</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun findPet(@PathVariable petId: String) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>测试是否<code>myParam</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以将其与请求标头条件一起使用，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets", headers = "myHeader=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>测试是否<code>myHeader</code>等于<code>myValue</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/pets", headers = ["myHeader=myValue"]) <i class="conum" data-value="1"></i><b>(1)</b>
fun findPet(@PathVariable petId: String) {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">你可以搭配<code>Content-Type</code>和<code>Accept</code>与标头条件一起使用，但最好使用<a href="#mvc-ann-requestmapping-consumes">消耗</a>和<a href="#mvc-ann-requestmapping-produces">产生</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-head-options"><a class="anchor" href="#mvc-ann-requestmapping-head-options"></a> HTTP HEAD，选项</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-head-options">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> （和<code>@RequestMapping(method=HttpMethod.GET)</code> ）透明地支持HTTP HEAD以进行请求映射。控制器方法不需要更改。响应包装，应用于<code>javax.servlet.http.HttpServlet</code> ，确保<code>Content-Length</code>标头设置为写入的字节数（实际上未写入响应）。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> （和<code>@RequestMapping(method=HttpMethod.GET)</code> ）隐式映射到并支持HTTP HEAD。像处理HTTP GET一样处理HTTP HEAD请求，不同的是，不是写入正文，而是对字节数进行计数，并且<code>Content-Length</code>标头已设置。</p>
</div>
<div class="paragraph">
<p>默认情况下，HTTP OPTIONS通过设置<code>Allow</code>对所有列出的HTTP方法列表的响应标头<code>@RequestMapping</code>具有匹配网址格式的方法。</p>
</div>
<div class="paragraph">
<p>为一个<code>@RequestMapping</code>如果没有HTTP方法声明， <code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code> 。控制器方法应始终声明支持的HTTP方法（例如，通过使用HTTP方法特定的变体： <code>@GetMapping</code> ， <code>@PostMapping</code> ， 和别的）。</p>
</div>
<div class="paragraph">
<p>您可以显式映射<code>@RequestMapping</code> HTTP HEAD和HTTP OPTIONS的方法，但在通常情况下不必要。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-composed"><a class="anchor" href="#mvc-ann-requestmapping-composed"></a>自定义注释</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#mvc-ann-requestmapping-head-options">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC支持将<a href="core.html#beans-meta-annotations">组合注释</a>用于请求映射。这些是本身带有元注释的注释<code>@RequestMapping</code>并组成为重新声明以下内容的子集（或全部） <code>@RequestMapping</code>具有更窄，更具体目的的属性。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> ， <code>@PostMapping</code> ， <code>@PutMapping</code> ， <code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。之所以提供它们，是因为大多数控制器方法应该映射为特定的HTTP方法，而不是使用<code>@RequestMapping</code> ，默认情况下，它与所有HTTP方法匹配。如果需要组合注释的示例，请查看如何声明它们。</p>
</div>
<div class="paragraph">
<p>Spring MVC还支持带有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要子类化<code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并返回自己的属性<code>RequestCondition</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestmapping-registration"><a class="anchor" href="#mvc-ann-requestmapping-registration"></a>明确注册</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestmapping-registration">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以以编程方式注册处理程序方法，这些方法可用于动态注册或高级用例，例如同一处理程序在不同URL下的不同实例。下面的示例注册一个处理程序方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) <i class="conum" data-value="1"></i><b>(1)</b>
            throws NoSuchMethodException {

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); <i class="conum" data-value="2"></i><b>(2)</b>

        Method method = UserHandler.class.getMethod("getUser", Long.class); <i class="conum" data-value="3"></i><b>(3)</b>

        mapping.registerMapping(info, handler, method); <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加注册。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class MyConfig {

    @Autowired
    fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { <i class="conum" data-value="1"></i><b>(1)</b>
        val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() <i class="conum" data-value="2"></i><b>(2)</b>
        val method = UserHandler::class.java.getMethod("getUser", Long::class.java) <i class="conum" data-value="3"></i><b>(3)</b>
        mapping.registerMapping(info, handler, method) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加注册。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-methods"><a class="anchor" href="#mvc-ann-methods"></a> 1.3.3。处理程序方法</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-methods">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从支持的控制器方法参数和返回值的范围中进行选择。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-arguments"><a class="anchor" href="#mvc-ann-arguments"></a>方法参数</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-arguments">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>下表描述了受支持的控制器方法参数。任何参数均不支持反应性类型。</p>
</div>
<div class="paragraph">
<p>JDK 8的<code>java.util.Optional</code>支持作为方法参数，并与具有<code>required</code>属性（例如， <code>@RequestParam</code> ， <code>@RequestHeader</code>和其他），并且等效于<code>required=false</code> 。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebRequest</code> ，<code>NativeWebRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通用访问请求参数以及请求和会话属性，而无需直接使用Servlet API。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.ServletRequest</code> ，<code>javax.servlet.ServletResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择任何特定的请求或响应类型-例如， <code>ServletRequest</code> ， <code>HttpServletRequest</code>或Spring的<code>MultipartRequest</code> ， <code>MultipartHttpServletRequest</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http.HttpSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制会话的存在。结果，这种论点永远不会<code>null</code> 。请注意，会话访问不是线程安全的。考虑设置<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标记为<code>true</code>如果允许多个请求同时访问一个会话。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http.PushBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于程序化HTTP / 2资源推送的Servlet 4.0推送构建器API。请注意，根据Servlet规范， <code>PushBuilder</code>如果客户端不支持该HTTP / 2功能，则instance可以为null。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前经过身份验证的用户-可能是特定用户<code>Principal</code>实现类（如果已知）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前请求的语言环境，由最具体的语言确定<code>LocaleResolver</code>可用（实际上，已配置<code>LocaleResolver</code>要么<code>LocaleContextResolver</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> +<code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与当前请求关联的时区，由<code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.InputStream</code> ，<code>java.io.Reader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet API公开的原始请求正文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.OutputStream</code> ，<code>java.io.Writer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet API公开的原始响应正文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI模板变量。请参阅<a href="#mvc-ann-requestmapping-uri-templates">URI模式</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问URI路径段中的名称/值对。请参阅<a href="#mvc-ann-matrix-variables">矩阵变量</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问Servlet请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。看到<a href="#mvc-ann-requestparam"><code>@RequestParam</code></a>以及<a href="#mvc-multipart-forms">Multipart</a> 。
</p><p class="tableblock">注意使用<code>@RequestParam</code>对于简单参数值是可选的。请参阅此表末尾的“其他任何参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头。标头值将转换为声明的方法参数类型。看到<a href="#mvc-ann-requestheader"><code>@RequestHeader</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问cookie。Cookies值将转换为声明的方法参数类型。看到<a href="#mvc-ann-cookievalue"><code>@CookieValue</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTTP请求正文。正文内容通过使用转换为声明的方法参数类型<code>HttpMessageConverter</code>实现。看到<a href="#mvc-ann-requestbody"><code>@RequestBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity<B></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求标头和正文。身体被转换为<code>HttpMessageConverter</code> 。参见<a href="#mvc-ann-httpentity">HttpEntity</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问零件<code>multipart/form-data</code>请求，用<code>HttpMessageConverter</code> 。参见<a href="#mvc-multipart-forms">多部分</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code> ， <code>org.springframework.ui.Model</code> ，<code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问HTML控制器中使用的模型，并作为视图渲染的一部分公开给模板。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedirectAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定在重定向的情况下使用的属性（即追加到查询字符串中），并指定要临时存储的属性，直到重定向后的请求为止。请参阅<a href="#mvc-redirecting-passing-data">重定向属性</a>和<a href="#mvc-flash-attributes">Flash属性</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问模型中的现有属性（如果不存在，则进行实例化），并应用数据绑定和验证。看到<a href="#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a>以及<a href="#mvc-ann-modelattrib-methods">模型</a>和<a href="#mvc-ann-initbinder"><code>DataBinder</code></a> 。
</p><p class="tableblock">注意使用<code>@ModelAttribute</code>是可选的（例如，设置其属性）。请参阅此表末尾的“其他任何参数”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code> ，<code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问验证和命令对象数据绑定中的错误（即<code>@ModelAttribute</code>参数）或验证的错误<code>@RequestBody</code>要么<code>@RequestPart</code>论点。您必须声明一个<code>Errors</code> ， 要么<code>BindingResult</code>经过验证的方法参数后立即添加参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> +班级<code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为了标记表单处理完成，将触发清除通过类级别声明的会话属性<code>@SessionAttributes</code>注解。看到<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于准备相对于当前请求的主机，端口，方案，上下文路径以及servlet映射的文字部分的URL。请参阅<a href="#mvc-uri-building">URI链接</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与任何由于类级别而存储在会话中的模型属性相反，用于访问任何会话属性<code>@SessionAttributes</code>宣言。看到<a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求属性。看到<a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他论点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果方法参数与该表中的任何较早值都不匹配，并且是简单类型（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定），则将其解析为<code>@RequestParam</code> 。否则，将其解析为<code>@ModelAttribute</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-return-types"><a class="anchor" href="#mvc-ann-return-types"></a>返回值</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-return-types">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>下表描述了受支持的控制器方法返回值。所有返回值都支持反应性类型。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">控制器方法返回值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值通过<code>HttpMessageConverter</code>实现并写入响应。看到<a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity<B></code> ，<code>ResponseEntity<B></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定完整响应（包括HTTP标头和正文）的返回值将通过以下方式转换<code>HttpMessageConverter</code>实现并写入响应。参见<a href="#mvc-ann-responseentity">ResponseEntity</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于返回带有标头且没有正文的响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要解析的视图名称<code>ViewResolver</code>实现并与隐式模型一起使用-通过命令对象和<code>@ModelAttribute</code>方法。处理程序方法还可以通过声明以下内容以编程方式丰富模型： <code>Model</code>参数（请参阅<a href="#mvc-ann-requestmapping-registration">显式注册</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种<code>View</code>用于与隐式模型一起呈现的实例（通过命令对象和<code>@ModelAttribute</code>方法。处理程序方法还可以通过声明以下内容以编程方式丰富模型： <code>Model</code>参数（请参阅<a href="#mvc-ann-requestmapping-registration">显式注册</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code> ，<code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到隐式模型的属性，其中视图名称通过<code>RequestToViewNameTranslator</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到模型的属性，视图名称通过<code>RequestToViewNameTranslator</code> 。
</p><p class="tableblock">注意<code>@ModelAttribute</code>是可选的。请参阅此表末尾的“其他任何返回值”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ModelAndView</code>宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的视图和模型属性，以及响应状态（可选）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种带有<code>void</code>返回类型（或<code>null</code>返回值），如果它还具有一个<code>ServletResponse</code> ， <code>OutputStream</code>参数，或<code>@ResponseStatus</code>注解。如果控制器做出肯定的决定，也是如此<code>ETag</code>要么<code>lastModified</code>时间戳检查（有关详细信息，请参阅<a href="#mvc-caching-etag-lastmodified">控制器</a> ）。
</p><p class="tableblock">如果以上条件都不成立，则<code>void</code>对于REST控制器，返回类型还可以指示“无响应正文”；对于HTML控制器，返回类型也可以指示默认视图名称选择。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DeferredResult<V></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从任何线程异步生成任何上述返回值-例如，由于某些事件或回调的结果。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Callable<V></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Spring MVC管理的线程中异步产生上述任何返回值。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-callable"><code>Callable</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListenableFuture<V></code> ， <code>java.util.concurrent.CompletionStage<V></code> ，<code>java.util.concurrent.CompletableFuture<V></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">替代<code>DeferredResult</code> ，以方便使用（例如，当基础服务返回其中之一时）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyEmitter</code> ，<code>SseEmitter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异步发出对象流以将其写入响应<code>HttpMessageConverter</code>实现。也支持作为主体<code>ResponseEntity</code> 。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-http-streaming">HTTP流</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamingResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写回覆<code>OutputStream</code>异步地。也支持作为主体<code>ResponseEntity</code> 。请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-http-streaming">HTTP流</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">反应类型-Reactor，RxJava或其他类型<code>ReactiveAdapterRegistry</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">替代<code>DeferredResult</code>多值流（例如， <code>Flux</code> ， <code>Observable</code> ）收集到<code>List</code> 。
</p><p class="tableblock">对于流方案（例如， <code>text/event-stream</code> ， <code>application/json+stream</code> ）， <code>SseEmitter</code>和<code>ResponseBodyEmitter</code>用来代替<code>ServletOutputStream</code>在Spring MVC管理的线程上执行阻塞I / O，并在每次写入完成时施加背压。
</p><p class="tableblock">请参阅<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-reactive-types">响应类型</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与该表中的任何早期值都不匹配的任何返回值，即<code>String</code>要么<code>void</code>被视为视图名称（通过选择默认视图名称<code>RequestToViewNameTranslator</code> （适用），但它不是<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定的简单类型。简单类型的值仍然无法解析。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-typeconversion"><a class="anchor" href="#mvc-ann-typeconversion"></a>类型转换</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-typeconversion">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>一些带注释的控制器方法参数代表<code>String</code>基于请求的输入（例如<code>@RequestParam</code> ， <code>@RequestHeader</code> ， <code>@PathVariable</code> ， <code>@MatrixVariable</code>和<code>@CookieValue</code> ）如果参数被声明为非<code>String</code> 。</p>
</div>
<div class="paragraph">
<p>在这种情况下，将根据配置的转换器自动应用类型转换。默认情况下，简单类型（ <code>int</code> ， <code>long</code> ， <code>Date</code> ，以及其他）。您可以通过<code>WebDataBinder</code> （看到<a href="#mvc-ann-initbinder"><code>DataBinder</code></a> ）或通过注册<code>Formatters</code>与<code>FormattingConversionService</code> 。参见<a href="core.html#format">Spring字段格式化</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-matrix-variables"><a class="anchor" href="#mvc-ann-matrix-variables"></a>矩阵变量</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-matrix-variables">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a>讨论了路径段中的名称/值对。在Spring MVC中，基于Tim Berners-Lee的<a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“旧帖子”</a> ，我们将其称为“矩阵变量”，但它们也可以称为URI路径参数。</p>
</div>
<div class="paragraph">
<p>矩阵变量可以出现在任何路径段中，每个变量都用分号分隔，而多个值则用逗号分隔（例如， <code>/cars;color=red,green;year=2012</code> ）。也可以通过重复的变量名称来指定多个值（例如， <code>color=red;color=green;color=blue</code> ）。</p>
</div>
<div class="paragraph">
<p>如果期望URL包含矩阵变量，则控制器方法的请求映射必须使用URI变量来屏蔽该变量内容，并确保可以成功地匹配请求，而与矩阵变量的顺序和状态无关。以下示例使用矩阵变量：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

    // petId == 42
    // q == 11
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设所有路径段都可能包含矩阵变量，则有时您可能需要消除矩阵变量应位于哪个路径变量的歧义。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable(name="q", pathVar="ownerId") int q1,
        @MatrixVariable(name="q", pathVar="petId") int q2) {

    // q1 == 11
    // q2 == 22
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(
        @MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
        @MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

    // q1 == 11
    // q2 == 22
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将矩阵变量定义为可选变量，并指定默认值，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

    // q == 1
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /pets/42

@GetMapping("/pets/{petId}")
fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

    // q == 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要获取所有矩阵变量，可以使用<code>MultiValueMap</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar="petId") MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
fun findPet(
        @MatrixVariable matrixVars: MultiValueMap&lt;String, String&gt;,
        @MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap&lt;String, String&gt;) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您需要启用矩阵变量的使用。在MVC Java配置中，您需要设置一个<code>UrlPathHelper</code>与<code>removeSemicolonContent=false</code>通过<a href="#mvc-config-path-matching">路径匹配</a> 。在MVC XML名称空间中，您可以设置<code><mvc:annotation-driven enable-matrix-variables="true"/></code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestparam"><a class="anchor" href="#mvc-ann-requestparam"></a><code>@RequestParam</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestparam">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestParam</code>注释，用于将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/pets")
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam("petId") int petId, Model model) { <i class="conum" data-value="1"></i><b>(1)</b>
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    // ...

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestParam</code>绑定<code>petId</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.ui.set

@Controller
@RequestMapping("/pets")
class EditPetForm {

    // ...

    @GetMapping
    fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { <i class="conum" data-value="1"></i><b>(1)</b>
        val pet = this.clinic.loadPet(petId);
        model["pet"] = pet
        return "petForm"
    }

    // ...

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestParam</code>绑定<code>petId</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，使用此批注的方法参数是必需的，但是您可以通过设置<code>@RequestParam</code>注释的<code>required</code>标记为<code>false</code>或使用<code>java.util.Optional</code>包装纸。</p>
</div>
<div class="paragraph">
<p>如果目标方法参数类型不是，则类型转换将自动应用<code>String</code> 。请参阅<a href="#mvc-ann-typeconversion">类型转换</a> 。</p>
</div>
<div class="paragraph">
<p>将参数类型声明为数组或列表，可以为同一参数名称解析多个参数值。</p>
</div>
<div class="paragraph">
<p>当一个<code>@RequestParam</code>注释被声明为<code>Map<String, String></code>要么<code>MultiValueMap<String, String></code> ，而在注释中未指定参数名称，则使用每个给定参数名称的请求参数值填充地图。</p>
</div>
<div class="paragraph">
<p>注意使用<code>@RequestParam</code>是可选的（例如，设置其属性）。默认情况下，任何简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）都没有被其他任何参数解析器解析，就如同使用注释<code>@RequestParam</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestheader"><a class="anchor" href="#mvc-ann-requestheader"></a><code>@RequestHeader</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestheader">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestHeader</code>注释，用于将请求标头绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>考虑以下带有标头的请求：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例获取<code>Accept-Encoding</code>和<code>Keep-Alive</code>标头：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(
        @RequestHeader("Accept-Encoding") String encoding, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestHeader("Keep-Alive") long keepAlive) { <i class="conum" data-value="2"></i><b>(2)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>Accept-Encoding</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获得价值<code>Keep-Alive</code>标头。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/demo")
fun handle(
        @RequestHeader("Accept-Encoding") encoding: String, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestHeader("Keep-Alive") keepAlive: Long) { <i class="conum" data-value="2"></i><b>(2)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>Accept-Encoding</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>获得价值<code>Keep-Alive</code>标头。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果目标方法的参数类型不是<code>String</code> ，类型转换将自动应用。请参阅<a href="#mvc-ann-typeconversion">类型转换</a> 。</p>
</div>
<div class="paragraph">
<p>当一个<code>@RequestHeader</code>注释用于<code>Map<String, String></code> ， <code>MultiValueMap<String, String></code> ， 要么<code>HttpHeaders</code>参数，该映射将填充所有标头值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">内置支持可用于将逗号分隔的字符串转换为数组或字符串集合或类型转换系统已知的其他类型。例如，用注释的方法参数<code>@RequestHeader("Accept")</code>可以是类型<code>String</code>但是也<code>String[]</code>要么<code>List<String></code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-cookievalue"><a class="anchor" href="#mvc-ann-cookievalue"></a><code>@CookieValue</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-cookievalue">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@CookieValue</code>注释，用于将HTTP cookie的值绑定到控制器中的方法参数。</p>
</div>
<div class="paragraph">
<p>考虑带有以下cookie的请求：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何获取cookie值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { <i class="conum" data-value="1"></i><b>(1)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>JSESSIONID</code>曲奇饼。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/demo")
fun handle(@CookieValue("JSESSIONID") cookie: String) { <i class="conum" data-value="1"></i><b>(1)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>获得价值<code>JSESSIONID</code>曲奇饼。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果目标方法的参数类型不是<code>String</code> ，类型转换将自动应用。请参阅<a href="#mvc-ann-typeconversion">类型转换</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-modelattrib-method-args"><a class="anchor" href="#mvc-ann-modelattrib-method-args"></a><code>@ModelAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-modelattrib-method-args">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ModelAttribute</code>方法参数上的注解，以从模型访问属性或将其实例化（如果不存在）。model属性还覆盖了名称与字段名称匹配的HTTP Servlet请求参数中的值。这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段的工作。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>绑定一个实例<code>Pet</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute pet: Pet): String { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>绑定一个实例<code>Pet</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>Pet</code>上面的实例解析如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从模型（如果已使用<a href="#mvc-ann-modelattrib-methods">Model</a>添加）。</p>
</li>
<li>
<p>通过使用HTTP会话<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a> 。</p>
</li>
<li>
<p>从URI路径变量通过<code>Converter</code> （请参见下一个示例）。</p>
</li>
<li>
<p>从默认构造函数的调用开始。</p>
</li>
<li>
<p>从调用具有与Servlet请求参数匹配的参数的“主要构造函数”开始。参数名称是通过JavaBeans确定的<code>@ConstructorProperties</code>或通过字节码中运行时保留的参数名称。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然使用<a href="#mvc-ann-modelattrib-methods">模型</a>向属性中填充模型是很常见的，但另一种替代方法是依靠<code>Converter<String, T></code>与URI路径变量约定结合使用。在以下示例中，模型属性名称， <code>account</code> ，与URI路径变量匹配， <code>account</code>和<code>Account</code>通过传递<code>String</code>通过注册的帐号<code>Converter<String, Account></code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PutMapping("/accounts/{account}")
public String save(@ModelAttribute("account") Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PutMapping("/accounts/{account}")
fun save(@ModelAttribute("account") account: Account): String {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取模型属性实例后，将应用数据绑定。的<code>WebDataBinder</code>类将Servlet请求参数名称（查询参数和表单字段）与目标上的字段名称匹配<code>Object</code> 。必要时在应用类型转换后填充匹配字段。有关数据绑定（和验证）的更多信息，请参见<a href="core.html#validation">验证</a> 。有关自定义数据绑定的更多信息，请参见<a href="#mvc-ann-initbinder"><code>DataBinder</code></a> 。</p>
</div>
<div class="paragraph">
<p>数据绑定可能导致错误。默认情况下， <code>BindException</code>被提出。但是，要检查控制器方法中的此类错误，可以添加一个<code>BindingResult</code>紧挨着的论点<code>@ModelAttribute</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加一个<code>BindingResult</code>在旁边<code>@ModelAttribute</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm"
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>添加一个<code>BindingResult</code>在旁边<code>@ModelAttribute</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望访问没有数据绑定的模型属性。在这种情况下，您可以注入<code>Model</code>进入控制器并直接访问它，或者设置<code>@ModelAttribute(binding=false)</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public AccountForm setUpForm() {
    return new AccountForm();
}

@ModelAttribute
public Account findAccount(@PathVariable String accountId) {
    return accountRepository.findOne(accountId);
}

@PostMapping("update")
public String update(@Valid AccountForm form, BindingResult result,
        @ModelAttribute(binding=false) Account account) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>@ModelAttribute(binding=false)</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ModelAttribute
fun setUpForm(): AccountForm {
    return AccountForm()
}

@ModelAttribute
fun findAccount(@PathVariable accountId: String): Account {
    return accountRepository.findOne(accountId)
}

@PostMapping("update")
fun update(@Valid form: AccountForm, result: BindingResult,
           @ModelAttribute(binding = false) account: Account): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>@ModelAttribute(binding=false)</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以在数据绑定后自动添加验证，方法是添加<code>javax.validation.Valid</code>注解或Spring的<code>@Validated</code>注解（ <a href="core.html#validation-beanvalidation">Bean验证</a>和<a href="core.html#validation">Spring验证</a> ）。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>验证<code>Pet</code>实例。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm"
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意使用<code>@ModelAttribute</code>是可选的（例如，设置其属性）。默认情况下，任何不是简单值类型（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定）且未被其他任何参数解析器解析的参数都将被视为带有注释<code>@ModelAttribute</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-sessionattributes"><a class="anchor" href="#mvc-ann-sessionattributes"></a><code>@SessionAttributes</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-sessionattributes">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code>用于在请求之间的HTTP Servlet会话中存储模型属性。它是类型级别的注释，用于声明特定控制器使用的会话属性。这通常列出应透明地存储在会话中以供后续访问请求的模型属性名称或模型属性类型。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>@SessionAttributes</code>注解：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttributes</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@SessionAttributes</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在第一个请求中，当模型名称为name时， <code>pet</code>会被添加到模型中，并会自动升级到并保存在HTTP Servlet会话中。它会保留在那里，直到另一种控制器方法使用<code>SessionStatus</code>方法参数清除存储，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) {
        if (errors.hasErrors) {
            // ...
        }
            status.setComplete(); <i class="conum" data-value="2"></i><b>(2)</b>
            // ...
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>储存<code>Pet</code> Servlet会话中的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>清除<code>Pet</code> Servlet会话中的值。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String {
        if (errors.hasErrors()) {
            // ...
        }
        status.setComplete() <i class="conum" data-value="2"></i><b>(2)</b>
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>储存<code>Pet</code> Servlet会话中的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>清除<code>Pet</code> Servlet会话中的值。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-sessionattribute"><a class="anchor" href="#mvc-ann-sessionattribute"></a><code>@SessionAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-sessionattribute">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>如果您需要访问全局存在（即在控制器外部（例如，通过过滤器）管理）并且可能存在或可能不存在的预先存在的会话属性，则可以使用<code>@SessionAttribute</code>方法参数的注释，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping("/")
public String handle(@SessionAttribute User user) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>用一个<code>@SessionAttribute</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RequestMapping("/")
fun handle(@SessionAttribute user: User): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于需要添加或删除会话属性的用例，请考虑注入<code>org.springframework.web.context.request.WebRequest</code>要么<code>javax.servlet.http.HttpSession</code>进入控制器方法。</p>
</div>
<div class="paragraph">
<p>要将模型属性临时存储在会话中作为控制器工作流的一部分，请考虑使用<code>@SessionAttributes</code>如中所述<a href="#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestattrib"><a class="anchor" href="#mvc-ann-requestattrib"></a><code>@RequestAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestattrib">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>相似<code>@SessionAttribute</code> ，您可以使用<code>@RequestAttribute</code>批注以访问先前创建的先前存在的请求属性（例如，由Servlet创建） <code>Filter</code>要么<code>HandlerInterceptor</code> ）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@RequestAttribute Client client) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestAttribute</code>注解。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/")
fun handle(@RequestAttribute client: Client): String { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用<code>@RequestAttribute</code>注解。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-redirecting-passing-data"><a class="anchor" href="#mvc-redirecting-passing-data"></a>重定向属性</h5>
<div class="paragraph">
<p>默认情况下，所有模型属性均被视为在重定向URL中作为URI模板变量公开。在其余属性中，那些属于原始类型或原始类型的集合或数组的属性会自动附加为查询参数。</p>
</div>
<div class="paragraph">
<p>如果专门为重定向准备了模型实例，则将原始类型属性作为查询参数附加可能是理想的结果。但是，在带注释的控制器中，模型可以包含为渲染目的添加的其他属性（例如，下拉字段值）。为了避免此类属性出现在网址中， <code>@RequestMapping</code>方法可以声明类型的参数<code>RedirectAttributes</code>并使用它来指定要用于的确切属性<code>RedirectView</code> 。如果该方法确实重定向，则<code>RedirectAttributes</code>用来。否则，将使用模型的内容。</p>
</div>
<div class="paragraph">
<p>的<code>RequestMappingHandlerAdapter</code>提供一个称为<code>ignoreDefaultModelOnRedirect</code> ，您可以使用它来指示默认内容<code>Model</code>如果控制器方法重定向，则永远不要使用。相反，控制器方法应声明一个类型的属性<code>RedirectAttributes</code>或者，如果不这样做，则不应将任何属性传递给<code>RedirectView</code> 。MVC命名空间和MVC Java配置都将此标志设置为<code>false</code> ，以保持向后兼容性。但是，对于新应用程序，我们建议将其设置为<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，展开重定向URL时，本请求中的URI模板变量会自动变为可用，而您无需通过以下方式显式添加它们<code>Model</code>要么<code>RedirectAttributes</code> 。以下示例显示了如何定义重定向：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/files/{path}")
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/files/{path}")
fun upload(...): String {
    // ...
    return "redirect:files/{path}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将数据传递到重定向目标的另一种方法是使用闪存属性。与其他重定向属性不同，闪存属性保存在HTTP会话中（因此不会出现在URL中）。有关更多信息，请参见<a href="#mvc-flash-attributes">Flash属性</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-flash-attributes"><a class="anchor" href="#mvc-flash-attributes"></a> Flash属性</h5>
<div class="paragraph">
<p>Flash属性为一个请求提供了一种存储打算在另一个请求中使用的属性的方式。重定向时最常需要此功能，例如Post-Redirect-Get模式。Flash属性在重定向之前（通常在会话中）被临时保存，以便在重定向之后可供请求使用，并立即被删除。</p>
</div>
<div class="paragraph">
<p>Spring MVC有两个主要的抽象来支持Flash属性。 <code>FlashMap</code>用于保存Flash属性，而<code>FlashMapManager</code>用于存储，检索和管理<code>FlashMap</code>实例。</p>
</div>
<div class="paragraph">
<p>Flash属性支持始终处于“打开”状态，无需显式启用。但是，如果不使用它，则永远不会导致HTTP会话创建。每个请求都有一个“输入” <code>FlashMap</code>具有从先前请求（如果有）传递的属性和“输出” <code>FlashMap</code>具有可保存用于后续请求的属性。都<code>FlashMap</code>实例可以通过Spring MVC中的静态方法从任何地方访问<code>RequestContextUtils</code> 。</p>
</div>
<div class="paragraph">
<p>带注释的控制器通常不需要使用<code>FlashMap</code>直。相反， <code>@RequestMapping</code>方法可以接受类型的参数<code>RedirectAttributes</code>并使用它为重定向方案添加Flash属性。通过添加Flash属性<code>RedirectAttributes</code>会自动传播到“输出” FlashMap。同样，重定向后，来自“输入”的属性<code>FlashMap</code>会自动添加到<code>Model</code>提供目标网址的控制器的名称。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">将请求与Flash属性匹配</div>
<div class="paragraph">
<p>Flash属性的概念存在于许多其他Web框架中，并已证明有时会遇到并发问题。这是因为根据定义，闪存属性将存储到下一个请求。但是，“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，过早删除了Flash属性。</p>
</div>
<div class="paragraph">
<p>为了减少此类问题的可能性， <code>RedirectView</code>自动“盖章” <code>FlashMap</code>具有目标重定向URL的路径和查询参数的实例。反过来，默认<code>FlashMapManager</code>在查找“输入”时将该信息与传入请求匹配<code>FlashMap</code> 。</p>
</div>
<div class="paragraph">
<p>这不能完全消除并发问题的可能性，但是可以通过重定向URL中已经可用的信息大大减少并发问题。因此，我们建议您主要将Flash属性用于重定向方案。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-multipart-forms"><a class="anchor" href="#mvc-multipart-forms"></a>多部分</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-multipart-forms">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>之后<code>MultipartResolver</code>已<a href="#mvc-multipart">启用</a> ，POST请求的内容与<code>multipart/form-data</code>作为常规请求参数进行解析和访问。以下示例访问一个常规表单字段和一个上载文件：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(@RequestParam("name") String name,
            @RequestParam("file") MultipartFile file) {

        if (!file.isEmpty()) {
            byte[] bytes = file.getBytes();
            // store the bytes somewhere
            return "redirect:uploadSuccess";
        }
        return "redirect:uploadFailure";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class FileUploadController {

    @PostMapping("/form")
    fun handleFormUpload(@RequestParam("name") name: String,
                        @RequestParam("file") file: MultipartFile): String {

        if (!file.isEmpty) {
            val bytes = file.bytes
            // store the bytes somewhere
            return "redirect:uploadSuccess"
        }
        return "redirect:uploadFailure"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将参数类型声明为<code>List<MultipartFile></code>允许使用相同的参数名称解析多个文件。</p>
</div>
<div class="paragraph">
<p>当。。。的时候<code>@RequestParam</code>注释被声明为<code>Map<String, MultipartFile></code>要么<code>MultiValueMap<String, MultipartFile></code> ，而在注释中未指定参数名称，则将使用每个给定参数名称的多部分文件填充地图。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过Servlet 3.0多部分解析，您还可以声明<code>javax.servlet.http.Part</code>而不是春天的<code>MultipartFile</code> ，作为方法参数或集合值类型。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以将多部分内容用作绑定到<a href="#mvc-ann-modelattrib-method-args">命令对象</a>的数据的一部分。例如，前面示例中的表单字段和文件可以是表单对象上的字段，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class MyForm {

    private String name;

    private MultipartFile file;

    // ...
}

@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(MyForm form, BindingResult errors) {
        if (!form.getFile().isEmpty()) {
            byte[] bytes = form.getFile().getBytes();
            // store the bytes somewhere
            return "redirect:uploadSuccess";
        }
        return "redirect:uploadFailure";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class MyForm(val name: String, val file: MultipartFile, ...)

@Controller
class FileUploadController {

    @PostMapping("/form")
    fun handleFormUpload(form: MyForm, errors: BindingResult): String {
        if (!form.file.isEmpty) {
            val bytes = form.file.bytes
            // store the bytes somewhere
            return "redirect:uploadSuccess"
        }
        return "redirect:uploadFailure"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在RESTful服务方案中，也可以从非浏览器客户端提交多部分请求。以下示例显示了带有JSON的文件：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下命令访问“元数据”部分<code>@RequestParam</code>作为一个<code>String</code>但您可能希望将其从JSON反序列化（类似于<code>@RequestBody</code> ）。使用<code>@RequestPart</code>使用<a href="integration.html#rest-message-conversion">HttpMessageConverter</a>转换后的批注以访问多部分：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata,
        @RequestPart("file-data") MultipartFile file) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@RequestPart("meta-data") metadata: MetaData,
        @RequestPart("file-data") file: MultipartFile): String {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestPart</code>与...结合<code>javax.validation.Valid</code>或使用Spring的<code>@Validated</code>批注，这两者都会导致应用标准Bean验证。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code> ，它变成400（BAD_REQUEST）响应。或者，您可以通过以下方式在控制器内本地处理验证错误： <code>Errors</code>要么<code>BindingResult</code>参数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
        BindingResult result) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/")
fun handle(@Valid @RequestPart("meta-data") metadata: MetaData,
        result: BindingResult): String {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-requestbody"><a class="anchor" href="#mvc-ann-requestbody"></a><code>@RequestBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-requestbody">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestBody</code>注释，以将请求正文读取并反序列化为<code>Object</code>通过<a href="integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a> 。以下示例使用<code>@RequestBody</code>参数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@RequestBody account: Account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<a href="#mvc-config">MVC Config</a>的“ <a href="#mvc-config-message-converters">消息转换器”</a>选项来配置或自定义消息转换。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@RequestBody</code>与...结合<code>javax.validation.Valid</code>或春天的<code>@Validated</code>批注，这两者都会导致应用标准Bean验证。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code> ，它变成400（BAD_REQUEST）响应。或者，您可以通过以下方式在控制器内本地处理验证错误： <code>Errors</code>要么<code>BindingResult</code>参数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(@Valid @RequestBody account: Account, result: BindingResult) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-httpentity"><a class="anchor" href="#mvc-ann-httpentity"></a> HttpEntity</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-httpentity">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code>与使用大致相同<a href="#mvc-ann-requestbody"><code>@RequestBody</code></a>但基于公开请求标头和正文的容器对象。以下清单显示了一个示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(HttpEntity&lt;Account&gt; entity) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping("/accounts")
fun handle(entity: HttpEntity&lt;Account&gt;) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-responsebody"><a class="anchor" href="#mvc-ann-responsebody"></a><code>@ResponseBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-responsebody">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ResponseBody</code>方法上的批注，以使返回值通过<a href="integration.html#rest-message-conversion">HttpMessageConverter</a>序列化为响应主体。以下清单显示了一个示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/accounts/{id}")
@ResponseBody
fun handle(): Account {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code>在类级别也受支持，在这种情况下，它由所有控制器方法继承。这是效果<code>@RestController</code> ，无非就是标有的元注释<code>@Controller</code>和<code>@ResponseBody</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ResponseBody</code>具有反应性类型。有关更多详细信息， <a href="#mvc-ann-async">请</a>参见<a href="#mvc-ann-async">异步请求</a>和<a href="#mvc-ann-async-reactive-types">响应类型</a> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<a href="#mvc-config">MVC Config</a>的“ <a href="#mvc-config-message-converters">消息转换器”</a>选项来配置或自定义消息转换。</p>
</div>
<div class="paragraph">
<p>你可以结合<code>@ResponseBody</code> JSON序列化视图的方法。有关详细信息，请参见<a href="#mvc-ann-jackson">Jackson JSON</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-responseentity"><a class="anchor" href="#mvc-ann-responseentity"></a>响应实体</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-responseentity">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code>就好像<a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a>但是带有状态和标题。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/something")
public ResponseEntity&lt;String&gt; handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/something")
fun handle(): ResponseEntity&lt;String&gt; {
    val body = ...
    val etag = ...
    return ResponseEntity.ok().eTag(etag).build(body)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring MVC支持使用单值<a href="#mvc-ann-async-reactive-types">反应类型</a>来生成<code>ResponseEntity</code>和/或主体的单值和多值反应类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-jackson"><a class="anchor" href="#mvc-ann-jackson"></a>杰克逊JSON</h5>
<div class="paragraph">
<p>Spring提供了对Jackson JSON库的支持。</p>
</div>
<div class="sect5">
<h6 id="mvc-ann-jsonview"><a class="anchor" href="#mvc-ann-jsonview"></a> JSON视图</h6>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-jsonview">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC为<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson的序列化视图</a>提供了内置支持，该<a href="https://www.baeldung.com/jackson-json-view-annotation">视图</a>仅允许呈现<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson中的</a>所有字段的子集。 <code>Object</code> 。搭配使用<code>@ResponseBody</code>要么<code>ResponseEntity</code>控制器方法，可以使用杰克逊的<code>@JsonView</code>注释以激活序列化视图类，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView::class)
    fun getUser() = User("eric", "7!jd#h23")
}

class User(
        @JsonView(WithoutPasswordView::class) val username: String,
        @JsonView(WithPasswordView::class) val password: String) {

    interface WithoutPasswordView
    interface WithPasswordView : WithoutPasswordView
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@JsonView</code>允许一组视图类，但是每个控制器方法只能指定一个。如果需要激活多个视图，则可以使用复合界面。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于依赖视图分辨率的控制器，可以将序列化视图类添加到模型中，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class UserController extends AbstractController {

    @GetMapping("/user")
    public String getUser(Model model) {
        model.addAttribute("user", new User("eric", "7!jd#h23"));
        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
        return "userView";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.ui.set

@Controller
class UserController : AbstractController() {

    @GetMapping("/user")
    fun getUser(model: Model): String {
        model["user"] = User("eric", "7!jd#h23")
        model[JsonView::class.qualifiedName] = User.WithoutPasswordView::class.java
        return "userView"
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-modelattrib-methods"><a class="anchor" href="#mvc-ann-modelattrib-methods"></a> 1.3.4。模型</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-modelattrib-methods">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ModelAttribute</code>注解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在<a href="#mvc-ann-modelattrib-method-args">方法自变量</a>中<code>@RequestMapping</code>创建或访问<code>Object</code>并通过一个模型将其绑定到请求<code>WebDataBinder</code> 。</p>
</li>
<li>
<p>作为方法级别的注释<code>@Controller</code>要么<code>@ControllerAdvice</code>有助于在任何之前初始化模型的类<code>@RequestMapping</code>方法调用。</p>
</li>
<li>
<p>在<code>@RequestMapping</code>标记其返回值的方法是模型属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节讨论<code>@ModelAttribute</code> methods —前面列表中的第二项。控制器可以具有任意数量的<code>@ModelAttribute</code>方法。所有此类方法均在调用之前<code>@RequestMapping</code>同一控制器中的方法。一种<code>@ModelAttribute</code>也可以通过以下方式在控制器之间共享方法<code>@ControllerAdvice</code> 。有关更多详细信息，请参见“ <a href="#mvc-ann-controller-advice">控制器建议</a> ”部分。</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。他们支持许多与<code>@RequestMapping</code>方法，除了<code>@ModelAttribute</code>本身或与请求正文相关的任何内容。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@ModelAttribute</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ModelAttribute
fun populateModel(@RequestParam number: String, model: Model) {
    model.addAttribute(accountRepository.findAccount(number))
    // add more ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例仅添加一个属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ModelAttribute
fun addAccount(@RequestParam number: String): Account {
    return accountRepository.findAccount(number)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未明确指定名称，则根据<code>Object</code>类型，如javadoc中所述<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a> 。您始终可以通过使用重载来分配显式名称<code>addAttribute</code>方法或通过<code>name</code>归因于<code>@ModelAttribute</code> （用于返回值）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您也可以使用<code>@ModelAttribute</code>作为方法级别的注释<code>@RequestMapping</code>方法，在这种情况下， <code>@RequestMapping</code>方法被解释为模型属性。通常不需要这样做，因为这是HTML控制器的默认行为，除非返回值是<code>String</code>否则将被解释为视图名称。
<code>@ModelAttribute</code>还可以自定义模型属性名称，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
    // ...
    return account;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
fun handle(): Account {
    // ...
    return account
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-initbinder"><a class="anchor" href="#mvc-ann-initbinder"></a> 1.3.5。<code>DataBinder</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-initbinder">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>要么<code>@ControllerAdvice</code>类可以有<code>@InitBinder</code>初始化实例的方法<code>WebDataBinder</code> ，而这些又可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将请求参数（即表单或查询数据）绑定到模型对象。</p>
</li>
<li>
<p>将基于字符串的请求值（例如请求参数，路径变量，标头，Cookie等）转换为控制器方法参数的目标类型。</p>
</li>
<li>
<p>将模型对象值格式化为<code>String</code>呈现HTML表单时的值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法可以注册特定于控制器的方法<code>java.bean.PropertyEditor</code>或春天<code>Converter</code>和<code>Formatter</code>组件。此外，您可以使用<a href="#mvc-config-conversion">MVC配置</a>进行注册<code>Converter</code>和<code>Formatter</code>输入全球共享<code>FormattingConversionService</code> 。</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code>方法支持许多相同的参数<code>@RequestMapping</code>方法可以，除了<code>@ModelAttribute</code> （命令对象）参数。通常，它们以<code>WebDataBinder</code>参数（用于注册）和一个<code>void</code>返回值。以下清单显示了一个示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个<code>@InitBinder</code>方法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    fun initBinder(binder: WebDataBinder) {
        val dateFormat = SimpleDateFormat("yyyy-MM-dd")
        dateFormat.isLenient = false
        binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个<code>@InitBinder</code>方法。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>或者，当您使用<code>Formatter</code>基于共享的设置<code>FormattingConversionService</code> ，您可以重复使用相同的方法并注册特定于控制器的<code>Formatter</code>实现，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个<code>@InitBinder</code>自定义格式化程序上的方法。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    protected fun initBinder(binder: WebDataBinder) {
        binder.addCustomFormatter(DateFormatter("yyyy-MM-dd"))
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>定义一个<code>@InitBinder</code>自定义格式化程序上的方法。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-exceptionhandler"><a class="anchor" href="#mvc-ann-exceptionhandler"></a> 1.3.6。例外情况</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-controller-exceptions">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code>和<a href="#mvc-ann-controller-advice">@ControllerAdvice</a>类可以具有<code>@ExceptionHandler</code>处理控制器方法异常的方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class SimpleController {

    // ...

    @ExceptionHandler
    public ResponseEntity&lt;String&gt; handle(IOException ex) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class SimpleController {

    // ...

    @ExceptionHandler
    fun handle(ex: IOException): ResponseEntity&lt;String&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该异常可能与正在传播的顶级异常（即直接<code>IOException</code>或针对顶级包装程序异常中的直接原因（例如， <code>IOException</code>包裹在里面<code>IllegalStateException</code> ）。</p>
</div>
<div class="paragraph">
<p>对于匹配的异常类型，如前面的示例所示，最好将目标异常声明为方法参数。当多个异常方法匹配时，根源异常匹配通常比原因异常匹配更可取。更具体地说， <code>ExceptionDepthComparator</code>用于根据异常从引发的异常类型的深度进行排序。</p>
</div>
<div class="paragraph">
<p>另外，注释声明可以缩小异常类型以使其匹配，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(IOException ex) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExceptionHandler(FileSystemException::class, RemoteException::class)
fun handle(ex: IOException): ResponseEntity&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以使用带有非常通用的参数签名的特定异常类型的列表，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(Exception ex) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@ExceptionHandler(FileSystemException::class, RemoteException::class)
fun handle(ex: Exception): ResponseEntity&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根和原因异常匹配之间的区别可能令人惊讶。</p>
</div>
<div class="paragraph">
<p>在里面<code>IOException</code>前面显示的变体，通常以实际<code>FileSystemException</code>要么<code>RemoteException</code>实例作为参数，因为它们都从<code>IOException</code> 。但是，如果在包装异常中传播了任何此类匹配异常，则包装异常本身就是<code>IOException</code> ，传入的异常实例就是包装异常。</p>
</div>
<div class="paragraph">
<p>该行为甚至更简单<code>handle(Exception)</code>变体。在包装方案中，总是使用包装器异常调用此方法，而实际匹配的异常可通过以下方法找到<code>ex.getCause()</code>在这种情况下。传入的异常是实际的<code>FileSystemException</code>要么<code>RemoteException</code>仅当将它们作为顶级异常抛出时才实例化。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，我们建议您在参数签名中尽可能具体，以减少根类型和原因异常类型之间不匹配的可能性。考虑将多重匹配方法分解为单个<code>@ExceptionHandler</code>方法，每个方法都通过其签名匹配单个特定的异常类型。</p>
</div>
<div class="paragraph">
<p>在多<code>@ControllerAdvice</code>安排，我们建议您在<code>@ControllerAdvice</code>按相应的顺序排列优先级。尽管根源异常匹配是原因的首选，但这是在给定控制器或<code>@ControllerAdvice</code>类。这意味着更高优先级的原因匹配<code>@ControllerAdvice</code>优先于优先级较低的任何匹配项（例如，根）使用bean <code>@ControllerAdvice</code>豆。</p>
</div>
<div class="paragraph">
<p>最后但并非最不重要的是， <code>@ExceptionHandler</code>方法实现可以选择通过以原始形式重新抛出异常来退出处理给定异常实例。在仅对根级别匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下，这很有用。重新抛出的异常会在剩余的解决方案链中传播，就像给定的<code>@ExceptionHandler</code>方法首先不会匹配。</p>
</div>
<div class="paragraph">
<p>支持<code>@ExceptionHandler</code> Spring MVC中的方法基于<code>DispatcherServlet</code>级别，使用<a href="#mvc-exceptionhandlers">HandlerExceptionResolver</a>机制。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-exceptionhandler-args"><a class="anchor" href="#mvc-ann-exceptionhandler-args"></a>方法参数</h5>
<div class="paragraph">
<p><code>@ExceptionHandler</code>方法支持以下参数：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">异常类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问引发的异常。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问引发异常的控制器方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebRequest</code> ，<code>NativeWebRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对请求参数以及请求和会话属性的一般访问，而无需直接使用Servlet API。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.ServletRequest</code> ，<code>javax.servlet.ServletResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择任何特定的请求或响应类型（例如， <code>ServletRequest</code>要么<code>HttpServletRequest</code>或或春天的<code>MultipartRequest</code>要么<code>MultipartHttpServletRequest</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.servlet.http.HttpSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制会话的存在。结果，这种论点永远不会<code>null</code> 。<br>请注意，会话访问不是线程安全的。考虑设置<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code>标记为<code>true</code>如果允许多个请求同时访问一个会话。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前经过身份验证的用户-可能是特定用户<code>Principal</code>实现类（如果已知）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前请求的语言环境，由最具体的语言确定<code>LocaleResolver</code>可用-实际上，已配置<code>LocaleResolver</code>要么<code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> ，<code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与当前请求关联的时区，由<code>LocaleContextResolver</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.io.OutputStream</code> ，<code>java.io.Writer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问原始响应主体（由Servlet API公开）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code> ， <code>org.springframework.ui.Model</code> ，<code>org.springframework.ui.ModelMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问模型以进行错误响应。永远是空的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedirectAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定在重定向的情况下要使用的属性（要附加到查询字符串中），并指定要临时存储的属性，直到重定向后的请求为止。请参阅<a href="#mvc-redirecting-passing-data">重定向属性</a>和<a href="#mvc-flash-attributes">Flash属性</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与任何由于类级别而存储在会话中的模型属性相反，用于访问任何会话属性<code>@SessionAttributes</code>宣言。看到<a href="#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a>更多细节。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问请求属性。看到<a href="#mvc-ann-requestattrib"><code>@RequestAttribute</code></a>更多细节。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-exceptionhandler-return-values"><a class="anchor" href="#mvc-ann-exceptionhandler-return-values"></a>返回值</h5>
<div class="paragraph">
<p><code>@ExceptionHandler</code>方法支持以下返回值：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值通过<code>HttpMessageConverter</code>实例并写入响应。看到<a href="#mvc-ann-responsebody"><code>@ResponseBody</code></a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity<B></code> ，<code>ResponseEntity<B></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值指定完整的响应（包括HTTP标头和正文）将通过以下方式转换<code>HttpMessageConverter</code>实例并写入响应。参见<a href="#mvc-ann-responseentity">ResponseEntity</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要解析的视图名称<code>ViewResolver</code>实现并与隐式模型一起使用-通过命令对象和<code>@ModelAttribute</code>方法。处理程序方法还可以通过声明以下内容以编程方式丰富模型： <code>Model</code>参数（如前所述）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种<code>View</code>用于与隐式模型一起呈现的实例（通过命令对象和<code>@ModelAttribute</code>方法。处理程序方法还可以通过声明以下内容以编程方式丰富模型： <code>Model</code>论点（前面已描述）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code> ，<code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到隐式模型的属性，其中视图名称是通过<code>RequestToViewNameTranslator</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要添加到模型的属性，其视图名称通过<code>RequestToViewNameTranslator</code> 。
</p><p class="tableblock">注意<code>@ModelAttribute</code>是可选的。请参见表末尾的“其他任何返回值”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ModelAndView</code>宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的视图和模型属性，以及响应状态（可选）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种带有<code>void</code>返回类型（或<code>null</code>返回值），如果它还具有一个<code>ServletResponse</code>一个<code>OutputStream</code>争论或<code>@ResponseStatus</code>注解。如果控制器做出肯定的决定，也是如此<code>ETag</code>要么<code>lastModified</code>时间戳检查（有关详细信息，请参阅<a href="#mvc-caching-etag-lastmodified">控制器</a> ）。
</p><p class="tableblock">如果以上条件都不成立，则<code>void</code>对于REST控制器，返回类型还可以指示“无响应正文”；对于HTML控制器，返回类型也可以指示默认视图名称选择。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何其他返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果返回值与上述任何一个都不匹配并且不是简单类型（由<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>确定），则默认情况下会将其视为要添加到模型的模型属性。如果是简单类型，则仍然无法解析。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="mvc-ann-rest-exceptions"><a class="anchor" href="#mvc-ann-rest-exceptions"></a> REST API例外</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-rest-exceptions">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>REST服务的常见要求是在响应正文中包含错误详细信息。Spring Framework 不会自动执行此操作，因为响应主体中错误详细信息的表示是特定于应用程序的。但是， <code>@RestController</code>可以使用<code>@ExceptionHandler</code>方法与<code>ResponseEntity</code>返回值以设置响应的状态和主体。这样的方法也可以在<code>@ControllerAdvice</code>类以将其全局应用。</p>
</div>
<div class="paragraph">
<p>在响应正文中使用错误详细信息实现全局异常处理的应用程序应考虑扩展<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html"><code>ResponseEntityExceptionHandler</code></a> ，它提供了Spring MVC引发的异常的处理，并提供了挂钩以自定义响应主体。要利用此功能，请创建一个子类<code>ResponseEntityExceptionHandler</code> ，用<code>@ControllerAdvice</code> ，重写必要的方法，并将其声明为Spring bean。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-controller-advice"><a class="anchor" href="#mvc-ann-controller-advice"></a> 1.3.7。控制器建议</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-ann-controller-advice">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>通常<code>@ExceptionHandler</code> ， <code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于<code>@Controller</code>声明它们的类（或类层次结构）。如果您希望此类方法更全局地应用（跨控制器），则可以在带有以下注释的类中声明它们： <code>@ControllerAdvice</code>要么<code>@RestControllerAdvice</code> 。</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code>带有注释<code>@Component</code> ，这意味着可以通过<a href="core.html#beans-java-instantiating-container-scan">组件扫描</a>将此类注册为Spring Bean。 <code>@RestControllerAdvice</code>是一个组合注释，同时用<code>@ControllerAdvice</code>和<code>@ResponseBody</code> ，这实质上意味着<code>@ExceptionHandler</code>方法通过消息转换（与视图分辨率或模板渲染相比）呈现给响应主体。</p>
</div>
<div class="paragraph">
<p>启动时，用于<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法检测带有注释的Spring bean <code>@ControllerAdvice</code>然后在运行时应用其方法。全球<code>@ExceptionHandler</code>方法（从<code>@ControllerAdvice</code> ） <em>在</em>本地（从<code>@Controller</code> ）。相比之下，全球<code>@ModelAttribute</code>和<code>@InitBinder</code>方法<em>先于</em>本地方法。</p>
</div>
<div class="paragraph">
<p>默认， <code>@ControllerAdvice</code>方法适用于每个请求（即所有控制器），但是您可以通过使用注释上的属性将其范围缩小到控制器的子集，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = [RestController::class])
class ExampleAdvice1

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
class ExampleAdvice2

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
class ExampleAdvice3</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a>有关更多详细信息，请参见javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-fn"><a class="anchor" href="#webmvc-fn"></a> 1.4。功能端点</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-fn">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Web MVC包含WebMvc.fn，这是一个轻量级的函数编程模型，其中的函数用于路由和处理请求，而契约则是为不变性而设计的。它是基于注释的编程模型的替代方案，但可以在同一<a href="#mvc-servlet">DispatcherServlet</a>上运行。</p>
</div>
<div class="sect3">
<h4 id="webmvc-fn-overview"><a class="anchor" href="#webmvc-fn-overview"></a> 1.4.1。总览</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-fn-overview">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在WebMvc.fn中，HTTP请求使用<code>HandlerFunction</code> ：需要的功能<code>ServerRequest</code>并返回一个<code>ServerResponse</code> 。作为请求对象的请求都具有不可变的协定，这些协定为JDK 8提供了对HTTP请求和响应的友好访问。
<code>HandlerFunction</code>等于一个物体的主体<code>@RequestMapping</code>基于注释的编程模型中的方法。</p>
</div>
<div class="paragraph">
<p>传入的请求被路由到带有<code>RouterFunction</code> ：需要的功能<code>ServerRequest</code>并返回一个可选<code>HandlerFunction</code> （即<code>Optional<HandlerFunction></code> ）。当路由器功能匹配时，返回处理程序功能。否则为空的Optional。
<code>RouterFunction</code>等于一个<code>@RequestMapping</code>注释，但主要区别在于路由器功能不仅提供数据，还提供行为。</p>
</div>
<div class="paragraph">
<p><code>RouterFunctions.route()</code>提供了一个有助于构建路由器的路由器构建器，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.servlet.function.RequestPredicates.*;
import static org.springframework.web.servlet.function.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople)
    .POST("/person", handler::createPerson)
    .build();


public class PersonHandler {

    // ...

    public ServerResponse listPeople(ServerRequest request) {
        // ...
    }

    public ServerResponse createPerson(ServerRequest request) {
        // ...
    }

    public ServerResponse getPerson(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.servlet.function.router

val repository: PersonRepository = ...
val handler = PersonHandler(repository)

val route = router { <i class="conum" data-value="1"></i><b>(1)</b>
    accept(APPLICATION_JSON).nest {
        GET("/person/{id}", handler::getPerson)
        GET("/person", handler::listPeople)
    }
    POST("/person", handler::createPerson)
}


class PersonHandler(private val repository: PersonRepository) {

    // ...

    fun listPeople(request: ServerRequest): ServerResponse {
        // ...
    }

    fun createPerson(request: ServerRequest): ServerResponse {
        // ...
    }

    fun getPerson(request: ServerRequest): ServerResponse {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>使用路由器DSL创建路由器。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您注册<code>RouterFunction</code>作为bean，例如通过将其暴露在@Configuration类中，它将由servlet自动检测，如“ <a href="#webmvc-fn-running">运行服务器”中所述</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-handler-functions"><a class="anchor" href="#webmvc-fn-handler-functions"></a> 1.4.2。处理函数</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-fn-handler-functions">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerRequest</code>和<code>ServerResponse</code>是不可变的接口，可提供JDK 8友好的HTTP请求和响应访问，包括标头，正文，方法和状态代码。</p>
</div>
<div class="sect4">
<h5 id="webmvc-fn-request"><a class="anchor" href="#webmvc-fn-request"></a><code>ServerRequest</code></h5>
<div class="paragraph">
<p><code>ServerRequest</code>提供对HTTP方法，URI，标头和查询参数的访问，而对正文的访问则通过<code>body</code>方法。</p>
</div>
<div class="paragraph">
<p>以下示例将请求正文提取到<code>String</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String string = request.body(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val string = request.body&lt;String&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例将主体提取到<code>List<Person></code> ，在哪里<code>Person</code>对象从序列化形式（例如JSON或XML）解码：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; people = request.body(new ParameterizedTypeReference&lt;List&lt;Person&gt;&gt;() {});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val people = request.body&lt;Person&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何访问参数：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">MultiValueMap&lt;String, String&gt; params = request.params();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val map = request.params()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webmvc-fn-response"><a class="anchor" href="#webmvc-fn-response"></a><code>ServerResponse</code></h5>
<div class="paragraph">
<p><code>ServerResponse</code>提供对HTTP响应的访问，并且由于它是不可变的，因此您可以使用<code>build</code>创建它的方法。您可以使用构建器来设置响应状态，添加响应标题或提供正文。以下示例使用JSON内容创建200（确定）响应：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Person person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val person: Person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用来构建201（已创建）响应<code>Location</code>标头，无正文：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI location = ...
ServerResponse.created(location).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val location: URI = ...
ServerResponse.created(location).build()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webmvc-fn-handler-classes"><a class="anchor" href="#webmvc-fn-handler-classes"></a>处理程序类</h5>
<div class="paragraph">
<p>我们可以将处理程序函数编写为lambda，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().body("Hello World");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val helloWorld: (ServerRequest) -&gt; ServerResponse =
  { ServerResponse.ok().body("Hello World") }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很方便，但是在应用程序中我们需要多个功能，并且多个内联lambda可能会变得凌乱。因此，将相关的处理程序功能分组到一个处理程序类中很有用，该类的作用与<code>@Controller</code>在基于注释的应用程序中。例如，以下类公开了一个反应式<code>Person</code>资料库：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

public class PersonHandler {

    private final PersonRepository repository;

    public PersonHandler(PersonRepository repository) {
        this.repository = repository;
    }

    public ServerResponse listPeople(ServerRequest request) { <i class="conum" data-value="1"></i><b>(1)</b>
        List&lt;Person&gt; people = repository.allPeople();
        return ok().contentType(APPLICATION_JSON).body(people);
    }

    public ServerResponse createPerson(ServerRequest request) throws Exception { <i class="conum" data-value="2"></i><b>(2)</b>
        Person person = request.body(Person.class);
        repository.savePerson(person);
        return ok().build();
    }

    public ServerResponse getPerson(ServerRequest request) { <i class="conum" data-value="3"></i><b>(3)</b>
        int personId = Integer.parseInt(request.pathVariable("id"));
        Person person = repository.getPerson(personId);
        if (person != null) {
            return ok().contentType(APPLICATION_JSON).body(person))
        }
        else {
            return ServerResponse.notFound().build();
        }
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>listPeople</code>是一个返回所有<code>Person</code>在存储库中以JSON形式找到的对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>createPerson</code>是一个存储新<code>Person</code>包含在请求正文中。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>getPerson</code>是一个返回单个人的处理函数，由<code>id</code>路径变量。我们检索到<code>Person</code>从存储库中创建一个JSON响应（如果找到）。如果找不到，我们将返回404 Not Found响应。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonHandler(private val repository: PersonRepository) {

    fun listPeople(request: ServerRequest): ServerResponse { <i class="conum" data-value="1"></i><b>(1)</b>
        val people: List&lt;Person&gt; = repository.allPeople()
        return ok().contentType(APPLICATION_JSON).body(people);
    }

    fun createPerson(request: ServerRequest): ServerResponse { <i class="conum" data-value="2"></i><b>(2)</b>
        val person = request.body&lt;Person&gt;()
        repository.savePerson(person)
        return ok().build()
    }

    fun getPerson(request: ServerRequest): ServerResponse { <i class="conum" data-value="3"></i><b>(3)</b>
        val personId = request.pathVariable("id").toInt()
        return repository.getPerson(personId)?.let { ok().contentType(APPLICATION_JSON).body(it) }
                ?: ServerResponse.notFound().build()

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>listPeople</code>是一个返回所有<code>Person</code>在存储库中以JSON形式找到的对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>createPerson</code>是一个存储新<code>Person</code>包含在请求正文中。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>getPerson</code>是一个返回单个人的处理函数，由<code>id</code>路径变量。我们检索到<code>Person</code>从存储库中创建一个JSON响应（如果找到）。如果找不到，我们将返回404 Not Found响应。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="webmvc-fn-handler-validation"><a class="anchor" href="#webmvc-fn-handler-validation"></a>验证方式</h5>
<div class="paragraph">
<p>功能端点可以使用Spring的<a href="core.html#validation">验证工具</a>将验证应用于请求主体。例如，给定一个自定义的Spring <a href="core.html#validation">Validator</a>实现， <code>Person</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonHandler {

    private final Validator validator = new PersonValidator(); <i class="conum" data-value="1"></i><b>(1)</b>

    // ...

    public ServerResponse createPerson(ServerRequest request) {
        Person person = request.body(Person.class);
        validate(person); <i class="conum" data-value="2"></i><b>(2)</b>
        repository.savePerson(person);
        return ok().build();
    }

    private void validate(Person person) {
        Errors errors = new BeanPropertyBindingResult(person, "person");
        validator.validate(person, errors);
        if (errors.hasErrors()) {
            throw new ServerWebInputException(errors.toString()); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建<code>Validator</code>实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>应用验证。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>引发400响应的异常。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PersonHandler(private val repository: PersonRepository) {

    private val validator = PersonValidator() <i class="conum" data-value="1"></i><b>(1)</b>

    // ...

    fun createPerson(request: ServerRequest): ServerResponse {
        val person = request.body&lt;Person&gt;()
        validate(person) <i class="conum" data-value="2"></i><b>(2)</b>
        repository.savePerson(person)
        return ok().build()
    }

    private fun validate(person: Person) {
        val errors: Errors = BeanPropertyBindingResult(person, "person")
        validator.validate(person, errors)
        if (errors.hasErrors()) {
            throw ServerWebInputException(errors.toString()) <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>创建<code>Validator</code>实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>应用验证。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>引发400响应的异常。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>处理程序还可以通过创建和注入全局bean来使用标准bean验证API（JSR-303）。 <code>Validator</code>实例基于<code>LocalValidatorFactoryBean</code> 。请参阅<a href="core.html#validation-beanvalidation">Spring Validation</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-router-functions"><a class="anchor" href="#webmvc-fn-router-functions"></a> 1.4.3。<code>RouterFunction</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-fn-router-functions">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>路由器功能用于将请求路由到相应的<code>HandlerFunction</code> 。通常，您不必自己编写路由器功能，而应在<code>RouterFunctions</code>实用程序类创建一个。
<code>RouterFunctions.route()</code> （无参数）为您提供了流畅的生成器来创建路由器功能，而<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code>提供了创建路由器的直接方法。</p>
</div>
<div class="paragraph">
<p>通常，建议使用<code>route()</code>构建器，因为它为典型的映射方案提供了便捷的捷径，而无需发现静态导入。例如，路由器功能构建器提供了方法<code>GET(String, HandlerFunction)</code>为GET请求创建映射；和<code>POST(String, HandlerFunction)</code>用于POST。</p>
</div>
<div class="paragraph">
<p>除了基于HTTP方法的映射外，路由构建器还提供了一种在映射到请求时引入其他谓词的方法。对于每个HTTP方法，都有一个重载的变体，它需要一个<code>RequestPredicate</code>作为参数，但可以表达其他约束。</p>
</div>
<div class="sect4">
<h5 id="webmvc-fn-predicates"><a class="anchor" href="#webmvc-fn-predicates"></a>谓词</h5>
<div class="paragraph">
<p>你可以自己写<code>RequestPredicate</code> ，但<code>RequestPredicates</code>实用程序类基于请求路径，HTTP方法，内容类型等提供常用的实现。以下示例使用请求谓词基于以下内容创建约束： <code>Accept</code>标头：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
    .GET("/hello-world", accept(MediaType.TEXT_PLAIN),
        request -&gt; ServerResponse.ok().body("Hello World"));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
    GET("/hello-world", accept(TEXT_PLAIN)) {
        ServerResponse.ok().body("Hello World")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下命令组合多个请求谓词：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestPredicate.and(RequestPredicate)</code> -两者必须匹配。</p>
</li>
<li>
<p><code>RequestPredicate.or(RequestPredicate)</code> -两者都可以匹配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>许多谓词来自<code>RequestPredicates</code>组成。例如， <code>RequestPredicates.GET(String)</code>由...组成<code>RequestPredicates.method(HttpMethod)</code>和<code>RequestPredicates.path(String)</code> 。上面显示的示例还使用了两个请求谓词，因为构建器使用<code>RequestPredicates.GET</code>在内部，并与<code>accept</code>谓语。</p>
</div>
</div>
<div class="sect4">
<h5 id="webmvc-fn-routes"><a class="anchor" href="#webmvc-fn-routes"></a>路线</h5>
<div class="paragraph">
<p>路由器功能按顺序评估：如果第一个路由不匹配，则评估第二个路由，依此类推。因此，在通用路由之前声明更具体的路由是有意义的。请注意，此行为不同于基于注释的编程模型，在该模型中，将自动选择“最特定”的控制器方法。</p>
</div>
<div class="paragraph">
<p>使用路由器功能生成器时，所有定义的路由都被组合为一个<code>RouterFunction</code>从返回<code>build()</code> 。还有其他方法可以将多个路由器功能组合在一起：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>add(RouterFunction)</code>在<code>RouterFunctions.route()</code>建造者</p>
</li>
<li>
<p><code>RouterFunction.and(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> —的快捷方式<code>RouterFunction.and()</code>与嵌套<code>RouterFunctions.route()</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了四种路线的组成：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.servlet.function.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
    .POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
    .add(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>GET /person/{id}</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>GET /person</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>POST /person</code>没有其他谓词的映射到<code>PersonHandler.createPerson</code>和</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>otherRoute</code>是在其他地方创建并添加到所建立路由的路由器功能。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.http.MediaType.APPLICATION_JSON
import org.springframework.web.servlet.function.router

val repository: PersonRepository = ...
val handler = PersonHandler(repository);

val otherRoute = router {  }

val route = router {
    GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
    GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
    POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
}.and(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>GET /person/{id}</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td><code>GET /person</code>带着<code>Accept</code>与JSON匹配的标头被路由到<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td><code>POST /person</code>没有其他谓词的映射到<code>PersonHandler.createPerson</code>和</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td><code>otherRoute</code>是在其他地方创建并添加到所建立路由的路由器功能。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="nested-routes"><a class="anchor" href="#nested-routes"></a>嵌套路线</h5>
<div class="paragraph">
<p>一组路由器功能通常具有共享谓词，例如共享路径。在上面的示例中，共享谓词将是与之匹配的路径谓词<code>/person</code> ，其中三条路线都使用了。使用注释时，您将使用类型级别来删除此重复项<code>@RequestMapping</code>映射到的注释<code>/person</code> 。在WebMvc.fn中，路径谓词可以通过以下方式共享<code>path</code>路由器功能构建器上的方法。例如，以上示例的最后几行可以通过使用嵌套路由以以下方式进行改进：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", builder -&gt; builder <i class="conum" data-value="1"></i><b>(1)</b>
        .GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        .GET("", accept(APPLICATION_JSON), handler::listPeople)
        .POST("/person", handler::createPerson))
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>请注意， <code>path</code>是使用路由器制造商的消费者。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
    "/person".nest {
        GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        GET("", accept(APPLICATION_JSON), handler::listPeople)
        POST("/person", handler::createPerson)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管基于路径的嵌套是最常见的，但是您可以通过使用<code>nest</code>生成器上的方法。上面仍然包含一些重复形式的共享<code>Accept</code> -header谓词。我们可以通过使用<code>nest</code>方法与<code>accept</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
    "/person".nest {
        accept(APPLICATION_JSON).nest {
            GET("/{id}", handler::getPerson)
            GET("", handler::listPeople)
            POST("/person", handler::createPerson)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-running"><a class="anchor" href="#webmvc-fn-running"></a> 1.4.4。运行服务器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-fn-running">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您通常会在<a href="#mvc-servlet"><code>DispatcherHandler</code></a>通过<a href="#mvc-config">MVC Config进行</a>基于设置的<a href="#mvc-config">设置</a> ，该设置使用Spring配置来声明处理请求所需的组件。MVC Java配置声明以下基础结构组件以支持功能端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctionMapping</code> ：检测一个或多个<code>RouterFunction<?></code> Spring配置中的bean，通过组合它们<code>RouterFunction.andOther</code> ，并将请求路由到生成的结果<code>RouterFunction</code> 。</p>
</li>
<li>
<p><code>HandlerFunctionAdapter</code> ：简单的适配器，让<code>DispatcherHandler</code>调用<code>HandlerFunction</code>映射到请求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的组件使功能端点适合<code>DispatcherServlet</code>请求处理生命周期，并（可能）与带注释的控制器（如果已声明）并排运行。这也是Spring Boot Web启动程序如何启用功能端点的方式。</p>
</div>
<div class="paragraph">
<p>以下示例显示了WebFlux Java配置：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableMvc
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionA() {
        // ...
    }

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionB() {
        // ...
    }

    // ...

    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        // configure message conversion...
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // configure CORS...
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // configure view resolution for HTML rendering...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableMvc
class WebConfig : WebMvcConfigurer {

    @Bean
    fun routerFunctionA(): RouterFunction&lt;*&gt; {
        // ...
    }

    @Bean
    fun routerFunctionB(): RouterFunction&lt;*&gt; {
        // ...
    }

    // ...

    override fun configureMessageConverters(converters: List&lt;HttpMessageConverter&lt;*&gt;&gt;) {
        // configure message conversion...
    }

    override fun addCorsMappings(registry: CorsRegistry) {
        // configure CORS...
    }

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        // configure view resolution for HTML rendering...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webmvc-fn-handler-filter-function"><a class="anchor" href="#webmvc-fn-handler-filter-function"></a> 1.4.5。过滤处理程序功能</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-fn-handler-filter-function">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>before</code> ， <code>after</code> ， 要么<code>filter</code>路由功能构建器上的方法。使用注释，您可以通过使用<code>@ControllerAdvice</code> ， 一种<code>ServletFilter</code> ， 或两者。该过滤器将应用于构建器构建的所有路由。这意味着在嵌套路由中定义的过滤器不适用于“顶级”路由。例如，考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople)
            .before(request -&gt; ServerRequest.from(request) <i class="conum" data-value="1"></i><b>(1)</b>
                .header("X-RequestHeader", "Value")
                .build()))
        .POST("/person", handler::createPerson))
    .after((request, response) -&gt; logResponse(response)) <i class="conum" data-value="2"></i><b>(2)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>before</code>添加自定义请求标头的过滤器仅应用于两个GET路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>after</code>记录响应的过滤器将应用于所有路由，包括嵌套路由。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.servlet.function.router

val route = router {
    "/person".nest {
        GET("/{id}", handler::getPerson)
        GET("", handler::listPeople)
        before { <i class="conum" data-value="1"></i><b>(1)</b>
            ServerRequest.from(it)
                    .header("X-RequestHeader", "Value").build()
        }
        POST("/person", handler::createPerson)
        after { _, response -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            logResponse(response)
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>before</code>添加自定义请求标头的过滤器仅应用于两个GET路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>的<code>after</code>记录响应的过滤器将应用于所有路由，包括嵌套路由。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>filter</code>路由器构建器上的方法需要一个<code>HandlerFilterFunction</code> ：需要一个<code>ServerRequest</code>和<code>HandlerFunction</code>并返回一个<code>ServerResponse</code> 。handler函数参数代表链中的下一个元素。这通常是路由到的处理程序，但是如果应用了多个，它也可以是另一个过滤器。</p>
</div>
<div class="paragraph">
<p>现在，假设我们有一个<code>SecurityManager</code>可以确定是否允许特定路径。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">SecurityManager securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .filter((request, next) -&gt; {
        if (securityManager.allowAccessTo(request.path())) {
            return next.handle(request);
        }
        else {
            return ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.web.servlet.function.router

val securityManager: SecurityManager = ...

val route = router {
    ("/person" and accept(APPLICATION_JSON)).nest {
        GET("/{id}", handler::getPerson)
        GET("", handler::listPeople)
        POST("/person", handler::createPerson)
        filter { request, next -&gt;
            if (securityManager.allowAccessTo(request.path())) {
                next(request)
            }
            else {
                status(UNAUTHORIZED).build();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例说明了调用<code>next.handle(ServerRequest)</code>是可选的。当允许访问时，我们仅允许执行处理函数。</p>
</div>
<div class="paragraph">
<p>除了使用<code>filter</code>路由器功能构建器上的方法，可以通过以下方法将过滤器应用于现有路由器功能<code>RouterFunction.filter(HandlerFilterFunction)</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过专用的CORS支持功能端点<a href="#webflux-cors-webfilter"><code>CorsWebFilter</code></a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-uri-building"><a class="anchor" href="#mvc-uri-building"></a> 1.5。URI链接</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-uri-building">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>本节描述了Spring Framework 中可用于URI的各种选项。</p>
</div>
<div class="sect3">
<h4 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a> 1.5.1。UriComponents</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>有助于从带有变量的URI模板构建URI，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
        .queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
        .encode() <i class="conum" data-value="3"></i><b>(3)</b>
        .build(); <i class="conum" data-value="4"></i><b>(4)</b>

URI uri = uriComponents.expand("Westin", "123").toUri();  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>请求对URI模板和URI变量进行编码。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>建个<code>UriComponents</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>展开变量并获得<code>URI</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uriComponents = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
        .queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
        .encode() <i class="conum" data-value="3"></i><b>(3)</b>
        .build() <i class="conum" data-value="4"></i><b>(4)</b>

val uri = uriComponents.expand("Westin", "123").toUri()  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>请求对URI模板和URI变量进行编码。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>建个<code>UriComponents</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>展开变量并获得<code>URI</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的示例可以合并为一个链，并且可以通过以下方式缩短<code>buildAndExpand</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("Westin", "123")
        .toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("Westin", "123")
        .toUri()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}?q={q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder
        .fromUriString("https://example.com/hotels/{hotel}?q={q}")
        .build("Westin", "123")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a> 1.5.2。UriBuilder</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a>贯彻<code>UriBuilder</code> 。您可以创建一个<code>UriBuilder</code> ，反过来， <code>UriBuilderFactory</code> 。一起， <code>UriBuilderFactory</code>和<code>UriBuilder</code>提供一种可插入的机制，以基于共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p>
</div>
<div class="paragraph">
<p>您可以配置<code>RestTemplate</code>和<code>WebClient</code>与一个<code>UriBuilderFactory</code>自定义URI的准备。 <code>DefaultUriBuilderFactory</code>是的默认实现<code>UriBuilderFactory</code>使用<code>UriComponentsBuilder</code>内部并公开共享的配置选项。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置<code>RestTemplate</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode

val baseUrl = "https://example.org"
val factory = DefaultUriBuilderFactory(baseUrl)
factory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES

val restTemplate = RestTemplate()
restTemplate.uriTemplateHandler = factory</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例配置了一个<code>WebClient</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "https://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode

val baseUrl = "https://example.org"
val factory = DefaultUriBuilderFactory(baseUrl)
factory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES

val client = WebClient.builder().uriBuilderFactory(factory).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，您还可以使用<code>DefaultUriBuilderFactory</code>直。类似于使用<code>UriComponentsBuilder</code>但是，它是一个实际的实例，其中包含配置和首选项，而不是静态的工厂方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String baseUrl = "https://example.com";
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val baseUrl = "https://example.com"
val uriBuilderFactory = DefaultUriBuilderFactory(baseUrl)

val uri = uriBuilderFactory.uriString("/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a> 1.5.3。URI编码</h4>
<div class="paragraph">
<p><span class="small">Spring MVC和Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder＃encode（）</a> ：首先对URI模板进行预编码，然后在扩展时严格对URI变量进行编码。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents＃encode（）</a> ：扩展URI变量<em>后，</em> <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">对</a> URI组件<em>进行</em>编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个选项都用转义的八位字节替换非ASCII和非法字符。但是，第一个选项还会替换出现在URI变量中的具有保留含义的字符。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">考虑“;”，这在路径上是合法的，但具有保留的含义。第一个选项代替“;” URI变量中带有“％3B”，但URI模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在大多数情况下，第一个选项可能会产生预期的结果，因为它将URI变量视为要完全编码的不透明数据，而选项2仅在URI变量有意包含保留字符的情况下才有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用第一个选项：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("New York", "foo+bar")
        .toUri();

// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("New York", "foo+bar")
        .toUri()

// Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过直接转到URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
        .queryParam("q", "{q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}?q={q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uri = UriComponentsBuilder.fromPath("/hotel list/{city}?q={q}")
        .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>WebClient</code>和<code>RestTemplate</code>通过内部扩展和编码URI模板<code>UriBuilderFactory</code>战略。两者都可以使用自定义策略进行配置。如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String baseUrl = "https://example.com";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

// Customize the RestTemplate..
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);

// Customize the WebClient..
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val baseUrl = "https://example.com"
val factory = DefaultUriBuilderFactory(baseUrl).apply {
    encodingMode = EncodingMode.TEMPLATE_AND_VALUES
}

// Customize the RestTemplate..
val restTemplate = RestTemplate().apply {
    uriTemplateHandler = factory
}

// Customize the WebClient..
val client = WebClient.builder().uriBuilderFactory(factory).build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>DefaultUriBuilderFactory</code>实施用途<code>UriComponentsBuilder</code>在内部扩展和编码URI模板。作为工厂，它提供了一个位置，可以根据以下一种编码模式来配置编码方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code> ：用途<code>UriComponentsBuilder#encode()</code> ，对应于较早列表中的第一个选项，以对URI模板进行预编码，并在扩展时严格编码URI变量。</p>
</li>
<li>
<p><code>VALUES_ONLY</code> ：不对URI模板进行编码，而是通过以下方式对URI变量进行严格编码<code>UriUtils#encodeUriUriVariables</code>在将它们扩展到模板之前。</p>
</li>
<li>
<p><code>URI_COMPONENTS</code> ：用途<code>UriComponents#encode()</code> ，与先前列表中的第二个选项相对应，以在扩展URI变量<em>后</em>对URI组件值进行编码。</p>
</li>
<li>
<p><code>NONE</code> ：未应用编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>RestTemplate</code>被设定为<code>EncodingMode.URI_COMPONENTS</code>由于历史原因和向后兼容性。的<code>WebClient</code>依赖于中的默认值<code>DefaultUriBuilderFactory</code> ，从更改为<code>EncodingMode.URI_COMPONENTS</code>在5.0.x中<code>EncodingMode.TEMPLATE_AND_VALUES</code>在5.1中。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-servleturicomponentsbuilder"><a class="anchor" href="#mvc-servleturicomponentsbuilder"></a> 1.5.4。相对Servlet请求</h4>
<div class="paragraph">
<p>您可以使用<code>ServletUriComponentsBuilder</code>创建相对于当前请求的URI，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpServletRequest request = ...

// Re-uses host, scheme, port, path and query string...

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
        .replaceQueryParam("accountId", "{id}").build()
        .expand("123")
        .encode();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val request: HttpServletRequest = ...

// Re-uses host, scheme, port, path and query string...

val ucb = ServletUriComponentsBuilder.fromRequest(request)
        .replaceQueryParam("accountId", "{id}").build()
        .expand("123")
        .encode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以创建相对于上下文路径的URI，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Re-uses host, port and context path...

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
        .path("/accounts").build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Re-uses host, port and context path...

val ucb = ServletUriComponentsBuilder.fromContextPath(request)
        .path("/accounts").build()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以创建相对于Servlet的URI（例如， <code>/main/*</code> ），如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Re-uses host, port, context path, and Servlet prefix...

ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
        .path("/accounts").build()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Re-uses host, port, context path, and Servlet prefix...

val ucb = ServletUriComponentsBuilder.fromServletMapping(request)
        .path("/accounts").build()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.1开始， <code>ServletUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code>标头，用于指定客户端起源的地址。考虑使用<a href="#filters-forwarded-headers"><code>ForwardedHeaderFilter</code></a>提取并使用或丢弃此类标头。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-links-to-controllers"><a class="anchor" href="#mvc-links-to-controllers"></a> 1.5.5。链接到控制器</h4>
<div class="paragraph">
<p>Spring MVC提供了一种准备到控制器方法的链接的机制。例如，以下MVC控制器允许创建链接：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/hotels/{hotel}")
public class BookingController {

    @GetMapping("/bookings/{booking}")
    public ModelAndView getBooking(@PathVariable Long booking) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
@RequestMapping("/hotels/{hotel}")
class BookingController {

    @GetMapping("/bookings/{booking}")
    fun getBooking(@PathVariable booking: Long): ModelAndView {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过按名称引用方法来准备链接，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UriComponents uriComponents = MvcUriComponentsBuilder
    .fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uriComponents = MvcUriComponentsBuilder
    .fromMethodName(BookingController::class.java, "getBooking", 21).buildAndExpand(42)

val uri = uriComponents.encode().toUri()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们提供了实际的方法参数值（在这种情况下，为long值： <code>21</code> ）用作路径变量并插入URL。此外，我们提供了价值， <code>42</code> ，以填写所有剩余的URI变量，例如<code>hotel</code>从类型级请求映射继承的变量。如果该方法具有更多参数，则可以为URL不需要的参数提供null。一般来说，只有<code>@PathVariable</code>和<code>@RequestParam</code>参数与构造URL有关。</p>
</div>
<div class="paragraph">
<p>还有其他使用方式<code>MvcUriComponentsBuilder</code> 。例如，您可以使用类似于代理的测试技术来避免按名称引用控制器方法，如以下示例所示（示例假定静态导入） <code>MvcUriComponentsBuilder.on</code> ）：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UriComponents uriComponents = MvcUriComponentsBuilder
    .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val uriComponents = MvcUriComponentsBuilder
    .fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

val uri = uriComponents.encode().toUri()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当控制器方法签名可用于创建链接时，其设计受到限制<code>fromMethodCall</code> 。除了需要适当的参数签名外，返回类型还存在技术限制（即，为链接生成器调用生成运行时代理），因此返回类型不得为<code>final</code> 。特别是常见的<code>String</code>视图名称的返回类型在这里不起作用。你应该用<code>ModelAndView</code>甚至平原<code>Object</code> （带有<code>String</code>返回值）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的示例在<code>MvcUriComponentsBuilder</code> 。在内部，他们依靠<code>ServletUriComponentsBuilder</code>根据当前请求的方案，主机，端口，上下文路径和servlet路径准备基本URL。在大多数情况下，此方法效果很好。但是，有时可能不足。例如，您可能不在请求的上下文之内（例如，准备链接的批处理过程），或者您可能需要插入路径前缀（例如，从请求路径中删除并需要重新设置的语言环境前缀）。插入链接）。</p>
</div>
<div class="paragraph">
<p>在这种情况下，您可以使用静态<code>fromXxx</code>接受一个<code>UriComponentsBuilder</code>使用基本URL。另外，您可以创建一个实例<code>MvcUriComponentsBuilder</code>使用基本URL，然后使用基于实例的<code>withXxx</code>方法。例如，以下清单使用<code>withMethodCall</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

URI uri = uriComponents.encode().toUri();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en")
val builder = MvcUriComponentsBuilder.relativeTo(base)
builder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

val uri = uriComponents.encode().toUri()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.1开始， <code>MvcUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code>标头，用于指定客户端起源的地址。考虑使用<a href="#filters-forwarded-headers">ForwardedHeaderFilter</a>提取和使用或丢弃此类标头。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-links-to-controllers-from-views"><a class="anchor" href="#mvc-links-to-controllers-from-views"></a> 1.5.6。视图中的链接</h4>
<div class="paragraph">
<p>在Thymeleaf，FreeMarker或JSP之类的视图中，您可以通过引用每个请求映射的隐式或显式分配的名称来构建到带注释的控制器的链接。</p>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping("/people/{id}/addresses")
public class PersonAddressController {

    @RequestMapping("/{country}")
    public HttpEntity&lt;PersonAddress&gt; getAddress(@PathVariable String country) { ... }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RequestMapping("/people/{id}/addresses")
class PersonAddressController {

    @RequestMapping("/{country}")
    fun getAddress(@PathVariable country: String): HttpEntity&lt;PersonAddress&gt; { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定前面的控制器，您可以按照以下步骤准备来自JSP的链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;
...
&lt;a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}"&gt;Get Address&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例依赖于<code>mvcUrl</code>在Spring标签库中声明的函数（即META-INF / spring.tld），但是很容易定义自己的函数或为其他模板技术准备类似的函数。</p>
</div>
<div class="paragraph">
<p>这是这样的。在启动时，每个<code>@RequestMapping</code>通过分配默认名称<code>HandlerMethodMappingNamingStrategy</code> ，其默认实现使用类的大写字母和方法名称（例如， <code>getThing</code>方法中<code>ThingController</code>变成“ TC＃getThing”）。如果名称冲突，可以使用<code>@RequestMapping(name="..")</code>分配一个明确的名称或实现自己的名称<code>HandlerMethodMappingNamingStrategy</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-ann-async"><a class="anchor" href="#mvc-ann-async"></a> 1.6。异步请求</h3>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC与Servlet 3.0异步请求<a href="#mvc-ann-async-processing">处理</a>具有广泛的集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>和<a href="#mvc-ann-async-callable"><code>Callable</code></a>控制器方法中的返回值，并为单个异步返回值提供基本支持。</p>
</li>
<li>
<p>控制器可以<a href="#mvc-ann-async-http-streaming">流式传输</a>多个值，包括<a href="#mvc-ann-async-sse">SSE</a>和<a href="#mvc-ann-async-output-stream">原始数据</a> 。</p>
</li>
<li>
<p>控制器可以使用反应式客户端并返回<a href="#mvc-ann-async-reactive-types">反应式类型</a>以进行响应处理。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-deferredresult"><a class="anchor" href="#mvc-ann-async-deferredresult"></a> 1.6.1。<code>DeferredResult</code></h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>一旦在Servlet容器中<a href="#mvc-ann-async-configuration">启用</a>了异步请求处理功能，控制器方法就可以使用以下命令包装任何受支持的控制器方法返回值： <code>DeferredResult</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/quotes")
@ResponseBody
public DeferredResult&lt;String&gt; quotes() {
    DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;();
    // Save the deferredResult somewhere..
    return deferredResult;
}

// From some other thread...
deferredResult.setResult(result);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/quotes")
@ResponseBody
fun quotes(): DeferredResult&lt;String&gt; {
    val deferredResult = DeferredResult&lt;String&gt;()
    // Save the deferredResult somewhere..
    return deferredResult
}

// From some other thread...
deferredResult.setResult(result)</code></pre>
</div>
</div>
<div class="paragraph">
<p>控制器可以从另一个线程异步生成返回值，例如，响应外部事件（JMS消息），计划任务或其他事件。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-callable"><a class="anchor" href="#mvc-ann-async-callable"></a> 1.6.2。<code>Callable</code></h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以使用以下命令包装任何受支持的返回值： <code>java.util.concurrent.Callable</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping
public Callable&lt;String&gt; processUpload(final MultipartFile file) {

    return new Callable&lt;String&gt;() {
        public String call() throws Exception {
            // ...
            return "someView";
        }
    };
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@PostMapping
fun processUpload(file: MultipartFile) = Callable&lt;String&gt; {
    // ...
    "someView"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以通过运行已<a href="#mvc-ann-async-configuration-spring-mvc">配置</a>的给定任务来获得返回值<code>TaskExecutor</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-processing"><a class="anchor" href="#mvc-ann-async-processing"></a> 1.6.3。处理中</h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>这是Servlet异步请求处理的非常简洁的概述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>ServletRequest</code>可以通过调用置于异步模式<code>request.startAsync()</code> 。这样做的主要作用是可以退出Servlet（以及所有过滤器），但是响应保持打开状态，以便以后完成处理。</p>
</li>
<li>
<p>致电<code>request.startAsync()</code>退货<code>AsyncContext</code> ，可用于进一步控制异步处理。例如，它提供了<code>dispatch</code>方法，该方法类似于Servlet API的转发，不同之处在于它允许应用程序恢复Servlet容器线程上的请求处理。</p>
</li>
<li>
<p>的<code>ServletRequest</code>提供访问当前<code>DispatcherType</code> ，可用于区分处理初始请求，异步调度，转发和其他调度程序类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DeferredResult</code>处理工作如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>控制器返回一个<code>DeferredResult</code>并将其保存在一些可以访问它的内存队列或列表中。</p>
</li>
<li>
<p>Spring MVC调用<code>request.startAsync()</code> 。</p>
</li>
<li>
<p>同时， <code>DispatcherServlet</code>并且所有已配置的过滤器都退出请求处理线程，但响应保持打开状态。</p>
</li>
<li>
<p>该应用程序设置<code>DeferredResult</code>从某个线程，Spring MVC将请求分派回Servlet容器。</p>
</li>
<li>
<p>的<code>DispatcherServlet</code>再次调用，并使用异步产生的返回值恢复处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Callable</code>处理工作如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>控制器返回一个<code>Callable</code> 。</p>
</li>
<li>
<p>Spring MVC调用<code>request.startAsync()</code>并提交<code>Callable</code>到一个<code>TaskExecutor</code>用于在单独的线程中进行处理。</p>
</li>
<li>
<p>同时， <code>DispatcherServlet</code>并且所有过滤器都退出Servlet容器线程，但是响应保持打开状态。</p>
</li>
<li>
<p>最终<code>Callable</code>产生结果，Spring MVC将请求分派回Servlet容器以完成处理。</p>
</li>
<li>
<p>的<code>DispatcherServlet</code>再次调用，并使用异步产生的返回值从<code>Callable</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多背景知识，您还可以阅读在Spring MVC 3.2中引入了异步请求处理支持<a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">的博客文章</a> 。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-exceptions"><a class="anchor" href="#mvc-ann-async-exceptions"></a>异常处理</h5>
<div class="paragraph">
<p>当您使用<code>DeferredResult</code> ，您可以选择是否拨打电话<code>setResult</code>要么<code>setErrorResult</code>有一个例外。在这两种情况下，Spring MVC都将请求分派回Servlet容器以完成处理。然后将其视为控制器方法返回了给定值，或者好像它产生了给定的异常。然后，该异常将通过常规的异常处理机制（例如，调用<code>@ExceptionHandler</code>方法）。</p>
</div>
<div class="paragraph">
<p>使用时<code>Callable</code> ，就会发生类似的处理逻辑，主要区别在于结果是从<code>Callable</code>否则会引发异常。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-interception"><a class="anchor" href="#mvc-ann-async-interception"></a>拦截</h5>
<div class="paragraph">
<p><code>HandlerInterceptor</code>实例可以是类型<code>AsyncHandlerInterceptor</code> ，以接收<code>afterConcurrentHandlingStarted</code>启动异步处理的初始请求的回调（而不是<code>postHandle</code>和<code>afterCompletion</code> ）。</p>
</div>
<div class="paragraph">
<p><code>HandlerInterceptor</code>实现也可以注册一个<code>CallableProcessingInterceptor</code>或一个<code>DeferredResultProcessingInterceptor</code> ，以便与异步请求的生命周期进行更深入的集成（例如，处理超时事件）。看到<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html"><code>AsyncHandlerInterceptor</code></a>更多细节。</p>
</div>
<div class="paragraph">
<p><code>DeferredResult</code>提供<code>onTimeout(Runnable)</code>和<code>onCompletion(Runnable)</code>回调。见的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">javadoc <code>DeferredResult</code></a>更多细节。 <code>Callable</code>可以代替<code>WebAsyncTask</code>公开了超时和完成回调的其他方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-vs-webflux"><a class="anchor" href="#mvc-ann-async-vs-webflux"></a>与WebFlux相比</h5>
<div class="paragraph">
<p>Servlet API最初是为通过Filter-Servlet链进行一次传递而构建的。Servlet 3.0中添加了异步请求处理，使应用程序可以退出Filter-Servlet链，但保留响应以进行进一步处理。Spring MVC异步支持围绕该机制构建。当控制器返回一个<code>DeferredResult</code> ，退出Filter-Servlet链，并释放Servlet容器线程。后来，当<code>DeferredResult</code>设置好了<code>ASYNC</code>进行了调度（到相同的URL），在此期间再次映射了控制器，但是，而不是调用它， <code>DeferredResult</code>使用该值（就像控制器返回它一样）来恢复处理。</p>
</div>
<div class="paragraph">
<p>相比之下，Spring WebFlux既不是基于Servlet API构建的，也不需要这种异步请求处理功能，因为它在设计上是异步的。异步处理已内置在所有框架协定中，并在请求处理的所有阶段得到内在支持。</p>
</div>
<div class="paragraph">
<p>从编程模型的角度来看，Spring MVC和Spring WebFlux都支持异步和响应<a href="#mvc-ann-async-reactive-types">类型</a>作为控制器方法中的返回值。Spring MVC甚至支持流式传输，包括反应性背压。但是，与WebFlux不同，WebFlux依赖于非阻塞I / O，并且每次写入都不需要额外的线程，因此对响应的单个写入仍然处于阻塞状态（并在单独的线程上执行）。</p>
</div>
<div class="paragraph">
<p>另一个基本区别是，Spring MVC在控制器方法参数中不支持异步或反应式类型（例如， <code>@RequestBody</code> ， <code>@RequestPart</code> ，以及其他），也没有对异步和反应式类型作为模型属性的任何显式支持。Spring WebFlux确实支持所有这些。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-http-streaming"><a class="anchor" href="#mvc-ann-async-http-streaming"></a> 1.6.4。HTTP流</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs-streaming">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以使用<code>DeferredResult</code>和<code>Callable</code>对于单个异步返回值。如果要产生多个异步值并将那些值写入响应，该怎么办？本节介绍如何执行此操作。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-objects"><a class="anchor" href="#mvc-ann-async-objects"></a>对象</h5>
<div class="paragraph">
<p>您可以使用<code>ResponseBodyEmitter</code>返回值以生成对象流，其中每个对象都使用<a href="integration.html#rest-message-conversion"><code>HttpMessageConverter</code></a>并写入响应，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/events")
public ResponseBodyEmitter handle() {
    ResponseBodyEmitter emitter = new ResponseBodyEmitter();
    // Save the emitter somewhere..
    return emitter;
}

// In some other thread
emitter.send("Hello once");

// and again later on
emitter.send("Hello again");

// and done at some point
emitter.complete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/events")
fun handle() = ResponseBodyEmitter().apply {
    // Save the emitter somewhere..
}

// In some other thread
emitter.send("Hello once")

// and again later on
emitter.send("Hello again")

// and done at some point
emitter.complete()</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>ResponseBodyEmitter</code>作为一个身体<code>ResponseEntity</code> ，让您自定义响应的状态和标题。</p>
</div>
<div class="paragraph">
<p>当一个<code>emitter</code>抛出<code>IOException</code> （例如，如果远程客户端消失了），应用程序不负责清理连接，因此不应调用<code>emitter.complete</code>要么<code>emitter.completeWithError</code> 。相反，Servlet容器会自动启动<code>AsyncListener</code>错误通知，其中Spring MVC发出<code>completeWithError</code>呼叫。反过来，此调用执行一个决赛<code>ASYNC</code>分派给应用程序，在此期间Spring MVC调用配置的异常解析器并完成请求。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-sse"><a class="anchor" href="#mvc-ann-async-sse"></a>上证所</h5>
<div class="paragraph">
<p><code>SseEmitter</code> （的子类<code>ResponseBodyEmitter</code> ）提供了对<a href="https://www.w3.org/TR/eventsource/">服务器发送事件的</a>支持，其中从服务器<a href="https://www.w3.org/TR/eventsource/">发送的事件</a>是根据W3C SSE规范进行格式化的。要从控制器生成SSE流，请返回<code>SseEmitter</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)
public SseEmitter handle() {
    SseEmitter emitter = new SseEmitter();
    // Save the emitter somewhere..
    return emitter;
}

// In some other thread
emitter.send("Hello once");

// and again later on
emitter.send("Hello again");

// and done at some point
emitter.complete();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/events", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
fun handle() = SseEmitter().apply {
    // Save the emitter somewhere..
}

// In some other thread
emitter.send("Hello once")

// and again later on
emitter.send("Hello again")

// and done at some point
emitter.complete()</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然SSE是流式传输到浏览器的主要选项，但请注意Internet Explorer不支持服务器发送事件。考虑将Spring的<a href="#websocket">WebSocket消息</a>与针对广泛浏览器的<a href="#websocket-fallback">SockJS后备</a>传输（包括SSE）一起使用。</p>
</div>
<div class="paragraph">
<p>另请参阅<a href="#mvc-ann-async-objects">上一节</a>以获取有关异常处理的注释。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-output-stream"><a class="anchor" href="#mvc-ann-async-output-stream"></a>原始数据</h5>
<div class="paragraph">
<p>有时，绕过消息转换并直接流向响应非常有用<code>OutputStream</code> （例如，用于文件下载）。您可以使用<code>StreamingResponseBody</code>这样做的返回值类型，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/download")
public StreamingResponseBody handle() {
    return new StreamingResponseBody() {
        @Override
        public void writeTo(OutputStream outputStream) throws IOException {
            // write...
        }
    };
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/download")
fun handle() = StreamingResponseBody {
    // write...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>StreamingResponseBody</code>作为一个身体<code>ResponseEntity</code>自定义响应的状态和标题。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-reactive-types"><a class="anchor" href="#mvc-ann-async-reactive-types"></a> 1.6.5。反应类型</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs-streaming">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC支持在控制器中使用反应式客户端库（另请参阅WebFlux部分中的<a href="web-reactive.html#webflux-reactive-libraries">反应式库</a> ）。这包括<code>WebClient</code>从<code>spring-webflux</code>以及其他数据，例如Spring Data反应数据存储库。在这种情况下，能够从控制器方法返回反应类型是很方便的。</p>
</div>
<div class="paragraph">
<p>反应性返回值的处理方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单值承诺适用于，类似于使用<code>DeferredResult</code> 。例子包括<code>Mono</code> （反应器）或<code>Single</code> （RxJava）。</p>
</li>
<li>
<p>具有流媒体类型（例如<code>application/stream+json</code>要么<code>text/event-stream</code> ）适用于，类似于使用<code>ResponseBodyEmitter</code>要么<code>SseEmitter</code> 。例子包括<code>Flux</code> （反应器）或<code>Observable</code> （RxJava）。申请也可以返回<code>Flux<ServerSentEvent></code>要么<code>Observable<ServerSentEvent></code> 。</p>
</li>
<li>
<p>具有任何其他媒体类型（例如<code>application/json</code> ）适用于，类似于使用<code>DeferredResult<List<?>></code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring MVC通过以下方式支持Reactor和RxJava： <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html"><code>ReactiveAdapterRegistry</code></a>从<code>spring-core</code> ，这使其可以适应多个反应式库。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了流式传输到响应，支持反应性背压，但是对响应的写仍然处于阻塞状态，并通过<a href="#mvc-ann-async-configuration-spring-mvc">配置的</a>在单独的线程上执行<code>TaskExecutor</code> ，以避免阻塞上游源（例如<code>Flux</code>从返回<code>WebClient</code> ）。默认， <code>SimpleAsyncTaskExecutor</code>用于阻塞写操作，但是在负载下不适合使用。如果计划使用响应类型进行流传输，则应使用<a href="#mvc-ann-async-configuration-spring-mvc">MVC配置</a>来配置任务执行程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-disconnects"><a class="anchor" href="#mvc-ann-async-disconnects"></a> 1.6.6。断开连接</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-codecs-streaming">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>当远程客户端离开时，Servlet API不提供任何通知。因此，在通过<a href="#mvc-ann-async-sse">SseEmitter</a>或<a href="#mvc-ann-async-reactive-types">反应性类型</a>流式传输到响应时，定期发送数据很重要，因为如果客户端断开连接，写入将失败。发送可以采取空（仅评论）SSE事件或另一端必须将其解释为心跳和忽略的任何其他数据的形式。</p>
</div>
<div class="paragraph">
<p>或者，考虑使用具有内置心跳机制的Web消息传递解决方案（例如，基于<a href="#websocket-stomp">WebSocket的STOMP</a>或具有<a href="#websocket-fallback">SockJS的</a> WebSocket）。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-ann-async-configuration"><a class="anchor" href="#mvc-ann-async-configuration"></a> 1.6.7。组态</h4>
<div class="paragraph">
<p><span class="small"><a href="#mvc-ann-async-vs-webflux">与WebFlux相比</a></span></p>
</div>
<div class="paragraph">
<p>必须在Servlet容器级别启用异步请求处理功能。MVC配置还为异步请求提供了多个选项。</p>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-configuration-servlet3"><a class="anchor" href="#mvc-ann-async-configuration-servlet3"></a> Servlet容器</h5>
<div class="paragraph">
<p>过滤器和Servlet声明有一个<code>asyncSupported</code>需要设置为<code>true</code>启用异步请求处理。此外，应声明过滤器映射以处理<code>ASYNC</code><code>javax.servlet.DispatchType</code> 。</p>
</div>
<div class="paragraph">
<p>在Java配置中，当您使用<code>AbstractAnnotationConfigDispatcherServletInitializer</code>初始化Servlet容器，这是自动完成的。</p>
</div>
<div class="paragraph">
<p>在<code>web.xml</code>配置，您可以添加<code><async-supported>true</async-supported></code>到<code>DispatcherServlet</code>并<code>Filter</code>声明并添加<code><dispatcher>ASYNC</dispatcher></code>过滤映射。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-ann-async-configuration-spring-mvc"><a class="anchor" href="#mvc-ann-async-configuration-spring-mvc"></a>春季MVC</h5>
<div class="paragraph">
<p>MVC配置公开了以下与异步请求处理相关的选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java配置：使用<code>configureAsyncSupport</code>回调<code>WebMvcConfigurer</code> 。</p>
</li>
<li>
<p>XML名称空间：使用<code><async-support></code>下的元素<code><mvc:annotation-driven></code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以配置以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>异步请求的默认超时值（如果未设置）取决于底层的Servlet容器（例如，在Tomcat上为10秒）。</p>
</li>
<li>
<p><code>AsyncTaskExecutor</code>用于使用<a href="#mvc-ann-async-reactive-types">响应类型</a>进行流式传输时阻止写入并执行<code>Callable</code>控制器方法返回的实例。如果您使用反应类型进行流式处理或具有返回的控制器方法，我们强烈建议配置此属性<code>Callable</code> ，因为默认情况下它是一个<code>SimpleAsyncTaskExecutor</code> 。</p>
</li>
<li>
<p><code>DeferredResultProcessingInterceptor</code>实现和<code>CallableProcessingInterceptor</code>实现。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，您还可以在<code>DeferredResult</code> ， 一种<code>ResponseBodyEmitter</code> ， 和<code>SseEmitter</code> 。为一个<code>Callable</code> ， 您可以使用<code>WebAsyncTask</code>提供超时值。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-cors"><a class="anchor" href="#mvc-cors"></a> 1.7。CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC使您可以处理CORS（跨源资源共享）。本节介绍如何执行此操作。</p>
</div>
<div class="sect3">
<h4 id="mvc-cors-intro"><a class="anchor" href="#mvc-cors-intro"></a> 1.7.1。介绍</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-intro">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>出于安全原因，浏览器禁止AJAX调用当前来源以外的资源。例如，您可以将您的银行帐户放在一个标签中，将evil.com放在另一个标签中。来自evil.com的脚本不应使用您的凭据向您的银行API发出AJAX请求，例如从您的帐户中提取资金！</p>
</div>
<div class="paragraph">
<p>跨域资源共享（CORS）是<a href="https://caniuse.com/#feat=cors">大多数浏览器</a>实现的<a href="https://www.w3.org/TR/cors/">W3C规范</a> ，可让您指定授权哪种类型的跨域请求，而不是使用基于IFRAME或JSONP的安全性较低且功能较弱的变通办法。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-processing"><a class="anchor" href="#mvc-cors-processing"></a> 1.7.2。处理中</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-processing">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>CORS规范区分飞行前，简单和实际请求。要了解CORS的工作原理，您可以阅读<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>以及其他内容，或者参阅规范以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>春季MVC <code>HandlerMapping</code>实现提供对CORS的内置支持。成功将请求映射到处理程序后， <code>HandlerMapping</code>实现检查给定请求和处理程序的CORS配置，并采取进一步的措施。飞行前请求直接处理，而简单和实际的CORS请求被拦截，验证并设置了必需的CORS响应标头。</p>
</div>
<div class="paragraph">
<p>为了启用跨域请求（即<code>Origin</code>标头存在并且与请求的主机不同），您需要具有一些显式声明的CORS配置。如果找不到匹配的CORS配置，则预检请求将被拒绝。没有将CORS标头添加到简单和实际CORS请求的响应中，因此，浏览器拒绝了它们。</p>
</div>
<div class="paragraph">
<p>每<code>HandlerMapping</code>可以使用基于URL模式的单独<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a> <code>CorsConfiguration</code>映射。在大多数情况下，应用程序使用MVC Java配置或XML名称空间声明此类映射，从而导致将单个全局映射传递给所有<code>HandlerMappping</code>实例。</p>
</div>
<div class="paragraph">
<p>您可以在以下位置组合全局CORS配置： <code>HandlerMapping</code>级别，以及更细粒度的处理程序级别的CORS配置。例如，带注释的控制器可以使用类或方法级别<code>@CrossOrigin</code>注释（其他处理程序可以实现<code>CorsConfigurationSource</code> ）。</p>
</div>
<div class="paragraph">
<p>组合全局和本地配置的规则通常是相加的，例如，所有全局和所有本地来源。对于那些只能接受单个值的属性（例如<code>allowCredentials</code>和<code>maxAge</code> ），则局部变量会覆盖全局值。看到<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a>更多细节。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要从源中了解更多信息或进行高级自定义，请查看后面的代码：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code> ，<code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-controller"><a class="anchor" href="#mvc-cors-controller"></a> 1.7.3。<code>@CrossOrigin</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-controller">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>注释启用带注释的控制器方法上的跨域请求，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    public Account retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public void remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
@RequestMapping("/account")
class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    fun retrieve(@PathVariable id: Long): Account {
        // ...
    }

    @DeleteMapping("/{id}")
    fun remove(@PathVariable id: Long) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>@CrossOrigin</code>允许：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p>控制器方法映射到的所有HTTP方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowedCredentials</code>默认情况下不会启用，因为这会建立一个信任级别，以公开敏感的用户特定信息（例如cookie和CSRF令牌），并且仅在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code>在类级别也受支持，并且被所有方法继承，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CrossOrigin(origins = "https://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @GetMapping("/{id}")
    public Account retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public void remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@CrossOrigin(origins = ["https://domain2.com"], maxAge = 3600)
@RestController
@RequestMapping("/account")
class AccountController {

    @GetMapping("/{id}")
    fun retrieve(@PathVariable id: Long): Account {
        // ...
    }

    @DeleteMapping("/{id}")
    fun remove(@PathVariable id: Long) {
        // ...
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>@CrossOrigin</code>在类级别和方法级别上，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin("https://domain2.com")
    @GetMapping("/{id}")
    public Account retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public void remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
class AccountController {

    @CrossOrigin("https://domain2.com")
    @GetMapping("/{id}")
    fun retrieve(@PathVariable id: Long): Account {
        // ...
    }

    @DeleteMapping("/{id}")
    fun remove(@PathVariable id: Long) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-global"><a class="anchor" href="#mvc-cors-global"></a> 1.7.4。全局配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-global">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>除了细粒度的控制器方法级别配置外，您可能还想定义一些全局CORS配置。您可以设置基于URL <code>CorsConfiguration</code>分别映射到任何<code>HandlerMapping</code> 。但是，大多数应用程序都使用MVC Java配置或MVC XML名称空间来执行此操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，全局配置启用以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有起源。</p>
</li>
<li>
<p>所有标题。</p>
</li>
<li>
<p><code>GET</code> ， <code>HEAD</code>和<code>POST</code>方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>allowedCredentials</code>默认情况下不会启用，因为这会建立一个信任级别，以公开敏感的用户特定信息（例如cookie和CSRF令牌），并且仅在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code>设置为30分钟。</p>
</div>
<div class="sect4">
<h5 id="mvc-cors-global-java"><a class="anchor" href="#mvc-cors-global-java"></a> Java配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-global">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>要在MVC Java配置中启用CORS，您可以使用<code>CorsRegistry</code>回调，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {

        registry.addMapping("/api/**")
            .allowedOrigins("https://domain2.com")
            .allowedMethods("PUT", "DELETE")
            .allowedHeaders("header1", "header2", "header3")
            .exposedHeaders("header1", "header2")
            .allowCredentials(true).maxAge(3600);

        // Add more mappings...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun addCorsMappings(registry: CorsRegistry) {

        registry.addMapping("/api/**")
                .allowedOrigins("https://domain2.com")
                .allowedMethods("PUT", "DELETE")
                .allowedHeaders("header1", "header2", "header3")
                .exposedHeaders("header1", "header2")
                .allowCredentials(true).maxAge(3600)

        // Add more mappings...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-cors-global-xml"><a class="anchor" href="#mvc-cors-global-xml"></a> XML配置</h5>
<div class="paragraph">
<p>要在XML名称空间中启用CORS，您可以使用<code><mvc:cors></code>元素，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:cors&gt;

    &lt;mvc:mapping path="/api/**"
        allowed-origins="https://domain1.com, https://domain2.com"
        allowed-methods="GET, PUT"
        allowed-headers="header1, header2, header3"
        exposed-headers="header1, header2" allow-credentials="true"
        max-age="123" /&gt;

    &lt;mvc:mapping path="/resources/**"
        allowed-origins="https://domain1.com" /&gt;

&lt;/mvc:cors&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-cors-filter"><a class="anchor" href="#mvc-cors-filter"></a> 1.7.5。CORS过滤器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-cors-webfilter">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以通过内置的方式应用CORS支持<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/filter/CorsFilter.html"><code>CorsFilter</code></a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您尝试使用<code>CorsFilter</code>使用Spring Security时，请记住Spring Security <a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">内置了</a>对CORS的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#cors">支持</a> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要配置过滤器，请传递<code>CorsConfigurationSource</code>到其构造函数，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">CorsConfiguration config = new CorsConfiguration();

// Possibly...
// config.applyPermitDefaultValues()

config.setAllowCredentials(true);
config.addAllowedOrigin("https://domain1.com");
config.addAllowedHeader("*");
config.addAllowedMethod("*");

UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration("/**", config);

CorsFilter filter = new CorsFilter(source);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">val config = CorsConfiguration()

// Possibly...
// config.applyPermitDefaultValues()

config.allowCredentials = true
config.addAllowedOrigin("https://domain1.com")
config.addAllowedHeader("*")
config.addAllowedMethod("*")

val source = UrlBasedCorsConfigurationSource()
source.registerCorsConfiguration("/**", config)

val filter = CorsFilter(source)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-web-security"><a class="anchor" href="#mvc-web-security"></a> 1.8。网络安全</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-web-security">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://projects.spring.io/spring-security/">Spring Security</a>项目提供了保护Web应用程序免受恶意利用的支持。请参阅Spring Security参考文档，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">Spring MVC安全性</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">Spring MVC测试支持</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF保护</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">安全响应标题</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://hdiv.org/">HDIV</a>是另一个与Spring MVC集成的Web安全框架。</p>
</div>
</div>
<div class="sect2">
<h3 id="mvc-caching"><a class="anchor" href="#mvc-caching"></a> 1.9。HTTP缓存</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕<code>Cache-Control</code>响应标头和随后的条件请求标头（例如<code>Last-Modified</code>和<code>ETag</code> ）。 <code>Cache-Control</code>为私有（例如浏览器）和公共（例如代理）缓存提供有关如何缓存和重用响应的建议。一个<code>ETag</code>标头用于发出条件请求，如果内容未更改，则可能导致没有主体的304（NOT_MODIFIED）。 <code>ETag</code>可以看成是<code>Last-Modified</code>标头。</p>
</div>
<div class="paragraph">
<p>本节描述了Spring Web MVC中与HTTP缓存相关的选项。</p>
</div>
<div class="sect3">
<h4 id="mvc-caching-cachecontrol"><a class="anchor" href="#mvc-caching-cachecontrol"></a> 1.9.1。<code>CacheControl</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching-cachecontrol">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>提供配置相关的设置支持<code>Cache-Control</code>标头，并在许多地方被接受为参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/WebContentInterceptor.html"><code>WebContentInterceptor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/support/WebContentGenerator.html"><code>WebContentGenerator</code></a></p>
</li>
<li>
<p><a href="#mvc-caching-etag-lastmodified">控制器</a></p>
</li>
<li>
<p><a href="#mvc-caching-static-resources">静态资源</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了所有可能的指令<code>Cache-Control</code>响应标头<code>CacheControl</code>类型采用面向用例的方法，重点关注常见方案：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Cache for an hour - "Cache-Control: max-age=3600"
CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

// Prevent caching - "Cache-Control: no-store"
CacheControl ccNoStore = CacheControl.noStore();

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">// Cache for an hour - "Cache-Control: max-age=3600"
val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

// Prevent caching - "Cache-Control: no-store"
val ccNoStore = CacheControl.noStore()

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebContentGenerator</code>也接受更简单<code>cachePeriod</code>属性（以秒为单位定义），其工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>-1</code>值不会产生<code>Cache-Control</code>响应头。</p>
</li>
<li>
<p>一种<code>0</code>值可防止通过使用<code>'Cache-Control: no-store'</code>指示。</p>
</li>
<li>
<p>一个<code>n > 0</code>值缓存给定的响应<code>n</code>通过使用<code>'Cache-Control: max-age=n'</code>指示。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="mvc-caching-etag-lastmodified"><a class="anchor" href="#mvc-caching-etag-lastmodified"></a> 1.9.2。控制器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching-etag-lastmodified">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以添加对HTTP缓存的显式支持。我们建议您这样做，因为<code>lastModified</code>要么<code>ETag</code>必须先计算资源的值，然后才能将其与条件请求标头进行比较。控制器可以添加一个<code>ETag</code>标头和<code>Cache-Control</code>设置为<code>ResponseEntity</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/book/{id}")
public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) {

    Book book = findBook(id);
    String version = book.getVersion();

    return ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
            .eTag(version) // lastModified is also available
            .body(book);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/book/{id}")
fun showBook(@PathVariable id: Long): ResponseEntity&lt;Book&gt; {

    val book = findBook(id);
    val version = book.getVersion()

    return ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
            .eTag(version) // lastModified is also available
            .body(book)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与条件请求标头的比较表明内容未更改，则前面的示例发送带有空主体的304（NOT_MODIFIED）响应。否则， <code>ETag</code>和<code>Cache-Control</code>标头添加到响应中。</p>
</div>
<div class="paragraph">
<p>您还可以在控制器中针对条件请求标头进行检查，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping
public String myHandleMethod(WebRequest webRequest, Model model) {

    long eTag = ... <i class="conum" data-value="1"></i><b>(1)</b>

    if (request.checkNotModified(eTag)) {
        return null; <i class="conum" data-value="2"></i><b>(2)</b>
    }

    model.addAttribute(...); <i class="conum" data-value="3"></i><b>(3)</b>
    return "myViewName";
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特定于应用程序的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）-无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>继续进行请求处理。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RequestMapping
fun myHandleMethod(webRequest: WebRequest, model: Model): String? {

    val eTag: Long = ... <i class="conum" data-value="1"></i><b>(1)</b>

    if (request.checkNotModified(eTag)) {
        return null <i class="conum" data-value="2"></i><b>(2)</b>
    }

    model[...] = ... <i class="conum" data-value="3"></i><b>(3)</b>
    return "myViewName"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>特定于应用程序的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）-无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>继续进行请求处理。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用三种变体检查条件请求<code>eTag</code>价值观<code>lastModified</code>值，或两者兼而有之。有条件的<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为304（NOT_MODIFIED）。有条件的<code>POST</code> ， <code>PUT</code>和<code>DELETE</code> ，您可以改为将响应设置为409（PRECONDITION_FAILED），以防止并发修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-caching-static-resources"><a class="anchor" href="#mvc-caching-static-resources"></a> 1.9.3。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-caching-static-resources">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您应该使用<code>Cache-Control</code>和条件响应标头以获得最佳性能。请参阅“配置<a href="#mvc-config-static-resources">静态资源</a> ”部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-httpcaching-shallowetag"><a class="anchor" href="#mvc-httpcaching-shallowetag"></a> 1.9.4。 <code>ETag</code> 过滤</h4>
<div class="paragraph">
<p>您可以使用<code>ShallowEtagHeaderFilter</code>添加“浅” <code>eTag</code>根据响应内容计算得出的值，从而节省带宽，但不节省CPU时间。请参阅<a href="#filters-shallow-etag">浅ETag</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-view"><a class="anchor" href="#mvc-view"></a> 1.10。查看技术</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring MVC中视图技术的使用是可插入的，无论您决定使用Thymeleaf，Groovy标记模板，JSP还是其他技术，主要取决于配置更改。本章介绍与Spring MVC集成的视图技术。我们假设您已经熟悉<a href="#mvc-viewresolver">View Resolution</a> 。</p>
</div>
<div class="sect3">
<h4 id="mvc-view-thymeleaf"><a class="anchor" href="#mvc-view-thymeleaf"></a> 1.10.1。胸腺</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-thymeleaf">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf是一种现代的服务器端Java模板引擎，它强调可以通过双击在浏览器中预览的自然HTML模板，这对于独立处理UI模板（例如，由设计人员）而无需进行非常有用的操作正在运行的服务器。如果要替换JSP，Thymeleaf提供了最广泛的功能集之一，以使这种过渡更加容易。Thymeleaf是积极开发和维护的。有关更完整的介绍，请参见<a href="https://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
</div>
<div class="paragraph">
<p>Thymeleaf与Spring MVC的集成由Thymeleaf项目管理。该配置涉及一些bean声明，例如<code>ServletContextTemplateResolver</code> ， <code>SpringTemplateEngine</code>和<code>ThymeleafViewResolver</code> 。有关更多详细信息，请参见<a href="https://www.thymeleaf.org/documentation.html">Thymeleaf + Spring</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-freemarker"><a class="anchor" href="#mvc-view-freemarker"></a> 1.10.2。FreeMarker</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-freemarker">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://freemarker.apache.org/">Apache FreeMarker</a>是一个模板引擎，用于生成从HTML到电子邮件等的任何类型的文本输出。Spring Framework 具有内置的集成，可以将Spring MVC与FreeMarker模板一起使用。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-freemarker-contextconfig"><a class="anchor" href="#mvc-view-freemarker-contextconfig"></a>查看配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-freemarker-contextconfig">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何将FreeMarker配置为一种视图技术：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    // Configure FreeMarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("/WEB-INF/freemarker");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.freeMarker()
    }

    // Configure FreeMarker...

    @Bean
    fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
        setTemplateLoaderPath("/WEB-INF/freemarker")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven/&gt;

&lt;mvc:view-resolvers&gt;
    &lt;mvc:freemarker/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;!-- Configure FreeMarker... --&gt;
&lt;mvc:freemarker-configurer&gt;
    &lt;mvc:template-loader-path location="/WEB-INF/freemarker"/&gt;
&lt;/mvc:freemarker-configurer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，您也可以声明<code>FreeMarkerConfigurer</code> Bean可以完全控制所有属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
    &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的模板需要存储在由<code>FreeMarkerConfigurer</code>如上例所示。根据上述配置，如果您的控制器返回的视图名称为<code>welcome</code> ，解析器会寻找<code>/WEB-INF/freemarker/welcome.ftl</code>模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-views-freemarker"><a class="anchor" href="#mvc-views-freemarker"></a> FreeMarker配置</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-views-freemarker">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以将FreeMarker的“设置”和“ SharedVariables”直接传递给FreeMarker <code>Configuration</code>对象（由Spring管理），方法是在<code>FreeMarkerConfigurer</code>豆。的<code>freemarkerSettings</code>财产需要<code>java.util.Properties</code>对象，以及<code>freemarkerVariables</code>财产需要<code>java.util.Map</code> 。以下示例显示了如何使用<code>FreeMarkerConfigurer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
    &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
    &lt;property name="freemarkerVariables"&gt;
        &lt;map&gt;
            &lt;entry key="xml_escape" value-ref="fmXmlEscape"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅FreeMarker文档，以获取适用于设置和变量的详细信息。 <code>Configuration</code>宾语。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-freemarker-forms"><a class="anchor" href="#mvc-view-freemarker-forms"></a>表格处理</h5>
<div class="paragraph">
<p>Spring提供了一个供JSP使用的标签库，其中包含一个<code><spring:bind/></code>元件。该元素主要允许表单显示来自表单支持对象的值，并显示来自表单验证失败的结果。 <code>Validator</code>在网络或业务层。Spring还支持FreeMarker中的相同功能，并带有用于生成表单输入元素本身的附加便利宏。</p>
</div>
<div class="sect5">
<h6 id="mvc-view-bind-macros"><a class="anchor" href="#mvc-view-bind-macros"></a>绑定宏</h6>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-bind-macros">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>标准宏集在<code>spring-webmvc.jar</code> FreeMarker的文件，因此它们始终可用于经过适当配置的应用程序。</p>
</div>
<div class="paragraph">
<p>Spring模板库中定义的一些宏被视为内部（私有）宏，但是在宏定义中不存在这种范围，使所有宏对调用代码和用户模板可见。以下各节仅关注您需要在模板中直接调用的宏。如果您想直接查看宏代码，则调用该文件<code>spring.ftl</code>并且在<code>org.springframework.web.servlet.view.freemarker</code>包。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-simple-binding"><a class="anchor" href="#mvc-view-simple-binding"></a>简单绑定</h6>
<div class="paragraph">
<p>在基于FreeMarker模板的HTML表单中，这些模板充当Spring MVC控制器的表单视图，您可以使用类似于下一个示例的代码绑定到字段值，并以与JSP等效的方式显示每个输入字段的错误消息。以下示例显示了<code>personForm</code>视图：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- FreeMarker macros have to be imported into a namespace.
    We strongly recommend sticking to 'spring'. --&gt;
&lt;#import "/spring.ftl" as spring/&gt;
&lt;html&gt;
    ...
    &lt;form action="" method="POST"&gt;
        Name:
        &lt;@spring.bind "personForm.name"/&gt;
        &lt;input type="text"
            name="${spring.status.expression}"
            value="${spring.status.value?html}"/&gt;&lt;br /&gt;
        &lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;${error}&lt;/b&gt; &lt;br /&gt; &lt;/#list&gt;
        &lt;br /&gt;
        ...
        &lt;input type="submit" value="submit"/&gt;
    &lt;/form&gt;
    ...
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><@spring.bind></code>需要一个'path'参数，该参数包含命令对象的名称（除非您在控制器配置中对其进行了更改，否则为'command'），后跟一个句点以及所需的命令对象上的字段名称绑定。您还可以使用嵌套字段，例如<code>command.address.street</code> 。的<code>bind</code>宏假定由设置的默认HTML转义行为<code>ServletContext</code>参数<code>defaultHtmlEscape</code>在<code>web.xml</code> 。</p>
</div>
<div class="paragraph">
<p>宏的另一种形式称为<code><@spring.bindEscaped></code>接受第二个参数，该参数明确指定在状态错误消息或值中应使用HTML转义。您可以将其设置为<code>true</code>要么<code>false</code>按要求。附加的表单处理宏可简化HTML转义的使用，并且应尽可能使用这些宏。下一节将对它们进行说明。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-views-form-macros"><a class="anchor" href="#mvc-views-form-macros"></a>输入宏</h6>
<div class="paragraph">
<p>FreeMarker的其他便利宏可简化绑定和表单生成（包括验证错误显示）。从来没有必要使用这些宏来生成表单输入字段，并且您可以将它们与简单的HTML混合或匹配，或者直接调用我们之前强调的Spring绑定宏。</p>
</div>
<div class="paragraph">
<p>下表列出了可用的宏，它们显示了FreeMarker模板（FTL）定义和每个参数采用的参数列表：</p>
</div>
<table id="views-macros-defs-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">表6。宏定义表</caption>
<colgroup>
<col style="width:75%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">巨集</th>
<th class="tableblock halign-left valign-top">FTL定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>message</code> （根据code参数从资源包中输出字符串）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.message code/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>messageText</code> （根据code参数从资源包中输出一个字符串，回退到默认参数的值）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.messageText code, text/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code> （使用应用程序的上下文根作为相对URL的前缀）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.url relativeUrl/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formInput</code> （用于收集用户输入的标准输入字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formInput path, attributes, fieldType/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formHiddenInput</code> （用于输入非用户输入的隐藏输入字段）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formHiddenInput path, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formPasswordInput</code> （用于收集密码的标准输入字段。请注意，此类型的字段中不会填充任何值。）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formPasswordInput path, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formTextarea</code> （大文本字段，用于收集长而自由格式的文本输入）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formTextarea path, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formSingleSelect</code> （选项的下拉框允许选择一个必需的值）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formSingleSelect path, options, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formMultiSelect</code> （选项列表框，允许用户选择0个或多个值）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formMultiSelect path, options, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formRadioButtons</code> （一组单选按钮，可从可用选项中进行单个选择）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formRadioButtons path, options separator, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formCheckboxes</code> （一组允许选择0个或多个值的复选框）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formCheckboxes path, options, separator, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>formCheckbox</code> （一个复选框）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.formCheckbox path, attributes/></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>showErrors</code> （简化了绑定字段验证错误的显示）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><@spring.showErrors separator, classOrStyle/></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在FreeMarker模板中， <code>formHiddenInput</code>和<code>formPasswordInput</code>实际上并不需要，因为您可以使用常规<code>formInput</code>宏，指定<code>hidden</code>要么<code>password</code>作为值<code>fieldType</code>参数。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以上任何宏的参数都具有一致的含义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path</code> ：要绑定的字段名称（即“ command.name”）</p>
</li>
<li>
<p><code>options</code> ： 一种<code>Map</code>可以在输入字段中选择的所有可用值中的一个。映射的键表示从表单回发并绑定到命令对象的值。针对键存储的地图对象是在表单上显示给用户的标签，并且可能与表单回发的相应值不同。通常，这种地图由控制器作为参考数据提供。您可以使用任何<code>Map</code>实施，取决于所需的行为。对于严格排序的地图，您可以使用<code>SortedMap</code> （比如一个<code>TreeMap</code> ） <code>Comparator</code>对于要按插入顺序返回值的任意Map，请使用<code>LinkedHashMap</code>或一个<code>LinkedMap</code>从<code>commons-collections</code> 。</p>
</li>
<li>
<p><code>separator</code> ：如果多个选项可用作离散元素（单选按钮或复选框），则用于分隔列表中每个字符的字符序列（例如<code><br></code> ）。</p>
</li>
<li>
<p><code>attributes</code> ：HTML标记本身包含的任意标记或文本的附加字符串。该字符串实际上是由宏回显的。例如，在<code>textarea</code>字段中，您可以提供属性（例如'rows =“ 5” cols =“ 60”'），也可以传递样式信息，例如'style =“ border：1px solid silver”。</p>
</li>
<li>
<p><code>classOrStyle</code> ： 为了<code>showErrors</code>宏，该CSS类的名称<code>span</code>包装每个错误使用的元素。如果没有提供任何信息（或该值为空），则将错误包裹在其中<code><b></b></code>标签。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下各节概述了宏的示例。</p>
</div>
<div class="sect6">
<h7 id="mvc-views-form-macros-input"><a class="anchor" href="#mvc-views-form-macros-input"></a>输入栏位</h7>
<div class="paragraph">
<p>的<code>formInput</code>宏需要<code>path</code>参数（ <code>command.name</code> ）和其他<code>attributes</code>参数（在后面的示例中为空）。该宏与所有其他表单生成宏一起，对path参数执行隐式Spring绑定。绑定保持有效，直到发生新的绑定，因此<code>showErrors</code>宏不需要再次传递path参数-它在最后创建绑定的字段上运行。</p>
</div>
<div class="paragraph">
<p>的<code>showErrors</code>宏使用分隔符参数（用于分隔给定字段上的多个错误的字符），并且还接受第二个参数-这次是类名称或样式属性。注意，FreeMarker可以为attributes参数指定默认值。以下示例显示了如何使用<code>formInput</code>和<code>showWErrors</code>巨集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;@spring.formInput "command.name"/&gt;
&lt;@spring.showErrors "&lt;br&gt;"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例显示表单片段的输出，生成名称字段，并在提交表单后在字段中没有值的情况下显示验证错误。验证通过Spring的Validation框架进行。</p>
</div>
<div class="paragraph">
<p>生成的HTML类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">Name:
&lt;input type="text" name="name" value=""&gt;
&lt;br&gt;
    &lt;b&gt;required&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>formTextarea</code>巨集的运作方式与<code>formInput</code>宏，并接受相同的参数列表。通常，第二个参数（ <code>attributes</code> ）用于传递样式信息或<code>rows</code>和<code>cols</code>的属性<code>textarea</code> 。</p>
</div>
</div>
<div class="sect6">
<h7 id="mvc-views-form-macros-select"><a class="anchor" href="#mvc-views-form-macros-select"></a>选择字段</h7>
<div class="paragraph">
<p>您可以使用四个选择字段宏在HTML表单中生成常见的UI值选择输入：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>formSingleSelect</code></p>
</li>
<li>
<p><code>formMultiSelect</code></p>
</li>
<li>
<p><code>formRadioButtons</code></p>
</li>
<li>
<p><code>formCheckboxes</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>四个宏都接受一个<code>Map</code>包含表单字段的值和与该值对应的标签的选项。值和标签可以相同。</p>
</div>
<div class="paragraph">
<p>下一个示例是FTL中的单选按钮。表单支持对象为此字段指定默认值“伦敦”，因此无需验证。呈现表单时，将在模型中以“ cityMap”为名称提供可供选择的整个城市列表作为参考数据。以下清单显示了示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">...
Town:
&lt;@spring.formRadioButtons "command.address.town", cityMap, ""/&gt;&lt;br&gt;&lt;br&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的清单呈现了一行单选按钮，其中每个对应一个值<code>cityMap</code> ，并使用的分隔符<code>""</code> 。没有提供其他属性（缺少该宏的最后一个参数）。的<code>cityMap</code>使用相同<code>String</code>映射中的每个键值对。地图的键是表单实际提交的形式<code>POST</code>请求参数。映射值是用户看到的标签。在前面的示例中，给定三个知名城市的列表以及表单支持对象中的默认值，HTML类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">Town:
&lt;input type="radio" name="address.town" value="London"&gt;London&lt;/input&gt;
&lt;input type="radio" name="address.town" value="Paris" checked="checked"&gt;Paris&lt;/input&gt;
&lt;input type="radio" name="address.town" value="New York"&gt;New York&lt;/input&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您的应用程序希望通过内部代码处理城市（例如），则可以使用合适的键创建代码地图，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected Map&lt;String, ?&gt; referenceData(HttpServletRequest request) throws Exception {
    Map&lt;String, String&gt; cityMap = new LinkedHashMap&lt;&gt;();
    cityMap.put("LDN", "London");
    cityMap.put("PRS", "Paris");
    cityMap.put("NYC", "New York");

    Map&lt;String, Object&gt; model = new HashMap&lt;&gt;();
    model.put("cityMap", cityMap);
    return model;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">protected fun referenceData(request: HttpServletRequest): Map&lt;String, *&gt; {
    val cityMap = linkedMapOf(
            "LDN" to "London",
            "PRS" to "Paris",
            "NYC" to "New York"
    )
    return hashMapOf("cityMap" to cityMap)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，该代码将生成输出，其中无线电值是相关代码，但是用户仍然可以看到更加用户友好的城市名称，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">Town:
&lt;input type="radio" name="address.town" value="LDN"&gt;London&lt;/input&gt;
&lt;input type="radio" name="address.town" value="PRS" checked="checked"&gt;Paris&lt;/input&gt;
&lt;input type="radio" name="address.town" value="NYC"&gt;New York&lt;/input&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-views-form-macros-html-escaping"><a class="anchor" href="#mvc-views-form-macros-html-escaping"></a> HTML转义</h6>
<div class="paragraph">
<p>前面描述的表单宏的默认用法会导致HTML元素符合HTML 4.01，并且使用您在HTML转义中定义的默认值<code>web.xml</code>文件，由Spring的绑定支持使用。要使元素符合XHTML或覆盖默认的HTML转义值，可以在模板（或模型中对模板可见的位置）中指定两个变量。在模板中指定它们的优点是，可以在稍后的模板处理中将它们更改为不同的值，以为表单中的不同字段提供不同的行为。</p>
</div>
<div class="paragraph">
<p>要为您的代码切换为符合XHTML，请指定值为<code>true</code>用于名为的模型或上下文变量<code>xhtmlCompliant</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">&lt;#-- for FreeMarker --&gt;
&lt;#assign xhtmlCompliant = true&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>处理完该指令后，Spring宏生成的任何元素现在都符合XHTML。</p>
</div>
<div class="paragraph">
<p>以类似的方式，您可以指定每个字段的HTML转义，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-jsp" data-lang="jsp">&lt;#-- until this point, default HTML escaping is used --&gt;

&lt;#assign htmlEscape = true&gt;
&lt;#-- next field will use HTML escaping --&gt;
&lt;@spring.formInput "command.name"/&gt;

&lt;#assign htmlEscape = false in spring&gt;
&lt;#-- all future fields will be bound with HTML escaping off --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-groovymarkup"><a class="anchor" href="#mvc-view-groovymarkup"></a> 1.10.3。Groovy标记</h4>
<div class="paragraph">
<p><a href="http://groovy-lang.org/templating.html#_the_markuptemplateengine">Groovy标记模板引擎</a>主要旨在生成类似XML的标记（XML，XHTML，HTML5等），但是您可以使用它来生成任何基于文本的内容。Spring Framework 具有内置的集成，可以将Spring MVC与Groovy标记一起使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy标记模板引擎需要Groovy 2.3.1+。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="mvc-view-groovymarkup-configuration"><a class="anchor" href="#mvc-view-groovymarkup-configuration"></a>组态</h5>
<div class="paragraph">
<p>以下示例显示了如何配置Groovy标记模板引擎：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.groovy();
    }

    // Configure the Groovy Markup Template Engine...

    @Bean
    public GroovyMarkupConfigurer groovyMarkupConfigurer() {
        GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();
        configurer.setResourceLoaderPath("/WEB-INF/");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.groovy()
    }

    // Configure the Groovy Markup Template Engine...

    @Bean
    fun groovyMarkupConfigurer() = GroovyMarkupConfigurer().apply {
        resourceLoaderPath = "/WEB-INF/"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven/&gt;

&lt;mvc:view-resolvers&gt;
    &lt;mvc:groovy/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;!-- Configure the Groovy Markup Template Engine... --&gt;
&lt;mvc:groovy-configurer resource-loader-path="/WEB-INF/"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-groovymarkup-example"><a class="anchor" href="#mvc-view-groovymarkup-example"></a>例</h5>
<div class="paragraph">
<p>与传统的模板引擎不同，Groovy标记依赖于使用构建器语法的DSL。以下示例显示了HTML页面的示例模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">yieldUnescaped '&lt;!DOCTYPE html&gt;'
html(lang:'en') {
    head {
        meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')
        title('My page')
    }
    body {
        p('This is an example of HTML contents')
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-script"><a class="anchor" href="#mvc-view-script"></a> 1.10.4。脚本视图</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-script">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework 具有内置的集成，可以将Spring MVC与可以在<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java脚本引擎之上运行的任何模板库一起使用。我们已经在不同的脚本引擎上测试了以下模板库：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">脚本库</th>
<th class="tableblock halign-left valign-top">脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://handlebarsjs.com/">车把</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">胡子</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://facebook.github.io/react/">反应</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://openjdk.java.net/projects/nashorn/">纳斯霍恩</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.stuartellis.name/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.jruby.org">红宝石</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">字符串模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.jython.org/">吉顿</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin脚本模板</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://kotlinlang.org/">Kotlin</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">集成任何其他脚本引擎的基本规则是，它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="mvc-view-script-dependencies"><a class="anchor" href="#mvc-view-script-dependencies"></a>要求</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-script-dependencies">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您需要在类路径上具有脚本引擎，其细节因脚本引擎而异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 8+随附了<a href="https://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript引擎。强烈建议使用可用的最新更新版本。</p>
</li>
<li>
<p>应该将<a href="https://www.jruby.org">JRuby</a>添加为对Ruby支持的依赖。</p>
</li>
<li>
<p>应该将<a href="https://www.jython.org">Jython</a>添加为对Python支持的依赖项。</p>
</li>
<li>
<p><code>org.jetbrains.kotlin:kotlin-script-util</code>依赖和<code>META-INF/services/javax.script.ScriptEngineFactory</code>包含<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>行应添加以支持Kotlin脚本。有关更多详细信息，请参<a href="https://github.com/sdeleuze/kotlin-script-templating">见此示例</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要具有脚本模板库。针对Javascript的一种方法是通过<a href="https://www.webjars.org/">WebJars</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-script-integrate"><a class="anchor" href="#mvc-view-script-integrate"></a>脚本模板</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-script-integrate">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以声明一个<code>ScriptTemplateConfigurer</code> bean来指定要使用的脚本引擎，要加载的脚本文件，调用呈现模板所需的函数等等。以下示例使用Mustache模板和Nashorn JavaScript引擎：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("mustache.js");
        configurer.setRenderObject("Mustache");
        configurer.setRenderFunction("render");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.scriptTemplate()
    }

    @Bean
    fun configurer() = ScriptTemplateConfigurer().apply {
        engineName = "nashorn"
        setScripts("mustache.js")
        renderObject = "Mustache"
        renderFunction = "render"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了XML中的相同排列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven/&gt;

&lt;mvc:view-resolvers&gt;
    &lt;mvc:script-template/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render"&gt;
    &lt;mvc:script location="mustache.js"/&gt;
&lt;/mvc:script-template-configurer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Java和XML配置，该控制器看起来没有什么不同，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class SampleController {

    @GetMapping("/sample")
    public String test(Model model) {
        model.addAttribute("title", "Sample title");
        model.addAttribute("body", "Sample body");
        return "template";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class SampleController {

    @GetMapping("/sample")
    fun test(model: Model): String {
        model["title"] = "Sample title"
        model["body"] = "Sample body"
        return "template"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了Mustache模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html" data-lang="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;{{title}}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;{{body}}&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下参数调用render函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code> ：模板内容</p>
</li>
<li>
<p><code>Map model</code> ：视图模型</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code> ： <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a>允许访问应用程序上下文，语言环境，模板加载器和URL（自5.0起）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code>与该签名本地兼容，因此您可以直接调用它。</p>
</div>
<div class="paragraph">
<p>如果您的模板技术需要一些自定义，则可以提供一个实现自定义渲染功能的脚本。例如， <a href="https://handlebarsjs.com">Handlerbars</a>需要使用它们之前编译模板和需要<a href="https://en.wikipedia.org/wiki/Polyfill">填充工具</a>来模拟浏览器的一些设施，不可用在服务器端脚本引擎。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");
        configurer.setRenderFunction("render");
        configurer.setSharedEngine(false);
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.scriptTemplate()
    }

    @Bean
    fun configurer() = ScriptTemplateConfigurer().apply {
        engineName = "nashorn"
        setScripts("polyfill.js", "handlebars.js", "render.js")
        renderFunction = "render"
        isSharedEngine = false
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置<code>sharedEngine</code>财产<code>false</code>当使用非线程安全的脚本引擎和不是为并发设计的模板库时，例如在Nashorn上运行的Handlebars或React，则需要使用。在这种情况下，由于<a href="https://bugs.openjdk.java.net/browse/JDK-8076099">此bug</a> ，需要Java SE 8 update 60，但通常建议在任何情况下都使用最新的Java SE修补程序版本。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code>仅定义<code>window</code>车把正常运行所需的对象，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var window = {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个基本<code>render.js</code>实现在使用模板之前先对其进行编译。生产就绪的实现还应该存储任何重用的缓存模板或预编译的模板。您可以在脚本方面进行操作（并处理所需的任何自定义，例如，管理模板引擎配置）。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">function render(template, model) {
    var compiledTemplate = Handlebars.compile(template);
    return compiledTemplate(model);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看Spring Framework单元测试， <a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script">Java</a>和<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script">资源</a> ，以获取更多配置示例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jsp"><a class="anchor" href="#mvc-view-jsp"></a> 1.10.5。JSP和JSTL</h4>
<div class="paragraph">
<p>Spring Framework 具有内置的集成，可以将Spring MVC与JSP和JSTL一起使用。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-resolver"><a class="anchor" href="#mvc-view-jsp-resolver"></a>查看解析器</h5>
<div class="paragraph">
<p>使用JSP开发时，可以声明一个<code>InternalResourceViewResolver</code>或一个<code>ResourceBundleViewResolver</code>豆。</p>
</div>
<div class="paragraph">
<p><code>ResourceBundleViewResolver</code>依靠属性文件来定义映射到类和URL的视图名称。用<code>ResourceBundleViewResolver</code> ，您可以仅使用一个解析器来混合不同类型的视图，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- the ResourceBundleViewResolver --&gt;
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;

# And a sample properties file is used (views.properties in WEB-INF/classes):
welcome.(class)=org.springframework.web.servlet.view.JstlView
welcome.url=/WEB-INF/jsp/welcome.jsp

productList.(class)=org.springframework.web.servlet.view.JstlView
productList.url=/WEB-INF/jsp/productlist.jsp</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>InternalResourceViewResolver</code>也可以用于JSP。最佳做法是，我们强烈建议您将JSP文件放置在<code>'WEB-INF'</code>目录，因此客户端无法直接访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
    &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
    &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-jstl"><a class="anchor" href="#mvc-view-jsp-jstl"></a> JSP与JSTL</h5>
<div class="paragraph">
<p>使用JSP标准标记库（JSTL）时，必须使用特殊的视图类，即<code>JstlView</code> ，因为JSTL需要一些准备工作，然后I18N功能才能正常工作。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-tags"><a class="anchor" href="#mvc-view-jsp-tags"></a> Spring的JSP标签库</h5>
<div class="paragraph">
<p>如前几章所述，Spring提供了请求参数到命令对象的数据绑定。为了促进结合这些数据绑定功能的JSP页面的开发，Spring提供了一些使事情变得更加容易的标记。所有Spring标记都具有HTML转义功能，以启用或禁用字符转义。</p>
</div>
<div class="paragraph">
<p>的<code>spring.tld</code>标签库描述符（TLD）包含在<code>spring-webmvc.jar</code> 。有关单个标签的全面参考，请浏览<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description">API参考</a>或查看标签库说明。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-jsp-formtaglib"><a class="anchor" href="#mvc-view-jsp-formtaglib"></a> Spring的表单标签库</h5>
<div class="paragraph">
<p>从2.0版开始，Spring使用JSP和Spring Web MVC提供了一套全面的数据绑定感知标签，用于处理表单元素。每个标签都支持其对应的HTML标签对等体的属性集，从而使标签熟悉且易于使用。标记生成的HTML符合HTML 4.01 / XHTML 1.0。</p>
</div>
<div class="paragraph">
<p>与其他表单/输入标签库不同，Spring的表单标签库与Spring Web MVC集成在一起，使标签可以访问命令对象和控制器处理的参考数据。正如我们在以下示例中所示，表单标签使JSP易于开发，读取和维护。</p>
</div>
<div class="paragraph">
<p>我们浏览一下表单标签，并查看一个如何使用每个标签的示例。我们包含了生成的HTML代码段，其中某些标记需要进一步的注释。</p>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-configuration"><a class="anchor" href="#mvc-view-jsp-formtaglib-configuration"></a>组态</h6>
<div class="paragraph">
<p>表单标签库捆绑在其中<code>spring-webmvc.jar</code> 。库描述符称为<code>spring-form.tld</code> 。</p>
</div>
<div class="paragraph">
<p>要使用此库中的标记，请在JSP页面顶部添加以下指令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>form</code>是您要用于此库中标签的标签名称前缀。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-formtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-formtag"></a>表单标签</h6>
<div class="paragraph">
<p>该标签呈现HTML'form'元素，并向内部标签公开绑定路径以进行绑定。它将命令对象放在<code>PageContext</code>以便可以通过内部标签访问命令对象。该库中的所有其他标签都是<code>form</code>标签。</p>
</div>
<div class="paragraph">
<p>假设我们有一个名为<code>User</code> 。它是具有以下属性的JavaBean <code>firstName</code>和<code>lastName</code> 。我们可以将其用作表单控制器的表单支持对象，该对象将返回<code>form.jsp</code> 。以下示例显示了什么<code>form.jsp</code>可能看起来像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="2"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>firstName</code>和<code>lastName</code>值是从放置在<code>PageContext</code>通过页面控制器。继续阅读以了解如何将内部标签与<code>form</code>标签。</p>
</div>
<div class="paragraph">
<p>下面的清单显示了生成的HTML，它看起来像标准格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form method="POST"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="firstName" type="text" value="Harry"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="lastName" type="text" value="Potter"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="2"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的JSP假定表单支持对象的变量名是<code>command</code> 。如果已将表单支持对象以另一个名称（肯定是最佳实践）放入模型中，则可以将表单绑定到命名变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form modelAttribute="user"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="2"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-inputtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-inputtag"></a>的<code>input</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>具有绑定值的元素和<code>type='text'</code>默认。有关此标签的示例，请参见<a href="#mvc-view-jsp-formtaglib-formtag">The Form标签</a> 。您还可以使用特定于HTML5的类型，例如<code>email</code> ， <code>tel</code> ， <code>date</code> ， 和别的。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-checkboxtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-checkboxtag"></a>的<code>checkbox</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>用<code>type</code>调成<code>checkbox</code> 。</p>
</div>
<div class="paragraph">
<p>假设我们<code>User</code>具有诸如订阅时事通讯和兴趣爱好之类的偏好。以下示例显示了<code>Preferences</code>类：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class Preferences {

    private boolean receiveNewsletter;
    private String[] interests;
    private String favouriteWord;

    public boolean isReceiveNewsletter() {
        return receiveNewsletter;
    }

    public void setReceiveNewsletter(boolean receiveNewsletter) {
        this.receiveNewsletter = receiveNewsletter;
    }

    public String[] getInterests() {
        return interests;
    }

    public void setInterests(String[] interests) {
        this.interests = interests;
    }

    public String getFavouriteWord() {
        return favouriteWord;
    }

    public void setFavouriteWord(String favouriteWord) {
        this.favouriteWord = favouriteWord;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class Preferences(
        var receiveNewsletter: Boolean,
        var interests: StringArray,
        var favouriteWord: String
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>相应的<code>form.jsp</code>然后可能类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;Subscribe to newsletter?:&lt;/td&gt;
            &lt;%-- Approach 1: Property is of type java.lang.Boolean --%&gt;
            &lt;td&gt;&lt;form:checkbox path="preferences.receiveNewsletter"/&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Interests:&lt;/td&gt;
            &lt;%-- Approach 2: Property is of an array or of type java.util.Collection --%&gt;
            &lt;td&gt;
                Quidditch: &lt;form:checkbox path="preferences.interests" value="Quidditch"/&gt;
                Herbology: &lt;form:checkbox path="preferences.interests" value="Herbology"/&gt;
                Defence Against the Dark Arts: &lt;form:checkbox path="preferences.interests" value="Defence Against the Dark Arts"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Favourite Word:&lt;/td&gt;
            &lt;%-- Approach 3: Property is of type java.lang.Object --%&gt;
            &lt;td&gt;
                Magic: &lt;form:checkbox path="preferences.favouriteWord" value="Magic"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有三种方法可以<code>checkbox</code>标签，它应该满足您所有复选框的需求。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方法一：当绑定值是类型时<code>java.lang.Boolean</code> ， <code>input(checkbox)</code>被标记为<code>checked</code>如果绑定值是<code>true</code> 。的<code>value</code>属性对应于的解析值<code>setValue(Object)</code>价值属性。</p>
</li>
<li>
<p>方法二：当绑定值是类型时<code>array</code>要么<code>java.util.Collection</code> ， <code>input(checkbox)</code>被标记为<code>checked</code>如果已配置<code>setValue(Object)</code>值存在于边界中<code>Collection</code> 。</p>
</li>
<li>
<p>方法三：对于任何其他绑定值类型， <code>input(checkbox)</code>被标记为<code>checked</code>如果已配置<code>setValue(Object)</code>等于界限值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，无论采用哪种方法，都会生成相同的HTML结构。以下HTML代码段定义了一些复选框：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Interests:&lt;/td&gt;
    &lt;td&gt;
        Quidditch: &lt;input name="preferences.interests" type="checkbox" value="Quidditch"/&gt;
        &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
        Herbology: &lt;input name="preferences.interests" type="checkbox" value="Herbology"/&gt;
        &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
        Defence Against the Dark Arts: &lt;input name="preferences.interests" type="checkbox" value="Defence Against the Dark Arts"/&gt;
        &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能不希望在每个复选框之后看到其他隐藏字段。如果未选中HTML页面中的复选框，则提交表单后，其值就不会作为HTTP请求参数的一部分发送到服务器，因此我们需要一种解决方法来使HTML中的这个问题生效，以使Spring表单数据绑定生效。的<code>checkbox</code>标记遵循现有的Spring约定，包括以下划线（ <code>_</code> ）的每个复选框。通过这样做，您可以有效地告诉Spring“复选框在表单中可见，并且我希望与表单数据绑定的对象能够反映复选框的状态，无论如何。”</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-checkboxestag"><a class="anchor" href="#mvc-view-jsp-formtaglib-checkboxestag"></a>的<code>checkboxes</code>标签</h6>
<div class="paragraph">
<p>此标记呈现多个HTML <code>input</code>带有<code>type</code>调成<code>checkbox</code> 。</p>
</div>
<div class="paragraph">
<p>本节以之前的示例为基础<code>checkbox</code>标签部分。有时，您希望不必在JSP页面中列出所有可能的爱好。您宁愿在运行时提供可用选项的列表，然后将其传递给标记。那是目的<code>checkboxes</code>标签。您可以传递<code>Array</code> ， 一种<code>List</code>或<code>Map</code>包含<code>items</code>属性。通常，bound属性是一个集合，因此它可以保存用户选择的多个值。以下示例显示了使用此标记的JSP：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;Interests:&lt;/td&gt;
            &lt;td&gt;
                &lt;%-- Property is of an array or of type java.util.Collection --%&gt;
                &lt;form:checkboxes path="preferences.interests" items="${interestList}"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>本示例假设<code>interestList</code>是一个<code>List</code>可用作模型属性，其中包含要从中选择的值的字符串。如果您使用<code>Map</code> ，将地图输入键用作值，并将地图输入的值用作要显示的标签。您还可以使用自定义对象，在其中可以通过使用提供值的属性名称<code>itemValue</code>和标签通过使用<code>itemLabel</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-radiobuttontag"><a class="anchor" href="#mvc-view-jsp-formtaglib-radiobuttontag"></a>的<code>radiobutton</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>元素与<code>type</code>调成<code>radio</code> 。</p>
</div>
<div class="paragraph">
<p>典型的用法模式涉及绑定到相同属性但值不同的多个标记实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Sex:&lt;/td&gt;
    &lt;td&gt;
        Male: &lt;form:radiobutton path="sex" value="M"/&gt; &lt;br/&gt;
        Female: &lt;form:radiobutton path="sex" value="F"/&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-radiobuttonstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-radiobuttonstag"></a>的<code>radiobuttons</code>标签</h6>
<div class="paragraph">
<p>此标记呈现多个HTML <code>input</code>与元素<code>type</code>调成<code>radio</code> 。</p>
</div>
<div class="paragraph">
<p>与<a href="#mvc-view-jsp-formtaglib-checkboxestag"><code>checkboxes</code> tag</a> ，您可能希望将可用选项作为运行时变量传递。为此，您可以使用<code>radiobuttons</code>标签。您传递了<code>Array</code> ， 一种<code>List</code>或<code>Map</code>包含<code>items</code>属性。如果您使用<code>Map</code> ，将地图输入键用作值，并将地图输入的值用作要显示的标签。您还可以使用自定义对象，在其中可以通过使用提供值的属性名称<code>itemValue</code>和标签通过使用<code>itemLabel</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Sex:&lt;/td&gt;
    &lt;td&gt;&lt;form:radiobuttons path="sex" items="${sexOptions}"/&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-passwordtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-passwordtag"></a>的<code>password</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>标签的类型设置为<code>password</code>与绑定值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Password:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:password path="password"/&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，默认情况下，不显示密码值。如果您确实希望显示密码值，则可以设置密码的值。 <code>showPassword</code>归因于<code>true</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Password:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:password path="password" value="^76525bvHGq" showPassword="true"/&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-selecttag"><a class="anchor" href="#mvc-view-jsp-formtaglib-selecttag"></a>的<code>select</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML“ select”元素。它支持将数据绑定到所选选项以及使用嵌套<code>option</code>和<code>options</code>标签。</p>
</div>
<div class="paragraph">
<p>假设一个<code>User</code>有一个技能列表。相应的HTML可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Skills:&lt;/td&gt;
    &lt;td&gt;&lt;form:select path="skills" items="${skills}"/&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>User’s</code>技能在“草药学”中，“技能”行的HTML来源可能如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Skills:&lt;/td&gt;
    &lt;td&gt;
        &lt;select name="skills" multiple="true"&gt;
            &lt;option value="Potions"&gt;Potions&lt;/option&gt;
            &lt;option value="Herbology" selected="selected"&gt;Herbology&lt;/option&gt;
            &lt;option value="Quidditch"&gt;Quidditch&lt;/option&gt;
        &lt;/select&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-optiontag"><a class="anchor" href="#mvc-view-jsp-formtaglib-optiontag"></a>的<code>option</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>option</code>元件。它设置<code>selected</code> ，基于绑定值。以下HTML显示了其典型输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;House:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:select path="house"&gt;
            &lt;form:option value="Gryffindor"/&gt;
            &lt;form:option value="Hufflepuff"/&gt;
            &lt;form:option value="Ravenclaw"/&gt;
            &lt;form:option value="Slytherin"/&gt;
        &lt;/form:select&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>User’s</code> house位于格兰芬多（Gryffindor），“房子”行的HTML源代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;House:&lt;/td&gt;
    &lt;td&gt;
        &lt;select name="house"&gt;
            &lt;option value="Gryffindor" selected="selected"&gt;Gryffindor&lt;/option&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            &lt;option value="Hufflepuff"&gt;Hufflepuff&lt;/option&gt;
            &lt;option value="Ravenclaw"&gt;Ravenclaw&lt;/option&gt;
            &lt;option value="Slytherin"&gt;Slytherin&lt;/option&gt;
        &lt;/select&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注意添加了一个<code>selected</code>属性。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-optionstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-optionstag"></a>的<code>options</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML列表<code>option</code>元素。它设置<code>selected</code>属性，基于绑定值。以下HTML显示了其典型输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Country:&lt;/td&gt;
    &lt;td&gt;
        &lt;form:select path="country"&gt;
            &lt;form:option value="-" label="--Please Select"/&gt;
            &lt;form:options items="${countryList}" itemValue="code" itemLabel="name"/&gt;
        &lt;/form:select&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>User</code>如果居住在英国，则“国家/地区”行的HTML来源如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Country:&lt;/td&gt;
    &lt;td&gt;
        &lt;select name="country"&gt;
            &lt;option value="-"&gt;--Please Select&lt;/option&gt;
            &lt;option value="AT"&gt;Austria&lt;/option&gt;
            &lt;option value="UK" selected="selected"&gt;United Kingdom&lt;/option&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            &lt;option value="US"&gt;United States&lt;/option&gt;
        &lt;/select&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>注意添加了一个<code>selected</code>属性。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如前面的示例所示， <code>option</code>用<code>options</code>标记生成相同的标准HTML，但是允许您在JSP中显式指定一个仅用于显示（它所属的位置）的值，例如示例中的默认字符串：“-Please Select”。</p>
</div>
<div class="paragraph">
<p>的<code>items</code>属性通常由项对象的集合或数组填充。
<code>itemValue</code>和<code>itemLabel</code>如果指定，请参考那些项目对象的bean属性。否则，项目对象本身将变成字符串。或者，您可以指定一个<code>Map</code>项，在这种情况下，映射键将解释为选项值，并且映射值对应于选项标签。如果<code>itemValue</code>要么<code>itemLabel</code> （或两者）碰巧也被指定了，item value属性应用于地图键，item label属性应用于地图值。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-textareatag"><a class="anchor" href="#mvc-view-jsp-formtaglib-textareatag"></a>的<code>textarea</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>textarea</code>元件。以下HTML显示了其典型输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;tr&gt;
    &lt;td&gt;Notes:&lt;/td&gt;
    &lt;td&gt;&lt;form:textarea path="notes" rows="3" cols="20"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;form:errors path="notes"/&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-hiddeninputtag"><a class="anchor" href="#mvc-view-jsp-formtaglib-hiddeninputtag"></a>的<code>hidden</code>标签</h6>
<div class="paragraph">
<p>此标记呈现HTML <code>input</code>用<code>type</code>调成<code>hidden</code>与绑定值。要提交未绑定的隐藏值，请使用HTML <code>input</code>用<code>type</code>调成<code>hidden</code> 。以下HTML显示了其典型输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:hidden path="house"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们选择提交<code>house</code>值作为隐藏值，HTML将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;input name="house" type="hidden" value="Gryffindor"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-errorstag"><a class="anchor" href="#mvc-view-jsp-formtaglib-errorstag"></a>的<code>errors</code>标签</h6>
<div class="paragraph">
<p>此标记在HTML中呈现字段错误<code>span</code>元件。它提供对在控制器中创建的错误或由与控制器关联的任何验证程序创建的错误的访问。</p>
</div>
<div class="paragraph">
<p>假设我们要显示所有错误消息<code>firstName</code>和<code>lastName</code>字段，一旦我们提交表格。我们有一个验证器，用于<code>User</code>类称为<code>UserValidator</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class UserValidator implements Validator {

    public boolean supports(Class candidate) {
        return User.class.isAssignableFrom(candidate);
    }

    public void validate(Object obj, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class UserValidator : Validator {

    override fun supports(candidate: Class&lt;*&gt;): Boolean {
        return User::class.java.isAssignableFrom(candidate)
    }

    override fun validate(obj: Any, errors: Errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.")
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>form.jsp</code>可能如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
            &lt;%-- Show errors for firstName field --%&gt;
            &lt;td&gt;&lt;form:errors path="firstName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
            &lt;%-- Show errors for lastName field --%&gt;
            &lt;td&gt;&lt;form:errors path="lastName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们在表单中提交带有空值的表单<code>firstName</code>和<code>lastName</code>字段，HTML将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form method="POST"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
            &lt;%-- Associated errors to firstName field displayed --%&gt;
            &lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
            &lt;%-- Associated errors to lastName field displayed --%&gt;
            &lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们要显示给定页面的整个错误列表怎么办？下一个示例显示<code>errors</code>标签还支持一些基本的通配符功能。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>path="*"</code> ：显示所有错误。</p>
</li>
<li>
<p><code>path="lastName"</code> ：显示与<code>lastName</code>领域。</p>
</li>
<li>
<p>如果<code>path</code>省略，仅显示对象错误。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例在页面顶部显示错误列表，然后在字段旁边显示特定于字段的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form&gt;
    &lt;form:errors path="*" cssClass="errorBox"/&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="firstName"/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;form:errors path="firstName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;form:input path="lastName"/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;form:errors path="lastName"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTML将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form method="POST"&gt;
    &lt;span name="*.errors" class="errorBox"&gt;Field is required.&lt;br/&gt;Field is required.&lt;/span&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;

        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
            &lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="3"&gt;
                &lt;input type="submit" value="Save Changes"/&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>spring-form.tld</code>标签库描述符（TLD）包含在<code>spring-webmvc.jar</code> 。有关单个标签的全面参考，请浏览<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#package.description">API参考</a>或查看标签库说明。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-rest-method-conversion"><a class="anchor" href="#mvc-rest-method-conversion"></a> HTTP方法转换</h6>
<div class="paragraph">
<p>REST的一个关键原则是使用“统一接口”。这意味着可以使用相同的四种HTTP方法（GET，PUT，POST和DELETE）来操纵所有资源（URL）。对于每种方法，HTTP规范都定义了确切的语义。例如，GET应该始终是安全的操作，这意味着它没有副作用，而PUT或DELETE应该是幂等的，这意味着您可以一遍又一遍地重复这些操作，但是最终结果应该相同。虽然HTTP定义了这四种方法，但HTML仅支持两种：GET和POST。幸运的是，有两种可能的解决方法：您可以使用JavaScript进行PUT或DELETE，或者可以使用“ real”方法作为附加参数（在HTML表单中建模为隐藏的输入字段）进行POST。春天的<code>HiddenHttpMethodFilter</code>使用后一种技巧。该过滤器是一个普通的Servlet过滤器，因此，它可以与任何Web框架（不仅仅是Spring MVC）结合使用。将此过滤器添加到您的web.xml，然后将POST与隐藏<code>method</code>参数转换为相应的HTTP方法请求。</p>
</div>
<div class="paragraph">
<p>为了支持HTTP方法转换，Spring MVC表单标签已更新为支持设置HTTP方法。例如，以下代码片段来自“宠物诊所”样本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;form:form method="delete"&gt;
    &lt;p class="submit"&gt;&lt;input type="submit" value="Delete Pet"/&gt;&lt;/p&gt;
&lt;/form:form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例执行HTTP POST，并将“真实” DELETE方法隐藏在请求参数后面。它由<code>HiddenHttpMethodFilter</code> ，它在web.xml中定义，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;servlet-name&gt;petclinic&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了对应的<code>@Controller</code>方法：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping(method = RequestMethod.DELETE)
public String deletePet(@PathVariable int ownerId, @PathVariable int petId) {
    this.clinic.deletePet(petId);
    return "redirect:/owners/" + ownerId;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@RequestMapping(method = [RequestMethod.DELETE])
fun deletePet(@PathVariable ownerId: Int, @PathVariable petId: Int): String {
    clinic.deletePet(petId)
    return "redirect:/owners/$ownerId"
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-jsp-formtaglib-html5"><a class="anchor" href="#mvc-view-jsp-formtaglib-html5"></a> HTML5标签</h6>
<div class="paragraph">
<p>Spring表单标签库允许输入动态属性，这意味着您可以输入任何HTML5特定的属性。</p>
</div>
<div class="paragraph">
<p>表格<code>input</code>标签支持输入非类型属性<code>text</code> 。这旨在允许呈现新的HTML5特定输入类型，例如<code>email</code> ， <code>date</code> ， <code>range</code> ， 和别的。注意输入<code>type='text'</code>不需要，因为<code>text</code>是默认类型。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-tiles"><a class="anchor" href="#mvc-view-tiles"></a> 1.10.6。瓷砖</h4>
<div class="paragraph">
<p>您可以像使用其他视图技术一样，将Tiles集成到使用Spring的Web应用程序中。本节以广泛的方式描述如何执行此操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本节重点介绍Spring对Tiles版本3的支持。 <code>org.springframework.web.servlet.view.tiles3</code>包。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="mvc-view-tiles-dependencies"><a class="anchor" href="#mvc-view-tiles-dependencies"></a>依存关系</h5>
<div class="paragraph">
<p>为了能够使用Tiles，您必须在Tiles 3.0.1或更高版本上添加一个依赖项，并将<a href="https://tiles.apache.org/framework/dependency-management.html">其传递依赖项添加</a>到您的项目中。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-tiles-integrate"><a class="anchor" href="#mvc-view-tiles-integrate"></a>组态</h5>
<div class="paragraph">
<p>为了能够使用Tiles，您必须使用包含定义的文件对其进行配置（有关定义和其他Tiles概念的基本信息，请参见<a href="https://tiles.apache.org" class="bare">https://tiles.apache.org</a> ）。在春季，可以通过使用<code>TilesConfigurer</code> 。下面的例子<code>ApplicationContext</code>配置显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例定义了五个包含定义的文件。这些文件都位于<code>WEB-INF/defs</code>目录。在初始化<code>WebApplicationContext</code> ，将加载文件，并初始化定义工厂。完成之后，定义文件中包含的Tiles可以用作Spring Web应用程序中的视图。要使用视图，您必须具有<code>ViewResolver</code>与Spring使用的任何其他视图技术一样。您可以使用两种实现方式之一， <code>UrlBasedViewResolver</code>和<code>ResourceBundleViewResolver</code> 。</p>
</div>
<div class="paragraph">
<p>您可以通过添加下划线然后添加语言环境来指定特定于语言环境的Tiles定义，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/defs/tiles.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/tiles_fr_FR.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用上述配置， <code>tiles_fr_FR.xml</code>用于与<code>fr_FR</code>语言环境，以及<code>tiles.xml</code>默认情况下使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于下划线用于指示语言环境，因此建议不要在图块定义的文件名中使用下划线。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="mvc-view-tiles-url"><a class="anchor" href="#mvc-view-tiles-url"></a><code>UrlBasedViewResolver</code></h6>
<div class="paragraph">
<p>的<code>UrlBasedViewResolver</code>实例化给定<code>viewClass</code>对于每个视图，它都必须解决。以下bean定义了一个<code>UrlBasedViewResolver</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-tiles-resource"><a class="anchor" href="#mvc-view-tiles-resource"></a><code>ResourceBundleViewResolver</code></h6>
<div class="paragraph">
<p>的<code>ResourceBundleViewResolver</code>必须提供一个属性文件，其中包含解析程序可以使用的视图名称和视图类。以下示例显示了针对<code>ResourceBundleViewResolver</code>以及相应的视图名称和视图类（摘自“宠物诊所”样本）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    ...
    welcomeView.(class)=org.springframework.web.servlet.view.tiles3.TilesView
    welcomeView.url=welcome (this is the name of a Tiles definition)

    vetsView.(class)=org.springframework.web.servlet.view.tiles3.TilesView
    vetsView.url=vetsView (again, this is the name of a Tiles definition)

    findOwnersForm.(class)=org.springframework.web.servlet.view.JstlView
    findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp
    ...</pre>
</div>
</div>
<div class="paragraph">
<p>当您使用<code>ResourceBundleViewResolver</code> ，您可以轻松地混合使用不同的视图技术。</p>
</div>
<div class="paragraph">
<p>请注意<code>TilesView</code>该类支持JSTL（JSP标准标记库）。</p>
</div>
</div>
<div class="sect5">
<h6 id="mvc-view-tiles-preparer"><a class="anchor" href="#mvc-view-tiles-preparer"></a><code>SimpleSpringPreparerFactory</code>和<code>SpringBeanPreparerFactory</code></h6>
<div class="paragraph">
<p>作为一项高级功能，Spring还支持两个特殊的图块<code>PreparerFactory</code>实现。有关如何使用的详细信息，请参见Tiles文档<code>ViewPreparer</code> Tiles定义文件中的引用。</p>
</div>
<div class="paragraph">
<p>您可以指定<code>SimpleSpringPreparerFactory</code>自动接线<code>ViewPreparer</code>基于指定的准备器类的实例，应用Spring的容器回调以及应用配置的Spring BeanPostProcessor。如果已激活Spring的上下文范围注释配置，则在<code>ViewPreparer</code>类会自动检测并应用。请注意，这需要Tiles定义文件中的preparer类作为默认值。 <code>PreparerFactory</code>做。</p>
</div>
<div class="paragraph">
<p>您可以指定<code>SpringBeanPreparerFactory</code>可以对指定的准备程序名称（而不是类）进行操作，从而从DispatcherServlet的应用程序上下文中获取相应的Spring bean。在这种情况下，完整的bean创建过程由Spring应用程序上下文控制，从而允许使用显式依赖项注入配置，作用域bean等。注意，您需要为每个准备器名称定义一个Spring bean定义（在Tiles定义中使用）。以下示例显示了如何定义<code>SpringBeanPreparerFactory</code>物业<code>TilesConfigurer</code>豆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer"&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;

    &lt;!-- resolving preparer names as Spring bean definition names --&gt;
    &lt;property name="preparerFactoryClass"
            value="org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory"/&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-feeds"><a class="anchor" href="#mvc-view-feeds"></a> 1.10.7。RSS和Atom</h4>
<div class="paragraph">
<p>都<code>AbstractAtomFeedView</code>和<code>AbstractRssFeedView</code>从继承<code>AbstractFeedView</code>基本类，分别用于提供Atom和RSS Feed视图。它们基于<a href="https://rometools.github.io/rome/">ROME</a>项目，位于软件包中<code>org.springframework.web.servlet.view.feed</code> 。</p>
</div>
<div class="paragraph">
<p><code>AbstractAtomFeedView</code>要求您实施<code>buildFeedEntries()</code>方法，并可以选择覆盖<code>buildFeedMetadata()</code>方法（默认实现为空）。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SampleContentAtomView extends AbstractAtomFeedView {

    @Override
    protected void buildFeedMetadata(Map&lt;String, Object&gt; model,
            Feed feed, HttpServletRequest request) {
        // implementation omitted
    }

    @Override
    protected List&lt;Entry&gt; buildFeedEntries(Map&lt;String, Object&gt; model,
            HttpServletRequest request, HttpServletResponse response) throws Exception {
        // implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SampleContentAtomView : AbstractAtomFeedView() {

    override fun buildFeedMetadata(model: Map&lt;String, Any&gt;,
            feed: Feed, request: HttpServletRequest) {
        // implementation omitted
    }

    override fun buildFeedEntries(model: Map&lt;String, Any&gt;,
            request: HttpServletRequest, response: HttpServletResponse): List&lt;Entry&gt; {
        // implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似的要求也适用于实施<code>AbstractRssFeedView</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SampleContentRssView extends AbstractRssFeedView {

    @Override
    protected void buildFeedMetadata(Map&lt;String, Object&gt; model,
            Channel feed, HttpServletRequest request) {
        // implementation omitted
    }

    @Override
    protected List&lt;Item&gt; buildFeedItems(Map&lt;String, Object&gt; model,
            HttpServletRequest request, HttpServletResponse response) throws Exception {
        // implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class SampleContentRssView : AbstractRssFeedView() {

    override fun buildFeedMetadata(model: Map&lt;String, Any&gt;,
                                feed: Channel, request: HttpServletRequest) {
        // implementation omitted
    }

    override fun buildFeedItems(model: Map&lt;String, Any&gt;,
            request: HttpServletRequest, response: HttpServletResponse): List&lt;Item&gt; {
        // implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>buildFeedItems()</code>和<code>buildFeedEntries()</code>方法需要传入HTTP请求，以防您需要访问区域设置。仅针对Cookie或其他HTTP标头的设置传入HTTP响应。方法返回后，提要将自动写入响应对象。</p>
</div>
<div class="paragraph">
<p>有关创建Atom视图的示例，请参阅Alef Arendsen的Spring Team Blog <a href="https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support">条目</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-document"><a class="anchor" href="#mvc-view-document"></a> 1.10.8。PDF和Excel</h4>
<div class="paragraph">
<p>Spring提供了返回HTML以外的输出的方法，包括PDF和Excel电子表格。本节介绍如何使用这些功能。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-document-intro"><a class="anchor" href="#mvc-view-document-intro"></a>文档视图简介</h5>
<div class="paragraph">
<p>HTML页面并非始终是用户查看模型输出的最佳方法，而Spring使从模型数据动态生成PDF文档或Excel电子表格变得简单。该文档是视图，并从服务器以正确的内容类型进行流传输，以（希望）使客户端PC能够运行其电子表格或PDF查看器应用程序作为响应。</p>
</div>
<div class="paragraph">
<p>为了使用Excel视图，您需要将Apache POI库添加到您的类路径中。为了生成PDF，您需要添加（最好是）OpenPDF库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果可能，您应该使用基础文档生成库的最新版本。特别是，我们强烈建议您使用OpenPDF（例如，OpenPDF 1.2.12）而不是过时的原始iText 2.1.7，因为OpenPDF会得到积极维护并修复了不可信任PDF内容的重要漏洞。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-document-pdf"><a class="anchor" href="#mvc-view-document-pdf"></a> PDF检视</h5>
<div class="paragraph">
<p>单词列表的简单PDF视图可以扩展<code>org.springframework.web.servlet.view.document.AbstractPdfView</code>并实施<code>buildPdfDocument()</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PdfWordList extends AbstractPdfView {

    protected void buildPdfDocument(Map&lt;String, Object&gt; model, Document doc, PdfWriter writer,
            HttpServletRequest request, HttpServletResponse response) throws Exception {

        List&lt;String&gt; words = (List&lt;String&gt;) model.get("wordList");
        for (String word : words) {
            doc.add(new Paragraph(word));
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">class PdfWordList : AbstractPdfView() {

    override fun buildPdfDocument(model: Map&lt;String, Any&gt;, doc: Document, writer: PdfWriter,
            request: HttpServletRequest, response: HttpServletResponse) {

        val words = model["wordList"] as List&lt;String&gt;
        for (word in words) {
            doc.add(Paragraph(word))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>控制器可以从外部视图定义（按名称引用）或以<code>View</code>处理程序方法中的实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-document-excel"><a class="anchor" href="#mvc-view-document-excel"></a> Excel视图</h5>
<div class="paragraph">
<p>从Spring Framework 4.2开始， <code>org.springframework.web.servlet.view.document.AbstractXlsView</code>作为Excel视图的基类提供。它基于Apache POI，带有专门的子类（ <code>AbstractXlsxView</code>和<code>AbstractXlsxStreamingView</code> ）取代了过时的<code>AbstractExcelView</code>类。</p>
</div>
<div class="paragraph">
<p>编程模型类似于<code>AbstractPdfView</code> ，带有<code>buildExcelDocument()</code>作为中央模板方法，控制器可以从外部定义（按名称）或以<code>View</code>处理程序方法中的实例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-jackson"><a class="anchor" href="#mvc-view-jackson"></a> 1.10.9。杰克逊</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-httpmessagewriter">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring提供了对Jackson JSON库的支持。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-json-mapping"><a class="anchor" href="#mvc-view-json-mapping"></a>基于Jackson的JSON MVC视图</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-httpmessagewriter">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>的<code>MappingJackson2JsonView</code>使用杰克逊图书馆的<code>ObjectMapper</code>将响应内容呈现为JSON。默认情况下，模型映射的全部内容（特定于框架的类除外）均编码为JSON。对于需要过滤地图内容的情况，您可以使用来指定一组特定的模型属性进行编码<code>modelKeys</code>属性。您也可以使用<code>extractValueFromSingleKeyModel</code>属性，以便直接提取和序列化单键模型中的值，而不是将其作为模型属性的映射。</p>
</div>
<div class="paragraph">
<p>您可以根据需要使用Jackson提供的注释来自定义JSON映射。当您需要进一步控制时，可以添加自定义<code>ObjectMapper</code>通过<code>ObjectMapper</code>属性，用于需要为特定类型提供自定义JSON序列化器和反序列化器的情况。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-xml-mapping"><a class="anchor" href="#mvc-view-xml-mapping"></a>基于Jackson的XML视图</h5>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-view-httpmessagewriter">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>MappingJackson2XmlView</code>使用<a href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML扩展名的</a> <code>XmlMapper</code>将响应内容呈现为XML。如果模型包含多个条目，则应使用来显式设置要序列化的对象。 <code>modelKey</code> bean属性。如果模型包含单个条目，则会自动序列化。</p>
</div>
<div class="paragraph">
<p>您可以根据需要使用JAXB或Jackson提供的注释自定义XML映射。当您需要进一步控制时，可以添加自定义<code>XmlMapper</code>通过<code>ObjectMapper</code>属性，对于自定义XML的情况，您需要为特定类型提供序列化器和反序列化器。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xml-marshalling"><a class="anchor" href="#mvc-view-xml-marshalling"></a> 1.10.10。XML编组</h4>
<div class="paragraph">
<p>的<code>MarshallingView</code>使用XML <code>Marshaller</code> （在<code>org.springframework.oxm</code>包）以将响应内容呈现为XML。您可以使用以下命令显式设置要编组的对象<code>MarshallingView</code>实例的<code>modelKey</code> bean属性。另外，视图还会迭代所有模型属性，并封送受支持的第一个类型<code>Marshaller</code> 。有关功能的更多信息，请参见<code>org.springframework.oxm</code>软件包，请参见<a href="data-access.html#oxm">使用O / X映射器编组XML</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-view-xslt"><a class="anchor" href="#mvc-view-xslt"></a> 1.10.11。XSLT视图</h4>
<div class="paragraph">
<p>XSLT是XML的一种转换语言，在Web应用程序中作为一种视图技术而流行。如果您的应用程序自然处理XML，或者您的模型可以轻松转换为XML，那么XSLT可以作为视图技术的不错选择。下一节说明如何将XML文档生成为模型数据，并在Spring Web MVC应用程序中使用XSLT对其进行转换。</p>
</div>
<div class="paragraph">
<p>这个例子是一个普通的Spring应用程序，它在<code>Controller</code>并将它们添加到模型图。返回该地图以及XSLT视图的视图名称。有关Spring Web MVC的详细信息，请参见带<a href="#mvc-controller">注释的控制器</a> 。 <code>Controller</code>接口。XSLT控制器将单词列表转换为准备转换的简单XML文档。</p>
</div>
<div class="sect4">
<h5 id="mvc-view-xslt-beandefs"><a class="anchor" href="#mvc-view-xslt-beandefs"></a>豆子</h5>
<div class="paragraph">
<p>配置是简单Spring Web应用程序的标准配置：MVC配置必须定义一个<code>XsltViewResolver</code> bean和常规的MVC注释配置。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EnableWebMvc
@ComponentScan
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public XsltViewResolver xsltViewResolver() {
        XsltViewResolver viewResolver = new XsltViewResolver();
        viewResolver.setPrefix("/WEB-INF/xsl/");
        viewResolver.setSuffix(".xslt");
        return viewResolver;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebMvc
@ComponentScan
@Configuration
class WebConfig : WebMvcConfigurer {

    @Bean
    fun xsltViewResolver() = XsltViewResolver().apply {
        setPrefix("/WEB-INF/xsl/")
        setSuffix(".xslt")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-xslt-controllercode"><a class="anchor" href="#mvc-view-xslt-controllercode"></a>控制者</h5>
<div class="paragraph">
<p>我们还需要一个封装了词生成逻辑的控制器。</p>
</div>
<div class="paragraph">
<p>控制器逻辑封装在<code>@Controller</code>类，其处理程序方法定义如下：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class XsltController {

    @RequestMapping("/")
    public String home(Model model) throws Exception {
        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        Element root = document.createElement("wordList");

        List&lt;String&gt; words = Arrays.asList("Hello", "Spring", "Framework");
        for (String word : words) {
            Element wordNode = document.createElement("word");
            Text textNode = document.createTextNode(word);
            wordNode.appendChild(textNode);
            root.appendChild(wordNode);
        }

        model.addAttribute("wordList", root);
        return "home";
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.ui.set

@Controller
class XsltController {

    @RequestMapping("/")
    fun home(model: Model): String {
        val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument()
        val root = document.createElement("wordList")

        val words = listOf("Hello", "Spring", "Framework")
        for (word in words) {
            val wordNode = document.createElement("word")
            val textNode = document.createTextNode(word)
            wordNode.appendChild(textNode)
            root.appendChild(wordNode)
        }

        model["wordList"] = root
        return "home"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，我们仅创建了一个DOM文档并将其添加到Model映射中。请注意，您还可以将XML文件作为<code>Resource</code>并使用它代替自定义DOM文档。</p>
</div>
<div class="paragraph">
<p>有可用的软件包自动“对象化”对象图，但是在Spring中，您可以完全灵活地以任何选择的方式从模型中创建DOM。这样可以防止XML转换在模型数据的结构中扮演过多的角色，这在使用工具来管理DOMification流程时是一种危险。</p>
</div>
</div>
<div class="sect4">
<h5 id="mvc-view-xslt-transforming"><a class="anchor" href="#mvc-view-xslt-transforming"></a>转型</h5>
<div class="paragraph">
<p>最后， <code>XsltViewResolver</code>解析“主” XSLT模板文件，并将DOM文档合并到其中以生成我们的视图。如图所示<code>XsltViewResolver</code>配置中，XSLT模板位于<code>war</code>文件在<code>WEB-INF/xsl</code>目录并以<code>xslt</code>文件扩展名。</p>
</div>
<div class="paragraph">
<p>以下示例显示了XSLT转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

    &lt;xsl:output method="html" omit-xml-declaration="yes"/&gt;

    &lt;xsl:template match="/"&gt;
        &lt;html&gt;
            &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;
                &lt;h1&gt;My First Words&lt;/h1&gt;
                &lt;ul&gt;
                    &lt;xsl:apply-templates/&gt;
                &lt;/ul&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="word"&gt;
        &lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的转换呈现为以下HTML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html" data-lang="html">&lt;html&gt;
    &lt;head&gt;
        &lt;META http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Hello!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;My First Words&lt;/h1&gt;
        &lt;ul&gt;
            &lt;li&gt;Hello&lt;/li&gt;
            &lt;li&gt;Spring&lt;/li&gt;
            &lt;li&gt;Framework&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-config"><a class="anchor" href="#mvc-config"></a> 1.11。MVC配置</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>MVC Java配置和MVC XML名称空间提供适用于大多数应用程序的默认配置以及用于对其进行自定义的配置API。</p>
</div>
<div class="paragraph">
<p>有关配置API中不可用的更多高级定制，请参阅<a href="#mvc-config-advanced-java">Advanced Java Config</a>和<a href="#mvc-config-advanced-xml">Advanced XML Config</a> 。</p>
</div>
<div class="paragraph">
<p>您不需要了解由MVC Java配置和MVC名称空间创建的基础bean。如果要了解更多信息，请参见<a href="#mvc-servlet-special-bean-types">特殊Bean类型</a>和<a href="#mvc-servlet-config">Web MVC Config</a> 。</p>
</div>
<div class="sect3">
<h4 id="mvc-config-enable"><a class="anchor" href="#mvc-config-enable"></a> 1.11.1。启用MVC配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-enable">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以使用<code>@EnableWebMvc</code>注释以启用MVC配置，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>在XML配置中，您可以使用<code><mvc:annotation-driven></code>元素以启用MVC配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

    &lt;mvc:annotation-driven/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例注册了许多Spring MVC <a href="#mvc-servlet-special-bean-types">基础结构Bean，</a>并适应了类路径上可用的依赖项（例如，JSON，XML等的有效负载转换器）。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-customize"><a class="anchor" href="#mvc-config-customize"></a> 1.11.2。MVC Config API</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-customize">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以实现<code>WebMvcConfigurer</code>界面，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    // Implement configuration methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {
    // Implement configuration methods...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在XML中，您可以检查的属性和子元素<code><mvc:annotation-driven/></code> 。您可以查看<a href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML模式</a>或使用IDE的代码完成功能来发现可用的属性和子元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-conversion"><a class="anchor" href="#mvc-config-conversion"></a> 1.11.3。类型转换</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-conversion">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，格式化程序<code>Number</code>和<code>Date</code>类型的安装，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code>注释。如果类路径中存在Joda-Time，则还将安装对Joda-Time格式库的完全支持。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以注册自定义格式器和转换器，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun addFormatters(registry: FormatterRegistry) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

    &lt;mvc:annotation-driven conversion-service="conversionService"/&gt;

    &lt;bean id="conversionService"
            class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;
        &lt;property name="converters"&gt;
            &lt;set&gt;
                &lt;bean class="org.example.MyConverter"/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name="formatters"&gt;
            &lt;set&gt;
                &lt;bean class="org.example.MyFormatter"/&gt;
                &lt;bean class="org.example.MyAnnotationFormatterFactory"/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name="formatterRegistrars"&gt;
            &lt;set&gt;
                &lt;bean class="org.example.MyFormatterRegistrar"/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">见<a href="core.html#format-FormatterRegistrar-SPI">的<code>FormatterRegistrar</code> SPI</a>和<code>FormattingConversionServiceFactoryBean</code>有关何时使用FormatterRegistrar实现的更多信息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-validation"><a class="anchor" href="#mvc-config-validation"></a> 1.11.4。验证方式</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-validation">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，如果<a href="core.html#validation-beanvalidation-overview">Bean验证</a>存在于类路径中（例如，Hibernate Validator），则<code>LocalValidatorFactoryBean</code>已注册为全局<a href="core.html#validator">验证器</a>以用于<code>@Valid</code>和<code>Validated</code>在控制器方法参数上。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以自定义全局<code>Validator</code>实例，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public Validator getValidator() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun getValidator(): Validator {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;

    &lt;mvc:annotation-driven validator="globalValidator"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您也可以注册<code>Validator</code>本地实现，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addValidators(new FooValidator());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class MyController {

    @InitBinder
    protected fun initBinder(binder: WebDataBinder) {
        binder.addValidators(FooValidator())
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您需要<code>LocalValidatorFactoryBean</code>注入某处，创建一个bean并标记为<code>@Primary</code>为了避免与MVC配置中声明的冲突。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-interceptors"><a class="anchor" href="#mvc-config-interceptors"></a> 1.11.5。拦截器</h4>
<div class="paragraph">
<p>在Java配置中，您可以注册拦截器以应用于传入的请求，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LocaleChangeInterceptor());
        registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
        registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun addInterceptors(registry: InterceptorRegistry) {
        registry.addInterceptor(LocaleChangeInterceptor())
        registry.addInterceptor(ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**")
        registry.addInterceptor(SecurityInterceptor()).addPathPatterns("/secure/*")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:interceptors&gt;
    &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path="/**"/&gt;
        &lt;mvc:exclude-mapping path="/admin/**"/&gt;
        &lt;bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path="/secure/*"/&gt;
        &lt;bean class="org.example.SecurityInterceptor"/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-content-negotiation"><a class="anchor" href="#mvc-config-content-negotiation"></a> 1.11.6。内容类型</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-content-negotiation">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以配置Spring MVC如何根据请求确定请求的媒体类型（例如， <code>Accept</code>标头，URL路径扩展，查询参数等）。</p>
</div>
<div class="paragraph">
<p>默认情况下，首先检查URL路径扩展名- <code>json</code> ， <code>xml</code> ， <code>rss</code>和<code>atom</code>注册为已知扩展名（取决于类路径依赖项）。的<code>Accept</code>标头被第二次检查。</p>
</div>
<div class="paragraph">
<p>考虑将这些默认值更改为<code>Accept</code>仅标头，并且，如果必须使用基于URL的内容类型解析，请考虑对路径扩展使用查询参数策略。有关更多详细信息，请参见<a href="#mvc-ann-requestmapping-suffix-pattern-match">后缀匹配</a>和<a href="#mvc-ann-requestmapping-rfd">后缀匹配以及RFD</a> 。</p>
</div>
<div class="paragraph">
<p>在Java配置中，您可以自定义请求的内容类型解析，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer.mediaType("json", MediaType.APPLICATION_JSON);
        configurer.mediaType("xml", MediaType.APPLICATION_XML);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer) {
        configurer.mediaType("json", MediaType.APPLICATION_JSON)
        configurer.mediaType("xml", MediaType.APPLICATION_XML)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/&gt;

&lt;bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean"&gt;
    &lt;property name="mediaTypes"&gt;
        &lt;value&gt;
            json=application/json
            xml=application/xml
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-message-converters"><a class="anchor" href="#mvc-config-message-converters"></a> 1.11.7。讯息转换器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-message-codecs">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以自定义<code>HttpMessageConverter</code>在Java配置中通过重写<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-"><code>configureMessageConverters()</code></a> （以替换由Spring MVC创建的默认转换器）或通过覆盖<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-"><code>extendMessageConverters()</code></a> （以自定义默认转换器或将其他转换器添加到默认转换器）。</p>
</div>
<div class="paragraph">
<p>以下示例添加了具有自定义功能的XML和Jackson JSON转换器<code>ObjectMapper</code>而不是默认值：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfiguration implements WebMvcConfigurer {

    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
                .indentOutput(true)
                .dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
                .modulesToInstall(new ParameterNamesModule());
        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfiguration : WebMvcConfigurer {

    override fun configureMessageConverters(converters: MutableList&lt;HttpMessageConverter&lt;*&gt;&gt;) {
        val builder = Jackson2ObjectMapperBuilder()
                .indentOutput(true)
                .dateFormat(SimpleDateFormat("yyyy-MM-dd"))
                .modulesToInstall(ParameterNamesModule())
        converters.add(MappingJackson2HttpMessageConverter(builder.build()))
        converters.add(MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()))</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a>用于为两者创建通用配置<code>MappingJackson2HttpMessageConverter</code>和<code>MappingJackson2XmlHttpMessageConverter</code>启用缩进，自定义日期格式和注册<a href="https://github.com/FasterXML/jackson-module-parameter-names"><code>jackson-module-parameter-names</code></a> ，它增加了对访问参数名称的支持（Java 8中添加的功能）。</p>
</div>
<div class="paragraph">
<p>该构建器自定义Jackson的默认属性，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a>被禁用。</p>
</li>
<li>
<p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a>被禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在类路径中检测到以下知名模块，它还将自动注册以下知名模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a> ：支持Java 7类型，例如<code>java.nio.file.Path</code> 。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a> ：支持Joda-Time类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a> ：支持Java 8日期和时间API类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a> ：支持其他Java 8类型，例如<code>Optional</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用Jackson XML支持启用缩进需要<a href="https://search.maven.org/#search|gav|1|g%3A"org.codehaus.woodstox" AND a%3A"woodstox-core-asl""><code>woodstox-core-asl</code></a>除了依赖<a href="https://search.maven.org/#search|ga|1|a%3A"jackson-dataformat-xml""><code>jackson-dataformat-xml</code></a>一。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>其他有趣的Jackson模块也可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a> ：支持<code>javax.money</code>类型（非官方模块）。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a> ：支持特定于Hibernate的类型和属性（包括延迟加载方面）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt;
            &lt;property name="objectMapper" ref="objectMapper"/&gt;
        &lt;/bean&gt;
        &lt;bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"&gt;
            &lt;property name="objectMapper" ref="xmlMapper"/&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;

&lt;bean id="objectMapper" class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"
      p:indentOutput="true"
      p:simpleDateFormat="yyyy-MM-dd"
      p:modulesToInstall="com.fasterxml.jackson.module.paramnames.ParameterNamesModule"/&gt;

&lt;bean id="xmlMapper" parent="objectMapper" p:createXmlMapper="true"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-view-controller"><a class="anchor" href="#mvc-config-view-controller"></a> 1.11.8。查看控制器</h4>
<div class="paragraph">
<p>这是定义<code>ParameterizableViewController</code>调用后立即转发到视图。在视图生成响应之前没有Java控制器逻辑要执行的静态情况下，可以使用它。</p>
</div>
<div class="paragraph">
<p>以下Java配置示例转发了对<code>/</code>到一个叫做<code>home</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("home");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun addViewControllers(registry: ViewControllerRegistry) {
        registry.addViewController("/").setViewName("home")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例通过使用，通过使用XML实现了与上一示例相同的操作<code><mvc:view-controller></code>元件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:view-controller path="/" view-name="home"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-view-resolvers"><a class="anchor" href="#mvc-config-view-resolvers"></a> 1.11.9。查看解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-view-resolvers">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>MVC配置简化了视图解析器的注册。</p>
</div>
<div class="paragraph">
<p>以下Java配置示例通过使用JSP和Jackson作为默认配置来配置内容协商视图解析<code>View</code>用于JSON渲染：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.enableContentNegotiation(new MappingJackson2JsonView());
        registry.jsp();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.enableContentNegotiation(MappingJackson2JsonView())
        registry.jsp()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:view-resolvers&gt;
    &lt;mvc:content-negotiation&gt;
        &lt;mvc:default-views&gt;
            &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt;
        &lt;/mvc:default-views&gt;
    &lt;/mvc:content-negotiation&gt;
    &lt;mvc:jsp/&gt;
&lt;/mvc:view-resolvers&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是请注意，FreeMarker，Tiles，Groovy标记和脚本模板也需要配置基础视图技术。</p>
</div>
<div class="paragraph">
<p>MVC命名空间提供了专用元素。以下示例适用于FreeMarker：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:view-resolvers&gt;
    &lt;mvc:content-negotiation&gt;
        &lt;mvc:default-views&gt;
            &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt;
        &lt;/mvc:default-views&gt;
    &lt;/mvc:content-negotiation&gt;
    &lt;mvc:freemarker cache="false"/&gt;
&lt;/mvc:view-resolvers&gt;

&lt;mvc:freemarker-configurer&gt;
    &lt;mvc:template-loader-path location="/freemarker"/&gt;
&lt;/mvc:freemarker-configurer&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Java配置中，您可以添加相应的<code>Configurer</code> Bean，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.enableContentNegotiation(new MappingJackson2JsonView());
        registry.freeMarker().cache(false);
    }

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("/freemarker");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureViewResolvers(registry: ViewResolverRegistry) {
        registry.enableContentNegotiation(MappingJackson2JsonView())
        registry.freeMarker().cache(false)
    }

    @Bean
    fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
        setTemplateLoaderPath("/freemarker")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-static-resources"><a class="anchor" href="#mvc-config-static-resources"></a> 1.11.10。静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-static-resources">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>此选项提供了一种方便的方法来从以下列表中提供静态资源<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a>的位置。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，给定一个以<code>/resources</code> ，相对路径用于查找和服务相对于<code>/public</code>在Web应用程序根目录下或在<code>/static</code> 。这些资源的使用期限为一年，以确保最大程度地利用浏览器缓存并减少浏览器发出的HTTP请求。的<code>Last-Modified</code>标头也会被评估，如果存在的话， <code>304</code>状态码被返回。</p>
</div>
<div class="paragraph">
<p>以下清单显示了如何使用Java配置进行操作：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
            .addResourceLocations("/public", "classpath:/static/")
            .setCachePeriod(31556926);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public", "classpath:/static/")
                .setCachePeriod(31556926)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:resources mapping="/resources/**"
    location="/public, classpath:/static/"
    cache-period="31556926" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请参阅<a href="#mvc-caching-static-resources">对静态资源的HTTP缓存支持</a> 。</p>
</div>
<div class="paragraph">
<p>资源处理程序还支持<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceResolver.html"><code>ResourceResolver</code></a>实现和<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a>实现，您可以使用它们来创建工具链以使用优化的资源。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>VersionResourceResolver</code>基于从内容，固定应用程序版本或其他内容计算得出的MD5哈希值的版本化资源URL。一种<code>ContentVersionStrategy</code> （MD5哈希）是一个不错的选择，但有一些值得注意的例外，例如与模块加载器一起使用的JavaScript资源。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>VersionResourceResolver</code>在Java配置中：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public/")
                .resourceChain(true)
                .addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public/")
                .resourceChain(true)
                .addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:resources mapping="/resources/**" location="/public/"&gt;
    &lt;mvc:resource-chain resource-cache="true"&gt;
        &lt;mvc:resolvers&gt;
            &lt;mvc:version-resolver&gt;
                &lt;mvc:content-version-strategy patterns="/**"/&gt;
            &lt;/mvc:version-resolver&gt;
        &lt;/mvc:resolvers&gt;
    &lt;/mvc:resource-chain&gt;
&lt;/mvc:resources&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>ResourceUrlProvider</code>重写URL并应用完整的解析器和转换器链-例如，插入版本。MVC配置提供了一个<code>ResourceUrlProvider</code> bean，以便可以将其注入其他对象。您也可以使用<code>ResourceUrlEncodingFilter</code>适用于Thymeleaf，JSP，FreeMarker以及其他依赖于URL标签的<code>HttpServletResponse#encodeURL</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，同时使用<code>EncodedResourceResolver</code> （例如，用于提供压缩或brotli编码的资源）和<code>VersionResourceResolver</code> ，您必须按此顺序注册。这样可以确保始终基于未编码文件可靠地计算基于内容的版本。</p>
</div>
<div class="paragraph">
<p><a href="https://www.webjars.org/documentation">WebJars</a>还通过以下方式支持<code>WebJarsResourceResolver</code>当<code>org.webjars:webjars-locator-core</code>库存在于类路径中。解析程序可以重写URL以包括jar的版本，并且还可以与没有版本的传入URL进行匹配-例如，从<code>/jquery/jquery.min.js</code>至<code>/jquery/1.2.0/jquery.min.js</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-default-servlet-handler"><a class="anchor" href="#mvc-default-servlet-handler"></a> 1.11.11。默认Servlet</h4>
<div class="paragraph">
<p>Spring MVC允许映射<code>DispatcherServlet</code>至<code>/</code> （从而覆盖容器默认Servlet的映射），同时仍允许容器默认Servlet处理静态资源请求。它配置一个<code>DefaultServletHttpRequestHandler</code> URL映射为<code>/**</code>以及相对于其他URL映射的最低优先级。</p>
</div>
<div class="paragraph">
<p>该处理程序将所有请求转发到默认Servlet。因此，它必须按所有其他URL的顺序保留在最后<code>HandlerMappings</code> 。如果您使用的话就是这种情况<code><mvc:annotation-driven></code> 。或者，如果您设置自己的自定义<code>HandlerMapping</code>实例，请务必设置其<code>order</code>属性值低于<code>DefaultServletHttpRequestHandler</code> ，这是<code>Integer.MAX_VALUE</code> 。</p>
</div>
<div class="paragraph">
<p>下面的示例说明如何使用默认设置启用功能：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
        configurer.enable()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:default-servlet-handler/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意要覆盖<code>/</code> Servlet映射是<code>RequestDispatcher</code>对于默认Servlet，必须按名称而不是按路径检索。的<code>DefaultServletHttpRequestHandler</code>尝试使用大多数主要Servlet容器（包括Tomcat，Jetty，GlassFish，JBoss，Resin，WebLogic和WebSphere）的已知名称列表，在启动时自动检测容器的默认Servlet。如果已使用其他名称自定义配置了默认Servlet，或者在默认Servlet名称未知的情况下使用了不同的Servlet容器，则必须显式提供默认Servlet的名称，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable("myCustomDefaultServlet");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
        configurer.enable("myCustomDefaultServlet")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-path-matching"><a class="anchor" href="#mvc-config-path-matching"></a> 1.11.12。路径匹配</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-path-matching">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>您可以自定义与路径匹配和URL处理有关的选项。有关各个选项的详细信息，请参见<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Java配置中自定义路径匹配：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseSuffixPatternMatch(true)
            .setUseTrailingSlashMatch(false)
            .setUseRegisteredSuffixPatternMatch(true)
            .setPathMatcher(antPathMatcher())
            .setUrlPathHelper(urlPathHelper())
            .addPathPrefix("/api",
                    HandlerTypePredicate.forAnnotation(RestController.class));
    }

    @Bean
    public UrlPathHelper urlPathHelper() {
        //...
    }

    @Bean
    public PathMatcher antPathMatcher() {
        //...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebMvc
class WebConfig : WebMvcConfigurer {

    override fun configurePathMatch(configurer: PathMatchConfigurer) {
        configurer
            .setUseSuffixPatternMatch(true)
            .setUseTrailingSlashMatch(false)
            .setUseRegisteredSuffixPatternMatch(true)
            .setPathMatcher(antPathMatcher())
            .setUrlPathHelper(urlPathHelper())
            .addPathPrefix("/api",
                    HandlerTypePredicate.forAnnotation(RestController::class.java))
    }

    @Bean
    fun urlPathHelper(): UrlPathHelper {
        //...
    }

    @Bean
    fun antPathMatcher(): PathMatcher {
        //...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在XML中实现相同的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:path-matching
        suffix-pattern="true"
        trailing-slash="false"
        registered-suffixes-only="true"
        path-helper="pathHelper"
        path-matcher="pathMatcher"/&gt;
&lt;/mvc:annotation-driven&gt;

&lt;bean id="pathHelper" class="org.example.app.MyPathHelper"/&gt;
&lt;bean id="pathMatcher" class="org.example.app.MyPathMatcher"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-advanced-java"><a class="anchor" href="#mvc-config-advanced-java"></a> 1.11.13。高级Java配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-config-advanced-java">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebMvc</code>进口<code>DelegatingWebMvcConfiguration</code> ， 哪一个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为Spring MVC应用程序提供默认的Spring配置</p>
</li>
<li>
<p>检测并委托给<code>WebMvcConfigurer</code>实现以自定义该配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级模式，您可以删除<code>@EnableWebMvc</code>并直接从<code>DelegatingWebMvcConfiguration</code>而不是执行<code>WebMvcConfigurer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebConfig extends DelegatingWebMvcConfiguration {

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class WebConfig : DelegatingWebMvcConfiguration() {

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以保留现有方法<code>WebConfig</code> ，但是现在您还可以覆盖基类中的bean声明，并且仍然可以具有任意数量的其他声明<code>WebMvcConfigurer</code>类路径上的实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-config-advanced-xml"><a class="anchor" href="#mvc-config-advanced-xml"></a> 1.11.14。高级XML配置</h4>
<div class="paragraph">
<p>MVC命名空间没有高级模式。如果您需要在Bean上自定义一个属性，则无法更改该属性，则可以使用<code>BeanPostProcessor</code>春天的生命周期钩<code>ApplicationContext</code> ，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyPostProcessor implements BeanPostProcessor {

    public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class MyPostProcessor : BeanPostProcessor {

    override fun postProcessBeforeInitialization(bean: Any, name: String): Any {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您需要声明<code>MyPostProcessor</code>作为bean，可以用XML显式表示，也可以通过<code><component-scan/></code>宣言。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc-http2"><a class="anchor" href="#mvc-http2"></a> 1.12。HTTP / 2</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-http2">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>需要Servlet 4容器来支持HTTP / 2，并且Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要做任何特定的事情。但是，有一些与服务器配置有关的注意事项。有关更多详细信息，请参见<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP / 2 Wiki页面</a> 。</p>
</div>
<div class="paragraph">
<p>Servlet API确实公开了一种与HTTP / 2相关的构造。您可以使用<code>javax.servlet.http.PushBuilder</code>主动将资源推送到客户端，并且作为<a href="#mvc-ann-arguments">方法参数</a>支持<code>@RequestMapping</code>方法。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webmvc-client"><a class="anchor" href="#webmvc-client"></a> 2。REST客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了客户端对REST端点的访问选项。</p>
</div>
<div class="sect2">
<h3 id="webmvc-resttemplate"><a class="anchor" href="#webmvc-resttemplate"></a> 2.1。<code>RestTemplate</code></h3>
<div class="paragraph">
<p><code>RestTemplate</code>是执行HTTP请求的同步客户端。它是原始的Spring REST客户端，在基础HTTP客户端库上公开了简单的模板方法API。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从5.0开始，非阻塞式，反应式<code>WebClient</code>提供了现代的替代方案<code>RestTemplate</code> ，并有效支持<a href="web-reactive.html#webflux-client-synchronous">同步和异步</a>以及流方案。的<code>RestTemplate</code>将在以后的版本中弃用，并且以后不会添加任何主要的新功能。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关详细信息，请参见<a href="integration.html#rest-client-access">REST端点</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="webmvc-webclient"><a class="anchor" href="#webmvc-webclient"></a> 2.2。<code>WebClient</code></h3>
<div class="paragraph">
<p><code>WebClient</code>是执行HTTP请求的非阻塞，反应式客户端。它是在5.0中引入的，它为<code>RestTemplate</code> ，并有效支持同步和异步以及流方案。</p>
</div>
<div class="paragraph">
<p>与之相反<code>RestTemplate</code> ， <code>WebClient</code>支持以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>非阻塞I / O。</p>
</li>
<li>
<p>反应性产生背压。</p>
</li>
<li>
<p>高并发，硬件资源更少。</p>
</li>
<li>
<p>利用Java 8 lambda的功能风格，流畅的API。</p>
</li>
<li>
<p>同步和异步交互。</p>
</li>
<li>
<p>从服务器流向上或从服务器向下流。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="web-reactive.html#webflux-client">WebClient</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a> 3。测试中</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-test">与Spring WebFlux相同</a></span></p>
</div>
<div class="paragraph">
<p>本节总结了<code>spring-test</code>用于Spring MVC应用程序。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servlet API模拟：用于单元测试控制器，过滤器和其他Web组件的Servlet API合约的模拟实现。有关更多详细信息，请参见<a href="testing.html#mock-objects-servlet">Servlet API</a>模拟对象。</p>
</li>
<li>
<p>TestContext Framework：支持在JUnit和TestNG测试中加载Spring配置，包括跨测试方法高效地缓存已加载的配置，并支持加载<code>WebApplicationContext</code>与一个<code>MockServletContext</code> 。有关更多详细信息，请参见<a href="testing.html#testcontext-framework">TestContext Framework</a> 。</p>
</li>
<li>
<p>Spring MVC测试：一个框架，也称为<code>MockMvc</code> ，用于通过来测试带注释的控制器<code>DispatcherServlet</code> （即，支持注释），带有Spring MVC基础结构，但没有HTTP服务器。有关更多详细信息，请参见<a href="testing.html#spring-mvc-test-framework">Spring MVC Test</a> 。</p>
</li>
<li>
<p>客户端REST： <code>spring-test</code>提供一个<code>MockRestServiceServer</code>您可以用作模拟服务器来测试内部使用<code>RestTemplate</code> 。有关更多详细信息，请参见<a href="testing.html#spring-mvc-test-client">客户端REST测试</a> 。</p>
</li>
<li>
<p><code>WebTestClient</code> ：专为测试WebFlux应用程序而构建，但也可以用于通过HTTP连接到任何服务器的端到端集成测试。它是一个无阻塞的反应式客户端，非常适合测试异步和流传输方案。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="websocket"><a class="anchor" href="#websocket"></a> 4。Web套接字</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>参考文档的此部分涵盖对Servlet堆栈的支持，包括原始WebSocket交互的WebSocket消息传递，通过SockJS进行WebSocket仿真以及通过STOMP作为WebSocket的子协议进行发布-订阅消息传递。</p>
</div>
<div class="sect2">
<h3 id="websocket-intro"><a class="anchor" href="#websocket-intro"></a> 4.1。WebSocket简介</h3>
<div class="paragraph">
<p>WebSocket协议<a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准化方法，可通过单个TCP连接在客户端和服务器之间建立全双工双向通信通道。它是与HTTP不同的TCP协议，但旨在通过端口80和443在HTTP上工作，并允许重复使用现有的防火墙规则。</p>
</div>
<div class="paragraph">
<p>WebSocket交互始于使用HTTP的HTTP请求<code>Upgrade</code>标头，以进行升级，或者在这种情况下，切换到WebSocket协议。以下示例显示了这种交互：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">GET /spring-websocket-portfolio/portfolio HTTP/1.1
Host: localhost:8080
Upgrade: websocket <i class="conum" data-value="1"></i><b>(1)</b>
Connection: Upgrade <i class="conum" data-value="2"></i><b>(2)</b>
Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==
Sec-WebSocket-Protocol: v10.stomp, v11.stomp
Sec-WebSocket-Version: 13
Origin: http://localhost:8080</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>Upgrade</code>标头。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>具有WebSocket支持的服务器代替通常的200状态代码，返回的输出类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">HTTP/1.1 101 Switching Protocols <i class="conum" data-value="1"></i><b>(1)</b>
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=
Sec-WebSocket-Protocol: v10.stomp</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>协议切换</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>握手成功后，HTTP升级请求的基础TCP套接字将保持打开状态，客户端和服务器均可继续发送和接收消息。</p>
</div>
<div class="paragraph">
<p>WebSockets的工作原理的完整介绍超出了本文档的范围。请参阅RFC 6455，HTML5的WebSocket章节或Web上的许多简介和教程中的任何一个。</p>
</div>
<div class="paragraph">
<p>请注意，如果WebSocket服务器在Web服务器（例如nginx）后面运行，则可能需要对其进行配置，以将WebSocket升级请求传递到WebSocket服务器。同样，如果应用程序在云环境中运行，请检查与WebSocket支持相关的云提供商的说明。</p>
</div>
<div class="sect3">
<h4 id="websocket-intro-architecture"><a class="anchor" href="#websocket-intro-architecture"></a> 4.1.1。HTTP与WebSocket</h4>
<div class="paragraph">
<p>尽管WebSocket被设计为与HTTP兼容并以HTTP请求开头，但重要的是要了解这两个协议导致了截然不同的体系结构和应用程序编程模型。</p>
</div>
<div class="paragraph">
<p>在HTTP和REST中，应用程序被建模为许多URL。为了与应用程序交互，客户端访问那些URL，即请求-响应样式。服务器根据HTTP URL，方法和标头将请求路由到适当的处理程序。</p>
</div>
<div class="paragraph">
<p>相反，在WebSockets中，通常只有一个URL用于初始连接。随后，所有应用程序消息在同一TCP连接上流动。这指向了一个完全不同的异步，事件驱动的消息传递体系结构。</p>
</div>
<div class="paragraph">
<p>WebSocket也是一种低级传输协议，与HTTP不同，它不对消息的内容规定任何语义。这意味着除非客户端和服务器就消息语义达成一致，否则就无法路由或处理消息。</p>
</div>
<div class="paragraph">
<p>WebSocket客户端和服务器可以通过以下方式协商使用更高级别的消息传递协议（例如STOMP）： <code>Sec-WebSocket-Protocol</code> HTTP握手请求上的标头。在这种情况下，他们需要提出自己的约定。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-intro-when-to-use"><a class="anchor" href="#websocket-intro-when-to-use"></a> 4.1.2。何时使用WebSockets</h4>
<div class="paragraph">
<p>WebSockets可以使网页具有动态性和交互性。但是，在许多情况下，结合使用Ajax和HTTP流或长轮询可以提供一种简单有效的解决方案。</p>
</div>
<div class="paragraph">
<p>例如，新闻，邮件和社交订阅源需要动态更新，但是每几分钟进行一次更新可能是完全可以的。另一方面，协作，游戏和金融应用程序需要更接近实时。</p>
</div>
<div class="paragraph">
<p>仅延迟并不是决定因素。如果消息量相对较少（例如，监视网络故障），则HTTP流或轮询可以提供有效的解决方案。低延迟，高频率和高音量的结合才是使用WebSocket的最佳案例。</p>
</div>
<div class="paragraph">
<p>还要记住，在Internet上，不受控制的代理可能会阻止WebSocket交互，因为它们没有配置为传递给WebSocket。 <code>Upgrade</code>标头或因为它们关闭了看起来很空闲的长期连接。这意味着与面向公众的应用程序相比，将WebSocket用于防火墙内部的应用程序是一个更直接的决定。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-server"><a class="anchor" href="#websocket-server"></a> 4.2。WebSocket API</h3>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>Spring Framework 提供了一个WebSocket API，可用于编写处理WebSocket消息的客户端和服务器端应用程序。</p>
</div>
<div class="sect3">
<h4 id="websocket-server-handler"><a class="anchor" href="#websocket-server-handler"></a> 4.2.1。<code>WebSocketHandler</code></h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-handler">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>创建WebSocket服务器就像实现一样简单<code>WebSocketHandler</code>或者更可能扩展<code>TextWebSocketHandler</code>要么<code>BinaryWebSocketHandler</code> 。以下示例使用<code>TextWebSocketHandler</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.TextMessage;

public class MyHandler extends TextWebSocketHandler {

    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有专用的WebSocket Java配置和XML名称空间支持，用于将前面的WebSocket处理程序映射到特定的URL，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:handlers&gt;
        &lt;websocket:mapping path="/myHandler" handler="myHandler"/&gt;
    &lt;/websocket:handlers&gt;

    &lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例用于Spring MVC应用程序，应包含在<a href="#mvc-servlet"><code>DispatcherServlet</code></a> 。但是，Spring的WebSocket支持不依赖于Spring MVC。集成一个相对简单<code>WebSocketHandler</code>借助以下工具进入其他HTTP服务环境<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html"><code>WebSocketHttpRequestHandler</code></a> 。</p>
</div>
<div class="paragraph">
<p>使用时<code>WebSocketHandler</code> API是直接还是间接（例如，通过<a href="#websocket-stomp">STOMP</a>消息传递），间接还是间接，应用程序必须同步消息的发送，因为底层的标准WebSocket会话（JSR-356）不允许并发发送。一种选择是包装<code>WebSocketSession</code>与<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/socket/handler/ConcurrentWebSocketSessionDecorator.html"><code>ConcurrentWebSocketSessionDecorator</code></a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-handshake"><a class="anchor" href="#websocket-server-handshake"></a> 4.2.2。WebSocket握手</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-handshake">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>自定义初始HTTP WebSocket握手请求的最简单方法是通过<code>HandshakeInterceptor</code> ，其中介绍了“握手之前”和“握手之后”的方法。您可以使用此类拦截器排除握手或使任何属性对<code>WebSocketSession</code> 。以下示例使用内置的拦截器将HTTP会话属性传递到WebSocket会话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new MyHandler(), "/myHandler")
            .addInterceptors(new HttpSessionHandshakeInterceptor());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:handlers&gt;
        &lt;websocket:mapping path="/myHandler" handler="myHandler"/&gt;
        &lt;websocket:handshake-interceptors&gt;
            &lt;bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/&gt;
        &lt;/websocket:handshake-interceptors&gt;
    &lt;/websocket:handlers&gt;

    &lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个更高级的选项是扩展<code>DefaultHandshakeHandler</code>它执行WebSocket握手的步骤，包括验证客户端来源，协商子协议以及其他详细信息。如果应用程序需要配置自定义，则可能还需要使用此选项。 <code>RequestUpgradeStrategy</code>为了适应尚不支持的WebSocket服务器引擎和版本（有关此主题的更多信息，请参阅<a href="#websocket-server-deployment">部署</a> ）。Java配置和XML名称空间都可以配置自定义<code>HandshakeHandler</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">春天提供了<code>WebSocketHandlerDecorator</code>您可以用来装饰一个基类<code>WebSocketHandler</code>带有其他行为。使用WebSocket Java配置或XML名称空间时，默认情况下会提供并添加日志记录和异常处理实现。的<code>ExceptionWebSocketHandlerDecorator</code>捕获任何因任何未捕获的异常<code>WebSocketHandler</code>方法并使用状态关闭WebSocket会话<code>1011</code> ，指示服务器错误。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-deployment"><a class="anchor" href="#websocket-server-deployment"></a> 4.2.3。部署方式</h4>
<div class="paragraph">
<p>Spring WebSocket API易于集成到Spring MVC应用程序中，其中<code>DispatcherServlet</code>提供HTTP WebSocket握手和其他HTTP请求。通过调用也很容易集成到其他HTTP处理方案中<code>WebSocketHttpRequestHandler</code> 。这是方便且易于理解的。但是，对于JSR-356运行时，需要特别注意。</p>
</div>
<div class="paragraph">
<p>Java WebSocket API（JSR-356）提供了两种部署机制。第一个涉及启动时的Servlet容器类路径扫描（Servlet 3功能）。另一个是在Servlet容器初始化时使用的注册API。这两种机制都无法将单个“前端控制器”用于所有HTTP处理（包括WebSocket握手和所有其他HTTP请求），例如Spring MVC <code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p>这是JSR-356的一个重大限制，即Spring的WebSocket支持使用特定于服务器的地址<code>RequestUpgradeStrategy</code>实现，即使在JSR-356运行时中运行也是如此。Tomcat，Jetty，GlassFish，WebLogic，WebSphere和Undertow（和WildFly）目前存在此类策略。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">已经创建了克服Java WebSocket API中的上述限制的请求，可以在<a href="https://github.com/eclipse-ee4j/websocket-api/issues/211">eclipse-ee4j / websocket-api＃211</a>处进行跟踪。Tomcat，Undertow和WebSphere提供了自己的API替代方案，使之可以做到这一点，而Jetty也可以实现。我们希望更多的服务器可以做到这一点。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第二个考虑因素是，期望具有JSR-356支持的Servlet容器能够执行<code>ServletContainerInitializer</code> （SCI）扫描可能会减慢应用程序的启动速度，在某些情况下会大大降低。如果在升级到支持JSR-356的Servlet容器版本后观察到重大影响，则应该可以通过使用<code><absolute-ordering /></code>元素在<code>web.xml</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0"&gt;

    &lt;absolute-ordering/&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以按名称有选择地启用Web片段，例如Spring自己的名称<code>SpringServletContainerInitializer</code>提供对Servlet 3 Java初始化API的支持。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0"&gt;

    &lt;absolute-ordering&gt;
        &lt;name&gt;spring_web&lt;/name&gt;
    &lt;/absolute-ordering&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-runtime-configuration"><a class="anchor" href="#websocket-server-runtime-configuration"></a> 4.2.4。服务器配置</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-config">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>每个基础WebSocket引擎都公开配置属性，这些属性控制运行时特征，例如消息缓冲区大小的大小，空闲超时等。</p>
</div>
<div class="paragraph">
<p>对于Tomcat，WildFly和GlassFish，您可以添加一个<code>ServletServerContainerFactoryBean</code>到您的WebSocket Java配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        container.setMaxTextMessageBufferSize(8192);
        container.setMaxBinaryMessageBufferSize(8192);
        return container;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;bean class="org.springframework...ServletServerContainerFactoryBean"&gt;
        &lt;property name="maxTextMessageBufferSize" value="8192"/&gt;
        &lt;property name="maxBinaryMessageBufferSize" value="8192"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于客户端WebSocket配置，应使用<code>WebSocketContainerFactoryBean</code> （XML）或<code>ContainerProvider.getWebSocketContainer()</code> （Java配置）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于Jetty，您需要提供一个预先配置的Jetty <code>WebSocketServerFactory</code>并将其插入Spring的<code>DefaultHandshakeHandler</code>通过您的WebSocket Java配置。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(echoWebSocketHandler(),
            "/echo").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:handlers&gt;
        &lt;websocket:mapping path="/echo" handler="echoHandler"/&gt;
        &lt;websocket:handshake-handler ref="handshakeHandler"/&gt;
    &lt;/websocket:handlers&gt;

    &lt;bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler"&gt;
        &lt;constructor-arg ref="upgradeStrategy"/&gt;
    &lt;/bean&gt;

    &lt;bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy"&gt;
        &lt;constructor-arg ref="serverFactory"/&gt;
    &lt;/bean&gt;

    &lt;bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory"&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="org.eclipse.jetty...WebSocketPolicy"&gt;
                &lt;constructor-arg value="SERVER"/&gt;
                &lt;property name="inputBufferSize" value="8092"/&gt;
                &lt;property name="idleTimeout" value="600000"/&gt;
            &lt;/bean&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-server-allowed-origins"><a class="anchor" href="#websocket-server-allowed-origins"></a> 4.2.5。允许的来源</h4>
<div class="paragraph">
<p><span class="small"><a href="web-reactive.html#webflux-websocket-server-cors">与Spring WebFlux中的相同</a></span></p>
</div>
<div class="paragraph">
<p>从Spring Framework 4.1.5开始，WebSocket和SockJS的默认行为是仅接受同源请求。也可以允许所有或指定的来源列表。此检查主要用于浏览器客户端。没有什么可以阻止其他类型的客户端修改<code>Origin</code>标头值（有关更多详细信息，请参阅<a href="https://tools.ietf.org/html/rfc6454">RFC 6454：Web Origin概念</a> ）。</p>
</div>
<div class="paragraph">
<p>三种可能的行为是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>仅允许相同来源的请求（默认）：在此模式下，启用SockJS时，Iframe HTTP响应标头<code>X-Frame-Options</code>被设定为<code>SAMEORIGIN</code> ，并且JSONP传输已禁用，因为它不允许检查请求的来源。因此，启用此模式时，不支持IE6和IE7。</p>
</li>
<li>
<p>允许指定来源列表：每个允许的来源必须以<code>http://</code>要么<code>https://</code> 。在此模式下，启用SockJS时，将禁用IFrame传输。因此，启用此模式时，不支持IE6到IE9。</p>
</li>
<li>
<p>允许所有来源：要启用此模式，您应提供<code>*</code>作为允许的原点值。在这种模式下，所有传输都可用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以配置WebSocket和SockJS允许的来源，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:handlers allowed-origins="https://mydomain.com"&gt;
        &lt;websocket:mapping path="/myHandler" handler="myHandler" /&gt;
    &lt;/websocket:handlers&gt;

    &lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-fallback"><a class="anchor" href="#websocket-fallback"></a> 4.3。SockJS后备</h3>
<div class="paragraph">
<p>在公共Internet上，控件之外的限制性代理可能会阻止WebSocket交互，因为它们没有配置为传递<code>Upgrade</code>标头或因为它们关闭了似乎空闲的长期连接。</p>
</div>
<div class="paragraph">
<p>解决此问题的方法是WebSocket仿真-即尝试先使用WebSocket，然后再尝试使用基于HTTP的技术来模拟WebSocket交互并公开相同的应用程序级API。</p>
</div>
<div class="paragraph">
<p>在Servlet堆栈上，Spring Framework 为SockJS协议提供服务器（和客户端）支持。</p>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-overview"><a class="anchor" href="#websocket-fallback-sockjs-overview"></a> 4.3.1。总览</h4>
<div class="paragraph">
<p>SockJS的目标是让应用程序使用WebSocket API，但在运行时必要时可以使用非WebSocket替代方案，而无需更改应用程序代码。</p>
</div>
<div class="paragraph">
<p>SockJS包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sockjs/sockjs-protocol">SockJS协议</a>以可执行<a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">叙述测试</a>的形式定义。</p>
</li>
<li>
<p><a href="https://github.com/sockjs/sockjs-client/">SockJS JavaScript客户端</a> -用于浏览器的客户端库。</p>
</li>
<li>
<p>SockJS服务器实现，包括Spring Framework 中的一个<code>spring-websocket</code>模块。</p>
</li>
<li>
<p>中的SockJS Java客户端<code>spring-websocket</code>模块（从4.1版开始）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SockJS设计用于浏览器。它使用多种技术来支持各种浏览器版本。有关SockJS传输类型和浏览器的完整列表，请参见<a href="https://github.com/sockjs/sockjs-client/">SockJS客户端</a>页面。传输分为三大类：WebSocket，HTTP流和HTTP长轮询。有关这些类别的概述，请参阅<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">此博客文章</a> 。</p>
</div>
<div class="paragraph">
<p>SockJS客户端首先发送<code>GET /info</code>从服务器获取基本信息。在那之后，它必须决定使用哪种交通工具。如果可能，请使用WebSocket。如果没有，在大多数浏览器中，至少有一个HTTP流选项。如果不是，则使用HTTP（长）轮询。</p>
</div>
<div class="paragraph">
<p>所有传输请求都具有以下URL结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}</pre>
</div>
</div>
<div class="paragraph">
<p>哪里：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{server-id}</code>对于在集群中路由请求很有用，但否则不使用。</p>
</li>
<li>
<p><code>{session-id}</code>关联属于SockJS会话的HTTP请求。</p>
</li>
<li>
<p><code>{transport}</code>指示运输类型（例如， <code>websocket</code> ， <code>xhr-streaming</code> ， 和别的）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>WebSocket传输仅需要单个HTTP请求即可进行WebSocket握手。此后所有消息在该套接字上交换。</p>
</div>
<div class="paragraph">
<p>HTTP传输需要更多请求。例如，Ajax / XHR流依赖于对服务器到客户端消息的一个长时间运行的请求，以及对客户端到服务器消息的其他HTTP POST请求。长轮询类似于长轮询，只是它在每次服务器到客户端发送后结束当前请求。</p>
</div>
<div class="paragraph">
<p>SockJS添加了最少的消息框架。例如，服务器发送信件<code>o</code> （“开放”框架）最初，消息发送为<code>a["message1","message2"]</code> （JSON编码数组），字母<code>h</code> （“心跳”帧），如果25秒内没有消息流（默认情况下），则显示字母<code>c</code> （“关闭”框架）以关闭会话。</p>
</div>
<div class="paragraph">
<p>要了解更多信息，请在浏览器中运行示例并查看HTTP请求。SockJS客户端允许固定传输列表，因此可以一次查看每个传输。SockJS客户端还提供了调试标志，该标志可在浏览器控制台中启用有用的消息。在服务器端，您可以启用<code>TRACE</code>记录<code>org.springframework.web.socket</code> 。有关更多详细信息，请参见SockJS协议<a href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">旁白测试</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-enable"><a class="anchor" href="#websocket-fallback-sockjs-enable"></a> 4.3.2。启用SockJS</h4>
<div class="paragraph">
<p>您可以通过Java配置启用SockJS，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(myHandler(), "/myHandler").withSockJS();
    }

    @Bean
    public WebSocketHandler myHandler() {
        return new MyHandler();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:handlers&gt;
        &lt;websocket:mapping path="/myHandler" handler="myHandler"/&gt;
        &lt;websocket:sockjs/&gt;
    &lt;/websocket:handlers&gt;

    &lt;bean id="myHandler" class="org.springframework.samples.MyHandler"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例用于Spring MVC应用程序，应包含在<a href="#mvc-servlet"><code>DispatcherServlet</code></a> 。但是，Spring的WebSocket和SockJS支持不依赖于Spring MVC。在以下的帮助下，将其集成到其他HTTP服务环境中相对简单<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/socket/sockjs/support/SockJsHttpRequestHandler.html"><code>SockJsHttpRequestHandler</code></a> 。</p>
</div>
<div class="paragraph">
<p>在浏览器方面，应用程序可以使用<a href="https://github.com/sockjs/sockjs-client/"><code>sockjs-client</code></a> （版本1.0.x）。它模拟W3C WebSocket API，并与服务器通信以选择最佳的传输选项，具体取决于运行它的浏览器。请参阅<a href="https://github.com/sockjs/sockjs-client/">sockjs-client</a>页面和浏览器支持的传输类型列表。客户端还提供了几个配置选项-例如，指定要包括的传输。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-xhr-vs-iframe"><a class="anchor" href="#websocket-fallback-xhr-vs-iframe"></a> 4.3.3。IE 8和9</h4>
<div class="paragraph">
<p>Internet Explorer 8和9仍在使用。它们是拥有SockJS的关键原因。本节涵盖有关在这些浏览器中运行的重要注意事项。</p>
</div>
<div class="paragraph">
<p>SockJS客户端通过使用Microsoft的IE在IE 8和9中支持Ajax / XHR流。 <a href="https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx"><code>XDomainRequest</code></a> 。跨域有效，但不支持发送Cookie。Cookies对于Java应用程序通常是必不可少的。但是，由于SockJS客户端可用于多种服务器类型（而不仅仅是Java类型），因此它需要知道cookie是否重要。如果是这样，则SockJS客户端更喜欢Ajax / XHR进行流传输。否则，它依赖于基于iframe的技术。</p>
</div>
<div class="paragraph">
<p>首先<code>/info</code>来自SockJS客户端的请求是对可能影响客户端选择传输方式的信息的请求。这些详细信息之一是服务器应用程序是否依赖Cookie（例如，出于身份验证目的或使用粘性会话进行群集）。Spring对SockJS的支持包括一个名为<code>sessionCookieNeeded</code> 。默认情况下启用此功能，因为大多数Java应用程序都依赖于<code>JSESSIONID</code>曲奇饼。如果您的应用程序不需要它，则可以关闭此选项，然后SockJS客户端应选择<code>xdr-streaming</code>在IE 8和9中。</p>
</div>
<div class="paragraph">
<p>如果您确实使用基于iframe的传输，请记住，可以通过设置HTTP响应标头指示浏览器阻止在给定页面上使用iframe <code>X-Frame-Options</code>至<code>DENY</code> ， <code>SAMEORIGIN</code> ， 要么<code>ALLOW-FROM <origin></code> 。这用于防止<a href="https://www.owasp.org/index.php/Clickjacking">点击劫持</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security 3.2+提供了对设置的支持<code>X-Frame-Options</code>在每一个回应。默认情况下，Spring Security Java配置将其设置为<code>DENY</code> 。在3.2中，Spring Security XML名称空间默认情况下不设置该标头，但可以配置为这样做。将来，它可能会默认设置。</p>
</div>
<div class="paragraph">
<p>请参阅Spring Security文档中的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers">Default Security Headers</a>以获取有关如何配置密码设置的详细信息。 <code>X-Frame-Options</code>标头。您也可以查看<a href="https://jira.spring.io/browse/SEC-2501">SEC-2501</a>以获取更多背景信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您的应用程序添加了<code>X-Frame-Options</code>响应标头（应如此！）并且依靠基于iframe的传输，您需要将标头值设置为<code>SAMEORIGIN</code>要么<code>ALLOW-FROM <origin></code> 。Spring SockJS支持还需要知道SockJS客户端的位置，因为它是从iframe加载的。默认情况下，iframe设置为从CDN位置下载SockJS客户端。最好将此选项配置为使用与应用程序源相同的URL。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Java配置中执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS()
                .setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>XML名称空间通过以下方式提供了类似的选项： <code><websocket:sockjs></code>元件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在初始开发过程中，请启用SockJS客户端<code>devel</code>模式，以防止浏览器缓存本应缓存的SockJS请求（如iframe）。有关如何启用它的详细信息，请参见<a href="https://github.com/sockjs/sockjs-client/">SockJS客户端</a>页面。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-heartbeat"><a class="anchor" href="#websocket-fallback-sockjs-heartbeat"></a> 4.3.4。心跳</h4>
<div class="paragraph">
<p>SockJS协议要求服务器发送心跳消息，以防止代理断定连接已挂起。Spring SockJS配置具有一个名为<code>heartbeatTime</code>您可以用来自定义频率。默认情况下，假设没有其他消息在该连接上发送，则心跳将在25秒后发送。这个25秒的值符合以下<a href="https://tools.ietf.org/html/rfc6202">IETF</a>对公共Internet应用程序的<a href="https://tools.ietf.org/html/rfc6202">建议</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在WebSocket和SockJS上使用STOMP时，如果STOMP客户端和服务器协商要交换的心跳，则会禁用SockJS心跳。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring SockJS支持还允许您配置<code>TaskScheduler</code>安排心跳任务。任务调度程序由线程池支持，其默认设置基于可用处理器的数量。您应该考虑根据您的特定需求自定义设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-servlet3-async"><a class="anchor" href="#websocket-fallback-sockjs-servlet3-async"></a> 4.3.5。客户端断开连接</h4>
<div class="paragraph">
<p>HTTP流和HTTP长轮询SockJS传输要求连接保持打开的时间比平常更长。有关这些技术的概述，请参见此<a href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">博客文章</a> 。</p>
</div>
<div class="paragraph">
<p>在Servlet容器中，这是通过Servlet 3异步支持完成的，该支持允许退出Servlet容器线程，处理请求并继续写入另一个线程的响应。</p>
</div>
<div class="paragraph">
<p>一个特定的问题是，Servlet API不会为已离开的客户端提供通知。请参阅<a href="https://github.com/eclipse-ee4j/servlet-api/issues/44">eclipse-ee4j / servlet-api＃44</a> 。但是，Servlet容器在随后尝试写入响应时会引发异常。由于Spring的SockJS服务支持服务器发送的心跳（默认情况下，每25秒发送一次），这意味着通常会在该时间段内（或更早，如果消息发送频率更高）检测到客户端断开连接。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">结果，由于客户端已断开连接，可能会发生网络I / O故障，这可能会在日志中填充不必要的堆栈跟踪。Spring会尽最大努力找出代表客户端断开连接（特定于每个服务器）的此类网络故障，并使用专用日志类别记录一条最小的消息， <code>DISCONNECTED_CLIENT_LOG_CATEGORY</code> （在<code>AbstractSockJsSession</code> ）。如果需要查看堆栈跟踪，可以将该日志类别设置为TRACE。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-cors"><a class="anchor" href="#websocket-fallback-cors"></a> 4.3.6。SockJS和CORS</h4>
<div class="paragraph">
<p>如果您允许跨域请求（请参阅<a href="#websocket-server-allowed-origins">Allowed Origins</a> ），则SockJS协议将CORS用于XHR流和轮询传输中的跨域支持。因此，除非在响应中检测到CORS标头的存在，否则将自动添加CORS标头。因此，如果已经将应用程序配置为提供CORS支持（例如，通过Servlet过滤器），那么Spring的<code>SockJsService</code>跳过这一部分。</p>
</div>
<div class="paragraph">
<p>也可以通过设置以下选项来禁止添加这些CORS标头<code>suppressCors</code> Spring的SockJsService中的属性。</p>
</div>
<div class="paragraph">
<p>SockJS需要以下标头和值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Access-Control-Allow-Origin</code> ：从的值初始化<code>Origin</code>请求标头。</p>
</li>
<li>
<p><code>Access-Control-Allow-Credentials</code> ：始终设置为<code>true</code> 。</p>
</li>
<li>
<p><code>Access-Control-Request-Headers</code> ：从等效请求标头中的值初始化。</p>
</li>
<li>
<p><code>Access-Control-Allow-Methods</code> ：传输支持的HTTP方法（请参阅<code>TransportType</code>枚举）。</p>
</li>
<li>
<p><code>Access-Control-Max-Age</code> ：设置为31536000（1年）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关确切的实现，请参见<code>addCorsHeaders</code>在<code>AbstractSockJsService</code>和<code>TransportType</code>枚举源代码。</p>
</div>
<div class="paragraph">
<p>另外，如果CORS配置允许，请考虑排除带有SockJS端点前缀的URL，从而让Spring的<code>SockJsService</code>处理它。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-fallback-sockjs-client"><a class="anchor" href="#websocket-fallback-sockjs-client"></a> 4.3.7。<code>SockJsClient</code></h4>
<div class="paragraph">
<p>Spring提供了一个SockJS Java客户端，无需使用浏览器即可连接到远程SockJS端点。当需要通过公用网络在两个服务器之间进行双向通信时（即，网络代理可能会阻止使用WebSocket协议），这特别有用。SockJS Java客户端对于测试目的也非常有用（例如，模拟大量并发用户）。</p>
</div>
<div class="paragraph">
<p>SockJS Java客户端支持<code>websocket</code> ， <code>xhr-streaming</code>和<code>xhr-polling</code>运输。其余的仅在浏览器中有意义。</p>
</div>
<div class="paragraph">
<p>您可以配置<code>WebSocketTransport</code>与：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StandardWebSocketClient</code>在JSR-356运行时中。</p>
</li>
<li>
<p><code>JettyWebSocketClient</code>通过使用Jetty 9+本机WebSocket API。</p>
</li>
<li>
<p>Spring的任何实现<code>WebSocketClient</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个<code>XhrTransport</code>从定义上讲，同时支持<code>xhr-streaming</code>和<code>xhr-polling</code> ，因为从客户端的角度来看，除了用于连接服务器的URL之外没有其他区别。当前有两种实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RestTemplateXhrTransport</code>使用Spring的<code>RestTemplate</code>用于HTTP请求。</p>
</li>
<li>
<p><code>JettyXhrTransport</code>使用码头的<code>HttpClient</code>用于HTTP请求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了如何创建SockJS客户端并连接到SockJS端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">List&lt;Transport&gt; transports = new ArrayList&lt;&gt;(2);
transports.add(new WebSocketTransport(new StandardWebSocketClient()));
transports.add(new RestTemplateXhrTransport());

SockJsClient sockJsClient = new SockJsClient(transports);
sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">SockJS对消息使用JSON格式的数组。默认情况下，使用Jackson 2，并且需要在类路径上。或者，您可以配置一个自定义实现<code>SockJsMessageCodec</code>并在<code>SockJsClient</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用<code>SockJsClient</code>为了模拟大量并发用户，您需要配置基础HTTP客户端（用于XHR传输）以允许足够数量的连接和线程。以下示例显示了如何使用Jetty进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了与服务器端SockJS相关的属性（有关详细信息，请参见javadoc），您还应考虑自定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/sockjs").withSockJS()
            .setStreamBytesLimit(512 * 1024) <i class="conum" data-value="1"></i><b>(1)</b>
            .setHttpMessageCacheSize(1000) <i class="conum" data-value="2"></i><b>(2)</b>
            .setDisconnectDelay(30 * 1000); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>设置<code>streamBytesLimit</code>属性为512KB（默认值为128KB — <code>128 * 1024</code> ）。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>设置<code>httpMessageCacheSize</code>属性设置为1,000（默认值为<code>100</code> ）。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>设置<code>disconnectDelay</code>属性设置为30个属性秒（默认值为5秒- <code>5 * 1000</code> ）。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket-stomp"><a class="anchor" href="#websocket-stomp"></a> 4.4。脚踩</h3>
<div class="paragraph">
<p>WebSocket协议定义了两种消息类型（文本消息和二进制消息），但是其内容未定义。该协议定义了一种机制，供客户端和服务器协商用于在WebSocket之上使用的子协议（即高级消息协议），以定义每种协议可以发送的消息类型，格式，内容。每个消息，依此类推。子协议的使用是可选的，但是无论哪种方式，客户端和服务器都需要就定义消息内容的某种协议达成共识。</p>
</div>
<div class="sect3">
<h4 id="websocket-stomp-overview"><a class="anchor" href="#websocket-stomp-overview"></a> 4.4.1。总览</h4>
<div class="paragraph">
<p><a href="https://stomp.github.io/stomp-specification-1.2.html#Abstract">STOMP</a> （面向简单文本的消息传递协议）最初是为脚本语言（如Ruby，Python和Perl）创建的，以连接到企业消息代理。它旨在解决常用消息传递模式的最小子集。STOMP可以在任何可靠的双向流网络协议上使用，例如TCP和WebSocket。尽管STOMP是面向文本的协议，但是消息有效负载可以是文本或二进制。</p>
</div>
<div class="paragraph">
<p>STOMP是基于帧的协议，其帧以HTTP为模型。以下清单显示了STOMP帧的结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>COMMAND
header1:value1
header2:value2

Body^@</pre>
</div>
</div>
<div class="paragraph">
<p>客户可以使用<code>SEND</code>要么<code>SUBSCRIBE</code>发送或订阅消息的命令以及<code>destination</code>标头，描述邮件的内容以及应由谁接收。这启用了一种简单的发布-订阅机制，您可以使用该机制通过代理将消息发送到其他连接的客户端，或者将消息发送到服务器以请求执行某些工作。</p>
</div>
<div class="paragraph">
<p>当您使用Spring的STOMP支持时，Spring WebSocket应用程序将充当客户端的STOMP代理。邮件被路由到<code>@Controller</code>消息处理方法或简单的内存代理，该代理跟踪订阅并向订阅的用户广播消息。您还可以将Spring配置为与专用的STOMP代理（例如RabbitMQ，ActiveMQ等）一起使用，以实际广播消息。在那种情况下，Spring维护与代理的TCP连接，将消息中继到该代理，并将消息从该代理向下传递到已连接的WebSocket客户端。因此，Spring Web应用程序可以依靠基于HTTP的统一安全性，通用验证以及用于消息处理的熟悉的编程模型。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个订阅以接收股票报价的客户端，服务器可能会定期发出该股票报价（例如，通过计划任务，该任务通过<code>SimpMessagingTemplate</code>给经纪人）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了一个客户端发送的交易请求，服务器可以通过<code>@MessageMapping</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@</pre>
</div>
</div>
<div class="paragraph">
<p>执行后，服务器可以向客户广播交易确认消息和详细信息。</p>
</div>
<div class="paragraph">
<p>在STOMP规范中，目的地的含义是故意不透明的。它可以是任何字符串，并且完全由STOMP服务器定义它们所支持的目的地的语义和语法。但是，目的地通常是类似路径的字符串，其中<code>/topic/..</code>表示发布-订阅（一对多），并且<code>/queue/</code>意味着点对点（一对一）消息交换。</p>
</div>
<div class="paragraph">
<p>STOMP服务器可以使用<code>MESSAGE</code>命令向所有订户广播消息。以下示例显示了服务器向订阅的客户端发送股票报价的服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@</pre>
</div>
</div>
<div class="paragraph">
<p>服务器无法发送未经请求的消息。来自服务器的所有消息都必须响应特定的客户端订阅，并且<code>subscription-id</code>服务器消息的标头必须与<code>id</code>客户端订阅的标头。</p>
</div>
<div class="paragraph">
<p>前面的概述旨在提供对STOMP协议的最基本的了解。我们建议您全面阅读协议<a href="https://stomp.github.io/stomp-specification-1.2.html">规范</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-benefits"><a class="anchor" href="#websocket-stomp-benefits"></a> 4.4.2。好处</h4>
<div class="paragraph">
<p>与使用原始WebSocket相比，使用STOMP作为子协议可以使Spring Framework和Spring Security提供更丰富的编程模型。关于HTTP与原始TCP以及它如何使Spring MVC和其他Web框架提供丰富的功能，可以得出相同的观点。以下是好处列表：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无需发明自定义消息协议和消息格式。</p>
</li>
<li>
<p>可以使用STOMP客户端，包括Spring Framework 中的<a href="#websocket-stomp-client">Java客户端</a> 。</p>
</li>
<li>
<p>您可以（可选）使用消息代理（例如RabbitMQ，ActiveMQ和其他代理）来管理订阅和广播消息。</p>
</li>
<li>
<p>应用程序逻辑可以以任何数量的形式组织<code>@Controller</code>实例和消息可以基于STOMP目标标头路由到它们，而不是通过单个处理原始WebSocket消息<code>WebSocketHandler</code>对于给定的连接。</p>
</li>
<li>
<p>您可以使用Spring Security基于STOMP目的地和消息类型来保护消息。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-enable"><a class="anchor" href="#websocket-stomp-enable"></a> 4.4.3。启用STOMP</h4>
<div class="paragraph">
<p>WebSocket中的STOMP over WebSocket支持在<code>spring-messaging</code>和<code>spring-websocket</code>模块。一旦有了这些依赖关系，就可以使用<a href="#websocket-fallback">SockJS Fallback</a>通过WebSocket公开STOMP端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();  <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.setApplicationDestinationPrefixes("/app"); <i class="conum" data-value="2"></i><b>(2)</b>
        config.enableSimpleBroker("/topic", "/queue"); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td><code>/portfolio</code>是WebSocket（或SockJS）客户端需要连接到WebSocket握手的终结点的HTTP URL。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>STOMP邮件，其目标标头以<code>/app</code>被路由到<code>@MessageMapping</code>方法中<code>@Controller</code>类。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>使用内置的消息代理进行订阅和广播，以及路由目标标头以其开头的消息<code>/topic `or `/queue</code>给经纪人。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:message-broker application-destination-prefix="/app"&gt;
        &lt;websocket:stomp-endpoint path="/portfolio"&gt;
            &lt;websocket:sockjs/&gt;
        &lt;/websocket:stomp-endpoint&gt;
        &lt;websocket:simple-broker prefix="/topic, /queue"/&gt;
    &lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于内置的简单经纪人， <code>/topic</code>和<code>/queue</code>前缀没有任何特殊含义。它们仅是区分发布订阅与点对点消息传递（即许多订户与一个消费者）的约定。使用外部代理时，请检查代理的STOMP页面以了解其支持哪种STOMP目标和前缀。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要通过浏览器进行连接，对于SockJS，您可以使用<a href="https://github.com/sockjs/sockjs-client"><code>sockjs-client</code></a> 。对于STOMP，许多应用程序都使用了<a href="https://github.com/jmesnil/stomp-websocket">jmesnil / stomp-websocket</a>库（也称为stomp.js），该库功能齐全，已在生产中使用多年，但不再维护。目前， <a href="https://github.com/JSteunou/webstomp-client">JSteunou / webstomp-client</a>是该库中最活跃且发展最快的后继程序。以下示例代码基于此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var socket = new SockJS("/spring-websocket-portfolio/portfolio");
var stompClient = webstomp.over(socket);

stompClient.connect({}, function(frame) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果您通过WebSocket（没有SockJS）进行连接，则可以使用以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var socket = new WebSocket("/spring-websocket-portfolio/portfolio");
var stompClient = Stomp.over(socket);

stompClient.connect({}, function(frame) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>stompClient</code>在前面的示例中不需要指定<code>login</code>和<code>passcode</code>标头。即使这样做，它们也会在服务器端被忽略（或更确切地说，被覆盖）。有关<a href="#websocket-stomp-authentication">身份验证</a>的更多信息，请参见<a href="#websocket-stomp-handle-broker-relay-configure">连接到代理</a>和<a href="#websocket-stomp-authentication">身份</a>验证。</p>
</div>
<div class="paragraph">
<p>有关更多示例代码，请参见：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/guides/gs/messaging-stomp-websocket/">使用WebSocket构建交互式Web应用程序</a> -入门指南。</p>
</li>
<li>
<p><a href="https://github.com/rstoyanchev/spring-websocket-portfolio">股票投资组合</a> —一个示例应用程序。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-server-config"><a class="anchor" href="#websocket-stomp-server-config"></a> 4.4.4。WebSocket服务器</h4>
<div class="paragraph">
<p>要配置基础的WebSocket服务器，请应用“ <a href="#websocket-server-runtime-configuration">服务器配置”中</a>的信息。对于码头，但是您需要设置<code>HandshakeHandler</code>和<code>WebSocketPolicy</code>通过<code>StompEndpointRegistry</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").setHandshakeHandler(handshakeHandler());
    }

    @Bean
    public DefaultHandshakeHandler handshakeHandler() {

        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
        policy.setInputBufferSize(8192);
        policy.setIdleTimeout(600000);

        return new DefaultHandshakeHandler(
                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-message-flow"><a class="anchor" href="#websocket-stomp-message-flow"></a> 4.4.5。消息流</h4>
<div class="paragraph">
<p>暴露了STOMP端点后，Spring应用程序将成为已连接客户端的STOMP代理。本节描述服务器端的消息流。</p>
</div>
<div class="paragraph">
<p>的<code>spring-messaging</code>该模块包含对起源于<a href="https://spring.io/spring-integration">Spring Integration的</a>消息传递应用程序的基础支持，后来被提取并合并到Spring Framework中，以在许多<a href="https://spring.io/projects">Spring项目</a>和应用程序场景中更广泛地使用。下面的列表简要描述了一些可用的消息传递抽象：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/Message.html">消息</a> ： <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/Message.html">消息的</a>简单表示，包括标题和有效负载。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html">MessageHandler</a> ：处理消息的合同。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/MessageChannel.html">MessageChannel</a> ：用于发送使生产者和消费者之间松散耦合的消息的合同。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/SubscribableChannel.html">SubscribableChannel</a> ： <code>MessageChannel</code>与<code>MessageHandler</code>订阅者。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html">ExecutorSubscribableChannel</a> ： <code>SubscribableChannel</code>使用一个<code>Executor</code>用于传递消息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两者都是Java配置（即<code>@EnableWebSocketMessageBroker</code> ）和XML名称空间配置（即， <code><websocket:message-broker></code> ）使用前面的组件来组装消息工作流程。下图显示了启用简单内置消息代理时使用的组件：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message-flow-simple-broker.png" alt="消息流简单代理">
</div>
</div>
<div class="paragraph">
<p>上图显示了三个消息通道：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientInboundChannel</code> ：用于传递从WebSocket客户端收到的消息。</p>
</li>
<li>
<p><code>clientOutboundChannel</code> ：用于向WebSocket客户端发送服务器消息。</p>
</li>
<li>
<p><code>brokerChannel</code> ：用于从服务器端应用程序代码内将消息发送到消息代理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下图显示了将外部代理（例如RabbitMQ）配置为用于管理订阅和广播消息时使用的组件：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/message-flow-broker-relay.png" alt="消息流代理中继">
</div>
</div>
<div class="paragraph">
<p>前面两个图之间的主要区别是使用“代理中继”将消息通过TCP传递到外部STOMP代理，以及将消息从代理传递到订阅的客户端。</p>
</div>
<div class="paragraph">
<p>当从WebSocket连接接收到消息时，它们被解码为STOMP帧，变成Spring <code>Message</code>表示，并发送到<code>clientInboundChannel</code>进行进一步处理。例如，目标标题以STOMP开头的消息<code>/app</code>可能会路由到<code>@MessageMapping</code>带注释的控制器中的方法，而<code>/topic</code>和<code>/queue</code>消息可以直接路由到消息代理。</p>
</div>
<div class="paragraph">
<p>一个带注释的<code>@Controller</code>处理来自客户端的STOMP消息的消息可能会通过<code>brokerChannel</code> ，然后经纪人通过将该消息广播给匹配的订户<code>clientOutboundChannel</code> 。相同的控制器还可以响应HTTP请求执行相同的操作，因此客户端可以执行HTTP POST，然后执行<code>@PostMapping</code>方法可以将消息发送到消息代理，以广播到订阅的客户端。</p>
</div>
<div class="paragraph">
<p>我们可以通过一个简单的示例跟踪流程。考虑以下示例，该示例设置了服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
    }
}

@Controller
public class GreetingController {

    @MessageMapping("/greeting") {
    public String handle(String greeting) {
        return "[" + getTimestamp() + ": " + greeting;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例支持以下流程：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端连接到<code><a href="http://localhost:8080/portfolio" class="bare">http://localhost:8080/portfolio</a></code>并且，一旦建立了WebSocket连接，STOMP帧就开始在其上流动。</p>
</li>
<li>
<p>客户端发送SUBSCRIBE帧，其目标标头为<code>/topic/greeting</code> 。收到并解码后，消息将发送到<code>clientInboundChannel</code>然后路由到消息代理，该代理存储客户端订阅。</p>
</li>
<li>
<p>客户端发送一个aSEND帧到<code>/app/greeting</code> 。的<code>/app</code>前缀有助于将其路由到带注释的控制器。之后<code>/app</code>前缀被剥离，其余<code>/greeting</code>目标的一部分已映射到<code>@MessageMapping</code>方法中<code>GreetingController</code> 。</p>
</li>
<li>
<p>从返回的值<code>GreetingController</code>变成了春天<code>Message</code>有效载荷基于返回值和默认目标标头为<code>/topic/greeting</code> （来自输入目标，带有<code>/app</code>取而代之<code>/topic</code> ）。结果消息发送到<code>brokerChannel</code>并由消息代理处理。</p>
</li>
<li>
<p>消息代理查找所有匹配的订户，并通过以下方式向每个发送一个MESSAGE帧<code>clientOutboundChannel</code> ，从中将消息编码为STOMP帧，并通过WebSocket连接发送消息。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下一节将提供有关带注释方法的更多详细信息，包括支持的参数类型和返回值。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-annotations"><a class="anchor" href="#websocket-stomp-handle-annotations"></a> 4.4.6。带注释的控制器</h4>
<div class="paragraph">
<p>应用程序可以使用带注释的<code>@Controller</code>用于处理来自客户端的消息的类。这样的类可以声明<code>@MessageMapping</code> ， <code>@SubscribeMapping</code>和<code>@ExceptionHandler</code>方法，如以下主题所述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#websocket-stomp-message-mapping"><code>@MessageMapping</code></a></p>
</li>
<li>
<p><a href="#websocket-stomp-subscribe-mapping"><code>@SubscribeMapping</code></a></p>
</li>
<li>
<p><a href="#websocket-stomp-exception-handler"><code>@MessageExceptionHandler</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="websocket-stomp-message-mapping"><a class="anchor" href="#websocket-stomp-message-mapping"></a><code>@MessageMapping</code></h5>
<div class="paragraph">
<p>您可以使用<code>@MessageMapping</code>注释根据消息的目的地路由消息的方法。在方法级别和类型级别都支持它。在类型级别， <code>@MessageMapping</code>用于表示控制器中所有方法之间的共享映射。</p>
</div>
<div class="paragraph">
<p>默认情况下，映射值是Ant样式的路径模式（例如<code>/thing*</code> ， <code>/thing/**</code> ），包括对模板变量的支持（例如， <code>/thing/{id}</code> ）。可以通过以下方式引用这些值<code>@DestinationVariable</code>方法参数。应用程序还可以切换到以点分隔的映射目标约定，如“ <a href="#websocket-stomp-destination-separator">作为分隔符的点”中所述</a> 。</p>
</div>
<div class="sect5">
<h6 id="supported-method-arguments"><a class="anchor" href="#supported-method-arguments"></a>支持的方法参数</h6>
<div class="paragraph">
<p>下表描述了方法参数：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width:33.3333%">
<col style="width:66.6667%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法参数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Message</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问完整的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问标题中的<code>Message</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageHeaderAccessor</code> ， <code>SimpMessageHeaderAccessor</code>和<code>StompHeaderAccessor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于通过类型化访问器方法访问标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为了访问消息的有效负载，由配置者转换（例如，从JSON） <code>MessageConverter</code> 。
</p><p class="tableblock">不需要此注释，因为默认情况下会假定没有其他自变量匹配。
</p><p class="tableblock">您可以使用以下方式注释有效负载参数<code>@javax.validation.Valid</code>或春天的<code>@Validated</code> ，以自动验证有效载荷参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Header</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问特定的标头值-以及使用<code>org.springframework.core.convert.converter.Converter</code> ，如有必要。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Headers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问消息中的所有标题。此参数必须可分配给<code>java.util.Map</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DestinationVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问从消息目标中提取的模板变量。根据需要将值转换为声明的方法参数类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">反映在WebSocket HTTP握手时登录的用户。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="return-values"><a class="anchor" href="#return-values"></a>返回值</h6>
<div class="paragraph">
<p>默认情况下， <code>@MessageMapping</code>通过匹配将方法序列化为有效负载<code>MessageConverter</code>并以<code>Message</code>到<code>brokerChannel</code> ，从那里广播给订户。出站邮件的目的地与入站邮件的目的地相同，但前缀为<code>/topic</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@SendTo</code>和<code>@SendToUser</code>批注以定制输出消息的目标。 <code>@SendTo</code>用于自定义目标目的地或指定多个目的地。 <code>@SendToUser</code>用于将输出消息定向到仅与输入消息关联的用户。请参阅<a href="#websocket-stomp-user-destination">用户目的地</a> 。</p>
</div>
<div class="paragraph">
<p>您可以同时使用<code>@SendTo</code>和<code>@SendToUser</code>同时在同一方法上使用，并且两者都在类级别受支持，在这种情况下，它们充当类中方法的默认值。但是，请记住，任何方法级别<code>@SendTo</code>要么<code>@SendToUser</code>注释会在类级别覆盖所有此类注释。</p>
</div>
<div class="paragraph">
<p>消息可以异步处理，并且<code>@MessageMapping</code>方法可以返回<code>ListenableFuture</code> ， <code>CompletableFuture</code> ， 要么<code>CompletionStage</code> 。</p>
</div>
<div class="paragraph">
<p>注意<code>@SendTo</code>和<code>@SendToUser</code>仅仅是一种便利，等同于使用<code>SimpMessagingTemplate</code>发送消息。如有必要，对于更高级的方案， <code>@MessageMapping</code>方法可以依靠<code>SimpMessagingTemplate</code>直。可以代替返回值，也可以添加返回值。请参阅<a href="#websocket-stomp-handle-send">发送消息</a> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-stomp-subscribe-mapping"><a class="anchor" href="#websocket-stomp-subscribe-mapping"></a><code>@SubscribeMapping</code></h5>
<div class="paragraph">
<p><code>@SubscribeMapping</code>类似于<code>@MessageMapping</code>但将映射范围缩小到仅订阅消息。它支持与以下<a href="#websocket-stomp-message-mapping">方法</a>相同的<a href="#websocket-stomp-message-mapping">方法参数</a> <code>@MessageMapping</code> 。但是，对于返回值，默认情况下，消息会直接发送到客户端（通过<code>clientOutboundChannel</code> ，以响应订阅）而不是代理（通过<code>brokerChannel</code> ，作为对匹配订阅的广播）。新增中<code>@SendTo</code>要么<code>@SendToUser</code>覆盖此行为，而是发送给代理。</p>
</div>
<div class="paragraph">
<p>什么时候有用？假定代理已映射到<code>/topic</code>和<code>/queue</code> ，而应用程序控制器映射到<code>/app</code> 。在此设置中，代理将所有订阅存储到<code>/topic</code>和<code>/queue</code>旨在进行重复广播，并且不需要该应用程序参与其中。客户也可以订阅一些<code>/app</code>目的地，并且控制器可以响应该预订而返回一个值，而无需经纪人，而无需再次存储或使用该预订（实际上是一次请求-答复交换）。一个用例是在启动时用初始数据填充UI。</p>
</div>
<div class="paragraph">
<p>什么时候没有用？不要尝试将代理和控制器映射到相同的目标前缀，除非出于某种原因您希望两者都独立处理消息（包括订阅）。入站消息是并行处理的。无法保证经纪人还是控制者首先处理给定的消息。如果要在存储预订并准备好广播时通知目标，则客户端应请求服务器是否支持收据（简单代理不支持）。例如，对于Java <a href="#websocket-stomp-client">STOMP客户端</a> ，您可以执行以下操作添加收据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Autowired
private TaskScheduler messageBrokerTaskScheduler;

// During initialization..
stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

// When subscribing..
StompHeaders headers = new StompHeaders();
headers.setDestination("/topic/...");
headers.setReceipt("r1");
FrameHandler handler = ...;
stompSession.subscribe(headers, handler).addReceiptTask(() -&gt; {
    // Subscription ready...
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>服务器端选项是<a href="#websocket-stomp-interceptors">注册</a>一个<code>ExecutorChannelInterceptor</code>在<code>brokerChannel</code>并实施<code>afterMessageHandled</code>在处理包括订阅在内的消息之后调用的方法。</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-stomp-exception-handler"><a class="anchor" href="#websocket-stomp-exception-handler"></a><code>@MessageExceptionHandler</code></h5>
<div class="paragraph">
<p>应用程序可以使用<code>@MessageExceptionHandler</code>处理来自以下对象的异常的方法<code>@MessageMapping</code>方法。如果要访问异常实例，则可以在批注本身中声明异常，也可以通过方法参数声明异常。以下示例通过方法参数声明异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

    // ...

    @MessageExceptionHandler
    public ApplicationError handleException(MyException exception) {
        // ...
        return appError;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@MessageExceptionHandler</code>方法支持灵活的方法签名，并支持与以下方法相同的方法参数类型和返回值<a href="#websocket-stomp-message-mapping"><code>@MessageMapping</code></a>方法。</p>
</div>
<div class="paragraph">
<p>通常， <code>@MessageExceptionHandler</code>方法适用于<code>@Controller</code>声明它们的类（或类层次结构）。如果您希望此类方法在全局范围内（跨控制器）应用，则可以在标有的类中声明它们<code>@ControllerAdvice</code> 。这与Spring MVC中可用的<a href="#mvc-ann-controller-advice">类似支持</a>相当。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-send"><a class="anchor" href="#websocket-stomp-handle-send"></a> 4.4.7。传送讯息</h4>
<div class="paragraph">
<p>如果要从应用程序的任何部分向连接的客户端发送消息怎么办？任何应用程序组件都可以将消息发送到<code>brokerChannel</code> 。最简单的方法是注入一个<code>SimpMessagingTemplate</code>并使用它发送消息。通常，您将按类型注入它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class GreetingController {

    private SimpMessagingTemplate template;

    @Autowired
    public GreetingController(SimpMessagingTemplate template) {
        this.template = template;
    }

    @RequestMapping(path="/greetings", method=POST)
    public void greet(String greeting) {
        String text = "[" + getTimestamp() + "]:" + greeting;
        this.template.convertAndSend("/topic/greetings", text);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您也可以通过其名称限定其名称（ <code>brokerMessagingTemplate</code> ），如果存在另一个相同类型的bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-simple-broker"><a class="anchor" href="#websocket-stomp-handle-simple-broker"></a> 4.4.8。简单经纪人</h4>
<div class="paragraph">
<p>内置的简单消息代理处理来自客户端的订阅请求，将其存储在内存中，并将消息广播到具有匹配目标的已连接客户端。该代理支持类似路径的目标，包括对Ant样式目标模式的订阅。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">应用程序还可以使用点分隔（而不是斜杠分隔）目标。请参见<a href="#websocket-stomp-destination-separator">点作为分隔符</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果配置了任务调度程序，则简单代理支持<a href="https://stomp.github.io/stomp-specification-1.2.html#Heart-beating">STOMP心跳</a> 。为此，您可以声明自己的调度程序，也可以使用内部自动声明和使用的调度程序。以下示例显示如何声明自己的调度程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    private TaskScheduler messageBrokerTaskScheduler;

    @Autowired
    public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) {
        this.messageBrokerTaskScheduler = taskScheduler;
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {

        registry.enableSimpleBroker("/queue/", "/topic/")
                .setHeartbeatValue(new long[] {10000, 20000})
                .setTaskScheduler(this.messageBrokerTaskScheduler);

        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-broker-relay"><a class="anchor" href="#websocket-stomp-handle-broker-relay"></a> 4.4.9。外部经纪人</h4>
<div class="paragraph">
<p>简单代理非常适合入门，但仅支持STOMP命令的子集（它不支持ack，回执和其他一些功能），依赖于简单的消息发送循环，并且不适合于集群。或者，您可以升级应用程序以使用功能齐全的消息代理。</p>
</div>
<div class="paragraph">
<p>请参阅STOMP文档以了解您选择的消息代理（例如<a href="https://www.rabbitmq.com/stomp.html">RabbitMQ</a> ， <a href="https://activemq.apache.org/stomp.html">ActiveMQ</a>等），安装代理，并在启用STOMP支持的情况下运行它。然后，您可以在Spring配置中启用STOMP代理中继（而不是简单代理）。</p>
</div>
<div class="paragraph">
<p>以下示例配置启用了功能齐全的代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/topic", "/queue");
        registry.setApplicationDestinationPrefixes("/app");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:message-broker application-destination-prefix="/app"&gt;
        &lt;websocket:stomp-endpoint path="/portfolio" /&gt;
            &lt;websocket:sockjs/&gt;
        &lt;/websocket:stomp-endpoint&gt;
        &lt;websocket:stomp-broker-relay prefix="/topic,/queue" /&gt;
    &lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>先前配置中的STOMP代理中继是Spring <a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html"><code>MessageHandler</code></a>通过将消息转发到外部消息代理来处理消息。为此，它建立到代理的TCP连接，将所有消息转发给它，然后通过它们的WebSocket会话将从代理收到的所有消息转发给客户端。本质上，它充当双向转发消息的“中继”。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">加<code>io.projectreactor.netty:reactor-netty</code>和<code>io.netty:netty-all</code> TCP连接管理对项目的依赖关系。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此外，应用程序组件（例如HTTP请求处理方法，业务服务等）也可以将消息发送到代理中继，如“ <a href="#websocket-stomp-handle-send">发送消息”中所述</a> ，以将消息广播到订阅的WebSocket客户端。</p>
</div>
<div class="paragraph">
<p>实际上，代理中继可实现健壮且可伸缩的消息广播。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-handle-broker-relay-configure"><a class="anchor" href="#websocket-stomp-handle-broker-relay-configure"></a> 4.4.10。连接到经纪人</h4>
<div class="paragraph">
<p>STOMP代理中继器维护与代理的单个“系统” TCP连接。此连接仅用于源自服务器端应用程序的消息，而不用于接收消息。您可以配置STOMP凭据（即STOMP框架<code>login</code>和<code>passcode</code>标头）。这在XML名称空间和Java配置中都公开为<code>systemLogin</code>和<code>systemPasscode</code>默认值为的属性<code>guest</code>和<code>guest</code> 。</p>
</div>
<div class="paragraph">
<p>STOMP代理中继还为每个连接的WebSocket客户端创建一个单独的TCP连接。您可以配置用于代表客户端创建的所有TCP连接的STOMP凭据。这在XML名称空间和Java配置中都公开为<code>clientLogin and `clientPasscode</code>默认值为的属性<code>guest`and `guest</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">STOMP代理中继始终将<code>login</code>和<code>passcode</code>每个标题<code>CONNECT</code>代表客户转发给经纪人的框架。因此，WebSocket客户端无需设置这些标头。他们被忽略。如“ <a href="#websocket-stomp-authentication">身份验证”</a>部分所述，WebSocket客户端应改为依靠HTTP身份验证来保护WebSocket端点并建立客户端身份。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>STOMP代理中继还通过“系统” TCP连接向消息代理发送和从消息代理接收心跳。您可以配置发送和接收心跳的间隔（默认情况下，每个间隔为10秒）。如果与代理的连接断开，则代理中继每5秒继续尝试重新连接，直到成功。</p>
</div>
<div class="paragraph">
<p>任何Spring bean都可以实现<code>ApplicationListener<BrokerAvailabilityEvent></code>在与代理的“系统”连接丢失并重新建立时接收通知。例如，当没有活动的“系统”连接时，广播股票报价的股票报价服务可以停止尝试发送消息。</p>
</div>
<div class="paragraph">
<p>默认情况下，STOMP代理中继始终连接到同一主机和端口，如果连接断开，则根据需要重新连接。如果希望提供多个地址，则在每次尝试连接时，都可以配置地址供应商，而不是固定的主机和端口。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
        registry.setApplicationDestinationPrefixes("/app");
    }

    private ReactorNettyTcpClient&lt;byte[]&gt; createTcpClient() {
        return new ReactorNettyTcpClient&lt;&gt;(
                client -&gt; client.addressSupplier(() -&gt; ... ),
                new StompReactorNettyCodec());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用以下命令配置STOMP代理中继<code>virtualHost</code>属性。此属性的值设置为<code>host</code>每个标题<code>CONNECT</code>框架，并且很有用（例如，在建立TCP连接的实际主机与提供基于云的STOMP服务的主机不同的云环境中）。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-destination-separator"><a class="anchor" href="#websocket-stomp-destination-separator"></a> 4.4.11。点作为分隔符</h4>
<div class="paragraph">
<p>邮件路由到时<code>@MessageMapping</code>方法，它们与<code>AntPathMatcher</code> 。默认情况下，模式应使用斜杠（ <code>/</code> ）作为分隔符。这是Web应用程序中的一个良好约定，类似于HTTP URL。但是，如果您更习惯于消息传递约定，则可以切换到使用点（ <code>.</code> ）作为分隔符。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Java配置中执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setPathMatcher(new AntPathMatcher("."));
        registry.enableStompBrokerRelay("/queue", "/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:websocket="http://www.springframework.org/schema/websocket"
        xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                https://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/websocket
                https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher"&gt;
        &lt;websocket:stomp-endpoint path="/stomp"/&gt;
        &lt;websocket:stomp-broker-relay prefix="/topic,/queue" /&gt;
    &lt;/websocket:message-broker&gt;

    &lt;bean id="pathMatcher" class="org.springframework.util.AntPathMatcher"&gt;
        &lt;constructor-arg index="0" value="."/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，控制器可以使用点（ <code>.</code> ）作为分隔符<code>@MessageMapping</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@MessageMapping("red")
public class RedController {

    @MessageMapping("blue.{green}")
    public void handleGreen(@DestinationVariable String green) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户端现在可以将消息发送到<code>/app/red.blue.green123</code> 。</p>
</div>
<div class="paragraph">
<p>在前面的示例中，我们没有更改“代理中继”上的前缀，因为这些前缀完全取决于外部消息代理。有关您使用的代理的信息，请参见STOMP文档页面，以查看其对目标标头支持的约定。</p>
</div>
<div class="paragraph">
<p>另一方面，“简单代理”确实依赖于已配置<code>PathMatcher</code> ，因此，如果切换分隔符，则此更改也将应用于代理，以及代理将目标从消息匹配到订阅中的模式的方式。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-authentication"><a class="anchor" href="#websocket-stomp-authentication"></a> 4.4.12。认证方式</h4>
<div class="paragraph">
<p>每个通过WebSocket进行的STOMP消息传递会话均以HTTP请求开头。这可以是升级到WebSockets的请求（即WebSocket握手），或者在SockJS后备情况下，是一系列SockJS HTTP传输请求。</p>
</div>
<div class="paragraph">
<p>许多Web应用程序已经具有身份验证和授权来保护HTTP请求。通常，使用某种机制（例如登录页面，HTTP基本认证或其他方式）通过Spring Security对用户进行认证。经过身份验证的用户的安全上下文保存在HTTP会话中，并与同一基于cookie的会话中的后续请求关联。</p>
</div>
<div class="paragraph">
<p>因此，对于WebSocket握手或SockJS HTTP传输请求，通常已经有一个通过身份验证的用户可以访问<code>HttpServletRequest#getUserPrincipal()</code> 。Spring会自动将该用户与为其创建的WebSocket或SockJS会话相关联，并随后与该会话中通过用户标头传输的所有STOMP消息相关联。</p>
</div>
<div class="paragraph">
<p>简而言之，典型的Web应用程序除了已经为安全起见，就不需要采取任何其他措施。通过基于Cookie的HTTP会话（然后与为该用户创建的WebSocket或SockJS会话相关联）维护的安全上下文在HTTP请求级别对用户进行身份验证，并导致在每个<code>Message</code>流经应用程序。</p>
</div>
<div class="paragraph">
<p>请注意，STOMP协议确实具有<code>login</code>和<code>passcode</code>标头<code>CONNECT</code>帧。这些最初是设计用于并且仍然需要的，例如，基于TCP的STOMP。但是，对于默认情况下，对于基于WebSocket的STOMP，Spring会在STOMP协议级别忽略授权标头，并假定该用户已经在HTTP传输级别进行了身份验证，并期望WebSocket或SockJS会话包含已通过身份验证的用户。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Security提供了<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket">WebSocket子协议授权</a> ，该<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket">授权</a>使用<code>ChannelInterceptor</code>根据邮件中的用户标头授权邮件。另外，Spring Session提供了<a href="https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket">WebSocket集成</a> ，可确保在WebSocket会话仍处于活动状态时，用户HTTP会话不会过期。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-authentication-token-based"><a class="anchor" href="#websocket-stomp-authentication-token-based"></a> 4.4.13。令牌认证</h4>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-security-oauth">Spring Security OAuth</a>支持基于令牌的安全性，包括JSON Web令牌（JWT）。可以将其用作Web应用程序中的身份验证机制，包括上一节中所述的WebSocket交互中的STOMP（即，通过基于cookie的会话维护身份）。</p>
</div>
<div class="paragraph">
<p>同时，基于cookie的会话并非总是最合适的（例如，在不维护服务器端会话的应用程序中或在通常使用标头进行身份验证的移动应用程序中）。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc6455#section-10.5">WebSocket协议RFC 6455</a> “没有规定服务器在WebSocket握手期间可以对客户端进行身份验证的任何特定方式。”但是，实际上，浏览器客户端只能使用标准身份验证标头（即基本HTTP身份验证）或cookie，而不能（例如）提供自定义标头。同样，SockJS JavaScript客户端也不提供通过SockJS传输请求发送HTTP标头的方法。请参阅<a href="https://github.com/sockjs/sockjs-client/issues/196">sockjs-client问题196</a> 。相反，它确实允许发送可用于发送令牌的查询参数，但这有其自身的缺点（例如，令牌可能会无意中与服务器日志中的URL一起记录）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的限制适用于基于浏览器的客户端，不适用于基于Spring Java的STOMP客户端，该客户端支持通过WebSocket和SockJS请求发送标头。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>因此，希望避免使用cookie的应用程序可能没有在HTTP协议级别进行身份验证的任何好的替代方法。他们可能更喜欢在STOMP消息传递协议级别使用标头进行身份验证，而不是使用Cookie。这样做需要两个简单的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用STOMP客户端在连接时传递身份验证头。</p>
</li>
<li>
<p>使用以下命令处理身份验证标头<code>ChannelInterceptor</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下一个示例使用服务器端配置来注册自定义身份验证拦截器。请注意，拦截器仅需要认证并在CONNECT上设置用户标头<code>Message</code> 。Spring记录并保存经过身份验证的用户，并将其与同一会话上的后续STOMP消息相关联。以下示例显示了如何注册自定义身份验证拦截器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {
                StompHeaderAccessor accessor =
                        MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    Authentication user = ... ; // access authentication header(s)
                    accessor.setUser(user);
                }
                return message;
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，请注意，目前，当您使用Spring Security的消息授权时，需要确保身份验证<code>ChannelInterceptor</code> config在Spring Security之前订购。最好通过在其自己的实现中声明自定义拦截器来完成此操作<code>WebSocketMessageBrokerConfigurer</code>标有<code>@Order(Ordered.HIGHEST_PRECEDENCE + 99)</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-user-destination"><a class="anchor" href="#websocket-stomp-user-destination"></a> 4.4.14。用户目的地</h4>
<div class="paragraph">
<p>应用程序可以发送针对特定用户的消息，Spring的STOMP支持可识别以前缀的目标<code>/user/</code>以此目的。例如，客户可能订阅了<code>/user/queue/position-updates</code>目的地。该目的地由<code>UserDestinationMessageHandler</code>并转换为用户会话唯一的目标（例如<code>/queue/position-updates-user123</code> ）。这提供了订阅通用命名目的地的便利，同时确保与订阅相同目的地的其他用户不发生冲突，以便每个用户都可以接收唯一的库存头寸更新。</p>
</div>
<div class="paragraph">
<p>在发送方，可以将邮件发送到目的地，例如<code>/user/{username}/queue/position-updates</code> ，然后由<code>UserDestinationMessageHandler</code>进入一个或多个目的地，与用户关联的每个会话一个。这样，应用程序中的任何组件都可以发送针对特定用户的消息，而不必知道他们的姓名和通用目的地。注释和消息传递模板也支持此功能。</p>
</div>
<div class="paragraph">
<p>消息处理方法可以通过与<code>@SendToUser</code>注释（在类级别上也支持共享公共目标），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class PortfolioController {

    @MessageMapping("/trade")
    @SendToUser("/queue/position-updates")
    public TradeResult executeTrade(Trade trade, Principal principal) {
        // ...
        return tradeResult;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果用户有多个会话，则默认情况下，所有订阅给定目标的会话都是目标。但是，有时可能仅需要将发送正在处理的消息的会话作为目标。您可以通过设置<code>broadcast</code>属性设置为false，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

    @MessageMapping("/action")
    public void handleAction() throws Exception{
        // raise MyBusinessException here
    }

    @MessageExceptionHandler
    @SendToUser(destinations="/queue/errors", broadcast=false)
    public ApplicationError handleException(MyBusinessException exception) {
        // ...
        return appError;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管用户目的地通常暗指经过身份验证的用户，但这并不是严格要求的。不与已认证用户关联的WebSocket会话可以订阅用户目的地。在这种情况下， <code>@SendToUser</code>注释的行为与<code>broadcast=false</code> （也就是说，仅定位到发送正在处理的消息的会话）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以从任何应用程序组件向用户目标发送消息，例如，注入<code>SimpMessagingTemplate</code>由Java配置或XML名称空间创建。（bean的名称是<code>"brokerMessagingTemplate"</code>如果要求具备<code>@Qualifier</code> ）以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class TradeServiceImpl implements TradeService {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    // ...

    public void afterTradeExecuted(Trade trade) {
        this.messagingTemplate.convertAndSendToUser(
                trade.getUserName(), "/queue/position-updates", trade.getResult());
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">将用户目标与外部消息代理一起使用时，应查看代理文档以了解如何管理非活动队列，以便在用户会话结束时，将删除所有唯一的用户队列。例如，当您使用目的地时，RabbitMQ将创建自动删除队列，例如<code>/exchange/amq.direct/position-updates</code> 。因此，在这种情况下，客户端可以订阅<code>/user/exchange/amq.direct/position-updates</code> 。同样，ActiveMQ具有用于清除非活动目标的<a href="https://activemq.apache.org/delete-inactive-destinations.html">配置选项</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在多应用程序服务器方案中，由于用户连接到其他服务器，因此用户目标可能无法解析。在这种情况下，可以将目标配置为广播未解析的消息，以便其他服务器可以尝试。这可以通过<code>userDestinationBroadcast</code>的属性<code>MessageBrokerRegistry</code>在Java配置和<code>user-destination-broadcast</code>的属性<code>message-broker</code> XML中的元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-ordered-messages"><a class="anchor" href="#websocket-stomp-ordered-messages"></a> 4.4.15。消息顺序</h4>
<div class="paragraph">
<p>来自经纪人的消息被发布到<code>clientOutboundChannel</code> ，从那里将它们写入WebSocket会话。由于渠道有一个<code>ThreadPoolExecutor</code> ，消息是在不同的线程中处理的，并且客户端接收到的结果序列可能与发布的确切顺序不匹配。</p>
</div>
<div class="paragraph">
<p>如果这是一个问题，请启用<code>setPreservePublishOrder</code>标志，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    protected void configureMessageBroker(MessageBrokerRegistry registry) {
        // ...
        registry.setPreservePublishOrder(true);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:message-broker preserve-publish-order="true"&gt;
        &lt;!-- ... --&gt;
    &lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置该标志后，同一客户端会话中的邮件将发布到<code>clientOutboundChannel</code>一次一次，这样可以保证发布的顺序。请注意，这会产生很小的性能开销，因此，仅在需要时才应启用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-appplication-context-events"><a class="anchor" href="#websocket-stomp-appplication-context-events"></a> 4.4.16。大事记</h4>
<div class="paragraph">
<p>一些<code>ApplicationContext</code>事件的发布可以通过实施Spring的<code>ApplicationListener</code>接口：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BrokerAvailabilityEvent</code> ：指示代理何时可用或不可用。当“简单”代理在启动时立即可用并保持运行状态时，STOMP“代理中继”可能会失去与功能齐全的代理的连接（例如，如果代理重新启动）。代理中继具有重新连接逻辑，并在代理返回时重新建立与代理的“系统”连接。因此，只要状态从连接变为断开，反之亦然，就会发布此事件。使用的组件<code>SimpMessagingTemplate</code>应该订阅此事件，并避免在代理不可用时发送消息。无论如何，他们应该准备好处理<code>MessageDeliveryException</code>发送消息时。</p>
</li>
<li>
<p><code>SessionConnectEvent</code> ：在收到新的STOMP CONNECT以指示新的客户端会话开始时发布。该事件包含代表连接的消息，包括会话ID，用户信息（如果有）和客户端发送的所有自定义标头。这对于跟踪客户端会话很有用。预订此事件的组件可以将包含的消息包装为<code>SimpMessageHeaderAccessor</code>要么<code>StompMessageHeaderAccessor</code> 。</p>
</li>
<li>
<p><code>SessionConnectedEvent</code> ：发布后不久<code>SessionConnectEvent</code>当代理已响应于CONNECT发送STOMP CONNECTED帧时。此时，可以认为STOMP会话已完全建立。</p>
</li>
<li>
<p><code>SessionSubscribeEvent</code> ：在收到新的STOMP SUBSCRIBE时发布。</p>
</li>
<li>
<p><code>SessionUnsubscribeEvent</code> ：在收到新的STOMP UNSUBSCRIBE时发布。</p>
</li>
<li>
<p><code>SessionDisconnectEvent</code> ：在STOMP会话结束时发布。DISCONNECT可能是从客户端发送的，也可能在WebSocket会话关闭时自动生成。在某些情况下，每个会话多次发布此事件。关于多个断开事件，组件应该是幂等的。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当您使用功能齐全的代理时，如果代理暂时不可用，则STOMP“代理中继”会自动重新连接“系统”连接。但是，客户端连接不会自动重新连接。假设启用了心跳，客户端通常会注意到代理在10秒内没有响应。客户端需要实现自己的重新连接逻辑。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-interceptors"><a class="anchor" href="#websocket-stomp-interceptors"></a> 4.4.17。拦截</h4>
<div class="paragraph">
<p><a href="#websocket-stomp-appplication-context-events">事件</a>为STOMP连接的生命周期提供通知，但不是为每条客户端消息提供通知。应用程序还可以注册一个<code>ChannelInterceptor</code>在处理链的任何部分拦截任何消息。以下示例显示如何拦截来自客户端的入站消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new MyChannelInterceptor());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个习俗<code>ChannelInterceptor</code>可以使用<code>StompHeaderAccessor</code>要么<code>SimpMessageHeaderAccessor</code>访问有关消息的信息，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyChannelInterceptor implements ChannelInterceptor {

    @Override
    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        StompCommand command = accessor.getStompCommand();
        // ...
        return message;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用程序也可以实现<code>ExecutorChannelInterceptor</code> ，它是的子接口<code>ChannelInterceptor</code>在处理消息的线程中具有回调。虽然一个<code>ChannelInterceptor</code>对于发送到频道的每条消息都会被调用一次， <code>ExecutorChannelInterceptor</code>在每个线程中提供钩子<code>MessageHandler</code>从频道订阅了消息。</p>
</div>
<div class="paragraph">
<p>请注意， <code>SesionDisconnectEvent</code>如前所述，DISCONNECT消息可以来自客户端，也可以在WebSocket会话关闭时自动生成。在某些情况下，对于每个会话，拦截器可能会多次拦截此消息。关于多个断开事件，组件应该是幂等的。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-client"><a class="anchor" href="#websocket-stomp-client"></a> 4.4.18。STOMP客户端</h4>
<div class="paragraph">
<p>Spring提供了一个基于WebSocket的STOMP客户端和一个基于TCP的STOMP客户端。</p>
</div>
<div class="paragraph">
<p>首先，您可以创建和配置<code>WebSocketStompClient</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebSocketClient webSocketClient = new StandardWebSocketClient();
WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
stompClient.setMessageConverter(new StringMessageConverter());
stompClient.setTaskScheduler(taskScheduler); // for heartbeats</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以替换<code>StandardWebSocketClient</code>与<code>SockJsClient</code> ，因为这也是<code>WebSocketClient</code> 。的<code>SockJsClient</code>可以使用WebSocket或基于HTTP的传输作为后备。有关更多详细信息，请参见<a href="#websocket-fallback-sockjs-client"><code>SockJsClient</code></a> 。</p>
</div>
<div class="paragraph">
<p>接下来，您可以建立连接并为STOMP会话提供处理程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String url = "ws://127.0.0.1:8080/endpoint";
StompSessionHandler sessionHandler = new MyStompSessionHandler();
stompClient.connect(url, sessionHandler);</code></pre>
</div>
</div>
<div class="paragraph">
<p>会话准备就绪后，将通知处理程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyStompSessionHandler extends StompSessionHandlerAdapter {

    @Override
    public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>建立会话后，任何有效负载都可以发送并与配置的序列化<code>MessageConverter</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">session.send("/topic/something", "payload");</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以订阅目的地。的<code>subscribe</code>方法需要订阅程序上的消息处理程序，并返回<code>Subscription</code>您可以用来取消订阅的处理。对于每个收到的消息，处理程序可以指定目标<code>Object</code>有效负载应反序列化的类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">session.subscribe("/topic/something", new StompFrameHandler() {

    @Override
    public Type getPayloadType(StompHeaders headers) {
        return String.class;
    }

    @Override
    public void handleFrame(StompHeaders headers, Object payload) {
        // ...
    }

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>要启用STOMP心跳，可以配置<code>WebSocketStompClient</code>与一个<code>TaskScheduler</code>并有选择地自定义心跳间隔（对于写入非活动状态，该时间为10秒，导致发送心跳；对于不活动读取状态，其时间为10秒，这会关闭连接）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用时<code>WebSocketStompClient</code>为了进行性能测试以模拟同一台计算机上的数千个客户端，请考虑关闭心跳，因为每个连接都计划自己的心跳任务，并且并未针对同一台计算机上运行的大量客户端进行优化。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>STOMP协议还支持收据，客户必须在其中添加一个收据。 <code>receipt</code>在处理发送或订阅之后，服务器以RECEIPT帧响应的标头。为此， <code>StompSession</code>优惠<code>setAutoReceipt(boolean)</code>导致<code>receipt</code>标头添加到每个后续的send或subscription事件上。或者，您也可以手动将收据标题添加到<code>StompHeaders</code> 。发送和订阅均返回的实例<code>Receiptable</code>可用于注册收据成功和失败回调。要使用此功能，您必须为客户端配置一个<code>TaskScheduler</code>以及收据过期之前的时间（默认为15秒）。</p>
</div>
<div class="paragraph">
<p>注意<code>StompSessionHandler</code>本身是一个<code>StompFrameHandler</code> ，它除了可以处理错误帧<code>handleException</code>回调消息处理中的异常<code>handleTransportError</code>对于运输级别的错误，包括<code>ConnectionLostException</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-websocket-scope"><a class="anchor" href="#websocket-stomp-websocket-scope"></a> 4.4.19。WebSocket范围</h4>
<div class="paragraph">
<p>每个WebSocket会话都有一个属性映射。该映射作为标头附加到入站客户端消息，可以通过控制器方法进行访问，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

    @MessageMapping("/action")
    public void handle(SimpMessageHeaderAccessor headerAccessor) {
        Map&lt;String, Object&gt; attrs = headerAccessor.getSessionAttributes();
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在中声明一个Spring管理的bean <code>websocket</code>范围。您可以将WebSocket作用域的bean注入控制器和在<code>clientInboundChannel</code> 。这些通常是单例，并且比任何单独的WebSocket会话寿命更长。因此，您需要对作用域WebSocket的bean使用作用域代理模式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyBean {

    @PostConstruct
    public void init() {
        // Invoked after dependencies injected
    }

    // ...

    @PreDestroy
    public void destroy() {
        // Invoked when the WebSocket session ends
    }
}

@Controller
public class MyController {

    private final MyBean myBean;

    @Autowired
    public MyController(MyBean myBean) {
        this.myBean = myBean;
    }

    @MessageMapping("/action")
    public void handle() {
        // this.myBean from the current WebSocket session
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与任何自定义范围一样，Spring会初始化一个新的<code>MyBean</code>第一次从控制器访问它的实例，并将实例存储在WebSocket会话属性中。随后将返回相同的实例，直到会话结束。WebSocket范围的bean调用了所有Spring生命周期方法，如前面的示例所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-configuration-performance"><a class="anchor" href="#websocket-stomp-configuration-performance"></a> 4.4.20。性能</h4>
<div class="paragraph">
<p>关于性能，没有灵丹妙药。影响它的因素很多，包括消息的大小和数量，应用程序方法是否执行需要阻止的工作以及外部因素（例如网络速度和其他问题）。本部分的目的是提供可用配置选项的概述，以及有关如何进行扩展的一些想法。</p>
</div>
<div class="paragraph">
<p>在消息传递应用程序中，消息通过通道传递以进行异步执行，并由线程池支持。配置这样的应用程序需要对通道和消息流有充分的了解。因此，建议查看<a href="#websocket-stomp-message-flow">消息流</a> 。</p>
</div>
<div class="paragraph">
<p>最明显的开始是配置支持该线程池的线程池。 <code>clientInboundChannel</code>和<code>clientOutboundChannel</code> 。默认情况下，两者都配置为可用处理器数量的两倍。</p>
</div>
<div class="paragraph">
<p>如果带注释的方法中的消息处理主要是受CPU限制的，则用于<code>clientInboundChannel</code>应保持接近处理器数量。如果他们所做的工作更多地受到IO限制，并且需要阻塞或等待数据库或其他外部系统，则可能需要增加线程池大小。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ThreadPoolExecutor</code>具有三个重要属性：核心线程池大小，最大线程池大小，以及队列存储没有可用线程的任务的容量。</p>
</div>
<div class="paragraph">
<p>常见的混淆点是，配置核心池大小（例如10）和最大池大小（例如20）会导致线程池具有10到20个线程。实际上，如果容量保留其默认值Integer。MAX_VALUE，因为所有其他任务都已排队，所以线程池永远不会超过核心池的大小。</p>
</div>
<div class="paragraph">
<p>见的javadoc <code>ThreadPoolExecutor</code>了解这些属性的工作原理并了解各种排队策略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在<code>clientOutboundChannel</code>方面，这都是关于向WebSocket客户端发送消息。如果客户端在快速网络上，则线程数应保持接近可用处理器数。如果它们很慢或带宽很低，它们将花费更长的时间来消耗消息并给线程池增加负担。因此，必须增加线程池的大小。</p>
</div>
<div class="paragraph">
<p>而工作量为<code>clientInboundChannel</code>毕竟，它是基于应用程序无法控制的因素，因此，很难预测-毕竟，它是基于应用程序的工作的-如何配置“ clientOutboundChannel”。因此，还有两个其他属性与消息发送有关： <code>sendTimeLimit</code>和<code>sendBufferSizeLimit</code> 。您可以使用这些方法来配置发送消息到客户端时允许发送多长时间以及可以缓冲多少数据。</p>
</div>
<div class="paragraph">
<p>通常的想法是，在任何给定时间，只能使用单个线程将其发送给客户端。同时，所有其他消息都将被缓冲，并且您可以使用这些属性来决定允许发送消息花费多长时间以及在此期间可以缓冲多少数据。有关其他重要信息，请参见XML模式的javadoc和文档。</p>
</div>
<div class="paragraph">
<p>以下示例显示了可能的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
        registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:message-broker&gt;
        &lt;websocket:transport send-timeout="15000" send-buffer-size="524288" /&gt;
        &lt;!-- ... --&gt;
    &lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用前面显示的WebSocket传输配置来配置传入STOMP消息的最大允许大小。从理论上讲，WebSocket消息的大小几乎是无限的。实际上，WebSocket服务器施加了限制-例如，Tomcat 8K和Jetty 64K。因此，STOMP客户端（例如JavaScript <a href="https://github.com/JSteunou/webstomp-client">webstomp-client</a>和其他<a href="https://github.com/JSteunou/webstomp-client">客户端</a> ）在16K边界处拆分较大的STOMP消息，并将其作为多个WebSocket消息发送，这需要服务器进行缓冲和重新组装。</p>
</div>
<div class="paragraph">
<p>Spring的STOMP-over-WebSocket支持可以做到这一点，因此应用程序可以为STOMP消息配置最大大小，而与WebSocket服务器特定的消息大小无关。请记住，如有必要，将自动调整WebSocket消息的大小，以确保它们最多可以承载16K WebSocket消息。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一种可能的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
        registration.setMessageSizeLimit(128 * 1024);
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示与前面的示例等效的XML配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

    &lt;websocket:message-broker&gt;
        &lt;websocket:transport message-size="131072" /&gt;
        &lt;!-- ... --&gt;
    &lt;/websocket:message-broker&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于扩展的重要一点涉及使用多个应用程序实例。当前，您无法使用简单代理执行此操作。但是，当您使用功能齐全的代理（例如RabbitMQ）时，每个应用程序实例都连接到代理，并且从一个应用程序实例广播的消息可以通过代理广播到通过任何其他应用程序实例连接的WebSocket客户端。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-stats"><a class="anchor" href="#websocket-stomp-stats"></a> 4.4.21。监控方式</h4>
<div class="paragraph">
<p>使用时<code>@EnableWebSocketMessageBroker</code>要么<code><websocket:message-broker></code> ，关键基础架构组件会自动收集统计信息和计数器，以提供对应用程序内部状态的重要了解。该配置还声明了一个类型为的bean <code>WebSocketMessageBrokerStats</code>将所有可用信息收集到一个地方，默认情况下将其记录在<code>INFO</code>每30分钟一次。该bean可以通过Spring的导出到JMX <code>MBeanExporter</code>用于在运行时查看（例如，通过JDK <code>jconsole</code> ）。以下列表总结了可用信息：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">客户端WebSocket会话</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">当前</dt>
<dd>
<p>指示当前有多少个客户端会话，并且通过WebSocket与HTTP流和轮询SockJS会话进一步细分该计数。</p>
</dd>
<dt class="hdlist1">总</dt>
<dd>
<p>指示已建立的会话总数。</p>
</dd>
<dt class="hdlist1">异常关闭</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">连接失败</dt>
<dd>
<p>已建立但在60秒内未收到任何消息后关闭的会话。这通常表示代理或网络问题。</p>
</dd>
<dt class="hdlist1">超过发送限制</dt>
<dd>
<p>超过配置的发送超时或发送缓冲区限制后，会话将关闭，缓慢的客户端可能会发生这些会话（请参阅上一节）。</p>
</dd>
<dt class="hdlist1">运输错误</dt>
<dd>
<p>传输错误（例如无法读取或写入WebSocket连接或HTTP请求或响应）后，会话关闭。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">STOMP框架</dt>
<dd>
<p>已处理的CONNECT，CONNECTED和DISCONNECT帧的总数，指示在STOMP级别上连接了多少个客户端。请注意，当会话异常关闭或客户端未发送DISCONNECT帧而关闭时，DISCONNECT计数可能会降低。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">STOMP经纪人接力</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">TCP连接</dt>
<dd>
<p>指示与代理建立了代表客户端WebSocket会话的TCP连接数。这应该等于客户端WebSocket会话的数量+ 1个用于从应用程序内部发送消息的附加共享“系统”连接。</p>
</dd>
<dt class="hdlist1">STOMP框架</dt>
<dd>
<p>代表客户转发到代理或从代理接收的CONNECT，CONNECTED和DISCONNECT帧总数。请注意，无论客户端WebSocket会话如何关闭，DISCONNECT帧都会发送到代理。因此，较低的DISCONNECT帧计数表示代理正在主动关闭连接（可能是由于未及时到达的心跳，无效的输入帧或其他问题）。</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">客户入站通道</dt>
<dd>
<p>来自支持的线程池的统计信息<code>clientInboundChannel</code>可以深入了解传入消息处理的运行状况。此处排队的任务表明该应用程序可能太慢而无法处理消息。如果存在I / O绑定的任务（例如，慢速的数据库查询，对第三方REST API的HTTP请求等），请考虑增加线程池的大小。</p>
</dd>
<dt class="hdlist1">客户出站通道</dt>
<dd>
<p>来自支持的线程池的统计信息<code>clientOutboundChannel</code>可以深入了解向客户端广播消息的运行状况。此处排队的任务表明客户端太慢而无法使用消息。解决此问题的一种方法是增加线程池大小，以容纳并发慢速客户端的预期数量。另一个选择是减少发送超时和发送缓冲区大小限制（请参阅上一节）。</p>
</dd>
<dt class="hdlist1">SockJS任务计划程序</dt>
<dd>
<p>来自SockJS任务调度程序的线程池的统计信息，用于发送心跳。请注意，在STOMP级别协商心跳时，将禁用SockJS心跳。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="websocket-stomp-testing"><a class="anchor" href="#websocket-stomp-testing"></a> 4.4.22。测试中</h4>
<div class="paragraph">
<p>当您使用Spring的STOMP-over-WebSocket支持时，有两种主要的方法来测试应用程序。首先是编写服务器端测试以验证控制器的功能及其带注释的消息处理方法。第二个是编写涉及运行客户端和服务器的完整的端到端测试。</p>
</div>
<div class="paragraph">
<p>两种方法不是互斥的。相反，每个人在整体测试策略中都有自己的位置。服务器端测试更加集中，更易于编写和维护。另一方面，端到端集成测试更完整，测试更多，但是编写和维护也更加复杂。</p>
</div>
<div class="paragraph">
<p>服务器端测试的最简单形式是编写控制器单元测试。但是，这还不够有用，因为控制器所做的很多事情都取决于其注释。纯单元测试根本无法测试。</p>
</div>
<div class="paragraph">
<p>理想情况下，应像在运行时一样调用被测控制器，就像使用Spring MVC Test框架测试处理HTTP请求的控制器的方法一样，即不运行Servlet容器而是依靠Spring Framework 来调用被测控制器。带注释的控制器。与Spring MVC Test一样，您有两种可能的选择，要么使用“基于上下文的”设置，要么使用“独立的”设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在Spring TestContext框架的帮助下加载实际的Spring配置，注入<code>clientInboundChannel</code>作为测试字段，并使用它发送要由控制器方法处理的消息。</p>
</li>
<li>
<p>手动设置调用控制器所需的最低Spring Framework 基础架构（即<code>SimpAnnotationMethodMessageHandler</code> ），并将控制器的消息直接传递给它。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">在股票投资组合</a>样本应用程序的<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试</a>中演示了这两种设置方案。</p>
</div>
<div class="paragraph">
<p>第二种方法是创建端到端集成测试。为此，您需要以嵌入式模式运行WebSocket服务器，并将其作为WebSocket客户端连接到该服务器，该客户端发送包含STOMP帧的WebSocket消息。通过使用Tomcat作为嵌入式WebSocket服务器和一个简单的STOMP客户端来进行<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试，针对股票</a>样本应用程序的<a href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试</a>也演示了这种方法。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="web-integration"><a class="anchor" href="#web-integration"></a> 5，其他Web框架</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章详细介绍了Spring与第三方Web框架的集成。</p>
</div>
<div class="paragraph">
<p>Spring Framework 的核心价值主张之一是支持<em>选择</em> 。从一般意义上讲，Spring不会强迫您使用或购买任何特定的体系结构，技术或方法（尽管它肯定比其他建议更重要）。可以自由选择与开发人员及其开发团队最相关的架构，技术或方法，这在Web领域最明显，在Web领域，Spring提供了自己的Web框架（ <a href="#mvc">Spring MVC</a>和<a href="#webflux">Spring WebFlux</a> ）。同时，支持与许多流行的第三方Web框架集成。</p>
</div>
<div class="sect2">
<h3 id="web-integration-common"><a class="anchor" href="#web-integration-common"></a> 5.1。通用配置</h3>
<div class="paragraph">
<p>在深入研究每个受支持的Web框架的集成细节之前，让我们首先看一下并非特定于任何Web框架的通用Spring配置。（本节同样适用于Spring自己的Web框架变体。）</p>
</div>
<div class="paragraph">
<p>Spring的轻量级应用程序模型拥护的一个概念（需要一个更好的词）是分层体系结构的概念。请记住，在“经典”分层体系结构中，Web层只是众多层中的一层。它充当服务器端应用程序的入口点之一，并委派服务层中定义的服务对象（外观），以满足特定于业务（与表示技术无关）的用例。在Spring中，这些服务对象，任何其他特定于业务的对象，数据访问对象和其他对象都存在于不同的“业务上下文”中，其中不包含Web或表示层对象（表示对象，例如Spring MVC控制器，通常是在不同的“展示环境”中进行配置）。本节详细介绍如何配置Spring容器（ <code>WebApplicationContext</code> ），其中包含应用程序中的所有“ Business Bean”。</p>
</div>
<div class="paragraph">
<p>继续讲细节，您要做的就是声明一个<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/context/ContextLoaderListener.html"><code>ContextLoaderListener</code></a>在标准Java EE servlet中<code>web.xml</code>您的Web应用程序文件并添加一个<code>contextConfigLocation</code><context-param></context-param>部分（在同一文件中），用于定义要加载的一组Spring XML配置文件。</p>
</div>
<div class="paragraph">
<p>考虑以下<code><listener/></code>组态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>进一步考虑以下<code><context-param/></code>组态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不指定<code>contextConfigLocation</code>上下文参数<code>ContextLoaderListener</code>寻找一个名为<code>/WEB-INF/applicationContext.xml</code>加载。加载上下文文件后，Spring会创建一个<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/context/WebApplicationContext.html"><code>WebApplicationContext</code></a>基于Bean定义的对象，并将其存储在<code>ServletContext</code> Web应用程序。</p>
</div>
<div class="paragraph">
<p>所有Java Web框架都是基于Servlet API构建的，因此您可以使用以下代码片段来访问此“业务上下文” <code>ApplicationContext</code>由创建<code>ContextLoaderListener</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何获取<code>WebApplicationContext</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/context/support/WebApplicationContextUtils.html"><code>WebApplicationContextUtils</code></a>类是为了方便起见，因此您不必记住名称<code>ServletContext</code>属性。它的<code>getWebApplicationContext()</code>方法返回<code>null</code>如果对象不存在<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>键。而不是冒险<code>NullPointerExceptions</code>在您的应用程序中，最好使用<code>getRequiredWebApplicationContext()</code>方法。当<code>ApplicationContext</code>不见了。</p>
</div>
<div class="paragraph">
<p>一旦您引用了<code>WebApplicationContext</code> ，您可以按其名称或类型检索bean。大多数开发人员都按名称检索bean，然后将其转换为实现的接口之一。</p>
</div>
<div class="paragraph">
<p>幸运的是，本节中的大多数框架都具有更简单的查找bean的方法。它们不仅使从Spring容器中获取bean变得容易，而且还使您可以在其控制器上使用依赖项注入。每个Web框架部分都有其特定集成策略的更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="jsf"><a class="anchor" href="#jsf"></a> 5.2。JSF</h3>
<div class="paragraph">
<p>JavaServer Faces（JSF）是JCP的基于组件的标准，事件驱动的Web用户界面框架。它是Java EE伞的正式组成部分，但也可以单独使用，例如通过将Mojarra或MyFaces嵌入Tomcat中。</p>
</div>
<div class="paragraph">
<p>请注意，JSF的最新版本已与应用程序服务器中的CDI基础结构紧密联系在一起，其中一些新的JSF功能仅在这种环境下有效。Spring的JSF支持不再积极发展，主要是在现代化较早的基于JSF的应用程序用于迁移时。</p>
</div>
<div class="paragraph">
<p>Spring的JSF集成中的关键要素是JSF <code>ELResolver</code>机制。</p>
</div>
<div class="sect3">
<h4 id="jsf-springbeanfaceselresolver"><a class="anchor" href="#jsf-springbeanfaceselresolver"></a> 5.2.1。Spring Bean解析器</h4>
<div class="paragraph">
<p><code>SpringBeanFacesELResolver</code>符合JSF <code>ELResolver</code>与JSF和JSP使用的标准Unified EL集成。它代表了Spring的“业务环境” <code>WebApplicationContext</code>首先，然后是基础JSF实现的默认解析器。</p>
</div>
<div class="paragraph">
<p>在配置方面，您可以定义<code>SpringBeanFacesELResolver</code>在您的JSF中<code>faces-context.xml</code>文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;faces-config&gt;
    &lt;application&gt;
        &lt;el-resolver&gt;org.springframework.web.jsf.el.SpringBeanFacesELResolver&lt;/el-resolver&gt;
        ...
    &lt;/application&gt;
&lt;/faces-config&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jsf-facescontextutils"><a class="anchor" href="#jsf-facescontextutils"></a> 5.2.2。使用<code>FacesContextUtils</code></h4>
<div class="paragraph">
<p>一个习俗<code>ELResolver</code>将属性映射到Bean中时，效果很好<code>faces-config.xml</code> ，但是有时您可能需要显式获取一个bean。的<a href="https://docs.spring.io/spring-framework/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/jsf/FacesContextUtils.html"><code>FacesContextUtils</code></a>上课很容易。它类似于<code>WebApplicationContextUtils</code> ，除了需要一个<code>FacesContext</code>参数而不是<code>ServletContext</code>参数。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用<code>FacesContextUtils</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="struts"><a class="anchor" href="#struts"></a> 5.3。Apache Struts 2.x</h3>
<div class="paragraph">
<p><a href="https://struts.apache.org">Struts</a>由Craig McClanahan发明，是由Apache Software Foundation托管的开源项目。当时，它极大地简化了JSP / Servlet编程范例，并赢得了许多使用专有框架的开发人员的青睐。它简化了编程模型，它是开源的（因此像啤酒一样免费），并且拥有庞大的社区，这使该项目得以发展并在Java Web开发人员中广受欢迎。</p>
</div>
<div class="paragraph">
<p>作为原始Struts 1.x的后继产品，请查看Struts 2.x和Struts提供的<a href="https://struts.apache.org/release/2.3.x/docs/spring-plugin.html">Spring Plugin</a>以进行内置的Spring集成。</p>
</div>
</div>
<div class="sect2">
<h3 id="tapestry"><a class="anchor" href="#tapestry"></a> 5.4。Apache Tapestry 5.x</h3>
<div class="paragraph">
<p><a href="https://tapestry.apache.org/">Tapestry</a>是一个“面向组件的框架，用于在Java中创建动态，健壮，高度可伸缩的Web应用程序。”</p>
</div>
<div class="paragraph">
<p>尽管Spring具有自己<a href="#mvc">强大的Web层</a> ，但通过将Tapestry用于Web用户界面并将Spring容器用于较低层，构建企业Java应用程序具有许多独特的优势。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见Tapestry的<a href="https://tapestry.apache.org/integrating-with-spring-framework.html">Spring</a>专用<a href="https://tapestry.apache.org/integrating-with-spring-framework.html">集成模块</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="web-integration-resources"><a class="anchor" href="#web-integration-resources"></a> 5.5。更多资源</h3>
<div class="paragraph">
<p>以下链接提供了有关本章中描述的各种Web框架的更多资源。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html">JSF</a>主页</p>
</li>
<li>
<p><a href="https://struts.apache.org/">Struts</a>主页</p>
</li>
<li>
<p><a href="https://tapestry.apache.org/">挂毯</a>首页</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">版本5.2.1。发布<br>最近更新时间2019-11-02 08:08:52 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script type="text/javascript" src="js/switch-language.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>