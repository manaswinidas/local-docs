<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>133.&nbsp;Serverless Platform Adapters</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="multi_spring-cloud.html" title="Spring Cloud"><link rel="up" href="multi__spring_cloud_function_2.html" title="Part&nbsp;XVI.&nbsp;Spring Cloud Function"><link rel="prev" href="multi__dynamic_compilation.html" title="132.&nbsp;Dynamic Compilation"><link rel="next" href="multi__spring_cloud_kubernetes.html" title="Part&nbsp;XVII.&nbsp;Spring Cloud Kubernetes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">133.&nbsp;Serverless Platform Adapters</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__dynamic_compilation.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;XVI.&nbsp;Spring Cloud Function</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi__spring_cloud_kubernetes.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_serverless_platform_adapters" href="#_serverless_platform_adapters"></a>133.&nbsp;Serverless Platform Adapters</h2></div></div></div><p>As well as being able to run as a standalone process, a Spring Cloud
Function application can be adapted to run one of the existing
serverless platforms. In the project there are adapters for
<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws" target="_top">AWS
Lambda</a>,
<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure" target="_top">Azure</a>,
and
<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk" target="_top">Apache
OpenWhisk</a>. The <a class="link" href="https://github.com/fnproject/fn" target="_top">Oracle Fn platform</a>
has its own Spring Cloud Function adapter. And
<a class="link" href="https://projectriff.io" target="_top">Riff</a> supports Java functions and its
<a class="link" href="https://github.com/projectriff/java-function-invoker" target="_top">Java Function
Invoker</a> acts natively is an adapter for Spring Cloud Function jars.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_aws_lambda" href="#_aws_lambda"></a>133.1&nbsp;AWS Lambda</h2></div></div></div><p>The <a class="link" href="https://aws.amazon.com/" target="_top">AWS</a> adapter takes a Spring Cloud Function app and converts it to a form that can run in AWS Lambda.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_3" href="#_introduction_3"></a>133.1.1&nbsp;Introduction</h3></div></div></div><p>The adapter has a couple of generic request handlers that you can use. The most generic is <code class="literal">SpringBootStreamHandler</code>, which uses a Jackson <code class="literal">ObjectMapper</code> provided by Spring Boot to serialize and deserialize the objects in the function. There is also a <code class="literal">SpringBootRequestHandler</code> which you can extend, and provide the input and output types as type parameters (enabling AWS to inspect the class and do the JSON conversions itself).</p><p>If your app has more than one <code class="literal">@Bean</code> of type <code class="literal">Function</code> etc. then you can choose the one to use by configuring <code class="literal">function.name</code> (e.g. as <code class="literal">FUNCTION_NAME</code> environment variable in AWS). The functions are extracted from the Spring Cloud <code class="literal">FunctionCatalog</code> (searching first for <code class="literal">Function</code> then <code class="literal">Consumer</code> and finally <code class="literal">Supplier</code>).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_notes_on_jar_layout" href="#_notes_on_jar_layout"></a>133.1.2&nbsp;Notes on JAR Layout</h3></div></div></div><p>You don&#8217;t need the Spring Cloud Function Web or Stream adapter at runtime in Lambda, so you might need to exclude those before you create the JAR you send to AWS. A Lambda application has to be shaded, but a Spring Boot standalone application does not, so you can run the same app using 2 separate jars (as per the sample). The sample app creates 2 jar files, one with an <code class="literal">aws</code> classifier for deploying in Lambda, and one executable (thin) jar that includes <code class="literal">spring-cloud-function-web</code> at runtime. Spring Cloud Function will try and locate a "main class" for you from the JAR file manifest, using the <code class="literal">Start-Class</code> attribute (which will be added for you by the Spring Boot tooling if you use the starter parent). If there is no <code class="literal">Start-Class</code> in your manifest you can use an environment variable <code class="literal">MAIN_CLASS</code> when you deploy the function to AWS.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_upload" href="#_upload"></a>133.1.3&nbsp;Upload</h3></div></div></div><p>Build the sample under <code class="literal">spring-cloud-function-samples/function-sample-aws</code> and upload the <code class="literal">-aws</code> jar file to Lambda. The handler can be <code class="literal">example.Handler</code> or <code class="literal">org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler</code> (FQN of the class, <span class="emphasis"><em>not</em></span> a method reference, although Lambda does accept method references).</p><pre class="screen">./mvnw -U clean package</pre><p>Using the AWS command line tools it looks like this:</p><pre class="screen">aws lambda create-function --function-name Uppercase --role arn:aws:iam::[USERID]:role/service-role/[ROLE] --zip-file fileb://function-sample-aws/target/function-sample-aws-2.0.0.BUILD-SNAPSHOT-aws.jar --handler org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler --description "Spring Cloud Function Adapter Example" --runtime java8 --region us-east-1 --timeout 30 --memory-size 1024 --publish</pre><p>The input type for the function in the AWS sample is a Foo with a single property called "value". So you would need this to test it:</p><pre class="screen">{
  "value": "test"
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The AWS sample app is written in the "functional" style (as an <code class="literal">ApplicationContextInitializer</code>). This is much faster on startup in Lambda than the traditional <code class="literal">@Bean</code> style, so if you don&#8217;t need <code class="literal">@Beans</code> (or <code class="literal">@EnableAutoConfiguration</code>) it&#8217;s a good choice. Warm starts are not affected.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_platfom_specific_features" href="#_platfom_specific_features"></a>133.1.4&nbsp;Platfom Specific Features</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_http_and_api_gateway" href="#_http_and_api_gateway"></a>HTTP and API Gateway</h4></div></div></div><p>AWS has some platform-specific data types, including batching of messages, which is much more efficient than processing each one individually. To make use of these types you can write a function that depends on those types. Or you can rely on Spring to extract the data from the AWS types and convert it to a Spring <code class="literal">Message</code>. To do this you tell AWS that the function is of a specific generic handler type (depending on the AWS service) and provide a bean of type <code class="literal">Function&lt;Message&lt;S&gt;,Message&lt;T&gt;&gt;</code>, where <code class="literal">S</code> and <code class="literal">T</code> are your business data types. If there is more than one bean of type <code class="literal">Function</code> you may also need to configure the Spring Boot property <code class="literal">function.name</code> to be the name of the target bean (e.g. use <code class="literal">FUNCTION_NAME</code> as an environment variable).</p><p>The supported AWS services and generic handler types are listed below:</p><div class="informaltable"><table class="informaltable" style="border-collapse: collapse;border-top: 1px solid ; border-bottom: 1px solid ; "><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Service</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">AWS Types</th><th style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top">Generic Handler</th><th style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</th></tr></thead><tbody><tr><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p>API Gateway</p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">APIGatewayProxyRequestEvent</code>, <code class="literal">APIGatewayProxyResponseEvent</code></p></td><td style="border-right: 1px solid ; border-bottom: 1px solid ; " align="left" valign="top"><p><code class="literal">org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code></p></td><td style="border-bottom: 1px solid ; " align="left" valign="top">&nbsp;</td></tr><tr><td style="border-right: 1px solid ; " align="left" valign="top"><p>Kinesis</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>KinesisEvent</p></td><td style="border-right: 1px solid ; " align="left" valign="top"><p>org.springframework.cloud.function.adapter.aws.SpringBootKinesisEventHandler</p></td><td style="" align="left" valign="top">&nbsp;</td></tr></tbody></table></div><p>For example, to deploy behind an API Gateway, use <code class="literal">--handler org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code> in your AWS command line (in via the UI) and define a <code class="literal">@Bean</code> of type <code class="literal">Function&lt;Message&lt;Foo&gt;,Message&lt;Bar&gt;&gt;</code> where <code class="literal">Foo</code> and <code class="literal">Bar</code> are POJO types (the data will be marshalled and unmarshalled by AWS using Jackson).</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_azure_functions" href="#_azure_functions"></a>133.2&nbsp;Azure Functions</h2></div></div></div><p>The <a class="link" href="https://azure.microsoft.com" target="_top">Azure</a> adapter bootstraps a Spring Cloud Function context and channels function calls from the Azure framework into the user functions, using Spring Boot configuration where necessary. Azure Functions has quite a unique, but invasive programming model, involving annotations in user code that are specific to the platform. The easiest way to use it with Spring Cloud is to extend a base class and write a method in it with the <code class="literal">@FunctionName</code> annotation which delegates to a base class method.</p><p>This project provides an adapter layer for a Spring Cloud Function application onto Azure.
You can write an app with a single <code class="literal">@Bean</code> of type <code class="literal">Function</code> and it will be deployable in Azure if you get the JAR file laid out right.</p><p>There is an <code class="literal">AzureSpringBootRequestHandler</code> which you must extend, and provide the input and output types as annotated method parameters (enabling Azure to inspect the class and create JSON bindings). The base class has two useful methods (<code class="literal">handleRequest</code> and <code class="literal">handleOutput</code>) to which you can delegate the actual function call, so mostly the function will only ever have one line.</p><p>Example:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooHandler <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AzureSpringBootRequestHandler&lt;Foo, Bar&gt; {
	<em><span class="hl-annotation" style="color: gray">@FunctionName("uppercase")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Bar execute(
			<em><span class="hl-annotation" style="color: gray">@HttpTrigger(name = "req", methods = { HttpMethod.GET,
					HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS)</span></em>
                    Foo foo,
			ExecutionContext context) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> handleRequest(foo, context);
	}
}</pre><p>This Azure handler will delegate to a <code class="literal">Function&lt;Foo,Bar&gt;</code> bean (or a <code class="literal">Function&lt;Publisher&lt;Foo&gt;,Publisher&lt;Bar&gt;&gt;</code>). Some Azure triggers (e.g. <code class="literal">@CosmosDBTrigger</code>) result in a input type of <code class="literal">List</code> and in that case you can bind to <code class="literal">List</code> in the Azure handler, or <code class="literal">String</code> (the raw JSON). The <code class="literal">List</code> input delegates to a <code class="literal">Function</code> with input type <code class="literal">Map&lt;String,Object&gt;</code>, or <code class="literal">Publisher</code> or <code class="literal">List</code> of the same type. The output of the <code class="literal">Function</code> can be a <code class="literal">List</code> (one-for-one) or a single value (aggregation), and the output binding in the Azure declaration should match.</p><p>If your app has more than one <code class="literal">@Bean</code> of type <code class="literal">Function</code> etc. then you can choose the one to use by configuring <code class="literal">function.name</code>. Or if you make the <code class="literal">@FunctionName</code> in the Azure handler method match the function name it should work that way (also for function apps with multiple functions). The functions are extracted from the Spring Cloud <code class="literal">FunctionCatalog</code> so the default function names are the same as the bean names.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_notes_on_jar_layout_2" href="#_notes_on_jar_layout_2"></a>133.2.1&nbsp;Notes on JAR Layout</h3></div></div></div><p>You don&#8217;t need the Spring Cloud Function Web at runtime in Azure, so you can exclude this before you create the JAR you deploy to Azure, but it won&#8217;t be used if you include it so it doesn&#8217;t hurt to leave it in. A function application on Azure is an archive generated by the Maven plugin. The function lives in the JAR file generated by this project. The sample creates it as an executable jar, using the thin layout, so that Azure can find the handler classes. If you prefer you can just use a regular flat JAR file. The dependencies should <span class="strong"><strong>not</strong></span> be included.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_build" href="#_build"></a>133.2.2&nbsp;Build</h3></div></div></div><pre class="screen">./mvnw -U clean package</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_running_the_sample" href="#_running_the_sample"></a>133.2.3&nbsp;Running the sample</h3></div></div></div><p>You can run the sample locally, just like the other Spring Cloud Function samples:</p><p></p><p></p><p>and <code class="literal">curl -H "Content-Type: text/plain" localhost:8080/function -d '{"value": "hello foobar"}'</code>.</p><p>You will need the <code class="literal">az</code> CLI app (see <a class="link" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven" target="_top">https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven</a> for more detail). To deploy the function on Azure runtime:</p><pre class="screen">$ az login
$ mvn azure-functions:deploy</pre><p>On another terminal try this: <code class="literal">curl <a class="link" href="https://<azure-function-url-from-the-log&gt;/api/uppercase" target="_top">https://&lt;azure-function-url-from-the-log&gt;/api/uppercase</a> -d '{"value": "hello foobar!"}'</code>. Please ensure that you use the right URL for the function above. Alternatively you can test the function in the Azure Dashboard UI (click on the function name, go to the right hand side and click "Test" and to the bottom right, "Run").</p><p>The input type for the function in the Azure sample is a Foo with a single property called "value". So you need this to test it with something like below:</p><pre class="screen">{
  "value": "foobar"
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The Azure sample app is written in the "non-functional" style (using <code class="literal">@Bean</code>). The functional style (with just <code class="literal">Function</code> or <code class="literal">ApplicationContextInitializer</code>) is much faster on startup in Azure than the traditional <code class="literal">@Bean</code> style, so if you don&#8217;t need <code class="literal">@Beans</code> (or <code class="literal">@EnableAutoConfiguration</code>) it&#8217;s a good choice. Warm starts are not affected.</p></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_apache_openwhisk" href="#_apache_openwhisk"></a>133.3&nbsp;Apache Openwhisk</h2></div></div></div><p>The <a class="link" href="https://openwhisk.apache.org/" target="_top">OpenWhisk</a> adapter is in the form of an executable jar that can be used in a a docker image to be deployed to Openwhisk. The platform works in request-response mode, listening on port 8080 on a specific endpoint, so the adapter is a simple Spring MVC application.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_quick_start_5" href="#_quick_start_5"></a>133.3.1&nbsp;Quick Start</h3></div></div></div><p>Implement a POF (be sure to use the <code class="literal">functions</code> package):</p><pre class="screen">package functions;

import java.util.function.Function;

public class Uppercase implements Function&lt;String, String&gt; {

	public String apply(String input) {
		return input.toUpperCase();
	}
}</pre><p>Install it into your local Maven repository:</p><pre class="screen">./mvnw clean install</pre><p>Create a <code class="literal">function.properties</code> file that provides its Maven coordinates. For example:</p><pre class="screen">dependencies.function: com.example:pof:0.0.1-SNAPSHOT</pre><p>Copy the openwhisk runner JAR to the working directory (same directory as the properties file):</p><pre class="screen">cp spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk/target/spring-cloud-function-adapter-openwhisk-2.0.0.BUILD-SNAPSHOT.jar runner.jar</pre><p>Generate a m2 repo from the <code class="literal">--thin.dryrun</code> of the runner JAR with the above properties file:</p><pre class="screen">java -jar -Dthin.root=m2 runner.jar --thin.name=function --thin.dryrun</pre><p>Use the following Dockerfile:</p><pre class="screen">FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY m2 /m2
ADD runner.jar .
ADD function.properties .
ENV JAVA_OPTS=""
ENTRYPOINT [ "java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "runner.jar", "--thin.root=/m2", "--thin.name=function", "--function.name=uppercase"]
EXPOSE 8080</pre><div class="blockquote"><blockquote class="blockquote"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>you could use a Spring Cloud Function app, instead of just a jar with a POF in it, in which case you would have to change the way the app runs in the container so that it picks up the main class as a source file. For example, you could change the <code class="literal">ENTRYPOINT</code> above and add <code class="literal">--spring.main.sources=com.example.SampleApplication</code>.</p></td></tr></table></div></blockquote></div><p>Build the Docker image:</p><pre class="screen">docker build -t [username/appname] .</pre><p>Push the Docker image:</p><pre class="screen">docker push [username/appname]</pre><p>Use the OpenWhisk CLI (e.g. after <code class="literal">vagrant ssh</code>) to create the action:</p><pre class="screen">wsk action create example --docker [username/appname]</pre><p>Invoke the action:</p><pre class="screen">wsk action invoke example --result --param payload foo
{
    "result": "FOO"
}</pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__dynamic_compilation.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="multi__spring_cloud_function_2.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi__spring_cloud_kubernetes.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">132.&nbsp;Dynamic Compilation&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;XVII.&nbsp;Spring Cloud Kubernetes</td></tr></table></div></body></html>