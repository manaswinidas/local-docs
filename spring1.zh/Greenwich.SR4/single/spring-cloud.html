<!DOCTYPE html>
<html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Spring Cloud</title><link rel="stylesheet" type="text/css" href="css/manual-singlepage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body><div lang="zh-Hans" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="d0e3"></a>Spring Cloud</h1></div></div><hr></div><div class="toc"><p><b>目录</b></p><dl class="toc"><dt><span class="preface"><a href="#d0e9"></a></span></dt><dt><span class="chapter"><a href="#_features">1。特征</a></span></dt><dt><span class="part"><a href="#_cloud_native_applications">一，云原生应用</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_spring_cloud_context_application_context_services">2。Spring Cloud Context：应用程序上下文服务</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_bootstrap_application_context">2.1。Bootstrap应用程序上下文</a></span></dt><dt><span class="section"><a href="#_application_context_hierarchies">2.2。应用程序上下文层次结构</a></span></dt><dt><span class="section"><a href="#customizing-bootstrap-properties">2.3。更改引导程序属性的位置</a></span></dt><dt><span class="section"><a href="#overriding-bootstrap-properties">2.4。覆盖远程属性的值</a></span></dt><dt><span class="section"><a href="#_customizing_the_bootstrap_configuration">2.5。自定义引导程序配置</a></span></dt><dt><span class="section"><a href="#customizing-bootstrap-property-sources">2.6。自定义Bootstrap属性源</a></span></dt><dt><span class="section"><a href="#_logging_configuration">2.7。记录配置</a></span></dt><dt><span class="section"><a href="#_environment_changes">2.8。环境变化</a></span></dt><dt><span class="section"><a href="#refresh-scope">2.9。刷新范围</a></span></dt><dt><span class="section"><a href="#_encryption_and_decryption">2.10。加密与解密</a></span></dt><dt><span class="section"><a href="#_endpoints">2.11。终点</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_commons_common_abstractions">3。Spring Cloud Commons：通用抽象</a></span></dt><dd><dl><dt><span class="section"><a href="#_enablediscoveryclient">3.1。@EnableDiscoveryClient</a></span></dt><dd><dl><dt><span class="section"><a href="#_health_indicator">3.1.1。健康指标</a></span></dt><dt><span class="section"><a href="#_ordering_discoveryclient_instances">3.1.2。定购<code class="literal">DiscoveryClient</code>实例</a></span></dt></dl></dd><dt><span class="section"><a href="#_serviceregistry">3.2。服务注册</a></span></dt><dd><dl><dt><span class="section"><a href="#_serviceregistry_auto_registration">3.2.1。ServiceRegistry自动注册</a></span></dt><dd><dl><dt><span class="section"><a href="#_serviceregistry_auto_registration_events">ServiceRegistry自动注册事件</a></span></dt></dl></dd><dt><span class="section"><a href="#_service_registry_actuator_endpoint">3.2.2。服务注册表执行器端点</a></span></dt></dl></dd><dt><span class="section"><a href="#_spring_resttemplate_as_a_load_balancer_client">3.3。Spring RestTemplate作为负载均衡器客户端</a></span></dt><dt><span class="section"><a href="#_spring_webclient_as_a_load_balancer_client">3.4。Spring WebClient作为负载均衡器客户端</a></span></dt><dd><dl><dt><span class="section"><a href="#_retrying_failed_requests">3.4.1。重试失败的请求</a></span></dt></dl></dd><dt><span class="section"><a href="#_multiple_resttemplate_objects">3.5。多个RestTemplate对象</a></span></dt><dt><span class="section"><a href="#loadbalanced-webclient">3.6。Spring WebFlux WebClient作为负载均衡器客户端</a></span></dt><dd><dl><dt><span class="section"><a href="#webflux-with-reactive-loadbalancer">3.6.1。带有响应式负载均衡器的Spring WebFlux WebClient</a></span></dt><dt><span class="section"><a href="#_spring_webflux_webclient_with_non_reactive_load_balancer_client">3.6.2。带有非反应式负载均衡器客户端的Spring WebFlux WebClient</a></span></dt><dt><span class="section"><a href="#_passing_your_own_load_balancer_client_configuration">3.6.3。传递自己的Load-Balancer客户端配置</a></span></dt></dl></dd><dt><span class="section"><a href="#ignore-network-interfaces">3.7。忽略网络接口</a></span></dt><dt><span class="section"><a href="#http-clients">3.8。HTTP客户端工厂</a></span></dt><dt><span class="section"><a href="#enabled-features">3.9。启用的功能</a></span></dt><dd><dl><dt><span class="section"><a href="#_feature_types">3.9.1。功能类型</a></span></dt><dt><span class="section"><a href="#_declaring_features">3.9.2。声明功能</a></span></dt></dl></dd><dt><span class="section"><a href="#_spring_cloud_compatibility_verification">3.10。Spring Cloud兼容性验证</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_config">二。 Spring Cloud Config</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_quick_start">4。快速开始</a></span></dt><dd><dl><dt><span class="section"><a href="#_client_side_usage">4.1。客户端使用</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_config_server">5，Spring Cloud Config服务器</a></span></dt><dd><dl><dt><span class="section"><a href="#_environment_repository">5.1。环境资料库</a></span></dt><dd><dl><dt><span class="section"><a href="#_git_backend">5.1.1。Git后端</a></span></dt><dd><dl><dt><span class="section"><a href="#_skipping_ssl_certificate_validation">跳过SSL证书验证</a></span></dt><dt><span class="section"><a href="#_setting_http_connection_timeout">设置HTTP连接超时</a></span></dt><dt><span class="section"><a href="#_placeholders_in_git_uri">Git URI中的占位符</a></span></dt><dt><span class="section"><a href="#_pattern_matching_and_multiple_repositories">模式匹配和多个存储库</a></span></dt><dt><span class="section"><a href="#_authentication">认证方式</a></span></dt><dt><span class="section"><a href="#_authentication_with_aws_codecommit">使用AWS CodeCommit进行身份验证</a></span></dt><dt><span class="section"><a href="#_git_ssh_configuration_using_properties">使用属性进行Git SSH配置</a></span></dt><dt><span class="section"><a href="#_placeholders_in_git_search_paths">Git搜索路径中的占位符</a></span></dt><dt><span class="section"><a href="#_force_pull_in_git_repositories">强制拉入Git存储库</a></span></dt><dt><span class="section"><a href="#_deleting_untracked_branches_in_git_repositories">删除Git存储库中未跟踪的分支</a></span></dt><dt><span class="section"><a href="#_git_refresh_rate">Git刷新率</a></span></dt></dl></dd><dt><span class="section"><a href="#_version_control_backend_filesystem_use">5.1.2。版本控制后端文件系统使用</a></span></dt><dt><span class="section"><a href="#_file_system_backend">5.1.3。文件系统后端</a></span></dt><dt><span class="section"><a href="#vault-backend">5.1.4。保管库后端</a></span></dt><dd><dl><dt><span class="section"><a href="#_multiple_properties_sources">多个属性来源</a></span></dt></dl></dd><dt><span class="section"><a href="#_accessing_backends_through_a_proxy">5.1.5。通过代理访问后端</a></span></dt><dt><span class="section"><a href="#_sharing_configuration_with_all_applications">5.1.6。与所有应用程序共享配置</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-config-server-file-based-repositories">基于文件的存储库</a></span></dt><dt><span class="section"><a href="#spring-cloud-config-server-vault-server">保管箱服务器</a></span></dt></dl></dd><dt><span class="section"><a href="#_jdbc_backend">5.1.7。JDBC后端</a></span></dt><dt><span class="section"><a href="#_credhub_backend">5.1.8。CredHub后端</a></span></dt><dd><dl><dt><span class="section"><a href="#_oauth_2_0">OAuth 2.0</a></span></dt></dl></dd><dt><span class="section"><a href="#composite-environment-repositories">5.1.9。复合环境存储库</a></span></dt><dd><dl><dt><span class="section"><a href="#_custom_composite_environment_repositories">定制复合环境存储库</a></span></dt></dl></dd><dt><span class="section"><a href="#_property_overrides">5.1.10。物业替代</a></span></dt></dl></dd><dt><span class="section"><a href="#_health_indicator_2">5.2。健康指标</a></span></dt><dt><span class="section"><a href="#_security">5.3。安全</a></span></dt><dt><span class="section"><a href="#_encryption_and_decryption_2">5.4。加密与解密</a></span></dt><dt><span class="section"><a href="#_key_management">5.5。密钥管理</a></span></dt><dt><span class="section"><a href="#_creating_a_key_store_for_testing">5.6。创建密钥库进行测试</a></span></dt><dt><span class="section"><a href="#_using_multiple_keys_and_key_rotation">5.7。使用多个按键和按键旋转</a></span></dt><dt><span class="section"><a href="#_serving_encrypted_properties">5.8。提供加密的属性</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_serving_alternative_formats">6。提供替代格式</a></span></dt><dt><span class="chapter"><a href="#_serving_plain_text">7。提供纯文本</a></span></dt><dt><span class="chapter"><a href="#_embedding_the_config_server">8。嵌入配置服务器</a></span></dt><dt><span class="chapter"><a href="#_push_notifications_and_spring_cloud_bus">9。推送通知和Spring Cloud Bus</a></span></dt><dt><span class="chapter"><a href="#_spring_cloud_config_client">10。Spring Cloud Config客户端</a></span></dt><dd><dl><dt><span class="section"><a href="#config-first-bootstrap">10.1。配置第一个引导程序</a></span></dt><dt><span class="section"><a href="#discovery-first-bootstrap">10.2。发现第一引导</a></span></dt><dt><span class="section"><a href="#config-client-fail-fast">10.3。快速配置客户端失败</a></span></dt><dt><span class="section"><a href="#config-client-retry">10.4。配置客户端重试</a></span></dt><dt><span class="section"><a href="#_locating_remote_configuration_resources">10.5。查找远程配置资源</a></span></dt><dt><span class="section"><a href="#_specifying_multiple_urls_for_the_config_server">10.6。为配置服务器指定多个地址</a></span></dt><dt><span class="section"><a href="#_configuring_timeouts">10.7。配置超时</a></span></dt><dt><span class="section"><a href="#_security_2">10.8。安全</a></span></dt><dd><dl><dt><span class="section"><a href="#_health_indicator_3">10.8.1。健康指标</a></span></dt><dt><span class="section"><a href="#custom-rest-template">10.8.2。提供自定义的RestTemplate</a></span></dt><dt><span class="section"><a href="#_vault">10.8.3。 Vault </a></span></dt></dl></dd><dt><span class="section"><a href="#_nested_keys_in_vault">10.9。 Vault 中的嵌套键</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_netflix">三， Spring Cloud Netflix</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_service_discovery_eureka_clients">11。服务发现：Eureka客户</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-eureka-client-starter">11.1。如何包括尤里卡客户</a></span></dt><dt><span class="section"><a href="#_registering_with_eureka">11.2。在尤里卡注册</a></span></dt><dt><span class="section"><a href="#_authenticating_with_the_eureka_server">11.3。使用Eureka服务器进行身份验证</a></span></dt><dt><span class="section"><a href="#_status_page_and_health_indicator">11.4。状态页和健康指示器</a></span></dt><dt><span class="section"><a href="#_registering_a_secure_application">11.5。注册安全的应用程序</a></span></dt><dt><span class="section"><a href="#_eurekas_health_checks">11.6。尤里卡的健康检查</a></span></dt><dt><span class="section"><a href="#_eureka_metadata_for_instances_and_clients">11.7。实例和客户端的Eureka元数据</a></span></dt><dd><dl><dt><span class="section"><a href="#_using_eureka_on_cloud_foundry">11.7.1。在Cloud Foundry上使用Eureka</a></span></dt><dt><span class="section"><a href="#_using_eureka_on_aws">11.7.2。在AWS上使用Eureka</a></span></dt><dt><span class="section"><a href="#_changing_the_eureka_instance_id">11.7.3。更改尤里卡实例ID</a></span></dt></dl></dd><dt><span class="section"><a href="#_using_the_eurekaclient">11.8。使用EurekaClient</a></span></dt><dd><dl><dt><span class="section"><a href="#_eurekaclient_without_jersey">11.8.1。没有球衣的EurekaClient</a></span></dt></dl></dd><dt><span class="section"><a href="#_alternatives_to_the_native_netflix_eurekaclient">11.9。本地Netflix EurekaClient的替代产品</a></span></dt><dt><span class="section"><a href="#_why_is_it_so_slow_to_register_a_service">11.10。为什么注册服务这么慢？</a></span></dt><dt><span class="section"><a href="#_zones">11.11。区域</a></span></dt><dt><span class="section"><a href="#_refreshing_eureka_clients">11.12。刷新尤里卡客户</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-eureka-server">12服务发现：Eureka服务器</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-eureka-server-starter">12.1。如何包含Eureka服务器</a></span></dt><dt><span class="section"><a href="#spring-cloud-running-eureka-server">12.2。如何运行尤里卡服务器</a></span></dt><dt><span class="section"><a href="#spring-cloud-eureka-server-zones-and-regions">12.3。高可用性，区域和区域</a></span></dt><dt><span class="section"><a href="#spring-cloud-eureka-server-standalone-mode">12.4。独立模式</a></span></dt><dt><span class="section"><a href="#spring-cloud-eureka-server-peer-awareness">12.5。同行意识</a></span></dt><dt><span class="section"><a href="#spring-cloud-eureka-server-prefer-ip-address">12.6。何时首选IP地址</a></span></dt><dt><span class="section"><a href="#_securing_the_eureka_server">12.7。保护Eureka服务器</a></span></dt><dt><span class="section"><a href="#_jdk_11_support">12.8。JDK 11支持</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_circuit_breaker_hystrix_clients">13断路器：Hystrix客户</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_to_include_hystrix">13.1。如何包括Hystrix</a></span></dt><dt><span class="section"><a href="#netflix-hystrix-starter">13.2。传播安全上下文或使用Spring Scope</a></span></dt><dt><span class="section"><a href="#_health_indicator_4">13.3。健康指标</a></span></dt><dt><span class="section"><a href="#_hystrix_metrics_stream">13.4。Hystrix指标流</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_circuit_breaker_hystrix_dashboard">14。断路器：Hystrix仪表板</a></span></dt><dt><span class="chapter"><a href="#_hystrix_timeouts_and_ribbon_clients">15Hystrix超时和功能区客户端</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-hystrix-dashboard-starter">15.1。如何包括Hystrix仪表板</a></span></dt><dt><span class="section"><a href="#_turbine">15.2。涡轮</a></span></dt><dd><dl><dt><span class="section"><a href="#_clusters_endpoint">15.2.1。集群端点</a></span></dt></dl></dd><dt><span class="section"><a href="#_turbine_stream">15.3。涡轮流</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-ribbon">16。客户端负载均衡器：功能区</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-ribbon-starter">16.1。如何包括功能区</a></span></dt><dt><span class="section"><a href="#_customizing_the_ribbon_client">16.2。自定义功能区客户端</a></span></dt><dt><span class="section"><a href="#_customizing_the_default_for_all_ribbon_clients">16.3。为所有功能区客户端自定义默认值</a></span></dt><dt><span class="section"><a href="#_customizing_the_ribbon_client_by_setting_properties">16.4。通过设置属性来自定义功能区客户端</a></span></dt><dt><span class="section"><a href="#_using_ribbon_with_eureka">16.5。将功能区与Eureka一起使用</a></span></dt><dt><span class="section"><a href="#spring-cloud-ribbon-without-eureka">16.6。示例：如何在没有尤里卡的情况下使用色带</a></span></dt><dt><span class="section"><a href="#_example_disable_eureka_use_in_ribbon">16.7。示例：禁用功能区中的尤里卡使用</a></span></dt><dt><span class="section"><a href="#_using_the_ribbon_api_directly">16.8。直接使用功能区API</a></span></dt><dt><span class="section"><a href="#ribbon-child-context-eager-load">16.9。缓存功能区配置</a></span></dt><dt><span class="section"><a href="#how-to-configure-hystrix-thread-pools">16.10。如何配置Hystrix线程池</a></span></dt><dt><span class="section"><a href="#how-to-provdie-a-key-to-ribbon">16.11。如何提供功能区的密钥<code class="literal">IRule</code></a></span></dt></dl></dd><dt><span class="chapter"><a href="#_external_configuration_archaius">17。外部配置：Archaius</a></span></dt><dt><span class="chapter"><a href="#_router_and_filter_zuul">18岁路由器和过滤器：Zuul</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-zuul-starter">18.1。如何包含Zuul</a></span></dt><dt><span class="section"><a href="#netflix-zuul-reverse-proxy">18.2。嵌入式Zuul反向代理</a></span></dt><dt><span class="section"><a href="#_zuul_http_client">18.3。Zuul Http客户端</a></span></dt><dt><span class="section"><a href="#_cookies_and_sensitive_headers">18.4。Cookie和敏感标题</a></span></dt><dt><span class="section"><a href="#_ignored_headers">18.5。忽略标题</a></span></dt><dt><span class="section"><a href="#_management_endpoints">18.6。管理端点</a></span></dt><dd><dl><dt><span class="section"><a href="#_routes_endpoint">18.6.1。路线终点</a></span></dt><dt><span class="section"><a href="#_filters_endpoint">18.6.2。过滤端点</a></span></dt></dl></dd><dt><span class="section"><a href="#_strangulation_patterns_and_local_forwards">18.7。勒索模式和本地前锋</a></span></dt><dt><span class="section"><a href="#_uploading_files_through_zuul">18.8。通过Zuul上传文件</a></span></dt><dt><span class="section"><a href="#_query_string_encoding">18.9。查询字符串编码</a></span></dt><dt><span class="section"><a href="#_request_uri_encoding">18.10。请求URI编码</a></span></dt><dt><span class="section"><a href="#_plain_embedded_zuul">18.11。纯色嵌入式Zuul</a></span></dt><dt><span class="section"><a href="#_disable_zuul_filters">18.12。禁用Zuul过滤器</a></span></dt><dt><span class="section"><a href="#hystrix-fallbacks-for-routes">18.13。提供路线的Hystrix后备</a></span></dt><dt><span class="section"><a href="#_zuul_timeouts">18.14。Zuul超时</a></span></dt><dt><span class="section"><a href="#zuul-redirect-location-rewrite">18.15。改写<code class="literal">Location</code>标头</a></span></dt><dt><span class="section"><a href="#_enabling_cross_origin_requests">18.16。启用跨源请求</a></span></dt><dt><span class="section"><a href="#_metrics">18.17。指标</a></span></dt><dt><span class="section"><a href="#zuul-developer-guide">18.18。Zuul开发人员指南</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_zuul_servlet">18.18.1。Zuul Servlet</a></span></dt><dt><span class="section"><a href="#_zuul_requestcontext">18.18.2。Zuul RequestContext</a></span></dt><dt><span class="section"><a href="#_enablezuulproxy_vs_enablezuulserver">18.18.3。 <code class="literal">@EnableZuulProxy</code>与<code class="literal">@EnableZuulServer</code></a></span></dt><dt><span class="section"><a href="#zuul-developer-guide-enable-filters">18.18.4。 <code class="literal">@EnableZuulServer</code> 筛选器</a></span></dt><dt><span class="section"><a href="#_enablezuulproxy_filters">18.18.5。 <code class="literal">@EnableZuulProxy</code> 筛选器</a></span></dt><dt><span class="section"><a href="#_custom_zuul_filter_examples">18.18.6。自定义Zuul过滤器示例</a></span></dt><dd><dl><dt><span class="section"><a href="#zuul-developer-guide-sample-pre-filter">如何编写预过滤器</a></span></dt><dt><span class="section"><a href="#zuul-developer-guide-sample-route-filter">如何编写路由过滤器</a></span></dt><dt><span class="section"><a href="#zuul-developer-guide-sample-post-filter">如何编写帖子过滤器</a></span></dt></dl></dd><dt><span class="section"><a href="#_how_zuul_errors_work">18.18.7。Zuul错误如何工作</a></span></dt><dt><span class="section"><a href="#_zuul_eager_application_context_loading">18.18.8。Zuul急切的应用程序上下文加载</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_polyglot_support_with_sidecar">19Sidecar支持多语种</a></span></dt><dt><span class="chapter"><a href="#retrying-failed-requests">20重试失败的请求</a></span></dt><dd><dl><dt><span class="section"><a href="#_backoff_policies">20.1。退避政策</a></span></dt><dt><span class="section"><a href="#_configuration">20.2。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#_zuul">20.2.1。祖尔</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_http_clients">21HTTP客户端</a></span></dt><dt><span class="chapter"><a href="#_modules_in_maintenance_mode">22维护模式下的模块</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_openfeign">IV。 Spring Cloud OpenFeign</a></span></dt><dd><dl><dt><span class="chapter"><a href="#spring-cloud-feign">23。声明式REST客户端：伪装</a></span></dt><dd><dl><dt><span class="section"><a href="#netflix-feign-starter">23.1。如何包含假装</a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-overriding-defaults">23.2。覆盖伪默认</a></span></dt><dt><span class="section"><a href="#_creating_feign_clients_manually">23.3。手动创建假客户</a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-hystrix">23.4。Feign Hystrix支持</a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-hystrix-fallback">23.5。假装Hystrix后备</a></span></dt><dt><span class="section"><a href="#_feign_and_primary">23.6。假装和<code class="literal">@Primary</code></a></span></dt><dt><span class="section"><a href="#spring-cloud-feign-inheritance">23.7。假继承支持</a></span></dt><dt><span class="section"><a href="#_feign_requestresponse_compression">23.8。伪装请求/响应压缩</a></span></dt><dt><span class="section"><a href="#_feign_logging">23.9。伪装伐木</a></span></dt><dt><span class="section"><a href="#_feign_querymap_support">23.10。假装@QueryMap支持</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_stream">V. Spring Cloud Stream </a></span></dt><dd><dl><dt><span class="chapter"><a href="#_a_brief_history_of_springs_data_integration_journey">24Spring数据集成之旅简史</a></span></dt><dt><span class="chapter"><a href="#_quick_start_2">25岁快速开始</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-preface-creating-sample-application">25.1。使用Spring Initializr创建示例应用程序</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-preface-importing-project">25.2。将项目导入您的IDE</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-preface-adding-message-handler">25.3。添加消息处理程序，构建并运行</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_whats_new_in_2_0">262.0中有什么新功能？</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-preface-new-features">26.1。新功能和组件</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-preface-notable-enhancements">26.2。显着增强</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-preface-actuator-web-dependencies">26.2.1。执行器和Web依赖关系现在都是可选的</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-preface-content-type-negotiation-improvements">26.2.2。内容类型协商的改进</a></span></dt></dl></dd><dt><span class="section"><a href="#spring-cloud-stream-preface-notable-deprecations">26.3。显着的弃用</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-preface-deprecation-java-serialization">26.3.1。Java序列化（Java本机和Kryo）</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-preface-deprecation-classes-methods">26.3.2。不推荐使用的类和方法</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#spring-cloud-stream-overview-introducing">27。介绍Spring Cloud Stream</a></span></dt><dt><span class="chapter"><a href="#_main_concepts">28岁主要概念</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-overview-application-model">28.1。应用模式</a></span></dt><dd><dl><dt><span class="section"><a href="#_fat_jar">28.1.1。胖子</a></span></dt></dl></dd><dt><span class="section"><a href="#spring-cloud-stream-overview-binder-abstraction">28.2。活页夹抽象</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-persistent-publish-subscribe-support">28.3。持久的发布-订阅支持</a></span></dt><dt><span class="section"><a href="#consumer-groups">28.4。消费群体</a></span></dt><dt><span class="section"><a href="#consumer-types">28.5。消费者类型</a></span></dt><dd><dl><dt><span class="section"><a href="#durability">28.5.1。耐用性</a></span></dt></dl></dd><dt><span class="section"><a href="#partitioning">28.6。分区支持</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_programming_model">29。程式设计模型</a></span></dt><dd><dl><dt><span class="section"><a href="#_destination_binders">29.1。目标绑定</a></span></dt><dt><span class="section"><a href="#_destination_bindings">29.2。目标绑定</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-producing-consuming-messages">29.3。生产和消费信息</a></span></dt><dd><dl><dt><span class="section"><a href="#_spring_integration_support">29.3.1。Spring集成支持</a></span></dt><dt><span class="section"><a href="#_using_streamlistener_annotation">29.3.2。使用@StreamListener注释</a></span></dt><dt><span class="section"><a href="#_using_streamlistener_for_content_based_routing">29.3.3。使用@StreamListener进行基于内容的路由</a></span></dt><dt><span class="section"><a href="#_spring_cloud_function">29.3.4。Spring Cloud功能支持</a></span></dt><dd><dl><dt><span class="section"><a href="#_functional_composition">功能组成</a></span></dt></dl></dd><dt><span class="section"><a href="#spring-cloud-streams-overview-using-polled-consumers">29.3.5。使用轮询的消费者</a></span></dt><dd><dl><dt><span class="section"><a href="#_overview">总览</a></span></dt><dt><span class="section"><a href="#polled-errors">处理错误</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#spring-cloud-stream-overview-error-handling">29.4。错误处理</a></span></dt><dd><dl><dt><span class="section"><a href="#_application_error_handling">29.4.1。应用错误处理</a></span></dt><dt><span class="section"><a href="#_system_error_handling">29.4.2。系统错误处理</a></span></dt><dd><dl><dt><span class="section"><a href="#_drop_failed_messages">删除失败的消息</a></span></dt><dt><span class="section"><a href="#_dlq_dead_letter_queue">DLQ-死信队列</a></span></dt><dt><span class="section"><a href="#_re_queue_failed_messages">重新排队失败的消息</a></span></dt></dl></dd><dt><span class="section"><a href="#_retry_template">29.4.3。重试模板</a></span></dt></dl></dd><dt><span class="section"><a href="#spring-cloud-stream-overview-reactive-programming-support">29.5。反应式编程支持</a></span></dt><dd><dl><dt><span class="section"><a href="#_reactor_based_handlers">29.5.1。基于反应堆的处理程序</a></span></dt><dt><span class="section"><a href="#_reactive_sources">29.5.2。反应源</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#spring-cloud-stream-overview-binders">30岁黏合剂</a></span></dt><dd><dl><dt><span class="section"><a href="#_producers_and_consumers">30.1。生产者和消费者</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-binder-api">30.2。活页夹SPI</a></span></dt><dt><span class="section"><a href="#_binder_detection">30.3。活页夹检测</a></span></dt><dd><dl><dt><span class="section"><a href="#_classpath_detection">30.3.1。类路径检测</a></span></dt></dl></dd><dt><span class="section"><a href="#multiple-binders">30.4。类路径上的多个绑定器</a></span></dt><dt><span class="section"><a href="#multiple-systems">30.5。连接到多个系统</a></span></dt><dt><span class="section"><a href="#_binding_visualization_and_control">30.6。绑定可视化和控制</a></span></dt><dt><span class="section"><a href="#_binder_configuration_properties">30.7。活页夹配置属性</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_configuration_options">31。配置选项</a></span></dt><dd><dl><dt><span class="section"><a href="#_binding_service_properties">31.1。绑定服务属性</a></span></dt><dt><span class="section"><a href="#binding-properties">31.2。绑定属性</a></span></dt><dd><dl><dt><span class="section"><a href="#_common_binding_properties">31.2.1。常用绑定属性</a></span></dt><dt><span class="section"><a href="#_consumer_properties">31.2.2。消费者财产</a></span></dt><dt><span class="section"><a href="#_producer_properties">31.2.3。生产者属性</a></span></dt></dl></dd><dt><span class="section"><a href="#dynamicdestination">31.3。使用动态绑定的目的地</a></span></dt></dl></dd><dt><span class="chapter"><a href="#content-type-management">32。内容类型协商</a></span></dt><dd><dl><dt><span class="section"><a href="#_mechanics">32.1。机械学</a></span></dt><dd><dl><dt><span class="section"><a href="#_content_type_versus_argument_type">32.1.1。内容类型与参数类型</a></span></dt><dt><span class="section"><a href="#_message_converters">32.1.2。讯息转换器</a></span></dt></dl></dd><dt><span class="section"><a href="#_provided_messageconverters">32.2。提供的MessageConverters</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-user-defined-message-converters">32.3。用户定义的消息转换器</a></span></dt></dl></dd><dt><span class="chapter"><a href="#schema-evolution">33。模式演进支持</a></span></dt><dd><dl><dt><span class="section"><a href="#_schema_registry_client">33.1。架构注册表客户端</a></span></dt><dd><dl><dt><span class="section"><a href="#_schema_registry_client_properties">33.1.1。架构注册表客户端属性</a></span></dt></dl></dd><dt><span class="section"><a href="#_avro_schema_registry_client_message_converters">33.2。Avro Schema Registry客户端消息转换器</a></span></dt><dd><dl><dt><span class="section"><a href="#_avro_schema_registry_message_converter_properties">33.2.1。Avro架构注册表消息转换器属性</a></span></dt></dl></dd><dt><span class="section"><a href="#_apache_avro_message_converters">33.3。Apache Avro消息转换器</a></span></dt><dt><span class="section"><a href="#_converters_with_schema_support">33.4。具有模式支持的转换器</a></span></dt><dt><span class="section"><a href="#_schema_registry_server">33.5。架构注册表服务器</a></span></dt><dd><dl><dt><span class="section"><a href="#_schema_registry_server_api">33.5.1。架构注册表服务器API</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-overview-registering-new-schema">注册新架构</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version">通过主题，格式和版本检索现有架构</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-retrieve-schema-subject-format">通过主题和格式检索现有模式</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-retrieve-schema-id">通过ID检索现有架构</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-deleting-schema-subject-format-version">按主题，格式和版本删除架构</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-deleting-schema-id">通过ID删除架构</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-deleting-schema-subject">按主题删除架构</a></span></dt></dl></dd><dt><span class="section"><a href="#_using_confluents_schema_registry">33.5.2。使用Confluent的架构注册表</a></span></dt></dl></dd><dt><span class="section"><a href="#_schema_registration_and_resolution">33.6。模式注册和解析</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-overview-schema-registration-process">33.6.1。模式注册过程（序列化）</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-schema-resolution-process">33.6.2。模式解析过程（反序列化）</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_inter_application_communication">34。应用间通信</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-overview-connecting-multiple-application-instances">34.1。连接多个应用程序实例</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-instance-index-instance-count">34.2。实例索引和实例计数</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-partitioning">34.3。分区</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning">34.3.1。配置输出绑定以进行分区</a></span></dt><dt><span class="section"><a href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning">34.3.2。配置输入绑定以进行分区</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_testing">35岁测试中</a></span></dt><dd><dl><dt><span class="section"><a href="#_disabling_the_test_binder_autoconfiguration">35.1。禁用测试绑定程序自动配置</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_health_indicator_5">36。健康指标</a></span></dt><dt><span class="chapter"><a href="#spring-cloud-stream-overview-metrics-emitter">37。公制发射器</a></span></dt><dt><span class="chapter"><a href="#_samples">38。样品</a></span></dt><dd><dl><dt><span class="section"><a href="#_deploying_stream_applications_on_cloudfoundry">38.1。在CloudFoundry上部署流应用程序</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_binder_implementations">VI。活页夹实现</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_apache_kafka_binder">39。Apache Kafka活页夹</a></span></dt><dd><dl><dt><span class="section"><a href="#_usage">39.1。用法</a></span></dt><dt><span class="section"><a href="#_apache_kafka_binder_overview">39.2。Apache Kafka Binder概述</a></span></dt><dt><span class="section"><a href="#_configuration_options_2">39.3。配置选项</a></span></dt><dd><dl><dt><span class="section"><a href="#_kafka_binder_properties">39.3.1。Kafka Binder属性</a></span></dt><dt><span class="section"><a href="#kafka-consumer-properties">39.3.2。卡夫卡消费物业</a></span></dt><dt><span class="section"><a href="#kafka-producer-properties">39.3.3。Kafka Producer属性</a></span></dt><dt><span class="section"><a href="#_usage_examples">39.3.4。用法示例</a></span></dt><dd><dl><dt><span class="section"><a href="#_example_setting_autocommitoffset_to_false_and_relying_on_manual_acking">示例：设置<code class="literal">autoCommitOffset</code>至<code class="literal">false</code>和依靠手工起搏</a></span></dt><dt><span class="section"><a href="#_example_security_configuration">示例：安全配置</a></span></dt><dt><span class="section"><a href="#pause-resume">示例：暂停和恢复使用方</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#kafka-error-channels">39.4。错误通道</a></span></dt><dt><span class="section"><a href="#kafka-metrics">39.5。卡夫卡指标</a></span></dt><dt><span class="section"><a href="#kafka-dlq-processing">39.6。死信主题处理</a></span></dt><dt><span class="section"><a href="#_partitioning_with_the_kafka_binder">39.7。使用Kafka活页夹进行分区</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_apache_kafka_streams_binder">40Apache Kafka Streams活页夹</a></span></dt><dd><dl><dt><span class="section"><a href="#_usage_2">40.1。用法</a></span></dt><dt><span class="section"><a href="#_kafka_streams_binder_overview">40.2。Kafka Streams Binder概述</a></span></dt><dd><dl><dt><span class="section"><a href="#_streams_dsl">40.2.1。流DSL</a></span></dt></dl></dd><dt><span class="section"><a href="#_configuration_options_3">40.3。配置选项</a></span></dt><dd><dl><dt><span class="section"><a href="#_kafka_streams_properties">40.3.1。Kafka Streams属性</a></span></dt><dt><span class="section"><a href="#_timewindow_properties">40.3.2。TimeWindow属性：</a></span></dt></dl></dd><dt><span class="section"><a href="#_multiple_input_bindings">40.4。多个输入绑定</a></span></dt><dd><dl><dt><span class="section"><a href="#_multiple_input_bindings_as_a_sink">40.4.1。多个输入绑定作为接收器</a></span></dt><dt><span class="section"><a href="#_multiple_input_bindings_as_a_processor">40.4.2。多个输入绑定作为处理器</a></span></dt></dl></dd><dt><span class="section"><a href="#_multiple_output_bindings_aka_branching">40.5。多个输出绑定（又名分支）</a></span></dt><dt><span class="section"><a href="#_message_conversion">40.6。讯息转换</a></span></dt><dd><dl><dt><span class="section"><a href="#_outbound_serialization">40.6.1。出站序列化</a></span></dt><dt><span class="section"><a href="#_inbound_deserialization">40.6.2。入站反序列化</a></span></dt></dl></dd><dt><span class="section"><a href="#_error_handling">40.7。错误处理</a></span></dt><dd><dl><dt><span class="section"><a href="#_handling_deserialization_exceptions">40.7.1。处理反序列化异常</a></span></dt><dt><span class="section"><a href="#_handling_non_deserialization_exceptions">40.7.2。处理非反序列化异常</a></span></dt></dl></dd><dt><span class="section"><a href="#_state_store">40.8。国营商店</a></span></dt><dt><span class="section"><a href="#_interactive_queries">40.9。互动查询</a></span></dt><dt><span class="section"><a href="#_accessing_the_underlying_kafkastreams_object">40.10。访问基础的KafkaStreams对象</a></span></dt><dt><span class="section"><a href="#_state_cleanup">40.11。状态清理</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_rabbitmq_binder">41。RabbitMQ活页夹</a></span></dt><dd><dl><dt><span class="section"><a href="#_usage_3">41.1。用法</a></span></dt><dt><span class="section"><a href="#_rabbitmq_binder_overview">41.2。RabbitMQ活页夹概述</a></span></dt><dt><span class="section"><a href="#_configuration_options_4">41.3配置选项</a></span></dt><dd><dl><dt><span class="section"><a href="#rabbit-binder-properties">41.3.1。RabbitMQ活页夹属性</a></span></dt><dt><span class="section"><a href="#_rabbitmq_consumer_properties">41.3.2。RabbitMQ消费者属性</a></span></dt><dt><span class="section"><a href="#_advanced_listener_container_configuration">41.3.3。高级侦听器容器配置</a></span></dt><dt><span class="section"><a href="#_rabbit_producer_properties">41.3.4。兔子生产者属性</a></span></dt></dl></dd><dt><span class="section"><a href="#_retry_with_the_rabbitmq_binder">41.4。使用RabbitMQ粘合剂重试</a></span></dt><dd><dl><dt><span class="section"><a href="#_putting_it_all_together">41.4.1。放在一起</a></span></dt></dl></dd><dt><span class="section"><a href="#rabbit-error-channels">41.5。错误通道</a></span></dt><dt><span class="section"><a href="#rabbit-dlq-processing">41.6。死信队列处理</a></span></dt><dd><dl><dt><span class="section"><a href="#_non_partitioned_destinations">41.6.1。非分区目的地</a></span></dt><dt><span class="section"><a href="#_partitioned_destinations">41.6.2。分区目的地</a></span></dt><dd><dl><dt><span class="section"><a href="#_republishtodlqfalse"><code class="literal">republishToDlq=false</code></a></span></dt><dt><span class="section"><a href="#_republishtodlqtrue"><code class="literal">republishToDlq=true</code></a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_partitioning_with_the_rabbitmq_binder">41.7。使用RabbitMQ活页夹进行分区</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_bus">七。spring-cloud-bus</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_quick_start_3">42。快速开始</a></span></dt><dt><span class="chapter"><a href="#_bus_endpoints">43。总线端点</a></span></dt><dd><dl><dt><span class="section"><a href="#_bus_refresh_endpoint">43.1。总线刷新端点</a></span></dt><dt><span class="section"><a href="#_bus_env_endpoint">43.2。总线环境端点</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_addressing_an_instance">44。寻址实例</a></span></dt><dt><span class="chapter"><a href="#_addressing_all_instances_of_a_service">45。处理服务的所有实例</a></span></dt><dt><span class="chapter"><a href="#_service_id_must_be_unique">46。服务ID必须唯一</a></span></dt><dt><span class="chapter"><a href="#_customizing_the_message_broker">47。自定义消息代理</a></span></dt><dt><span class="chapter"><a href="#_tracing_bus_events">48。追踪巴士事件</a></span></dt><dt><span class="chapter"><a href="#_broadcasting_your_own_events">49。广播自己的活动</a></span></dt><dd><dl><dt><span class="section"><a href="#_registering_events_in_custom_packages">49.1。在自定义包中注册事件</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_sleuth">八。 Spring Cloud Sleuth </a></span></dt><dd><dl><dt><span class="chapter"><a href="#_introduction">50介绍</a></span></dt><dd><dl><dt><span class="section"><a href="#_terminology">50.1。术语</a></span></dt><dt><span class="section"><a href="#_purpose">50.2。目的</a></span></dt><dd><dl><dt><span class="section"><a href="#_distributed_tracing_with_zipkin">50.2.1。使用Zipkin进行分布式跟踪</a></span></dt><dt><span class="section"><a href="#_visualizing_errors">50.2.2。可视化错误</a></span></dt><dt><span class="section"><a href="#_distributed_tracing_with_brave">50.2.3。勇敢的分布式跟踪</a></span></dt><dt><span class="section"><a href="#_live_examples">50.2.4。现场例子</a></span></dt><dt><span class="section"><a href="#_log_correlation">50.2.5。日志关联</a></span></dt><dd><dl><dt><span class="section"><a href="#_json_logback_with_logstash">使用Logstash进行JSON Logback</a></span></dt></dl></dd><dt><span class="section"><a href="#_propagating_span_context">50.2.6。传播跨度上下文</a></span></dt><dd><dl><dt><span class="section"><a href="#_baggage_versus_span_tags">行李与跨度标签</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#sleuth-adding-project">50.3将侦探添加到项目中</a></span></dt><dd><dl><dt><span class="section"><a href="#_only_sleuth_log_correlation">50.3.1。仅侦探（对数相关）</a></span></dt><dt><span class="section"><a href="#_sleuth_with_zipkin_via_http">50.3.2。通过HTTP与Zipkin一起侦探</a></span></dt><dt><span class="section"><a href="#_sleuth_with_zipkin_over_rabbitmq_or_kafka">50.3.3。与Zipkin一起在RabbitMQ或Kafka上侦探</a></span></dt></dl></dd><dt><span class="section"><a href="#_overriding_the_auto_configuration_of_zipkin">50.4。覆盖Zipkin的自动配置</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_additional_resources">51。其他资源</a></span></dt><dt><span class="chapter"><a href="#_features_2">52。特征</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction_to_brave">52.1。勇敢简介</a></span></dt><dd><dl><dt><span class="section"><a href="#_tracing">52.1.1。追踪</a></span></dt><dt><span class="section"><a href="#_local_tracing">52.1.2。本地追踪</a></span></dt><dt><span class="section"><a href="#_customizing_spans">52.1.3。自定义跨度</a></span></dt><dt><span class="section"><a href="#_implicitly_looking_up_the_current_span">52.1.4。隐式查找当前跨度</a></span></dt><dt><span class="section"><a href="#_rpc_tracing">52.1.5。RPC追踪</a></span></dt><dd><dl><dt><span class="section"><a href="#_one_way_tracing">单向跟踪</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#_sampling">53。采样</a></span></dt><dd><dl><dt><span class="section"><a href="#_declarative_sampling">53.1。声明式抽样</a></span></dt><dt><span class="section"><a href="#_custom_sampling">53.2。定制采样</a></span></dt><dt><span class="section"><a href="#_sampling_in_spring_cloud_sleuth">53.3。在Spring Cloud Sleuth中采样</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_propagation">54。传播</a></span></dt><dd><dl><dt><span class="section"><a href="#_propagating_extra_fields">54.1。传播额外的字段</a></span></dt><dd><dl><dt><span class="section"><a href="#prefixed-fields">54.1.1。前缀字段</a></span></dt><dt><span class="section"><a href="#_extracting_a_propagated_context">54.1.2。提取传播的上下文</a></span></dt><dt><span class="section"><a href="#_sharing_span_ids_between_client_and_server">54.1.3。在客户端和服务器之间共享范围ID</a></span></dt><dt><span class="section"><a href="#_implementing_propagation">54.1.4。实施传播</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_current_tracing_component">55。当前跟踪组件</a></span></dt><dt><span class="chapter"><a href="#_current_span">56。当前跨度</a></span></dt><dd><dl><dt><span class="section"><a href="#_setting_a_span_in_scope_manually">56.1。手动设置范围</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_instrumentation">57。仪器仪表</a></span></dt><dt><span class="chapter"><a href="#_span_lifecycle">58。跨度生命周期</a></span></dt><dd><dl><dt><span class="section"><a href="#creating-and-finishing-spans">58.1。创建和整理跨度</a></span></dt><dt><span class="section"><a href="#continuing-spans">58.2。连续跨度</a></span></dt><dt><span class="section"><a href="#creating-spans-with-explicit-parent">58.3。使用显式父级创建跨度</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_naming_spans">59。命名范围</a></span></dt><dd><dl><dt><span class="section"><a href="#_spanname_annotation">59.1。 <code class="literal">@SpanName</code> 注解</a></span></dt><dt><span class="section"><a href="#_tostring_method">59.2。 <code class="literal">toString()</code>方法</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_managing_spans_with_annotations">60使用注释管理跨度</a></span></dt><dd><dl><dt><span class="section"><a href="#_rationale">60.1。基本原理</a></span></dt><dt><span class="section"><a href="#_creating_new_spans">60.2。创建新的跨度</a></span></dt><dt><span class="section"><a href="#_continuing_spans">60.3。连续跨度</a></span></dt><dt><span class="section"><a href="#_advanced_tag_setting">60.4。高级标签设置</a></span></dt><dd><dl><dt><span class="section"><a href="#_custom_extractor">60.4.1。定制提取器</a></span></dt><dt><span class="section"><a href="#_resolving_expressions_for_a_value">60.4.2。为值解析表达式</a></span></dt><dt><span class="section"><a href="#_using_the_tostring_method">60.4.3。使用<code class="literal">toString()</code>方法</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_customizations">61。客制化</a></span></dt><dd><dl><dt><span class="section"><a href="#_customizers">61.1。客制化</a></span></dt><dt><span class="section"><a href="#_http">61.2。HTTP</a></span></dt><dt><span class="section"><a href="#_tracingfilter">61.3。<code class="literal">TracingFilter</code></a></span></dt><dt><span class="section"><a href="#_rpc">61.4。RPC</a></span></dt><dt><span class="section"><a href="#_custom_service_name">61.5。定制服务名称</a></span></dt><dt><span class="section"><a href="#_customization_of_reported_spans">61.6。自定义报告的跨度</a></span></dt><dt><span class="section"><a href="#_host_locator">61.7。主机定位器</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_sending_spans_to_zipkin">62。发送跨区到Zipkin</a></span></dt><dt><span class="chapter"><a href="#_zipkin_stream_span_consumer">63。Zipkin流跨度消费者</a></span></dt><dt><span class="chapter"><a href="#_integrations">64。整合方式</a></span></dt><dd><dl><dt><span class="section"><a href="#_opentracing">64.1。开放追踪</a></span></dt><dt><span class="section"><a href="#_runnable_and_callable">64.2。可运行和可调用</a></span></dt><dt><span class="section"><a href="#_hystrix">64.3。Hystrix</a></span></dt><dd><dl><dt><span class="section"><a href="#_custom_concurrency_strategy">64.3.1。自定义并发策略</a></span></dt><dt><span class="section"><a href="#_manual_command_setting">64.3.2。手动指令设定</a></span></dt></dl></dd><dt><span class="section"><a href="#_rxjava">64.4。RxJava的</a></span></dt><dt><span class="section"><a href="#_http_integration">64.5。HTTP整合</a></span></dt><dd><dl><dt><span class="section"><a href="#_http_filter">64.5.1。HTTP过滤器</a></span></dt><dt><span class="section"><a href="#_handlerinterceptor">64.5.2。处理程序拦截器</a></span></dt><dt><span class="section"><a href="#_async_servlet_support">64.5.3。异步Servlet支持</a></span></dt><dt><span class="section"><a href="#_webflux_support">64.5.4。WebFlux支持</a></span></dt><dt><span class="section"><a href="#_dubbo_rpc_support">64.5.5。Dubbo RPC支持</a></span></dt></dl></dd><dt><span class="section"><a href="#_http_client_integration">64.6。HTTP客户端集成</a></span></dt><dd><dl><dt><span class="section"><a href="#_synchronous_rest_template">64.6.1。同步休息模板</a></span></dt><dt><span class="section"><a href="#_asynchronous_rest_template">64.6.2。异步休息模板</a></span></dt><dd><dl><dt><span class="section"><a href="#_multiple_asynchronous_rest_templates">多个异步休息模板</a></span></dt></dl></dd><dt><span class="section"><a href="#_webclient">64.6.3。<code class="literal">WebClient</code></a></span></dt><dt><span class="section"><a href="#_traverson">64.6.4。特拉弗森</a></span></dt><dt><span class="section"><a href="#_apache_httpclientbuilder_and_httpasyncclientbuilder">64.6.5。阿帕奇<code class="literal">HttpClientBuilder</code>和<code class="literal">HttpAsyncClientBuilder</code></a></span></dt><dt><span class="section"><a href="#_netty_httpclient">64.6.6。净额<code class="literal">HttpClient</code></a></span></dt><dt><span class="section"><a href="#_userinforesttemplatecustomizer">64.6.7。<code class="literal">UserInfoRestTemplateCustomizer</code></a></span></dt></dl></dd><dt><span class="section"><a href="#_feign">64.7。假装</a></span></dt><dt><span class="section"><a href="#_grpc">64.8。 gRPC</a></span></dt><dd><dl><dt><span class="section"><a href="#_variant_1">64.8.1。变体1</a></span></dt><dd><dl><dt><span class="section"><a href="#_dependencies">依存关系</a></span></dt><dt><span class="section"><a href="#_server_instrumentation">服务器检测</a></span></dt><dt><span class="section"><a href="#_client_instrumentation">客户端工具</a></span></dt></dl></dd><dt><span class="section"><a href="#_variant_2">64.8.2。变体2</a></span></dt></dl></dd><dt><span class="section"><a href="#_asynchronous_communication">64.9。异步通讯</a></span></dt><dd><dl><dt><span class="section"><a href="#_async_annotated_methods">64.9.1。 <code class="literal">@Async</code> 带注释的方法</a></span></dt><dt><span class="section"><a href="#_scheduled_annotated_methods">64.9.2。 <code class="literal">@Scheduled</code> 带注释的方法</a></span></dt><dt><span class="section"><a href="#_executor_executorservice_and_scheduledexecutorservice">64.9.3。Executor，ExecutorService和ScheduledExecutorService</a></span></dt><dd><dl><dt><span class="section"><a href="#_customization_of_executors">定制执行者</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_messaging">64.10。讯息传递</a></span></dt><dd><dl><dt><span class="section"><a href="#_spring_integration_and_spring_cloud_stream">64.10.1。Spring集成和Spring Cloud Stream</a></span></dt><dt><span class="section"><a href="#_spring_rabbitmq">64.10.2。春天兔子</a></span></dt><dt><span class="section"><a href="#_spring_kafka">64.10.3。 Spring Kafka </a></span></dt><dt><span class="section"><a href="#_spring_jms">64.10.4。春季JMS</a></span></dt></dl></dd><dt><span class="section"><a href="#_zuul_2">64.11。祖尔</a></span></dt><dt><span class="section"><a href="#_project_reactor">64.12。项目反应堆</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_running_examples">65。运行示例</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_consul">九。spring-cloud-consul</a></span></dt><dd><dl><dt><span class="chapter"><a href="#spring-cloud-consul-install">66。安装领事</a></span></dt><dt><span class="chapter"><a href="#spring-cloud-consul-agent">67。领事代理</a></span></dt><dt><span class="chapter"><a href="#spring-cloud-consul-discovery">68。领事服务发现</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_to_activate">68.1。如何激活</a></span></dt><dt><span class="section"><a href="#_registering_with_consul">68.2。向领事注册</a></span></dt><dd><dl><dt><span class="section"><a href="#_registering_management_as_a_separate_service">68.2.1。将管理注册为单独的服务</a></span></dt></dl></dd><dt><span class="section"><a href="#_http_health_check">68.3。HTTP运行状况检查</a></span></dt><dd><dl><dt><span class="section"><a href="#_metadata_and_consul_tags">68.3.1。元数据和领事标签</a></span></dt><dt><span class="section"><a href="#_making_the_consul_instance_id_unique">68.3.2。使领事实例ID唯一</a></span></dt><dt><span class="section"><a href="#_applying_headers_to_health_check_requests">68.3.3。将标头应用于健康检查请求</a></span></dt></dl></dd><dt><span class="section"><a href="#_looking_up_services">68.4。查找服务</a></span></dt><dd><dl><dt><span class="section"><a href="#_using_ribbon">68.4.1。使用功能区</a></span></dt><dt><span class="section"><a href="#_using_the_discoveryclient">68.4.2。使用DiscoveryClient</a></span></dt></dl></dd><dt><span class="section"><a href="#_consul_catalog_watch">68.5。Consul Catalog Watch</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-consul-config">69。使用Consul进行分布式配置</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_to_activate_2">69.1。如何激活</a></span></dt><dt><span class="section"><a href="#_customizing">69.2。客制化</a></span></dt><dt><span class="section"><a href="#spring-cloud-consul-config-watch">69.3。配置监视</a></span></dt><dt><span class="section"><a href="#spring-cloud-consul-config-format">69.4。YAML或具有配置的属性</a></span></dt><dt><span class="section"><a href="#spring-cloud-consul-config-git2consul">69.5。 git2consul与配置</a></span></dt><dt><span class="section"><a href="#spring-cloud-consul-failfast">69.6。快速失败</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-consul-retry">70Consul 重试</a></span></dt><dt><span class="chapter"><a href="#spring-cloud-consul-bus">71。带 Consul 的Spring Cloud Bus</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_to_activate_3">71.1。如何激活</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-consul-hystrix">72。Hystrix断路器</a></span></dt><dt><span class="chapter"><a href="#spring-cloud-consul-turbine">73。Hystrix指标通过Turbine和Consul进行聚合</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_zookeeper">X.Spring Cloud Zookeeper</a></span></dt><dd><dl><dt><span class="chapter"><a href="#spring-cloud-zookeeper-install">74。安装Zookeeper</a></span></dt><dt><span class="chapter"><a href="#spring-cloud-zookeeper-discovery">75。Zookeeper的服务发现</a></span></dt><dd><dl><dt><span class="section"><a href="#_activating">75.1。激活</a></span></dt><dt><span class="section"><a href="#_registering_with_zookeeper">75.2。向Zookeeper注册</a></span></dt><dt><span class="section"><a href="#_using_the_discoveryclient_2">75.3。使用DiscoveryClient</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-zookeeper-netflix">76。将Spring Cloud Zookeeper与Spring Cloud Netflix组件一起使用</a></span></dt><dd><dl><dt><span class="section"><a href="#_ribbon_with_zookeeper">76.1。与Zookeeper的功能区</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-zookeeper-service-registry">77。Spring Cloud Zookeeper和服务注册表</a></span></dt><dd><dl><dt><span class="section"><a href="#_instance_status">77.1。实例状态</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-zookeeper-dependencies">78。Zookeeper依赖关系</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-zookeeper-dependencies-using">78.1。使用Zookeeper依赖关系</a></span></dt><dt><span class="section"><a href="#spring-cloud-zookeeper-dependencies-activating">78.2。激活Zookeeper依赖关系</a></span></dt><dt><span class="section"><a href="#spring-cloud-zookeeper-dependencies-setting-up">78.3。设置Zookeeper依赖关系</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-zookeeper-dependencies-setting-up-aliases">78.3.1。别名</a></span></dt><dt><span class="section"><a href="#_path">78.3.2。路径</a></span></dt><dt><span class="section"><a href="#_load_balancer_type">78.3.3。负载均衡器类型</a></span></dt><dt><span class="section"><a href="#_content_type_template_and_version">78.3.4。 <code class="literal">Content-Type</code> 模板和版本</a></span></dt><dt><span class="section"><a href="#_default_headers">78.3.5。默认标题</a></span></dt><dt><span class="section"><a href="#_required_dependencies">78.3.6。所需的依存关系</a></span></dt><dt><span class="section"><a href="#_stubs">78.3.7。存根</a></span></dt></dl></dd><dt><span class="section"><a href="#spring-cloud-zookeeper-dependencies-configuring">78.4。配置Spring Cloud Zookeeper依赖关系</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-zookeeper-dependency-watcher">79。Spring Cloud Zookeeper依赖性观察程序</a></span></dt><dd><dl><dt><span class="section"><a href="#_activating_2">79.1。激活</a></span></dt><dt><span class="section"><a href="#_registering_a_listener">79.2。注册听众</a></span></dt><dt><span class="section"><a href="#spring-cloud-zookeeper-dependency-watcher-presence-checker">79.3。使用状态检查器</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-zookeeper-config">80。Zookeeper的分布式配置</a></span></dt><dd><dl><dt><span class="section"><a href="#_activating_3">80.1。激活</a></span></dt><dt><span class="section"><a href="#_customizing_2">80.2。客制化</a></span></dt><dt><span class="section"><a href="#_access_control_lists_acls">80.3。访问控制列表（ACL）</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_security">十一。 Spring Cloud安全性</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_quickstart">81。快速开始</a></span></dt><dd><dl><dt><span class="section"><a href="#_oauth2_single_sign_on">81.1。OAuth2单点登录</a></span></dt><dt><span class="section"><a href="#_oauth2_protected_resource">81.2。OAuth2受保护的资源</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_more_detail">82。更多详情</a></span></dt><dd><dl><dt><span class="section"><a href="#_single_sign_on">82.1。单点登录</a></span></dt><dt><span class="section"><a href="#_token_relay">82.2。令牌中继</a></span></dt><dd><dl><dt><span class="section"><a href="#_client_token_relay_in_spring_cloud_gateway">82.2.1。Spring Cloud Gateway中的客户端令牌中继</a></span></dt><dt><span class="section"><a href="#_client_token_relay">82.2.2。客户令牌中继</a></span></dt><dt><span class="section"><a href="#_client_token_relay_in_zuul_proxy">82.2.3。Zuul代理中的客户端令牌中继</a></span></dt><dt><span class="section"><a href="#_resource_server_token_relay">82.2.4。资源服务器令牌中继</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_configuring_authentication_downstream_of_a_zuul_proxy">83。配置Zuul代理的下游身份验证</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_for_cloud_foundry">十二。 Spring Cloud for Cloud Foundry</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_discovery">84。发现</a></span></dt><dt><span class="chapter"><a href="#_single_sign_on_2">85。单点登录</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_contract">十三。Spring Cloud Contract</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_spring_cloud_contract_2">86。Spring Cloud Contract</a></span></dt><dt><span class="chapter"><a href="#_spring_cloud_contract_verifier_introduction">87。Spring Cloud Contract Verifier简介</a></span></dt><dd><dl><dt><span class="section"><a href="#_history">87.1。历史</a></span></dt><dt><span class="section"><a href="#_why_a_contract_verifier">87.2。为什么要签约验证人？</a></span></dt><dd><dl><dt><span class="section"><a href="#_testing_issues">87.2.1。测试问题</a></span></dt></dl></dd><dt><span class="section"><a href="#_purposes">87.3。目的</a></span></dt><dt><span class="section"><a href="#_how_it_works">87.4。怎么运行的</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-contract-verifier-intro-three-second-tour">87.4.1。三秒游</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-contract-verifier-intro-three-second-tour-producer">在生产者方面</a></span></dt><dt><span class="section"><a href="#spring-cloud-contract-verifier-intro-three-second-tour-consumer">在消费者方面</a></span></dt></dl></dd><dt><span class="section"><a href="#spring-cloud-contract-verifier-intro-three-minute-tour">87.4.2。三分钟游</a></span></dt><dd><dl><dt><span class="section"><a href="#spring-cloud-contract-verifier-intro-three-minute-tour-producer">在生产者方面</a></span></dt><dt><span class="section"><a href="#spring-cloud-contract-verifier-intro-three-minute-tour-consumer">在消费者方面</a></span></dt></dl></dd><dt><span class="section"><a href="#_defining_the_contract">87.4.3。定义合同</a></span></dt><dt><span class="section"><a href="#_client_side">87.4.4。客户端</a></span></dt><dt><span class="section"><a href="#_server_side">87.4.5。服务器端</a></span></dt></dl></dd><dt><span class="section"><a href="#_step_by_step_guide_to_consumer_driven_contracts_cdc">87.5。消费者驱动合同（CDC）分步指南</a></span></dt><dd><dl><dt><span class="section"><a href="#_technical_note">87.5.1。技术说明</a></span></dt><dt><span class="section"><a href="#_consumer_side_loan_issuance">87.5.2。消费者方（贷款发行）</a></span></dt><dt><span class="section"><a href="#_producer_side_fraud_detection_server">87.5.3。生产者端（欺诈检测服务器）</a></span></dt><dt><span class="section"><a href="#_consumer_side_loan_issuance_final_step">87.5.4。消费者方（贷款发行）最后一步</a></span></dt></dl></dd><dt><span class="section"><a href="#_dependencies_2">87.6。依存关系</a></span></dt><dt><span class="section"><a href="#_additional_links">87.7。附加链接</a></span></dt><dd><dl><dt><span class="section"><a href="#_spring_cloud_contract_video">87.7.1。Spring Cloud Contract视频</a></span></dt><dt><span class="section"><a href="#_readings">87.7.2。读物</a></span></dt></dl></dd><dt><span class="section"><a href="#_samples_2">87.8。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_contract_faq">88。Spring Cloud Contract常见问题解答</a></span></dt><dd><dl><dt><span class="section"><a href="#_why_use_spring_cloud_contract_verifier_and_not_x">88.1。为什么使用Spring Cloud Contract Verifier而不使用X？</a></span></dt><dt><span class="section"><a href="#_i_dont_want_to_write_a_contract_in_groovy">88.2。我不想在Groovy中写合同！</a></span></dt><dt><span class="section"><a href="#_what_is_this_valueconsumer_producer">88.3。这个值是什么（consumer（），producer（））？</a></span></dt><dt><span class="section"><a href="#_how_to_do_stubs_versioning">88.4。如何进行存根版本控制？</a></span></dt><dd><dl><dt><span class="section"><a href="#_api_versioning">88.4.1。API版本控制</a></span></dt><dt><span class="section"><a href="#_jar_versioning">88.4.2。JAR版本控制</a></span></dt><dt><span class="section"><a href="#_dev_or_prod_stubs">88.4.3。开发或产品存根</a></span></dt></dl></dd><dt><span class="section"><a href="#_common_repo_with_contracts">88.5。合同共同回购</a></span></dt><dd><dl><dt><span class="section"><a href="#_repo_structure">88.5.1。回购结构</a></span></dt><dt><span class="section"><a href="#_workflow">88.5.2。工作流程</a></span></dt><dt><span class="section"><a href="#_consumer">88.5.3。消费者</a></span></dt><dt><span class="section"><a href="#_producer">88.5.4。制片人</a></span></dt><dt><span class="section"><a href="#_how_can_i_define_messaging_contracts_per_topic_not_per_producer">88.5.5。如何按主题而不是按生产者定义消息传递合同？</a></span></dt><dd><dl><dt><span class="section"><a href="#_for_maven_project">对于Maven项目</a></span></dt><dt><span class="section"><a href="#_for_gradle_project">对于Gradle项目</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_do_i_need_a_binary_storage_cant_i_use_git">88.6。我需要二进制存储吗？我不能使用Git吗？</a></span></dt><dd><dl><dt><span class="section"><a href="#_protocol_convention">88.6.1。协议约定</a></span></dt><dt><span class="section"><a href="#_producer_2">88.6.2。制片人</a></span></dt><dt><span class="section"><a href="#_producer_with_contracts_stored_locally">88.6.3。生产者，合同存储在本地</a></span></dt><dd><dl><dt><span class="section"><a href="#_keeping_contracts_with_the_producer_and_stubs_in_an_external_repository">保持与生产者的合同和存根在外部存储库中</a></span></dt></dl></dd><dt><span class="section"><a href="#_consumer_2">88.6.4。消费者</a></span></dt></dl></dd><dt><span class="section"><a href="#_can_i_use_the_pact_broker">88.7。我可以使用契约代理吗？</a></span></dt><dd><dl><dt><span class="section"><a href="#_pact_consumer">88.7.1。契约消费者</a></span></dt><dt><span class="section"><a href="#_producer_3">88.7.2。制片人</a></span></dt><dt><span class="section"><a href="#_pact_consumer_producer_contract_approach">88.7.3。契约消费者（生产者合同法）</a></span></dt></dl></dd><dt><span class="section"><a href="#_how_can_i_debug_the_requestresponse_being_sent_by_the_generated_tests_client">88.8。如何调试由生成的测试客户端发送的请求/响应？</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_can_i_debug_the_mappingrequestresponse_being_sent_by_wiremock">88.8.1。如何调试WireMock发送的映射/请求/响应？</a></span></dt><dt><span class="section"><a href="#_how_can_i_see_what_got_registered_in_the_http_server_stub">88.8.2。如何查看在HTTP服务器存根中注册了什么？</a></span></dt><dt><span class="section"><a href="#_can_i_reference_text_from_file">88.8.3。我可以引用文件中的文本吗？</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_contract_verifier_setup">89。Spring Cloud Contract Verifier设置</a></span></dt><dd><dl><dt><span class="section"><a href="#gradle-project">89.1。摇篮项目</a></span></dt><dd><dl><dt><span class="section"><a href="#gradle-prerequisites">89.1.1。先决条件</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#gradle-add-gradle-plugin">90添加具有依赖项的Gradle插件</a></span></dt><dd><dl><dt><span class="section"><a href="#gradle-and-rest-assured">90.1Gradle and Rest Assured 2.0</a></span></dt><dt><span class="section"><a href="#gradle-snapshot-versions">90.2。Gradle的快照版本</a></span></dt><dt><span class="section"><a href="#gradle-add-stubs">90.3。添加存根</a></span></dt><dt><span class="section"><a href="#gradle-run-plugin">90.4。运行插件</a></span></dt><dt><span class="section"><a href="#gradle-default-setup">90.5。默认设置</a></span></dt><dt><span class="section"><a href="#gradle-configure-plugin">90.6。配置插件</a></span></dt><dt><span class="section"><a href="#gradle-configuration-options">90.7。配置选项</a></span></dt><dt><span class="section"><a href="#gradle-single-base-class">90.8。所有测试的单一基类</a></span></dt><dt><span class="section"><a href="#gradle-different-base-classes">90.9。合同的不同基本类别</a></span></dt><dt><span class="section"><a href="#gradle-invoking-generated-tests">90.10。调用生成的测试</a></span></dt><dt><span class="section"><a href="#gradle-pushing-stubs-to-scm">90.11。将存根推送到SCM</a></span></dt><dt><span class="section"><a href="#gradle-consumer">90.12。消费者方的Spring Cloud Contract Verifier</a></span></dt><dt><span class="section"><a href="#maven-project">90.13。Maven项目</a></span></dt><dd><dl><dt><span class="section"><a href="#maven-add-plugin">90.13.1。添加Maven插件</a></span></dt><dt><span class="section"><a href="#maven-rest-assured">90.13.2。Maven和安心保障2.0</a></span></dt><dt><span class="section"><a href="#maven-snapshot-versions">90.13.3。Maven的快照版本</a></span></dt><dt><span class="section"><a href="#maven-add-stubs">90.13.4。添加存根</a></span></dt><dt><span class="section"><a href="#maven-run-plugin">90.13.5。运行插件</a></span></dt><dt><span class="section"><a href="#maven-configure-plugin">90.13.6。配置插件</a></span></dt><dt><span class="section"><a href="#maven-configuration-options">90.13.7。配置选项</a></span></dt><dt><span class="section"><a href="#maven-single-base">90.13.8。所有测试的单一基类</a></span></dt><dt><span class="section"><a href="#maven-different-base">90.13.9。合同的不同基本类别</a></span></dt><dt><span class="section"><a href="#maven-invoking-generated-tests">90.13.10。调用生成的测试</a></span></dt><dt><span class="section"><a href="#maven-pushing-stubs-to-scm">90.13.11。将存根推送到SCM</a></span></dt><dt><span class="section"><a href="#maven-sts">90.13.12。Maven插件和STS</a></span></dt><dt><span class="section"><a href="#_maven_plugin_with_spock_tests">90.13.13。具有Spock测试的Maven插件</a></span></dt></dl></dd><dt><span class="section"><a href="#_stubs_and_transitive_dependencies">90.14。存根和传递依存关系</a></span></dt><dt><span class="section"><a href="#_scenarios">90.15。情境</a></span></dt><dt><span class="section"><a href="#docker-project">90.16。Docker项目</a></span></dt><dd><dl><dt><span class="section"><a href="#_short_intro_to_maven_jars_and_binary_storage">90.16.1。Maven，JAR和二进制存储的简短介绍</a></span></dt><dt><span class="section"><a href="#_how_it_works_2">90.16.2。怎么运行的</a></span></dt><dd><dl><dt><span class="section"><a href="#_environment_variables">环境变量</a></span></dt></dl></dd><dt><span class="section"><a href="#_example_of_usage">90.16.3。使用例</a></span></dt><dt><span class="section"><a href="#docker-server-side">90.16.4。服务器端（nodejs）</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_contract_verifier_messaging">91。Spring Cloud Contract Verifier消息传递</a></span></dt><dd><dl><dt><span class="section"><a href="#_integrations_2">91.1。整合方式</a></span></dt><dt><span class="section"><a href="#_manual_integration_testing">91.2。手动集成测试</a></span></dt><dt><span class="section"><a href="#_publisher_side_test_generation">91.3。发布方测试生成</a></span></dt><dd><dl><dt><span class="section"><a href="#_scenario_1_no_input_message">91.3.1。方案1：无输入消息</a></span></dt><dt><span class="section"><a href="#_scenario_2_output_triggered_by_input">91.3.2。方案2：由输入触发的输出</a></span></dt><dt><span class="section"><a href="#_scenario_3_no_output_message">91.3.3。方案3：无输出消息</a></span></dt></dl></dd><dt><span class="section"><a href="#_consumer_stub_generation">91.4。消费者存根生成</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_contract_stub_runner">92。Spring Cloud Contract存根转轮</a></span></dt><dd><dl><dt><span class="section"><a href="#_snapshot_versions">92.1。快照版本</a></span></dt><dt><span class="section"><a href="#publishing-stubs-as-jars">92.2。将存根发布为JAR</a></span></dt><dt><span class="section"><a href="#_stub_runner_core">92.3存根转轮核心</a></span></dt><dd><dl><dt><span class="section"><a href="#_retrieving_stubs">92.3.1。检索存根</a></span></dt><dd><dl><dt><span class="section"><a href="#_stub_downloading">存根下载</a></span></dt><dt><span class="section"><a href="#_classpath_scanning">类路径扫描</a></span></dt><dt><span class="section"><a href="#_configuring_http_server_stubs">配置HTTP服务器存根</a></span></dt></dl></dd><dt><span class="section"><a href="#_running_stubs">92.3.2。正在运行的存根</a></span></dt><dd><dl><dt><span class="section"><a href="#_running_using_main_app">使用主应用程序运行</a></span></dt><dt><span class="section"><a href="#_http_stubs">HTTP存根</a></span></dt><dt><span class="section"><a href="#_viewing_registered_mappings">查看注册的映射</a></span></dt><dt><span class="section"><a href="#_messaging_stubs">消息存根</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_stub_runner_junit_rule_and_stub_runner_junit5_extension">92.4。Stub Runner JUnit规则和Stub Runner JUnit5扩展</a></span></dt><dd><dl><dt><span class="section"><a href="#_maven_settings">92.4.1。Maven设置</a></span></dt><dt><span class="section"><a href="#_providing_fixed_ports">92.4.2。提供固定端口</a></span></dt><dt><span class="section"><a href="#_fluent_api">92.4.3。流利的API</a></span></dt><dt><span class="section"><a href="#_stub_runner_with_spring">92.4.4。春天的存根转轮</a></span></dt></dl></dd><dt><span class="section"><a href="#_stub_runner_spring_cloud">92.5。存根赛跑者春天云</a></span></dt><dd><dl><dt><span class="section"><a href="#_stubbing_service_discovery">92.5.1。存根服务发现</a></span></dt><dd><dl><dt><span class="section"><a href="#_test_profiles_and_service_discovery">测试配置文件和服务发现</a></span></dt></dl></dd><dt><span class="section"><a href="#_additional_configuration">92.5.2。附加配置</a></span></dt></dl></dd><dt><span class="section"><a href="#_stub_runner_boot_application">92.6。存根转轮启动应用程序</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_to_use_it">92.6.1。如何使用它？</a></span></dt><dd><dl><dt><span class="section"><a href="#_stub_runner_server">存根转轮服务器</a></span></dt><dt><span class="section"><a href="#_stub_runner_server_fat_jar">存根转轮服务器胖子</a></span></dt><dt><span class="section"><a href="#_spring_cloud_cli">Spring Cloud CLI</a></span></dt></dl></dd><dt><span class="section"><a href="#_endpoints_2">92.6.2。终点</a></span></dt><dd><dl><dt><span class="section"><a href="#_http_2">HTTP</a></span></dt><dt><span class="section"><a href="#_messaging_2">讯息传递</a></span></dt></dl></dd><dt><span class="section"><a href="#_example">92.6.3。例</a></span></dt><dt><span class="section"><a href="#_stub_runner_boot_with_service_discovery">92.6.4。具有服务发现功能的存根运行器引导</a></span></dt></dl></dd><dt><span class="section"><a href="#_stubs_per_consumer">92.7。每个消费者存根</a></span></dt><dt><span class="section"><a href="#_common">92.8。共同</a></span></dt><dd><dl><dt><span class="section"><a href="#common-properties-junit-spring">92.8.1。JUnit和Spring的通用属性</a></span></dt><dt><span class="section"><a href="#stub-runner-stub-ids">92.8.2。存根转轮存根ID</a></span></dt></dl></dd><dt><span class="section"><a href="#stubrunner-docker">92.9。Stub Runner Docker</a></span></dt><dd><dl><dt><span class="section"><a href="#_how_to_use_it_2">92.9.1。如何使用它</a></span></dt><dt><span class="section"><a href="#_example_of_client_side_usage_in_a_non_jvm_project">92.9.2。非JVM项目中的客户端用法示例</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#stub-runner-for-messaging">93。消息传送存根</a></span></dt><dd><dl><dt><span class="section"><a href="#_stub_triggering">93.1。存根触发</a></span></dt><dd><dl><dt><span class="section"><a href="#trigger-label">93.1.1。按标签触发</a></span></dt><dt><span class="section"><a href="#trigger-group-artifact-ids">93.1.2。按组和工件ID触发</a></span></dt><dt><span class="section"><a href="#trigger-artifact-ids">93.1.3。由工件ID触发</a></span></dt><dt><span class="section"><a href="#trigger-all-messages">93.1.4。触发所有讯息</a></span></dt></dl></dd><dt><span class="section"><a href="#_stub_runner_camel">93.2。存根转轮骆驼</a></span></dt><dd><dl><dt><span class="section"><a href="#_adding_it_to_the_project">93.2.1。将其添加到项目中</a></span></dt><dt><span class="section"><a href="#_disabling_the_functionality">93.2.2。禁用功能</a></span></dt><dt><span class="section"><a href="#_examples">93.2.3。例子</a></span></dt><dd><dl><dt><span class="section"><a href="#_stubs_structure">存根结构</a></span></dt><dt><span class="section"><a href="#_scenario_1_no_input_message_2">方案1（无输入消息）</a></span></dt><dt><span class="section"><a href="#_scenario_2_output_triggered_by_input_2">场景2（输入触发输出）</a></span></dt><dt><span class="section"><a href="#_scenario_3_input_with_no_output">方案3（输入无输出）</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_stub_runner_integration">93.3。Stub Runner集成</a></span></dt><dd><dl><dt><span class="section"><a href="#_adding_the_runner_to_the_project">93.3.1。将跑步者添加到项目</a></span></dt><dt><span class="section"><a href="#_disabling_the_functionality_2">93.3.2。禁用功能</a></span></dt><dd><dl><dt><span class="section"><a href="#integration-scenario-1">方案1（无输入消息）</a></span></dt><dt><span class="section"><a href="#integration-scenario-2">场景2（输入触发输出）</a></span></dt><dt><span class="section"><a href="#integration-scenario-3">方案3（输入无输出）</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_stub_runner_stream">93.4。存根转轮流</a></span></dt><dd><dl><dt><span class="section"><a href="#_adding_the_runner_to_the_project_2">93.4.1。将跑步者添加到项目</a></span></dt><dt><span class="section"><a href="#_disabling_the_functionality_3">93.4.2。禁用功能</a></span></dt><dd><dl><dt><span class="section"><a href="#stream-scenario-1">方案1（无输入消息）</a></span></dt><dt><span class="section"><a href="#stream-scenario-2">场景2（输入触发输出）</a></span></dt><dt><span class="section"><a href="#stream-scenario-3">方案3（输入无输出）</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_stub_runner_spring_amqp">93.5。Stub Runner Spring AMQP</a></span></dt><dd><dl><dt><span class="section"><a href="#_adding_the_runner_to_the_project_3">93.5.1。将跑步者添加到项目</a></span></dt><dd><dl><dt><span class="section"><a href="#_triggering_the_message">触发讯息</a></span></dt><dt><span class="section"><a href="#_spring_amqp_test_configuration">Spring AMQP测试配置</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#contract-dsl">94。合约DSL</a></span></dt><dd><dl><dt><span class="section"><a href="#_limitations">94.1。局限性</a></span></dt><dt><span class="section"><a href="#_common_top_level_elements">94.2。常见的顶级元素</a></span></dt><dd><dl><dt><span class="section"><a href="#contract-dsl-description">94.2.1。描述</a></span></dt><dt><span class="section"><a href="#contract-dsl-name">94.2.2。名称</a></span></dt><dt><span class="section"><a href="#contract-dsl-ignoring-contracts">94.2.3。忽略合同</a></span></dt><dt><span class="section"><a href="#contract-dsl-passing-values-from-files">94.2.4。从文件传递值</a></span></dt><dt><span class="section"><a href="#contract-dsl-http-top-level-elements">94.2.5。HTTP顶级元素</a></span></dt></dl></dd><dt><span class="section"><a href="#_request">94.3。请求</a></span></dt><dt><span class="section"><a href="#_response">94.4。响应</a></span></dt><dt><span class="section"><a href="#_dynamic_properties">94.5。动态特性</a></span></dt><dd><dl><dt><span class="section"><a href="#_dynamic_properties_inside_the_body">94.5.1。体内的动态特性</a></span></dt><dt><span class="section"><a href="#_regular_expressions">94.5.2。常用表达</a></span></dt><dt><span class="section"><a href="#_passing_optional_parameters">94.5.3。传递可选参数</a></span></dt><dt><span class="section"><a href="#_executing_custom_methods_on_the_server_side">94.5.4。在服务器端执行自定义方法</a></span></dt><dt><span class="section"><a href="#_referencing_the_request_from_the_response">94.5.5。引用响应中的请求</a></span></dt><dt><span class="section"><a href="#_registering_your_own_wiremock_extension">94.5.6。注册自己的WireMock扩展</a></span></dt><dt><span class="section"><a href="#contract-matchers">94.5.7。匹配器部分中的动态属性</a></span></dt></dl></dd><dt><span class="section"><a href="#_jax_rs_support">94.6。JAX-RS支持</a></span></dt><dt><span class="section"><a href="#_async_support">94.7。异步支持</a></span></dt><dt><span class="section"><a href="#_working_with_context_paths">94.8。使用上下文路径</a></span></dt><dt><span class="section"><a href="#_working_with_webflux">94.9。使用WebFlux</a></span></dt><dd><dl><dt><span class="section"><a href="#_webflux_with_webtestclient">94.9.1。WebFlux与WebTestClient</a></span></dt><dt><span class="section"><a href="#_webflux_with_explicit_mode">94.9.2。WebFlux具有显式模式</a></span></dt></dl></dd><dt><span class="section"><a href="#_xml_support_for_rest">94.10。REST的XML支持</a></span></dt><dt><span class="section"><a href="#_messaging_top_level_elements">94.11。消息传递顶级元素</a></span></dt><dd><dl><dt><span class="section"><a href="#contract-dsl-output-triggered-method">94.11.1。方法触发的输出</a></span></dt><dt><span class="section"><a href="#contract-dsl-output-triggered-message">94.11.2。消息触发的输出</a></span></dt><dt><span class="section"><a href="#contract-dsl-consumer-producer">94.11.3。消费者/生产者</a></span></dt><dt><span class="section"><a href="#contract-dsl-common">94.11.4。共同</a></span></dt></dl></dd><dt><span class="section"><a href="#_multiple_contracts_in_one_file">94.12。一个文件中的多个合同</a></span></dt><dt><span class="section"><a href="#_generating_spring_rest_docs_snippets_from_the_contracts">94.13。从合同中生成Spring REST Docs片段</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_customization">95。客制化</a></span></dt><dd><dl><dt><span class="section"><a href="#_extending_the_dsl">95.1。扩展DSL</a></span></dt><dd><dl><dt><span class="section"><a href="#_common_jar">95.1.1。普通JAR</a></span></dt><dt><span class="section"><a href="#_adding_the_dependency_to_the_project">95.1.2。将依赖项添加到项目中</a></span></dt><dt><span class="section"><a href="#_test_the_dependency_in_the_projects_dependencies">95.1.3。在项目的依赖关系中测试依赖关系</a></span></dt><dt><span class="section"><a href="#_test_a_dependency_in_the_plugins_dependencies">95.1.4。在插件的依赖项中测试依赖项</a></span></dt><dt><span class="section"><a href="#_referencing_classes_in_dsls">95.1.5。引用DSL中的类</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_using_the_pluggable_architecture">96。使用可插拔架构</a></span></dt><dd><dl><dt><span class="section"><a href="#_custom_contract_converter">96.1。定制合同转换器</a></span></dt><dd><dl><dt><span class="section"><a href="#pact-converter">96.1.1。契约转换器</a></span></dt><dt><span class="section"><a href="#_pact_contract">96.1.2。契约合同</a></span></dt><dt><span class="section"><a href="#_pact_for_producers">96.1.3。生产者契约</a></span></dt><dt><span class="section"><a href="#_pact_for_consumers">96.1.4。消费者契约</a></span></dt></dl></dd><dt><span class="section"><a href="#_using_the_custom_test_generator">96.2。使用自定义测试生成器</a></span></dt><dt><span class="section"><a href="#_using_the_custom_stub_generator">96.3。使用自定义存根生成器</a></span></dt><dt><span class="section"><a href="#_using_the_custom_stub_runner">96.4。使用自定义存根运行器</a></span></dt><dt><span class="section"><a href="#_using_the_custom_stub_downloader">96.5。使用自定义存根下载器</a></span></dt><dt><span class="section"><a href="#scm-stub-downloader">96.6。使用SCM存根下载器</a></span></dt><dt><span class="section"><a href="#pact-stub-downloader">96.7。使用契约存根下载器</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_contract_wiremock">97。Spring Cloud Contract WireMock</a></span></dt><dd><dl><dt><span class="section"><a href="#_registering_stubs_automatically">97.1。自动注册存根</a></span></dt><dt><span class="section"><a href="#_using_files_to_specify_the_stub_bodies">97.2。使用文件指定存根实体</a></span></dt><dt><span class="section"><a href="#_alternative_using_junit_rules">97.3。替代方案：使用JUnit规则</a></span></dt><dt><span class="section"><a href="#_relaxed_ssl_validation_for_rest_template">97.4。放松模板的SSL验证</a></span></dt><dt><span class="section"><a href="#_wiremock_and_spring_mvc_mocks">97.5。WireMock和Spring MVC模拟</a></span></dt><dt><span class="section"><a href="#_customization_of_wiremock_configuration">97.6。定制WireMock配置</a></span></dt><dt><span class="section"><a href="#_generating_stubs_using_rest_docs">97.7。使用REST文档生成存根</a></span></dt><dt><span class="section"><a href="#_generating_contracts_by_using_rest_docs">97.8。使用REST文档生成合同</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_migrations">98。移居</a></span></dt><dd><dl><dt><span class="section"><a href="#cloud-verifier-1.0-1.1">98.1。1.0.x→1.1.x</a></span></dt><dd><dl><dt><span class="section"><a href="#_new_structure_of_generated_stubs">98.1.1。生成的存根的新结构</a></span></dt></dl></dd><dt><span class="section"><a href="#cloud-verifier-1.1-1.2">98.2。1.1.x→1.2.x</a></span></dt><dd><dl><dt><span class="section"><a href="#_custom_httpserverstub">98.2.1。自订<code class="literal">HttpServerStub</code></a></span></dt><dt><span class="section"><a href="#_new_packages_for_generated_tests">98.2.2。用于生成测试的新软件包</a></span></dt><dt><span class="section"><a href="#_new_methods_in_templateprocessor">98.2.3。TemplateProcessor中的新方法</a></span></dt><dt><span class="section"><a href="#_restassured_3_0">98.2.4。RestAssured 3.0</a></span></dt></dl></dd><dt><span class="section"><a href="#cloud-verifier-1.2-2.0">98.3。1.2.x→2.0.x</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_links">99。链接</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_vault">十四。 Spring Cloud Vault</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_quick_start_4">100快速开始</a></span></dt><dt><span class="chapter"><a href="#_client_side_usage_2">101。客户端使用</a></span></dt><dd><dl><dt><span class="section"><a href="#_authentication_2">101.1。认证方式</a></span></dt></dl></dd><dt><span class="chapter"><a href="#vault.config.authentication">102。认证方式</a></span></dt><dd><dl><dt><span class="section"><a href="#vault.config.authentication.token">102.1。令牌认证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.appid">102.2。AppId验证</a></span></dt><dd><dl><dt><span class="section"><a href="#_custom_userid">102.2.1。自定义用户ID</a></span></dt></dl></dd><dt><span class="section"><a href="#_approle_authentication">102.3。AppRole身份验证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.awsec2">102.4。AWS-EC2身份验证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.awsiam">102.5。AWS-IAM身份验证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.azuremsi">102.6。Azure MSI身份验证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.clientcert">102.7。TLS证书认证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.cubbyhole">102.8。隔间认证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.gcpgce">102.9。GCP-GCE认证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.gcpiam">102.10。GCP-IAM认证</a></span></dt><dt><span class="section"><a href="#vault.config.authentication.kubernetes">102.11。Kubernetes认证</a></span></dt></dl></dd><dt><span class="chapter"><a href="#vault.config.backends">103。秘密后端</a></span></dt><dd><dl><dt><span class="section"><a href="#vault.config.backends.generic">103.1。通用后端</a></span></dt><dt><span class="section"><a href="#vault.config.backends.kv.versioned">103.2。版本化键值后端</a></span></dt><dt><span class="section"><a href="#vault.config.backends.consul">103.3。领事</a></span></dt><dt><span class="section"><a href="#vault.config.backends.rabbitmq">103.4。兔子MQ</a></span></dt><dt><span class="section"><a href="#vault.config.backends.aws">103.5。AWS</a></span></dt></dl></dd><dt><span class="chapter"><a href="#vault.config.backends.database-backends">104。数据库后端</a></span></dt><dd><dl><dt><span class="section"><a href="#vault.config.backends.database">104.1。数据库</a></span></dt><dt><span class="section"><a href="#vault.config.backends.cassandra">104.2。阿帕奇·卡桑德拉（Apache Cassandra）</a></span></dt><dt><span class="section"><a href="#vault.config.backends.mongodb">104.3。MongoDB</a></span></dt><dt><span class="section"><a href="#vault.config.backends.mysql">104.4。的MySQL</a></span></dt><dt><span class="section"><a href="#vault.config.backends.postgresql">104.5。PostgreSQL的</a></span></dt></dl></dd><dt><span class="chapter"><a href="#vault.config.backends.configurer">105。配置<code class="literal">PropertySourceLocator</code>行为</a></span></dt><dt><span class="chapter"><a href="#_service_registry_configuration">106。服务注册表配置</a></span></dt><dt><span class="chapter"><a href="#vault.config.fail-fast">107。Vault Client快速失败</a></span></dt><dt><span class="chapter"><a href="#vault.config.ssl">108。Vault Client SSL配置</a></span></dt><dt><span class="chapter"><a href="#vault-lease-renewal">109。租赁生命周期管理（续订和吊销）</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_gateway">XV。 Spring Cloud Gateway</a></span></dt><dd><dl><dt><span class="chapter"><a href="#gateway-starter">110。如何包括Spring Cloud Gateway</a></span></dt><dt><span class="chapter"><a href="#_glossary">111。词汇表</a></span></dt><dt><span class="chapter"><a href="#gateway-how-it-works">112。怎么运行的</a></span></dt><dt><span class="chapter"><a href="#gateway-request-predicates-factories">113。路线谓词工厂</a></span></dt><dd><dl><dt><span class="section"><a href="#_after_route_predicate_factory">113.1。后路线谓词工厂</a></span></dt><dt><span class="section"><a href="#_before_route_predicate_factory">113.2。路线谓词工厂之前</a></span></dt><dt><span class="section"><a href="#_between_route_predicate_factory">113.3。路线谓词工厂之间</a></span></dt><dt><span class="section"><a href="#_cookie_route_predicate_factory">113.4。Cookie路线谓词工厂</a></span></dt><dt><span class="section"><a href="#_header_route_predicate_factory">113.5。标头路由谓词工厂</a></span></dt><dt><span class="section"><a href="#_host_route_predicate_factory">113.6。主机路由谓词工厂</a></span></dt><dt><span class="section"><a href="#_method_route_predicate_factory">113.7。方法路线谓词工厂</a></span></dt><dt><span class="section"><a href="#_path_route_predicate_factory">113.8。路径路线谓词工厂</a></span></dt><dt><span class="section"><a href="#_query_route_predicate_factory">113.9。查询路由谓词工厂</a></span></dt><dt><span class="section"><a href="#_remoteaddr_route_predicate_factory">113.10。RemoteAddr路由谓词工厂</a></span></dt><dd><dl><dt><span class="section"><a href="#_modifying_the_way_remote_addresses_are_resolved">113.10.1。修改远程地址的解析方式</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_gatewayfilter_factories">114。GatewayFilter工厂</a></span></dt><dd><dl><dt><span class="section"><a href="#_addrequestheader_gatewayfilter_factory">114.1。AddRequestHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_addrequestparameter_gatewayfilter_factory">114.2。AddRequestParameter GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_addresponseheader_gatewayfilter_factory">114.3。AddResponseHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_deduperesponseheader_gatewayfilter_factory">114.4。DedupeResponseHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#hystrix">114.5。Hystrix GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#fallback-headers">114.6。FallbackHeaders GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_maprequestheader_gatewayfilter_factory">114.7。MapRequestHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_prefixpath_gatewayfilter_factory">114.8。PrefixPath GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_preservehostheader_gatewayfilter_factory">114.9。PreserveHostHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_requestratelimiter_gatewayfilter_factory">114.10。RequestRateLimiter GatewayFilter工厂</a></span></dt><dd><dl><dt><span class="section"><a href="#_redis_ratelimiter">114.10.1。Redis RateLimiter</a></span></dt></dl></dd><dt><span class="section"><a href="#_redirectto_gatewayfilter_factory">114.11。重定向到GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_removehopbyhopheadersfilter_gatewayfilter_factory">114.12。RemoveHopByHopHeadersFilter GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_removerequestheader_gatewayfilter_factory">114.13。RemoveRequestHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_removeresponseheader_gatewayfilter_factory">114.14。RemoveResponseHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_rewritepath_gatewayfilter_factory">114.15。RewritePath GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_rewritelocationresponseheader_gatewayfilter_factory">114.16。RewriteLocationResponseHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_rewriteresponseheader_gatewayfilter_factory">114.17。RewriteResponseHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_savesession_gatewayfilter_factory">114.18。SaveSession GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_secureheaders_gatewayfilter_factory">114.19。SecureHeaders GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_setpath_gatewayfilter_factory">114.20。SetPath GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_setrequestheader_gatewayfilter_factory">114.21。SetRequestHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_setresponseheader_gatewayfilter_factory">114.22。SetResponseHeader GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_setstatus_gatewayfilter_factory">114.23。SetStatus GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_stripprefix_gatewayfilter_factory">114.24。StripPrefix GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_retry_gatewayfilter_factory">114.25。重试GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_requestsize_gatewayfilter_factory">114.26。RequestSize GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_modify_request_body_gatewayfilter_factory">114.27。修改请求正文GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_modify_response_body_gatewayfilter_factory">114.28。修改响应主体GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_default_filters">114.29。默认过滤器</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_global_filters">115。全局过滤器</a></span></dt><dd><dl><dt><span class="section"><a href="#_combined_global_filter_and_gatewayfilter_ordering">15.1。全局过滤器和GatewayFilter的组合订购</a></span></dt><dt><span class="section"><a href="#_forward_routing_filter">15.2。正向路由过滤器</a></span></dt><dt><span class="section"><a href="#_loadbalancerclient_filter">15.3。LoadBalancerClient筛选器</a></span></dt><dt><span class="section"><a href="#reactive-loadbalancer-client-filter">115.4。ReactiveLoadBalancerClientFilter</a></span></dt><dt><span class="section"><a href="#_netty_routing_filter">115.5。网络路由过滤器</a></span></dt><dt><span class="section"><a href="#_netty_write_response_filter">115.6。净写响应过滤器</a></span></dt><dt><span class="section"><a href="#_routetorequesturl_filter">115.7。RouteToRequestUrl过滤器</a></span></dt><dt><span class="section"><a href="#_websocket_routing_filter">115.8。Websocket路由过滤器</a></span></dt><dt><span class="section"><a href="#_gateway_metrics_filter">115.9。网关指标过滤器</a></span></dt><dt><span class="section"><a href="#_marking_an_exchange_as_routed">115.10。将交换标记为已路由</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_tls_ssl">116。TLS / SSL</a></span></dt><dd><dl><dt><span class="section"><a href="#_tls_handshake">16.1。TLS握手</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_configuration_2">117。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#_fluent_java_routes_api">117.1。流利的Java Routes API</a></span></dt><dt><span class="section"><a href="#_discoveryclient_route_definition_locator">117.2。DiscoveryClient路由定义定位器</a></span></dt><dd><dl><dt><span class="section"><a href="#_configuring_predicates_and_filters_for_discoveryclient_routes">117.2.1。为DiscoveryClient路由配置谓词和过滤器</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_reactor_netty_access_logs">118。Reactor Netty访问日志</a></span></dt><dt><span class="chapter"><a href="#_cors_configuration">119。CORS配置</a></span></dt><dt><span class="chapter"><a href="#_actuator_api">120。执行器API</a></span></dt><dd><dl><dt><span class="section"><a href="#_verbose_actuator_format">120.1。详细执行器格式</a></span></dt><dt><span class="section"><a href="#_retrieving_route_filters">120.2。检索路由过滤器</a></span></dt><dd><dl><dt><span class="section"><a href="#_global_filters_2">120.2.1。全局过滤器</a></span></dt><dt><span class="section"><a href="#_route_filters">120.2.2。路线过滤器</a></span></dt></dl></dd><dt><span class="section"><a href="#_refreshing_the_route_cache">120.3。刷新路由缓存</a></span></dt><dt><span class="section"><a href="#_retrieving_the_routes_defined_in_the_gateway">120.4。检索网关中定义的路由</a></span></dt><dt><span class="section"><a href="#_retrieving_information_about_a_particular_route">120.5。检索有关特定路线的信息</a></span></dt><dt><span class="section"><a href="#_creating_and_deleting_a_particular_route">120.6。创建和删除特定路线</a></span></dt><dt><span class="section"><a href="#_recap_list_of_all_endpoints">120.7。回顾：所有端点的列表</a></span></dt></dl></dd><dt><span class="chapter"><a href="#troubleshooting">121。故障排除</a></span></dt><dd><dl><dt><span class="section"><a href="#_log_levels">121.1。日志级别</a></span></dt><dt><span class="section"><a href="#_wiretap">121.2。窃听</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_developer_guide">122。开发人员指南</a></span></dt><dd><dl><dt><span class="section"><a href="#_writing_custom_route_predicate_factories">122.1。编写自定义路线谓词工厂</a></span></dt><dt><span class="section"><a href="#_writing_custom_gatewayfilter_factories">122.2。编写自定义GatewayFilter工厂</a></span></dt><dt><span class="section"><a href="#_writing_custom_global_filters">122.3。编写自定义全局过滤器</a></span></dt><dt><span class="section"><a href="#_writing_custom_route_locators_and_writers">122.4。编写自定义路线定位器和编写器</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_building_a_simple_gateway_using_spring_mvc_or_webflux">123。使用Spring MVC或Webflux构建简单的网关</a></span></dt></dl></dd><dt><span class="part"><a href="#_spring_cloud_function_2">十六。spring-cloud-function</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_introduction_2">124。介绍</a></span></dt><dt><span class="chapter"><a href="#_getting_started">125。入门</a></span></dt><dt><span class="chapter"><a href="#_building_and_running_a_function">126。建立和运行功能</a></span></dt><dt><span class="chapter"><a href="#_function_catalog_and_flexible_function_signatures">127。功能目录和灵活的功能签名</a></span></dt><dd><dl><dt><span class="section"><a href="#_java_8_function_support">127.1。Java 8功能支持</a></span></dt><dt><span class="section"><a href="#_kotlin_lambda_support">127.2。Kotlin Lambda支持</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_standalone_web_applications">128。独立的Web应用程序</a></span></dt><dt><span class="chapter"><a href="#_standalone_streaming_applications">129。独立流媒体应用程序</a></span></dt><dt><span class="chapter"><a href="#_deploying_a_packaged_function">130。部署打包功能</a></span></dt><dt><span class="chapter"><a href="#_functional_bean_definitions">131。功能Bean定义</a></span></dt><dd><dl><dt><span class="section"><a href="#_comparing_functional_with_traditional_bean_definitions">131.1。将功能与传统Bean定义进行比较</a></span></dt><dt><span class="section"><a href="#_testing_functional_applications">131.2。测试功能应用</a></span></dt><dt><span class="section"><a href="#_limitations_of_functional_bean_declaration">131.3。功能Bean声明的局限性</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_dynamic_compilation">132。动态编译</a></span></dt><dt><span class="chapter"><a href="#_serverless_platform_adapters">133。无服务器平台适配器</a></span></dt><dd><dl><dt><span class="section"><a href="#_aws_lambda">133.1。AWS Lambda</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction_3">133.1.1。介绍</a></span></dt><dt><span class="section"><a href="#_notes_on_jar_layout">133.1.2。有关JAR布局的注意事项</a></span></dt><dt><span class="section"><a href="#_upload">133.1.3。上载</a></span></dt><dt><span class="section"><a href="#_platfom_specific_features">133.1.4。Platfom的特定功能</a></span></dt><dd><dl><dt><span class="section"><a href="#_http_and_api_gateway">HTTP和API网关</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_azure_functions">133.2。Azure功能</a></span></dt><dd><dl><dt><span class="section"><a href="#_notes_on_jar_layout_2">133.2.1。有关JAR布局的注意事项</a></span></dt><dt><span class="section"><a href="#_build">133.2.2。建立</a></span></dt><dt><span class="section"><a href="#_running_the_sample">133.2.3。运行样本</a></span></dt></dl></dd><dt><span class="section"><a href="#_apache_openwhisk">133.3。Apache Openwhisk</a></span></dt><dd><dl><dt><span class="section"><a href="#_quick_start_5">133.3.1。快速开始</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#_spring_cloud_kubernetes">十七。 Spring Cloud Kubernetes</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_why_do_you_need_spring_cloud_kubernetes">134。为什么需要Spring Cloud Kubernetes？</a></span></dt><dt><span class="chapter"><a href="#_starters">135。初学者</a></span></dt><dt><span class="chapter"><a href="#_discoveryclient_for_kubernetes">136。Kubernetes的DiscoveryClient</a></span></dt><dt><span class="chapter"><a href="#_kubernetes_native_service_discovery">137。Kubernetes本机服务发现</a></span></dt><dt><span class="chapter"><a href="#_kubernetes_propertysource_implementations">138。Kubernetes PropertySource实现</a></span></dt><dd><dl><dt><span class="section"><a href="#configmap-propertysource">138.1。用一个<code class="literal">ConfigMap</code> <code class="literal">PropertySource</code></a></span></dt><dt><span class="section"><a href="#_secrets_propertysource">138.2。秘密PropertySource</a></span></dt><dt><span class="section"><a href="#_propertysource_reload">138.3。 <code class="literal">PropertySource</code> 重装</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_ribbon_discovery_in_kubernetes">139。Kubernetes中的Ribbon发现</a></span></dt><dt><span class="chapter"><a href="#_kubernetes_ecosystem_awareness">140。Kubernetes生态系统意识</a></span></dt><dd><dl><dt><span class="section"><a href="#_kubernetes_profile_autoconfiguration">140.1。Kubernetes配置文件自动配置</a></span></dt><dt><span class="section"><a href="#_istio_awareness">140.2。Istio意识</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_pod_health_indicator">141。 bean 荚健康指标</a></span></dt><dt><span class="chapter"><a href="#_leader_election">142。领导人选举</a></span></dt><dt><span class="chapter"><a href="#_security_configurations_inside_kubernetes">143。Kubernetes内部的安全配置</a></span></dt><dd><dl><dt><span class="section"><a href="#_namespace">143.1。命名空间</a></span></dt><dt><span class="section"><a href="#_service_account">143.2。服务帐号</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_service_registry_implementation">144。服务注册表实施</a></span></dt><dt><span class="chapter"><a href="#_examples_2">145。例子</a></span></dt><dt><span class="chapter"><a href="#_other_resources">146。其他资源</a></span></dt><dt><span class="chapter"><a href="#_building">147。建造</a></span></dt><dd><dl><dt><span class="section"><a href="#_basic_compile_and_test">147.1。基本编译和测试</a></span></dt><dt><span class="section"><a href="#_documentation">147.2。文献资料</a></span></dt><dt><span class="section"><a href="#_working_with_the_code">147.3。使用代码</a></span></dt><dd><dl><dt><span class="section"><a href="#_importing_into_eclipse_with_m2eclipse">147.3.1。使用m2eclipse导入eclipse</a></span></dt><dt><span class="section"><a href="#_importing_into_eclipse_without_m2eclipse">147.3.2。不使用m2eclipse导入eclipse</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_contributing">148。贡献</a></span></dt><dd><dl><dt><span class="section"><a href="#_sign_the_contributor_license_agreement">148.1。签署贡献者许可协议</a></span></dt><dt><span class="section"><a href="#_code_of_conduct">148.2。行为守则</a></span></dt><dt><span class="section"><a href="#_code_conventions_and_housekeeping">148.3。规范和内务守则</a></span></dt><dt><span class="section"><a href="#_checkstyle">148.4。Checkstyle</a></span></dt><dd><dl><dt><span class="section"><a href="#_checkstyle_configuration">148.4.1。Checkstyle配置</a></span></dt></dl></dd><dt><span class="section"><a href="#_ide_setup">148.5。IDE设置</a></span></dt><dd><dl><dt><span class="section"><a href="#_intellij_idea">148.5.1。Intellij IDEA</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#spring-cloud-gcp-reference">十八。 Spring Cloud GCP</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_introduction_4">149。介绍</a></span></dt><dt><span class="chapter"><a href="#_dependency_management">150。依赖管理</a></span></dt><dt><span class="chapter"><a href="#_getting_started_2">151。入门</a></span></dt><dd><dl><dt><span class="section"><a href="#_spring_initializr">151.1。Spring Initializr</a></span></dt><dd><dl><dt><span class="section"><a href="#_gcp_support">151.1.1。GCP支持</a></span></dt><dt><span class="section"><a href="#_gcp_messaging">151.1.2。GCP讯息</a></span></dt><dt><span class="section"><a href="#_gcp_storage">151.1.3。GCP储存</a></span></dt></dl></dd><dt><span class="section"><a href="#_code_samples">151.2。代码样例</a></span></dt><dt><span class="section"><a href="#_code_challenges">151.3。代码挑战</a></span></dt><dt><span class="section"><a href="#_getting_started_guides">151.4。入门指南</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring-cloud-gcp-core">152。Spring Cloud GCP核心</a></span></dt><dd><dl><dt><span class="section"><a href="#_project_id">152.1。专案编号</a></span></dt><dt><span class="section"><a href="#_credentials">152.2。证书</a></span></dt><dd><dl><dt><span class="section"><a href="#_scopes">152.2.1。范围</a></span></dt></dl></dd><dt><span class="section"><a href="#_environment">152.3。环境</a></span></dt><dt><span class="section"><a href="#_spring_initializr_2">152.4。Spring Initializr</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_google_cloud_pubsub">153。Google Cloud Pub / Sub</a></span></dt><dd><dl><dt><span class="section"><a href="#_pubsub_operations_template">153.1。发布/订阅操作和模板</a></span></dt><dd><dl><dt><span class="section"><a href="#_publishing_to_a_topic">153.1.1。发布到主题</a></span></dt><dd><dl><dt><span class="section"><a href="#_json_support">JSON支持</a></span></dt></dl></dd><dt><span class="section"><a href="#_subscribing_to_a_subscription">153.1.2。订阅订阅</a></span></dt><dt><span class="section"><a href="#_pulling_messages_from_a_subscription">153.1.3。从订阅中提取消息</a></span></dt></dl></dd><dt><span class="section"><a href="#_pubsub_management">153.2。发布/订阅管理</a></span></dt><dd><dl><dt><span class="section"><a href="#_creating_a_topic">153.2.1。创建一个话题</a></span></dt><dt><span class="section"><a href="#_deleting_a_topic">153.2.2。删除主题</a></span></dt><dt><span class="section"><a href="#_listing_topics">153.2.3。列出主题</a></span></dt><dt><span class="section"><a href="#_creating_a_subscription">153.2.4。创建订阅</a></span></dt><dt><span class="section"><a href="#_deleting_a_subscription">153.2.5。删除订阅</a></span></dt><dt><span class="section"><a href="#_listing_subscriptions">153.2.6。列表订阅</a></span></dt></dl></dd><dt><span class="section"><a href="#pubsub-configuration">153.3。组态</a></span></dt><dt><span class="section"><a href="#_sample">153.4。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_resources">154。春季资源</a></span></dt><dd><dl><dt><span class="section"><a href="#_google_cloud_storage">154.1。谷歌云存储</a></span></dt><dd><dl><dt><span class="section"><a href="#_setting_the_content_type">154.1.1。设置内容类型</a></span></dt></dl></dd><dt><span class="section"><a href="#_configuration_3">154.2。组态</a></span></dt><dt><span class="section"><a href="#_sample_2">154.3。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_jdbc">155。Spring JDBC</a></span></dt><dd><dl><dt><span class="section"><a href="#_prerequisites">155.1。先决条件</a></span></dt><dt><span class="section"><a href="#_spring_boot_starter_for_google_cloud_sql">155.2。适用于Google Cloud SQL的Spring Boot Starter</a></span></dt><dd><dl><dt><span class="section"><a href="#_datasource_creation_flow">155.2.1。 <code class="literal">DataSource</code>创作流程</a></span></dt><dt><span class="section"><a href="#_troubleshooting_tips">155.2.2。故障排除技巧</a></span></dt><dd><dl><dt><span class="section"><a href="#connection-issues">连接问题</a></span></dt><dt><span class="section"><a href="#_errors_like_c_g_cloud_sql_core_sslsocketfactory_re_throwing_cached_exception_due_to_attempt_to_refresh_instance_information_too_soon_after_error">像这样的错误<code class="literal">c.g.cloud.sql.core.SslSocketFactory : Re-throwing cached exception due to attempt to refresh instance information too soon after error</code></a></span></dt><dt><span class="section"><a href="#_postgresql_java_net_socketexception_already_connected_issue">PostgreSQL： <code class="literal">java.net.SocketException: already connected</code>问题</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#_samples_3">155.3。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_integration">156。 Spring Integration </a></span></dt><dd><dl><dt><span class="section"><a href="#_channel_adapters_for_cloud_pubsub">156.1。Cloud Pub / Sub的通道适配器</a></span></dt><dd><dl><dt><span class="section"><a href="#_inbound_channel_adapter">156.1.1。入站通道适配器</a></span></dt><dt><span class="section"><a href="#_outbound_channel_adapter">156.1.2。出站通道适配器</a></span></dt><dt><span class="section"><a href="#_header_mapping">156.1.3。标头映射</a></span></dt></dl></dd><dt><span class="section"><a href="#_sample_3">156.2。样品</a></span></dt><dt><span class="section"><a href="#_channel_adapters_for_google_cloud_storage">156.3。Google Cloud Storage的通道适配器</a></span></dt><dd><dl><dt><span class="section"><a href="#_inbound_channel_adapter_2">156.3.1。入站通道适配器</a></span></dt><dt><span class="section"><a href="#_inbound_streaming_channel_adapter">156.3.2。入站流媒体通道适配器</a></span></dt><dt><span class="section"><a href="#_outbound_channel_adapter_2">156.3.3。出站通道适配器</a></span></dt></dl></dd><dt><span class="section"><a href="#_sample_4">156.4。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_stream_2">157。 Spring Cloud Stream </a></span></dt><dd><dl><dt><span class="section"><a href="#_overview_2">157.1。总览</a></span></dt><dt><span class="section"><a href="#_configuration_4">157.2。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#_producer_destination_configuration">157.2.1。生产者目标配置</a></span></dt><dt><span class="section"><a href="#_consumer_destination_configuration">157.2.2。消费者目的地配置</a></span></dt></dl></dd><dt><span class="section"><a href="#_sample_5">157.3。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_sleuth_2">158。 Spring Cloud Sleuth </a></span></dt><dd><dl><dt><span class="section"><a href="#_tracing_2">158.1。追踪</a></span></dt><dt><span class="section"><a href="#_spring_boot_starter_for_stackdriver_trace">158.2。用于Stackdriver Trace的Spring Boot Starter</a></span></dt><dt><span class="section"><a href="#_overriding_the_auto_configuration">158.3。覆盖自动配置</a></span></dt><dt><span class="section"><a href="#_integration_with_logging">158.4。与记录集成</a></span></dt><dt><span class="section"><a href="#_sample_6">158.5。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_stackdriver_logging">159。Stackdriver记录</a></span></dt><dd><dl><dt><span class="section"><a href="#_web_mvc_interceptor">159.1。Web MVC拦截器</a></span></dt><dt><span class="section"><a href="#_logback_support">159.2。登录支持</a></span></dt><dd><dl><dt><span class="section"><a href="#_log_via_api">159.2.1。通过API记录</a></span></dt><dt><span class="section"><a href="#_log_via_console">159.2.2。通过控制台登录</a></span></dt></dl></dd><dt><span class="section"><a href="#_sample_7">159.3。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_cloud_config_2">160。Spring Cloud Config</a></span></dt><dd><dl><dt><span class="section"><a href="#_configuration_5">160.1。组态</a></span></dt><dt><span class="section"><a href="#_quick_start_6">160.2。快速开始</a></span></dt><dt><span class="section"><a href="#_refreshing_the_configuration_at_runtime">160.3在运行时刷新配置</a></span></dt><dt><span class="section"><a href="#_sample_8">160.4。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_data_cloud_spanner">161。Spring Data Cloud Spanner</a></span></dt><dd><dl><dt><span class="section"><a href="#_configuration_6">161.1。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#_cloud_spanner_settings">161.1.1。Cloud Spanner设置</a></span></dt><dt><span class="section"><a href="#_repository_settings">161.1.2。储存库设定</a></span></dt><dt><span class="section"><a href="#_autoconfiguration">161.1.3。自动配置</a></span></dt></dl></dd><dt><span class="section"><a href="#_object_mapping">161.2。对象映射</a></span></dt><dd><dl><dt><span class="section"><a href="#_constructors">161.2.1。建设者</a></span></dt><dt><span class="section"><a href="#_table">161.2.2。表</a></span></dt><dd><dl><dt><span class="section"><a href="#_spel_expressions_for_table_names">表名称的SpEL表达式</a></span></dt></dl></dd><dt><span class="section"><a href="#_primary_keys">161.2.3。主键</a></span></dt><dt><span class="section"><a href="#_columns">161.2.4。列</a></span></dt><dt><span class="section"><a href="#_embedded_objects">161.2.5。嵌入式对象</a></span></dt><dt><span class="section"><a href="#_relationships">161.2.6。人际关系</a></span></dt><dt><span class="section"><a href="#_supported_types">161.2.7。支持的类型</a></span></dt><dt><span class="section"><a href="#_lists">161.2.8。清单</a></span></dt><dt><span class="section"><a href="#_lists_of_structs">161.2.9。结构清单</a></span></dt><dt><span class="section"><a href="#_custom_types">161.2.10。自定义类型</a></span></dt><dt><span class="section"><a href="#_custom_converter_for_struct_array_columns">161.2.11。结构数组列的自定义转换器</a></span></dt></dl></dd><dt><span class="section"><a href="#_spanner_operations_template">161.3。扳手操作和模板</a></span></dt><dd><dl><dt><span class="section"><a href="#_sql_query">161.3.1。SQL查询</a></span></dt><dt><span class="section"><a href="#_read">161.3.2。读</a></span></dt><dt><span class="section"><a href="#_advanced_reads">161.3.3。高级阅读</a></span></dt><dd><dl><dt><span class="section"><a href="#_stale_read">过时的阅读</a></span></dt><dt><span class="section"><a href="#_read_from_a_secondary_index">从二级索引读取</a></span></dt><dt><span class="section"><a href="#_read_with_offsets_and_limits">读取偏移量和限制</a></span></dt><dt><span class="section"><a href="#_sorting">排序</a></span></dt><dt><span class="section"><a href="#_partial_read">部分阅读</a></span></dt><dt><span class="section"><a href="#_summary_of_options_for_query_vs_read">查询与读取的选项摘要</a></span></dt></dl></dd><dt><span class="section"><a href="#_write_update">161.3.4。写入/更新</a></span></dt><dd><dl><dt><span class="section"><a href="#_insert">插入</a></span></dt><dt><span class="section"><a href="#_update">更新资料</a></span></dt><dt><span class="section"><a href="#_upsert">增补</a></span></dt><dt><span class="section"><a href="#_partial_update">部分更新</a></span></dt></dl></dd><dt><span class="section"><a href="#_dml">161.3.5。DML</a></span></dt><dt><span class="section"><a href="#_transactions">161.3.6。交易次数</a></span></dt><dd><dl><dt><span class="section"><a href="#_readwrite_transaction">读/写事务</a></span></dt><dt><span class="section"><a href="#_read_only_transaction">只读交易</a></span></dt><dt><span class="section"><a href="#_declarative_transactions_with_transactional_annotation">带有@Transactional批注的声明式事务</a></span></dt></dl></dd><dt><span class="section"><a href="#_dml_statements">161.3.7。DML语句</a></span></dt></dl></dd><dt><span class="section"><a href="#_repositories">161.4。储存库</a></span></dt><dd><dl><dt><span class="section"><a href="#_crud_repository">161.4.1。CRUD资料库</a></span></dt><dt><span class="section"><a href="#_paging_and_sorting_repository">161.4.2。分页和排序存储库</a></span></dt><dt><span class="section"><a href="#_spanner_repository">161.4.3。扳手仓库</a></span></dt></dl></dd><dt><span class="section"><a href="#_query_methods">161.5。查询方法</a></span></dt><dd><dl><dt><span class="section"><a href="#_query_methods_by_convention">161.5.1。按约定查询方法</a></span></dt><dt><span class="section"><a href="#_custom_sqldml_query_methods">161.5.2。自定义SQL / DML查询方法</a></span></dt><dd><dl><dt><span class="section"><a href="#_query_methods_with_named_queries_properties">具有命名查询属性的查询方法</a></span></dt><dt><span class="section"><a href="#_query_methods_with_annotation">带注释的查询方法</a></span></dt></dl></dd><dt><span class="section"><a href="#_projections">161.5.3。投影</a></span></dt><dt><span class="section"><a href="#_rest_repositories">161.5.4。REST资料库</a></span></dt></dl></dd><dt><span class="section"><a href="#_database_and_schema_admin">161.6。数据库和架构管理</a></span></dt><dt><span class="section"><a href="#_sample_9">161.7。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_spring_data_cloud_datastore">162。Spring Data Cloud数据存储</a></span></dt><dd><dl><dt><span class="section"><a href="#_configuration_7">162.1。组态</a></span></dt><dd><dl><dt><span class="section"><a href="#_cloud_datastore_settings">162.1.1。Cloud Datastore设置</a></span></dt><dt><span class="section"><a href="#_repository_settings_2">162.1.2。储存库设定</a></span></dt><dt><span class="section"><a href="#_autoconfiguration_2">162.1.3。自动配置</a></span></dt></dl></dd><dt><span class="section"><a href="#_object_mapping_2">162.2。对象映射</a></span></dt><dd><dl><dt><span class="section"><a href="#_constructors_2">162.2.1。建设者</a></span></dt><dt><span class="section"><a href="#_kind">162.2.2。类</a></span></dt><dt><span class="section"><a href="#_keys">162.2.3。按键</a></span></dt><dt><span class="section"><a href="#_fields">162.2.4。领域</a></span></dt><dt><span class="section"><a href="#_supported_types_2">162.2.5。支持的类型</a></span></dt><dt><span class="section"><a href="#_custom_types_2">162.2.6。自定义类型</a></span></dt><dt><span class="section"><a href="#_collections_and_arrays">162.2.7。集合和数组</a></span></dt><dt><span class="section"><a href="#_custom_converter_for_collections">162.2.8。自定义转换器的集合</a></span></dt></dl></dd><dt><span class="section"><a href="#_relationships_2">162.3。人际关系</a></span></dt><dd><dl><dt><span class="section"><a href="#_embedded_entities">162.3.1。嵌入式实体</a></span></dt><dd><dl><dt><span class="section"><a href="#_maps">地图</a></span></dt></dl></dd><dt><span class="section"><a href="#_ancestor_descendant_relationships">162.3.2。祖辈关系</a></span></dt><dt><span class="section"><a href="#_key_reference_relationships">162.3.3。关键参考关系</a></span></dt></dl></dd><dt><span class="section"><a href="#_datastore_operations_template">162.4。数据存储操作和模板</a></span></dt><dd><dl><dt><span class="section"><a href="#_gql_query">162.4.1。GQL查询</a></span></dt><dt><span class="section"><a href="#_find_by_ids">162.4.2。按编号查找</a></span></dt><dd><dl><dt><span class="section"><a href="#_indexes">指标</a></span></dt><dt><span class="section"><a href="#_read_with_offsets_limits_and_sorting">读取偏移量，限制和排序</a></span></dt><dt><span class="section"><a href="#_partial_read_2">部分阅读</a></span></dt></dl></dd><dt><span class="section"><a href="#_write_update_2">162.4.3。写入/更新</a></span></dt><dd><dl><dt><span class="section"><a href="#_partial_update_2">部分更新</a></span></dt></dl></dd><dt><span class="section"><a href="#_transactions_2">162.4.4。交易次数</a></span></dt><dd><dl><dt><span class="section"><a href="#_declarative_transactions_with_transactional_annotation_2">带有@Transactional批注的声明式事务</a></span></dt></dl></dd><dt><span class="section"><a href="#_read_write_support_for_maps">162.4.5。对地图的读写支持</a></span></dt></dl></dd><dt><span class="section"><a href="#_repositories_2">162.5。储存库</a></span></dt><dd><dl><dt><span class="section"><a href="#_query_methods_by_convention_2">162.5.1。按约定查询方法</a></span></dt><dt><span class="section"><a href="#_custom_gql_query_methods">162.5.2。自定义GQL查询方法</a></span></dt><dd><dl><dt><span class="section"><a href="#_query_methods_with_annotation_2">带注释的查询方法</a></span></dt><dt><span class="section"><a href="#_query_methods_with_named_queries_properties_2">具有命名查询属性的查询方法</a></span></dt></dl></dd><dt><span class="section"><a href="#_transactions_3">162.5.3。交易次数</a></span></dt><dt><span class="section"><a href="#_projections_2">162.5.4。投影</a></span></dt><dt><span class="section"><a href="#_rest_repositories_2">162.5.5。REST资料库</a></span></dt></dl></dd><dt><span class="section"><a href="#_sample_10">162.6。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_cloud_memorystore_for_redis">163。Redis的Cloud Memorystore</a></span></dt><dd><dl><dt><span class="section"><a href="#_spring_caching">163.1。春季缓存</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_cloud_identity_aware_proxy_iap_authentication">164。云身份识别代理（IAP）身份验证</a></span></dt><dd><dl><dt><span class="section"><a href="#_configuration_8">164.1。组态</a></span></dt><dt><span class="section"><a href="#_sample_11">164.2。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_google_cloud_vision">165。Google Cloud Vision</a></span></dt><dd><dl><dt><span class="section"><a href="#_cloud_vision_template">165.1。云视觉模板</a></span></dt><dt><span class="section"><a href="#_detect_image_labels_example">165.2。检测图像标签示例</a></span></dt><dt><span class="section"><a href="#_sample_12">165.3。样品</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_cloud_foundry">166。云铸造</a></span></dt><dt><span class="chapter"><a href="#_kotlin_support">167。Kotlin支持</a></span></dt><dd><dl><dt><span class="section"><a href="#_prerequisites_2">167.1。先决条件</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_sample_13">168。样品</a></span></dt></dl></dd><dt><span class="part"><a href="#_appendix_compendium_of_configuration_properties">十九。附录：配置属性概述</a></span></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="d0e9" href="#d0e9"></a></h1></div></div></div><p>Spring Cloud为开发人员提供了工具，以快速构建分布式系统中的某些常见模式（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致样板式样，并且使用Spring Cloud开发人员可以快速站起来实现这些样板的服务和应用程序。它们将在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心以及诸如Cloud Foundry之类的托管平台。</p><p>版本：格林威治。SR4</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_features" href="#_features"></a> 1。特征</h1></div></div></div><p>Spring Cloud专注于为典型的用例和扩展机制提供良好的开箱即用体验，以涵盖其他情况。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">分布式/版本化配置</li><li class="listitem">服务注册和发现</li><li class="listitem">路由</li><li class="listitem">服务到服务的通话</li><li class="listitem">负载均衡</li><li class="listitem">断路器</li><li class="listitem">分布式消息传递</li></ul></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_cloud_native_applications" href="#_cloud_native_applications"></a>第一部分：云原生应用程序</h1></div></div></div><div class="partintro"><div></div><p><a class="link" href="https://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook" target="_top">Cloud Native</a>是一种应用程序开发样式，鼓励在持续交付和价值驱动型开发领域轻松采用最佳实践。一个相关的学科是构建<a class="link" href="https://12factor.net/" target="_top">12要素应用程序</a> ，其中开发实践与交付和运营目标保持一致-例如，通过使用声明性编程，管理和监视。Spring Cloud通过多种特定方式促进了这些开发风格。起点是一组功能，分布式系统中的所有组件都需要轻松访问这些功能。</p><p>Spring Cloud构建于其中的Spring <a class="link" href="https://projects.spring.io/spring-boot" target="_top">Boot</a>涵盖了许多这些功能。Spring Cloud作为两个库提供了更多功能：Spring Cloud上下文和Spring Cloud Commons。Spring Cloud Context为以下项目提供实用程序和特殊服务： <code class="literal">ApplicationContext</code> Spring Cloud应用程序（引导上下文，加密，刷新作用域和环境端点）。Spring Cloud Commons是在不同的Spring Cloud实现中使用的一组抽象和通用类（例如Spring Cloud Netflix和Spring Cloud Consul）。</p><p>如果由于“密钥大小非法”而导致异常，并且使用Sun的JDK，则需要安装Java密码术扩展（JCE）无限强度管辖权策略文件。有关更多信息，请参见以下链接：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_top">Java 6 JCE</a></li><li class="listitem"><a class="link" href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_top">Java 7 JCE</a></li><li class="listitem"><a class="link" href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_top">Java 8 JCE</a></li></ul></div><p>将文件解压缩到您使用的JRE/JDK x64/x86版本的JDK/jre/lib/security文件夹中。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，可以在<a class="link" href="https://github.com/spring-cloud/spring-cloud-commons/tree/master/docs/src/main/asciidoc" target="_top">github上</a>找到源代码和项目跟踪工具。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_context_application_context_services" href="#_spring_cloud_context_application_context_services"></a> 2。Spring Cloud Context：应用程序上下文服务</h2></div></div></div><p>Spring Boot对于如何使用Spring构建应用程序有一个坚定的看法。例如，它具有用于公共配置文件的常规位置，并具有用于公共管理和监视任务的端点。Spring Cloud在此基础上构建并添加了一些功能，这些功能可能是系统中所有组件可能会使用或偶尔需要的。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_the_bootstrap_application_context" href="#_the_bootstrap_application_context"></a> 2.1 Bootstrap应用程序上下文</h2></div></div></div><p>Spring Cloud应用程序通过创建<span class="quote">“ <span class="quote">bootstrap</span> ”</span>上下文进行操作，该上下文是主应用程序的父上下文。它负责从外部源加载配置属性，并负责解密本地外部配置文件中的属性。这两个上下文共享一个<code class="literal">Environment</code> ，这是任何Spring应用程序的外部属性的来源。默认情况下，引导程序属性（不<code class="literal">bootstrap.properties</code>但在引导阶段加载的属性）具有较高的优先级，因此它们不能被本地配置覆盖。</p><p>引导上下文使用不同于主应用程序上下文的约定来定位外部配置。代替<code class="literal">application.yml</code> （要么<code class="literal">.properties</code> ）， 您可以使用<code class="literal">bootstrap.yml</code> ，将引导程序的外部配置和主上下文很好地分开。以下清单显示了一个示例：</p><p><b>bootstrap.yml。</b>
</p><pre class="screen">spring:
  application:
    name: foo
  cloud:
    config:
      uri: ${SPRING_CONFIG_URI:http://localhost:8888}</pre><p>
</p><p>如果您的应用程序需要来自服务器的任何特定于应用程序的配置，则最好设置<code class="literal">spring.application.name</code> （在<code class="literal">bootstrap.yml</code>要么<code class="literal">application.yml</code> ）。为了财产<code class="literal">spring.application.name</code>要用作应用程序的上下文ID，必须在<code class="literal">bootstrap.[properties | yml]</code> 。</p><p>您可以通过设置完全禁用引导过程<code class="literal">spring.cloud.bootstrap.enabled=false</code> （例如，在系统属性中）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_application_context_hierarchies" href="#_application_context_hierarchies"></a> 2.2应用程序上下文层次结构</h2></div></div></div><p>如果您从中构建应用程序上下文<code class="literal">SpringApplication</code>要么<code class="literal">SpringApplicationBuilder</code> ，然后将Bootstrap上下文作为父级添加到该上下文。Spring的一个功能是子上下文从其父级继承属性源和配置文件，因此，与没有Spring Cloud Config的相同上下文相比， <span class="quote">“ <span class="quote">main</span> ”</span>应用程序上下文包含其他属性源。其他属性来源是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="quote">“ <span class="quote">bootstrap</span> ”</span> ：如果有的话<code class="literal">PropertySourceLocators</code>在Bootstrap上下文中找到，并且如果它们具有非空属性，则为可选<code class="literal">CompositePropertySource</code>优先出现。一个示例就是Spring Cloud Config Server中的属性。有关如何自定义此属性源内容的说明<span class="quote"><span class="quote"><a class="xref" href="#customizing-bootstrap-property-sources" title="2.6 Customizing the Bootstrap Property Sources">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#customizing-bootstrap-property-sources" title="2.6自定义Bootstrap属性源">第2.6节“自定义Bootstrap属性源”</a></span> ”</span> 。</li><li class="listitem"><span class="quote">“ <span class="quote">applicationConfig：[classpath：bootstrap.yml]</span> ”</span> （以及相关文件，如果Spring配置文件处于活动状态）：如果您有一个<code class="literal">bootstrap.yml</code> （要么<code class="literal">.properties</code> ），这些属性用于配置Bootstrap上下文。然后，当它们的父级被设置时，它们被添加到子级上下文中。它们的优先级低于<code class="literal">application.yml</code> （要么<code class="literal">.properties</code> ）以及在创建Spring Boot应用程序过程中通常添加到子级的任何其他属性源。有关如何自定义这些属性源内容的说明，请参见<span class="quote">“ <span class="quote"><a class="xref" href="#customizing-bootstrap-properties" title="2.3更改引导程序属性的位置">第2.3节“更改引导程序属性的位置”</a></span> ”</span> 。</li></ul></div><p>由于属性源的排序规则， <span class="quote">“ <span class="quote">bootstrap</span> ”</span>条目优先。但是，请注意，这些不包含来自<code class="literal">bootstrap.yml</code> ，其优先级非常低，但可用于设置默认值。</p><p>您可以通过设置以下内容的父上下文来扩展上下文层次结构<code class="literal">ApplicationContext</code>您创建-例如，通过使用自己的界面或<code class="literal">SpringApplicationBuilder</code>便利方法（ <code class="literal">parent()</code> ， <code class="literal">child()</code>和<code class="literal">sibling()</code> ）。引导上下文是您创建的最高级祖先的父级。层次结构中的每个上下文都有其自己的<span class="quote">“ <span class="quote">bootstrap</span> ”</span> （可能为空）属性源，以避免无意中将价值从父母传给后代。如果有配置服务器，则层次结构中的每个上下文原则上也可以具有不同的内容<code class="literal">spring.application.name</code>因此，另一个远程资源来源。常规的Spring应用程序上下文行为规则适用于属性解析：子上下文中的属性会按名称以及属性源名称覆盖父级属性。（如果子级具有与父级同名的属性源，则子级中不包含父级的值）。</p><p>请注意<code class="literal">SpringApplicationBuilder</code>让你分享一个<code class="literal">Environment</code>在整个层次结构中，但这不是默认值。因此，同级上下文尤其不需要具有相同的配置文件或属性源，即使它们可以与其父级共享相同的值。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="customizing-bootstrap-properties" href="#customizing-bootstrap-properties"></a> 2.3更改引导程序属性的位置</h2></div></div></div><p>的<code class="literal">bootstrap.yml</code> （要么<code class="literal">.properties</code> ）位置可以通过设置来指定<code class="literal">spring.cloud.bootstrap.name</code> （默认： <code class="literal">bootstrap</code> ） 要么<code class="literal">spring.cloud.bootstrap.location</code> （默认值：空）—例如，在系统属性中。这些属性的行为类似于<code class="literal">spring.config.*</code>具有相同名称的变体。实际上，它们是用来设置引导程序的<code class="literal">ApplicationContext</code>通过设置其属性<code class="literal">Environment</code> 。如果有有效的个人资料（来自<code class="literal">spring.profiles.active</code>或通过<code class="literal">Environment</code>在您正在构建的上下文中使用API），该配置文件中的属性也会被加载，与常规Spring Boot应用程序中的加载方法相同（例如，从<code class="literal">bootstrap-development.properties</code>为一个<code class="literal">development</code>轮廓。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="overriding-bootstrap-properties" href="#overriding-bootstrap-properties"></a> 2.4覆盖远程属性的值</h2></div></div></div><p>通过引导上下文添加到应用程序的属性源通常是<span class="quote">“ <span class="quote">远程的</span> ”</span> （例如，来自Spring Cloud Config Server）。默认情况下，不能在本地覆盖它们。如果要让您的应用程序使用自己的系统属性或配置文件覆盖远程属性，则远程属性源必须通过设置来授予其权限<code class="literal">spring.cloud.config.allowOverride=true</code> （在本地设置此功能无效）。设置该标志后，将使用两个更细粒度的设置来控制远程属性相对于系统属性和应用程序本地配置的位置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">spring.cloud.config.overrideNone=true</code> ：从任何本地属性源覆盖。</li><li class="listitem"><code class="literal">spring.cloud.config.overrideSystemProperties=false</code>注意：只有系统属性，命令行参数和环境变量（而不是本地配置文件）才应覆盖远程设置。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizing_the_bootstrap_configuration" href="#_customizing_the_bootstrap_configuration"></a> 2.5自定义Bootstrap配置</h2></div></div></div><p>引导上下文可以设置为通过添加条目来执行您喜欢的任何操作<code class="literal">/META-INF/spring.factories</code>在名为<code class="literal">org.springframework.cloud.bootstrap.BootstrapConfiguration</code> 。它包含逗号分隔的Spring列表<code class="literal">@Configuration</code>用于创建上下文的类。您可以在此处创建要对主应用程序上下文可用以进行自动装配的任何bean。有一个特殊的合同<code class="literal">@Beans</code>类型的<code class="literal">ApplicationContextInitializer</code> 。如果要控制启动顺序，则可以用<code class="literal">@Order</code>批注（默认顺序为<code class="literal">last</code> ）。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>添加自定义时<code class="literal">BootstrapConfiguration</code> ，请注意不要添加添加的类<code class="literal">@ComponentScanned</code>错误地进入你的<span class="quote">“ <span class="quote">主</span> ”</span>应用程序上下文，这里可能并不需要它们。为启动配置类使用单独的程序包名称，并确保您的名称尚未涵盖该名称<code class="literal">@ComponentScan</code>要么<code class="literal">@SpringBootApplication</code>带注释的配置类。</p></td></tr></tbody></table></div><p>引导过程通过将初始化程序注入主程序而结束<code class="literal">SpringApplication</code>实例（这是正常的Spring Boot启动序列，无论它是作为独立应用程序运行还是在应用程序服务器中部署）。首先，从中找到的类创建引导上下文<code class="literal">spring.factories</code> 。然后，全部<code class="literal">@Beans</code>类型的<code class="literal">ApplicationContextInitializer</code>被添加到主要<code class="literal">SpringApplication</code>在开始之前。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="customizing-bootstrap-property-sources" href="#customizing-bootstrap-property-sources"></a> 2.6自定义Bootstrap属性源</h2></div></div></div><p>引导过程添加的外部配置的默认属性源是Spring Cloud Config Server，但是您可以通过添加类型的bean添加其他源<code class="literal">PropertySourceLocator</code>到引导上下文（通过<code class="literal">spring.factories</code> ）。例如，您可以从其他服务器或数据库插入其他属性。</p><p>例如，请考虑以下定制定位器：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomPropertySourceLocator <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> PropertySourceLocator {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> PropertySource&lt;?&gt; locate(Environment environment) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MapPropertySource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customProperty"</span>,
                Collections.&lt;String, Object&gt;singletonMap(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"property.from.sample.custom.source"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"worked as intended"</span>));
    }

}</pre><p>的<code class="literal">Environment</code>传入的是用于<code class="literal">ApplicationContext</code>即将创建-换句话说，我们为其提供其他属性源的属性。它已经有正常的Spring Boot提供的属性源，因此您可以使用这些属性来定位特定于此的属性源<code class="literal">Environment</code> （例如，通过将其<code class="literal">spring.application.name</code> ，就像在默认的Spring Cloud Config Server属性源定位器中所做的一样。</p><p>如果您在其中创建带有此类的jar，然后添加一个<code class="literal">META-INF/spring.factories</code>包含以下内容<code class="literal">customProperty</code><code class="literal">PropertySource</code>出现在任何在其类路径中包含该jar的应用程序中：</p><pre class="screen">org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_logging_configuration" href="#_logging_configuration"></a> 2.7记录配置</h2></div></div></div><p>如果要使用Spring Boot配置日志设置，则应将此配置放在`bootstrap。[yml |属性]，如果您希望将其应用于所有事件。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>为了使Spring Cloud正确初始化日志记录配置，您不能使用自定义前缀。例如，使用<code class="literal">custom.loggin.logpath</code>初始化日志记录系统时，Spring Cloud将无法识别。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_environment_changes" href="#_environment_changes"></a> 2.8环境变化</h2></div></div></div><p>该应用程序监听<code class="literal">EnvironmentChangeEvent</code>并以几种标准方式对更改做出反应（其他<code class="literal">ApplicationListeners</code>可以添加为<code class="literal">@Beans</code>由用户以正常方式）。当一个<code class="literal">EnvironmentChangeEvent</code>被观察到，它具有已更改的键值的列表，应用程序使用这些键值来：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">重新绑定任何<code class="literal">@ConfigurationProperties</code>上下文中的bean</li><li class="listitem">在以下位置设置记录器级别的任何属性<code class="literal">logging.level.*</code></li></ul></div><p>请注意，默认情况下，“配置客户端”不会轮询<code class="literal">Environment</code> 。通常，我们不建议您使用这种方法来检测更改（尽管您可以使用<code class="literal">@Scheduled</code>注解）。如果您拥有横向扩展的客户端应用程序，则最好广播<code class="literal">EnvironmentChangeEvent</code>所有实例，而不是让它们轮询更改（例如，通过使用<a class="link" href="https://github.com/spring-cloud/spring-cloud-bus" target="_top">Spring Cloud Bus</a> ）。</p><p>的<code class="literal">EnvironmentChangeEvent</code>涵盖了一大类刷新用例，只要您实际上可以对<code class="literal">Environment</code>并发布活动。请注意，这些API是公共的，并且是核心Spring的一部分）。您可以验证更改是否绑定到<code class="literal">@ConfigurationProperties</code>通过访问<code class="literal">/configprops</code>端点（正常的Spring Boot Actuator功能）。例如，一个<code class="literal">DataSource</code>可以有它<code class="literal">maxPoolSize</code>在运行时更改（默认<code class="literal">DataSource</code>由Spring Boot创建的是<code class="literal">@ConfigurationProperties</code> bean）并动态地增加容量。重新绑定<code class="literal">@ConfigurationProperties</code>不涵盖另一类大类用例，在这些用例中，您需要对刷新有更多的控制，并且需要进行更改以使整体成为原子<code class="literal">ApplicationContext</code> 。为了解决这些问题，我们有<code class="literal">@RefreshScope</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="refresh-scope" href="#refresh-scope"></a> 2.9刷新范围</h2></div></div></div><p>当配置发生变化时，弹簧<code class="literal">@Bean</code>被标记为<code class="literal">@RefreshScope</code>得到特殊待遇。此功能解决了有状态Bean的问题，只有在初始化它们时才注入配置。例如，如果<code class="literal">DataSource</code>通过以下方式更改数据库URL时，连接已打开<code class="literal">Environment</code> ，您可能希望这些连接的持有人能够完成他们正在做的事情。然后，下次某物从池中借用连接时，它将获得具有新URL的连接。</p><p>有时，甚至可能必须应用<code class="literal">@RefreshScope</code>某些bean上的注释只能被初始化一次。如果bean是“不可变的”，则必须使用以下命令对bean进行注释<code class="literal">@RefreshScope</code>或在属性键下指定类名<code class="literal">spring.cloud.refresh.extra-refreshable</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您创建一个<code class="literal">DataSource</code> bean自己，实现是一个<code class="literal">HikariDataSource</code> ，返回最具体的类型，在这种情况下<code class="literal">HikariDataSource</code> 。否则，您需要设置<code class="literal">spring.cloud.refresh.extra-refreshable=javax.sql.DataSource</code> 。</p></td></tr></tbody></table></div><p>刷新作用域bean是惰性代理，它们在使用时（即，在调用方法时）进行初始化，并且作用域充当初始化值的缓存。要强制Bean在下一个方法调用上重新初始化，必须使它的缓存条目无效。</p><p>的<code class="literal">RefreshScope</code>在上下文中是一个bean，并且有一个公共的<code class="literal">refreshAll()</code>通过清除目标缓存来刷新作用域中所有bean的方法。的<code class="literal">/refresh</code>端点公开了此功能（通过HTTP或JMX）。要通过名称刷新单个bean，还有一个<code class="literal">refresh(String)</code>方法。</p><p>揭露<code class="literal">/refresh</code>端点，您需要向应用程序添加以下配置：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">management</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  endpoints</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    web</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      exposure</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        include</span>: refresh</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">@RefreshScope</code> （技术上）在<code class="literal">@Configuration</code>类，但可能会导致令人惊讶的行为。例如，这并不意味着所有<code class="literal">@Beans</code>该类中定义的自己<code class="literal">@RefreshScope</code> 。特别是，依赖于那些bean的任何东西都不能依赖于刷新启动时对其进行更新，除非它本身在其中<code class="literal">@RefreshScope</code> 。在这种情况下，将在刷新时重建它，并重新注入其依赖项。此时，它们将从刷新后重新初始化<code class="literal">@Configuration</code> ）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_encryption_and_decryption" href="#_encryption_and_decryption"></a> 2.10加密和解密</h2></div></div></div><p>Spring Cloud有一个<code class="literal">Environment</code>用于本地解密属性值的预处理器。它遵循与Config Server相同的规则，并通过以下方式具有相同的外部配置<code class="literal">encrypt.*</code> 。因此，您可以使用以下形式的加密值： <code class="literal">{cipher}*</code>并且，只要有一个有效的密钥，它们就会在主应用程序上下文获得<code class="literal">Environment</code>设置。要在应用程序中使用加密功能，您需要在类路径中包含Spring Security RSA（Maven坐标：“ org.springframework.security:spring-security-rsa”），并且还需要在其中使用完整强度的JCE扩展。您的JVM。</p><p>如果由于“密钥大小非法”而导致异常，并且使用Sun的JDK，则需要安装Java密码术扩展（JCE）无限强度管辖权策略文件。有关更多信息，请参见以下链接：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_top">Java 6 JCE</a></li><li class="listitem"><a class="link" href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_top">Java 7 JCE</a></li><li class="listitem"><a class="link" href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_top">Java 8 JCE</a></li></ul></div><p>将文件解压缩到您使用的JRE/JDK x64/x86版本的JDK/jre/lib/security文件夹中。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_endpoints" href="#_endpoints"></a> 2.11端点</h2></div></div></div><p>对于Spring Boot Actuator应用程序，可以使用一些其他管理端点。您可以使用：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">POST</code>至<code class="literal">/actuator/env</code>更新<code class="literal">Environment</code>并重新绑定<code class="literal">@ConfigurationProperties</code>和日志级别。</li><li class="listitem"><code class="literal">/actuator/refresh</code>重新加载引导上下文并刷新<code class="literal">@RefreshScope</code>beans。</li><li class="listitem"><code class="literal">/actuator/restart</code>关闭<code class="literal">ApplicationContext</code>并重新启动它（默认情况下禁用）。</li><li class="listitem"><code class="literal">/actuator/pause</code>和<code class="literal">/actuator/resume</code>用于呼叫<code class="literal">Lifecycle</code>方法 （ <code class="literal">stop()</code>和<code class="literal">start()</code>在<code class="literal">ApplicationContext</code> ）。</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果禁用<code class="literal">/actuator/restart</code>端点然后<code class="literal">/actuator/pause</code>和<code class="literal">/actuator/resume</code>端点也将被禁用，因为它们只是<code class="literal">/actuator/restart</code> 。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_commons_common_abstractions" href="#_spring_cloud_commons_common_abstractions"></a> 3。Spring Cloud Commons：通用抽象</h2></div></div></div><p>服务发现，负载平衡和电路断路器等模式将它们带到一个通用的抽象层，可以由所有Spring Cloud客户端使用，而与实现无关（例如，使用Eureka或Consul进行的发现）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_enablediscoveryclient" href="#_enablediscoveryclient"></a> 3.1 @EnableDiscoveryClient</h2></div></div></div><p>Spring Cloud Commons提供了<code class="literal">@EnableDiscoveryClient</code>注解。这寻找实现<code class="literal">DiscoveryClient</code>与<code class="literal">META-INF/spring.factories</code> 。Discovery Client的实现将配置类添加到<code class="literal">spring.factories</code>在下面<code class="literal">org.springframework.cloud.client.discovery.EnableDiscoveryClient</code>键。示例<code class="literal">DiscoveryClient</code>实现包括<a class="link" href="https://cloud.spring.io/spring-cloud-netflix/" target="_top">Spring Cloud Netflix Eureka</a> ， <a class="link" href="https://cloud.spring.io/spring-cloud-consul/" target="_top">Spring Cloud Consul Discovery</a>和<a class="link" href="https://cloud.spring.io/spring-cloud-zookeeper/" target="_top">Spring Cloud Zookeeper Discovery</a> 。</p><p>默认情况下， <code class="literal">DiscoveryClient</code>向远程发现服务器自动注册本地Spring Boot服务器。可以通过设置禁用此行为<code class="literal">autoRegister=false</code>在<code class="literal">@EnableDiscoveryClient</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">@EnableDiscoveryClient</code>不再需要。你可以放一个<code class="literal">DiscoveryClient</code>类路径上的实现导致Spring Boot应用程序向服务发现服务器注册。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_health_indicator" href="#_health_indicator"></a> 3.1.1健康指标</h3></div></div></div><p>公用创建spring-boot<code class="literal">HealthIndicator</code>那<code class="literal">DiscoveryClient</code>实施可以通过实施参与<code class="literal">DiscoveryHealthIndicator</code> 。禁用复合<code class="literal">HealthIndicator</code> ，设定<code class="literal">spring.cloud.discovery.client.composite-indicator.enabled=false</code> 。通用<code class="literal">HealthIndicator</code>基于<code class="literal">DiscoveryClient</code>已自动配置（ <code class="literal">DiscoveryClientHealthIndicator</code> ）。要禁用它，请设置<code class="literal">spring.cloud.discovery.client.health-indicator.enabled=false</code> 。要禁用<code class="literal">DiscoveryClientHealthIndicator</code> ，设定<code class="literal">spring.cloud.discovery.client.health-indicator.include-description=false</code> 。否则，它会随着<code class="literal">description</code>卷起的<code class="literal">HealthIndicator</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_ordering_discoveryclient_instances" href="#_ordering_discoveryclient_instances"></a> 3.1.2订购<code class="literal">DiscoveryClient</code>实例</h3></div></div></div><p><code class="literal">DiscoveryClient</code>接口扩展<code class="literal">Ordered</code> 。当使用多个发现客户端时，这很有用，因为它允许您定义返回的发现客户端的顺序，类似于如何订购Spring应用程序加载的bean。默认情况下，任何<code class="literal">DiscoveryClient</code>被设定为<code class="literal">0</code> 。如果您想为自定义设置其他订单<code class="literal">DiscoveryClient</code>实现，您只需要覆盖<code class="literal">getOrder()</code>方法，以便它返回适合您的设置的值。除此之外，您还可以使用属性来设置<code class="literal">DiscoveryClient</code> Spring Cloud提供的实现，以及其他<code class="literal">ConsulDiscoveryClient</code> ， <code class="literal">EurekaDiscoveryClient</code>和<code class="literal">ZookeeperDiscoveryClient</code> 。为此，您只需要设置<code class="literal">spring.cloud.{clientIdentifier}.discovery.order</code> （要么<code class="literal">eureka.client.order</code> （对于Eureka）属性为所需值。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_serviceregistry" href="#_serviceregistry"></a> 3.2服务注册</h2></div></div></div><p>现在，Commons提供了一个<code class="literal">ServiceRegistry</code>提供诸如以下方法的接口<code class="literal">register(Registration)</code>和<code class="literal">deregister(Registration)</code> ，让您提供自定义的注册服务。
<code class="literal">Registration</code>是标记界面。</p><p>以下示例显示了<code class="literal">ServiceRegistry</code>正在使用：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableDiscoveryClient(autoRegister=false)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ServiceRegistry registry;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyConfiguration(ServiceRegistry registry) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.registry = registry;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// called through some external process, such as an event or a custom actuator endpoint</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> register() {
        Registration registration = constructRegistration();
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.registry.register(registration);
    }
}</pre><p>每<code class="literal">ServiceRegistry</code>实现有自己的<code class="literal">Registry</code>实施。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">ZookeeperRegistration</code>用于<code class="literal">ZookeeperServiceRegistry</code></li><li class="listitem"><code class="literal">EurekaRegistration</code>用于<code class="literal">EurekaServiceRegistry</code></li><li class="listitem"><code class="literal">ConsulRegistration</code>用于<code class="literal">ConsulServiceRegistry</code></li></ul></div><p>如果您正在使用<code class="literal">ServiceRegistry</code>界面，您将需要通过正确的<code class="literal">Registry</code>实施<code class="literal">ServiceRegistry</code>您正在使用的实现。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_serviceregistry_auto_registration" href="#_serviceregistry_auto_registration"></a> 3.2.1 ServiceRegistry自动注册</h3></div></div></div><p>默认情况下， <code class="literal">ServiceRegistry</code>实现自动注册正在运行的服务。要禁用该行为，可以设置：* <code class="literal">@EnableDiscoveryClient(autoRegister=false)</code>永久禁用自动注册。* <code class="literal">spring.cloud.service-registry.auto-registration.enabled=false</code>通过配置禁用行为。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_serviceregistry_auto_registration_events" href="#_serviceregistry_auto_registration_events"></a> ServiceRegistry自动注册事件</h4></div></div></div><p>服务自动注册时将触发两个事件。第一个事件称为<code class="literal">InstancePreRegisteredEvent</code>在注册服务之前被触发。第二个事件称为<code class="literal">InstanceRegisteredEvent</code>注册服务后触发。您可以注册一个<code class="literal">ApplicationListener</code> （s）听这些事件并做出反应。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果发生以下情况，则不会触发这些事件<code class="literal">spring.cloud.service-registry.auto-registration.enabled</code>被设定为<code class="literal">false</code> 。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_service_registry_actuator_endpoint" href="#_service_registry_actuator_endpoint"></a> 3.2.2服务注册表执行器端点</h3></div></div></div><p>Spring Cloud Commons提供了一个<code class="literal">/service-registry</code>执行器端点。该端点依赖于<code class="literal">Registration</code> Spring应用程序上下文中的bean。呼唤<code class="literal">/service-registry</code>使用GET返回的状态<code class="literal">Registration</code> 。对带有JSON正文的同一终结点使用POST可以更改当前状态<code class="literal">Registration</code>达到新的价值。JSON正文必须包含<code class="literal">status</code>具有首选值的字段。请参阅<code class="literal">ServiceRegistry</code>在更新状态和为状态返回的值时用于允许值的实现。例如，Eureka的支持状态为<code class="literal">UP</code> ， <code class="literal">DOWN</code> ， <code class="literal">OUT_OF_SERVICE</code>和<code class="literal">UNKNOWN</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_resttemplate_as_a_load_balancer_client" href="#_spring_resttemplate_as_a_load_balancer_client"></a> 3.3 Spring RestTemplate作为负载均衡器客户端</h2></div></div></div><p><code class="literal">RestTemplate</code>可以自动配置为在后台使用负载均衡器客户端。创建负载平衡<code class="literal">RestTemplate</code> ， 创建一个<code class="literal">RestTemplate</code><code class="literal">@Bean</code>并使用<code class="literal">@LoadBalanced</code>限定符，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {

    <em><span class="hl-annotation" style="color: gray">@LoadBalanced</span></em>
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    RestTemplate restTemplate() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RestTemplate();
    }
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RestTemplate restTemplate;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doOtherStuff() {
        String results = restTemplate.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://stores/stores"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> results;
    }
}</pre><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>一种<code class="literal">RestTemplate</code>不再通过自动配置创建bean。各个应用程序必须创建它。</p></td></tr></tbody></table></div><p>URI需要使用虚拟主机名（即服务名，而不是主机名）。功能区客户端用于创建完整的物理地址。有关如何执行以下操作的详细信息，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-ribbon/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonAutoConfiguration.java" target="_top">RibbonAutoConfiguration</a> 。 <code class="literal">RestTemplate</code>设置好了。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>为了使用负载均衡<code class="literal">RestTemplate</code> ，您需要在类路径中有一个负载平衡器实现。推荐的实现是<code class="literal">BlockingLoadBalancerClient</code> -添加<code class="literal">org.springframework.cloud:spring-cloud-loadbalancer</code>为了使用它。的<code class="literal">RibbonLoadBalancerClient</code>也可以使用，但现在正在维护中，我们不建议将其添加到新项目中。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果要使用<code class="literal">BlockingLoadBalancerClient</code> ，请确保您没有<code class="literal">RibbonLoadBalancerClient</code>在项目类路径中，由于向后兼容的原因，默认情况下将使用它。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_webclient_as_a_load_balancer_client" href="#_spring_webclient_as_a_load_balancer_client"></a> 3.4 Spring WebClient作为负载均衡器客户端</h2></div></div></div><p><code class="literal">WebClient</code>可以自动配置为使用负载平衡器客户端。创建负载平衡<code class="literal">WebClient</code> ， 创建一个<code class="literal">WebClient.Builder</code><code class="literal">@Bean</code>并使用<code class="literal">@LoadBalanced</code>限定符，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@LoadBalanced</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> WebClient.Builder loadBalancedWebClientBuilder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> WebClient.builder();
	}
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> WebClient.Builder webClientBuilder;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Mono&lt;String&gt; doOtherStuff() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> webClientBuilder.build().get().uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://stores/stores"</span>)
        				.retrieve().bodyToMono(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
    }
}</pre><p>URI需要使用虚拟主机名（即服务名，而不是主机名）。功能区客户端用于创建完整的物理地址。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您想使用<code class="literal">@LoadBalanced WebClient.Builder</code> ，则需要在类路径中有一个loadbalancer实现。建议您添加<code class="literal">org.springframework.cloud:spring-cloud-loadbalancer</code>对项目的依赖。然后， <code class="literal">ReactiveLoadBalancer</code>将在下面使用。另外，此功能也可以与spring-cloud-starter-netflix-ribbon一起使用，但是该请求将由非响应式处理<code class="literal">LoadBalancerClient</code>在引擎盖下。此外，spring-cloud-starter-netflix-ribbon已经处于维护模式，因此我们不建议您将其添加到新项目中。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">ReactorLoadBalancer</code>在下面使用支持缓存。如果<code class="literal">cacheManager</code>被检测到的缓存版本<code class="literal">ServiceInstanceSupplier</code>将会被使用。如果没有，我们将从发现服务中检索实例而不对其进行缓存。如果您使用，我们建议您在项目中<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html" target="_top">启用缓存</a> <code class="literal">ReactiveLoadBalancer</code> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_retrying_failed_requests" href="#_retrying_failed_requests"></a> 3.4.1重试失败的请求</h3></div></div></div><p>负载均衡<code class="literal">RestTemplate</code>可以配置为重试失败的请求。默认情况下，禁用此逻辑。您可以通过将<a class="link" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a>添加到应用程序的类路径来启用它。负载均衡<code class="literal">RestTemplate</code>支持某些与重试失败请求有关的功能区配置值。您可以使用<code class="literal">client.ribbon.MaxAutoRetries</code> ， <code class="literal">client.ribbon.MaxAutoRetriesNextServer</code>和<code class="literal">client.ribbon.OkToRetryOnAllOperations</code>属性。如果您想在类路径上使用Spring Retry禁用重试逻辑，则可以设置<code class="literal">spring.cloud.loadbalancer.retry.enabled=false</code> 。有关这些属性的说明，请参见<a class="link" href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties" target="_top">功能区文档</a> 。</p><p>如果您想实施<code class="literal">BackOffPolicy</code>在重试中，您需要创建一个类型为的bean <code class="literal">LoadBalancedRetryFactory</code>并覆盖<code class="literal">createBackOffPolicy</code>方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    LoadBalancedRetryFactory retryFactory() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LoadBalancedRetryFactory() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> BackOffPolicy createBackOffPolicy(String service) {
        		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ExponentialBackOffPolicy();
        	}
        };
    }
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">client</code>在上述示例中，应将其替换为Ribbon客户的名称。</p></td></tr></tbody></table></div><p>如果要添加一个或多个<code class="literal">RetryListener</code>重试功能的实现，您需要创建一个类型为的bean <code class="literal">LoadBalancedRetryListenerFactory</code>然后返回<code class="literal">RetryListener</code>您要用于给定服务的数组，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    LoadBalancedRetryListenerFactory retryListenerFactory() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LoadBalancedRetryListenerFactory() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RetryListener[] createRetryListeners(String service) {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RetryListener[]{<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RetryListener() {
                    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> &lt;T, E <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Throwable&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> open(RetryContext context, RetryCallback&lt;T, E&gt; callback) {
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//TODO Do you business...</span>
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> true;
                    }

                    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
                     <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> &lt;T, E <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Throwable&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> close(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//TODO Do you business...</span>
                    }

                    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> &lt;T, E <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Throwable&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> onError(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//TODO Do you business...</span>
                    }
                }};
            }
        };
    }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_multiple_resttemplate_objects" href="#_multiple_resttemplate_objects"></a> 3.5多个RestTemplate对象</h2></div></div></div><p>如果你想要一个<code class="literal">RestTemplate</code>那不是负载均衡的，创建一个<code class="literal">RestTemplate</code> bean 并注入。访问负载均衡<code class="literal">RestTemplate</code> ， 使用<code class="literal">@LoadBalanced</code>创建您的限定词<code class="literal">@Bean</code> ，如以下示例所示：\</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {

    <em><span class="hl-annotation" style="color: gray">@LoadBalanced</span></em>
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    RestTemplate loadBalanced() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RestTemplate();
    }

    <em><span class="hl-annotation" style="color: gray">@Primary</span></em>
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    RestTemplate restTemplate() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RestTemplate();
    }
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RestTemplate restTemplate;

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <em><span class="hl-annotation" style="color: gray">@LoadBalanced</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RestTemplate loadBalanced;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doOtherStuff() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> loadBalanced.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://stores/stores"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doStuff() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> restTemplate.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://example.com"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
    }
}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>注意使用<code class="literal">@Primary</code>在平原上的注释<code class="literal">RestTemplate</code>在前面的示例中进行声明以消除不合格的歧义<code class="literal">@Autowired</code>注射。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果您看到以下错误<code class="literal">java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89</code> ，尝试注入<code class="literal">RestOperations</code>或设置<code class="literal">spring.aop.proxyTargetClass=true</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="loadbalanced-webclient" href="#loadbalanced-webclient"></a> 3.6 Spring WebFlux WebClient作为负载均衡器客户端</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="webflux-with-reactive-loadbalancer" href="#webflux-with-reactive-loadbalancer"></a> 3.6.1带有响应式负载均衡器的Spring WebFlux WebClient</h3></div></div></div><p><code class="literal">WebClient</code>可以配置为使用<code class="literal">ReactiveLoadBalancer</code> 。如果添加<code class="literal">org.springframework.cloud:spring-cloud-loadbalancer</code>对你的项目， <code class="literal">ReactorLoadBalancerExchangeFilterFunction</code>是自动配置的，如果<code class="literal">spring-webflux</code>在类路径上。以下示例显示了如何配置<code class="literal">WebClient</code>在引擎盖下使用无功负载均衡器：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ReactorLoadBalancerExchangeFilterFunction lbFunction;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Mono&lt;String&gt; doOtherStuff() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> WebClient.builder().baseUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://stores"</span>)
            .filter(lbFunction)
            .build()
            .get()
            .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stores"</span>)
            .retrieve()
            .bodyToMono(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
    }
}</pre><p>URI需要使用虚拟主机名（即服务名，而不是主机名）。的<code class="literal">ReactorLoadBalancerClient</code>用于创建完整的物理地址。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_webflux_webclient_with_non_reactive_load_balancer_client" href="#_spring_webflux_webclient_with_non_reactive_load_balancer_client"></a> 3.6.2具有非反应式负载均衡器客户端的Spring WebFlux WebClient</h3></div></div></div><p>如果你没有<code class="literal">org.springframework.cloud:spring-cloud-loadbalancer</code>在您的项目中，但是您确实有spring-cloud-starter-netflix-ribbon，您仍然可以使用<code class="literal">WebClient</code>与<code class="literal">LoadBalancerClient</code> 。<code class="literal">LoadBalancerExchangeFilterFunction</code>将在以下情况下自动配置<code class="literal">spring-webflux</code>在类路径上。但是请注意，这是在后台使用非反应性客户端。以下示例显示了如何配置<code class="literal">WebClient</code>使用负载均衡器：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> LoadBalancerExchangeFilterFunction lbFunction;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Mono&lt;String&gt; doOtherStuff() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> WebClient.builder().baseUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://stores"</span>)
            .filter(lbFunction)
            .build()
            .get()
            .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stores"</span>)
            .retrieve()
            .bodyToMono(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
    }
}</pre><p>URI需要使用虚拟主机名（即服务名，而不是主机名）。的<code class="literal">LoadBalancerClient</code>用于创建完整的物理地址。</p><p>警告：现在不建议使用此方法。我们建议您将<a class="link" href="#webflux-with-reactive-loadbalancer" title="3.6.1带有响应式负载均衡器的Spring WebFlux WebClient">WebFlux与电抗性负载平衡器一起</a>使用。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_passing_your_own_load_balancer_client_configuration" href="#_passing_your_own_load_balancer_client_configuration"></a> 3.6.3传递自己的负载均衡客户端配置</h3></div></div></div><p>您也可以使用<code class="literal">@LoadBalancerClient</code>批注传递您自己的负载均衡器客户端配置，并传递负载均衡器客户端的名称和配置类，如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@LoadBalancerClient(value = "stores", configuration = StoresLoadBalancerClientConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@LoadBalanced</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> WebClient.Builder loadBalancedWebClientBuilder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> WebClient.builder();
	}
}</pre><p>也可以通过以下方式将多个配置（对于一个以上的负载均衡器客户端）一起传递： <code class="literal">@LoadBalancerClients</code>注释，如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@LoadBalancerClients({@LoadBalancerClient(value = "stores", configuration = StoresLoadBalancerClientConfiguration.class), @LoadBalancerClient(value = "customers", configuration = CustomersLoadBalancerClientConfiguration.class)})</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@LoadBalanced</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> WebClient.Builder loadBalancedWebClientBuilder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> WebClient.builder();
	}
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="ignore-network-interfaces" href="#ignore-network-interfaces"></a> 3.7忽略网络接口</h2></div></div></div><p>有时，忽略某些命名的网络接口很有用，以便可以将它们从服务发现注册中排除（例如，在Docker容器中运行时）。可以设置正则表达式列表以使所需的网络接口被忽略。以下配置忽略了<code class="literal">docker0</code>接口和所有以开头的接口<code class="literal">veth</code> ：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    inetutils:
      ignoredInterfaces:
        - docker0
        - veth.*</pre><p>
</p><p>您还可以通过使用正则表达式列表来强制仅使用指定的网络地址，如以下示例所示：</p><p><b>bootstrap.yml。</b>
</p><pre class="screen">spring:
  cloud:
    inetutils:
      preferredNetworks:
        - 192.168
        - 10.0</pre><p>
</p><p>您也可以只使用站点本地地址，如以下示例所示：.application.yml</p><pre class="screen">spring:
  cloud:
    inetutils:
      useOnlySiteLocalInterfaces: true</pre><p>有关构成站点本地地址的详细信息，请参见<a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/net/Inet4Address.html#isSiteLocalAddress--" target="_top">Inet4Address.html.isSiteLocalAddress（）</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="http-clients" href="#http-clients"></a> 3.8 HTTP客户端工厂</h2></div></div></div><p>Spring Cloud Commons提供了用于创建两个Apache HTTP客户端的bean（ <code class="literal">ApacheHttpClientFactory</code> ）和确定的HTTP客户端（ <code class="literal">OkHttpClientFactory</code> ）。的<code class="literal">OkHttpClientFactory</code>仅当OK HTTP jar位于类路径上时，才会创建bean。另外，Spring Cloud Commons提供了用于创建两个客户端都使用的连接管理器的bean： <code class="literal">ApacheHttpClientConnectionManagerFactory</code>用于Apache HTTP客户端和<code class="literal">OkHttpClientConnectionPoolFactory</code>确定HTTP客户端。如果要自定义在下游项目中创建HTTP客户端的方式，则可以提供自己的这些Bean实现。另外，如果您提供类型为的Bean <code class="literal">HttpClientBuilder</code>要么<code class="literal">OkHttpClient.Builder</code> ，默认工厂将这些构建器用作返回到下游项目的构建器的基础。您还可以通过设置禁用这些Bean的创建<code class="literal">spring.cloud.httpclientfactories.apache.enabled</code>要么<code class="literal">spring.cloud.httpclientfactories.ok.enabled</code>至<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="enabled-features" href="#enabled-features"></a> 3.9启用的功能</h2></div></div></div><p>Spring Cloud Commons提供了一个<code class="literal">/features</code>执行器端点。该端点返回类路径上可用的功能以及是否已启用它们。返回的信息包括功能类型，名称，版本和供应商。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_feature_types" href="#_feature_types"></a> 3.9.1功能类型</h3></div></div></div><p>“功能”有两种类型：抽象和命名。</p><p>抽象功能是定义接口或抽象类并创建实现的功能，例如<code class="literal">DiscoveryClient</code> ， <code class="literal">LoadBalancerClient</code> ， 要么<code class="literal">LockService</code> 。抽象类或接口用于在上下文中查找该类型的Bean。显示的版本是<code class="literal">bean.getClass().getPackage().getImplementationVersion()</code> 。</p><p>命名功能是没有实现的特定类的功能，例如“ Circuit Breaker”，“ API Gateway”，“ Spring Cloud Bus”等。这些功能需要名称和Bean类型。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_declaring_features" href="#_declaring_features"></a> 3.9.2声明功能</h3></div></div></div><p>任何模块都可以声明任意数量的<code class="literal">HasFeature</code> bean，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HasFeatures commonsFeatures() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> HasFeatures.abstractFeatures(DiscoveryClient.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, LoadBalancerClient.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HasFeatures consulFeatures() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> HasFeatures.namedFeatures(
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> NamedFeature(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Spring Cloud Bus"</span>, ConsulBusAutoConfiguration.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>),
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> NamedFeature(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Circuit Breaker"</span>, HystrixCommandAspect.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>));
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
HasFeatures localFeatures() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> HasFeatures.builder()
      .abstractFeature(Foo.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
      .namedFeature(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> NamedFeature(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Bar Feature"</span>, Bar.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>))
      .abstractFeature(Baz.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
      .build();
}</pre><p>这些 bean 中的每一个都应放入适当保护的容器中<code class="literal">@Configuration</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_cloud_compatibility_verification" href="#_spring_cloud_compatibility_verification"></a> 3.10 Spring Cloud兼容性验证</h2></div></div></div><p>由于某些用户在设置Spring Cloud应用程序时遇到问题，我们决定添加兼容性验证机制。如果您当前的设置与Spring Cloud要求不兼容，它会中断，并附上一份报告，显示出确切的问题。</p><p>目前，我们验证将哪个版本的Spring Boot添加到您的类路径中。</p><p>报告范例</p><pre class="screen">***************************
APPLICATION FAILED TO START
***************************

Description:

Your project setup is incompatible with our requirements due to following reasons:

- Spring Boot [2.1.0.RELEASE] is not compatible with this Spring Cloud release train


Action:

Consider applying the following actions:

- Change Spring Boot version to one of the following versions [1.2.x, 1.3.x] .
You can find the latest Spring Boot versions here [https://spring.io/projects/spring-boot#learn].
If you want to learn more about the Spring Cloud Release train compatibility, you can visit this page [https://spring.io/projects/spring-cloud#overview] and check the [Release Trains] section.</pre><p>为了禁用此功能，请设置<code class="literal">spring.cloud.compatibility-verifier.enabled</code>至<code class="literal">false</code> 。如果您想覆盖兼容的Spring Boot版本，只需设置<code class="literal">spring.cloud.compatibility-verifier.compatible-boot-versions</code>属性，以逗号分隔的兼容Spring Boot版本列表。</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_config" href="#_spring_cloud_config"></a>第二部分Spring Cloud Config</h1></div></div></div><div class="partintro"><div></div><p><span class="strong"><strong>格林威治。SR4</strong></span></p><p>Spring Cloud Config为分布式系统中的外部化配置提供服务器端和客户端支持。使用Config Server，您可以在中心位置管理所有环境中应用程序的外部属性。客户端和服务器上的概念与Spring完全相同<code class="literal">Environment</code>和<code class="literal">PropertySource</code>抽象，因此它们非常适合Spring应用程序，但可以与以任何语言运行的任何应用程序一起使用。在应用程序从开发人员到测试人员再到生产人员的整个部署管道中进行移动时，您可以管理这些环境之间的配置，并确保应用程序具有它们迁移时所需的一切。服务器存储后端的默认实现使用git，因此它轻松支持带标签的配置环境版本，并且可以通过各种工具来访问这些内容来管理内容。添加替代实现并将其插入Spring配置很容易。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_quick_start" href="#_quick_start"></a> 4。快速开始</h2></div></div></div><p>该快速入门介绍了如何同时使用Spring Cloud Config Server的服务器和客户端。</p><p>首先，启动服务器，如下所示：</p><pre class="screen">$ cd spring-cloud-config-server
$ ../mvnw spring-boot:run</pre><p>该服务器是Spring Boot应用程序，因此，如果愿意，可以从IDE运行它（主类是<code class="literal">ConfigServerApplication</code> ）。</p><p>接下来尝试一个客户端，如下所示：</p><pre class="screen">$ curl localhost:8888/foo/development
{"name":"foo","label":"master","propertySources":[
  {"name":"https://github.com/scratches/config-repo/foo-development.properties","source":{"bar":"spam"}},
  {"name":"https://github.com/scratches/config-repo/foo.properties","source":{"foo":"bar"}}
]}</pre><p>定位属性源的默认策略是克隆git存储库（位于<code class="literal">spring.cloud.config.server.git.uri</code> ）并使用它初始化一个迷你<code class="literal">SpringApplication</code> 。迷你应用程序的<code class="literal">Environment</code>用于枚举属性源并将其发布在JSON端点上。</p><p>HTTP服务具有以下形式的资源：</p><pre class="screen">/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties</pre><p>哪里<code class="literal">application</code>作为注入<code class="literal">spring.config.name</code>在里面<code class="literal">SpringApplication</code> （通常是<code class="literal">application</code>在常规的Spring Boot应用中）， <code class="literal">profile</code>是活动配置文件（或属性的逗号分隔列表），并且<code class="literal">label</code>是可选的git标签（默认为<code class="literal">master</code> ）</p><p>Spring Cloud Config Server从各种来源为远程客户端提取配置。以下示例从git存储库（必须提供）中获取配置，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo</pre><p>其他来源包括任何与JDBC兼容的数据库，Subversion，Hashicorp Vault，Credhub和本地文件系统。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_client_side_usage" href="#_client_side_usage"></a> 4.1客户端使用</h2></div></div></div><p>要在应用程序中使用这些功能，可以将其构建为依赖于spring-cloud-config-client的Spring Boot应用程序（例如，请参阅config-client或示例应用程序的测试用例）。添加依赖项最方便的方法是使用Spring Boot启动器<code class="literal">org.springframework.cloud:spring-cloud-starter-config</code> 。还有一个父pom和BOM（ <code class="literal">spring-cloud-starter-parent</code> ）（适用于Maven用户）和Spring IO版本管理属性文件（适用于Gradle和Spring CLI用户）。以下示例显示了典型的Maven配置：</p><p><b>pom.xml。</b>
</p><pre class="programlisting">   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;parent&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-parent<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{spring-boot-docs-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;relativePath /&gt;</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- lookup parent from repository --&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/parent&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{spring-cloud-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-config<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;build&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugins&gt;</span>
           <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
               <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
               <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
           <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugins&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/build&gt;</span>

   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- repositories also needed for snapshots and milestones --&gt;</span></pre><p>
</p><p>现在，您可以创建一个标准的Spring Boot应用程序，例如以下HTTP服务器：</p><pre class="screen">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</pre><p>当此HTTP服务器运行时，它将从端口8888上的默认本地配置服务器（如果正在运行）中获取外部配置。要修改启动行为，可以使用以下命令更改配置服务器的位置<code class="literal">bootstrap.properties</code> （相似<code class="literal">application.properties</code>但适用于应用程序上下文的引导阶段），如以下示例所示：</p><pre class="screen">spring.cloud.config.uri: http://myconfigserver.com</pre><p>默认情况下，如果未设置应用程序名称， <code class="literal">application</code>将会被使用。要修改名称，可以将以下属性添加到<code class="literal">bootstrap.properties</code>文件：</p><pre class="screen">spring.application.name: myapp</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>设置属性时<code class="literal">${spring.application.name}</code>不要在您的应用名称前加上保留字<code class="literal">application-</code>以防止解决正确的属性源的问题。</p></td></tr></tbody></table></div><p>引导程序属性显示在<code class="literal">/env</code>端点作为高优先级属性源，如以下示例所示。</p><pre class="screen">$ curl localhost:8080/env
{
  "profiles":[],
  "configService:https://github.com/spring-cloud-samples/config-repo/bar.properties":{"foo":"bar"},
  "servletContextInitParams":{},
  "systemProperties":{...},
  ...
}</pre><p>属性来源称为<code class="literal">``configService:<URL of remote repository>/<file name></code>包含<code class="literal">foo</code>值为的属性<code class="literal">bar</code>并且是最高优先级。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>属性源名称中的URL是git存储库，而不是配置服务器URL。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_config_server" href="#_spring_cloud_config_server"></a> 5，Spring Cloud Config服务器</h2></div></div></div><p>Spring Cloud Config Server为外部配置（名称-值对或等效的YAML内容）提供了一个基于HTTP资源的API。该服务器可通过使用以下命令嵌入到Spring Boot应用程序中： <code class="literal">@EnableConfigServer</code>注解。因此，以下应用程序是配置服务器：</p><p><b>ConfigServer.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableConfigServer</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ConfigServer {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(ConfigServer.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }
}</pre><p>
</p><p>像所有Spring Boot应用程序一样，它默认在端口8080上运行，但是您可以通过各种方式将其切换到更传统的端口8888。最简单的方法是设置启动默认配置存储库，方法是<code class="literal">spring.config.name=configserver</code> （有一个<code class="literal">configserver.yml</code>在Config Server jar中）。另一种是使用自己的<code class="literal">application.properties</code> ，如以下示例所示：</p><p><b>application.properties。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">server.port</span>: 8888
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.config.server.git.uri</span>: file://${user.home}/config-repo</pre><p>
</p><p>哪里<code class="literal">${user.home}/config-repo</code>是一个包含YAML和属性文件的git存储库。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在Windows上，如果文件URL带有驱动器前缀，则为绝对值（例如， <code class="literal"><a class="link" href="file:///${user.home}/config-repo" target="_top">file:///${user.home}/config-repo</a></code> ）。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>以下清单显示了在前面的示例中创建git存储库的方法：</p><pre class="screen">$ cd $HOME
$ mkdir config-repo
$ cd config-repo
$ git init .
$ echo info.foo: bar &gt; application.properties
$ git add -A .
$ git commit -m "Add application.properties"</pre></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>将本地文件系统用于git存储库仅用于测试。您应该使用服务器在生产环境中托管配置存储库。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果仅在其中存储文本文件，则配置存储库的初始克隆可以快速有效。如果存储二进制文件（尤其是大文件），则可能会在首次请求配置时遇到延迟，或者在服务器中遇到内存不足错误。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_environment_repository" href="#_environment_repository"></a> 5.1环境资料库</h2></div></div></div><p>您应该在哪里存储配置服务器的配置数据？控制这种行为的策略是<code class="literal">EnvironmentRepository</code> ，服务<code class="literal">Environment</code>对象。这个<code class="literal">Environment</code>是春季的域名的浅表副本<code class="literal">Environment</code> （包含<code class="literal">propertySources</code>作为主要功能）。的<code class="literal">Environment</code>资源由三个变量参数化：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">{application}</code> ，它映射到<code class="literal">spring.application.name</code>在客户端。</li><li class="listitem"><code class="literal">{profile}</code> ，它映射到<code class="literal">spring.profiles.active</code>在客户端（以逗号分隔的列表）上。</li><li class="listitem"><code class="literal">{label}</code> ，这是服务器端功能，标记了一组“版本化”的配置文件。</li></ul></div><p>仓库实现通常表现为类似于Spring Boot应用程序，从<code class="literal">spring.config.name</code>等于<code class="literal">{application}</code>参数，以及<code class="literal">spring.profiles.active</code>等于<code class="literal">{profiles}</code>参数。配置文件的优先规则也与常规Spring Boot应用程序中的规则相同：活动配置文件的优先级高于默认设置，如果有多个配置文件，则最后一个优先（类似于将条目添加到默认配置）。 <code class="literal">Map</code> ）。</p><p>以下示例客户端应用程序具有此引导程序配置：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: foo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: dev,mysql</pre><p>
</p><p>（与Spring Boot应用程序一样，这些属性也可以由环境变量或命令行参数设置）。</p><p>如果存储库基于文件，则服务器将创建一个<code class="literal">Environment</code>从<code class="literal">application.yml</code> （在所有客户之间共享）和<code class="literal">foo.yml</code> （与<code class="literal">foo.yml</code>优先）。如果YAML文件中包含指向Spring配置文件的文档，则将以更高的优先级应用这些文件（按列出的配置文件的顺序）。如果存在特定于配置文件的YAML（或属性）文件，这些文件也将以比默认文件更高的优先级应用。较高的优先级会转化为<code class="literal">PropertySource</code>在前面列出的<code class="literal">Environment</code> 。（这些规则适用于独立的Spring Boot应用程序。）</p><p>您可以将spring.cloud.config.server.accept-empty设置为false，以便在未找到应用程序的情况下Server返回HTTP 404状态。默认情况下，此标志设置为true。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_git_backend" href="#_git_backend"></a> 5.1.1 Git后端</h3></div></div></div><p>默认实现<code class="literal">EnvironmentRepository</code>使用Git后端，这对于管理升级和物理环境以及审核更改非常方便。要更改存储库的位置，您可以设置<code class="literal">spring.cloud.config.server.git.uri</code> Config Server中的配置属性（例如<code class="literal">application.yml</code> ）。如果您使用<code class="literal">file:</code>前缀，它应该在本地存储库中运行，以便您无需服务器即可快速轻松地开始使用。但是，在这种情况下，服务器直接在本地存储库上运行而无需克隆它（如果它不是裸露的，这并不重要，因为Config Server从不对“远程”存储库进行更改）。要扩展Config Server并使其高度可用，您需要使服务器的所有实例都指向同一存储库，因此仅共享文件系统可以工作。即使在这种情况下，最好还是使用<code class="literal">ssh:</code>共享文件系统存储库的协议，以便服务器可以克隆它并将本地工作副本用作缓存。</p><p>此存储库实现映射了<code class="literal">{label}</code> git标签（提交ID，分支名称或标签）的HTTP资源的参数。如果git分支或标记名称包含斜杠（ <code class="literal">/</code> ），则应使用特殊字符串在HTTP URL中指定标签<code class="literal">(_)</code> （以避免与其他URL路径产生歧义）。例如，如果标签是<code class="literal">foo/bar</code> ，替换斜杠将产生以下标签： <code class="literal">foo(_)bar</code> 。包含特殊字符串<code class="literal">(_)</code>也可以应用于<code class="literal">{application}</code>参数。如果您使用命令行客户端（例如curl），请注意URL中的括号-您应使用单引号（''）将其从外壳中移出。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_skipping_ssl_certificate_validation" href="#_skipping_ssl_certificate_validation"></a>跳过SSL证书验证</h4></div></div></div><p>可以通过设置以下选项来禁用配置服务器对Git服务器的SSL证书的验证： <code class="literal">git.skipSslValidation</code>财产<code class="literal">true</code> （默认为<code class="literal">false</code> ）。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://example.com/my/repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          skipSslValidation</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_setting_http_connection_timeout" href="#_setting_http_connection_timeout"></a>设置HTTP连接超时</h4></div></div></div><p>您可以配置配置服务器将等待获取HTTP连接的时间（以秒为单位）。使用<code class="literal">git.timeout</code>属性。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://example.com/my/repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          timeout</span>: <span class="hl-number">4</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_placeholders_in_git_uri" href="#_placeholders_in_git_uri"></a> Git URI中的占位符</h4></div></div></div><p>Spring Cloud Config Server支持带有占位符的git存储库URL <code class="literal">{application}</code>和<code class="literal">{profile}</code> （和<code class="literal">{label}</code> （如果需要），但请记住，无论如何该标签都将用作git标签）。因此，您可以使用类似于以下的结构来支持<span class="quote">“ <span class="quote">每个应用程序一个存储库</span> ”</span>策略：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/myorg/{application<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>您也可以使用类似的模式来支持<span class="quote">“ <span class="quote">每个配置文件一个存储库</span> ”</span>策略， <code class="literal">{profile}</code> 。</p><p>此外，在您的代码中使用特殊字符串“（_）” <code class="literal">{application}</code>参数可以启用对多个组织的支持，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/{application<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>哪里<code class="literal">{application}</code>在请求时以以下格式提供： <code class="literal">organization(_)application</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_pattern_matching_and_multiple_repositories" href="#_pattern_matching_and_multiple_repositories"></a>模式匹配和多个存储库</h4></div></div></div><p>Spring Cloud Config还通过在应用程序和配置文件名称上进行模式匹配来支持更复杂的需求。模式格式是逗号分隔的列表<code class="literal">{application}/{profile}</code>带通配符的名称（请注意，以通配符开头的模式可能需要加引号），如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          repos</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            simple</span>: https://github.com/simple/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            special</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              pattern</span>: special*/dev*,*special*/dev*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              uri</span>: https://github.com/special/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            local</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              pattern</span>: local*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              uri</span>: file:/home/configsvc/config-repo</pre><p>如果<code class="literal">{application}/{profile}</code>与任何模式都不匹配，它使用在下定义的默认URI <code class="literal">spring.cloud.config.server.git.uri</code> 。在上述例子中，对于<span class="quote">“ <span class="quote">简单</span> ” <span class="quote">的</span></span>存储库中，该模式是<code class="literal">simple/*</code> （它仅与一个名为<code class="literal">simple</code>在所有配置文件中）。<span class="quote">“ <span class="quote">本地</span> ”</span>存储库匹配所有以以下名称开头的应用程序名称<code class="literal">local</code>在所有配置文件中（ <code class="literal">/*</code>后缀会自动添加到没有配置文件匹配器的任何模式中。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>仅在要设置的唯一属性是URI的情况下，才能使用<span class="quote">“ <span class="quote">简单</span> ”</span>示例中使用的<span class="quote">“</span> <span class="quote"><span class="quote">单线</span> ”</span>快捷方式。如果您需要设置其他任何内容（凭证，模式等），则需要使用完整表格。</p></td></tr></tbody></table></div><p>的<code class="literal">pattern</code>回购中的属性实际上是一个数组，因此您可以使用YAML数组（或<code class="literal">[0]</code> ， <code class="literal">[1]</code>等属性文件中的后缀）以绑定到多个模式。如果要运行具有多个配置文件的应用程序，则可能需要这样做，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          repos</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            development</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              pattern</span>:
                - <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'*/development'</span>
                - <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'*/staging'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              uri</span>: https://github.com/development/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            staging</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              pattern</span>:
                - <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'*/qa'</span>
                - <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'*/production'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              uri</span>: https://github.com/staging/config-repo</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud猜测包含未以结尾的配置文件的模式<code class="literal">*</code>表示您实际上要匹配以该模式开头的配置文件列表（因此<code class="literal">*/staging</code>是的快捷方式<code class="literal">["*/staging", "*/staging,*"]</code> ， 等等）。例如，这很常见，例如，您需要在本地的<span class="quote">“ <span class="quote">开发</span> ”</span>配置文件中运行应用程序，而又需要远程地运行<span class="quote">“ <span class="quote">云</span> ”</span>配置文件。</p></td></tr></tbody></table></div><p>每个存储库还可以选择将配置文件存储在子目录中，并且可以将搜索这些目录的模式指定为<code class="literal">searchPaths</code> 。以下示例在顶层显示了一个配置文件：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          searchPaths</span>: foo,bar*</pre><p>在前面的示例中，服务器在顶层和服务器中搜索配置文件。 <code class="literal">foo/</code>子目录，以及名称以“。”开头的任何子目录<code class="literal">bar</code> 。</p><p>默认情况下，第一次请求配置时，服务器会克隆远程存储库。可以将服务器配置为在启动时克隆存储库，如以下顶级示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://git/common/config-repo.git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          repos</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            team-a</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                pattern</span>: team-a-*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                cloneOnStart</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                uri</span>: https://git/team-a/config-repo.git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            team-b</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                pattern</span>: team-b-*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                cloneOnStart</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                uri</span>: https://git/team-b/config-repo.git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            team-c</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                pattern</span>: team-c-*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                uri</span>: https://git/team-a/config-repo.git</pre><p>在前面的示例中，服务器在接受任何请求之前会在启动时克隆team-a的config-repo。在请求从存储库进行配置之前，不会克隆所有其他存储库。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>设置要在Config Server启动时克隆的存储库可以帮助在Config Server启动时快速识别配置错误的配置源（例如无效的存储库URI）。用<code class="literal">cloneOnStart</code>如果未为配置源启用配置服务器，则配置服务器可能会以配置错误或无效的配置源成功启动，并且直到应用程序从该配置源请求配置时才检测到错误。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_authentication" href="#_authentication"></a>认证方式</h4></div></div></div><p>要在远程存储库上使用HTTP基本身份验证，请添加<code class="literal">username</code>和<code class="literal">password</code>分别显示属性（不在URL中），如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          username</span>: trolley
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          password</span>: strongpassword</pre><p>如果您不使用HTTPS和用户凭据，则将密钥存储在默认目录中时，SSH也应立即可用（ <code class="literal">~/.ssh</code> ），并且URI指向SSH位置，例如<code class="literal">git@github.com:configuration/cloud-configuration</code> 。Git服务器的条目必须出现在<code class="literal">~/.ssh/known_hosts</code>文件，它在<code class="literal">ssh-rsa</code>格式。其他格式（例如<code class="literal">ecdsa-sha2-nistp256</code> ）不受支持。为避免意外，您应确保在<code class="literal">known_hosts</code> Git服务器的文件，并与您提供给配置服务器的URL匹配。如果您在网址中使用主机名，则希望在主机名中完全包含该主机名（而不是IP）。 <code class="literal">known_hosts</code>文件。使用JGit访问存储库，因此您找到的任何文档都应该适用。可以在以下位置设置HTTPS代理设置<code class="literal">~/.git/config</code>或（与其他任何JVM进程相同）具有系统属性（ <code class="literal">-Dhttps.proxyHost</code>和<code class="literal">-Dhttps.proxyPort</code> ）。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果你不知道你在哪里<code class="literal">~/.git</code>目录是，使用<code class="literal">git config --global</code>操作设置（例如， <code class="literal">git config --global http.sslVerify false</code> ）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_authentication_with_aws_codecommit" href="#_authentication_with_aws_codecommit"></a>使用AWS CodeCommit进行身份验证</h4></div></div></div><p>Spring Cloud Config Server还支持<a class="link" href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html" target="_top">AWS CodeCommit</a>身份验证。从命令行使用Git时，AWS CodeCommit使用身份验证帮助程序。该帮助程序未与JGit库一起使用，因此，如果Git URI与AWS CodeCommit模式匹配，则会为AWS CodeCommit创建一个JGit CredentialProvider。AWS CodeCommit URI遵循此模式：// git-codecommit。$ {AWS_REGION} .amazonaws.com / $ {repopath}。</p><p>如果您提供带有AWS CodeCommit URI的用户名和密码，则它们必须是提供对存储库的访问权的<a class="link" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html" target="_top">AWS accessKeyId和secretAccessKey</a> 。如果您未指定用户名和密码，则使用<a class="link" href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html" target="_top">AWS Default Credential Provider链</a>检索accessKeyId和secretAccessKey。</p><p>如果您的Git URI与CodeCommit URI模式（如前所示）匹配，则必须在用户名和密码或默认凭据提供程序链支持的位置之一中提供有效的AWS凭据。AWS EC2实例可以将<a class="link" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html" target="_top">IAM角色用于EC2实例</a> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">aws-java-sdk-core</code> jar是可选的依赖项。如果<code class="literal">aws-java-sdk-core</code> jar不在您的类路径上，无论git服务器URI如何，都不会创建AWS Code Commit凭证提供程序。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_git_ssh_configuration_using_properties" href="#_git_ssh_configuration_using_properties"></a>使用属性进行Git SSH配置</h4></div></div></div><p>默认情况下，Spring Cloud Config Server使用的JGit库使用SSH配置文件，例如<code class="literal">~/.ssh/known_hosts</code>和<code class="literal">/etc/ssh/ssh_config</code>使用SSH URI连接到Git存储库时。在Cloud Foundry之类的云环境中，本地文件系统可能是临时的，或者不容易访问。在这种情况下，可以使用Java属性设置SSH配置。为了激活基于属性的SSH配置， <code class="literal">spring.cloud.config.server.git.ignoreLocalSshSettings</code>属性必须设置为<code class="literal">true</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            uri</span>: git<em><span class="hl-annotation" style="color: gray">@gitserver.com:team/repo1.git</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            ignoreLocalSshSettings</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            hostKey</span>: someHostKey
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            hostKeyAlgorithm</span>: ssh-rsa
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            privateKey</span>: |
                         -----BEGIN RSA PRIVATE KEY-----
                         MIIEpgIBAAKCAQEAx4UbaDzY5xjW6hc9jwN0mX33XpTDVW9WqHp5AKaRbtAC3DqX
                         IXFMPgw3K45jxRb93f8tv9vL3rD9CUG1Gv4FM+o7ds7FRES5RTjv2RT/JVNJCoqF
                         ol8+ngLqRZCyBtQN7zYByWMRirPGoDUqdPYrj2yq+ObBBNhg5N+hOwKjjpzdj2Ud
                         <span class="hl-number">1l</span>7R+wxIqmJo1IYyy16xS8WsjyQuyC0lL456qkd5BDZ0Ag8j2X9H9D5220Ln7s9i
                         oezTipXipS7p7Jekf3Ywx6abJwOmB0rX79dV4qiNcGgzATnG1PkXxqt76VhcGa0W
                         DDVHEEYGbSQ6hIGSh0I7BQun0aLRZojfE3gqHQIDAQABAoIBAQCZmGrk8BK6tXCd
                         fY6yTiKxFzwb38IQP0ojIUWNrq0+<span class="hl-number">9</span>Xt+NsypviLHkXfXXCKKU4zUHeIGVRq5MN9b
                         BO56/RrcQHHOoJdUWuOV2qMqJvPUtC0CpGkD+valhfD75MxoXU7s3FK7yjxy3rsG
                         EmfA6tHV8/<span class="hl-number">4</span>a5umo5TqSd2YTm5B19AhRqiuUVI1wTB41DjULUGiMYrnYrhzQlVvj
                         <span class="hl-number">5</span>MjnKTlYu3V8PoYDfv1GmxPPh6vlpafXEeEYN8VB97e5x3DGHjZ5UrurAmTLTdO8
                         +AahyoKsIY612TkkQthJlt7FJAwnCGMgY6podzzvzICLFmmTXYiZ/<span class="hl-number">28</span>I4BX/mOSe
                         pZVnfRixAoGBAO6Uiwt40/PKs53mCEWngslSCsh9oGAaLTf/XdvMns5VmuyyAyKG
                         ti8Ol5wqBMi4GIUzjbgUvSUt+IowIrG3f5tN85wpjQ1UGVcpTnl5Qo9xaS1PFScQ
                         xrtWZ9eNj2TsIAMp/svJsyGG3OibxfnuAIpSXNQiJPwRlW3irzpGgVx/AoGBANYW
                         dnhshUcEHMJi3aXwR12OTDnaLoanVGLwLnkqLSYUZA7ZegpKq90UAuBdcEfgdpyi
                         PhKpeaeIiAaNnFo8m9aoTKr+<span class="hl-number">7</span>I6/uMTlwrVnfrsVTZv3orxjwQV20YIBCVRKD1uX
                         VhE0ozPZxwwKSPAFocpyWpGHGreGF1AIYBE9UBtjAoGBAI8bfPgJpyFyMiGBjO6z
                         FwlJc/xlFqDusrcHL7abW5qq0L4v3R+FrJw3ZYufzLTVcKfdj6GelwJJO+<span class="hl-number">8</span>wBm+R
                         gTKYJItEhT48duLIfTDyIpHGVm9+I1MGhh5zKuCqIhxIYr9jHloBB7kRm0rPvYY4
                         VAykcNgyDvtAVODP+<span class="hl-number">4</span>m6JvhjAoGBALbtTqErKN47V0+JJpapLnF0KxGrqeGIjIRV
                         cYA6V4WYGr7NeIfesecfOC356PyhgPfpcVyEztwlvwTKb3RzIT1TZN8fH4YBr6Ee
                         KTbTjefRFhVUjQqnucAvfGi29f+<span class="hl-number">9</span>oE3Ei9f7wA+H35ocF6JvTYUsHNMIO/<span class="hl-number">3</span>gZ38N
                         CPjyCMa9AoGBAMhsITNe3QcbsXAbdUR00dDsIFVROzyFJ2m40i4KCRM35bC/BIBs
                         q0TY3we+ERB40U8Z2BvU61QuwaunJ2+uGadHo58VSVdggqAo0BSkH58innKKt96J
                         <span class="hl-number">69</span>pcVH/<span class="hl-number">4</span>rmLbXdcmNYGm6iu+MlPQk4BUZknHSmVHIFdJ0EPupVaQ8RHT
                         -----END RSA PRIVATE KEY-----</pre><p>下表描述了SSH配置属性。</p><div class="table"><a name="d0e2031" href="#d0e2031"></a><p class="title"><b>表5.1。SSH配置属性</b></p><div class="table-contents"><table class="table" summary="SSH Configuration Properties" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid;border-left:1px solid;border-right:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">物业名称</th><th align="left" valign="top" style="border-bottom:1px solid">备注</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>ignoreLocalSshSettings</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果<code class="literal">true</code> ，请使用基于属性的SSH而非基于文件的SSH配置。必须设置为<code class="literal">spring.cloud.config.server.git.ignoreLocalSshSettings</code> ， <span class="strong"><strong>而不是</strong></span>在存储库定义中。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>私钥</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>有效的SSH私钥。如果必须设置<code class="literal">ignoreLocalSshSettings</code>是true，Git URI是SSH格式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>hostKey</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>有效的SSH主机密钥。如果必须设置<code class="literal">hostKeyAlgorithm</code>也设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>hostKeyAlgorithm</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>之一<code class="literal">ssh-dss, ssh-rsa, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521</code> 。如果必须设置<code class="literal">hostKey</code>也设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>strictHostKeyChecking</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code>要么<code class="literal">false</code> 。如果为false，请忽略主机密钥错误。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>knownHostsFile</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>海关地点<code class="literal">.known_hosts</code>文件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><span class="strong"><strong>preferredAuthentications</strong></span></p></td><td align="left" valign="top"><p>覆盖服务器身份验证方法顺序。如果服务器在启动之前具有键盘交互式身份验证，这应该可以避免登录提示。 <code class="literal">publickey</code>方法。</p></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_placeholders_in_git_search_paths" href="#_placeholders_in_git_search_paths"></a> Git搜索路径中的占位符</h4></div></div></div><p>Spring Cloud Config Server还支持带有占位符的搜索路径，用于<code class="literal">{application}</code>和<code class="literal">{profile}</code> （和<code class="literal">{label}</code> （如需要），如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          searchPaths</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{application}'</span></pre><p>上面的清单导致在存储库中搜索与目录（以及顶层）同名的文件。通配符在带有占位符的搜索路径中也有效（搜索中包括任何匹配的目录）。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_force_pull_in_git_repositories" href="#_force_pull_in_git_repositories"></a>强制拉入Git存储库</h4></div></div></div><p>如前所述，Spring Cloud Config Server会克隆远程git存储库，以防本地副本变脏（例如，操作系统进程更改了文件夹内容），从而使Spring Cloud Config Server无法从远程存储库更新本地副本。</p><p>为了解决这个问题，有一个<code class="literal">force-pull</code>如果本地副本是脏的，使得Spring Cloud Config Server强制从远程存储库中拉出属性，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          force-pull</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><p>如果您有多个存储库配置，则可以配置<code class="literal">force-pull</code>每个存储库的属性，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://git/common/config-repo.git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          force-pull</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          repos</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            team-a</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                pattern</span>: team-a-*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                uri</span>: https://git/team-a/config-repo.git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                force-pull</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            team-b</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                pattern</span>: team-b-*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                uri</span>: https://git/team-b/config-repo.git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                force-pull</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            team-c</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                pattern</span>: team-c-*
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                uri</span>: https://git/team-a/config-repo.git</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的默认值<code class="literal">force-pull</code>财产是<code class="literal">false</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_deleting_untracked_branches_in_git_repositories" href="#_deleting_untracked_branches_in_git_repositories"></a>删除Git存储库中未跟踪的分支</h4></div></div></div><p>由于Spring Cloud Config Server在将分支检出到本地存储库（例如，通过标签获取属性）后具有远程git存储库的克隆，因此它将永久保留该分支，直到下一个服务器重启（这将创建新的本地存储库）。因此，有可能删除远程分支，但仍可获取其本地副本。如果Spring Cloud Config Server客户端服务以<code class="literal">--spring.cloud.config.label=deletedRemoteBranch,master</code>它将从中获取属性<code class="literal">deletedRemoteBranch</code>本地分支机构，但不是来自<code class="literal">master</code> 。</p><p>为了使本地存储库分支保持整洁并保持远程状态- <code class="literal">deleteUntrackedBranches</code>可以设置属性。它将使Spring Cloud Config Server <span class="strong"><strong>强制</strong></span>从本地存储库中删除未跟踪的分支。例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          deleteUntrackedBranches</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的默认值<code class="literal">deleteUntrackedBranches</code>财产是<code class="literal">false</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_git_refresh_rate" href="#_git_refresh_rate"></a> Git刷新率</h4></div></div></div><p>您可以使用以下方法控制配置服务器从Git后端获取更新的配置数据的频率： <code class="literal">spring.cloud.config.server.git.refreshRate</code> 。以秒为单位指定此属性的值。默认情况下，该值为0，这意味着配置服务器将在每次请求时从Git存储库中获取更新的配置。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_version_control_backend_filesystem_use" href="#_version_control_backend_filesystem_use"></a> 5.1.2版本控制后端文件系统使用</h3></div></div></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>使用基于VCS的后端（git，svn），文件被检出或克隆到本地文件系统。默认情况下，它们被放置在系统临时目录中，前缀为<code class="literal">config-repo-</code> 。例如，在Linux上，它可能是<code class="literal">/tmp/config-repo-<randomid></code> 。一些操作系统<a class="link" href="https://serverfault.com/questions/377348/when-does-tmp-get-cleared/377349#377349" target="_top">通常会清除</a>临时目录。这可能导致意外的行为，例如缺少属性。为避免此问题，请通过设置更改Config Server使用的目录<code class="literal">spring.cloud.config.server.git.basedir</code>要么<code class="literal">spring.cloud.config.server.svn.basedir</code>到不在系统临时结构中的目录。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_file_system_backend" href="#_file_system_backend"></a> 5.1.3文件系统后端</h3></div></div></div><p>Config Server中还有一个<span class="quote">“ <span class="quote">本机</span> ”</span>配置文件，该配置文件不使用Git，而是从本地类路径或文件系统（您要指向的任何静态URL）加载配置文件。 <code class="literal">spring.cloud.config.server.native.searchLocations</code> ）。要使用本机配置文件，请使用以下命令启动配置服务器： <code class="literal">spring.profiles.active=native</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>请记住使用<code class="literal">file:</code>文件资源的前缀（不带前缀的默认值通常是类路径）。与任何Spring Boot配置一样，您可以嵌入<code class="literal">${}</code>风格的环境占位符，但请记住，Windows中的绝对路径需要额外的空间<code class="literal">/</code> （例如， <code class="literal"><a class="link" href="file:///${user.home}/config-repo" target="_top">file:///${user.home}/config-repo</a></code> ）。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>的默认值<code class="literal">searchLocations</code>与本地Spring Boot应用程序相同（即， <code class="literal">[classpath:/, classpath:/config, file:./, file:./config]</code> ）。这不会暴露<code class="literal">application.properties</code>从服务器到所有客户端，因为服务器中存在的所有属性源在发送给客户端之前都已删除。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>文件系统后端非常适合快速入门和测试。要在生产环境中使用它，您需要确保文件系统可靠并且可以在Config Server的所有实例之间共享。</p></td></tr></tbody></table></div><p>搜索位置可以包含占位符<code class="literal">{application}</code> ， <code class="literal">{profile}</code>和<code class="literal">{label}</code> 。这样，您可以隔离路径中的目录，然后选择一种对您有意义的策略（例如，每个应用程序的子目录或每个配置文件的子目录）。</p><p>如果您不在搜索位置中使用占位符，则此存储库还会附加<code class="literal">{label}</code> HTTP资源的参数作为搜索路径上的后缀，因此将从每个搜索位置<span class="strong"><strong>和</strong></span>与标签名称相同的子目录加载属性文件（在Spring Environment中，标记的属性优先）。因此，没有占位符的默认行为与添加以结尾的搜索位置相同<code class="literal">/{label}/</code> 。例如， <code class="literal">file:/tmp/config</code>是相同的<code class="literal">file:/tmp/config,file:/tmp/config/{label}</code> 。可以通过设置禁用此行为<code class="literal">spring.cloud.config.server.native.addLabelLocations=false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="vault-backend" href="#vault-backend"></a> 5.1.4保管库后端</h3></div></div></div><p>Spring Cloud Config Server还支持将<a class="link" href="https://www.vaultproject.io" target="_top">Vault</a>作为后端。</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><b></b></p></div></div></div><p> Vault 是用于安全访问机密的工具。秘密是您要严格控制访问权限的任何内容，例如API密钥，密码，证书和其他敏感信息。保管箱提供了对任何机密信息的统一界面，同时提供了严格的访问控制并记录了详细的审核日志。</p></div><p>有关Vault的更多信息，请参阅<a class="link" href="https://learn.hashicorp.com/vault/?track=getting-started#getting-started" target="_top">Vault快速入门指南</a> 。</p><p>要使配置服务器能够使用Vault后端，您可以通过以下方式运行配置服务器： <code class="literal">vault</code>轮廓。例如，在您的配置服务器的<code class="literal">application.properties</code> ， 你可以加<code class="literal">spring.profiles.active=vault</code> 。</p><p>默认情况下，配置服务器假定您的Vault服务器运行在<code class="literal"><a class="link" href="http://127.0.0.1:8200" target="_top">http://127.0.0.1:8200</a></code> 。它还假定后端的名称是<code class="literal">secret</code>关键是<code class="literal">application</code> 。所有这些默认值都可以在配置服务器的<code class="literal">application.properties</code> 。下表描述了可配置的保管库属性：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid;border-left:1px solid;border-right:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">名称</th><th align="left" valign="top" style="border-bottom:1px solid">默认值</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>主办</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>127.0.0.1</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>港口</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>8200</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>方案</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>http</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>后端</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>秘密</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>defaultKey</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>profileSeparator</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>，</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>kv版本</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>1个</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>skipSslValidation</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>假</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>超时</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>5</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>命名空间</p></td><td align="left" valign="top"><p>空值</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>上表中的所有属性都必须带有前缀<code class="literal">spring.cloud.config.server.vault</code>或放置在组合配置的正确“ Vault ”部分中。</p></td></tr></tbody></table></div><p>可以在以下位置找到所有可配置的属性<code class="literal">org.springframework.cloud.config.server.environment.VaultEnvironmentProperties</code> 。</p><p>Vault 0.10.0引入了版本化的键值后端（k / v后端版本2），该后端公开的API与早期版本不同，因此现在需要<code class="literal">data/</code>在安装路径和实际上下文路径之间，并将秘密包装在<code class="literal">data</code>宾语。设置<code class="literal">kvVersion=2</code>将考虑到这一点。</p><p>（可选）对Vault Enterprise的支持<code class="literal">X-Vault-Namespace</code>标头。要将其发送到 Vault ，请设置<code class="literal">namespace</code>属性。</p><p>在配置服务器运行的情况下，您可以向服务器发出HTTP请求，以从Vault后端检索值。为此，您需要Vault服务器的令牌。</p><p>首先，将一些数据放入Vault中，如以下示例所示：</p><pre class="programlisting">$ vault kv put secret/application foo=bar baz=bam
$ vault kv put secret/myapp foo=myappsbar</pre><p>其次，向配置服务器发出HTTP请求以检索值，如以下示例所示：</p><p><code class="literal">$ curl -X "GET" "http://localhost:8888/myapp/default" -H "X-Config-Token: yourtoken"</code></p><p>您应该看到类似于以下内容的响应：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myapp"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"profiles"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"default"</span>
   ]<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"label"</span>:null<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"version"</span>:null<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"state"</span>:null<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"propertySources"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"vault:myapp"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"source"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myappsbar"</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"vault:application"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"source"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"baz"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bam"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_multiple_properties_sources" href="#_multiple_properties_sources"></a>多个属性来源</h4></div></div></div><p>使用Vault时，可以为您的应用程序提供多个属性源。例如，假设您已将数据写入Vault中的以下路径：</p><pre class="programlisting">secret/myApp,dev
secret/myApp
secret/application,dev
secret/application</pre><p>写入的属性<code class="literal">secret/application</code>可用于<a class="link" href="#">使用Config Server的所有应用程序</a> 。名称为“ <code class="literal">myApp</code> ，会将任何属性写入<code class="literal">secret/myApp</code>和<code class="literal">secret/application</code>可用。什么时候<code class="literal">myApp</code>有<code class="literal">dev</code>启用配置文件后，将可以使用写入上述所有路径的属性，列表中第一个路径中的属性优先于其他属性。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_accessing_backends_through_a_proxy" href="#_accessing_backends_through_a_proxy"></a> 5.1.5通过代理访问后端</h3></div></div></div><p>配置服务器可以通过HTTP或HTTPS代理访问Git或Vault后端。对于Git或 Vault ，此行为通过以下设置进行控制<code class="literal">proxy.http</code>和<code class="literal">proxy.https</code> 。这些设置是针对每个存储库的，因此，如果您使用<a class="link" href="#composite-environment-repositories" title="5.1.9复合环境存储库">组合环境存储库</a> ，则必须分别为组合中的每个后端配置代理设置。如果使用的网络需要HTTP和HTTPS URL分别使用代理服务器，则可以为单个后端配置HTTP和HTTPS代理设置。</p><p>下表描述了HTTP和HTTPS代理的代理配置属性。所有这些属性必须以开头<code class="literal">proxy.http</code>要么<code class="literal">proxy.https</code> 。</p><div class="table"><a name="d0e2536" href="#d0e2536"></a><p class="title"><b>表5.2。代理配置属性</b></p><div class="table-contents"><table class="table" summary="Proxy Configuration Properties" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid;border-left:1px solid;border-right:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">物业名称</th><th align="left" valign="top" style="border-bottom:1px solid">备注</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>主办</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>代理的主机。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>港口</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于访问代理的端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>nonProxyHosts</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置服务器应在代理外部访问的所有主机。如果同时提供两个值<code class="literal">proxy.http.nonProxyHosts</code>和<code class="literal">proxy.https.nonProxyHosts</code> ， <code class="literal">proxy.http</code>值将被使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>用户名</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用来验证代理的用户名。如果同时提供两个值<code class="literal">proxy.http.username</code>和<code class="literal">proxy.https.username</code> ， <code class="literal">proxy.http</code>值将被使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><span class="strong"><strong>密码</strong></span></p></td><td align="left" valign="top"><p>用来验证代理的密码。如果同时提供两个值<code class="literal">proxy.http.password</code>和<code class="literal">proxy.https.password</code> ， <code class="literal">proxy.http</code>值将被使用。</p></td></tr></tbody></table></div></div><br class="table-break"><p>以下配置使用HTTPS代理访问Git存储库。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: https://github.com/spring-cloud-samples/config-repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          proxy</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            https</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              host</span>: my-proxy.host.io
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              password</span>: myproxypassword
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              port</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'3128'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              username</span>: myproxyusername
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              nonProxyHosts</span>: example.com</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_sharing_configuration_with_all_applications" href="#_sharing_configuration_with_all_applications"></a> 5.1.6与所有应用程序共享配置</h3></div></div></div><p>所有应用程序之间的共享配置根据您采用的方法而异，如以下主题所述：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-config-server-file-based-repositories" title="基于文件的存储库">称为“基于文件的存储库”的部分</a></li><li class="listitem"><a class="xref" href="#spring-cloud-config-server-vault-server" title="保管箱服务器">“保管库服务器”部分</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-config-server-file-based-repositories" href="#spring-cloud-config-server-file-based-repositories"></a>基于文件的存储库</h4></div></div></div><p>对于基于文件（git，svn和本机）的存储库，具有文件名的资源位于<code class="literal">application*</code> （ <code class="literal">application.properties</code> ， <code class="literal">application.yml</code> ， <code class="literal">application-*.properties</code> ，等等）在所有客户端应用程序之间共享。您可以使用具有这些文件名的资源来配置全局默认值，并在必要时使它们被应用程序特定的文件覆盖。</p><p>#_property_overrides [属性覆盖]功能也可以用于设置全局默认值，允许使用占位符应用程序在本地覆盖它们。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>使用<span class="quote">“ <span class="quote">本机</span> ”</span>配置文件（本地文件系统后端），您应该使用不属于服务器自身配置的显式搜索位置。否则， <code class="literal">application*</code>默认搜索位置中的资源被删除，因为它们是服务器的一部分。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-config-server-vault-server" href="#spring-cloud-config-server-vault-server"></a>保管箱服务器</h4></div></div></div><p>使用Vault作为后端时，您可以通过将配置放在以下位置来与所有应用程序共享配置<code class="literal">secret/application</code> 。例如，如果运行以下Vault命令，则使用配置服务器的所有应用程序都将具有以下属性： <code class="literal">foo</code>和<code class="literal">baz</code>可供他们使用：</p><pre class="programlisting">$ vault write secret/application foo=bar baz=bam</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_jdbc_backend" href="#_jdbc_backend"></a> 5.1.7 JDBC后端</h3></div></div></div><p>Spring Cloud Config Server支持JDBC（关系数据库）作为配置属性的后端。您可以通过添加启用此功能<code class="literal">spring-jdbc</code>到类路径并使用<code class="literal">jdbc</code>概要文件或通过添加类型的Bean <code class="literal">JdbcEnvironmentRepository</code> 。如果您在类路径上包含正确的依赖项（有关更多详细信息，请参见用户指南），Spring Boot会配置数据源。</p><p>数据库需要有一个名为<code class="literal">PROPERTIES</code>与列称为<code class="literal">APPLICATION</code> ， <code class="literal">PROFILE</code>和<code class="literal">LABEL</code> （与通常<code class="literal">Environment</code>含义），再加上<code class="literal">KEY</code>和<code class="literal">VALUE</code>对于键和值对<code class="literal">Properties</code>样式。Java中所有字段的类型均为String，因此您可以将它们设置为<code class="literal">VARCHAR</code>无论您需要什么长度。属性值的行为与如果它们来自名为Spring Boot的属性文件的行为相同<code class="literal">{application}-{profile}.properties</code> ，包括所有加密和解密，将作为后处理步骤应用（也就是说，不会直接在存储库实现中使用）。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_credhub_backend" href="#_credhub_backend"></a> 5.1.8 CredHub后端</h3></div></div></div><p>春天的云配置服务器支持<a class="link" href="https://docs.cloudfoundry.org/credhub" target="_top">CredHub</a>作为配置属性后端。您可以通过向<a class="link" href="https://spring.io/projects/spring-credhub" target="_top">Spring CredHub</a>添加依赖项来启用此功能。</p><p><b>pom.xml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.credhub<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-credhub-starter<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre><p>
</p><p>以下配置使用双向TLS访问CredHub：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: credhub
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        credhub</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          url</span>: https://credhub:<span class="hl-number">8844</span></pre><p>这些属性应存储为JSON，例如：</p><pre class="programlisting">credhub set --name "/demo-app/default/master/toggles" --type=json
value: {"toggle.button": "blue", "toggle.link": "red"}</pre><pre class="programlisting">credhub set --name "/demo-app/default/master/abs" --type=json
value: {"marketing.enabled": true, "external.enabled": false}</pre><p>所有客户端应用程序的名称<code class="literal">spring.cloud.config.name=demo-app</code>将具有以下可用属性：</p><pre class="screen">{
    toggle.button: "blue",
    toggle.link: "red",
    marketing.enabled: true,
    external.enabled: false
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>未指定配置文件时<code class="literal">default</code>当未指定标签时将使用<code class="literal">master</code>将用作默认值。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_oauth_2_0" href="#_oauth_2_0"></a> OAuth 2.0</h4></div></div></div><p>您可以验证<a class="link" href="https://oauth.net/2/" target="_top">的OAuth 2.0</a>使用<a class="link" href="https://docs.cloudfoundry.org/concepts/architecture/uaa.html" target="_top">UAA</a>作为一个供应商。</p><p><b>pom.xml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.security<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-security-config<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.security<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-security-oauth2-client<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre><p>
</p><p>以下配置使用OAuth 2.0和UAA访问CredHub：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: credhub
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        credhub</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          url</span>: https://credhub:<span class="hl-number">8844</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          oauth2</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            registration-id</span>: credhub-client
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  security</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    oauth2</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        registration</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          credhub-client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            provider</span>: uaa
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            client-id</span>: credhub_config_server
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            client-secret</span>: asecret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            authorization-grant-type</span>: client_credentials
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        provider</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uaa</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            token-uri</span>: https://uaa:<span class="hl-number">8443</span>/oauth/token</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>使用的UAA客户ID应该具有<code class="literal">credhub.read</code>作为范围。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="composite-environment-repositories" href="#composite-environment-repositories"></a> 5.1.9复合环境存储库</h3></div></div></div><p>在某些情况下，您可能希望从多个环境存储库中提取配置数据。为此，您可以启用<code class="literal">composite</code>配置服务器的应用程序属性或YAML文件中的配置文件。例如，如果要从Subversion存储库以及两个Git存储库中提取配置数据，则可以为配置服务器设置以下属性：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: composite
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        composite</span>:
        -
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          type</span>: svn
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: file:///path/to/svn/repo
        -
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          type</span>: git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: file:///path/to/rex/git/repo
        -
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          type</span>: git
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: file:///path/to/walter/git/repo</pre><p>使用此配置，优先级由存储库在“存储库”下列出的顺序确定。 <code class="literal">composite</code>键。在上面的示例中，首先列出了Subversion存储库，因此在Subversion存储库中找到的值将覆盖在其中一个Git存储库中为同一属性找到的值。在中找到的值<code class="literal">rex</code>在使用Git存储库之前，会在其中找到相同属性的值<code class="literal">walter</code> Git存储库。</p><p>如果您只想从各自不同类型的存储库中提取配置数据，则可以启用相应的配置文件，而不是启用<code class="literal">composite</code>配置文件，在配置服务器的应用程序属性或YAML文件中。例如，如果要从单个Git存储库和单个HashiCorp Vault服务器提取配置数据，则可以为配置服务器设置以下属性：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: git<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> vault
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        git</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          uri</span>: file:///path/to/git/repo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          order</span>: <span class="hl-number">2</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          host</span>: <span class="hl-number">127.0</span>.<span class="hl-number">0.1</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          port</span>: <span class="hl-number">8200</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          order</span>: <span class="hl-number">1</span></pre><p>使用此配置，优先级可以由<code class="literal">order</code>属性。您可以使用<code class="literal">order</code>属性，用于指定所有存储库的优先级顺序。数值越低<code class="literal">order</code>属性，它具有更高的优先级。存储库的优先级顺序有助于解决包含相同属性值的存储库之间的任何潜在冲突。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您的复合环境包括上一个示例中的Vault服务器，则必须在对配置服务器的每个请求中都包含Vault令牌。请参阅<a class="link" href="#vault-backend" title="5.1.4保管库后端">保管库后端</a> 。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>从环境存储库中检索值时，任何类型的故障都会导致整个组合环境的故障。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>使用复合环境时，所有存储库都包含相同的标签很重要。如果您的环境与上述示例中的环境类似，并且您要求使用<code class="literal">master</code>标签，但Subversion存储库不包含名为<code class="literal">master</code> ，整个请求失败。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_custom_composite_environment_repositories" href="#_custom_composite_environment_repositories"></a>定制复合环境存储库</h4></div></div></div><p>除了使用Spring Cloud中的一个环境存储库之外，您还可以提供自己的<code class="literal">EnvironmentRepository</code> bean被包含在复合环境中。为此，您的bean必须实现<code class="literal">EnvironmentRepository</code>接口。如果您想控制自定义的优先级<code class="literal">EnvironmentRepository</code>在复合环境中，您还应该实现<code class="literal">Ordered</code>接口并覆盖<code class="literal">getOrdered</code>方法。如果您不执行<code class="literal">Ordered</code>界面，您的<code class="literal">EnvironmentRepository</code>被赋予最低优先级。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_property_overrides" href="#_property_overrides"></a> 5.1.10属性替代</h3></div></div></div><p>Config Server具有<span class="quote">“ <span class="quote">替代</span> ”</span>功能，使操作员可以为所有应用程序提供配置属性。应用程序使用常规的Spring Boot钩子不会意外更改重写的属性。要声明覆盖，请向其中添加名称/值对映射<code class="literal">spring.cloud.config.server.overrides</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        overrides</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          foo</span>: bar</pre><p>前面的示例使所有作为配置客户端的应用程序读取<code class="literal">foo=bar</code> ，独立于自己的配置。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>配置系统不能强制应用程序以任何特定方式使用配置数据。因此，覆盖无法执行。但是，它们确实为Spring Cloud Config客户端提供了有用的默认行为。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>通常，Spring环境占位符带有<code class="literal">${}</code>可以使用反斜杠（ <code class="literal">\</code> ）逃脱<code class="literal">$</code>或者<code class="literal">{</code> 。例如， <code class="literal">\${app.foo:bar}</code>决心<code class="literal">bar</code> ，除非应用提供自己的<code class="literal">app.foo</code> 。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在YAML中，您不需要转义反斜杠本身。但是，在属性文件中，在服务器上配置替代时，确实需要转义反斜杠。</p></td></tr></tbody></table></div><p>您可以将客户端中所有替代的优先级更改为更像默认值，通过设置<code class="literal">spring.cloud.config.overrideNone=true</code>远程存储库中的标志（默认为false）。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_health_indicator_2" href="#_health_indicator_2"></a> 5.2健康指标</h2></div></div></div><p>Config Server带有运行状况指示器，用于检查是否已配置<code class="literal">EnvironmentRepository</code>工作中。默认情况下，它会询问<code class="literal">EnvironmentRepository</code>对于名为<code class="literal">app</code> ， <code class="literal">default</code>配置文件，以及<code class="literal">EnvironmentRepository</code>实施。</p><p>您可以配置运行状况指示器以检查更多应用程序以及自定义配置文件和自定义标签，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        health</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          repositories</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            myservice</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              label</span>: mylabel
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            myservice-dev</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              name</span>: myservice
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              profiles</span>: development</pre><p>您可以通过设置禁用健康状况指示器<code class="literal">spring.cloud.config.server.health.enabled=false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_security" href="#_security"></a> 5.3安全性</h2></div></div></div><p>您可以使用对您有意义的任何方式来保护Config Server（从物理网络安全到OAuth2承载令牌），因为Spring Security和Spring Boot提供了对许多安全性安排的支持。</p><p>要使用默认的Spring Boot配置的HTTP Basic安全性，请在类路径中包含Spring Security（例如，通过<code class="literal">spring-boot-starter-security</code> ）。默认用户名是<code class="literal">user</code>以及随机生成的密码。随机密码实际上没有用，因此我们建议您配置密码（通过设置<code class="literal">spring.security.user.password</code> ）并对其进行加密（有关如何操作的说明，请参见下文）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_encryption_and_decryption_2" href="#_encryption_and_decryption_2"></a> 5.4加密和解密</h2></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>要使用加密和解密功能，您需要在JVM中安装完整功能的JCE（默认情况下不包括）。您可以从Oracle下载<span class="quote">“ <span class="quote">Java密码学扩展（JCE）无限强度管辖权策略文件</span> ”</span> ，并按照安装说明进行操作（本质上，您需要用下载的JRE lib / security目录替换这两个策略文件）。</p></td></tr></tbody></table></div><p>如果远程属性源包含加密的内容（值以<code class="literal">{cipher}</code> ），则将其解密，然后再通过HTTP发送给客户端。此设置的主要优点是，当属性值处于<span class="quote">“ <span class="quote">静止</span> ”状态时</span> （例如，在git存储库中），不需要使用纯文本格式。如果无法解密某个值，则将其从属性源中删除，并使用相同的密钥添加一个附加属性，但前缀为<code class="literal">invalid</code>和一个表示<span class="quote">“ <span class="quote">不适用</span> ”</span>的值（通常<code class="literal"><n/a></code> ）。这很大程度上是为了防止密文用作密码和意外泄漏。</p><p>如果您为配置客户端应用程序设置了远程配置存储库，则它可能包含一个<code class="literal">application.yml</code>类似于以下内容：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  datasource</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    username</span>: dbuser
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    password</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'</span></pre><p>
</p><p>.properties文件中的加密值不能用引号引起来。否则，该值不会解密。以下示例显示了有效的值：</p><p><b>application.properties。</b>
</p><pre class="screen">spring.datasource.username: dbuser
spring.datasource.password: {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ</pre><p>
</p><p>您可以安全地将此纯文本推送到共享的git存储库，并且秘密密码仍然受到保护。</p><p>服务器还公开<code class="literal">/encrypt</code>和<code class="literal">/decrypt</code>端点（假设它们是安全的，并且只能由授权代理访问）。如果您编辑远程配置文件，则可以使用Config Server通过POST到<code class="literal">/encrypt</code>端点，如以下示例所示：</p><pre class="screen">$ curl localhost:8888/encrypt -d mysecret
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您加密的值中包含需要URL编码的字符，则应使用<code class="literal">--data-urlencode</code>选择<code class="literal">curl</code>确保它们编码正确。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>确保不要在加密值中包含任何curl命令统计信息。将值输出到文件可以帮助避免此问题。</p></td></tr></tbody></table></div><p>逆运算也可以通过<code class="literal">/decrypt</code> （前提是服务器配置了对称密钥或完整密钥对），如以下示例所示：</p><pre class="screen">$ curl localhost:8888/decrypt -d 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果您进行卷曲测试，请使用<code class="literal">--data-urlencode</code> （代替<code class="literal">-d</code> ）或设置一个明确的<code class="literal">Content-Type: text/plain</code>以确保curl在存在特殊字符时正确编码数据（“ +”特别棘手）。</p></td></tr></tbody></table></div><p>取加密值并添加<code class="literal">{cipher}</code>前缀，然后再将其放入YAML或属性文件中，然后再提交并推送到远程（可能不安全）存储中。</p><p>的<code class="literal">/encrypt</code>和<code class="literal">/decrypt</code>端点也都接受以下形式的路径<code class="literal">/*/{application}/{profiles}</code> ，当客户端调用主环境资源时，可用于基于每个应用程序（名称）和每个配置文件控制密码。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>要以这种精细的方式控制密码，您还必须提供一个<code class="literal">@Bean</code>类型的<code class="literal">TextEncryptorLocator</code>会根据名称和配置文件创建不同的加密器。默认情况下不提供（所有加密使用相同的密钥）。</p></td></tr></tbody></table></div><p>的<code class="literal">spring</code>命令行客户端（安装了Spring Cloud CLI扩展）也可以用于加密和解密，如以下示例所示：</p><pre class="screen">$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre><p>要使用文件中的密钥（例如用于加密的RSA公钥），请在密钥值前添加“ @”并提供文件路径，如以下示例所示：</p><pre class="screen">$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">--key</code>参数是强制性的（尽管有一个<code class="literal">--</code>字首）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_key_management" href="#_key_management"></a> 5.5密钥管理</h2></div></div></div><p>Config Server可以使用对称（共享）密钥或非对称密钥（RSA密钥对）。非对称选择在安全性方面是优越的，但是使用对称密钥通常更方便，因为它是在服务器中配置的单个属性值。 <code class="literal">bootstrap.properties</code> 。</p><p>要配置对称密钥，您需要设置<code class="literal">encrypt.key</code>到一个秘密的字符串（或使用<code class="literal">ENCRYPT_KEY</code>环境变量，以使其脱离纯文本配置文件）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您不能使用以下命令配置非对称密钥<code class="literal">encrypt.key</code> 。</p></td></tr></tbody></table></div><p>要配置非对称密钥，请使用密钥库（例如，由密钥库创建的密钥库）。 <code class="literal">keytool</code> JDK附带的实用程序）。密钥库属性是<code class="literal">encrypt.keyStore.*</code>与<code class="literal">*</code>等于</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid;border-left:1px solid;border-right:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="center" valign="top" style="border-right:1px solid;border-bottom:1px solid">属性</th><th align="center" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">encrypt.keyStore.location</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>包含一个<code class="literal">Resource</code>地点</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">encrypt.keyStore.password</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>持有用于解锁密钥库的密码</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">encrypt.keyStore.alias</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标识商店中要使用的密钥</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">encrypt.keyStore.type</code></p></td><td align="left" valign="top"><p>要创建的KeyStore的类型。默认为<code class="literal">jks</code> 。</p></td></tr></tbody></table></div><p>加密是使用公钥完成的，解密需要私钥。因此，原则上，如果您只想加密（并准备使用私钥在本地解密值），则只能在服务器中配置公钥。实际上，您可能不希望在本地进行解密，因为它会将密钥管理过程分布在所有客户端上，而不是将其集中在服务器上。另一方面，如果您的配置服务器相对不安全并且只有少数客户端需要加密的属性，那么它可能是一个有用的选项。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_creating_a_key_store_for_testing" href="#_creating_a_key_store_for_testing"></a> 5.6创建密钥库进行测试</h2></div></div></div><p>要创建用于测试的密钥库，可以使用类似于以下内容的命令：</p><pre class="screen">$ keytool -genkeypair -alias mytestkey -keyalg RSA \
  -dname "CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US" \
  -keypass changeme -keystore server.jks -storepass letmein</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>使用JDK 11或更高版本时，使用上述命令时可能会收到以下警告。在这种情况下，您可能要确保<code class="literal">keypass</code>和<code class="literal">storepass</code>值匹配。</p></td></tr></tbody></table></div><pre class="screen">Warning:  Different store and key passwords not supported for PKCS12 KeyStores. Ignoring user-specified -keypass value.</pre><p>放在<code class="literal">server.jks</code>文件放在类路径中（例如），然后在<code class="literal">bootstrap.yml</code> ，对于Config Server，请创建以下设置：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">encrypt</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  keyStore</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    location</span>: classpath:/server.jks
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    password</span>: letmein
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    alias</span>: mytestkey
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    secret</span>: changeme</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_multiple_keys_and_key_rotation" href="#_using_multiple_keys_and_key_rotation"></a> 5.7使用多个键和键旋转</h2></div></div></div><p>除了<code class="literal">{cipher}</code>加密属性值中的前缀，则Config Server查找零个或多个<code class="literal">{name:value}</code> （Base64编码）密文开始之前的前缀。密钥被传递给<code class="literal">TextEncryptorLocator</code> ，它可以执行定位一个<code class="literal">TextEncryptor</code>密码。如果已配置密钥库（ <code class="literal">encrypt.keystore.location</code> ），默认定位器会查找具有由<code class="literal">key</code>前缀，类似如下的密文：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">foo</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  bar</span>: `{cipher}{key:testkey}...`</pre><p>定位器查找名为“ testkey”的密钥。也可以使用<code class="literal">{secret:…​}</code>前缀中的值。但是，如果未提供，则默认为使用密钥库密码（这是在构建密钥库且未指定密钥时得到的密码）。如果您确实提供了机密，则还应该使用自定义加密机密<code class="literal">SecretLocator</code> 。</p><p>当密钥仅用于加密几个字节的配置数据时（也就是说，它们未在其他地方使用），从密码的角度讲，几乎不需要旋转密钥。但是，您有时可能需要更改密钥（例如，在发生安全漏洞时）。在这种情况下，所有客户端都需要更改其源配置文件（例如，在git中）并使用新的<code class="literal">{key:…​}</code>所有密码的前缀。请注意，客户端需要首先检查Config Server密钥库中的密钥别名是否可用。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果要让Config Server处理所有加密和解密，则<code class="literal">{name:value}</code>前缀也可以以纯文本形式添加到<code class="literal">/encrypt</code>端点。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_serving_encrypted_properties" href="#_serving_encrypted_properties"></a> 5.8提供加密的属性</h2></div></div></div><p>有时，您希望客户端在本地解密配置，而不是在服务器中进行解密。在这种情况下，如果您提供<code class="literal">encrypt.*</code>配置以找到密钥，您仍然可以<code class="literal">/encrypt</code>和<code class="literal">/decrypt</code>端点，但是您需要通过放置来显式关闭对传出属性的解密<code class="literal">spring.cloud.config.server.encrypt.enabled=false</code>在<code class="literal">bootstrap.[yml|properties]</code> 。如果您不关心端点，则在不配置键或启用标志的情况下都可以使用。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_serving_alternative_formats" href="#_serving_alternative_formats"></a> 6。提供替代格式</h2></div></div></div><p>来自环境端点的默认JSON格式非常适合Spring应用程序使用，因为它直接映射到<code class="literal">Environment</code>抽象。如果愿意，可以通过在资源路径中添加后缀（“ .yml”，“。yaml”或“ .properties”）来使用与YAML或Java属性相同的数据。对于不关心JSON终结点的结构或它们提供的额外元数据的应用程序来说，这可能很有用（例如，不使用Spring的应用程序可能会受益于此方法的简单性）。</p><p>YAML和属性表示形式还有一个附加标志（作为布尔查询参数提供，称为<code class="literal">resolvePlaceholders</code> ），以在源文档中发出占位符的信号（在标准Spring中<code class="literal">${…​}</code>形式）应尽可能在输出之前解析。对于不了解Spring占位符约定的使用者来说，这是一个有用的功能。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>使用YAML或属性格式存在一些限制，主要是与元数据的丢失有关。例如，JSON被构造为属性源的有序列表，其名称与该源相关。即使值的来源有多个来源，YAML和属性形式也会合并到一个映射中，并且原始来源文件的名称也会丢失。同样，YAML表示也不一定是后备存储库中YAML源的忠实表示。它由一系列平面属性来源构成，并且必须对密钥的形式进行假设。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_serving_plain_text" href="#_serving_plain_text"></a> 7。提供纯文本</h2></div></div></div><p>而不是使用<code class="literal">Environment</code>抽象（或YAML或属性格式的另一种表示形式），您的应用程序可能需要针对其环境量身定制的通用纯文本配置文件。Config Server通过位于以下位置的附加终结点提供这些功能<code class="literal">/{application}/{profile}/{label}/{path}</code> ，在哪里<code class="literal">application</code> ， <code class="literal">profile</code>和<code class="literal">label</code>与常规环境端点具有相同的含义，但<code class="literal">path</code>是文件名的路径（例如<code class="literal">log.xml</code> ）。该端点的源文件与环境端点的定位方式相同。属性和YAML文件使用相同的搜索路径。但是，不是汇总所有匹配资源，而是仅返回要匹配的第一个资源。</p><p>找到资源后，使用常规格式的占位符（ <code class="literal">${…​}</code> ）通过使用有效解决<code class="literal">Environment</code>提供的应用程序名称，配置文件和标签。这样，资源端点与环境端点紧密集成在一起。考虑以下用于GIT或SVN存储库的示例：</p><pre class="screen">application.yml
nginx.conf</pre><p>哪里<code class="literal">nginx.conf</code>看起来像这样：</p><pre class="screen">server {
    listen              80;
    server_name         ${nginx.server.name};
}</pre><p>和<code class="literal">application.yml</code>像这样：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">nginx</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: example.com
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">---</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>: development
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">nginx</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: develop.com</pre><p>的<code class="literal">/foo/default/master/nginx.conf</code>资源可能如下：</p><pre class="screen">server {
    listen              80;
    server_name         example.com;
}</pre><p>和<code class="literal">/foo/development/master/nginx.conf</code>像这样：</p><pre class="screen">server {
    listen              80;
    server_name         develop.com;
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>与用于环境配置的源文件一样， <code class="literal">profile</code>用于解析文件名。因此，如果您要使用特定于配置文件的文件， <code class="literal">/*/development/*/logback.xml</code>可以通过名为<code class="literal">logback-development.xml</code> （优先于<code class="literal">logback.xml</code> ）。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您不想提供<code class="literal">label</code>并让服务器使用默认标签，您可以提供一个<code class="literal">useDefaultLabel</code>请求参数。因此，前面的示例<code class="literal">default</code>个人资料可能是<code class="literal">/foo/default/nginx.conf?useDefaultLabel</code> 。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_embedding_the_config_server" href="#_embedding_the_config_server"></a> 8。嵌入配置服务器</h2></div></div></div><p>Config Server最好作为独立应用程序运行。但是，如果需要，可以将其嵌入另一个应用程序。为此，请使用<code class="literal">@EnableConfigServer</code>注解。名为的可选属性<code class="literal">spring.cloud.config.server.bootstrap</code>在这种情况下很有用。它是一个标志，指示服务器是否应从其自己的远程存储库中进行配置。默认情况下，该标志为关闭状态，因为它会延迟启动。但是，当嵌入到另一个应用程序中时，以与其他任何应用程序相同的方式进行初始化是有意义的。设定时<code class="literal">spring.cloud.config.server.bootstrap</code>至<code class="literal">true</code>您还必须使用<a class="link" href="#composite-environment-repositories" title="5.1.9复合环境存储库">复合环境存储库配置</a> 。例如</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: configserver
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  profiles</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    active</span>: composite
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        composite</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          - type</span>: native
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            search-locations</span>: ${HOME}/Desktop/config
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        bootstrap</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果使用bootstrap标志，则配置服务器需要在以下位置配置其名称和存储库URI： <code class="literal">bootstrap.yml</code> 。</p></td></tr></tbody></table></div><p>要更改服务器端点的位置，可以（可选）设置<code class="literal">spring.cloud.config.server.prefix</code> （例如， <code class="literal">/config</code> ），以便在前缀下提供资源。前缀应以a开头但不能以a结尾<code class="literal">/</code> 。它适用于<code class="literal">@RequestMappings</code>在Config Server中（即Spring Boot的下面） <code class="literal">server.servletPath</code>和<code class="literal">server.contextPath</code>前缀）。</p><p>如果要直接从后端存储库（而不是从配置服务器）读取应用程序的配置，则基本上需要没有端点的嵌入式配置服务器。您可以不使用<code class="literal">@EnableConfigServer</code>注解（设置<code class="literal">spring.cloud.config.server.bootstrap=true</code> ）。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_push_notifications_and_spring_cloud_bus" href="#_push_notifications_and_spring_cloud_bus"></a> 9。推送通知和Spring Cloud Bus</h2></div></div></div><p>许多源代码存储库提供程序（例如Github，Gitlab，Gita，Gitee，Gogs或Bitbucket）都通过Webhook通知您存储库中的更改。您可以通过提供者的用户界面将Webhook配置为URL和感兴趣的一组事件。例如， <a class="link" href="https://developer.github.com/v3/activity/events/types/#pushevent" target="_top">Github</a>使用带有JSON主体（包含提交列表和标头（ <code class="literal">X-Github-Event</code> ） 调成<code class="literal">push</code> 。如果您添加对<code class="literal">spring-cloud-config-monitor</code>库并在配置服务器中激活Spring Cloud Bus，然后<code class="literal">/monitor</code>端点已启用。</p><p>Webhook激活后，配置服务器将发送<code class="literal">RefreshRemoteApplicationEvent</code>针对它认为可能已更改的应用程序。变化检测可以被策略化。但是，默认情况下，它会查找与应用程序名称匹配的文件中的更改（例如， <code class="literal">foo.properties</code>针对于<code class="literal">foo</code>申请，而<code class="literal">application.properties</code>针对所有应用程序）。要覆盖行为时要使用的策略是<code class="literal">PropertyPathNotificationExtractor</code> ，它接受请求标头和正文作为参数，并返回已更改文件路径的列表。</p><p>默认配置可以与Github，Gitlab，Gitea，Gitee，Gogs或Bitbucket一起使用。除了来自Github，Gitlab，Gitee或Bitbucket的JSON通知之外，您还可以通过以下方法触发更改通知： <code class="literal">/monitor</code>具有形式编码的主体参数<code class="literal">path={application}</code> 。这样做会广播到与<code class="literal">{application}</code>模式（可以包含通配符）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">RefreshRemoteApplicationEvent</code>仅在<code class="literal">spring-cloud-bus</code>已在Config Server和客户端应用程序中激活。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认配置还检测本地git存储库中的文件系统更改。在这种情况下，不使用Webhook。但是，一旦您编辑配置文件，就会广播刷新。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_config_client" href="#_spring_cloud_config_client"></a> 10。Spring Cloud Config客户端</h2></div></div></div><p>Spring Boot应用程序可以立即利用Spring Config Server（或应用程序开发人员提供的其他外部属性源）。它还选择了一些与<code class="literal">Environment</code>更改事件。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="config-first-bootstrap" href="#config-first-bootstrap"></a> 10.1配置第一个引导程序</h2></div></div></div><p>在类路径上具有Spring Cloud Config Client的任何应用程序的默认行为如下：当配置客户端启动时，它将绑定到Config Server（通过<code class="literal">spring.cloud.config.uri</code>引导程序配置属性）并初始化Spring <code class="literal">Environment</code>与远程资源来源。</p><p>此行为的最终结果是，所有要使用Config Server的客户端应用程序都需要一个<code class="literal">bootstrap.yml</code> （或环境变量），其中服务器地址设置为<code class="literal">spring.cloud.config.uri</code> （默认为“ http：// localhost：8888”）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="discovery-first-bootstrap" href="#discovery-first-bootstrap"></a> 10.2发现第一引导程序</h2></div></div></div><p>如果您使用<code class="literal">DiscoveryClient</code>实施，例如Spring Cloud Netflix和Eureka Service Discovery或Spring Cloud Consul，您可以让Config Server在Discovery Service中注册。但是，在默认的<span class="quote">“ <span class="quote">Config First</span> ”</span>模式下，客户端无法利用注册。</p><p>如果您喜欢使用<code class="literal">DiscoveryClient</code>要找到配置服务器，可以通过设置<code class="literal">spring.cloud.config.discovery.enabled=true</code> （默认为<code class="literal">false</code> ）。这样做的最终结果是，客户端应用程序都需要一个<code class="literal">bootstrap.yml</code> （或环境变量）以及适当的发现配置。例如，对于Spring Cloud Netflix，您需要定义Eureka服务器地址（例如，在<code class="literal">eureka.client.serviceUrl.defaultZone</code> ）。使用此选项的价格是启动时需要进行额外的网络往返，以查找服务注册。好处是，只要发现服务是固定点，配置服务器就可以更改其坐标。默认服务ID是<code class="literal">configserver</code> ，但是您可以通过设置在客户端上进行更改<code class="literal">spring.cloud.config.discovery.serviceId</code> （以及在服务器上，以通常用于服务的方式，例如通过设置<code class="literal">spring.application.name</code> ）。</p><p>发现客户端实现均支持某种元数据映射（例如， <code class="literal">eureka.instance.metadataMap</code>尤里卡）。Config Server的某些其他属性可能需要在其服务注册元数据中进行配置，以便客户端可以正确连接。如果Config Server受HTTP Basic保护，则可以将凭据配置为<code class="literal">user</code>和<code class="literal">password</code> 。另外，如果Config Server具有上下文路径，则可以设置<code class="literal">configPath</code> 。例如，以下YAML文件适用于作为Eureka客户端的Config Server：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">eureka</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  instance</span>:
    ...
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    metadataMap</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      user</span>: osufhalskjrtl
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      password</span>: lviuhlszvaorhvlo5847
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      configPath</span>: /config</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="config-client-fail-fast" href="#config-client-fail-fast"></a> 10.3配置客户端快速失败</h2></div></div></div><p>在某些情况下，如果服务无法连接到Config Server，您可能希望启动失败。如果这是所需的行为，请设置引导程序配置属性<code class="literal">spring.cloud.config.fail-fast=true</code>使客户端因异常而暂停。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="config-client-retry" href="#config-client-retry"></a> 10.4配置客户端重试</h2></div></div></div><p>如果您希望配置服务器在应用程序启动时偶尔会不可用，则可以使其在失败后继续尝试。首先，您需要设置<code class="literal">spring.cloud.config.fail-fast=true</code> 。然后，您需要添加<code class="literal">spring-retry</code>和<code class="literal">spring-boot-starter-aop</code>到你的classpath。默认行为是重试六次，初始回退间隔为1000ms，随后的回退的指数乘数为1.1。您可以通过设置以下属性来配置这些属性（和其他属性） <code class="literal">spring.cloud.config.retry.*</code>配置属性。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>要完全控制重试行为，请添加一个<code class="literal">@Bean</code>类型的<code class="literal">RetryOperationsInterceptor</code> ID为<code class="literal">configServerRetryInterceptor</code> 。Spring Retry有一个<code class="literal">RetryInterceptorBuilder</code>支持创建一个。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_locating_remote_configuration_resources" href="#_locating_remote_configuration_resources"></a> 10.5查找远程配置资源</h2></div></div></div><p>Config Service从以下位置提供属性源<code class="literal">/{application}/{profile}/{label}</code> ，其中客户端应用程序中的默认绑定如下：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">“名称” =<code class="literal">${spring.application.name}</code></li><li class="listitem">“个人资料” = <code class="literal">${spring.profiles.active}</code> （其实<code class="literal">Environment.getActiveProfiles()</code> ）</li><li class="listitem">“ label” =“主人”</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>设置属性时<code class="literal">${spring.application.name}</code>不要在您的应用名称前加上保留字<code class="literal">application-</code>以防止解决正确的属性源的问题。</p></td></tr></tbody></table></div><p>您可以通过设置覆盖所有这些<code class="literal">spring.cloud.config.*</code> （哪里<code class="literal">*</code>是<code class="literal">name</code> ， <code class="literal">profile</code>要么<code class="literal">label</code> ）。的<code class="literal">label</code>对于回滚到以前的配置版本很有用。使用默认的Config Server实现，它可以是git标签，分支名称或提交ID。标签也可以逗号分隔的列表形式提供。在这种情况下，列表中的项目将一一尝试直到成功为止。在要素分支上工作时，此行为可能很有用。例如，您可能想使配置标签与分支对齐，但使其成为可选（在这种情况下，请使用<code class="literal">spring.cloud.config.label=myfeature,develop</code> ）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_specifying_multiple_urls_for_the_config_server" href="#_specifying_multiple_urls_for_the_config_server"></a> 10.6为配置服务器指定多个地址</h2></div></div></div><p>为确保在部署了Config Server的多个实例并且不时会出现一个或多个实例不可用时确保高可用性，可以指定多个URL（作为逗号分隔的列表，位于<code class="literal">spring.cloud.config.uri</code>属性），或让您的所有实例在Eureka之类的服务注册表中注册（如果使用Discovery-First Bootstrap模式）。请注意，只有在未运行Config Server时（即，应用程序退出时）或发生连接超时时，这样做才能确保高可用性。例如，如果Config Server返回500（内部服务器错误）响应，或者Config Client从Config Server收到401（由于凭据错误或其他原因），则Config Client不会尝试从其他URL获取属性。此类错误表示用户问题，而不是可用性问题。</p><p>如果您在Config Server上使用HTTP基本安全性，则仅当您将凭据嵌入到您在Config Server下指定的每个URL中时，当前才有可能支持per-Config Server身份验证凭据。 <code class="literal">spring.cloud.config.uri</code>属性。如果使用任何其他类型的安全性机制，则（当前）不能支持每台配置服务器的身份验证和授权。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuring_timeouts" href="#_configuring_timeouts"></a> 10.7配置超时</h2></div></div></div><p>如果要配置超时阈值：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">可以使用属性配置读取超时<code class="literal">spring.cloud.config.request-read-timeout</code> 。</li><li class="listitem">可以使用属性配置连接超时<code class="literal">spring.cloud.config.request-connect-timeout</code> 。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_security_2" href="#_security_2"></a> 10.8安全性</h2></div></div></div><p>如果在服务器上使用HTTP基本安全性，则客户端需要知道密码（如果不是默认用户名，则需要用户名）。您可以通过配置服务器URI或通过单独的用户名和密码属性来指定用户名和密码，如以下示例所示：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">     uri</span>: https://user:secret@myconfig.mycompany.com</pre><p>
</p><p>以下示例显示了传递相同信息的另一种方法：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">     uri</span>: https://myconfig.mycompany.com
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">     username</span>: user
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">     password</span>: secret</pre><p>
</p><p>的<code class="literal">spring.cloud.config.password</code>和<code class="literal">spring.cloud.config.username</code>值将覆盖URI中提供的任何内容。</p><p>如果您在Cloud Foundry上部署应用程序，则提供密码的最佳方法是通过服务凭据（例如URI，因为它不需要在配置文件中）。以下示例在本地运行，并且适用于名为Cloud Foundry的用户提供的服务<code class="literal">configserver</code> ：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">     uri</span>: ${vcap.services.configserver.credentials.uri:http://user:password@localhost:<span class="hl-number">8888</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>如果您使用其他形式的安全性，则可能需要<a class="link" href="#custom-rest-template" title="10.8.2提供自定义的RestTemplate">提供<code class="literal">RestTemplate</code></a>到<code class="literal">ConfigServicePropertySourceLocator</code> （例如，通过在引导上下文中获取它并注入它）。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_health_indicator_3" href="#_health_indicator_3"></a> 10.8.1健康指标</h3></div></div></div><p>Config Client提供一个Spring Boot Health Indicator，该指示器尝试从Config Server加载配置。可以通过设置禁用健康指示器<code class="literal">health.config.enabled=false</code> 。由于性能原因，响应也被缓存。默认的生存时间为5分钟。要更改该值，请设置<code class="literal">health.config.time-to-live</code>属性（以毫秒为单位）。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-rest-template" href="#custom-rest-template"></a> 10.8.2提供自定义的RestTemplate</h3></div></div></div><p>在某些情况下，您可能需要自定义来自客户端对配置服务器的请求。通常，这样做涉及通过特殊<code class="literal">Authorization</code>标头以验证对服务器的请求。提供自定义<code class="literal">RestTemplate</code> ：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">使用以下实现创建一个新的配置Bean <code class="literal">PropertySourceLocator</code> ，如以下示例所示：</li></ol></div><p><b>CustomConfigServiceBootstrapConfiguration.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomConfigServiceBootstrapConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ConfigServicePropertySourceLocator configServicePropertySourceLocator() {
        ConfigClientProperties clientProperties = configClientProperties();
       ConfigServicePropertySourceLocator configServicePropertySourceLocator =  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ConfigServicePropertySourceLocator(clientProperties);
        configServicePropertySourceLocator.setRestTemplate(customRestTemplate(clientProperties));
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> configServicePropertySourceLocator;
    }
}</pre><p>
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">在<code class="literal">resources/META-INF</code> ，创建一个名为<code class="literal">spring.factories</code>并指定您的自定义配置，如以下示例所示：</li></ol></div><p><b>弹簧工厂。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">org.springframework.cloud.bootstrap.BootstrapConfiguration </span>= com.my.config.client.CustomConfigServiceBootstrapConfiguration</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_vault" href="#_vault"></a> 10.8.3库</h3></div></div></div><p>使用保管库作为配置服务器的后端时，客户端需要为服务器提供令牌以从保管库检索值。可以通过设置在客户端内部提供此令牌<code class="literal">spring.cloud.config.token</code>在<code class="literal">bootstrap.yml</code> ，如以下示例所示：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      token</span>: YourVaultToken</pre><p>
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_nested_keys_in_vault" href="#_nested_keys_in_vault"></a> 10.9 Vault 中的嵌套键</h2></div></div></div><p> Vault 支持将键嵌套在 Vault 中存储的值中的功能，如以下示例所示：</p><p><code class="literal">echo -n '{"appA": {"secret": "appAsecret"}, "bar": "baz"}' | vault write secret/myapp -</code></p><p>此命令将JSON对象写入您的 Vault 。要在Spring中访问这些值，您可以使用传统的点（ <code class="literal">.</code> ）注释，如以下示例所示</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Value("${appA.secret}")</span></em>
String name = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"World"</span>;</pre><p>前面的代码将设置<code class="literal">name</code>可变为<code class="literal">appAsecret</code> 。</p></div></div></div><div class="part"><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_netflix" href="#_spring_cloud_netflix"></a>第三部分Spring Cloud Netflix</h1></div></div></div><div class="partintro"><div></div><p><span class="strong"><strong>格林威治。SR4</strong></span></p><p>该项目通过自动配置并绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供了Netflix OSS集成。通过一些简单的注释，您可以快速启用和配置应用程序内部的通用模式，并使用经过测试的Netflix组件构建大型分布式系统。提供的模式包括服务发现（Eureka），断路器（Hystrix），智能路由（Zuul）和客户端负载平衡（Ribbon）。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_service_discovery_eureka_clients" href="#_service_discovery_eureka_clients"></a> 11。服务发现：Eureka客户</h2></div></div></div><p>服务发现是基于微服务的体系结构的主要宗旨之一。尝试手动配置每个客户端或某种形式的约定可能很困难并且很脆弱。Eureka是Netflix Service Discovery服务器和客户端。可以将服务器配置和部署为高可用性，每个服务器将有关已注册服务的状态复制到其他服务器。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-eureka-client-starter" href="#netflix-eureka-client-starter"></a> 11.1如何包括尤里卡客户</h2></div></div></div><p>要将Eureka Client包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID为<code class="literal">spring-cloud-starter-netflix-eureka-client</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_with_eureka" href="#_registering_with_eureka"></a> 11.2在尤里卡注册</h2></div></div></div><p>客户端向Eureka注册时，它会提供有关其自身的元数据，例如主机，端口，运行状况指示器URL，主页和其他详细信息。Eureka从属于服务的每个实例接收心跳消息。如果心跳在可配置的时间表上进行故障转移，则通常会将实例从注册表中删除。</p><p>以下示例显示了一个最小的Eureka客户端应用程序：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String home() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello world"</span>;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).web(true).run(args);
    }

}</pre><p>请注意，前面的示例显示了一个普通的<a class="link" href="https://projects.spring.io/spring-boot/" target="_top">Spring Boot</a>应用程序。有了<code class="literal">spring-cloud-starter-netflix-eureka-client</code>在类路径上，您的应用程序会自动向Eureka Server注册。需要配置以找到Eureka服务器，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre><p>
</p><p>在前面的示例中，“ defaultZone”是一个魔术字符串后备值，它为任何不表达首选项的客户端提供服务URL（换句话说，这是一个有用的默认值）。</p><p>默认应用程序名称（即服务ID），虚拟主机和非安全端口（从<code class="literal">Environment</code> ） 是<code class="literal">${spring.application.name}</code> ， <code class="literal">${spring.application.name}</code>和<code class="literal">${server.port}</code> ， 分别。</p><p>有<code class="literal">spring-cloud-starter-netflix-eureka-client</code>在类路径上的，使该应用程序同时成为Eureka的<span class="quote">“ <span class="quote">实例</span> ”</span> （即，它自己注册）和<span class="quote">“ <span class="quote">客户端</span> ”</span> （它可以查询注册表以定位其他服务）。实例行为由<code class="literal">eureka.instance.*</code>配置键，但如果确保您的应用程序具有<code class="literal">spring.application.name</code> （这是Eureka服务ID或VIP的默认设置）。</p><p>有关<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java" target="_top">可</a>配置选项的更多详细信息，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java" target="_top">EurekaInstanceConfigBean</a>和<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java" target="_top">EurekaClientConfigBean</a> 。</p><p>要禁用Eureka Discovery Client，您可以设置<code class="literal">eureka.client.enabled</code>至<code class="literal">false</code> 。在以下情况下，Eureka Discovery Client也将被禁用<code class="literal">spring.cloud.discovery.enabled</code>被设定为<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_authenticating_with_the_eureka_server" href="#_authenticating_with_the_eureka_server"></a> 11.3通过Eureka服务器进行身份验证</h2></div></div></div><p>如果其中一种是HTTP基本身份验证，则会自动添加到您的eureka客户端<code class="literal">eureka.client.serviceUrl.defaultZone</code> URL中嵌入了凭据（卷曲样式，如下所示： <code class="literal"><a class="link" href="http://user:password@localhost:8761/eureka" target="_top">http://user:password@localhost:8761/eureka</a></code> ）。对于更复杂的需求，您可以创建一个<code class="literal">@Bean</code>类型的<code class="literal">DiscoveryClientOptionalArgs</code>并注入<code class="literal">ClientFilter</code>实例，将所有实例应用于从客户端到服务器的调用。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>由于Eureka的限制，无法支持每服务器的基本身份验证凭据，因此仅使用找到的第一组凭据。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_status_page_and_health_indicator" href="#_status_page_and_health_indicator"></a> 11.4状态页和运行状况指示器</h2></div></div></div><p>Eureka实例的状态页和运行状况指示器默认为<code class="literal">/info</code>和<code class="literal">/health</code>分别是Spring Boot Actuator应用程序中有用端点的默认位置。即使您使用非默认上下文路径或servlet路径（例如， <code class="literal">server.servletPath=/custom</code> ）。下面的示例显示两个设置的默认值：</p><p><b>application.yml。</b>
</p><pre class="screen">eureka:
  instance:
    statusPageUrlPath: ${server.servletPath}/info
    healthCheckUrlPath: ${server.servletPath}/health</pre><p>
</p><p>这些链接显示在客户端使用的元数据中，并在某些情况下用于确定是否将请求发送到您的应用程序，因此，如果请求准确无误，这将很有帮助。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在Dalston中，还需要在更改该管理上下文路径时设置状态和运行状况检查URL。从Edgware开始就删除了此要求。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_a_secure_application" href="#_registering_a_secure_application"></a> 11.5注册安全的应用程序</h2></div></div></div><p>如果您想通过HTTPS与您的应用进行联系，则可以在<code class="literal">EurekaInstanceConfig</code> ：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">eureka.instance.[nonSecurePortEnabled]=[false]</code></li><li class="listitem"><code class="literal">eureka.instance.[securePortEnabled]=[true]</code></li></ul></div><p>这样做使Eureka发布实例信息，该实例信息显示出对安全通信的明确偏好。Spring Cloud<code class="literal">DiscoveryClient</code>始终返回以开头的URI <code class="literal">https</code>以这种方式配置的服务。同样，以这种方式配置服务时，Eureka（本机）实例信息具有安全的运行状况检查URL。</p><p>由于Eureka在内部工作的方式，它仍然会为状态和主页发布非安全URL，除非您也明确地覆盖了这些URL。您可以使用占位符来配置eureka实例URL，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">eureka:
  instance:
    statusPageUrl: https://${eureka.hostname}/info
    healthCheckUrl: https://${eureka.hostname}/health
    homePageUrl: https://${eureka.hostname}/</pre><p>
</p><p>（注意<code class="literal">${eureka.hostname}</code>是本机占位符，仅在更高版本的Eureka中可用。您也可以使用Spring占位符来实现相同的目的-例如，通过使用<code class="literal">${eureka.instance.hostName}</code> ）</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您的应用程序在代理后面运行，并且SSL终止在代理中（例如，如果您在Cloud Foundry或其他平台中作为服务运行），那么您需要确保拦截并处理了代理的<span class="quote">“ <span class="quote">转发</span> ”</span>标头通过应用程序。如果嵌入在Spring Boot应用程序中的Tomcat容器具有针对'X-Forwarded-\ *`标头的显式配置，则会自动发生。应用程序提供的指向自身的链接错误（错误的主机，端口或协议）表明此配置错误。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_eurekas_health_checks" href="#_eurekas_health_checks"></a> 11.6尤里卡的健康检查</h2></div></div></div><p>默认情况下，Eureka使用客户端心跳来确定客户端是否启动。除非另有说明，否则，根据Spring Boot Actuator，发现客户端不会传播应用程序的当前运行状况检查状态。因此，成功注册后，Eureka始终宣布该应用程序处于“启动”状态。可以通过启用Eureka运行状况检查来更改此行为，这会导致应用程序状态传播到Eureka。结果，所有其他应用程序都不会将流量发送到状态为“ UP”以外的其他应用程序。以下示例显示了如何为客户端启用运行状况检查：</p><p><b>application.yml。</b>
</p><pre class="screen">eureka:
  client:
    healthcheck:
      enabled: true</pre><p>
</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p><code class="literal">eureka.client.healthcheck.enabled=true</code>应该只设置在<code class="literal">application.yml</code> 。在中设置值<code class="literal">bootstrap.yml</code>会导致不良的副作用，例如在Eureka中注册<code class="literal">UNKNOWN</code>状态。</p></td></tr></tbody></table></div><p>如果您需要对健康检查进行更多控制，请考虑实施自己的检查<code class="literal">com.netflix.appinfo.HealthCheckHandler</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_eureka_metadata_for_instances_and_clients" href="#_eureka_metadata_for_instances_and_clients"></a> 11.7实例和客户端的Eureka元数据</h2></div></div></div><p>值得花费一些时间来了解Eureka元数据的工作原理，因此您可以在平台上使用有意义的方式使用它。有用于信息的标准元数据，例如主机名，IP地址，端口号，状态页和运行状况检查。这些将发布在服务注册表中，并由客户端用于以直接方式联系服务。可以将其他元数据添加到实例注册中<code class="literal">eureka.instance.metadataMap</code> ，并且可以在远程客户端中访问此元数据。通常，除非让客户端了解元数据的含义，否则其他元数据不会更改客户端的行为。在本文档后面将介绍几种特殊情况，其中Spring Cloud已经为元数据映射分配了含义。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_eureka_on_cloud_foundry" href="#_using_eureka_on_cloud_foundry"></a> 11.7.1在Cloud Foundry上使用Eureka</h3></div></div></div><p>Cloud Foundry具有全局路由器，因此同一应用程序的所有实例都具有相同的主机名（其他具有类似体系结构的PaaS解决方案的布置也相同）。这不一定是使用尤里卡的障碍。但是，如果您使用路由器（建议或什至是强制性的，取决于平台的设置方式），则需要显式设置主机名和端口号（安全或非安全），以便它们使用路由器。您可能还希望使用实例元数据，以便可以区分客户端上的实例（例如，在自定义负载平衡器中）。默认情况下， <code class="literal">eureka.instance.instanceId</code>是<code class="literal">vcap.application.instance_id</code> ，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80</pre><p>
</p><p>根据在Cloud Foundry实例中设置安全规则的方式，您可能可以注册并使用主机VM的IP地址进行直接的服务到服务的调用。Pivotal Web服务（ <a class="link" href="https://run.pivotal.io" target="_top">PWS</a> ）尚不提供此功能。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_eureka_on_aws" href="#_using_eureka_on_aws"></a> 11.7.2在AWS上使用Eureka</h3></div></div></div><p>如果计划将应用程序部署到AWS云，则必须将Eureka实例配置为可感知AWS。您可以通过如下自定义<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java" target="_top">EurekaInstanceConfigBean</a>来实现：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@Profile("!default")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
  EurekaInstanceConfigBean b = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> EurekaInstanceConfigBean(inetUtils);
  AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"eureka"</span>);
  b.setDataCenterInfo(info);
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> b;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_changing_the_eureka_instance_id" href="#_changing_the_eureka_instance_id"></a> 11.7.3修改Eureka实例ID</h3></div></div></div><p>一个普通的Netflix Eureka实例注册的ID等于其主机名（即，每个主机仅提供一项服务）。Spring Cloud Eureka提供了合理的默认值，定义如下：</p><p><code class="literal">${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}</code></p><p>一个例子是<code class="literal">myhost:myappname:8080</code> 。</p><p>通过使用Spring Cloud，您可以通过在<code class="literal">eureka.instance.instanceId</code> ，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">eureka:
  instance:
    instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre><p>
</p><p>通过前面示例中显示的元数据和在本地主机上部署的多个服务实例，在其中插入随机值以使实例唯一。在Cloud Foundry中， <code class="literal">vcap.application.instance_id</code>是在Spring Boot应用程序中自动填充的，因此不需要随机值。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_eurekaclient" href="#_using_the_eurekaclient"></a> 11.8使用EurekaClient</h2></div></div></div><p>一旦拥有作为发现客户端的应用程序，就可以使用它从<a class="link" href="#spring-cloud-eureka-server" title="12服务发现：Eureka服务器">Eureka Server</a>发现服务实例。一种方法是使用本机<code class="literal">com.netflix.discovery.EurekaClient</code> （与Spring Cloud相对<code class="literal">DiscoveryClient</code> ），如以下示例所示：</p><pre class="screen">@Autowired
private EurekaClient discoveryClient;

public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
}</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>请勿使用<code class="literal">EurekaClient</code>在一个<code class="literal">@PostConstruct</code>方法或<code class="literal">@Scheduled</code>方法（或任何<code class="literal">ApplicationContext</code>可能尚未启动）。初始化为<code class="literal">SmartLifecycle</code> （与<code class="literal">phase=0</code> ），因此最早可以依靠它的是另一个<code class="literal">SmartLifecycle</code>具有更高的阶段。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_eurekaclient_without_jersey" href="#_eurekaclient_without_jersey"></a> 11.8.1不带球衣的EurekaClient</h3></div></div></div><p>默认情况下，EurekaClient使用Jersey进行HTTP通信。如果希望避免来自Jersey的依赖关系，可以将其从依赖关系中排除。Spring Cloud基于Spring自动配置传输客户端<code class="literal">RestTemplate</code> 。以下示例显示排除了Jersey：</p><pre class="screen">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.sun.jersey.contribs&lt;/groupId&gt;
            &lt;artifactId&gt;jersey-apache-client4&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_alternatives_to_the_native_netflix_eurekaclient" href="#_alternatives_to_the_native_netflix_eurekaclient"></a> 11.9本地Netflix EurekaClient的替代方案</h2></div></div></div><p>您无需使用原始Netflix <code class="literal">EurekaClient</code> 。而且，通常在某种包装器后面使用它会更方便。Spring Cloud支持<a class="link" href="#spring-cloud-feign" title="23。声明式REST客户端：伪装">Feign</a> （REST客户端构建器）和<a class="link" href="#spring-cloud-ribbon" title="16。客户端负载均衡器：功能区">Spring <code class="literal">RestTemplate</code></a>通过逻辑Eureka服务标识符（VIP）而不是物理URL。要使用固定的物理服务器列表配置功能区，可以设置<code class="literal"><client>.ribbon.listOfServers</code>到以逗号分隔的物理地址（或主机名）列表，其中<code class="literal"><client></code>是客户端的ID。</p><p>您也可以使用<code class="literal">org.springframework.cloud.client.discovery.DiscoveryClient</code> ，它为发现客户端提供了一个简单的API（非Netflix专用），如以下示例所示：</p><pre class="screen">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_why_is_it_so_slow_to_register_a_service" href="#_why_is_it_so_slow_to_register_a_service"></a> 11.10为什么注册服务这么慢？</h2></div></div></div><p>成为实例还涉及到注册表的定期心跳（通过客户端的<code class="literal">serviceUrl</code> ），默认时长为30秒。直到实例，服务器和客户端在其本地缓存中都具有相同的元数据后，客户端才能发现该服务（因此可能需要3个心跳）。您可以通过设置更改周期<code class="literal">eureka.instance.leaseRenewalIntervalInSeconds</code> 。将其设置为小于30的值可加快使客户端连接到其他服务的过程。在生产中，最好使用默认值，因为服务器中的内部计算对租约续订期进行了假设。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_zones" href="#_zones"></a> 11.11区域</h2></div></div></div><p>如果您已将Eureka客户端部署到多个区域，则您可能更希望这些客户端在同一区域内使用服务，然后再尝试其他区域中的服务。要进行设置，您需要正确配置Eureka客户端。</p><p>首先，您需要确保已将Eureka服务器部署到每个区域，并且它们彼此对等。有关更多信息，请参见<a class="link" href="#spring-cloud-eureka-server-zones-and-regions" title="12.3高可用性，区域和区域">区域和区域</a>部分。</p><p>接下来，您需要告诉Eureka您的服务位于哪个区域。您可以使用<code class="literal">metadataMap</code>属性。例如，如果<code class="literal">service 1</code>部署到两个<code class="literal">zone 1</code>和<code class="literal">zone 2</code> ，您需要在中设置以下Eureka属性<code class="literal">service 1</code> ：</p><p><span class="strong"><strong>1区服务1</strong></span></p><pre class="screen">eureka.instance.metadataMap.zone = zone1
eureka.client.preferSameZoneEureka = true</pre><p><span class="strong"><strong>2区服务1</strong></span></p><pre class="screen">eureka.instance.metadataMap.zone = zone2
eureka.client.preferSameZoneEureka = true</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_refreshing_eureka_clients" href="#_refreshing_eureka_clients"></a> 11.12刷新Eureka客户</h2></div></div></div><p>默认情况下， <code class="literal">EurekaClient</code> bean是可刷新的，这意味着可以更改和刷新Eureka客户端属性。刷新发生时，客户端将从Eureka服务器中取消注册，并且可能会在短暂的时间内不提供给定服务的所有实例。消除这种情况的一种方法是禁用刷新Eureka客户端的功能。为此做<code class="literal">eureka.client.refresh.enable=false</code> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-eureka-server" href="#spring-cloud-eureka-server"></a> 12服务发现：Eureka服务器</h2></div></div></div><p>本节介绍如何设置Eureka服务器。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-eureka-server-starter" href="#netflix-eureka-server-starter"></a> 12.1如何包括Eureka服务器</h2></div></div></div><p>要将Eureka Server包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID为<code class="literal">spring-cloud-starter-netflix-eureka-server</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您的项目已经使用Thymeleaf作为其模板引擎，则可能无法正确加载Eureka服务器的Freemarker模板。在这种情况下，必须手动配置模板加载器：</p></td></tr></tbody></table></div><p><b>application.yml。</b>
</p><pre class="screen">spring:
  freemarker:
    template-loader-path: classpath:/templates/
    prefer-file-system-access: false</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-running-eureka-server" href="#spring-cloud-running-eureka-server"></a> 12.2如何运行尤里卡服务器</h2></div></div></div><p>以下示例显示了最小的Eureka服务器：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableEurekaServer</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).web(true).run(args);
    }

}</pre><p>该服务器有一个主页，其中包含UI和HTTP API端点，用于在下面的常规Eureka功能。 <code class="literal">/eureka/*</code> 。</p><p>以下链接具有一些Eureka背景知识： <a class="link" href="https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer" target="_top">磁通电容器</a>和<a class="link" href="https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0" target="_top">google小组讨论</a> 。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>由于Gradle的依存关系解析规则以及缺少父Bom功能，具体取决于<code class="literal">spring-cloud-starter-netflix-eureka-server</code>可能会导致应用程序启动失败。要解决此问题，请添加Spring Boot Gradle插件并按如下所示导入Spring Cloud Starter父Bom：</p><p><b>build.gradle。</b>
</p><pre class="programlisting">buildscript {
  dependencies {
    classpath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-docs-version}"</span>)
  }
}

apply plugin: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring-boot"</span>

dependencyManagement {
  imports {
    mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-dependencies:{spring-cloud-version}"</span>
  }
}</pre><p>
</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-eureka-server-zones-and-regions" href="#spring-cloud-eureka-server-zones-and-regions"></a> 12.3高可用性，区域和区域</h2></div></div></div><p>Eureka服务器没有后端存储，但是注册表中的所有服务实例都必须发送心跳信号以使其注册保持最新（因此可以在内存中完成）。客户端还具有Eureka注册的内存缓存（因此，对于每个对服务的请求，它们都不必进入注册表）。</p><p>默认情况下，每个Eureka服务器也是Eureka客户端，并且需要（至少一个）服务URL来定位对等方。如果您不提供该服务，则该服务将运行并运行，但是它将使您的日志充满关于无法向对等方注册的噪音。</p><p>另请参阅<a class="link" href="#spring-cloud-ribbon" title="16. Client Side Load Balancer: Ribbon">以下</a>有关客户端对区域和区域<a class="link" href="#spring-cloud-ribbon" title="16。客户端负载均衡器：功能区">的功能区支持的详细信息</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-eureka-server-standalone-mode" href="#spring-cloud-eureka-server-standalone-mode"></a> 12.4独立模式</h2></div></div></div><p>只要有某种监视器或弹性运行时（例如Cloud Foundry），这两个缓存（客户端和服务器）和心跳的组合就可以使一台独立的Eureka服务器对故障具有相当的恢复能力。在独立模式下，您可能希望关闭客户端行为，以使其不会继续尝试并无法到达其对等对象。下面的示例演示如何关闭客户端行为：</p><p><b>application.yml（独立Eureka服务器）。</b>
</p><pre class="screen">server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</pre><p>
</p><p>请注意<code class="literal">serviceUrl</code>指向与本地实例相同的主机。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-eureka-server-peer-awareness" href="#spring-cloud-eureka-server-peer-awareness"></a> 12.5同行意识</h2></div></div></div><p>通过运行多个实例并要求它们相互注册，可以使Eureka更具弹性并可以使用。实际上，这是默认行为，因此您需要做的就是添加一个有效的<code class="literal">serviceUrl</code>到对等方，如以下示例所示：</p><p><b>application.yml（两个对等感知Eureka服务器）。</b>
</p><pre class="screen">---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: http://peer2/eureka/

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/</pre><p>
</p><p>在前面的示例中，我们有一个YAML文件，可用于在两台主机上运行同一服务器（ <code class="literal">peer1</code>和<code class="literal">peer2</code> ），方法是在不同的Spring配置文件中运行它。您可以使用此配置通过操作来测试单个主机上的对等感知（在生产环境中这样做没有太大价值） <code class="literal">/etc/hosts</code>解析主机名。实际上， <code class="literal">eureka.instance.hostname</code>如果您在知道其主机名的计算机上运行，则不需要（默认情况下，通过使用<code class="literal">java.net.InetAddress</code> ）。</p><p>您可以将多个对等方添加到系统，并且只要它们均通过至少一个边缘彼此连接，它们就可以在彼此之间同步注册。如果对等方在物理上是分开的（在一个数据中心内部或在多个数据中心之间），则该系统原则上可以解决<span class="quote">“ <span class="quote">裂脑</span> ”</span>型故障。您可以将多个对等方添加到系统中，并且只要它们都直接相互连接，它们就可以在彼此之间同步注册。</p><p><b>application.yml（三个对等感知Eureka服务器）。</b>
</p><pre class="screen">eureka:
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/,http://peer2/eureka/,http://peer3/eureka/

---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2

---
spring:
  profiles: peer3
eureka:
  instance:
    hostname: peer3</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-eureka-server-prefer-ip-address" href="#spring-cloud-eureka-server-prefer-ip-address"></a> 12.6何时首选IP地址</h2></div></div></div><p>在某些情况下，尤里卡最好公布服务的IP地址而不是主机名。组<code class="literal">eureka.instance.preferIpAddress</code>至<code class="literal">true</code>当应用程序向eureka注册时，它将使用其IP地址而不是其主机名。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果Java无法确定主机名，则IP地址将发送到Eureka。设置主机名的唯一明确方法是通过设置<code class="literal">eureka.instance.hostname</code>属性。您可以使用环境变量在运行时设置主机名，例如， <code class="literal">eureka.instance.hostname=${HOST_NAME}</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_securing_the_eureka_server" href="#_securing_the_eureka_server"></a> 12.7保护Eureka服务器</h2></div></div></div><p>您只需通过以下方式将Spring Security添加到服务器的类路径中即可保护Eureka服务器的安全： <code class="literal">spring-boot-starter-security</code> 。默认情况下，当Spring Security在类路径上时，它将要求将有效的CSRF令牌与每个请求一起发送到应用程序。尤里卡（Eureka）客户通常不会拥有有效的跨站点请求伪造（CSRF）令牌，因此您需要为<code class="literal">/eureka/**</code>端点。例如：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableWebSecurity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> WebSecurityConfig <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> WebSecurityConfigurerAdapter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> configure(HttpSecurity http) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
        http.csrf().ignoringAntMatchers(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/eureka/**"</span>);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>.configure(http);
    }
}</pre><p>有关CSRF的更多信息，请参见<a class="link" href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf" target="_top">Spring Security文档</a> 。</p><p>可以在Spring Cloud Samples存储<a class="link" href="https://github.com/spring-cloud-samples/eureka/tree/Eureka-With-Security" target="_top">库中</a>找到演示版的Eureka Server。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_jdk_11_support" href="#_jdk_11_support"></a> 12.8 JDK 11支持</h2></div></div></div><p>在JDK 11中删除了Eureka服务器所依赖的JAXB模块。如果打算在运行Eureka服务器时使用JDK 11，则必须在POM或Gradle文件中包括这些依赖项。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.glassfish.jaxb<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>jaxb-runtime<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_circuit_breaker_hystrix_clients" href="#_circuit_breaker_hystrix_clients"></a> 13断路器：Hystrix客户</h2></div></div></div><p>Netflix创建了一个名为<a class="link" href="https://github.com/Netflix/Hystrix" target="_top">Hystrix</a>的库，该库实现了<a class="link" href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_top">断路器模式</a> 。在微服务架构中，通常有多个服务调用层，如以下示例所示：</p><div class="figure"><a name="d0e4543" href="#d0e4543"></a><p class="title"><b>图13.1。微服务图</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/master/docs/src/main/asciidoc/images/Hystrix.png" alt="Hystrix"></div></div></div><br class="figure-break"><p>较低级别的服务中的服务故障可能会导致级联故障，直至用户。当对特定服务的呼叫超过<code class="literal">circuitBreaker.requestVolumeThreshold</code> （默认值：20个请求），并且失败百分比大于<code class="literal">circuitBreaker.errorThresholdPercentage</code> （默认值：> 50％）在由<code class="literal">metrics.rollingStats.timeInMilliseconds</code> （默认值：10秒），电路断开并且不进行呼叫。在出现错误和断路的情况下，开发人员可以提供备用功能。</p><div class="figure"><a name="d0e4563" href="#d0e4563"></a><p class="title"><b>图13.2Hystrix后备可防止级联故障</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/master/docs/src/main/asciidoc/images/HystrixFallback.png" alt="HystrixFallback"></div></div></div><br class="figure-break"><p>开路可停止级联故障，并让不堪重负的服务故障时间得以恢复。回退可以是另一个受Hystrix保护的调用，静态数据或合理的空值。可以将回退链接在一起，以便第一个回退进行其他业务调用，然后回退到静态数据。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_to_include_hystrix" href="#_how_to_include_hystrix"></a> 13.1如何包括Hystrix</h2></div></div></div><p>要将Hystrix包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID为<code class="literal">spring-cloud-starter-netflix-hystrix</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><p>以下示例显示了带有Hystrix断路器的最小型Eureka服务器：</p><pre class="screen">@SpringBootApplication
@EnableCircuitBreaker
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map&lt;String, Object&gt; parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map&lt;String, Object&gt; parameters) {
        return /* something useful */;
    }
}</pre><p>的<code class="literal">@HystrixCommand</code>由一个名为<a class="link" href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica" target="_top"><span class="quote">“ <span class="quote">javanica</span> ”</span></a>的Netflix contrib库提供。Spring Cloud会自动将带有该批注的Spring bean包装在连接到Hystrix断路器的代理中。断路器计算何时断开和闭合电路，以及在发生故障时应采取的措施。</p><p>配置<code class="literal">@HystrixCommand</code>您可以使用<code class="literal">commandProperties</code>具有列表的属性<code class="literal">@HystrixProperty</code>注释。有关更多详细信息，请参见<a class="link" href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration" target="_top">此处</a> 。有关可用属性的详细信息，请参见<a class="link" href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_top">Hystrix Wiki</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-hystrix-starter" href="#netflix-hystrix-starter"></a> 13.2传播安全上下文或使用Spring Scope</h2></div></div></div><p>如果您希望某些线程本地上下文传播到<code class="literal">@HystrixCommand</code> ，默认声明无效，因为它在线程池中执行命令（如果超时）。您可以通过配置或要求注释使用不同的<span class="quote">“ <span class="quote">隔离策略</span> ”</span> ，将Hystrix切换为使用与调用方相同的线程或直接在注释中使用。以下示例演示了如何在注释中设置线程：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@HystrixCommand(fallbackMethod = "stubMyService",
    commandProperties = {
      @HystrixProperty(name="execution.isolation.strategy", value="SEMAPHORE")
    }
)</span></em>
...</pre><p>如果您使用的是同一件事<code class="literal">@SessionScope</code>要么<code class="literal">@RequestScope</code> 。如果遇到运行时异常，提示它找不到范围内的上下文，则需要使用同一线程。</p><p>您还可以选择设置<code class="literal">hystrix.shareSecurityContext</code>财产<code class="literal">true</code> 。这样做会自动配置Hystrix并发策略插件挂钩以传输<code class="literal">SecurityContext</code>从您的主线程到Hystrix命令使用的线程。Hystrix不允许注册多个Hystrix并发策略，因此可以通过声明自己的扩展机制来使用<code class="literal">HystrixConcurrencyStrategy</code>作为Spring bean 。Spring Cloud在Spring上下文中寻找您的实现，并将其包装在自己的插件中。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_health_indicator_4" href="#_health_indicator_4"></a> 13.3健康指标</h2></div></div></div><p>连接的断路器的状态也暴露在<code class="literal">/health</code>调用应用程序的端点，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"hystrix"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"openCircuitBreakers"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"StoreIntegration::getStoresByLocationLink"</span>
        ]<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CIRCUIT_OPEN"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UP"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_hystrix_metrics_stream" href="#_hystrix_metrics_stream"></a> 13.4 Hystrix指标流</h2></div></div></div><p>要启用Hystrix指标流，请包括对<code class="literal">spring-boot-starter-actuator</code>并设置<code class="literal">management.endpoints.web.exposure.include: hystrix.stream</code> 。这样做会暴露<code class="literal">/actuator/hystrix.stream</code>作为管理端点，如以下示例所示：</p><pre class="programlisting">    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-actuator<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_circuit_breaker_hystrix_dashboard" href="#_circuit_breaker_hystrix_dashboard"></a> 14。断路器：Hystrix仪表板</h2></div></div></div><p>Hystrix的主要优点之一是它收集的有关每个HystrixCommand的一组指标。Hystrix仪表板以有效的方式显示每个断路器的运行状况。</p><div class="figure"><a name="d0e4684" href="#d0e4684"></a><p class="title"><b>图14.1Hystrix仪表板</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/master/docs/src/main/asciidoc/images/Hystrix.png" alt="Hystrix"></div></div></div><br class="figure-break"></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_hystrix_timeouts_and_ribbon_clients" href="#_hystrix_timeouts_and_ribbon_clients"></a> 15Hystrix超时和功能区客户端</h2></div></div></div><p>使用用于包装Ribbon客户端的Hystrix命令时，您要确保将Hystrix超时配置为比配置的Ribbon超时更长，包括可能进行的任何重试。例如，如果您的功能区连接超时为一秒，并且功能区客户端可能重试该请求三次，则Hystrix超时应该稍微超过三秒钟。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-hystrix-dashboard-starter" href="#netflix-hystrix-dashboard-starter"></a> 15.1如何包括Hystrix仪表板</h2></div></div></div><p>要将Hystrix仪表板包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID为<code class="literal">spring-cloud-starter-netflix-hystrix-dashboard</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><p>要运行Hystrix仪表板，请使用以下命令注释您的Spring Boot主类<code class="literal">@EnableHystrixDashboard</code> 。然后参观<code class="literal">/hystrix</code>并将仪表板指向单个实例的<code class="literal">/hystrix.stream</code> Hystrix客户端应用程序中的端点。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>连接到<code class="literal">/hystrix.stream</code>如果端点使用HTTPS，则JVM必须信任服务器使用的证书。如果证书不受信任，则必须将证书导入JVM，以便Hystrix仪表板成功连接到流端点。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_turbine" href="#_turbine"></a> 15.2涡轮</h2></div></div></div><p>从系统的整体运行状况来看，查看单个实例的Hystrix数据不是很有用。<a class="link" href="https://github.com/Netflix/Turbine" target="_top">涡轮</a>是一个汇总所有相关信息的应用程序<code class="literal">/hystrix.stream</code>端点合并<code class="literal">/turbine.stream</code>用于Hystrix仪表板。个别实例通过Eureka定位。要运行Turbine，需要使用<code class="literal">@EnableTurbine</code>注释（例如，通过使用spring-cloud-starter-netflix-turbine设置类路径）。<a class="link" href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)" target="_top">Turbine 1 Wiki中</a>记录的所有配置属性均适用。唯一的区别是<code class="literal">turbine.instanceUrlSuffix</code>不需要前置端口，因为它将自动处理，除非<code class="literal">turbine.instanceInsertPort=false</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认情况下，涡轮查找<code class="literal">/hystrix.stream</code>通过查找其注册实例上的端点<code class="literal">hostName</code>和<code class="literal">port</code>尤里卡中的条目，然后附加<code class="literal">/hystrix.stream</code>对此。如果实例的元数据包含<code class="literal">management.port</code> ，它代替了<code class="literal">port</code>的价值<code class="literal">/hystrix.stream</code>端点。默认情况下，元数据条目称为<code class="literal">management.port</code>等于<code class="literal">management.port</code>配置属性。可以使用以下配置覆盖它：</p></td></tr></tbody></table></div><pre class="screen">eureka:
  instance:
    metadata-map:
      management.port: ${management.port:8081}</pre><p>的<code class="literal">turbine.appConfig</code>配置密钥是Eureka serviceIds的列表，涡轮用于查找实例。然后在Hystrix仪表板中使用该涡轮流，并使用类似于以下内容的URL：</p><p><code class="literal"><a class="link" href="https://my.turbine.server:8080/turbine.stream?cluster=CLUSTERNAME" target="_top">https://my.turbine.server:8080/turbine.stream?cluster=CLUSTERNAME</a></code></p><p>如果名称为，则可以省略cluster参数<code class="literal">default</code> 。的<code class="literal">cluster</code>参数必须与中的条目匹配<code class="literal">turbine.aggregator.clusterConfig</code> 。从Eureka返回的值是大写的。因此，如果有一个名为<code class="literal">customers</code>在尤里卡（Eureka）注册：</p><pre class="screen">turbine:
  aggregator:
    clusterConfig: CUSTOMERS
  appConfig: customers</pre><p>如果您需要自定义Turbine应该使用哪些群集名称（因为您不想将群集名称存储在<code class="literal">turbine.aggregator.clusterConfig</code>配置），提供一个类型的bean <code class="literal">TurbineClustersProvider</code> 。</p><p>的<code class="literal">clusterName</code>可以通过SPEL表达式自定义<code class="literal">turbine.clusterNameExpression</code>以root作为实例<code class="literal">InstanceInfo</code> 。默认值为<code class="literal">appName</code> ，这意味着尤里卡<code class="literal">serviceId</code>成为群集密钥（即， <code class="literal">InstanceInfo</code>为客户有一个<code class="literal">appName</code>的<code class="literal">CUSTOMERS</code> ）。一个不同的例子是<code class="literal">turbine.clusterNameExpression=aSGName</code> ，它从AWS ASG名称获取集群名称。以下清单显示了另一个示例：</p><pre class="screen">turbine:
  aggregator:
    clusterConfig: SYSTEM,USER
  appConfig: customers,stores,ui,admin
  clusterNameExpression: metadata['cluster']</pre><p>在前面的示例中，来自四个服务的集群名称是从它们的元数据映射中拉出的，并且期望其值包括<code class="literal">SYSTEM</code>和<code class="literal">USER</code> 。</p><p>要对所有应用程序使用<span class="quote">“ <span class="quote">default</span> ”</span>集群，您需要一个字符串文字表达式（如果在YAML中，也要使用单引号和双引号进行转义）：</p><pre class="screen">turbine:
  appConfig: customers,stores
  clusterNameExpression: "'default'"</pre><p>Spring Cloud提供了<code class="literal">spring-cloud-starter-netflix-turbine</code>具有运行Turbine服务器所需的所有依赖项。要添加Turbine，请创建一个Spring Boot应用程序并使用<code class="literal">@EnableTurbine</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认情况下，Spring Cloud允许Turbine使用主机和端口来允许每个主机，每个集群多个进程。如果你想内置式水轮机<span class="emphasis"><em>不是</em></span>本地Netflix的行为允许每个主机上的多个过程，每簇（关键实例ID是主机名），集<code class="literal">turbine.combineHostPort=false</code> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_clusters_endpoint" href="#_clusters_endpoint"></a> 15.2.1集群端点</h3></div></div></div><p>在某些情况下，其他应用程序了解Turbine中配置了哪些custers可能会很有用。为此，您可以使用<code class="literal">/clusters</code>端点，它将返回所有已配置集群的JSON数组。</p><p><b>GET /群集。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"RACES"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"link"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:8383/turbine.stream?cluster=RACES"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"WEB"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"link"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:8383/turbine.stream?cluster=WEB"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>
</p><p>可以通过设置禁用此端点<code class="literal">turbine.endpoints.clusters.enabled</code>至<code class="literal">false</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_turbine_stream" href="#_turbine_stream"></a> 15.3涡轮流</h2></div></div></div><p>在某些环境中（例如在PaaS设置中），从所有分布式Hystrix命令中提取指标的经典Turbine模型不起作用。在这种情况下，您可能想让Hystrix命令将度量标准推送到Turbine。Spring Cloud通过消息传递实现了这一点。为此，请在客户端上添加依赖项<code class="literal">spring-cloud-netflix-hystrix-stream</code>和<code class="literal">spring-cloud-starter-stream-*</code>你的选择。请参阅<a class="link" href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/" target="_top">Spring Cloud Stream文档</a>以获取有关代理以及如何配置客户端凭据的详细信息。对于本地代理，它应该开箱即用。</p><p>在服务器端，创建一个Spring Boot应用程序并使用<code class="literal">@EnableTurbineStream</code> 。Turbine Stream服务器需要使用Spring Webflux，因此<code class="literal">spring-boot-starter-webflux</code>需要包含在您的项目中。默认<code class="literal">spring-boot-starter-webflux</code>添加时包含<code class="literal">spring-cloud-starter-netflix-turbine-stream</code>到您的应用程序。</p><p>然后，您可以将Hystrix仪表板指向Turbine Stream Server，而不是指向单个Hystrix流。如果Turbine Stream在myhost的端口8989上运行，则将<code class="literal"><a class="link" href="http://myhost:8989" target="_top">http://myhost:8989</a></code>在Hystrix仪表板的流输入字段中。电路以其各自的前缀为前缀<code class="literal">serviceId</code> ，后跟一个点（ <code class="literal">.</code> ），然后是电路名称。</p><p>Spring Cloud提供了<code class="literal">spring-cloud-starter-netflix-turbine-stream</code>具有运行Turbine Stream服务器所需的所有依赖项。然后，您可以添加所选的Stream活页夹-例如<code class="literal">spring-cloud-starter-stream-rabbit</code> 。</p><p>Turbine Stream服务器还支持<code class="literal">cluster</code>参数。与Turbine服务器不同，Turbine Stream使用eureka serviceIds作为群集名称，并且这些名称不可配置。</p><p>如果Turbine Stream服务器正在端口8989上运行<code class="literal">my.turbine.server</code>并且您有两个eureka serviceIds <code class="literal">customers</code>和<code class="literal">products</code>在您的环境中，以下URL将在您的Turbine Stream服务器上可用。 <code class="literal">default</code>空集群名称将提供Turbine Stream服务器接收的所有指标。</p><pre class="screen">https://my.turbine.sever:8989/turbine.stream?cluster=customers
https://my.turbine.sever:8989/turbine.stream?cluster=products
https://my.turbine.sever:8989/turbine.stream?cluster=default
https://my.turbine.sever:8989/turbine.stream</pre><p>因此，您可以将eureka serviceIds用作Turbine仪表板（或任何兼容的仪表板）的群集名称。您不需要配置任何属性，例如<code class="literal">turbine.appConfig</code> ， <code class="literal">turbine.clusterNameExpression</code>和<code class="literal">turbine.aggregator.clusterConfig</code>用于您的Turbine Stream服务器。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Turbine Stream服务器使用Spring Cloud Stream从配置的输入通道收集所有指标。这意味着它不会从每个实例主动收集Hystrix指标。它只能提供每个实例已经收集到输入通道中的度量。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-ribbon" href="#spring-cloud-ribbon"></a> 16。客户端负载均衡器：功能区</h2></div></div></div><p>Ribbon是客户端负载平衡器，可让您对HTTP和TCP客户端的行为进行大量控制。Feign已在使用Ribbon，因此，如果您使用<code class="literal">@FeignClient</code> ，本节也适用。</p><p>Ribbon中的中心概念是指定客户端的概念。每个负载平衡器都是组件的一部分，这些组件可以一起工作以按需联系远程服务器，并且该组件的名称是您作为应用程序开发人员提供的（例如，通过使用<code class="literal">@FeignClient</code>注解）。随需应变，Spring Cloud会创建一个新的集成<code class="literal">ApplicationContext</code>通过使用每个命名客户端<code class="literal">RibbonClientConfiguration</code> 。其中包括（除其他事项外） <code class="literal">ILoadBalancer</code> ， 一种<code class="literal">RestClient</code>和<code class="literal">ServerListFilter</code> 。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-ribbon-starter" href="#netflix-ribbon-starter"></a> 16.1如何包括功能区</h2></div></div></div><p>要将Ribbon包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID为<code class="literal">spring-cloud-starter-netflix-ribbon</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizing_the_ribbon_client" href="#_customizing_the_ribbon_client"></a> 16.2自定义功能区客户端</h2></div></div></div><p>您可以使用以下命令中的外部属性来配置功能区客户端的一些位<code class="literal"><client>.ribbon.*</code> ，除了可以使用Spring Boot配置文件之外，与本地使用Netflix API相似。可以将本机选项作为静态字段进行检查<a class="link" href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java" target="_top"><code class="literal">CommonClientConfigKey</code></a> （色带芯的一部分）。</p><p>Spring Cloud还允许您通过声明其他配置（在<code class="literal">RibbonClientConfiguration</code> ）使用<code class="literal">@RibbonClient</code> ，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@RibbonClient(name = "custom", configuration = CustomConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TestConfiguration {
}</pre><p>在这种情况下，客户端由已经存在的组件组成<code class="literal">RibbonClientConfiguration</code> ，以及任何<code class="literal">CustomConfiguration</code> （后者通常会覆盖前者）。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">CustomConfiguration</code> clas一定是<code class="literal">@Configuration</code>类，但要注意它不在<code class="literal">@ComponentScan</code>用于主要应用程序上下文。否则，它会被所有<code class="literal">@RibbonClients</code> 。如果您使用<code class="literal">@ComponentScan</code> （要么<code class="literal">@SpringBootApplication</code> ），则需要采取措施避免将其包含在内（例如，您可以将其放在单独的，不重叠的程序包中，或指定要在其中明确扫描的程序包） <code class="literal">@ComponentScan</code> ）。</p></td></tr></tbody></table></div><p>下表显示了Spring Cloud Netflix默认为Ribbon提供的bean：</p><div class="informaltable"><table class="informaltable" width="60%" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="center" valign="top" style="border-right:1px solid;border-bottom:1px solid"> Bean type 型</th><th align="center" valign="top" style="border-right:1px solid;border-bottom:1px solid">Bean name</th><th align="center" valign="top" style="border-bottom:1px solid">班级名称</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">IClientConfig</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ribbonClientConfig</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">DefaultClientConfigImpl</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">IRule</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ribbonRule</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">ZoneAvoidanceRule</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">IPing</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ribbonPing</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">DummyPing</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ServerList<Server></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ribbonServerList</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">ConfigurationBasedServerList</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ServerListFilter<Server></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ribbonServerListFilter</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">ZonePreferenceServerListFilter</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ILoadBalancer</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">ribbonLoadBalancer</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">ZoneAwareLoadBalancer</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">ServerListUpdater</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">ribbonServerListUpdater</code></p></td><td align="left" valign="top"><p><code class="literal">PollingServerListUpdater</code></p></td></tr></tbody></table></div><p>创建其中一种类型的Bean并将其放置在<code class="literal">@RibbonClient</code>配置（例如<code class="literal">FooConfiguration</code>如上所示），您可以覆盖所描述的每个bean，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ZonePreferenceServerListFilter serverListFilter() {
		ZonePreferenceServerListFilter filter = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ZonePreferenceServerListFilter();
		filter.setZone(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myTestZone"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> filter;
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> IPing ribbonPing() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PingUrl();
	}

}</pre><p>前面示例中的include语句替换<code class="literal">NoOpPing</code>与<code class="literal">PingUrl</code>并提供自定义<code class="literal">serverListFilter</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizing_the_default_for_all_ribbon_clients" href="#_customizing_the_default_for_all_ribbon_clients"></a> 16.3为所有功能区客户端自定义默认值</h2></div></div></div><p>通过使用以下命令，可以为所有功能区客户端提供默认配置： <code class="literal">@RibbonClients</code>注释并注册默认配置，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> RibbonClientDefaultConfigurationTestsConfig {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BazServiceList <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ConfigurationBasedServerList {

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> BazServiceList(IClientConfig config) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>.initWithNiwsConfig(config);
		}

	}

}

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DefaultRibbonConfig {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> IRule ribbonRule() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BestAvailableRule();
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> IPing ribbonPing() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PingUrl();
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config);
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ServerListSubsetFilter serverListFilter() {
		ServerListSubsetFilter filter = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ServerListSubsetFilter();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> filter;
	}

}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizing_the_ribbon_client_by_setting_properties" href="#_customizing_the_ribbon_client_by_setting_properties"></a> 16.4通过设置属性来自定义功能区客户端</h2></div></div></div><p>从1.2.0版开始，Spring Cloud Netflix现在通过将属性设置为与<a class="link" href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer" target="_top">Ribbon文档</a>兼容来支持自定义Ribbon客户端。</p><p>这使您可以在启动时在不同环境中更改行为。</p><p>以下列表显示了受支持的属性>：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal"><clientName>.ribbon.NFLoadBalancerClassName</code> ：应实施<code class="literal">ILoadBalancer</code></li><li class="listitem"><code class="literal"><clientName>.ribbon.NFLoadBalancerRuleClassName</code> ：应实施<code class="literal">IRule</code></li><li class="listitem"><code class="literal"><clientName>.ribbon.NFLoadBalancerPingClassName</code> ：应实施<code class="literal">IPing</code></li><li class="listitem"><code class="literal"><clientName>.ribbon.NIWSServerListClassName</code> ：应实施<code class="literal">ServerList</code></li><li class="listitem"><code class="literal"><clientName>.ribbon.NIWSServerListFilterClassName</code> ：应实施<code class="literal">ServerListFilter</code></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>这些属性中定义的类优先于使用定义的bean <code class="literal">@RibbonClient(configuration=MyRibbonConfig.class)</code>以及Spring Cloud Netflix提供的默认设置。</p></td></tr></tbody></table></div><p>设置<code class="literal">IRule</code>服务名称为<code class="literal">users</code> ，您可以设置以下属性：</p><p><b>application.yml。</b>
</p><pre class="screen">users:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</pre><p>
</p><p>有关<a class="link" href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers" target="_top">功能区</a>提供的实现，请参见<a class="link" href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers" target="_top">功能区文档</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_ribbon_with_eureka" href="#_using_ribbon_with_eureka"></a> 16.5将功能区与Eureka一起使用</h2></div></div></div><p>当Eureka与Ribbon结合使用时（也就是说，两者都在类路径上）， <code class="literal">ribbonServerList</code>被扩展为<code class="literal">DiscoveryEnabledNIWSServerList</code> ，其中填充了Eureka的服务器列表。它还取代了<code class="literal">IPing</code>与<code class="literal">NIWSDiscoveryPing</code> ，它委托Eureka确定服务器是否已启动。的<code class="literal">ServerList</code>默认情况下安装的是<code class="literal">DomainExtractingServerList</code> 。其目的是使元数据可用于负载均衡器，而无需使用AWS AMI元数据（这是Netflix所依赖的）。默认情况下，服务器列表是使用实例元数据中提供的<span class="quote">“ <span class="quote">zone</span> ”</span>信息构建的（因此，在远程客户端上， <code class="literal">eureka.instance.metadataMap.zone</code> ）。如果缺少，并且<code class="literal">approximateZoneFromHostname</code>如果设置了flag，它可以使用服务器主机名中的域名作为区域的代理。区域信息可用后，可以在<code class="literal">ServerListFilter</code> 。默认情况下，它用于在与客户端相同的区域中定位服务器，因为默认值为<code class="literal">ZonePreferenceServerListFilter</code> 。默认情况下，客户端区域的确定方式与远程实例相同（即，通过<code class="literal">eureka.instance.metadataMap.zone</code> ）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>设置客户端区域的传统<span class="quote">“ <span class="quote">archaius</span> ”</span>方法是通过名为“ @zone”的配置属性。如果可用，Spring Cloud会优先使用所有其他设置（请注意，密钥必须在YAML配置中用引号引起来）。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果没有其他区域数据源，则根据客户端配置（而不是实例配置）进行猜测。我们采取<code class="literal">eureka.client.availabilityZones</code> ，这是从区域名称到区域列表的映射，并为实例自己的区域拉出第一个区域（即<code class="literal">eureka.client.region</code> ，默认为“ us-east-1”，以与本机Netflix兼容）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-ribbon-without-eureka" href="#spring-cloud-ribbon-without-eureka"></a> 16.6示例：如何在没有尤里卡的情况下使用色带</h2></div></div></div><p>Eureka是一种抽象发现远程服务器的便捷方法，因此您不必在客户端中对它们的URL进行硬编码。但是，如果您不想使用Eureka，Ribbon和Feign也可以使用。假设您已经声明了<code class="literal">@RibbonClient</code>用于“商店”，并且Eureka未被使用（甚至不在类路径上）。功能区客户端默认为配置的服务器列表。您可以提供以下配置：</p><p><b>application.yml。</b>
</p><pre class="screen">stores:
  ribbon:
    listOfServers: example.com,google.com</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_example_disable_eureka_use_in_ribbon" href="#_example_disable_eureka_use_in_ribbon"></a> 16.7示例：禁用功能区中的尤里卡使用</h2></div></div></div><p>设置<code class="literal">ribbon.eureka.enabled</code>财产<code class="literal">false</code>明确禁用在功能区中使用Eureka，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">ribbon:
  eureka:
   enabled: false</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_ribbon_api_directly" href="#_using_the_ribbon_api_directly"></a> 16.8直接使用Ribbon API</h2></div></div></div><p>您也可以使用<code class="literal">LoadBalancerClient</code>直接，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> LoadBalancerClient loadBalancer;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doStuff() {
        ServiceInstance instance = loadBalancer.choose(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stores"</span>);
        URI storesUri = URI.create(String.format(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://%s:%s"</span>, instance.getHost(), instance.getPort()));
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ... do something with the URI</span>
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="ribbon-child-context-eager-load" href="#ribbon-child-context-eager-load"></a> 16.9缓存功能区配置</h2></div></div></div><p>每个名为Ribbon的客户端都有一个Spring Cloud维护的相应子应用程序上下文。此应用程序上下文在对命名客户端的第一个请求上延迟加载。通过指定功能区客户端的名称，可以更改此延迟加载行为，以代替在启动时急于加载这些子应用程序上下文，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">ribbon:
  eager-load:
    enabled: true
    clients: client1, client2, client3</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="how-to-configure-hystrix-thread-pools" href="#how-to-configure-hystrix-thread-pools"></a> 16.10如何配置Hystrix线程池</h2></div></div></div><p>如果你改变<code class="literal">zuul.ribbonIsolationStrategy</code>至<code class="literal">THREAD</code> ，Hystrix的线程隔离策略用于所有路由。在这种情况下， <code class="literal">HystrixThreadPoolKey</code>被设定为<code class="literal">RibbonCommand</code>作为默认值。这意味着所有路由的HystrixCommands在同一个Hystrix线程池中执行。可以使用以下配置更改此行为：</p><p><b>application.yml。</b>
</p><pre class="screen">zuul:
  threadPool:
    useSeparateThreadPools: true</pre><p>
</p><p>前面的示例导致在Hystrix线程池中为每个路由执行HystrixCommands。</p><p>在这种情况下，默认<code class="literal">HystrixThreadPoolKey</code>与每个路由的服务ID相同。为添加前缀<code class="literal">HystrixThreadPoolKey</code> ，设定<code class="literal">zuul.threadPool.threadPoolKeyPrefix</code>到要添加的值，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">zuul:
  threadPool:
    useSeparateThreadPools: true
    threadPoolKeyPrefix: zuulgw</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="how-to-provdie-a-key-to-ribbon" href="#how-to-provdie-a-key-to-ribbon"></a> 16.11如何提供功能区的密钥<code class="literal">IRule</code></h2></div></div></div><p>如果您需要提供自己的<code class="literal">IRule</code>实现以处理诸如<span class="quote">“ <span class="quote">canary</span> ”</span>测试之类的特殊路由要求，将一些信息传递给<code class="literal">choose</code>的方法<code class="literal">IRule</code> 。</p><p><b>com.netflix.loadbalancer。IRule.java。</b>
</p><pre class="screen">public interface IRule{
    public Server choose(Object key);
         :</pre><p>
</p><p>您可以提供一些您的使用信息<code class="literal">IRule</code>实现以选择目标服务器，如以下示例所示：</p><pre class="screen">RequestContext.getCurrentContext()
              .set(FilterConstants.LOAD_BALANCER_KEY, "canary-test");</pre><p>如果您将任何物体放入<code class="literal">RequestContext</code>的关键<code class="literal">FilterConstants.LOAD_BALANCER_KEY</code> ，它将传递给<code class="literal">choose</code>的方法<code class="literal">IRule</code>实施。前面示例中显示的代码必须在执行之前<code class="literal">RibbonRoutingFilter</code>被执行。Zuul的前置过滤器是执行此操作的最佳位置。您可以通过以下方式访问HTTP标头和查询参数<code class="literal">RequestContext</code>在预过滤器中，因此可以用来确定<code class="literal">LOAD_BALANCER_KEY</code>传递给功能区。如果您不重视任何<code class="literal">LOAD_BALANCER_KEY</code>在<code class="literal">RequestContext</code> ，则将null作为参数传递给<code class="literal">choose</code>方法。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_external_configuration_archaius" href="#_external_configuration_archaius"></a> 17。外部配置：Archaius</h2></div></div></div><p><a class="link" href="https://github.com/Netflix/archaius" target="_top">Archaius</a>是Netflix客户端配置库。它是所有Netflix OSS组件用于配置的库。Archaius是<a class="link" href="https://commons.apache.org/proper/commons-configuration" target="_top">Apache Commons Configuration</a>项目的扩展。它可以通过轮询源以进行更改或通过将源将更改推送到客户端来更新配置。Archaius使用动态<type>属性类作为属性的句柄，如以下示例所示：</type></p><p><b>Archaius示例。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ArchaiusTest {
    DynamicStringProperty myprop = DynamicPropertyFactory
            .getInstance()
            .getStringProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"my.prop"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doSomething() {
        OtherClass.someMethod(myprop.get());
    }
}</pre><p>
</p><p>Archaius具有自己的一组配置文件和加载优先级。Spring应用程序通常不应该直接使用Archaius，但是仍然需要本地配置Netflix工具。Spring Cloud具有一个Spring Environment Bridge，以便Archaius可以从Spring Environment中读取属性。该桥允许Spring Boot项目使用常规配置工具链，同时允许它们按记录（大多数情况下）配置Netflix工具。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_router_and_filter_zuul" href="#_router_and_filter_zuul"></a> 18岁路由器和过滤器：Zuul</h2></div></div></div><p>路由是微服务架构不可或缺的一部分。例如， <code class="literal">/</code>可能会映射到您的Web应用程序， <code class="literal">/api/users</code>映射到用户服务，并且<code class="literal">/api/shop</code>映射到商店服务。
<a class="link" href="https://github.com/Netflix/zuul" target="_top">Zuul</a>是Netflix的基于JVM的路由器和服务器端负载平衡器。</p><p><a class="link" href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27" target="_top">Netflix将Zuul</a>用于以下<a class="link" href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27" target="_top">用途</a> ：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">认证方式</li><li class="listitem">见解</li><li class="listitem">压力测试</li><li class="listitem">金丝雀测试</li><li class="listitem">动态路由</li><li class="listitem">服务迁移</li><li class="listitem">减载</li><li class="listitem">安全</li><li class="listitem">静态响应处理</li><li class="listitem">主动/主动流量管理</li></ul></div><p>Zuul的规则引擎使规则和过滤器基本上可以用任何JVM语言编写，并具有对Java和Groovy的内置支持。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>配置属性<code class="literal">zuul.max.host.connections</code>已被两个新属性取代， <code class="literal">zuul.host.maxTotalConnections</code>和<code class="literal">zuul.host.maxPerRouteConnections</code> ，分别默认为200和20。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认的Hystrix隔离模式（ <code class="literal">ExecutionIsolationStrategy</code> ）的所有路线是<code class="literal">SEMAPHORE</code> 。
<code class="literal">zuul.ribbonIsolationStrategy</code>可以更改为<code class="literal">THREAD</code>如果首选该隔离模式。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-zuul-starter" href="#netflix-zuul-starter"></a> 18.1如何包括Zuul</h2></div></div></div><p>要将Zuul包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID为<code class="literal">spring-cloud-starter-netflix-zuul</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-zuul-reverse-proxy" href="#netflix-zuul-reverse-proxy"></a> 18.2嵌入式Zuul反向代理</h2></div></div></div><p>Spring Cloud创建了嵌入式Zuul代理，以简化UI应用程序要对一个或多个后端服务进行代理调用的常见用例的开发。此功能对于用户界面代理所需的后端服务很有用，从而避免了为所有后端独立管理CORS和身份验证问题的需求。</p><p>要启用它，用<code class="literal">@EnableZuulProxy</code> 。这样做会导致将本地呼叫转发到适当的服务。按照惯例，ID为<code class="literal">users</code>从位于以下位置的代理接收请求<code class="literal">/users</code> （去除前缀）。代理使用功能区来定位要通过发现转发到的实例。所有请求均在<a class="link" href="#hystrix-fallbacks-for-routes" title="18.13提供路线的Hystrix后备">hystrix命令</a>中执行，因此失败会显示在Hystrix指标中。一旦电路断开，代理就不会尝试与服务联系。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Zuul启动程序不包括发现客户端，因此，对于基于服务ID的路由，您还需要在类路径上提供其中之一（Eureka是一种选择）。</p></td></tr></tbody></table></div><p>要跳过自动添加服务的过程，请设置<code class="literal">zuul.ignored-services</code>服务ID模式列表。如果服务与被忽略但已包含在显式配置的路由映射中的模式匹配，则将其忽略，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ignoredServices</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'*'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>: /myusers/**</pre><p>
</p><p>在前面的示例中，所有服务均被忽略， <span class="strong"><strong>除了</strong></span> <code class="literal">users</code> 。</p><p>要增加或更改代理路由，可以添加外部配置，如下所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>: /myusers/**</pre><p>
</p><p>前面的示例意味着HTTP调用<code class="literal">/myusers</code>转发给<code class="literal">users</code>服务（例如<code class="literal">/myusers/101</code>转发给<code class="literal">/101</code> ）。</p><p>要对路由进行更细粒度的控制，可以分别指定路径和serviceId，如下所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      serviceId</span>: users_service</pre><p>
</p><p>前面的示例意味着HTTP调用<code class="literal">/myusers</code>转发给<code class="literal">users_service</code>服务。该路线必须有一个<code class="literal">path</code>可以指定为蚂蚁风格的图案<code class="literal">/myusers/*</code>只匹配一个级别，但是<code class="literal">/myusers/**</code>分层匹配。</p><p>后端的位置可以指定为<code class="literal">serviceId</code> （用于发现服务）或<code class="literal">url</code> （针对实际位置），如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://example.com/users_service</pre><p>
</p><p>这些简单的网址路由不会作为<code class="literal">HystrixCommand</code> ，也不会使用功能区对多个URL进行负载均衡。要实现这些目标，您可以指定一个<code class="literal">serviceId</code>具有静态服务器列表，如下所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    echo</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      serviceId</span>: myusers-service
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      stripPrefix</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">hystrix</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  command</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    myusers-service</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      execution</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        isolation</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          thread</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            timeoutInMilliseconds</span>: ...

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">myusers-service</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    NIWSServerListClassName</span>: com.netflix.loadbalancer.ConfigurationBasedServerList
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    listOfServers</span>: https://example1.com,http://example2.com
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    ConnectTimeout</span>: <span class="hl-number">1000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    ReadTimeout</span>: <span class="hl-number">3000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    MaxTotalHttpConnections</span>: <span class="hl-number">500</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    MaxConnectionsPerHost</span>: <span class="hl-number">100</span></pre><p>
</p><p>另一种方法是指定服务路由并为<code class="literal">serviceId</code> （这样做需要在功能区中禁用Eureka支持- <a class="link" href="#spring-cloud-ribbon-without-eureka" title="16.6 Example: How to Use Ribbon Without Eureka">有关更多信息</a> ，请参见<a class="link" href="#spring-cloud-ribbon-without-eureka" title="16.6示例：如何在没有尤里卡的情况下使用色带">上文</a> ），如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      serviceId</span>: users

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  eureka</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    listOfServers</span>: example.com,google.com</pre><p>
</p><p>您可以在<code class="literal">serviceId</code>和路线使用<code class="literal">regexmapper</code> 。它使用正则表达式命名组从中提取变量<code class="literal">serviceId</code>并将它们注入到路由模式中，如以下示例所示：</p><p><b>ApplicationConfiguration.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> PatternServiceRouteMapper serviceRouteMapper() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PatternServiceRouteMapper(
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)"</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${version}/${name}"</span>);
}</pre><p>
</p><p>前面的示例表示<code class="literal">serviceId</code>的<code class="literal">myusers-v1</code>映射到路线<code class="literal">/v1/myusers/**</code> 。可以接受任何正则表达式，但是所有命名组都必须同时存在<code class="literal">servicePattern</code>和<code class="literal">routePattern</code> 。如果<code class="literal">servicePattern</code>与不符<code class="literal">serviceId</code> ，则使用默认行为。在前面的示例中， <code class="literal">serviceId</code>的<code class="literal">myusers</code>映射到“ / myusers / **”路由（未检测到版本）。默认情况下，此功能是禁用的，仅适用于发现的服务。</p><p>要为所有映射添加前缀，请设置<code class="literal">zuul.prefix</code>到一个值，例如<code class="literal">/api</code> 。默认情况下，代理前缀会从请求中剥离，然后再转发请求（您可以通过以下方式关闭此行为： <code class="literal">zuul.stripPrefix=false</code> ）。您还可以关闭从单个路由中剥离特定于服务的前缀，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      stripPrefix</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">zuul.stripPrefix</code>仅适用于中设置的前缀<code class="literal">zuul.prefix</code> 。它对给定路由的内部定义的前缀没有任何影响<code class="literal">path</code> 。</p></td></tr></tbody></table></div><p>在前面的示例中， <code class="literal">/myusers/101</code>转发给<code class="literal">/myusers/101</code>在<code class="literal">users</code>服务。</p><p>的<code class="literal">zuul.routes</code>条目实际上绑定到类型的对象<code class="literal">ZuulProperties</code> 。如果查看该对象的属性，可以看到它也有一个<code class="literal">retryable</code>旗。将该标志设置为<code class="literal">true</code>使功能区客户端自动重试失败的请求。您也可以将该标志设置为<code class="literal">true</code>当您需要修改使用功能区客户端配置的重试操作的参数时。</p><p>默认情况下， <code class="literal">X-Forwarded-Host</code>标头已添加到转发的请求中。要关闭它，设置<code class="literal">zuul.addProxyHeaders = false</code> 。默认情况下，前缀路径被剥离，并且对后端的请求接收到一个<code class="literal">X-Forwarded-Prefix</code>标头（ <code class="literal">/myusers</code>在前面显示的示例中）。</p><p>如果您设置默认路线（ <code class="literal">/</code> ），具有<code class="literal">@EnableZuulProxy</code>可以充当独立服务器。例如， <code class="literal">zuul.route.home: /</code>会将所有流量（“ / **”）路由到“家庭”服务。</p><p>如果需要更细粒度的忽略，则可以指定要忽略的特定模式。这些模式在路线定位过程开始时进行评估，这意味着模式中应包含前缀以保证匹配。被忽略的模式跨越所有服务，并取代任何其他路由规范。以下示例显示了如何创建忽略的模式：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ignoredPatterns</span>: /**/admin/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>: /myusers/**</pre><p>
</p><p>前面的示例表示所有调用（例如<code class="literal">/myusers/101</code> ）转发给<code class="literal">/101</code>在<code class="literal">users</code>服务。但是，通话包括<code class="literal">/admin/</code>不解决。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果您需要保留路线的顺序，则需要使用YAML文件，因为使用属性文件时顺序会丢失。以下示例显示了这样的YAML文件：</p></td></tr></tbody></table></div><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    legacy</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /**</pre><p>
</p><p>如果要使用属性文件，则<code class="literal">legacy</code>路径可能会终止于<code class="literal">users</code>路径，呈现<code class="literal">users</code>路径无法到达。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_zuul_http_client" href="#_zuul_http_client"></a> 18.3 Zuul Http客户端</h2></div></div></div><p>Zuul使用的默认HTTP客户端现在由Apache HTTP客户端而不是已弃用的功能区支持<code class="literal">RestClient</code> 。使用<code class="literal">RestClient</code>要么<code class="literal">okhttp3.OkHttpClient</code> ，设定<code class="literal">ribbon.restclient.enabled=true</code>要么<code class="literal">ribbon.okhttp.enabled=true</code> ， 分别。如果要自定义Apache HTTP客户端或OK HTTP客户端，请提供以下类型的Bean： <code class="literal">ClosableHttpClient</code>要么<code class="literal">OkHttpClient</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_cookies_and_sensitive_headers" href="#_cookies_and_sensitive_headers"></a> 18.4 Cookie和敏感标题</h2></div></div></div><p>您可以在同一系统中的服务之间共享标头，但是您可能不希望敏感标头泄漏到下游到外部服务器中。您可以在路由配置中指定忽略的标头列表。Cookies发挥着特殊的作用，因为它们在浏览器中具有定义明确的语义，并且始终将它们视为敏感内容。如果代理的使用者是浏览器，那么下游服务的cookie也会给用户带来问题，因为它们都混杂在一起（所有下游服务看起来都来自同一位置）。</p><p>如果您对服务的设计很谨慎（例如，如果只有一个下游服务设置cookie），则可以让它们从后端一直流到调用者。另外，如果您的代理设置cookie，并且所有后端服务都在同一系统中，则很自然地简单地共享它们（例如，使用Spring Session将它们链接到某些共享状态）。除此之外，由下游服务设置的任何cookie可能对调用者都无用，因此建议您（至少）进行<code class="literal">Set-Cookie</code>和<code class="literal">Cookie</code>放入不属于您域的路由的敏感标头中。即使对于属于您域的路由，也要在让Cookie与代理之间流动之前，仔细考虑其含义。</p><p>可以将敏感头配置为每个路由的逗号分隔列表，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      sensitiveHeaders</span>: Cookie,Set-Cookie,Authorization
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://downstream</pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>这是默认值<code class="literal">sensitiveHeaders</code> ，因此除非您希望它与众不同，否则无需进行设置。这是Spring Cloud Netflix 1.1中的新功能（在1.0中，用户无法控制标题，并且所有cookie都双向流动）。</p></td></tr></tbody></table></div><p>的<code class="literal">sensitiveHeaders</code>是黑名单，默认值不为空。因此，要让Zuul发送所有标头（ <code class="literal">ignored</code> ），则必须将其明确设置为空列表。如果要将Cookie或授权标头传递到后端，则必须这样做。以下示例显示了如何使用<code class="literal">sensitiveHeaders</code> ：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    users</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /myusers/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      sensitiveHeaders</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://downstream</pre><p>
</p><p>您还可以通过设置<code class="literal">zuul.sensitiveHeaders</code> 。如果<code class="literal">sensitiveHeaders</code>在路线上设置，它将覆盖全局<code class="literal">sensitiveHeaders</code>设置。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_ignored_headers" href="#_ignored_headers"></a> 18.5忽略标题</h2></div></div></div><p>除了路由敏感标头之外，您还可以设置一个名为<code class="literal">zuul.ignoredHeaders</code>与下游服务交互期间应丢弃的值（请求和响应）。默认情况下，如果Spring Security不在类路径中，则它们为空。否则，它们将初始化为Spring Security指定的一组众所周知的<span class="quote">“ <span class="quote">security</span> ”</span>标头（例如，涉及缓存）。在这种情况下，假设下游服务也可以添加这些标头，但是我们需要来自代理的值。要在Spring Security位于类路径上时不丢弃这些众所周知的安全标头，可以设置<code class="literal">zuul.ignoreSecurityHeaders</code>至<code class="literal">false</code> 。如果您在Spring Security中禁用了HTTP Security响应标头，并且想要下游服务提供的值，则这样做很有用。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_management_endpoints" href="#_management_endpoints"></a> 18.6管理端点</h2></div></div></div><p>默认情况下，如果您使用<code class="literal">@EnableZuulProxy</code>使用Spring Boot Actuator，可以启用两个附加端点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">路线</li><li class="listitem">筛选器</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_routes_endpoint" href="#_routes_endpoint"></a> 18.6.1路由端点</h3></div></div></div><p>GET到路由端点<code class="literal">/routes</code>返回已映射路由的列表：</p><p><b>GET /路线。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  /stores/**: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:8081"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>可以通过添加其他路线详细信息来请求<code class="literal">?format=details</code>查询字符串<code class="literal">/routes</code> 。这样做会产生以下输出：</p><p><b>获取/ routes / details。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stores/**"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stores"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fullPath"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stores/**"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"location"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:8081"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"path"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/**"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"prefix"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stores"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"retryable"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customSensitiveHeaders"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"prefixStripped"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>一种<code class="literal">POST</code>至<code class="literal">/routes</code>强制刷新现有路由（例如，服务目录中发生更改时）。您可以通过设置禁用此端点<code class="literal">endpoints.routes.enabled</code>至<code class="literal">false</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>路由应自动响应服务目录中的更改，但是<code class="literal">POST</code>至<code class="literal">/routes</code>是一种迫使更改立即发生的方法。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_filters_endpoint" href="#_filters_endpoint"></a> 18.6.2过滤器端点</h3></div></div></div><p>一种<code class="literal">GET</code>到位于的过滤器端点<code class="literal">/filters</code>按类型返回Zuul过滤器的地图。对于地图中的每种过滤器类型，您将获得该类型的所有过滤器的列表以及它们的详细信息。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_strangulation_patterns_and_local_forwards" href="#_strangulation_patterns_and_local_forwards"></a> 18.7扼杀模式和本地转发</h2></div></div></div><p>迁移现有应用程序或API时，常见的模式是<span class="quote">“ <span class="quote">扼杀</span> ”</span>旧的端点，并用不同的实现方式慢慢替换它们。Zuul代理是一个有用的工具，因为您可以使用它来处理来自旧端点客户端的所有流量，但可以将某些请求重定向到新请求。</p><p>以下示例显示<span class="quote">“ <span class="quote">扼杀</span> ”</span>方案的配置详细信息：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    first</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /first/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://first.example.com
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    second</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /second/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: forward:/second
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    third</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /third/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: forward:/<span class="hl-number">3</span>rd
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    legacy</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      path</span>: /**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      url</span>: https://legacy.example.com</pre><p>
</p><p>在前面的示例中，我们扼杀了<span class="quote">“ <span class="quote">legacy</span> ”</span>应用程序，该应用程序映射到与其他模式之一不匹配的所有请求。中的路径<code class="literal">/first/**</code>已使用外部URL提取到新服务中。中的路径<code class="literal">/second/**</code>被转发，以便可以在本地处理（例如，使用常规Spring <code class="literal">@RequestMapping</code> ）。中的路径<code class="literal">/third/**</code>也被转发，但前缀不同（ <code class="literal">/third/foo</code>转发给<code class="literal">/3rd/foo</code> ）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>被忽略的模式不会被完全忽略，它们不会由代理处理（因此它们也会在本地有效转发）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_uploading_files_through_zuul" href="#_uploading_files_through_zuul"></a> 18.8通过Zuul上传文件</h2></div></div></div><p>如果您使用<code class="literal">@EnableZuulProxy</code> ，您可以使用代理路径上传文件，只要文件很小，它就可以正常工作。对于大文件，有一个替代路径可以绕过Spring <code class="literal">DispatcherServlet</code> （以避免多部分处理）在“ / zuul / *”中。换句话说，如果您有<code class="literal">zuul.routes.customers=/customers/**</code> ， 那么你也能<code class="literal">POST</code>大文件<code class="literal">/zuul/customers/*</code> 。servlet路径通过以下方式外部化<code class="literal">zuul.servletPath</code> 。如果代理路由带您通过功能区负载平衡器，则极大的文件也需要提高的超时设置，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</span>: <span class="hl-number">60000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ConnectTimeout</span>: <span class="hl-number">3000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ReadTimeout</span>: <span class="hl-number">60000</span></pre><p>
</p><p>请注意，要使流技术处理大文件，您需要在请求中使用分块编码（某些浏览器默认不这样做），如以下示例所示：</p><pre class="programlisting">$ curl -v -H <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Transfer-Encoding: chunked"</span> \
    -F <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"file=@mylarge.iso"</span> localhost:<span class="hl-number">9999</span>/zuul/simple/file</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_query_string_encoding" href="#_query_string_encoding"></a> 18.9查询字符串编码</h2></div></div></div><p>在处理传入请求时，查询参数将被解码，以便可以在Zuul过滤器中进行可能的修改。然后将它们重新编码，在路由过滤器中重建后端请求。如果（例如）使用Javascript的编码，则结果可能不同于原始输入<code class="literal">encodeURIComponent()</code>方法。尽管这在大多数情况下不会引起问题，但是某些Web服务器可能对复杂查询字符串的编码很挑剔。</p><p>要强制使用查询字符串的原始编码，可以将特殊标志传递给<code class="literal">ZuulProperties</code>以便查询字符串按原样使用<code class="literal">HttpServletRequest::getQueryString</code>方法，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  forceOriginalQueryStringEncoding</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>此特殊标志仅适用于<code class="literal">SimpleHostRoutingFilter</code> 。此外，您失去了使用以下命令轻松覆盖查询参数的功能<code class="literal">RequestContext.getCurrentContext().setRequestQueryParams(someOverriddenParameters)</code> ，因为现在直接在原始字符串中获取查询字符串<code class="literal">HttpServletRequest</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_request_uri_encoding" href="#_request_uri_encoding"></a> 18.10请求URI编码</h2></div></div></div><p>处理传入请求时，在将请求URI与路由匹配之前，先对其进行解码。然后在路由过滤器中重建后端请求时，将对请求URI进行重新编码。如果您的URI包含编码的“ /”字符，则可能导致某些意外行为。</p><p>要使用原始请求URI，可以向'ZuulProperties'传递一个特殊标志，以便URI可以与<code class="literal">HttpServletRequest::getRequestURI</code>方法，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  decodeUrl</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您使用覆盖请求URI <code class="literal">requestURI</code> RequestContext属性，并且此标志设置为false，则不会对在请求上下文中设置的URL进行编码。确保URL已被编码是您的责任。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_plain_embedded_zuul" href="#_plain_embedded_zuul"></a> 18.11纯嵌入式Zuul</h2></div></div></div><p>如果您使用<code class="literal">@EnableZuulServer</code> （代替<code class="literal">@EnableZuulProxy</code> ），您也可以运行Zuul服务器而无需代理或有选择地打开代理平台的某些部分。您添加到类型为的应用程序中的所有bean <code class="literal">ZuulFilter</code>会自动安装（与<code class="literal">@EnableZuulProxy</code> ），但不会自动添加任何代理过滤器。</p><p>在这种情况下，仍然可以通过配置“ zuul.routes。*”来指定进入Zuul服务器的路由，但是没有服务发现也没有代理。因此，“ serviceId”和“ url”设置将被忽略。以下示例将“ / api / **”中的所有路径映射到Zuul过滤器链：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute"> zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    api</span>: /api/**</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_disable_zuul_filters" href="#_disable_zuul_filters"></a> 18.12禁用Zuul过滤器</h2></div></div></div><p>Zuul for Spring Cloud附带了许多<code class="literal">ZuulFilter</code>在代理和服务器模式下默认启用的bean。有关可启用的过滤器列表，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-zuul/src/main/java/org/springframework/cloud/netflix/zuul/filters" target="_top">Zuul过滤器包</a> 。如果要禁用一个，请设置<code class="literal">zuul.<SimpleClassName>.<filterType>.disable=true</code> 。按照惯例，包装后<code class="literal">filters</code>是Zuul过滤器类型。例如禁用<code class="literal">org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code> ，设定<code class="literal">zuul.SendResponseFilter.post.disable=true</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="hystrix-fallbacks-for-routes" href="#hystrix-fallbacks-for-routes"></a> 18.13提供路线的Hystrix后备</h2></div></div></div><p>当Zuul中给定路线的电路发生跳闸时，您可以通过创建一个类型为bean的bean提供回退响应<code class="literal">FallbackProvider</code> 。在此Bean中，您需要指定备用的路由ID，并提供一个<code class="literal">ClientHttpResponse</code>返回作为后备。下面的例子展示了一个相对简单的<code class="literal">FallbackProvider</code>实施：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyFallbackProvider <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> FallbackProvider {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getRoute() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customers"</span>;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ClientHttpResponse fallbackResponse(String route, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Throwable cause) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (cause <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">instanceof</span> HystrixTimeoutException) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> response(HttpStatus.GATEWAY_TIMEOUT);
        } <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> response(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ClientHttpResponse response(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> HttpStatus status) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClientHttpResponse() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpStatus getStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> status;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> getRawStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> status.value();
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getStatusText() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> status.getReasonPhrase();
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> close() {
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> InputStream getBody() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ByteArrayInputStream(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback"</span>.getBytes());
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpHeaders getHeaders() {
                HttpHeaders headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> headers;
            }
        };
    }
}</pre><p>以下示例显示了上一个示例的路由配置可能如何显示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">zuul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    customers</span>: /customers/**</pre><p>如果您想为所有路由提供默认回退，则可以创建一个类型为的Bean <code class="literal">FallbackProvider</code>并拥有<code class="literal">getRoute</code>方法返回<code class="literal">*</code>要么<code class="literal">null</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyFallbackProvider <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> FallbackProvider {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getRoute() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*"</span>;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ClientHttpResponse fallbackResponse(String route, Throwable throwable) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClientHttpResponse() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpStatus getStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> HttpStatus.OK;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> getRawStatusCode() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">200</span>;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getStatusText() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>;
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> close() {

            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> InputStream getBody() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ByteArrayInputStream(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback"</span>.getBytes());
            }

            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HttpHeaders getHeaders() {
                HttpHeaders headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> headers;
            }
        };
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_zuul_timeouts" href="#_zuul_timeouts"></a> 18.14 Zuul超时</h2></div></div></div><p>如果要为通过Zuul代理的请求配置套接字超时和读取超时，则根据您的配置，有两种选择：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">如果Zuul使用服务发现，则需要使用以下命令配置这些超时<code class="literal">ribbon.ReadTimeout</code>和<code class="literal">ribbon.SocketTimeout</code>功能区属性。</li></ul></div><p>如果通过指定URL配置了Zuul路由，则需要使用<code class="literal">zuul.host.connect-timeout-millis</code>和<code class="literal">zuul.host.socket-timeout-millis</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="zuul-redirect-location-rewrite" href="#zuul-redirect-location-rewrite"></a> 18.15重写<code class="literal">Location</code>标头</h2></div></div></div><p>如果Zuul正在使用Web应用程序，则可能需要重新编写<code class="literal">Location</code> Web应用程序通过HTTP状态代码重定向时的标头<code class="literal">3XX</code> 。否则，浏览器将重定向到Web应用程序的URL，而不是Zuul URL。您可以配置<code class="literal">LocationRewriteFilter</code> Zuul过滤器重新编写<code class="literal">Location</code> Zuul网址的标头。它还添加回去的全局前缀和特定于路由的前缀。以下示例使用Spring Configuration文件添加过滤器：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.netflix.zuul.filters.post.LocationRewriteFilter;
...

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableZuulProxy</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ZuulConfig {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> LocationRewriteFilter locationRewriteFilter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LocationRewriteFilter();
    }
}</pre><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>小心使用此过滤器。过滤器作用于<code class="literal">Location</code> ALL的标题<code class="literal">3XX</code>响应代码，可能不适用于所有情况，例如在将用户重定向到外部URL时。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_enabling_cross_origin_requests" href="#_enabling_cross_origin_requests"></a> 18.16启用跨源请求</h2></div></div></div><p>默认情况下，Zuul将所有跨源请求（CORS）路由到服务。如果您想让Zuul处理这些请求，可以通过提供自定义来完成<code class="literal">WebMvcConfigurer</code> bean ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> WebMvcConfigurer corsConfigurer() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> WebMvcConfigurer() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> addCorsMappings(CorsRegistry registry) {
            registry.addMapping(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/path-1/**"</span>)
                    .allowedOrigins(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://allowed-origin.com"</span>)
                    .allowedMethods(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"GET"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"POST"</span>);
        }
    };
}</pre><p>在上面的示例中，我们允许<code class="literal">GET</code>和<code class="literal">POST</code>来自的方法<code class="literal"><a class="link" href="https://allowed-origin.com" target="_top">https://allowed-origin.com</a></code>将跨域请求发送到以<code class="literal">path-1</code> 。您可以使用以下方式将CORS配置应用于特定的路径模式或整个应用程序的全局路径<code class="literal">/**</code>映射。您可以自定义属性： <code class="literal">allowedOrigins</code> ， <code class="literal">allowedMethods</code> ， <code class="literal">allowedHeaders</code> ， <code class="literal">exposedHeaders</code> ， <code class="literal">allowCredentials</code>和<code class="literal">maxAge</code>通过此配置。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_metrics" href="#_metrics"></a> 18.17指标</h2></div></div></div><p>Zuul将在执行器指标端点下提供指标，以解决路由请求时可能发生的任何故障。这些指标可以通过点击<code class="literal">/actuator/metrics</code> 。指标的名称格式如下<code class="literal">ZUUL::EXCEPTION:errorCause:statusCode</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="zuul-developer-guide" href="#zuul-developer-guide"></a> 18.18 Zuul开发人员指南</h2></div></div></div><p>有关Zuul的工作原理的一般概述，请参见<a class="link" href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_top">Zuul Wiki</a> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_the_zuul_servlet" href="#_the_zuul_servlet"></a> 18.18.1 Zuul Servlet</h3></div></div></div><p>Zuul被实现为Servlet。对于一般情况，Zuul已嵌入到Spring Dispatch机制中。这使Spring MVC可以控制路由。在这种情况下，Zuul缓冲请求。如果需要不缓存请求就通过Zuul（例如，对于大文件上传），则Servlet也会安装在Spring Dispatcher的外部。缺省情况下，该servlet的地址为<code class="literal">/zuul</code> 。您可以使用<code class="literal">zuul.servlet-path</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_zuul_requestcontext" href="#_zuul_requestcontext"></a> 18.18.2 Zuul RequestContext</h3></div></div></div><p>为了在过滤器之间传递信息，Zuul使用了<a class="link" href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java" target="_top"><code class="literal">RequestContext</code></a> 。其数据保存在<code class="literal">ThreadLocal</code>特定于每个请求。有关在何处路由请求，错误和实际信息的信息<code class="literal">HttpServletRequest</code>和<code class="literal">HttpServletResponse</code>被存储在那里。的<code class="literal">RequestContext</code>延伸<code class="literal">ConcurrentHashMap</code> ，因此任何内容都可以存储在上下文中。 <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-zuul/src/main/java/org/springframework/cloud/netflix/zuul/filters/support/FilterConstants.java" target="_top"><code class="literal">FilterConstants</code></a>包含由Spring Cloud Netflix安装的过滤器使用的密钥（ <a class="link" href="#zuul-developer-guide-enable-filters" title="18.18.4 @EnableZuulServer筛选器">稍后会</a>详细介绍）。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_enablezuulproxy_vs_enablezuulserver" href="#_enablezuulproxy_vs_enablezuulserver"></a> 18.18.3 <code class="literal">@EnableZuulProxy</code>与<code class="literal">@EnableZuulServer</code></h3></div></div></div><p>Spring Cloud Netflix安装了许多过滤器，具体取决于用于启用Zuul的注释。 <code class="literal">@EnableZuulProxy</code>是...的超集<code class="literal">@EnableZuulServer</code> 。换一种说法， <code class="literal">@EnableZuulProxy</code>包含所有安装的过滤器<code class="literal">@EnableZuulServer</code> 。<span class="quote">“ <span class="quote">代理</span> ”中</span>的其他过滤器启用路由功能。如果您想要<span class="quote">“ <span class="quote">空白</span> ”</span> Zuul，则应使用<code class="literal">@EnableZuulServer</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="zuul-developer-guide-enable-filters" href="#zuul-developer-guide-enable-filters"></a> 18.18.4 <code class="literal">@EnableZuulServer</code>筛选器</h3></div></div></div><p><code class="literal">@EnableZuulServer</code>创建一个<code class="literal">SimpleRouteLocator</code>从Spring Boot配置文件加载路由定义。</p><p>安装了以下过滤器（作为普通的Spring Bean）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">前置过滤器：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">ServletDetectionFilter</code> ：检测请求是否通过Spring Dispatcher。设置键为的布尔值<code class="literal">FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</code> 。</li><li class="listitem"><code class="literal">FormBodyWrapperFilter</code> ：解析表单数据并为下游请求重新编码。</li><li class="listitem"><code class="literal">DebugFilter</code> ：如果<code class="literal">debug</code>设置请求参数，设置<code class="literal">RequestContext.setDebugRouting()</code>和<code class="literal">RequestContext.setDebugRequest()</code>至<code class="literal">true</code> 。*路由过滤器：</li><li class="listitem"><code class="literal">SendForwardFilter</code> ：通过使用Servlet转发请求<code class="literal">RequestDispatcher</code> 。转发位置存储在<code class="literal">RequestContext</code>属性， <code class="literal">FilterConstants.FORWARD_TO_KEY</code> 。这对于转发到当前应用程序中的端点很有用。</li></ul></div></li><li class="listitem"><p class="simpara">帖子过滤器：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">SendResponseFilter</code> ：将代理请求的响应写入当前响应。</li></ul></div></li><li class="listitem"><p class="simpara">错误过滤器：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">SendErrorFilter</code> ：转发至<code class="literal">/error</code> （默认情况下）如果<code class="literal">RequestContext.getThrowable()</code>不为空。您可以更改默认转发路径（ <code class="literal">/error</code> ）设置<code class="literal">error.path</code>属性。</li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_enablezuulproxy_filters" href="#_enablezuulproxy_filters"></a> 18.18.5 <code class="literal">@EnableZuulProxy</code>筛选器</h3></div></div></div><p>创建一个<code class="literal">DiscoveryClientRouteLocator</code>从一个加载路线定义<code class="literal">DiscoveryClient</code> （例如Eureka）以及属性。为每个创建一条路线<code class="literal">serviceId</code>来自<code class="literal">DiscoveryClient</code> 。添加新服务后，将刷新路由。</p><p>除了前面描述的过滤器之外，还安装了以下过滤器（作为普通的Spring Bean）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">前置过滤器：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">PreDecorationFilter</code> ：根据提供的内容确定路线和路线<code class="literal">RouteLocator</code> 。它还为下游请求设置了各种与代理相关的标头。</li></ul></div></li><li class="listitem"><p class="simpara">路线过滤器：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><p class="simpara"><code class="literal">RibbonRoutingFilter</code> ：使用Ribbon，Hystrix和可插拔HTTP客户端发送请求。服务ID位于<code class="literal">RequestContext</code>属性， <code class="literal">FilterConstants.SERVICE_ID_KEY</code> 。此过滤器可以使用不同的HTTP客户端：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:square"><li class="listitem">阿帕奇<code class="literal">HttpClient</code> ：默认客户端。</li><li class="listitem">方形<code class="literal">OkHttpClient</code> v3：通过启用<code class="literal">com.squareup.okhttp3:okhttp</code>类路径和设置上的库<code class="literal">ribbon.okhttp.enabled=true</code> 。</li><li class="listitem">Netflix Ribbon HTTP客户端：通过设置启用<code class="literal">ribbon.restclient.enabled=true</code> 。该客户端具有局限性，包括不支持PATCH方法，但还具有内置的重试功能。</li></ul></div></li><li class="listitem"><code class="literal">SimpleHostRoutingFilter</code> ：通过Apache HttpClient将请求发送到预定的URL。网址位于<code class="literal">RequestContext.getRouteHost()</code> 。</li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_zuul_filter_examples" href="#_custom_zuul_filter_examples"></a> 18.18.6自定义Zuul过滤器示例</h3></div></div></div><p>下面的大多数“如何编写”示例都包含在<a class="link" href="https://github.com/spring-cloud-samples/sample-zuul-filters" target="_top">示例Zuul过滤器</a>项目中。在该存储库中也有一些处理请求或响应正文的示例。</p><p>本节包括以下示例：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#zuul-developer-guide-sample-pre-filter" title="如何编写预过滤器">名为“如何编写预过滤器”的部分</a></li><li class="listitem"><a class="xref" href="#zuul-developer-guide-sample-route-filter" title="如何编写路由过滤器">名为“如何编写路由过滤器”的部分</a></li><li class="listitem"><a class="xref" href="#zuul-developer-guide-sample-post-filter" title="如何编写帖子过滤器">名为“如何编写后置过滤器”的部分</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="zuul-developer-guide-sample-pre-filter" href="#zuul-developer-guide-sample-pre-filter"></a>如何编写预过滤器</h4></div></div></div><p>前置过滤器可在<code class="literal">RequestContext</code>用于下游过滤器。主要用例是设置路由过滤器所需的信息。以下示例显示了Zuul预过滤器：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> QueryParamPreFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ZuulFilter {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> filterOrder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> PRE_DECORATION_FILTER_ORDER - <span class="hl-number">1</span>; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// run before PreDecoration</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String filterType() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> PRE_TYPE;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldFilter() {
		RequestContext ctx = RequestContext.getCurrentContext();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> !ctx.containsKey(FORWARD_TO_KEY) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// a filter has already forwarded</span>
				&amp;&amp; !ctx.containsKey(SERVICE_ID_KEY); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// a filter has already determined serviceId</span>
	}
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
		HttpServletRequest request = ctx.getRequest();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (request.getParameter(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"sample"</span>) != null) {
		    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// put the serviceId in `RequestContext`</span>
    		ctx.put(SERVICE_ID_KEY, request.getParameter(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>));
    	}
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
    }
}</pre><p>前面的过滤器填充<code class="literal">SERVICE_ID_KEY</code>来自<code class="literal">sample</code>请求参数。实际上，您不应该执行这种直接映射。而是应从的值查询服务ID <code class="literal">sample</code>代替。</p><p>现在<code class="literal">SERVICE_ID_KEY</code>被填充<code class="literal">PreDecorationFilter</code>不运行，并且<code class="literal">RibbonRoutingFilter</code>运行。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果您要路由到完整网址，请致电<code class="literal">ctx.setRouteHost(url)</code>代替。</p></td></tr></tbody></table></div><p>要修改路由过滤器转发到的路径，请设置<code class="literal">REQUEST_URI_KEY</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="zuul-developer-guide-sample-route-filter" href="#zuul-developer-guide-sample-route-filter"></a>如何编写路由过滤器</h4></div></div></div><p>路由过滤器在预过滤器之后运行，并向其他服务发出请求。此处的许多工作是在客户端所需的模型之间来回转换请求和响应数据。以下示例显示了Zuul路由过滤器：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> OkHttpRoutingFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ZuulFilter {
	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ProxyRequestHelper helper;

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String filterType() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> ROUTE_TYPE;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> filterOrder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> SIMPLE_HOST_ROUTING_FILTER_ORDER - <span class="hl-number">1</span>;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldFilter() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RequestContext.getCurrentContext().getRouteHost() != null
				&amp;&amp; RequestContext.getCurrentContext().sendZuulResponse();
	}

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object run() {
		OkHttpClient httpClient = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> OkHttpClient.Builder()
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// customize</span>
				.build();

		RequestContext context = RequestContext.getCurrentContext();
		HttpServletRequest request = context.getRequest();

		String method = request.getMethod();

		String uri = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.helper.buildZuulRequestURI(request);

		Headers.Builder headers = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Headers.Builder();
		Enumeration&lt;String&gt; headerNames = request.getHeaderNames();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (headerNames.hasMoreElements()) {
			String name = headerNames.nextElement();
			Enumeration&lt;String&gt; values = request.getHeaders(name);

			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (values.hasMoreElements()) {
				String value = values.nextElement();
				headers.add(name, value);
			}
		}

		InputStream inputStream = request.getInputStream();

		RequestBody requestBody = null;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (inputStream != null &amp;&amp; HttpMethod.permitsRequestBody(method)) {
			MediaType mediaType = null;
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>) != null) {
				mediaType = MediaType.parse(headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>));
			}
			requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream));
		}

		Request.Builder builder = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Request.Builder()
				.headers(headers.build())
				.url(uri)
				.method(method, requestBody);

		Response response = httpClient.newCall(builder.build()).execute();

		LinkedMultiValueMap&lt;String, String&gt; responseHeaders = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LinkedMultiValueMap&lt;&gt;();

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : response.headers().toMultimap().entrySet()) {
			responseHeaders.put(entry.getKey(), entry.getValue());
		}

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.helper.setResponse(response.code(), response.body().byteStream(),
				responseHeaders);
		context.setRouteHost(null); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// prevent SimpleHostRoutingFilter from running</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
    }
}</pre><p>前面的过滤器将Servlet请求信息转换为OkHttp3请求信息，执行HTTP请求，并将OkHttp3响应信息转换为Servlet响应。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="zuul-developer-guide-sample-post-filter" href="#zuul-developer-guide-sample-post-filter"></a>如何编写帖子过滤器</h4></div></div></div><p>后置过滤器通常操纵响应。以下过滤器添加了随机<code class="literal">UUID</code>作为<code class="literal">X-Sample</code>标头：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> AddResponseHeaderFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ZuulFilter {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String filterType() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> POST_TYPE;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> filterOrder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> SEND_RESPONSE_FILTER_ORDER - <span class="hl-number">1</span>;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldFilter() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> true;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object run() {
		RequestContext context = RequestContext.getCurrentContext();
    	HttpServletResponse servletResponse = context.getResponse();
		servletResponse.addHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"X-Sample"</span>, UUID.randomUUID().toString());
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
	}
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>其他操作，例如转换响应主体，则更加复杂且计算量大。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_zuul_errors_work" href="#_how_zuul_errors_work"></a> 18.18.7 Zuul错误的工作方式</h3></div></div></div><p>如果在Zuul过滤器生命周期的任何部分引发异常，则将执行错误过滤器。的<code class="literal">SendErrorFilter</code>仅在以下情况下运行<code class="literal">RequestContext.getThrowable()</code>不是<code class="literal">null</code> 。然后设置特定<code class="literal">javax.servlet.error.*</code>属性在请求中并将请求转发到Spring Boot错误页面。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_zuul_eager_application_context_loading" href="#_zuul_eager_application_context_loading"></a> 18.18.8 Zuul Eager应用程序上下文加载</h3></div></div></div><p>Zuul在内部使用Ribbon来调用远程URL。默认情况下，丝带云客户端在第一次调用时由Spring Cloud延迟加载。通过使用以下配置，可以为Zuul更改此行为，这将导致在应用程序启动时急于加载与子Ribbon相关的应用程序上下文。以下示例显示了如何启用即时加载：</p><p><b>application.yml。</b>
</p><pre class="screen">zuul:
  ribbon:
    eager-load:
      enabled: true</pre><p>
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_polyglot_support_with_sidecar" href="#_polyglot_support_with_sidecar"></a> 19Sidecar支持多语种</h2></div></div></div><p>您是否要使用非JVM语言来利用Eureka，Ribbon和Config Server？Spring Cloud Netflix Sidecar的灵感来自<a class="link" href="https://github.com/Netflix/Prana" target="_top">Netflix Prana</a> 。它包括一个HTTP API，用于获取给定服务的所有实例（按主机和端口）。您也可以通过嵌入式Zuul代理来代理服务呼叫，该代理从Eureka获取其路由条目。可以通过主机查找或通过Zuul代理直接访问Spring Cloud Config Server。非JVM应用程序应实施运行状况检查，以便Sidecar可以向Eureka报告应用程序是启动还是关闭。</p><p>要将Sidecar包含在您的项目中，请使用组ID为<code class="literal">org.springframework.cloud</code>和工件ID或<code class="literal">spring-cloud-netflix-sidecar</code> 。</p><p>要启用Sidecar，请使用以下命令创建一个Spring Boot应用程序： <code class="literal">@EnableSidecar</code> 。该注释包括<code class="literal">@EnableCircuitBreaker</code> ， <code class="literal">@EnableDiscoveryClient</code>和<code class="literal">@EnableZuulProxy</code> 。在与非JVM应用程序相同的主机上运行结果应用程序。</p><p>要配置侧车，请添加<code class="literal">sidecar.port</code>和<code class="literal">sidecar.health-uri</code>至<code class="literal">application.yml</code> 。的<code class="literal">sidecar.port</code> property是非JVM应用程序侦听的端口。这样，Sidecar可以在Eureka中正确注册该应用程序。的<code class="literal">sidecar.secure-port-enabled</code>选项提供了一种启用流量安全端口的方法。的<code class="literal">sidecar.health-uri</code>是在非JVM应用程序上可访问的URI，它模仿Spring Boot运行状况指示器。它应该返回类似于以下内容的JSON文档：</p><p><b>health-uri-document。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UP"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>以下application.yml示例显示了Sidecar应用程序的示例配置：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  port</span>: <span class="hl-number">5678</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: sidecar

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">sidecar</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  port</span>: <span class="hl-number">8000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  health-uri</span>: http://localhost:<span class="hl-number">8000</span>/health.json</pre><p>
</p><p>的API <code class="literal">DiscoveryClient.getInstances()</code>方法是<code class="literal">/hosts/{serviceId}</code> 。以下示例响应<code class="literal">/hosts/customers</code>返回不同主机上的两个实例：</p><p><b>/ hosts / customers。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"host"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myhost"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"port"</span>: <span class="hl-number">9000</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uri"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://myhost:9000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"serviceId"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CUSTOMERS"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secure"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"host"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myhost2"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"port"</span>: <span class="hl-number">9000</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uri"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://myhost2:9000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"serviceId"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CUSTOMERS"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secure"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>
</p><p>非JVM应用程序可以访问此API（如果sidecar位于端口5678上），位于<code class="literal"><a class="link" href="http://localhost:5678/hosts/{serviceId}" target="_top">http://localhost:5678/hosts/{serviceId}</a></code> 。</p><p>Zuul代理会自动为Eureka中已知的每个服务添加路由到<code class="literal">/<serviceId></code> ，因此可以在以下位置获得客户服务<code class="literal">/customers</code> 。非JVM应用程序可以在以下位置访问客户服务<code class="literal"><a class="link" href="http://localhost:5678/customers" target="_top">http://localhost:5678/customers</a></code> （假设Sidecar正在监听5678端口）。</p><p>如果Config Server已向Eureka注册，则非JVM应用程序可以通过Zuul代理对其进行访问。如果<code class="literal">serviceId</code> ConfigServer的是<code class="literal">configserver</code>并且Sidecar在端口5678上，则可以从<a class="link" href="http://localhost:5678/configserver" target="_top">http：// localhost：5678 / configserver</a>对其进行访问。</p><p>非JVM应用程序可以利用Config Server返回YAML文档的功能。例如，调用<a class="link" href="https://sidecar.local.spring.io:5678/configserver/default-master.yml" target="_top">https://sidecar.local.spring.io:5678/configserver/default-master.yml</a>可能会导致YAML文档类似于以下内容：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">eureka</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    serviceUrl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      defaultZone</span>: http://localhost:<span class="hl-number">8761</span>/eureka/
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  password</span>: password
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">info</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  description</span>: Spring Cloud Samples
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  url</span>: https://github.com/spring-cloud-samples</pre><p>在使用HTTP时启用健康检查请求以接受所有证书<code class="literal">sidecar.accept-all-ssl-certificates</code>为`true。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="retrying-failed-requests" href="#retrying-failed-requests"></a> 20重试失败的请求</h2></div></div></div><p>Spring Cloud Netflix提供了多种发出HTTP请求的方式。您可以使用负载平衡<code class="literal">RestTemplate</code> ，功能区或伪装。无论您选择如何创建HTTP请求，始终都有可能导致请求失败。当请求失败时，您可能希望自动重试该请求。为此，在使用Sping Cloud Netflix时，需要在应用程序的类路径中包括<a class="link" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a> 。存在Spring Retry时，负载均衡<code class="literal">RestTemplates</code> ，Feign和Zuul会自动重试任何失败的请求（假设您的配置允许这样做）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_backoff_policies" href="#_backoff_policies"></a> 20.1退避政策</h2></div></div></div><p>默认情况下，重试请求时不使用任何退避策略。如果要配置退避策略，则需要创建一个类型为的bean <code class="literal">LoadBalancedRetryFactory</code>并覆盖<code class="literal">createBackOffPolicy</code>给定服务的方法，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    LoadBalancedRetryFactory retryFactory() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LoadBalancedRetryFactory() {
            <em><span class="hl-annotation" style="color: gray">@Override</span></em>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> BackOffPolicy createBackOffPolicy(String service) {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ExponentialBackOffPolicy();
            }
        };
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration" href="#_configuration"></a> 20.2配置</h2></div></div></div><p>当将Ribbon与Spring Retry一起使用时，可以通过配置某些Ribbon属性来控制重试功能。为此，请设置<code class="literal">client.ribbon.MaxAutoRetries</code> ， <code class="literal">client.ribbon.MaxAutoRetriesNextServer</code>和<code class="literal">client.ribbon.OkToRetryOnAllOperations</code>属性。有关这些属性的说明，请参见<a class="link" href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties" target="_top">功能区文档</a> 。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>启用<code class="literal">client.ribbon.OkToRetryOnAllOperations</code>包括重试POST请求，由于请求正文的缓冲，这可能会对服务器资源产生影响。</p></td></tr></tbody></table></div><p>此外，您可能想在响应中返回某些状态代码时重试请求。您可以通过设置功能列表来列出希望功能区客户端重试的响应代码。 <code class="literal">clientName.ribbon.retryableStatusCodes</code>属性，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">clientName</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    retryableStatusCodes</span>: <span class="hl-number">404</span>,<span class="hl-number">502</span></pre><p>您还可以创建一个类型的bean <code class="literal">LoadBalancedRetryPolicy</code>并实施<code class="literal">retryableStatusCode</code>给定状态码的方法重试请求。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_zuul" href="#_zuul"></a> 20.2.1 Zuul</h3></div></div></div><p>您可以通过设置关闭Zuul的重试功能<code class="literal">zuul.retryable</code>至<code class="literal">false</code> 。您还可以通过设置来禁用逐个路由的重试功能<code class="literal">zuul.routes.routename.retryable</code>至<code class="literal">false</code> 。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_http_clients" href="#_http_clients"></a> 21HTTP客户端</h2></div></div></div><p>Spring Cloud Netflix会自动为您创建Ribbon，Feign和Zuul使用的HTTP客户端。但是，您也可以根据需要提供自定义的HTTP客户端。为此，您可以创建一个类型为的bean <code class="literal">ClosableHttpClient</code>如果您使用的是Apache Http Cient或<code class="literal">OkHttpClient</code>如果使用的是OK HTTP。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>创建自己的HTTP客户端时，您还负责为这些客户端实施正确的连接管理策略。这样做不当会导致资源管理问题。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_modules_in_maintenance_mode" href="#_modules_in_maintenance_mode"></a> 22维护模式下的模块</h2></div></div></div><p>将模块置于维护模式意味着Spring Cloud团队将不再向该模块添加新功能。我们将修复阻止程序错误和安全性问题，还将考虑并审查社区提出的小请求。</p><p>自格林威治发布列车全面上市以来，我们打算继续为这些模块提供至少一年的支持。</p><p>以下Spring Cloud Netflix模块和相应的启动程序将进入维护模式：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">spring-cloud-netflix-archaius</li><li class="listitem">spring-cloud-netflix-hystrix-contract</li><li class="listitem">spring-cloud-netflix-hystrix-dashboard</li><li class="listitem">spring-cloud-netflix-hystrix-stream</li><li class="listitem">spring-cloud-netflix-hystrix</li><li class="listitem">spring-cloud-netflix-ribbon</li><li class="listitem">spring-cloud-netflix-turbine-stream</li><li class="listitem">spring-cloud-netflix-turbine</li><li class="listitem">spring-cloud-netflix-zuul</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>这不包括Eureka或并发限制模块。</p></td></tr></tbody></table></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_openfeign" href="#_spring_cloud_openfeign"></a>第四部分Spring Cloud OpenFeign</h1></div></div></div><div class="partintro"><div></div><p><span class="strong"><strong>格林威治。SR4</strong></span></p><p>该项目通过自动配置并绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供OpenFeign集成。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-feign" href="#spring-cloud-feign"></a> 23。声明式REST客户端：伪装</h2></div></div></div><p><a class="link" href="https://github.com/Netflix/feign" target="_top">Feign</a>是声明性Web服务客户端。它使编写Web服务客户端更加容易。要使用Feign，请创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC批注以及使用它们的支持<code class="literal">HttpMessageConverters</code>在Spring Web中默认使用。当使用Feign时，Spring Cloud集成了Ribbon和Eureka以提供负载平衡的http客户端。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="netflix-feign-starter" href="#netflix-feign-starter"></a> 23.1如何包含假装</h2></div></div></div><p>要将Feign包含在您的项目中，请使用带有starter的组<code class="literal">org.springframework.cloud</code>和工件ID <code class="literal">spring-cloud-starter-openfeign</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><p>Spring Boot应用程序示例</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableFeignClients</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
    }

}</pre><p><b>StoreClient.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient("stores")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StoreClient {
    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/stores")</span></em>
    List&lt;Store&gt; getStores();

    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")</span></em>
    Store update(<em><span class="hl-annotation" style="color: gray">@PathVariable("storeId")</span></em> Long storeId, Store store);
}</pre><p>
</p><p>在里面<code class="literal">@FeignClient</code>注释String值（上面的“ stores”）是一个任意的客户端名称，用于创建Ribbon负载均衡器（请参见<a class="link" href="#spring-cloud-ribbon" title="16。客户端负载均衡器：功能区">下面的Ribbon支持的详细信息</a> ）。您也可以使用<code class="literal">url</code>属性（绝对值或只是主机名）。应用程序上下文中的Bean名称是接口的标准名称。要指定自己的别名值，您可以使用<code class="literal">qualifier</code>的价值<code class="literal">@FeignClient</code>注解。</p><p>上面的功能区客户端将要发现“商店”服务的物理地址。如果您的应用程序是Eureka客户端，则它将在Eureka服务注册表中解析该服务。如果您不想使用Eureka，则可以在外部配置中简单地配置服务器列表（ <a class="link" href="#spring-cloud-ribbon-without-eureka" title="16.6 Example: How to Use Ribbon Without Eureka">例如，</a>参见<a class="link" href="#spring-cloud-ribbon-without-eureka" title="16.6示例：如何在没有尤里卡的情况下使用色带">上文</a> ）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-feign-overriding-defaults" href="#spring-cloud-feign-overriding-defaults"></a> 23.2覆盖伪装默认值</h2></div></div></div><p>Spring Cloud的Feign支持中的中心概念是指定客户端的概念。每个虚拟客户端都是组件的一部分，这些组件可以一起工作以按需联系远程服务器，并且该组件的名称是您使用<code class="literal">@FeignClient</code>注解。Spring Cloud创建了一个新的合奏<code class="literal">ApplicationContext</code>按需使用每个命名客户<code class="literal">FeignClientsConfiguration</code> 。其中包括（除其他事项外） <code class="literal">feign.Decoder</code> ， 一种<code class="literal">feign.Encoder</code>和<code class="literal">feign.Contract</code> 。可以通过使用<code class="literal">contextId</code>的属性<code class="literal">@FeignClient</code>注解。</p><p>通过Spring Cloud，您可以通过声明其他配置（在<code class="literal">FeignClientsConfiguration</code> ）使用<code class="literal">@FeignClient</code> 。例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "stores", configuration = FooConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StoreClient {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//..</span>
}</pre><p>在这种情况下，客户端由已经存在的组件组成<code class="literal">FeignClientsConfiguration</code>与任何<code class="literal">FooConfiguration</code> （后者将覆盖前者）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">FooConfiguration</code>不需要注释<code class="literal">@Configuration</code> 。但是，如果是这样，请小心将其从任何<code class="literal">@ComponentScan</code>否则将包括此配置，因为它将成为该配置的默认来源<code class="literal">feign.Decoder</code> ， <code class="literal">feign.Encoder</code> ， <code class="literal">feign.Contract</code> ，等等。通过将其与任何其他产品放在单独的，不重叠的包装中可以避免这种情况<code class="literal">@ComponentScan</code>要么<code class="literal">@SpringBootApplication</code> ，也可以明确排除在<code class="literal">@ComponentScan</code> 。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">serviceId</code>现在不推荐使用属性，而推荐使用<code class="literal">name</code>属性。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>使用<code class="literal">contextId</code>的属性<code class="literal">@FeignClient</code>注释，除了更改名称<code class="literal">ApplicationContext</code>集成，它将覆盖客户端名称的别名，并将其用作为该客户端创建的配置Bean名称的一部分。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>以前，使用<code class="literal">url</code>属性，不需要<code class="literal">name</code>属性。使用<code class="literal">name</code>现在是必需的。</p></td></tr></tbody></table></div><p>占位符在<code class="literal">name</code>和<code class="literal">url</code>属性。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "${feign.name}", url = "${feign.url}")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StoreClient {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//..</span>
}</pre><p>Spring Cloud Netflix默认为假装提供以下bean（ <code class="literal">BeanType</code> beanName： <code class="literal">ClassName</code> ）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">Decoder</code> feignDecoder： <code class="literal">ResponseEntityDecoder</code> （其中包含一个<code class="literal">SpringDecoder</code> ）</li><li class="listitem"><code class="literal">Encoder</code> feignEncoder：<code class="literal">SpringEncoder</code></li><li class="listitem"><code class="literal">Logger</code> feignLogger：<code class="literal">Slf4jLogger</code></li><li class="listitem"><code class="literal">Contract</code> feignContract：<code class="literal">SpringMvcContract</code></li><li class="listitem"><code class="literal">Feign.Builder</code> feignBuilder：<code class="literal">HystrixFeign.Builder</code></li><li class="listitem"><code class="literal">Client</code> feignClient：如果启用功能区，则为<code class="literal">LoadBalancerFeignClient</code> ，否则将使用默认的伪装客户端。</li></ul></div><p>OkHttpClient和ApacheHttpClient伪装客户端可以通过设置使用<code class="literal">feign.okhttp.enabled</code>要么<code class="literal">feign.httpclient.enabled</code>至<code class="literal">true</code> ，并将它们放在类路径中。您可以通过提供以下任一类型的bean来定制所使用的HTTP客户端<code class="literal">ClosableHttpClient</code>使用Apache或<code class="literal">OkHttpClient</code>使用OK HTTP时。</p><p>spring-cloud-netflix的默认情况下<span class="emphasis"><em>不</em></span>为假死提供以下 bean ，但仍查找这些类型从应用程序上下文创建佯客户的 Bean type ：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">Logger.Level</code></li><li class="listitem"><code class="literal">Retryer</code></li><li class="listitem"><code class="literal">ErrorDecoder</code></li><li class="listitem"><code class="literal">Request.Options</code></li><li class="listitem"><code class="literal">Collection<RequestInterceptor></code></li><li class="listitem"><code class="literal">SetterFactory</code></li></ul></div><p>创建其中一种类型的Bean并将其放置在<code class="literal">@FeignClient</code>配置（例如<code class="literal">FooConfiguration</code>以上）允许您覆盖所描述的每个bean。例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Contract feignContract() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> feign.Contract.Default();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicAuthRequestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"password"</span>);
    }
}</pre><p>这取代了<code class="literal">SpringMvcContract</code>与<code class="literal">feign.Contract.Default</code>并添加一个<code class="literal">RequestInterceptor</code>到的集合<code class="literal">RequestInterceptor</code> 。</p><p><code class="literal">@FeignClient</code>也可以使用配置属性进行配置。</p><p>application.yml</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">feign</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      feignName</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        connectTimeout</span>: <span class="hl-number">5000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        readTimeout</span>: <span class="hl-number">5000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        loggerLevel</span>: full
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        errorDecoder</span>: com.example.SimpleErrorDecoder
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        retryer</span>: com.example.SimpleRetryer
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        requestInterceptors</span>:
          - com.example.FooRequestInterceptor
          - com.example.BarRequestInterceptor
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        decode404</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        encoder</span>: com.example.SimpleEncoder
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        decoder</span>: com.example.SimpleDecoder
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        contract</span>: com.example.SimpleContract</pre><p>可以在<code class="literal">@EnableFeignClients</code>属性<code class="literal">defaultConfiguration</code>以与上述类似的方式。不同的是，这个配置将适用于<span class="emphasis"><em>所有</em></span>客户假死。</p><p>如果您更喜欢使用配置属性来配置所有<code class="literal">@FeignClient</code> ，您可以使用<code class="literal">default</code>假名。</p><p>application.yml</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">feign</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      default</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        connectTimeout</span>: <span class="hl-number">5000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        readTimeout</span>: <span class="hl-number">5000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        loggerLevel</span>: basic</pre><p>如果我们都创建<code class="literal">@Configuration</code> bean和配置属性，配置属性将获胜。它将覆盖<code class="literal">@Configuration</code>价值观。但是，如果您想将优先级更改为<code class="literal">@Configuration</code> ， 你可以改变<code class="literal">feign.client.default-to-properties</code>至<code class="literal">false</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您需要使用<code class="literal">ThreadLocal</code>您的绑定变量<code class="literal">RequestInterceptor`s you will need to either set the thread isolation strategy for Hystrix to `SEMAPHORE</code>或在Feign中禁用Hystrix。</p></td></tr></tbody></table></div><p>application.yml</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># To disable Hystrix in Feign</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">feign</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  hystrix</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># To set thread isolation to SEMAPHORE</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">hystrix</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  command</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    default</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      execution</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        isolation</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          strategy</span>: SEMAPHORE</pre><p>如果我们要创建多个具有相同名称或网址的伪装客户端，以便它们指向同一台服务器，但每个客户端使用不同的自定义配置，则必须使用<code class="literal">contextId</code>的属性<code class="literal">@FeignClient</code>为了避免这些配置bean的名称冲突。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(contextId = "fooClient", name = "stores", configuration = FooConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> FooClient {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//..</span>
}</pre><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(contextId = "barClient", name = "stores", configuration = BarConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> BarClient {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//..</span>
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_creating_feign_clients_manually" href="#_creating_feign_clients_manually"></a> 23.3手动创建假客户</h2></div></div></div><p>在某些情况下，可能有必要使用上述方法无法实现的方式自定义Feign客户。在这种情况下，您可以使用<a class="link" href="https://github.com/OpenFeign/feign/#basics" target="_top">Feign Builder API</a>创建客户端。下面是一个示例，该示例创建两个具有相同接口的Feign客户端，但为每个客户端配置一个单独的请求拦截器。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Import(FeignClientsConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooController {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> FooClient fooClient;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> FooClient adminClient;

    	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> FooController(Decoder decoder, Encoder encoder, Client client, Contract contract) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.fooClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.contract(contract)
				.requestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicAuthRequestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>))
				.target(FooClient.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://PROD-SVC"</span>);

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.adminClient = Feign.builder().client(client)
				.encoder(encoder)
				.decoder(decoder)
				.contract(contract)
				.requestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BasicAuthRequestInterceptor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"admin"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"admin"</span>))
				.target(FooClient.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://PROD-SVC"</span>);
    }
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在上面的例子中<code class="literal">FeignClientsConfiguration.class</code>是Spring Cloud Netflix提供的默认配置。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">PROD-SVC</code>是客户将向其请求的服务的名称。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>假装<code class="literal">Contract</code>对象定义接口上有效的注释和值。自动接线<code class="literal">Contract</code> bean提供了对SpringMVC注释的支持，而不是默认的Feign本机注释。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-feign-hystrix" href="#spring-cloud-feign-hystrix"></a> 23.4 Feign Hystrix支持</h2></div></div></div><p>如果Hystrix在类路径上并且<code class="literal">feign.hystrix.enabled=true</code> ，Feign将使用断路器包装所有方法。返回一个<code class="literal">com.netflix.hystrix.HystrixCommand</code>也可以。这使您可以使用反应模式（通过调用<code class="literal">.toObservable()</code>要么<code class="literal">.observe()</code>或异步使用（通过调用<code class="literal">.queue()</code> ）。</p><p>要基于每个客户端禁用Hystrix支持，请创建香草<code class="literal">Feign.Builder</code>具有“原型”范围，例如：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<em><span class="hl-annotation" style="color: gray">@Scope("prototype")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Feign.Builder feignBuilder() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Feign.builder();
	}
}</pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>在Spring Cloud Dalston发行之前，如果Hystrix在类路径中，Feign默认会将所有方法包装在断路器中。Spring Cloud Dalston中更改了此默认行为，以支持选择加入方法。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-feign-hystrix-fallback" href="#spring-cloud-feign-hystrix-fallback"></a> 23.5 Feign Hystrix后备</h2></div></div></div><p>Hystrix支持回退的概念：当它们的电路断开或出现错误时，将执行默认代码路径。为给定启用后备<code class="literal">@FeignClient</code>设置<code class="literal">fallback</code>属性为实现后备的类名称。您还需要将实现声明为Spring bean。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "hello", fallback = HystrixClientFallback.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> HystrixClient {
    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/hello")</span></em>
    Hello iFailSometimes();
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HystrixClientFallback <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> HystrixClient {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Hello iFailSometimes() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Hello(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback"</span>);
    }
}</pre><p>如果需要访问引起后备触发器的原因，则可以使用<code class="literal">fallbackFactory</code>内部属性<code class="literal">@FeignClient</code> 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "hello", fallbackFactory = HystrixClientFallbackFactory.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> HystrixClient {
	<em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/hello")</span></em>
	Hello iFailSometimes();
}

<em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HystrixClientFallbackFactory <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> FallbackFactory&lt;HystrixClient&gt; {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> HystrixClient create(Throwable cause) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HystrixClient() {
			<em><span class="hl-annotation" style="color: gray">@Override</span></em>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Hello iFailSometimes() {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Hello(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fallback; reason was: "</span> + cause.getMessage());
			}
		};
	}
}</pre><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>Feign中的后备实现以及Hystrix后备如何工作存在局限性。当前不支持回退方法<code class="literal">com.netflix.hystrix.HystrixCommand</code>和<code class="literal">rx.Observable</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_feign_and_primary" href="#_feign_and_primary"></a> 23.6假装和<code class="literal">@Primary</code></h2></div></div></div><p>当将Feign与Hystrix备用广告素材一起使用时， <code class="literal">ApplicationContext</code>相同类型的。这将导致<code class="literal">@Autowired</code>之所以无法工作，是因为没有一个bean，也没有一个被标记为primary。为解决此问题，Spring Cloud Netflix将所有Feign实例标记为<code class="literal">@Primary</code> ，因此Spring Framework将知道要注入哪个bean。在某些情况下，这可能不是理想的。要关闭此行为，请设置<code class="literal">primary</code>的属性<code class="literal">@FeignClient</code>虚假。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient(name = "hello", primary = false)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> HelloClient {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// methods here</span>
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-feign-inheritance" href="#spring-cloud-feign-inheritance"></a> 23.7假继承支持</h2></div></div></div><p>Feign通过单继承接口支持样板API。这允许将常用操作分组为方便的基本接口。</p><p><b>UserService.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> UserService {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value ="/users/{id}")</span></em>
    User getUser(<em><span class="hl-annotation" style="color: gray">@PathVariable("id")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id);
}</pre><p>
</p><p><b>UserResource.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> UserResource <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> UserService {

}</pre><p>
</p><p><b>UserClient.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> project.user;

<em><span class="hl-annotation" style="color: gray">@FeignClient("users")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> UserClient <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> UserService {

}</pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>通常不建议在服务器和客户端之间共享接口。它引入了紧密耦合，并且实际上也无法以当前形式与Spring MVC一起使用（方法参数映射不被继承）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_feign_requestresponse_compression" href="#_feign_requestresponse_compression"></a> 23.8伪装请求/响应压缩</h2></div></div></div><p>您可以考虑为您的Feign请求启用请求或响应GZIP压缩。您可以通过启用以下属性之一来做到这一点：</p><pre class="programlisting">feign.compression.request.enabled=true
feign.compression.response.enabled=true</pre><p>伪装请求压缩为您提供的设置类似于您为Web服务器设置的设置：</p><pre class="programlisting">feign.compression.request.enabled=true
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=<span class="hl-number">2048</span></pre><p>这些属性使您可以选择压缩媒体类型和最小请求阈值长度。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_feign_logging" href="#_feign_logging"></a> 23.9假装伐木</h2></div></div></div><p>为每个创建的Feign客户端创建一个记录器。默认情况下，记录器的名称是用于创建Feign客户端的接口的全类名称。伪装日志仅响应<code class="literal">DEBUG</code>水平。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">logging.level.project.user.UserClient</span>: DEBUG</pre><p>
</p><p>的<code class="literal">Logger.Level</code>您可以为每个客户端配置的对象，告诉Feign要记录多少。选择是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">NONE</code> ，不记录（ <span class="strong"><strong>DEFAULT</strong></span> ）。</li><li class="listitem"><code class="literal">BASIC</code> ，仅记录请求方法和URL以及响应状态代码和执行时间。</li><li class="listitem"><code class="literal">HEADERS</code> ，记录基本信息以及请求和响应标头。</li><li class="listitem"><code class="literal">FULL</code> ，记录请求和响应的标题，正文和元数据。</li></ul></div><p>例如，以下将设置<code class="literal">Logger.Level</code>至<code class="literal">FULL</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooConfiguration {
    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    Logger.Level feignLoggerLevel() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Logger.Level.FULL;
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_feign_querymap_support" href="#_feign_querymap_support"></a> 23.10 Feign @QueryMap支持</h2></div></div></div><p>OpenFeign <code class="literal">@QueryMap</code>批注支持将POJO用作GET参数映射。不幸的是，默认的OpenFeign QueryMap注释与Spring不兼容，因为它缺少一个<code class="literal">value</code>属性。</p><p>Spring Cloud OpenFeign提供了等效的功能<code class="literal">@SpringQueryMap</code>批注，用于批注POJO或Map参数作为查询参数映射。</p><p>例如， <code class="literal">Params</code>类定义参数<code class="literal">param1</code>和<code class="literal">param2</code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Params.java</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Params {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String param1;
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String param2;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// [Getters and setters omitted for brevity]</span>
}</pre><p>以下伪装客户使用<code class="literal">Params</code>通过使用<code class="literal">@SpringQueryMap</code>注解：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient("demo")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoTemplate {

    <em><span class="hl-annotation" style="color: gray">@GetMapping(path = "/demo")</span></em>
    String demoEndpoint(<em><span class="hl-annotation" style="color: gray">@SpringQueryMap</span></em> Params params);
}</pre></div></div></div><div class="part"><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_stream" href="#_spring_cloud_stream"></a>第五部分Spring Cloud Stream</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_a_brief_history_of_springs_data_integration_journey" href="#_a_brief_history_of_springs_data_integration_journey"></a> 24Spring数据集成之旅简史</h2></div></div></div><p>Spring的Data Integration之旅始于<a class="link" href="https://projects.spring.io/spring-integration/" target="_top">Spring Integration</a> 。通过其编程模型，它为开发人员提供了一致的开发经验，以构建可以包含<a class="link" href="http://www.enterpriseintegrationpatterns.com/" target="_top">企业集成模式</a>以与外部系统（例如数据库，消息代理等）连接的应用程序。</p><p>快进到云时代，微服务已在企业环境中变得突出。<a class="link" href="https://projects.spring.io/spring-boot/" target="_top">Spring Boot</a>改变了开发人员构建应用程序的方式。借助Spring的编程模型和Spring Boot处理的运行时职责，开发独立的，生产级的基于Spring的微服务变得无缝。</p><p>为了将其扩展到数据集成工作负载，将Spring Integration和Spring Boot合并到一个新项目中。Spring Cloud Stream诞生了。</p><p>借助Spring Cloud Stream，开发人员可以：*隔离地构建，测试，迭代和部署以数据为中心的应用程序。*应用现代微服务架构模式，包括通过消息传递进行组合。*以事件为中心的思维将应用程序职责分离。事件可以表示及时发生的事件，下游消费者应用程序可以在不知道事件起源或生产者身份的情况下做出反应。*将业务逻辑移植到消息代理（例如RabbitMQ，Apache Kafka，Amazon Kinesis）上。通过使用Project Reactor的Flux和Kafka Streams API在基于通道的应用程序和基于非通道的应用程序绑定方案之间进行互操作，以支持无状态和有状态的计算。 *依靠框架对常见用例的自动内容类型支持。可以扩展到不同的数据转换类型。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_quick_start_2" href="#_quick_start_2"></a> 25岁快速开始</h2></div></div></div><p>您可以按照以下三步指南在不到5分钟的时间内尝试使用Spring Cloud Stream，甚至无需跳入任何细节。</p><p>我们向您展示了如何创建一个Spring Cloud Stream应用程序，该应用程序接收来自您选择的消息传递中间件的消息（稍后会详细介绍），并将接收到的消息记录到控制台。我们称之为<code class="literal">LoggingConsumer</code> 。尽管不是很实用，但它很好地介绍了一些主要概念和抽象，使您更容易理解本用户指南的其余部分。</p><p>三个步骤如下：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-creating-sample-application" title="25.1使用Spring Initializr创建一个示例应用程序">第25.1节“使用Spring Initializr创建示例应用程序”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-importing-project" title="25.2将项目导入IDE">第25.2节“将项目导入IDE”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-adding-message-handler" title="25.3添加消息处理程序，构建并运行">第25.3节“添加消息处理程序，构建和运行”</a></li></ol></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-preface-creating-sample-application" href="#spring-cloud-stream-preface-creating-sample-application"></a> 25.1使用Spring Initializr创建一个示例应用程序</h2></div></div></div><p>首先，请访问<a class="link" href="https://start.spring.io" target="_top">Spring Initializr</a> 。从那里，您可以生成我们的<code class="literal">LoggingConsumer</code>应用。为此：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">在“ <span class="strong"><strong>依赖关系”</strong></span>部分，开始输入<code class="literal">stream</code> 。当<span class="quote">“ <span class="quote">云流</span> ”</span>选项出现时，选择它。</li><li class="listitem">开始输入“ kafka”或“兔子”。</li><li class="listitem"><p class="simpara">选择<span class="quote">“ <span class="quote">Kafka</span> ”</span>或<span class="quote">“ <span class="quote">RabbitMQ</span> ”</span> 。</p><p class="simpara">基本上，您选择应用程序绑定到的消息传递中间件。我们建议您使用已经安装的一种，或者对安装和运行感到更舒适。另外，从“启动器”屏幕上可以看到，还有一些其他选项可以选择。例如，您可以选择Gradle作为构建工具，而不是Maven（默认设置）。</p></li><li class="listitem"><p class="simpara">在<span class="strong"><strong>工件</strong></span>字段中，输入“ logging-consumer”。</p><p class="simpara"><span class="strong"><strong>Artifact</strong></span>字段的值成为应用程序名称。如果您选择RabbitMQ作为中间件，那么Spring Initializr现在应该如下所示：</p><div class="informalfigure"><div class="mediaobject"><img src="images/stream-initializr.png" alt="流初始化"></div></div></li><li class="listitem"><p class="simpara">单击<span class="strong"><strong>生成项目</strong></span>按钮。</p><p class="simpara">这样做会将生成的项目的压缩版本下载到硬盘上。</p></li><li class="listitem">将文件解压缩到要用作项目目录的文件夹中。</li></ol></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>我们鼓励您探索Spring Initializr中可用的许多可能性。它使您可以创建许多不同种类的Spring应用程序。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-preface-importing-project" href="#spring-cloud-stream-preface-importing-project"></a> 25.2将项目导入IDE</h2></div></div></div><p>现在，您可以将项目导入到IDE中。请记住，取决于IDE，您可能需要遵循特定的导入过程。例如，根据项目的生成方式（Maven或Gradle），您可能需要遵循特定的导入过程（例如，在Eclipse或STS中，您需要使用File→Import→Maven→Existing Maven Project）。</p><p>导入后，该项目必须没有任何类型的错误。也， <code class="literal">src/main/java</code>应该包含<code class="literal">com.example.loggingconsumer.LoggingConsumerApplication</code> 。</p><p>从技术上讲，此时，您可以运行应用程序的主类。它已经是一个有效的Spring Boot应用程序。但是，它没有任何作用，因此我们想添加一些代码。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-preface-adding-message-handler" href="#spring-cloud-stream-preface-adding-message-handler"></a> 25.3添加消息处理程序，构建并运行</h2></div></div></div><p>修改<code class="literal">com.example.loggingconsumer.LoggingConsumerApplication</code>该类看起来如下：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> LoggingConsumerApplication {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(LoggingConsumerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
	}

	<em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handle(Person person) {
		System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Received: "</span> + person);
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Person {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String name;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getName() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> name;
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setName(String name) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.name = name;
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String toString() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.name;
		}
	}
}</pre><p>从前面的清单中可以看到：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">我们已经启用<code class="literal">Sink</code>通过使用绑定（输入无输出） <code class="literal">@EnableBinding(Sink.class)</code> 。这样做会向框架发出信号，以启动对消息传递中间件的绑定，在该消息传递中间件中，它会自动创建绑定到消息传递中间件的目标（即队列，主题等）。 <code class="literal">Sink.INPUT</code>渠道。</li><li class="listitem">我们添加了一个<code class="literal">handler</code>接收类型为传入消息的方法<code class="literal">Person</code> 。这样做可以使您看到框架的核心功能之一：它尝试自动将传入的消息有效负载转换为类型<code class="literal">Person</code> 。</li></ul></div><p>现在，您有了一个功能齐全的Spring Cloud Stream应用程序，该应用程序确实侦听消息。从这里开始，为简单起见，我们假设您在<a class="link" href="#spring-cloud-stream-preface-creating-sample-application" title="25.1使用Spring Initializr创建一个示例应用程序">第一步中</a>选择RabbitMQ。假设您已安装并运行RabbitMQ，则可以通过运行它来启动应用程序<code class="literal">main</code> IDE中的方法。</p><p>您应该看到以下输出：</p><pre class="screen">	--- [ main] c.s.b.r.p.RabbitExchangeQueueProvisioner : declaring queue for inbound: input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg, bound to: input
	--- [ main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [localhost:5672]
	--- [ main] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory#2a3a299:0/SimpleConnection@66c83fc8. . .
	. . .
	--- [ main] o.s.i.a.i.AmqpInboundChannelAdapter      : started inbound.input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg
	. . .
	--- [ main] c.e.l.LoggingConsumerApplication         : Started LoggingConsumerApplication in 2.531 seconds (JVM running for 2.897)</pre><p>转到RabbitMQ管理控制台或任何其他RabbitMQ客户端并将消息发送至<code class="literal">input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg</code> 。的<code class="literal">anonymous.CbMIwdkJSBO1ZoPDOtHtCg</code> part代表组名并生成，因此它在您的环境中必然是不同的。对于更可预测的内容，您可以通过设置<code class="literal">spring.cloud.stream.bindings.input.group=hello</code> （或您喜欢的任何名称）。</p><p>消息的内容应为的JSON表示形式<code class="literal">Person</code>类，如下：</p><pre class="literallayout">{"name":"Sam Spade"}</pre><p>然后，在控制台中，您应该看到：</p><p><code class="literal">Received: Sam Spade</code></p><p>您还可以将应用程序生成并打包到启动jar中（通过使用<code class="literal">./mvnw clean install</code> ），然后使用来运行内置的JAR <code class="literal">java -jar</code>命令。</p><p>现在，您有了一个正在运行的（尽管非常基础）Spring Cloud Stream应用程序。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_whats_new_in_2_0" href="#_whats_new_in_2_0"></a> 262.0中有什么新功能？</h2></div></div></div><p>Spring Cloud Stream引入了许多新功能，增强功能和更改。以下各节概述了最值得注意的部分：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-new-features" title="26.1新功能和组件">第26.1节“新功能和组件”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-notable-enhancements" title="26.2显着增强">第26.2节“显着增强”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-preface-new-features" href="#spring-cloud-stream-preface-new-features"></a> 26.1新功能和组件</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>轮询使用者</strong></span> ：引入轮询使用者，使应用程序可以控制消息处理速率。有关更多详细信息<span class="quote"><span class="quote"><a class="xref" href="#spring-cloud-streams-overview-using-polled-consumers" title="29.3.5 Using Polled Consumers">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-streams-overview-using-polled-consumers" title="29.3.5使用轮询的使用者">第29.3.5节“使用受调查的消费者”）</a></span></span> 。您也可以阅读<a class="link" href="https://spring.io/blog/2018/02/27/spring-cloud-stream-2-0-polled-consumers" target="_top">此博客文章</a>以获取更多详细信息。</li><li class="listitem"><span class="strong"><strong>千分尺支持</strong></span> ：度量标准已切换为使用<a class="link" href="https://micrometer.io/" target="_top">千分尺</a> 。
<code class="literal">MeterRegistry</code>还以Bean的形式提供，以便自定义应用程序可以自动连接它以捕获自定义指标。有关更多详细信息<span class="quote"><span class="quote"><a class="xref" href="#spring-cloud-stream-overview-metrics-emitter" title="37. Metrics Emitter">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-metrics-emitter" title="37。公制发射器">第37章， <i>度量标准发射器</i></a></span> ”</span> 。</li><li class="listitem"><span class="strong"><strong>新的执行器绑定控件</strong></span> ：新的执行器绑定控件使您可以可视化并控制绑定的生命周期。有关更多详细信息，请参见<a class="xref" href="#_binding_visualization_and_control" title="30.6绑定可视化和控制">第30.6节“绑定可视化和控件”</a> 。</li><li class="listitem"><span class="strong"><strong>可配置的RetryTemplate</strong></span> ：除了提供要配置的属性外<code class="literal">RetryTemplate</code> ，现在，您可以提供自己的模板，从而有效地覆盖框架提供的模板。要使用它，请将其配置为<code class="literal">@Bean</code>在您的应用程序中。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-preface-notable-enhancements" href="#spring-cloud-stream-preface-notable-enhancements"></a> 26.2显着增强</h2></div></div></div><p>此版本包括以下显着增强：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-actuator-web-dependencies" title="26.2.1现在，执行器和Web依赖项都是可选的">第26.2.1节“执行器和Web依赖关系现在都是可选的”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-content-type-negotiation-improvements" title="26.2.2内容类型协商的改进">第26.2.2节“内容类型协商的改进”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-notable-deprecations" title="26.3显着弃用">第26.3节“显着的弃用”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-preface-actuator-web-dependencies" href="#spring-cloud-stream-preface-actuator-web-dependencies"></a> 26.2.1现在，执行器和Web依赖项都是可选的</h3></div></div></div><p>如果既不需要执行器也不需要Web依赖项，此更改将减少已部署应用程序的占用空间。还可以通过手动添加以下依赖项之一，在反应式和常规Web范例之间进行切换。</p><p>以下清单显示了如何添加常规Web框架：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-web<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>以下清单显示了如何添加反应式Web框架：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-webflux<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>下表显示了如何添加执行器依赖性：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-actuator<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-preface-content-type-negotiation-improvements" href="#spring-cloud-stream-preface-content-type-negotiation-improvements"></a> 26.2.2内容类型协商的改进</h3></div></div></div><p>Verion 2.0的核心主题之一是围绕内容类型协商和消息转换的改进（在一致性和性能方面）。以下摘要概述了该领域的显着变化和改进。有关更多详细信息<span class="quote"><span class="quote"><a class="xref" href="#content-type-management" title="32. Content Type Negotiation">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#content-type-management" title="32。内容类型协商">第32章， <i>内容类型协商</i></a></span> ”</span>部分。此外， <a class="link" href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation" target="_top">此博客文章还</a>包含更多详细信息。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">现在，所有邮件转换<span class="strong"><strong>仅</strong></span>由<code class="literal">MessageConverter</code>对象。</li><li class="listitem">我们介绍了<code class="literal">@StreamMessageConverter</code>提供自定义的注释<code class="literal">MessageConverter</code>对象。</li><li class="listitem">我们引入了默认<code class="literal">Content Type</code>如<code class="literal">application/json</code> ，在迁移1.3应用程序或以混合模式运行（即1.3生产者→2.0消费者）时需要考虑到这一点。</li><li class="listitem">带有文本有效载荷和<code class="literal">contentType</code>的<code class="literal">text/…​</code>要么<code class="literal">…​/json</code>不再转换为<code class="literal">Message<String></code>对于提供的参数类型<code class="literal">MessageHandler</code>无法确定（即， <code class="literal">public void handle(Message<?> message)</code>要么<code class="literal">public void handle(Object payload)</code> ）。此外，强参数类型可能不足以正确转换消息，因此<code class="literal">contentType</code>标头可能被某些人用作补充<code class="literal">MessageConverters</code> 。</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-preface-notable-deprecations" href="#spring-cloud-stream-preface-notable-deprecations"></a> 26.3显着弃用</h2></div></div></div><p>从2.0版开始，不推荐使用以下项目：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-deprecation-java-serialization" title="26.3.1 Java序列化（Java本机和Kryo）">第26.3.1节“ Java序列化（Java Native和Kryo）”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-preface-deprecation-classes-methods" title="26.3.2不推荐使用的类和方法">第26.3.2节“不推荐使用的类和方法”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-preface-deprecation-java-serialization" href="#spring-cloud-stream-preface-deprecation-java-serialization"></a> 26.3.1 Java序列化（Java本机和Kryo）</h3></div></div></div><p><code class="literal">JavaSerializationMessageConverter</code>和<code class="literal">KryoMessageConverter</code>暂时保留。但是，我们计划将来将它们移出核心软件包和支持。弃用此文件的主要原因是要标记基于类型，特定于语言的序列化可能在分布式环境中引起的问题，在该环境中，生产者和使用者可能依赖于不同的JVM版本或具有不同版本的支持库（即Kryo）。我们还想提请注意这样一个事实，即消费者和生产者甚至可能都不基于Java，因此多语言风格的序列化（即JSON）更适合。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-preface-deprecation-classes-methods" href="#spring-cloud-stream-preface-deprecation-classes-methods"></a> 26.3.2不推荐使用的类和方法</h3></div></div></div><p>以下是显着弃用的快速摘要。有关更多详细信息，请参见相应的{spring-cloud-stream-javadoc-current} [javadoc]。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">SharedChannelRegistry</code> 。使用<code class="literal">SharedBindingTargetRegistry</code> 。</li><li class="listitem"><code class="literal">Bindings</code> 。符合条件的Bean已通过其类型进行了唯一标识-例如， <code class="literal">Source</code> ， <code class="literal">Processor</code>或自定义绑定：</li></ul></div><pre class="screen">public interface Sample {
	String OUTPUT = "sampleOutput";

	@Output(Sample.OUTPUT)
	MessageChannel output();
}</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">HeaderMode.raw</code> 。使用<code class="literal">none</code> ， <code class="literal">headers</code>要么<code class="literal">embeddedHeaders</code></li><li class="listitem"><code class="literal">ProducerProperties.partitionKeyExtractorClass</code>有利于<code class="literal">partitionKeyExtractorName</code>和<code class="literal">ProducerProperties.partitionSelectorClass</code>有利于<code class="literal">partitionSelectorName</code> 。这项更改确保了两个组件都由Spring配置和管理，并且以对Spring友好的方式被引用。</li><li class="listitem"><code class="literal">BinderAwareRouterBeanPostProcessor</code> 。虽然组件仍然存在，但它不再是<code class="literal">BeanPostProcessor</code>并将在将来重命名。</li><li class="listitem"><code class="literal">BinderProperties.setEnvironment(Properties environment)</code> 。使用<code class="literal">BinderProperties.setEnvironment(Map<String, Object> environment)</code> 。</li></ul></div><p>本节将详细介绍如何使用Spring Cloud Stream。它涵盖了诸如创建和运行流应用程序之类的主题。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-stream-overview-introducing" href="#spring-cloud-stream-overview-introducing"></a> 27。介绍Spring Cloud Stream</h2></div></div></div><p>Spring Cloud Stream是用于构建消息驱动的微服务应用程序的框架。Spring Cloud Stream基于Spring Boot来创建独立的生产级Spring应用程序，并使用Spring Integration提供与消息代理的连接。它提供了来自多家供应商的中间件的合理配置，并介绍了持久性发布-订阅语义，使用者组和分区的概念。</p><p>您可以添加<code class="literal">@EnableBinding</code>批注到您的应用程序以立即连接到消息代理，您可以添加<code class="literal">@StreamListener</code>一种使它接收事件以进行流处理的方法。以下示例显示了接收外部消息的接收器应用程序：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> VoteRecordingSinkApplication {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(VoteRecordingSinkApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

  <em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> processVote(Vote vote) {
      votingService.recordVote(vote);
  }
}</pre><p>的<code class="literal">@EnableBinding</code>注释将一个或多个接口作为参数（在这种情况下，参数为单个<code class="literal">Sink</code>接口）。接口声明输入和输出通道。Spring Cloud Stream提供了<code class="literal">Source</code> ， <code class="literal">Sink</code>和<code class="literal">Processor</code>接口。您也可以定义自己的接口。</p><p>以下清单显示了<code class="literal">Sink</code>接口：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Sink {
  String INPUT = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"input"</span>;

  <em><span class="hl-annotation" style="color: gray">@Input(Sink.INPUT)</span></em>
  SubscribableChannel input();
}</pre><p>的<code class="literal">@Input</code>批注标识输入渠道，接收到的消息通过该输入渠道进入应用程序。的<code class="literal">@Output</code>批注标识一个输出通道，已发布的消息通过该通道离开应用程序。的<code class="literal">@Input</code>和<code class="literal">@Output</code>批注可以使用频道名称作为参数。如果未提供名称，则使用带注释的方法的名称。</p><p>Spring Cloud Stream为您创建接口的实现。您可以通过自动装配在应用程序中使用它，如以下示例所示（来自测试用例）：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringJUnit4ClassRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringApplicationConfiguration(classes = VoteRecordingSinkApplication.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@WebAppConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@DirtiesContext</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> StreamApplicationTests {

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Sink sink;

  <em><span class="hl-annotation" style="color: gray">@Test</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() {
    assertNotNull(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.sink.input());
  }
}</pre></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_main_concepts" href="#_main_concepts"></a> 28岁主要概念</h2></div></div></div><p>Spring Cloud Stream提供了许多抽象和原语，简化了消息驱动的微服务应用程序的编写。本节概述了以下内容：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="#spring-cloud-stream-overview-application-model" title="28.1应用模型">Spring Cloud Stream的应用程序模型</a></li><li class="listitem"><a class="xref" href="#spring-cloud-stream-overview-binder-abstraction" title="28.2活页夹抽象">第28.2节“活页夹抽象”</a></li><li class="listitem"><a class="link" href="#spring-cloud-stream-overview-persistent-publish-subscribe-support" title="28.3持久的发布-订阅支持">持久的发布-订阅支持</a></li><li class="listitem"><a class="link" href="#consumer-groups" title="28.4消费群体">消费者群体支持</a></li><li class="listitem"><a class="link" href="#partitioning" title="28.6分区支持">分区支持</a></li><li class="listitem"><a class="link" href="#spring-cloud-stream-overview-binder-api" title="30.2粘合剂SPI">可插拔的Binder SPI</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-application-model" href="#spring-cloud-stream-overview-application-model"></a> 28.1应用模型</h2></div></div></div><p>Spring Cloud Stream应用程序由与中间件无关的核心组成。该应用程序通过Spring Cloud Stream注入到外界的输入和输出通道与外界进行通信。通道通过特定于中间件的Binder实现连接到外部代理。</p><div class="figure"><a name="d0e8320" href="#d0e8320"></a><p class="title"><b>图28.1Spring Cloud Stream应用程序</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/SCSt-with-binder.png" align="middle" alt="带粘合剂的SCSt"></div></div></div><br class="figure-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_fat_jar" href="#_fat_jar"></a> 28.1.1 Fat JAR</h3></div></div></div><p>可以从您的IDE以独立模式运行Spring Cloud Stream应用程序以进行测试。要在生产中运行Spring Cloud Stream应用程序，您可以使用为Maven或Gradle提供的标准Spring Boot工具来创建可执行（或<span class="quote">“ <span class="quote">fat</span> ”</span> ）JAR。有关更多详细信息，请参见《 <a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-build.html#howto-create-an-executable-jar-with-maven" target="_top">Spring Boot参考指南》</a> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-binder-abstraction" href="#spring-cloud-stream-overview-binder-abstraction"></a> 28.2活页夹抽象</h2></div></div></div><p>Spring Cloud Stream为<a class="link" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka" target="_top">Kafka</a>和<a class="link" href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit" target="_top">Rabbit MQ</a>提供了Binder实现。 Spring Cloud Stream还包含一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java" target="_top">TestSupportBinder</a> ，该通道使通道保持<a class="link" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java" target="_top">不变</a> ，以便测试可以直接与通道交互并可靠地断言所接收的内容。您还可以使用可扩展的API编写自己的Binder。</p><p>Spring Cloud Stream使用Spring Boot进行配置，而Binder抽象使Spring Cloud Stream应用程序可以灵活地连接到中间件。例如，部署者可以在运行时动态选择通道连接到的目的地（例如Kafka主题或RabbitMQ交换）。可以通过外部配置属性以及Spring Boot支持的任何形式（包括应用程序参数，环境变量和<code class="literal">application.yml</code>要么<code class="literal">application.properties</code>文件）。在<a class="xref" href="#spring-cloud-stream-overview-introducing" title="27。介绍Spring Cloud Stream">第27章“ <i>介绍Spring Cloud Stream”</i></a>部分的接收器示例中，设置<code class="literal">spring.cloud.stream.bindings.input.destination</code>应用属性<code class="literal">raw-sensor-data</code>使它从<code class="literal">raw-sensor-data</code> Kafka主题或绑定到队列<code class="literal">raw-sensor-data</code> RabbitMQ交换。</p><p>Spring Cloud Stream自动检测并使用在类路径上找到的绑定器。您可以使用具有相同代码的不同类型的中间件。为此，在构建时包括一个不同的活页夹。对于更复杂的用例，您还可以在应用程序中打包多个活页夹，并让它在运行时选择活页夹（甚至为不同的通道使用不同的活页夹）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-persistent-publish-subscribe-support" href="#spring-cloud-stream-overview-persistent-publish-subscribe-support"></a> 28.3持久的发布-订阅支持</h2></div></div></div><p>应用程序之间的通信遵循发布-订阅模型，其中数据通过共享主题进行广播。在下图中可以看到，该图显示了一组交互的Spring Cloud Stream应用程序的典型部署。</p><div class="figure"><a name="d0e8383" href="#d0e8383"></a><p class="title"><b>图28.2Spring Cloud Stream发布-订阅</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/SCSt-sensors.png" align="middle" alt="SCSt传感器"></div></div></div><br class="figure-break"><p>传感器报告给HTTP端点的数据将发送到名为<code class="literal">raw-sensor-data</code> 。从目的地开始，它由计算时间窗平均值的微服务应用程序和另一个将原始数据摄取到HDFS（Hadoop分布式文件系统）的微服务应用程序独立处理。为了处理数据，两个应用程序都在运行时将主题声明为其输入。</p><p>发布-订阅通信模型降低了生产者和使用者的复杂性，并允许在不中断现有流程的情况下将新应用程序添加到拓扑中。例如，在平均计算应用程序的下游，您可以添加一个应用程序，该应用程序计算用于显示和监视的最高温度值。然后，您可以添加另一个解释相同平均值流以进行故障检测的应用程序。通过共享主题而不是点对点队列进行所有通信可以减少微服务之间的耦合。</p><p>尽管发布-订阅消息传递的概念并不新鲜，但是Spring Cloud Stream采取了额外的步骤，使其成为其应用程序模型的明智选择。通过使用本机中间件支持，Spring Cloud Stream还简化了跨不同平台的发布-订阅模型的使用。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="consumer-groups" href="#consumer-groups"></a> 28.4消费群体</h2></div></div></div><p>尽管发布-订阅模型使通过共享主题轻松连接应用程序变得很重要，但是通过创建给定应用程序的多个实例进行扩展的能力同样重要。这样做时，会将应用程序的不同实例置于竞争的消费者关系中，在该消费者关系中，只有一个实例可以处理给定消息。</p><p>Spring Cloud Stream通过消费者群体的概念对这种行为进行建模。（Spring Cloud Stream用户组与Kafka用户组相似并受其启发。）每个消费者绑定都可以使用<code class="literal">spring.cloud.stream.bindings.<channelName>.group</code>属性以指定组名。对于下图所示的消费者，此属性将设置为<code class="literal">spring.cloud.stream.bindings.<channelName>.group=hdfsWrite</code>要么<code class="literal">spring.cloud.stream.bindings.<channelName>.group=average</code> 。</p><div class="figure"><a name="d0e8417" href="#d0e8417"></a><p class="title"><b>图28.3Spring Cloud Stream消费群</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/SCSt-groups.png" align="middle" alt="SCSt小组"></div></div></div><br class="figure-break"><p>订阅给定目标的所有组都将收到已发布数据的副本，但是每个组中只有一个成员从该目标接收给定消息。默认情况下，当未指定组时，Spring Cloud Stream会将应用程序分配给与所有其他使用者组具有发布-订阅关系的匿名且独立的单成员使用者组。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="consumer-types" href="#consumer-types"></a> 28.5消费者类型</h2></div></div></div><p>支持两种类型的使用者：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">消息驱动（有时称为异步）</li><li class="listitem">轮询（有时称为同步）</li></ul></div><p>在2.0版之前，仅支持异步使用者。消息一旦可用，就会被传递，并且有线程可以处理它。</p><p>当您希望控制消息的处理速率时，可能需要使用同步使用者。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="durability" href="#durability"></a> 28.5.1耐久性</h3></div></div></div><p>与Spring Cloud Stream公认的应用程序模型一致，消费者组订阅是持久的。也就是说，活页夹实现可确保组订阅是持久的，并且一旦为组创建了至少一个订阅，该组就可以接收消息，即使消息是在组中所有应用程序停止时发送的也是如此。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>匿名订阅本质上是非持久的。对于某些绑定器实现（例如RabbitMQ），可能具有非持久的组订阅。</p></td></tr></tbody></table></div><p>通常，在将应用程序绑定到给定目标时，最好始终指定使用者组。扩展Spring Cloud Stream应用程序时，必须为其每个输入绑定指定使用者组。这样做可以防止应用程序的实例接收重复的消息（除非需要这种行为，这是不寻常的）。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="partitioning" href="#partitioning"></a> 28.6分区支持</h2></div></div></div><p>Spring Cloud Stream支持在给定应用程序的多个实例之间对数据进行分区。在分区方案中，物理通信介质（例如代理主题）被视为结构化为多个分区。一个或多个生产者应用程序实例将数据发送到多个消费者应用程序实例，并确保由共同特征标识的数据由同一消费者实例处理。</p><p>Spring Cloud Stream提供了一种通用抽象，用于以统一的方式实现分区处理用例。因此，无论代理本身是自然分区（例如，Kafka）还是非自然分区（例如，RabbitMQ），都可以使用分区。</p><div class="figure"><a name="d0e8461" href="#d0e8461"></a><p class="title"><b>图28.4。Spring Cloud Stream分区</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/SCSt-partitioning.png" align="middle" alt="SCSt分区"></div></div></div><br class="figure-break"><p>分区是有状态处理中的关键概念，对于确保所有相关数据都一起处理，分区是至关重要的（出于性能或一致性方面的考虑）。例如，在带时间窗的平均计算示例中，重要的是，来自任何给定传感器的所有测量都应由同一应用实例处理。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>要设置分区处理方案，必须同时配置数据产生端和数据消耗端。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_programming_model" href="#_programming_model"></a> 29。程式设计模型</h2></div></div></div><p>要了解编程模型，您应该熟悉以下核心概念：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>目标绑定器：</strong></span>负责与外部消息传递系统集成的组件。</li><li class="listitem"><span class="strong"><strong>目标绑定：</strong></span>外部消息传递系统和应用程序之间提供的桥梁（消息的<span class="emphasis"><em>生产者</em></span>和<span class="emphasis"><em>消费者</em></span> ）（由<span class="strong"><strong>目标绑定</strong></span>程序创建）。</li><li class="listitem"><span class="strong"><strong>消息：</strong></span>生产者和消费者使用的规范数据结构，用于与目标绑定程序（以及通过外部消息传递系统进行的其他应用程序）进行通信。</li></ul></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/SCSt-overview.png" align="middle" alt="SCSt概述"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_destination_binders" href="#_destination_binders"></a> 29.1目标绑定器</h2></div></div></div><p>Destination Binders是Spring Cloud Stream的扩展组件，负责提供必要的配置和实现以促进与外部消息传递系统的集成。这种集成负责连接性，委派以及与生产者和消费者之间的消息的路由以及路由，数据类型转换，用户代码的调用等等。</p><p>粘合剂要承担很多样板工作，否则这些工作就落在了您的肩膀上。但是，要实现这一点，活页夹仍然需要用户提供的一些帮助，包括一些简单但必需的说明，这些说明通常以某种类型的配置形式出现。</p><p>尽管讨论所有可用的绑定器和绑定配置选项（本手册的其余部分全面介绍它们）不在本节的讨论范围之内，但<span class="emphasis"><em>目标绑定</em></span>确实需要特别注意。下一节将详细讨论。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_destination_bindings" href="#_destination_bindings"></a> 29.2目标绑定</h2></div></div></div><p>如前所述， <span class="emphasis"><em>目标绑定</em></span>提供了外部消息传递系统与应用程序提供的<span class="emphasis"><em>生产者</em></span>和<span class="emphasis"><em>消费者</em></span>之间的桥梁。</p><p>将@EnableBinding批注应用于应用程序的一个配置类可定义目标绑定。的<code class="literal">@EnableBinding</code>注释本身是使用元注释的<code class="literal">@Configuration</code>并触发Spring Cloud Stream基础架构的配置。</p><p>以下示例显示了一个已完全配置且可以正常运行的Spring Cloud Stream应用程序，该应用程序从以下位置接收消息的有效负载： <code class="literal">INPUT</code>作为目的地<code class="literal">String</code>类型（请参阅<a class="xref" href="#content-type-management" title="32。内容类型协商">第32章， <i>内容类型协商</i></a>部分），将其记录到控制台并将其发送到控制台。 <code class="literal">OUTPUT</code>转换为大写字母后的目标。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyApplication {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(MyApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
	}

	<em><span class="hl-annotation" style="color: gray">@StreamListener(Processor.INPUT)</span></em>
	<em><span class="hl-annotation" style="color: gray">@SendTo(Processor.OUTPUT)</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String handle(String value) {
		System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Received: "</span> + value);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value.toUpperCase();
	}
}</pre><p>如您所见<code class="literal">@EnableBinding</code>批注可以将一个或多个接口类作为参数。这些参数称为<span class="emphasis"><em>绑定</em></span> ，它们包含表示<span class="emphasis"><em>可绑定组件的</em></span>方法。这些组件通常是消息通道（请参阅<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-messaging.html" target="_top">Spring Messaging</a> ），用于基于通道的活页夹（例如Rabbit，Kafka和其他）。但是，其他类型的绑定可以为相应技术的本机功能提供支持。例如，Kafka Streams活页夹（以前称为KStream）允许直接绑定到Kafka Streams（有关更多详细信息，请参见<a class="link" href="https://docs.spring.io/autorepo/docs/spring-cloud-stream-binder-kafka-docs/1.1.0.M1/reference/htmlsingle/" target="_top">Kafka Streams</a> ）。</p><p>Spring Cloud Stream已经为典型的消息交换合同提供了<span class="emphasis"><em>绑定</em></span>接口，其中包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>水槽：</strong></span>识别由提供来自该消息所消耗的目的地为所述消息用户的合同。</li><li class="listitem"><span class="strong"><strong>源：</strong></span>通过提供将生成的消息发送到的目的地来标识消息生产者的合同。</li><li class="listitem"><span class="strong"><strong>处理器：</strong></span>通过公开两个允许使用和产生消息的目的地，封装了接收器和源协定。</li></ul></div><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Sink {

  String INPUT = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"input"</span>;

  <em><span class="hl-annotation" style="color: gray">@Input(Sink.INPUT)</span></em>
  SubscribableChannel input();
}</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Source {

  String OUTPUT = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"output"</span>;

  <em><span class="hl-annotation" style="color: gray">@Output(Source.OUTPUT)</span></em>
  MessageChannel output();
}</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Processor <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Source, Sink {}</pre><p>尽管前面的示例满足了大多数情况，但是您也可以通过定义自己的绑定接口和使用来定义自己的合同<code class="literal">@Input</code>和<code class="literal">@Output</code>注释以标识实际的<span class="emphasis"><em>可绑定组件</em></span> 。</p><p>例如：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Barista {

    <em><span class="hl-annotation" style="color: gray">@Input</span></em>
    SubscribableChannel orders();

    <em><span class="hl-annotation" style="color: gray">@Output</span></em>
    MessageChannel hotDrinks();

    <em><span class="hl-annotation" style="color: gray">@Output</span></em>
    MessageChannel coldDrinks();
}</pre><p>使用上例中显示的接口作为参数<code class="literal">@EnableBinding</code>触发三个绑定通道的创建<code class="literal">orders</code> ， <code class="literal">hotDrinks</code>和<code class="literal">coldDrinks</code> ， 分别。</p><p>您可以根据需要提供任意数量的绑定接口，作为<code class="literal">@EnableBinding</code>注释，如以下示例所示：</p><pre class="programlisting">@EnableBinding(value = { Orders.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Payment.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> })</pre><p>在Spring Cloud Stream中，可绑定<code class="literal">MessageChannel</code>组件是Spring Messaging <code class="literal">MessageChannel</code> （对于出站）及其扩展名， <code class="literal">SubscribableChannel</code> ，（用于入站）。</p><p><span class="strong"><strong>可轮询的目标绑定</strong></span></p><p>尽管前面描述的绑定支持基于事件的消息使用，但是有时您需要更多控制，例如使用率。</p><p>从2.0版开始，您现在可以绑定可轮询的使用者：</p><p>以下示例显示了如何绑定可轮询的使用者：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> PolledBarista {

    <em><span class="hl-annotation" style="color: gray">@Input</span></em>
    PollableMessageSource orders();
	. . .
}</pre><p>在这种情况下， <code class="literal">PollableMessageSource</code>绑定到<code class="literal">orders</code> “渠道”。有关更多详细信息<a class="xref" href="#spring-cloud-streams-overview-using-polled-consumers" title="29.3.5 Using Polled Consumers">，</a>请参见<a class="xref" href="#spring-cloud-streams-overview-using-polled-consumers" title="29.3.5使用轮询的使用者">第29.3.5节“使用轮询的使用者”</a> 。</p><p><span class="strong"><strong>自定义频道名称</strong></span></p><p>通过使用<code class="literal">@Input</code>和<code class="literal">@Output</code>注释，您可以为频道指定自定义的频道名称，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Barista {
    <em><span class="hl-annotation" style="color: gray">@Input("inboundOrders")</span></em>
    SubscribableChannel orders();
}</pre><p>在前面的示例中，创建的绑定通道被命名为<code class="literal">inboundOrders</code> 。</p><p>通常，您无需直接访问单个通道或绑定（然后通过<code class="literal">@EnableBinding</code>注解）。但是，您有时可能会遇到诸如测试或其他极端情况的情况。</p><p>除了为每个绑定生成通道并将其注册为Spring Bean之外，Spring Cloud Stream还为每个绑定接口生成一个实现该接口的bean。这意味着您可以通过在应用程序中自动进行接线来访问表示绑定或各个通道的接口，如以下两个示例所示：</p><p><span class="emphasis"><em>自动接线绑定界面</em></span></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowire</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Source source

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> sayHello(String name) {
    source.output().send(MessageBuilder.withPayload(name).build());
}</pre><p><span class="emphasis"><em>自动连线个别频道</em></span></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowire</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MessageChannel output;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> sayHello(String name) {
    output.send(MessageBuilder.withPayload(name).build());
}</pre><p>您也可以使用标准的Spring <code class="literal">@Qualifier</code>注释，用于自定义渠道名称或需要特别命名的渠道的多渠道方案。</p><p>下面的示例演示如何以这种方式使用@Qualifier批注：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowire</span></em>
<em><span class="hl-annotation" style="color: gray">@Qualifier("myChannel")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MessageChannel output;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-producing-consuming-messages" href="#spring-cloud-stream-overview-producing-consuming-messages"></a> 29.3生产和消费消息</h2></div></div></div><p>您可以使用Spring Integration批注或Spring Cloud Stream本机批注编写Spring Cloud Stream应用程序。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_integration_support" href="#_spring_integration_support"></a> 29.3.1 Spring集成支持</h3></div></div></div><p>Spring Cloud Stream建立在<a class="link" href="http://www.enterpriseintegrationpatterns.com/" target="_top">Enterprise Integration Patterns</a>定义的概念和模式的基础上，并依赖于其内部实现，该内部实现依赖于Spring项目组合中已建立且流行的Enterprise Integration Patterns实现： <a class="link" href="https://projects.spring.io/spring-integration/" target="_top">Spring Integration</a>框架。</p><p>因此，它自然支持Spring Integration已经建立的基础，语义和配置选项。</p><p>例如，您可以附加一个<code class="literal">Source</code>到<code class="literal">MessageSource</code>并使用熟悉的<code class="literal">@InboundChannelAdapter</code>注释，如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TimerSource {

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = "10", maxMessagesPerPoll = "1"))</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageSource&lt;String&gt; timerMessageSource() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> () -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello Spring Cloud Stream"</span>);
  }
}</pre><p>同样，可以在提供<span class="emphasis"><em>处理器</em></span>绑定协定的消息处理程序方法的实现时，使用@Transformer或@ServiceActivator，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TransformProcessor {
  <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object transform(String message) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> message.toUpperCase();
  }
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>尽管这可能会略过一些，但重要的是要了解，当您使用<code class="literal">@StreamListener</code>注解，使用发布-订阅模型。每种方法都带有注释<code class="literal">@StreamListener</code>收到自己的消息副本，每个消息都有自己的使用者组。但是，如果您通过使用Spring Integration批注（例如， <code class="literal">@Aggregator</code> ， <code class="literal">@Transformer</code> ， 要么<code class="literal">@ServiceActivator</code> ），则它们在竞争模型中消费。没有为每个订阅创建单独的消费者组。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_streamlistener_annotation" href="#_using_streamlistener_annotation"></a> 29.3.2使用@StreamListener注释</h3></div></div></div><p>作为对其Spring Integration支持的补充，Spring Cloud Stream提供了自己的<code class="literal">@StreamListener</code>注释，其模仿其他Spring Messaging注释（ <code class="literal">@MessageMapping</code> ， <code class="literal">@JmsListener</code> ， <code class="literal">@RabbitListener</code> ，以及其他），并提供便利，例如基于内容的路由等。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> VoteHandler {

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  VotingService votingService;

  <em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handle(Vote vote) {
    votingService.record(vote);
  }
}</pre><p>与其他Spring Messaging方法一样，方法参数可以用注释<code class="literal">@Payload</code> ， <code class="literal">@Headers</code>和<code class="literal">@Header</code> 。</p><p>对于返回数据的方法，必须使用<code class="literal">@SendTo</code>注释，用于指定方法返回的数据的输出绑定目标，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TransformProcessor {

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  VotingService votingService;

  <em><span class="hl-annotation" style="color: gray">@StreamListener(Processor.INPUT)</span></em>
  <em><span class="hl-annotation" style="color: gray">@SendTo(Processor.OUTPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> VoteResult handle(Vote vote) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> votingService.record(vote);
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_streamlistener_for_content_based_routing" href="#_using_streamlistener_for_content_based_routing"></a> 29.3.3使用@StreamListener进行基于内容的路由</h3></div></div></div><p>Spring Cloud Stream支持将消息调度到带有注释的多个处理程序方法<code class="literal">@StreamListener</code>根据条件。</p><p>为了有资格支持条件分派，一种方法必须满足以下条件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">它不能返回值。</li><li class="listitem">它必须是单独的消息处理方法（不支持反应性API方法）。</li></ul></div><p>该条件由SpEL表达式在<code class="literal">condition</code>注释的参数，并为每个消息评估。所有与条件匹配的处理程序都在同一线程中调用，并且不必假设调用的顺序。</p><p>在以下示例中<code class="literal">@StreamListener</code>在具有分派条件的情况下，所有带有标头的消息<code class="literal">type</code>具有价值<code class="literal">bogey</code>派遣到<code class="literal">receiveBogey</code>方法，以及所有带有标头的消息<code class="literal">type</code>具有价值<code class="literal">bacall</code>派遣到<code class="literal">receiveBacall</code>方法。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TestPojoWithAnnotatedArguments {

    <em><span class="hl-annotation" style="color: gray">@StreamListener(target = Sink.INPUT, condition = "headers['type']=='bogey'")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> receiveBogey(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> BogeyPojo bogeyPojo) {
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle the message</span>
    }

    <em><span class="hl-annotation" style="color: gray">@StreamListener(target = Sink.INPUT, condition = "headers['type']=='bacall'")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> receiveBacall(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> BacallPojo bacallPojo) {
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle the message</span>
    }
}</pre><p><span class="strong"><strong>内容上下文中的内容类型协商<code class="literal">condition</code></strong></span></p><p>重要的是要了解使用基于内容的路由背后的一些机制<code class="literal">condition</code>的论点<code class="literal">@StreamListener</code> ，尤其是在整个消息类型的上下文中。如果您在继续之前熟悉<a class="xref" href="#content-type-management" title="32。内容类型协商">第32章， <i>内容类型协商</i> ，</a>也可能会有所帮助。</p><p>请考虑以下情形：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CatsAndDogs {

    <em><span class="hl-annotation" style="color: gray">@StreamListener(target = Sink.INPUT, condition = "payload.class.simpleName=='Dog'")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> bark(Dog dog) {
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle the message</span>
    }

    <em><span class="hl-annotation" style="color: gray">@StreamListener(target = Sink.INPUT, condition = "payload.class.simpleName=='Cat'")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> purr(Cat cat) {
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle the message</span>
    }
}</pre><p>前面的代码是完全有效的。它可以毫无问题地进行编译和部署，但是永远不会产生您期望的结果。</p><p>这是因为您正在测试的东西在您期望的状态下尚不存在。这是因为消息的有效负载尚未从有线格式转换为（ <code class="literal">byte[]</code> ）为所需的类型。换句话说，它尚未经过<a class="xref" href="#content-type-management" title="32。内容类型协商">第32章， <i>内容类型协商</i></a>中描述的类型转换过程。</p><p>因此，除非您使用SPeL表达式来评估原始数据（例如，字节数组中第一个字节的值），否则请使用基于消息标头的表达式（例如<code class="literal">condition = "headers['type']=='dog'"</code> ）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>目前，通过<code class="literal">@StreamListener</code>仅基于通道的绑定器（不支持反应式编程）支持条件。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_cloud_function" href="#_spring_cloud_function"></a> 29.3.4 Spring Cloud Function支持</h3></div></div></div><p>从Spring Cloud Stream v2.1开始，用于定义<span class="emphasis"><em>流处理程序</em></span>和<span class="emphasis"><em>源的</em></span>另一种选择是使用对<a class="link" href="https://cloud.spring.io/spring-cloud-function/" target="_top">Spring Cloud Function的</a>内置支持，其中可以将它们表示为类型的Bean <code class="literal">java.util.function.[Supplier/Function/Consumer]</code> 。</p><p>要指定哪个功能bean绑定到绑定公开的外部目标，您必须提供<code class="literal">spring.cloud.stream.function.definition</code>属性。</p><p>这是Processor应用程序将消息处理程序公开为的示例<code class="literal">java.util.function.Function</code></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyFunctionBootApp {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(MyFunctionBootApp.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"--spring.cloud.stream.function.definition=toUpperCase"</span>);
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; toUpperCase() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> s -&gt; s.toUpperCase();
	}
}</pre><p>在上面，我们只定义了一个类型为的bean <code class="literal">java.util.function.Function</code>调用<span class="emphasis"><em>toUpperCase</em></span>并将其标识为要用作消息处理程序的bean，其“输入”和“输出”必须绑定到Processor绑定公开的外部目标。</p><p>以下是支持源，处理器和接收器的简单功能应用程序的示例。</p><p>这是定义为<code class="literal">java.util.function.Supplier</code></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SourceFromSupplier {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(SourceFromSupplier.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"--spring.cloud.stream.function.definition=date"</span>);
	}
	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Supplier&lt;Date&gt; date() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> () -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Date(<span class="hl-number">12345L</span>);
	}
}</pre><p>这是定义为<code class="literal">java.util.function.Function</code></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ProcessorFromFunction {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(ProcessorFromFunction.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"--spring.cloud.stream.function.definition=toUpperCase"</span>);
	}
	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; toUpperCase() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> s -&gt; s.toUpperCase();
	}
}</pre><p>这是一个定义为<code class="literal">java.util.function.Consumer</code></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkFromConsumer {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(SinkFromConsumer.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"--spring.cloud.stream.function.definition=sink"</span>);
	}
	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Consumer&lt;String&gt; sink() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> System.out::println;
	}
}</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_functional_composition" href="#_functional_composition"></a>功能组成</h4></div></div></div><p>使用此编程模型，您还可以从功能组合中受益，在该功能组合中，您可以从一组简单的函数动态组成复杂的处理程序。作为示例，让我们将以下函数bean添加到上面定义的应用程序中</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; wrapInQuotes() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> s -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\""</span> + s + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\""</span>;
}</pre><p>并修改<code class="literal">spring.cloud.stream.function.definition</code>属性，以反映您打算从“ toUpperCase”和“ wrapInQuotes”组成新功能的意图。为此，Spring Cloud Function允许您使用<code class="literal">|</code> （管道）符号。因此，完成我们的示例，我们的属性现在将如下所示：</p><pre class="programlisting">&#8212;spring.cloud.stream.function.definition=toUpperCase|wrapInQuotes</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-streams-overview-using-polled-consumers" href="#spring-cloud-streams-overview-using-polled-consumers"></a> 29.3.5使用轮询的使用者</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_overview" href="#_overview"></a>总览</h4></div></div></div><p>使用受调查的消费者时，您可以对<code class="literal">PollableMessageSource</code>一经请求。考虑以下受调查消费者的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> PolledConsumer {

    <em><span class="hl-annotation" style="color: gray">@Input</span></em>
    PollableMessageSource destIn();

    <em><span class="hl-annotation" style="color: gray">@Output</span></em>
    MessageChannel destOut();

}</pre><p>给定上一个示例中的受调查消费者，您可以按以下方式使用它：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ApplicationRunner poller(PollableMessageSource destIn, MessageChannel destOut) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> args -&gt; {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (someCondition()) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (!destIn.poll(m -&gt; {
                    String newPayload = ((String) m.getPayload()).toUpperCase();
                    destOut.send(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GenericMessage&lt;&gt;(newPayload));
                })) {
                    Thread.sleep(<span class="hl-number">1000</span>);
                }
            }
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">catch</span> (Exception e) {
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// handle failure</span>
            }
        }
    };
}</pre><p>的<code class="literal">PollableMessageSource.poll()</code>方法需要<code class="literal">MessageHandler</code>参数（通常是lambda表达式，如此处所示）。它返回<code class="literal">true</code>如果消息已接收并成功处理。</p><p>与消息驱动的消费者一样，如果<code class="literal">MessageHandler</code>引发异常，消息将发布到错误通道，如<span class="quote">“ <span class="quote"><a class="xref" href="#">???”中所述</a></span> ”</span> 。</p><p>通常， <code class="literal">poll()</code>当该方法确认消息时<code class="literal">MessageHandler</code>退出。如果该方法异常退出，则该消息将被拒绝（不重新排队），但请参阅<a class="xref" href="#polled-errors" title="处理错误">“处理错误”一节</a> 。您可以通过对确认负责来覆盖该行为，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ApplicationRunner poller(PollableMessageSource dest1In, MessageChannel dest2Out) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> args -&gt; {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (someCondition()) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (!dest1In.poll(m -&gt; {
                StaticMessageHeaderAccessor.getAcknowledgmentCallback(m).noAutoAck();
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// e.g. hand off to another thread which can perform the ack</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// or acknowledge(Status.REQUEUE)</span>

            })) {
                Thread.sleep(<span class="hl-number">1000</span>);
            }
        }
    };
}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>你必须<code class="literal">ack</code> （要么<code class="literal">nack</code> ）消息，以避免资源泄漏。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>一些消息传递系统（例如Apache Kafka）在日志中维护简单的偏移量。如果交付失败并重新排队<code class="literal">StaticMessageHeaderAccessor.getAcknowledgmentCallback(m).acknowledge(Status.REQUEUE);</code> ，任何以后成功确认的消息都会重新发送。</p></td></tr></tbody></table></div><p>还有一个超载<code class="literal">poll</code>方法，其定义如下：</p><pre class="programlisting">poll(MessageHandler handler, ParameterizedTypeReference&lt;?&gt; type)</pre><p>的<code class="literal">type</code>是一个转换提示，它允许转换传入的消息有效负载，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> result = pollableSource.poll(received -&gt; {
			Map&lt;String, Foo&gt; payload = (Map&lt;String, Foo&gt;) received.getPayload();
            ...

		}, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ParameterizedTypeReference&lt;Map&lt;String, Foo&gt;&gt;() {});</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="polled-errors" href="#polled-errors"></a>处理错误</h4></div></div></div><p>默认情况下，为可轮询源配置了一个错误通道。如果回调引发异常，则<code class="literal">ErrorMessage</code>发送到错误通道（ <code class="literal"><destination>.<group>.errors</code> ）;此错误通道也已桥接到全局Spring Integration <code class="literal">errorChannel</code> 。</p><p>您可以使用<code class="literal">@ServiceActivator</code>处理错误；如果没有订阅，则将仅记录错误并确认消息成功。如果错误通道服务激活器引发异常，则该消息将被拒绝（默认情况下），并且不会重新发送。如果服务激活器抛出一个<code class="literal">RequeueCurrentMessageException</code> ，该消息将在代理处重新排队，并在随后的轮询中再次检索。</p><p>如果听众抛出一个<code class="literal">RequeueCurrentMessageException</code>如上所述，直接将消息重新排队，并且不会将其发送到错误通道。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-error-handling" href="#spring-cloud-stream-overview-error-handling"></a> 29.4错误处理</h2></div></div></div><p>错误会发生，Spring Cloud Stream提供了几种灵活的机制来处理它们。错误处理有两种形式：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>应用程序：</strong></span>错误处理在应用程序（自定义错误处理程序）中完成。</li><li class="listitem"><span class="strong"><strong>系统：</strong></span>错误处理委托给联编程序（重新排队，DL和其他）。请注意，这些技术取决于绑定程序的实现和底层消息传递中间件的功能。</li></ul></div><p>Spring Cloud Stream使用<a class="link" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a>库来促进成功的消息处理。有关更多详细信息<a class="xref" href="#_retry_template" title="29.4.3 Retry Template">，</a>请参见<a class="xref" href="#_retry_template" title="29.4.3重试模板">第29.4.3节“重试模板”</a> 。但是，当所有操作失败时，消息处理程序引发的异常将传播回绑定程序。那时，活页夹调用自定义错误处理程序或将错误传达回消息传递系统（重新排队，DLQ等）。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_application_error_handling" href="#_application_error_handling"></a> 29.4.1应用程序错误处理</h3></div></div></div><p>有两种类型的应用程序级错误处理。可以在每个绑定订阅中处理错误，或者全局处理程序可以处理所有绑定订阅错误。让我们查看详细信息。</p><div class="figure"><a name="d0e9098" href="#d0e9098"></a><p class="title"><b>图29.1具有自定义和全局错误处理程序的Spring Cloud Stream Sink应用程序</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/custom_vs_global_error_channels.png" align="middle" alt="自定义与全局错误通道"></div></div></div><br class="figure-break"><p>对于每个输入绑定，Spring Cloud Stream创建具有以下语义的专用错误通道<code class="literal"><destinationName>.errors</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal"><destinationName></code>由绑定的名称组成（例如<code class="literal">input</code> ）和组名（例如<code class="literal">myGroup</code> ）。</p></td></tr></tbody></table></div><p>考虑以下：</p><pre class="programlisting">spring.cloud.stream.bindings.input.group=myGroup</pre><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// destination name 'input.myGroup'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handle(Person value) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throw</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RuntimeException(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"BOOM!"</span>);
}

<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = Processor.INPUT + ".myGroup.errors")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//channel name 'input.myGroup.errors'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> error(Message&lt;?&gt; message) {
	System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Handling ERROR: "</span> + message);
}</pre><p>在前面的示例中，目标名称为<code class="literal">input.myGroup</code>专用错误通道名称为<code class="literal">input.myGroup.errors</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>@StreamListener批注的使用专门用于定义桥接内部通道和外部目标的绑定。鉴于特定于目标的错误通道没有关联的外部目标，因此此类通道是Spring Integration（SI）的特权。这意味着必须使用SI处理程序注释之一（即@ ServiceActivator，@ Transformer等）定义用于此类目标的处理程序。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果<code class="literal">group</code>未指定使用匿名组（类似<code class="literal">input.anonymous.2K37rb06Q6m2r51-SPIDDQ</code> ），不适合用于错误处理方案，因为在创建目标之前，您不知道它将是什么。</p></td></tr></tbody></table></div><p>另外，如果您绑定到现有目的地，例如：</p><pre class="programlisting">spring.cloud.stream.bindings.input.destination=myFooDestination
spring.cloud.stream.bindings.input.group=myGroup</pre><p>完整的目的地名称是<code class="literal">myFooDestination.myGroup</code>然后专用错误通道名称是<code class="literal">myFooDestination.myGroup.errors</code> 。</p><p>回到例子...</p><p>的<code class="literal">handle(..)</code>方法，该方法订阅名为<code class="literal">input</code> ，引发异常。给定错误通道的订阅者<code class="literal">input.myGroup.errors</code>所有错误消息均由该订户处理。</p><p>如果您有多个绑定，则可能需要一个错误处理程序。通过将每个单独的错误通道桥接到命名通道，Spring Cloud Stream自动为<span class="emphasis"><em>全局错误通道</em></span>提供支持<code class="literal">errorChannel</code> ，允许单个订阅者处理所有错误，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@StreamListener("errorChannel")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> error(Message&lt;?&gt; message) {
	System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Handling ERROR: "</span> + message);
}</pre><p>如果错误处理逻辑相同，则与哪个处理程序产生错误无关，这可能是一个方便的选择。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_system_error_handling" href="#_system_error_handling"></a> 29.4.2系统错误处理</h3></div></div></div><p>系统级错误处理意味着将错误传递回消息传递系统，并且鉴于并非每个消息传递系统都相同，因此各个粘合剂的功能可能有所不同。</p><p>也就是说，在本节中，我们解释了系统级错误处理背后的一般思想，并以Rabbit绑定程序为例。注意：尽管某些配置属性确实有所不同，但Kafka活页夹提供了类似的支持。另外，有关更多详细信息和配置选项，请参见各个活页夹的文档。</p><p>如果未配置内部错误处理程序，则错误将传播到绑定程序，而绑定程序随后会将这些错误传播回消息传递系统。根据消息传递系统的功能，这样的系统可能会<span class="emphasis"><em>丢弃</em></span>该消息， <span class="emphasis"><em>重新排队</em></span>该消息以进行重新处理或<span class="emphasis"><em>将失败的消息发送给DLQ</em></span> 。 Rabbit和Kafka都支持这些概念。但是，其他联编程序可能没有，因此请参阅您单独的联编程序的文档，以获取有关受支持的系统级错误处理选项的详细信息。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_drop_failed_messages" href="#_drop_failed_messages"></a>删除失败的消息</h4></div></div></div><p>默认情况下，如果未提供其他系统级配置，则消息传递系统将丢弃失败的消息。尽管在某些情况下可以接受，但在大多数情况下是不可接受的，我们需要某种恢复机制来避免消息丢失。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_dlq_dead_letter_queue" href="#_dlq_dead_letter_queue"></a> DLQ-死信队列</h4></div></div></div><p>DLQ允许将失败的消息发送到特殊目标： <span class="emphasis"><em>-Dead Letter Queue</em></span> 。</p><p>配置后，失败的消息将发送到此目标，以进行后续的重新处理或审核与对帐。</p><p>例如，继续前面的示例，并使用Rabbit活页夹设置DLQ，您需要设置以下属性：</p><pre class="programlisting">spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true</pre><p>请记住，在上述属性中， <code class="literal">input</code>对应于输入目标绑定的名称。的<code class="literal">consumer</code>表示它是消费者财产，并且<code class="literal">auto-bind-dlq</code>指示绑定程序为以下内容配置DLQ <code class="literal">input</code>目标，这将导致一个名为Rabbit的附加Rabbit队列<code class="literal">input.myGroup.dlq</code> 。</p><p>配置完成后，所有失败的消息都会通过错误消息路由到此队列，类似于以下内容：</p><pre class="programlisting">delivery_mode:	1
headers:
x-death:
count:	1
reason:	rejected
queue:	input.hello
time:	1522328151
exchange:
routing-keys:	input.myGroup
Payload {"name&#8221;:"Bob"}</pre><p>从上面可以看到，原始消息会保留下来，以供进一步操作。</p><p>但是，您可能已经注意到的一件事是，有关消息处理的原始问题的信息有限。例如，您看不到与原始错误相对应的堆栈跟踪。要获取有关原始错误的更多相关信息，您必须设置一个附加属性：</p><pre class="programlisting">spring.cloud.stream.rabbit.bindings.input.consumer.republish-to-dlq=true</pre><p>这样做会强制内部错误处理程序拦截错误消息并向其添加其他信息，然后再将其发布到DLQ。配置完成后，您可以看到错误消息包含与原始错误有关的更多信息，如下所示：</p><pre class="programlisting">delivery_mode:	2
headers:
x-original-exchange:
x-exception-message:	has an error
x-original-routingKey:	input.myGroup
x-exception-stacktrace:	org.springframework.messaging.MessageHandlingException: nested exception is
      org.springframework.messaging.MessagingException: has an error, failedMessage=GenericMessage [payload=byte[15],
      headers={amqp_receivedDeliveryMode=NON_PERSISTENT, amqp_receivedRoutingKey=input.hello, amqp_deliveryTag=1,
      deliveryAttempt=3, amqp_consumerQueue=input.hello, amqp_redelivered=false, id=a15231e6-3f80-677b-5ad7-d4b1e61e486e,
      amqp_consumerTag=amq.ctag-skBFapilvtZhDsn0k3ZmQg, contentType=application/json, timestamp=1522327846136}]
      at org.spring...integ...han...MethodInvokingMessageProcessor.processMessage(MethodInvokingMessageProcessor.java:107)
      at. . . . .
Payload {"name&#8221;:"Bob"}</pre><p>这有效地结合了应用程序级和系统级的错误处理，以进一步协助下游故障排除机制。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_re_queue_failed_messages" href="#_re_queue_failed_messages"></a>重新排队失败的消息</h4></div></div></div><p>如前所述，当前受支持的活页夹（Rabbit和Kafka）依赖<code class="literal">RetryTemplate</code>促进成功的消息处理。有关详细信息<a class="xref" href="#_retry_template" title="29.4.3 Retry Template">，</a>请参见<a class="xref" href="#_retry_template" title="29.4.3重试模板">第29.4.3节“重试模板”</a> 。但是，对于<code class="literal">max-attempts</code>属性设置为1，禁用消息的内部重新处理。在这一点上，您可以通过指示消息传递系统重新排队失败的消息来促进消息的重新处理（重试）。重新排队后，失败的消息将发送回原始处理程序，从本质上创建一个重试循环。</p><p>如果错误的性质与某些资源的偶发性但短期不可用有关，则此选项可能是可行的。</p><p>为此，必须设置以下属性：</p><pre class="programlisting">spring.cloud.stream.bindings.input.consumer.max-attempts=1
spring.cloud.stream.rabbit.bindings.input.consumer.requeue-rejected=true</pre><p>在前面的示例中， <code class="literal">max-attempts</code>设置为1实质上禁用内部重试，并且<code class="literal">requeue-rejected</code> （ <span class="emphasis"><em>重新排队拒绝消息的</em></span>缩写）设置为<code class="literal">true</code> 。设置后，失败的消息将重新提交给同一处理程序，并连续循环或直到处理程序抛出<code class="literal">AmqpRejectAndDontRequeueException</code>本质上允许您在处理程序本身内构建自己的重试逻辑。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_retry_template" href="#_retry_template"></a> 29.4.3重试模板</h3></div></div></div><p>的<code class="literal">RetryTemplate</code>是<a class="link" href="https://github.com/spring-projects/spring-retry" target="_top">Spring Retry</a>库的一部分。尽管超出了本文档的范围，无法涵盖本文档的所有功能。 <code class="literal">RetryTemplate</code> ，我们将提及以下与<code class="literal">RetryTemplate</code> ：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">maxAttempts</span></dt><dd><p class="simpara">处理消息的尝试次数。</p><p class="simpara">默认值：3</p></dd><dt><span class="term">backOffInitialInterval</span></dt><dd><p class="simpara">重试时的退避初始间隔。</p><p class="simpara">默认值1000毫秒。</p></dd><dt><span class="term">backOffMaxInterval</span></dt><dd><p class="simpara">最大退避间隔。</p><p class="simpara">默认值10000毫秒。</p></dd><dt><span class="term">backOffMultiplier</span></dt><dd><p class="simpara">退避乘数。</p><p class="simpara">默认值2.0。</p></dd><dt><span class="term">defaultRetryable</span></dt><dd><p class="simpara">侦听器是否抛出了未在列表中列出的异常<code class="literal">retryableExceptions</code>可重试。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">retryableExceptions</span></dt><dd><p class="simpara">键中Throwable类名称的映射，值中布尔值的映射。指定将要重试的那些异常（和子类）。另见<code class="literal">defaultRetriable</code> 。例： <code class="literal">spring.cloud.stream.bindings.input.consumer.retryable-exceptions.java.lang.IllegalStateException=false</code> 。</p><p class="simpara">默认值：空。</p></dd></dl></div><p>尽管上述设置足以满足大多数自定义要求，但它们可能无法满足某些复杂的要求，此时您可能希望提供自己的实例。 <code class="literal">RetryTemplate</code> 。为此，将其配置为应用程序配置中的Bean。应用程序提供的实例将覆盖框架提供的实例。另外，为避免冲突，您必须限定<code class="literal">RetryTemplate</code>您想被活页夹用作<code class="literal">@StreamRetryTemplate</code> 。例如，</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@StreamRetryTemplate</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RetryTemplate myRetryTemplate() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RetryTemplate();
}</pre><p>从上面的示例中可以看到，您不需要使用<code class="literal">@Bean</code>以来<code class="literal">@StreamRetryTemplate</code>是合格的<code class="literal">@Bean</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-reactive-programming-support" href="#spring-cloud-stream-overview-reactive-programming-support"></a> 29.5反应式编程支持</h2></div></div></div><p>Spring Cloud Stream还支持使用反应式API，将传入和传出的数据作为连续的数据流进行处理。可通过以下方式获得对反应式API的支持： <code class="literal">spring-cloud-stream-reactive</code> ，需要将其显式添加到您的项目中。</p><p>具有反应式API的编程模型是声明性的。您可以使用描述从入站数据流到出站数据流的功能转换的运算符，而不是指定每个消息的处理方式。</p><p>目前，Spring Cloud Stream仅支持<a class="link" href="https://projectreactor.io/" target="_top">Reactor API</a> 。将来，我们打算支持基于反应式流的更通用的模型。</p><p>反应式编程模型还使用<code class="literal">@StreamListener</code>用于设置反应性处理程序的注释。区别在于：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">的<code class="literal">@StreamListener</code>批注不能指定输入或输出，因为它们作为参数提供并从方法返回值。</li><li class="listitem">该方法的参数必须用注释<code class="literal">@Input</code>和<code class="literal">@Output</code> ，分别指示传入和传出数据流连接到哪个输入或输出。</li><li class="listitem">方法的返回值（如果有）用注释<code class="literal">@Output</code> ，指示应该将数据发送到的输入。</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>响应式编程支持需要Java 1.8。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>从Spring Cloud Stream 1.1.1和更高版本开始（从发布培训Brooklyn开始。SR2），反应式编程支持要求使用Reactor 3.0.4。发行及更高版本。较早的Reactor版本（包括3.0.1）。发布3.0.2。发布和3.0.3。不支持RELEASE）。
<code class="literal">spring-cloud-stream-reactive</code>可传递地检索正确的版本，但是项目结构可以管理版本的<code class="literal">io.projectreactor:reactor-core</code>到早期版本，尤其是在使用Maven时。对于使用Spring Initializr和Spring Boot 1.x生成的项目就是这种情况，该项目将Reactor版本覆盖为<code class="literal">2.0.8.RELEASE</code> 。在这种情况下，您必须确保发布了正确版本的工件。您可以通过添加直接依赖来实现<code class="literal">io.projectreactor:reactor-core</code>与版本<code class="literal">3.0.4.RELEASE</code>或更高版本的项目。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>当前，术语<span class="quote">“ <span class="quote">反应式</span> ”</span>的使用是指正在使用的反应式API，而不是指执行模型是反应式的（也就是说，绑定的端点仍使用“推”式而非“拉式”模型）。尽管通过使用Reactor提供了一些反压支持，但我们确实打算在将来的版本中通过将本地反应式客户端用于连接的中间件来完全支持反应式管道。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_reactor_based_handlers" href="#_reactor_based_handlers"></a> 29.5.1基于反应堆的处理程序</h3></div></div></div><p>基于Reactor的处理程序可以具有以下参数类型：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">对于带有注释的参数<code class="literal">@Input</code> ，它支持Reactor <code class="literal">Flux</code>类型。入站Flux的参数化遵循与处理单个消息相同的规则：它可以是整个<code class="literal">Message</code> ，一个POJO可以是<code class="literal">Message</code>有效负载或POJO，它是基于<code class="literal">Message</code>内容类型标头。提供了多个输入。</li><li class="listitem">对于带有注释的参数<code class="literal">Output</code> ，它支持<code class="literal">FluxSender</code>类型，将一个<code class="literal">Flux</code>该方法产生的输出。一般而言，仅在该方法可以具有多个输出时才建议将输出指定为参数。</li></ul></div><p>基于Reactor的处理程序支持以下类型的返回类型： <code class="literal">Flux</code> 。在这种情况下，必须使用<code class="literal">@Output</code> 。我们建议在单个输出时使用该方法的返回值<code class="literal">Flux</code>可用。</p><p>以下示例显示了基于Reactor的<code class="literal">Processor</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> UppercaseTransformer {

  <em><span class="hl-annotation" style="color: gray">@StreamListener</span></em>
  <em><span class="hl-annotation" style="color: gray">@Output(Processor.OUTPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Flux&lt;String&gt; receive(<em><span class="hl-annotation" style="color: gray">@Input(Processor.INPUT)</span></em> Flux&lt;String&gt; input) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> input.map(s -&gt; s.toUpperCase());
  }
}</pre><p>使用输出参数的同一处理器看起来像以下示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> UppercaseTransformer {

  <em><span class="hl-annotation" style="color: gray">@StreamListener</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> receive(<em><span class="hl-annotation" style="color: gray">@Input(Processor.INPUT)</span></em> Flux&lt;String&gt; input,
     <em><span class="hl-annotation" style="color: gray">@Output(Processor.OUTPUT)</span></em> FluxSender output) {
     output.send(input.map(s -&gt; s.toUpperCase()));
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_reactive_sources" href="#_reactive_sources"></a> 29.5.2反应源</h3></div></div></div><p>Spring Cloud Stream反应性支持还提供了通过以下方式创建反应性源的功能： <code class="literal">@StreamEmitter</code>注解。通过使用<code class="literal">@StreamEmitter</code>注解，可以将常规源转换为被动源。
<code class="literal">@StreamEmitter</code>是方法级别注释，用于将方法标记为使用以下方法声明的输出的发射器： <code class="literal">@EnableBinding</code> 。您不能使用<code class="literal">@Input</code>注释以及<code class="literal">@StreamEmitter</code> ，因为带有此批注标记的方法不会监听任何输入。而是标有<code class="literal">@StreamEmitter</code>产生输出。遵循与<code class="literal">@StreamListener</code> ， <code class="literal">@StreamEmitter</code>还允许使用灵活的方式<code class="literal">@Output</code>注释，具体取决于方法是否具有任何参数，返回类型和其他注意事项。</p><p>本节的其余部分包含使用<code class="literal">@StreamEmitter</code>各种样式的注释。</p><p>以下示例发出了<code class="literal">Hello, World</code>每毫秒发送一次消息并发布到Reactor <code class="literal">Flux</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HelloWorldEmitter {

  <em><span class="hl-annotation" style="color: gray">@StreamEmitter</span></em>
  <em><span class="hl-annotation" style="color: gray">@Output(Source.OUTPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Flux&lt;String&gt; emit() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Flux.intervalMillis(<span class="hl-number">1</span>)
            .map(l -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>);
  }
}</pre><p>在前面的示例中， <code class="literal">Flux</code>被发送到<code class="literal">Source</code> 。</p><p>下一个示例是<code class="literal">@StreamEmmitter</code>发送一个反应堆<code class="literal">Flux</code> 。而不是返回一个<code class="literal">Flux</code> ，以下方法使用<code class="literal">FluxSender</code>以编程方式发送<code class="literal">Flux</code>从来源：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HelloWorldEmitter {

  <em><span class="hl-annotation" style="color: gray">@StreamEmitter</span></em>
  <em><span class="hl-annotation" style="color: gray">@Output(Source.OUTPUT)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> emit(FluxSender output) {
    output.send(Flux.intervalMillis(<span class="hl-number">1</span>)
            .map(l -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>));
  }
}</pre><p>下一个示例在功能和样式上与上述代码段完全相同。但是，与其使用显式<code class="literal">@Output</code>方法上的注释，它使用方法参数上的注释。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HelloWorldEmitter {

  <em><span class="hl-annotation" style="color: gray">@StreamEmitter</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> emit(<em><span class="hl-annotation" style="color: gray">@Output(Source.OUTPUT)</span></em> FluxSender output) {
    output.send(Flux.intervalMillis(<span class="hl-number">1</span>)
            .map(l -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>));
  }
}</pre><p>本节的最后一个示例是使用Reactive Streams Publisher API并利用<a class="link" href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference" target="_top">Spring Integration Java DSL</a>对它的支持来编写反应源的另一种方式。的<code class="literal">Publisher</code>在下面的示例中仍然使用Reactor <code class="literal">Flux</code>在幕后，但是，从应用程序角度看，这对用户是透明的，并且只需要Reactive Streams和Java DSL即可进行Spring集成：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HelloWorldEmitter {

  <em><span class="hl-annotation" style="color: gray">@StreamEmitter</span></em>
  <em><span class="hl-annotation" style="color: gray">@Output(Source.OUTPUT)</span></em>
  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Publisher&lt;Message&lt;String&gt;&gt; emit() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> IntegrationFlows.from(() -&gt;
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>),
        e -&gt; e.poller(p -&gt; p.fixedDelay(<span class="hl-number">1</span>)))
        .toReactivePublisher();
  }
}</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-stream-overview-binders" href="#spring-cloud-stream-overview-binders"></a> 30岁黏合剂</h2></div></div></div><p>Spring Cloud Stream提供了一个Binder抽象，可用于连接到外部中间件上的物理目标。本节提供有关Binder SPI背后的主要概念，其主要组件以及特定于实现的详细信息。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_producers_and_consumers" href="#_producers_and_consumers"></a> 30.1生产者和消费者</h2></div></div></div><p>下图显示了生产者和消费者的一般关系：</p><div class="figure"><a name="d0e9629" href="#d0e9629"></a><p class="title"><b>图30.1。生产者和消费者</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/producers-consumers.png" align="middle" alt="生产者消费者"></div></div></div><br class="figure-break"><p>生产者是将消息发送到通道的任何组件。该通道可以通过以下方式绑定到外部消息代理： <code class="literal">Binder</code>该经纪人的实施。调用时<code class="literal">bindProducer()</code>方法，第一个参数是代理内目标的名称，第二个参数是生产者向其发送消息的本地通道实例，第三个参数包含将在适配器内使用的属性（例如分区键表达式）为该频道创建的。</p><p>使用者是从通道接收消息的任何组件。与生产者一样，消费者的渠道可以绑定到外部消息代理。调用时<code class="literal">bindConsumer()</code>方法，第一个参数是目标名称，第二个参数提供逻辑上的使用者组名称。由给定目标的消费者绑定表示的每个组都接收生产者发送到该目标的每条消息的副本（也就是说，它遵循常规的发布-订阅语义）。如果有多个使用相同组名绑定的使用者实例，那么消息将在这些使用者实例之间进行负载平衡，以便由生产者发送的每条消息仅在每个组中的单个使用者实例中被使用（也就是说，它遵循常规排队语义）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-binder-api" href="#spring-cloud-stream-overview-binder-api"></a> 30.2粘合剂SPI</h2></div></div></div><p>Binder SPI由许多接口，现成的实用程序类和发现策略组成，这些策略提供了用于连接到外部中间件的可插拔机制。</p><p>SPI的关键是<code class="literal">Binder</code>接口，这是一种将输入和输出连接到外部中间件的策略。以下清单显示了<code class="literal">Binder</code>接口：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> Binder&lt;T, C <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ConsumerProperties, P <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ProducerProperties&gt; {
    Binding&lt;T&gt; bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);

    Binding&lt;T&gt; bindProducer(String name, T outboundBindTarget, P producerProperties);
}</pre><p>该接口已参数化，提供了许多扩展点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">输入和输出绑定目标。从1.0版开始<code class="literal">MessageChannel</code>支持，但将来打算用作扩展点。</li><li class="listitem">扩展的使用者和生产者属性，允许特定的Binder实现添加可以以类型安全的方式支持的补充属性。</li></ul></div><p>典型的活页夹实现包括以下内容：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">实现<code class="literal">Binder</code>接口;</li><li class="listitem">春天<code class="literal">@Configuration</code>创建类型Bean的类<code class="literal">Binder</code>以及中间件连接基础结构。</li><li class="listitem"><p class="simpara">一种<code class="literal">META-INF/spring.binders</code>在类路径上找到的包含一个或多个绑定程序定义的文件，如以下示例所示：</p><pre class="screen">kafka:\
org.springframework.cloud.stream.binder.kafka.config.KafkaBinderConfiguration</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_binder_detection" href="#_binder_detection"></a> 30.3活页夹检测</h2></div></div></div><p>Spring Cloud Stream依赖于Binder SPI的实现来执行将通道连接到消息代理的任务。每个Binder实现通常都连接到一种消息传递系统。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_classpath_detection" href="#_classpath_detection"></a> 30.3.1类路径检测</h3></div></div></div><p>默认情况下，Spring Cloud Stream依靠Spring Boot的自动配置来配置绑定过程。如果在类路径上找到单个Binder实现，Spring Cloud Stream将自动使用它。例如，旨在仅绑定到RabbitMQ的Spring Cloud Stream项目可以添加以下依赖项：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-binder-rabbit<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>有关其他活页夹依赖项的特定Maven坐标，请参阅该活页夹实现的文档。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="multiple-binders" href="#multiple-binders"></a> 30.4类路径上的多个绑定器</h2></div></div></div><p>当类路径上存在多个绑定程序时，应用程序必须指示将哪个绑定程序用于每个通道绑定。每个活页夹配置都包含一个<code class="literal">META-INF/spring.binders</code>文件，这是一个简单的属性文件，如以下示例所示：</p><pre class="screen">rabbit:\
org.springframework.cloud.stream.binder.rabbit.config.RabbitServiceAutoConfiguration</pre><p>其他提供的活页夹实现（例如Kafka）也存在类似的文件，并且自定义活页夹实现也有望提供它们。关键字表示绑定程序实现的标识名，而该值是逗号分隔的配置类列表，每个配置类都包含一个且仅一个类型的bean定义<code class="literal">org.springframework.cloud.stream.binder.Binder</code> 。</p><p>活页夹选择可以使用<code class="literal">spring.cloud.stream.defaultBinder</code>属性（例如， <code class="literal">spring.cloud.stream.defaultBinder=rabbit</code> ）或单独配置，方法是在每个频道绑定上配置绑定器。例如，一个处理器应用程序（具有名为<code class="literal">input</code>和<code class="literal">output</code>从Kafka读取并写入RabbitMQ分别用于读取和写入）可以指定以下配置：</p><pre class="screen">spring.cloud.stream.bindings.input.binder=kafka
spring.cloud.stream.bindings.output.binder=rabbit</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="multiple-systems" href="#multiple-systems"></a> 30.5连接到多个系统</h2></div></div></div><p>默认情况下，活页夹共享应用程序的Spring Boot自动配置，以便创建在类路径上找到的每个活页夹的一个实例。如果您的应用程序应连接到多个相同类型的代理，则可以指定多个绑定程序配置，每个配置具有不同的环境设置。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>打开显式活页夹配置将完全禁用默认的活页夹配置过程。如果这样做，则必须在配置中包括所有正在使用的活页夹。打算透明地使用Spring Cloud Stream的框架可以创建可以按名称引用的绑定器配置，但它们不会影响默认的绑定器配置。为此，活页夹配置可能具有其<code class="literal">defaultCandidate</code>标记设置为false（例如， <code class="literal">spring.cloud.stream.binders.<configurationName>.defaultCandidate=false</code> ）。这表示独立于默认绑定程序配置过程而存在的配置。</p></td></tr></tbody></table></div><p>以下示例显示了连接到两个RabbitMQ代理实例的处理器应用程序的典型配置：</p><pre class="programlisting">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: thing1
          binder: rabbit1
        output:
          destination: thing2
          binder: rabbit2
      binders:
        rabbit1:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host1&gt;
        rabbit2:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: &lt;host2&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_binding_visualization_and_control" href="#_binding_visualization_and_control"></a> 30.6绑定可视化和控制</h2></div></div></div><p>从2.0版开始，Spring Cloud Stream支持通过Actuator端点进行绑定的可视化和控制。</p><p>从版本2.0执行器和Web开始，是可选的，您必须首先添加Web依赖项之一，然后手动添加执行器依赖项。下面的示例显示如何为Web框架添加依赖项：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
     <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
     <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-web<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>下面的示例演示如何为WebFlux框架添加依赖项：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-webflux<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>您可以添加执行器依赖项，如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-actuator<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>要在Cloud Foundry中运行Spring Cloud Stream 2.0应用，您必须添加<code class="literal">spring-boot-starter-web</code>和<code class="literal">spring-boot-starter-actuator</code>到类路径。否则，由于运行状况检查失败，该应用程序将无法启动。</p></td></tr></tbody></table></div><p>您还必须启用<code class="literal">bindings</code>通过设置以下属性来执行器端点： <code class="literal">--management.endpoints.web.exposure.include=bindings</code> 。</p><p>一旦满足这些先决条件。应用程序启动时，您应该在日志中看到以下内容：</p><pre class="literallayout">: Mapped "{[/actuator/bindings/{name}],methods=[POST]. . .
: Mapped "{[/actuator/bindings],methods=[GET]. . .
: Mapped "{[/actuator/bindings/{name}],methods=[GET]. . .</pre><p>要显示当前绑定，请访问以下URL：<code class="literal"><a class="link" href="http://<host>:<port>/actuator/bindings" target="_top">http://<host>:<port>/actuator/bindings</a></code></p><p>或者，要查看单个绑定，请访问类似于以下内容的URL之一：<code class="literal"><a class="link" href="http://<host>:<port>/actuator/bindings/myBindingName" target="_top">http://<host>:<port>/actuator/bindings/myBindingName</a></code></p><p>您还可以通过发布到同一URL来停止，开始，暂停和继续单个绑定，同时提供一个<code class="literal">state</code>参数为JSON，如以下示例所示：</p><p>curl -d'{“状态”：“已停止”}'-H“内容类型：应用程序/ json” -X POST <a class="link" href="javascript:void(0);" target="_top">http：// <host>： <port>/ actuator / bindings / myBindingName</port></host></a> curl -d'{“状态”：“开始“}” -H“内容类型：application / json” -X POST <a class="link" href="javascript:void(0);" target="_top">http：// <host>： <port>/ actuator / bindings / myBindingName</port></host></a> curl -d'{“ state”：“ PAUSED”}'-H“内容类型：application / json“ -X POST <a class="link" href="javascript:void(0);" target="_top">http：// <host>： <port>/ actuator / bindings / myBindingName</port></host></a> curl -d'{” state“：” RESUMED“}'-H” Content-Type：application / json“ -X POST <a class="link" href="javascript:void(0);" target="_top">http：// <host>： <port>/ actuator / bindings / myBindingName</port></host></a></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">PAUSED</code>和<code class="literal">RESUMED</code>仅当相应的活页夹及其底层技术支持它时，该文件才起作用。否则，您会在日志中看到警告消息。目前，只有Kafka活页夹支持<code class="literal">PAUSED</code>和<code class="literal">RESUMED</code>状态。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_binder_configuration_properties" href="#_binder_configuration_properties"></a> 30.7活页夹配置属性</h2></div></div></div><p>定制活页夹配置时，以下属性可用。这些属性通过<code class="literal">org.springframework.cloud.stream.config.BinderProperties</code></p><p>它们必须以<code class="literal">spring.cloud.stream.binders.<configurationName></code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">类型</span></dt><dd><p class="simpara">资料夹类型。它通常引用在类路径上找到的绑定器之一-特别是<code class="literal">META-INF/spring.binders</code>文件。</p><p class="simpara">默认情况下，它具有与配置名称相同的值。</p></dd><dt><span class="term">继承环境</span></dt><dd><p class="simpara">配置是否继承应用程序本身的环境。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">环境</span></dt><dd><p class="simpara">根可用于定制活页夹环境的一组属性。设置此属性后，在其中创建活页夹的上下文不是应用程序上下文的子级。该设置允许在粘合剂组分和应用组分之间完全分离。</p><p class="simpara">默认： <code class="literal">empty</code> 。</p></dd><dt><span class="term">defaultCandidate</span></dt><dd><p class="simpara">活页夹配置是被视为默认活页夹的候选者，还是仅在明确引用时才可以使用。此设置允许添加活页夹配置，而不会干扰默认处理。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd></dl></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_configuration_options" href="#_configuration_options"></a> 31。配置选项</h2></div></div></div><p>Spring Cloud Stream支持常规配置选项以及绑定和活页夹的配置。一些活页夹使附加的绑定属性支持特定于中间件的功能。</p><p>可以通过Spring Boot支持的任何机制将配置选项提供给Spring Cloud Stream应用程序。这包括应用程序参数，环境变量以及YAML或.properties文件。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_binding_service_properties" href="#_binding_service_properties"></a> 31.1绑定服务属性</h2></div></div></div><p>这些属性通过<code class="literal">org.springframework.cloud.stream.config.BindingServiceProperties</code></p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.instanceCount</span></dt><dd><p class="simpara">应用程序已部署实例的数量。必须在生产者端进行分区设置。如果使用RabbitMQ和Kafka，则必须在用户端设置<code class="literal">autoRebalanceEnabled=false</code> 。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">spring.cloud.stream.instanceIndex</span></dt><dd>应用程序的实例索引：来自的数字<code class="literal">0</code>至<code class="literal">instanceCount - 1</code> 。用于通过RabbitMQ和Kafka进行分区，如果<code class="literal">autoRebalanceEnabled=false</code> 。在Cloud Foundry中自动设置以匹配应用程序的实例索引。</dd><dt><span class="term">spring.cloud.stream.dynamic目的地</span></dt><dd><p class="simpara">可以动态绑定的目的地列表（例如，在动态路由方案中）。如果设置，则只能绑定列出的目的地。</p><p class="simpara">默认值：空（将任何目的地绑定）。</p></dd><dt><span class="term">spring.cloud.stream.defaultBinder</span></dt><dd><p class="simpara">如果配置了多个联编程序，则使用的默认联编程序。请参见<a class="link" href="#multiple-binders" title="30.4类路径上的多个绑定器">Classpath上的多个绑定器</a> 。</p><p class="simpara">默认值：空。</p></dd><dt><span class="term">spring.cloud.stream.overrideCloudConnectors</span></dt><dd><p class="simpara">仅当<code class="literal">cloud</code>配置文件处于活动状态，并且该应用程序提供了Spring Cloud Connector。如果属性是<code class="literal">false</code> （默认设置），绑定程序会检测合适的绑定服务（例如，在Cloud Foundry中为RabbitMQ绑定程序绑定的RabbitMQ服务）并将其用于创建连接（通常通过Spring Cloud Connectors）。设置为<code class="literal">true</code> ，此属性指示绑定程序完全忽略绑定的服务，并依赖于Spring Boot属性（例如，依赖于<code class="literal">spring.rabbitmq.*</code>环境中为RabbitMQ活页夹提供的属性）。<a class="link" href="#multiple-systems" title="30.5 Connecting to Multiple Systems">连接到多个系统时</a> ，此属性的典型用法是嵌套在自定义环境<a class="link" href="#multiple-systems" title="30.5连接到多个系统">中</a> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">spring.cloud.stream.bindingRetryInterval</span></dt><dd><p class="simpara">例如，当绑定器不支持后期绑定并且代理（例如，Apache Kafka）关闭时，重试绑定创建之间的间隔（以秒为单位）。将其设置为零可将此类情况视为致命情况，从而阻止应用程序启动。</p><p class="simpara">默认：<code class="literal">30</code></p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="binding-properties" href="#binding-properties"></a> 31.2绑定属性</h2></div></div></div><p>绑定属性通过以下格式提供<code class="literal">spring.cloud.stream.bindings.<channelName>.<property>=<value></code> 。的<code class="literal"><channelName></code>代表正在配置的通道的名称（例如， <code class="literal">output</code>为一个<code class="literal">Source</code> ）。</p><p>为了避免重复，Spring Cloud Stream支持以以下格式设置所有通道的值： <code class="literal">spring.cloud.stream.default.<property>=<value></code> 。</p><p>在避免重复使用扩展绑定属性时，应使用以下格式- <code class="literal">spring.cloud.stream.<binder-type>.default.<producer|consumer>.<property>=<value></code> 。</p><p>在下面的内容中，我们指出了我们省略了<code class="literal">spring.cloud.stream.bindings.<channelName>.</code>前缀，并只关注属性名称，前提是在运行时会包含前缀。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_common_binding_properties" href="#_common_binding_properties"></a> 31.2.1通用绑定属性</h3></div></div></div><p>这些属性通过<code class="literal">org.springframework.cloud.stream.config.BindingProperties</code></p><p>以下绑定属性可用于输入和输出绑定，并且必须使用前缀<code class="literal">spring.cloud.stream.bindings.<channelName>.</code> （例如， <code class="literal">spring.cloud.stream.bindings.input.destination=ticktock</code> ）。</p><p>可以使用<code class="literal">spring.cloud.stream.default</code>前缀（例如spring.cloud.stream.default.contentType = application / json`）。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">目的地</span></dt><dd>绑定的中间件上的通道的目标位置（例如，RabbitMQ交换或Kafka主题）。如果将通道绑定为使用者，则可以将其绑定到多个目标，并且目标名称可以指定为逗号分隔<code class="literal">String</code>价值观。如果未设置，则使用通道名称。此属性的默认值不能被覆盖。</dd><dt><span class="term">组</span></dt><dd><p class="simpara">渠道的消费群体。仅适用于入站绑定。请参阅<a class="link" href="#consumer-groups" title="28.4消费群体">消费者组</a> 。</p><p class="simpara">默认： <code class="literal">null</code> （表示匿名消费者）。</p></dd><dt><span class="term">内容类型</span></dt><dd><p class="simpara">频道的内容类型。请参见<span class="quote">“ <span class="quote"><a class="xref" href="#content-type-management" title="32。内容类型协商">第32章， <i>内容类型协商</i></a></span> ”</span> 。</p><p class="simpara">默认： <code class="literal">application/json</code> 。</p></dd><dt><span class="term">黏合剂</span></dt><dd><p class="simpara">此绑定使用的粘合剂。有关详细信息<span class="quote"><span class="quote"><a class="xref" href="#multiple-binders" title="30.4 Multiple Binders on the Classpath">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#multiple-binders" title="30.4类路径上的多个绑定器">第30.4节“类路径上的多个绑定器”</a></span> ”</span> 。</p><p class="simpara">默认： <code class="literal">null</code> （如果存在，则使用默认的活页夹）。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer_properties" href="#_consumer_properties"></a> 31.2.2消费者财产</h3></div></div></div><p>这些属性通过<code class="literal">org.springframework.cloud.stream.binder.ConsumerProperties</code></p><p>以下绑定属性仅可用于输入绑定，并且必须带有前缀<code class="literal">spring.cloud.stream.bindings.<channelName>.consumer.</code> （例如， <code class="literal">spring.cloud.stream.bindings.input.consumer.concurrency=3</code> ）。</p><p>可以使用<code class="literal">spring.cloud.stream.default.consumer</code>前缀（例如， <code class="literal">spring.cloud.stream.default.consumer.headerMode=none</code> ）。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">并发</span></dt><dd><p class="simpara">入站使用者的并发。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">分区的</span></dt><dd><p class="simpara">消费者是否从分区生产者那里接收数据。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">headerMode</span></dt><dd><p class="simpara">设置为<code class="literal">none</code> ，禁用输入的标头解析。仅对本身不支持消息头且需要消息头嵌入的消息中间件有效。当不支持本机头时，使用非Spring Cloud Stream应用程序中的数据时，此选项很有用。设置为<code class="literal">headers</code> ，它使用中间件的本机头机制。设置为<code class="literal">embeddedHeaders</code> ，它将标头嵌入到消息有效负载中。</p><p class="simpara">默认值：取决于活页夹的实现。</p></dd><dt><span class="term">maxAttempts</span></dt><dd><p class="simpara">如果处理失败，则尝试处理消息的次数（包括第一次）。调成<code class="literal">1</code>禁用重试。</p><p class="simpara">默认： <code class="literal">3</code> 。</p></dd><dt><span class="term">backOffInitialInterval</span></dt><dd><p class="simpara">重试时的退避初始间隔。</p><p class="simpara">默认： <code class="literal">1000</code> 。</p></dd><dt><span class="term">backOffMaxInterval</span></dt><dd><p class="simpara">最大退避间隔。</p><p class="simpara">默认： <code class="literal">10000</code> 。</p></dd><dt><span class="term">backOffMultiplier</span></dt><dd><p class="simpara">退避乘数。</p><p class="simpara">默认： <code class="literal">2.0</code> 。</p></dd><dt><span class="term">defaultRetryable</span></dt><dd><p class="simpara">侦听器是否抛出了未在列表中列出的异常<code class="literal">retryableExceptions</code>可重试。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">instanceIndex</span></dt><dd><p class="simpara">设置为大于零的值时，它允许自定义此使用者的实例索引（如果与<code class="literal">spring.cloud.stream.instanceIndex</code> ）。设置为负值时，默认为<code class="literal">spring.cloud.stream.instanceIndex</code> 。有关更多信息<span class="quote"><span class="quote"><a class="xref" href="#spring-cloud-stream-overview-instance-index-instance-count" title="34.2 Instance Index and Instance Count">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-instance-index-instance-count" title="34.2实例索引和实例计数">第34.2节“实例索引和实例计数”</a></span> ”</span> 。</p><p class="simpara">默认： <code class="literal">-1</code> 。</p></dd><dt><span class="term">instanceCount</span></dt><dd><p class="simpara">设置为大于零的值时，它允许自定义此使用者的实例计数（如果与<code class="literal">spring.cloud.stream.instanceCount</code> ）。设置为负值时，默认为<code class="literal">spring.cloud.stream.instanceCount</code> 。有关更多信息<span class="quote"><span class="quote"><a class="xref" href="#spring-cloud-stream-overview-instance-index-instance-count" title="34.2 Instance Index and Instance Count">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-instance-index-instance-count" title="34.2实例索引和实例计数">第34.2节“实例索引和实例计数”</a></span> ”</span> 。</p><p class="simpara">默认： <code class="literal">-1</code> 。</p></dd><dt><span class="term">retryableExceptions</span></dt><dd><p class="simpara">键中Throwable类名称的映射，值中布尔值的映射。指定将要重试的那些异常（和子类）。另见<code class="literal">defaultRetriable</code> 。例： <code class="literal">spring.cloud.stream.bindings.input.consumer.retryable-exceptions.java.lang.IllegalStateException=false</code> 。</p><p class="simpara">默认值：空。</p></dd><dt><span class="term">useNativeDecoding</span></dt><dd><p class="simpara">设置为<code class="literal">true</code> ，入站消息将直接由客户端库反序列化，该库必须进行相应配置（例如，设置适当的Kafka生产者值反序列化器）。使用此配置时，入站邮件解组不是基于<code class="literal">contentType</code>的绑定。使用本机解码时，生产者负责使用适当的编码器（例如，Kafka生产者值序列化程序）对出站消息进行序列化。此外，当使用本机编码和解码时， <code class="literal">headerMode=embeddedHeaders</code>属性将被忽略，并且标头未嵌入消息中。查看生产者财产<code class="literal">useNativeEncoding</code> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer_properties" href="#_producer_properties"></a> 31.2.3生产者属性</h3></div></div></div><p>这些属性通过<code class="literal">org.springframework.cloud.stream.binder.ProducerProperties</code></p><p>以下绑定属性仅可用于输出绑定，并且必须带有前缀<code class="literal">spring.cloud.stream.bindings.<channelName>.producer.</code> （例如， <code class="literal">spring.cloud.stream.bindings.input.producer.partitionKeyExpression=payload.id</code> ）。</p><p>可以使用前缀设置默认值<code class="literal">spring.cloud.stream.default.producer</code> （例如， <code class="literal">spring.cloud.stream.default.producer.partitionKeyExpression=payload.id</code> ）。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">partitionKeyExpression</span></dt><dd><p class="simpara">一个SpEL表达式，该表达式确定如何对出站数据进行分区。如果设置，或者<code class="literal">partitionKeyExtractorClass</code>设置后，将对该通道上的出站数据进行分区。 <code class="literal">partitionCount</code>必须将其设置为大于1的值才能生效。与互斥<code class="literal">partitionKeyExtractorClass</code> 。请参见<span class="quote">“ <span class="quote"><a class="xref" href="#partitioning" title="28.6分区支持">第28.6节“分区支持”</a></span> ”</span> 。</p><p class="simpara">默认值：null。</p></dd><dt><span class="term">partitionKeyExtractorClass</span></dt><dd><p class="simpara">一种<code class="literal">PartitionKeyExtractorStrategy</code>实施。如果设置，或者<code class="literal">partitionKeyExpression</code>设置后，将对该通道上的出站数据进行分区。 <code class="literal">partitionCount</code>必须将其设置为大于1的值才能生效。与互斥<code class="literal">partitionKeyExpression</code> 。请参见<span class="quote">“ <span class="quote"><a class="xref" href="#partitioning" title="28.6分区支持">第28.6节“分区支持”</a></span> ”</span> 。</p><p class="simpara">默认： <code class="literal">null</code> 。</p></dd><dt><span class="term">partitionSelectorClass</span></dt><dd><p class="simpara">一种<code class="literal">PartitionSelectorStrategy</code>实施。与互斥<code class="literal">partitionSelectorExpression</code> 。如果两者均未设置，则选择该分区作为<code class="literal">hashCode(key) % partitionCount</code> ，在哪里<code class="literal">key</code>通过以下任一方式计算<code class="literal">partitionKeyExpression</code>要么<code class="literal">partitionKeyExtractorClass</code> 。</p><p class="simpara">默认： <code class="literal">null</code> 。</p></dd><dt><span class="term">partitionSelectorExpression</span></dt><dd><p class="simpara">用于自定义分区选择的SpEL表达式。与互斥<code class="literal">partitionSelectorClass</code> 。如果两者均未设置，则选择该分区作为<code class="literal">hashCode(key) % partitionCount</code> ，在哪里<code class="literal">key</code>通过以下任一方式计算<code class="literal">partitionKeyExpression</code>要么<code class="literal">partitionKeyExtractorClass</code> 。</p><p class="simpara">默认： <code class="literal">null</code> 。</p></dd><dt><span class="term">partitionCount</span></dt><dd><p class="simpara">数据的目标分区数（如果启用了分区）。如果生产者已分区，则必须将其设置为大于1的值。在Kafka上，它被解释为提示。取其较大者，并使用目标主题的分区数。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">requiredGroups</span></dt><dd>生产者必须确保将消息传递到的组的逗号分隔列表，即使它们是在创建消息之后开始的（例如，通过在RabbitMQ中预先创建持久队列）。</dd><dt><span class="term">headerMode</span></dt><dd><p class="simpara">设置为<code class="literal">none</code> ，它会禁用在输出中嵌入标头。它仅对本身不支持消息头并且需要消息头嵌入的消息中间件有效。当不支持本机头时，在为非Spring Cloud Stream应用程序生成数据时，此选项很有用。设置为<code class="literal">headers</code> ，它使用中间件的本机头机制。设置为<code class="literal">embeddedHeaders</code> ，它将标头嵌入到消息有效负载中。</p><p class="simpara">默认值：取决于活页夹的实现。</p></dd><dt><span class="term">useNativeEncoding</span></dt><dd><p class="simpara">设置为<code class="literal">true</code> ，则出站消息将直接由客户端库进行序列化，该库必须进行相应配置（例如，设置适当的Kafka生产者值序列化程序）。使用此配置时，出站邮件编组不是基于<code class="literal">contentType</code>的绑定。使用本机编码时，消费者有责任使用适当的解码器（例如，Kafka消费者值反序列化器）对入站消息进行反序列化。此外，当使用本机编码和解码时， <code class="literal">headerMode=embeddedHeaders</code>属性将被忽略，并且标头未嵌入消息中。查看消费者财产<code class="literal">useNativeDecoding</code> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">errorChannelEnabled</span></dt><dd><p class="simpara">设置为<code class="literal">true</code> ，如果活页夹支持异步发送结果，则发送失败将发送到目标的错误通道。参见<span class="quote">“ <span class="quote"><a class="xref" href="#">???</a></span> ”</span> 想要查询更多的信息。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="dynamicdestination" href="#dynamicdestination"></a> 31.3使用动态绑定的目的地</h2></div></div></div><p>除了使用定义的渠道<code class="literal">@EnableBinding</code> ，Spring Cloud Stream使应用程序可以将消息发送到动态绑定的目标。例如，当需要在运行时确定目标目的地时，这很有用。应用程序可以通过使用<code class="literal">BinderAwareChannelResolver</code> Bean，由<code class="literal">@EnableBinding</code>注解。</p><p>“ spring.cloud.stream.dynamicDestinations”属性可用于将动态目标名称限制为已知集合（白名单）。如果未设置此属性，则可以动态绑定任何目标。</p><p>的<code class="literal">BinderAwareChannelResolver</code>可以直接使用，如以下使用路径变量确定目标通道的REST控制器示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding</span></em>
<em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SourceWithDynamicDestination {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> BinderAwareChannelResolver resolver;

    <em><span class="hl-annotation" style="color: gray">@RequestMapping(path = "/{target}", method = POST, consumes = "*/*")</span></em>
    <em><span class="hl-annotation" style="color: gray">@ResponseStatus(HttpStatus.ACCEPTED)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handleRequest(<em><span class="hl-annotation" style="color: gray">@RequestBody</span></em> String body, <em><span class="hl-annotation" style="color: gray">@PathVariable("target")</span></em> target,
           <em><span class="hl-annotation" style="color: gray">@RequestHeader(HttpHeaders.CONTENT_TYPE)</span></em> Object contentType) {
        sendMessage(body, target, contentType);
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> sendMessage(String body, String target, Object contentType) {
        resolver.resolveDestination(target).send(MessageBuilder.createMessage(body,
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
    }
}</pre><p>现在考虑当我们在默认端口（8080）上启动应用程序并使用CURL发出以下请求时会发生什么：</p><pre class="screen">curl -H "Content-Type: application/json" -X POST -d "customer-1" http://localhost:8080/customers

curl -H "Content-Type: application/json" -X POST -d "order-1" http://localhost:8080/orders</pre><p>在代理中创建目的地“客户”和“订单”（在Rabbit的交换中或在Kafka的主题中），名称为“客户”和“订单”，并将数据发布到适当的目的地。</p><p>的<code class="literal">BinderAwareChannelResolver</code>是通用的Spring Integration <code class="literal">DestinationResolver</code>并可以注入到其他组件中，例如，在使用基于以下内容的SpEL表达式的路由器中<code class="literal">target</code>传入JSON消息的字段。以下示例包含一个读取SpEL表达式的路由器：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding</span></em>
<em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SourceWithDynamicDestination {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> BinderAwareChannelResolver resolver;


    <em><span class="hl-annotation" style="color: gray">@RequestMapping(path = "/", method = POST, consumes = "application/json")</span></em>
    <em><span class="hl-annotation" style="color: gray">@ResponseStatus(HttpStatus.ACCEPTED)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handleRequest(<em><span class="hl-annotation" style="color: gray">@RequestBody</span></em> String body, <em><span class="hl-annotation" style="color: gray">@RequestHeader(HttpHeaders.CONTENT_TYPE)</span></em> Object contentType) {
        sendMessage(body, contentType);
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> sendMessage(Object body, Object contentType) {
        routerChannel().send(MessageBuilder.createMessage(body,
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
    }

    <em><span class="hl-annotation" style="color: gray">@Bean(name = "routerChannel")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageChannel routerChannel() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> DirectChannel();
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "routerChannel")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ExpressionEvaluatingRouter router() {
        ExpressionEvaluatingRouter router =
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ExpressionEvaluatingRouter(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpelExpressionParser().parseExpression(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"payload.target"</span>));
        router.setDefaultOutputChannelName(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"default-output"</span>);
        router.setChannelResolver(resolver);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> router;
    }
}</pre><p><a class="link" href="https://github.com/spring-cloud-stream-app-starters/router" target="_top">路由器接收器应用程序</a>使用此技术按需创建目的地。</p><p>如果预先知道通道名称，则可以像其他任何目的地一样配置生产者属性。或者，如果您注册一个<code class="literal">NewBindingCallback<></code> Bean，就在创建绑定之前调用它。回调采用绑定程序使用的扩展生产者属性的通用类型。它有一种方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> configure(String channelName, MessageChannel channel, ProducerProperties producerProperties,
        T extendedProducerProperties);</pre><p>以下示例显示了如何使用RabbitMQ绑定器：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> NewBindingCallback&lt;RabbitProducerProperties&gt; dynamicConfigurer() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (name, channel, props, extended) -&gt; {
        props.setRequiredGroups(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bindThisQueue"</span>);
        extended.setQueueNameGroupOnly(true);
        extended.setAutoBindDlq(true);
        extended.setDeadLetterQueueName(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myDLQ"</span>);
    };
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您需要支持具有多种活页夹类型的动态目标，请使用<code class="literal">Object</code>泛型类型并强制转换<code class="literal">extended</code>根据需要争论。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="content-type-management" href="#content-type-management"></a> 32。内容类型协商</h2></div></div></div><p>数据转换是任何消息驱动的微服务体系结构的核心功能之一。鉴于此，在Spring Cloud Stream中，此类数据表示为Spring <code class="literal">Message</code> ，则可能必须先将邮件转换为所需的形状或大小，然后才能到达目的地。这样做有两个原因：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">转换传入消息的内容以匹配应用程序提供的处理程序的签名。</li><li class="listitem">将外发邮件的内容转换为有线格式。</li></ol></div><p>有线格式通常是<code class="literal">byte[]</code> （对于Kafka和Rabbit活页夹而言，这是正确的），但它受活页夹实现的支配。</p><p>在Spring Cloud Stream中，消息转换是通过<code class="literal">org.springframework.messaging.converter.MessageConverter</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>作为后续细节的补充，您可能还需要阅读以下<a class="link" href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation" target="_top">博客文章</a> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_mechanics" href="#_mechanics"></a> 32.1力学</h2></div></div></div><p>为了更好地理解内容类型协商的机制和必要性，我们以下面的消息处理程序为例，看一个非常简单的用例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@StreamListener(Processor.INPUT)</span></em>
<em><span class="hl-annotation" style="color: gray">@SendTo(Processor.OUTPUT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String handle(Person person) {..}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>为简单起见，我们假设这是应用程序中唯一的处理程序（我们假设没有内部管道）。</p></td></tr></tbody></table></div><p>前面示例中显示的处理程序期望一个<code class="literal">Person</code>对象作为参数并产生一个<code class="literal">String</code>输入作为输出。为了使框架成功传递传入的信息<code class="literal">Message</code>作为此处理程序的参数，它必须以某种方式转换<code class="literal">Message</code>从电汇格式输入到<code class="literal">Person</code>类型。换句话说，框架必须找到并应用适当的<code class="literal">MessageConverter</code> 。为此，框架需要用户的一些指示。这些指令之一已由处理程序方法本身的签名提供（ <code class="literal">Person</code>类型）。因此，从理论上讲，这应该是（并且在某些情况下是足够的）。但是，对于大多数用例来说，为了选择合适的<code class="literal">MessageConverter</code> ，框架需要其他信息。那块缺失的是<code class="literal">contentType</code> 。</p><p>Spring Cloud Stream提供了三种机制来定义<code class="literal">contentType</code> （按优先顺序）：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><span class="strong"><strong>标题</strong></span> ： <code class="literal">contentType</code>可以通过消息本身进行通信。通过提供<code class="literal">contentType</code>标头，则声明要用于查找和应用适当内容的内容类型<code class="literal">MessageConverter</code> 。</li><li class="listitem"><p class="simpara"><span class="strong"><strong>绑定</strong></span> ： <code class="literal">contentType</code>可以通过设置目标绑定来设置<code class="literal">spring.cloud.stream.bindings.input.content-type</code>属性。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">input</code>属性名称中的句段对应于目的地的实际名称（在我们的示例中为“输入”）。通过这种方法，您可以按绑定声明用于查找和应用适当内容的内容类型。 <code class="literal">MessageConverter</code> 。</p></td></tr></tbody></table></div></li><li class="listitem"><span class="strong"><strong>默认值</strong></span> ：如果<code class="literal">contentType</code>不存在于<code class="literal">Message</code>标头或绑定，默认<code class="literal">application/json</code>内容类型用于查找和应用适当的内容<code class="literal">MessageConverter</code> 。</li></ol></div><p>如前所述，前面的列表还演示了平局时的优先顺序。例如，标头提供的内容类型优先于任何其他内容类型。对于按绑定设置的内容类型也是如此，这实际上使您可以覆盖默认内容类型。但是，它也提供了明智的默认设置（由社区反馈确定）。</p><p>制作的另一个原因<code class="literal">application/json</code>默认值来自分布式微服务架构所驱动的互操作性要求，在该架构中，生产者和使用者不仅可以在不同的JVM中运行，而且还可以在不同的非JVM平台上运行。</p><p>当非无效处理程序方法返回时，如果返回值已经是<code class="literal">Message</code> ， <code class="literal">Message</code>成为有效载荷。但是，当返回值不是<code class="literal">Message</code> ， 新的<code class="literal">Message</code>以返回值作为有效载荷构造，同时从输入继承标头<code class="literal">Message</code>减去定义或过滤的标头<code class="literal">SpringIntegrationProperties.messageHandlerNotPropagatedHeaders</code> 。默认情况下，仅设置一个标头： <code class="literal">contentType</code> 。这意味着新<code class="literal">Message</code>不具有<code class="literal">contentType</code>标头设置，从而确保<code class="literal">contentType</code>可以进化。您随时可以选择不返回<code class="literal">Message</code>从处理程序方法中，您可以在其中注入所需的任何标头。</p><p>如果有内部管道， <code class="literal">Message</code>通过相同的转换过程被发送到下一个处理程序。但是，如果没有内部管道或您已经到达内部管道的末端， <code class="literal">Message</code>被发送回输出目的地。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_content_type_versus_argument_type" href="#_content_type_versus_argument_type"></a> 32.1.1内容类型与参数类型</h3></div></div></div><p>如前所述，为框架选择合适的<code class="literal">MessageConverter</code> ，它需要参数类型以及（可选）内容类型信息。选择合适的逻辑<code class="literal">MessageConverter</code>与参数解析器（ <code class="literal">HandlerMethodArgumentResolvers</code> ），它会在调用用户定义的处理程序方法之前触发（这是框架知道实际参数类型的时间）。如果参数类型与当前有效负载的类型不匹配，则框架将委派给预先配置的堆栈<code class="literal">MessageConverters</code>看看其中任何一个都可以转换有效载荷。如您所见， <code class="literal">Object fromMessage(Message<?> message, Class<?> targetClass);</code> MessageConverter的操作需要<code class="literal">targetClass</code>作为其论点之一。该框架还确保提供的<code class="literal">Message</code>总是包含一个<code class="literal">contentType</code>标头。当没有contentType标头时，它将注入每个绑定<code class="literal">contentType</code>标头或默认<code class="literal">contentType</code>标头。的结合<code class="literal">contentType</code>参数类型是框架确定消息是否可以转换为目标类型的机制。如果不合适<code class="literal">MessageConverter</code>找到后，将引发异常，您可以通过添加自定义来处理<code class="literal">MessageConverter</code> （请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-user-defined-message-converters" title="32.3用户定义的消息转换器">第32.3节“用户定义的消息转换器”</a></span> ”</span> ）。</p><p>但是，如果有效负载类型与处理程序方法声明的目标类型匹配，该怎么办？在这种情况下，没有任何要转换的内容，并且有效载荷未经修改地传递。尽管这听起来很简单且合乎逻辑，但请记住使用一个<code class="literal">Message<?></code>要么<code class="literal">Object</code>作为争论。通过声明目标类型为<code class="literal">Object</code> （这是一个<code class="literal">instanceof</code> Java中的所有内容），您实际上就放弃了转换过程。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>不要指望<code class="literal">Message</code>仅根据<code class="literal">contentType</code> 。请记住<code class="literal">contentType</code>与目标类型互补。如果您愿意，可以提供一个提示， <code class="literal">MessageConverter</code>可能会或可能不会考虑。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_message_converters" href="#_message_converters"></a> 32.1.2消息转换器</h3></div></div></div><p><code class="literal">MessageConverters</code>定义两种方法：</p><pre class="programlisting">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);

Message&lt;?&gt; toMessage(Object payload, <em><span class="hl-annotation" style="color: gray">@Nullable</span></em> MessageHeaders headers);</pre><p>了解这些方法的约定及其用法非常重要，尤其是在Spring Cloud Stream的上下文中。</p><p>的<code class="literal">fromMessage</code>方法转换传入的<code class="literal">Message</code>到参数类型。的有效载荷<code class="literal">Message</code>可以是任何类型，这取决于实际的实施<code class="literal">MessageConverter</code>支持多种类型。例如，某些JSON转换器可能支持有效负载类型为<code class="literal">byte[]</code> ， <code class="literal">String</code> ， 和别的。当应用程序包含内部管道（即，输入→handler1→handler2→..→→输出）并且上游处理程序的输出结果为<code class="literal">Message</code>可能不是初始电汇格式。</p><p>然而<code class="literal">toMessage</code>方法具有更严格的合同，必须始终转换<code class="literal">Message</code>转换为电汇格式： <code class="literal">byte[]</code> 。</p><p>因此，出于所有意图和目的（尤其是在实现自己的转换器时），您将这两种方法视为具有以下签名：</p><pre class="programlisting">Object fromMessage(Message&lt;?&gt; message, Class&lt;?&gt; targetClass);

Message&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; toMessage(Object payload, <em><span class="hl-annotation" style="color: gray">@Nullable</span></em> MessageHeaders headers);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_provided_messageconverters" href="#_provided_messageconverters"></a> 32.2提供的MessageConverters</h2></div></div></div><p>如前所述，该框架已经提供了<code class="literal">MessageConverters</code>处理最常见的用例。以下列表描述了所提供的<code class="literal">MessageConverters</code> ，按优先顺序（第一个<code class="literal">MessageConverter</code>使用有效的）：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><code class="literal">ApplicationJsonMessageMarshallingConverter</code> ：的变化<code class="literal">org.springframework.messaging.converter.MappingJackson2MessageConverter</code> 。支持转换有效载荷<code class="literal">Message</code>在以下情况下往返POJO <code class="literal">contentType</code>是<code class="literal">application/json</code> （默认）。</li><li class="listitem"><code class="literal">TupleJsonMessageConverter</code> ：已<span class="strong"><strong>弃用</strong></span>支持转换有效负载<code class="literal">Message</code>往/返<code class="literal">org.springframework.tuple.Tuple</code> 。</li><li class="listitem"><code class="literal">ByteArrayMessageConverter</code> ：支持转换有效负载<code class="literal">Message</code>从<code class="literal">byte[]</code>至<code class="literal">byte[]</code>对于情况<code class="literal">contentType</code>是<code class="literal">application/octet-stream</code> 。它实质上是一个传递，主要是为了向后兼容而存在。</li><li class="listitem"><code class="literal">ObjectStringMessageConverter</code> ：支持将任何类型转换为<code class="literal">String</code>什么时候<code class="literal">contentType</code>是<code class="literal">text/plain</code> 。它调用对象的<code class="literal">toString()</code>方法，或者如果有效载荷是<code class="literal">byte[]</code> ，一个新的<code class="literal">String(byte[])</code> 。</li><li class="listitem"><code class="literal">JavaSerializationMessageConverter</code> ： <span class="strong"><strong>DEPRECATED在以下情况下</strong></span>支持基于Java序列化的转换<code class="literal">contentType</code>是<code class="literal">application/x-java-serialized-object</code> 。</li><li class="listitem"><code class="literal">KryoMessageConverter</code> ： <span class="strong"><strong>弃用时</strong></span>支持基于Kryo序列化的转换<code class="literal">contentType</code>是<code class="literal">application/x-java-object</code> 。</li><li class="listitem"><code class="literal">JsonUnmarshallingConverter</code> ：类似于<code class="literal">ApplicationJsonMessageMarshallingConverter</code> 。它支持任何类型的转换<code class="literal">contentType</code>是<code class="literal">application/x-java-object</code> 。它期望将实际类型信息嵌入到<code class="literal">contentType</code>作为属性（例如， <code class="literal">application/x-java-object;type=foo.bar.Cat</code> ）。</li></ol></div><p>当找不到合适的转换器时，框架将引发异常。发生这种情况时，您应该检查代码和配置，并确保您没有错过任何内容（即，确保您提供了<code class="literal">contentType</code>通过使用绑定或标头）。但是，很可能您发现了一些不常见的情况（例如自定义<code class="literal">contentType</code>可能）和当前提供的堆栈<code class="literal">MessageConverters</code>不知道如何转换。如果是这样，您可以添加自定义<code class="literal">MessageConverter</code> 。请参见<a class="xref" href="#spring-cloud-stream-overview-user-defined-message-converters" title="32.3用户定义的消息转换器">第32.3节“用户定义的消息转换器”</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-user-defined-message-converters" href="#spring-cloud-stream-overview-user-defined-message-converters"></a> 32.3用户定义的消息转换器</h2></div></div></div><p>Spring Cloud Stream公开了定义和注册其他内容的机制<code class="literal">MessageConverters</code> 。要使用它，实现<code class="literal">org.springframework.messaging.converter.MessageConverter</code> ，将其配置为<code class="literal">@Bean</code> ，并用<code class="literal">@StreamMessageConverter</code> 。然后将其附加到MessageConverter的现有堆栈中。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>重要的是要了解习惯<code class="literal">MessageConverter</code>实现被添加到现有堆栈的头部。因此，习惯<code class="literal">MessageConverter</code>实施优先于现有的实施，这使您可以覆盖以及添加到现有的转换器中。</p></td></tr></tbody></table></div><p>下面的示例演示如何创建消息转换器Bean以支持称为<code class="literal">application/bar</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

    ...

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <em><span class="hl-annotation" style="color: gray">@StreamMessageConverter</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter customMessageConverter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MyCustomMessageConverter();
    }
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyCustomMessageConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AbstractMessageConverter {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MyCustomMessageConverter() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MimeType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>));
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> supports(Class&lt;?&gt; clazz) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (Bar.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>.equals(clazz));
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> Object convertFromInternal(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint) {
        Object payload = message.getPayload();
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (payload <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">instanceof</span> Bar ? payload : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Bar((<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]) payload));
    }
}</pre><p>Spring Cloud Stream还支持基于Avro的转换器和模式演变。有关详细信息<span class="quote"><span class="quote"><a class="xref" href="#schema-evolution" title="33. Schema Evolution Support">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#schema-evolution" title="33。模式演进支持">第33章， <i>模式演化支持</i></a></span> ”</span> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="schema-evolution" href="#schema-evolution"></a> 33。模式演进支持</h2></div></div></div><p>Spring Cloud Stream提供了对模式演化的支持，因此数据可以随着时间的推移而演化，并且仍然可以与新旧的生产者和消费者一起使用，反之亦然。大多数序列化模型，尤其是那些旨在跨平台和语言进行移植的模型，都依赖于描述数据如何在二进制有效负载中进行序列化的模式。为了序列化数据然后解释它，发送方和接收方都必须有权访问描述二进制格式的模式。在某些情况下，可以从序列化时的有效负载类型或反序列化时的目标类型推断模式。但是，许多应用程序都可以从访问描述二进制数据格式的显式架构中受益。使用模式注册表，您可以以文本格式（通常为JSON）存储模式信息，并使该信息可用于需要它以二进制格式接收和发送数据的各种应用程序。模式可引用为一个元组，该元组包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">主题，是架构的逻辑名称</li><li class="listitem">模式版本</li><li class="listitem">模式格式，描述数据的二进制格式</li></ul></div><p>以下各节详细介绍了架构演变过程中涉及的各种组件。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_schema_registry_client" href="#_schema_registry_client"></a> 33.1架构注册表客户端</h2></div></div></div><p>与架构注册表服务器进行交互的客户端抽象是<code class="literal">SchemaRegistryClient</code>界面，其结构如下：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> SchemaRegistryClient {

    SchemaRegistrationResponse register(String subject, String format, String schema);

    String fetch(SchemaReference schemaReference);

    String fetch(Integer id);

}</pre><p>Spring Cloud Stream提供了开箱即用的实现，可用于与其自己的模式服务器进行交互以及与Confluent Schema Registry进行交互。</p><p>可以使用以下命令配置Spring Cloud Stream模式注册表的客户端<code class="literal">@EnableSchemaRegistryClient</code> ， 如下：</p><pre class="programlisting">  <em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
  <em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
  <em><span class="hl-annotation" style="color: gray">@EnableSchemaRegistryClient</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> AvroSinkApplication {
    ...
  }</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认转换器经过优化，不仅可以缓存远程服务器的架构，还可以缓存远程服务器的架构。 <code class="literal">parse()</code>和<code class="literal">toString()</code>方法，这很昂贵。因此，它使用了<code class="literal">DefaultSchemaRegistryClient</code>不缓存响应。如果要更改默认行为，则可以直接在代码上使用客户端，并将其覆盖为所需的结果。为此，您必须添加属性<code class="literal">spring.cloud.stream.schemaRegistryClient.cached=true</code>您的应用程序属性。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_schema_registry_client_properties" href="#_schema_registry_client_properties"></a> 33.1.1架构注册表客户端属性</h3></div></div></div><p>架构注册表客户端支持以下属性：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">spring.cloud.stream.schemaRegistryClient.endpoint</code></span></dt><dd>模式服务器的位置。进行设置时，请使用完整的URL，包括协议（ <code class="literal">http</code>要么<code class="literal">https</code> ），端口和上下文路径。</dd><dt><span class="term">默认</span></dt><dd><code class="literal"><a class="link" href="http://localhost:8990/" target="_top">http://localhost:8990/</a></code></dd><dt><span class="term"><code class="literal">spring.cloud.stream.schemaRegistryClient.cached</code></span></dt><dd>客户端是否应缓存架构服务器响应。通常设置为<code class="literal">false</code> ，因为缓存发生在消息转换器中。使用架构注册表客户端的客户端应将此设置为<code class="literal">true</code> 。</dd><dt><span class="term">默认</span></dt><dd><code class="literal">true</code></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_avro_schema_registry_client_message_converters" href="#_avro_schema_registry_client_message_converters"></a> 33.2 Avro Schema Registry客户端消息转换器</h2></div></div></div><p>对于已向应用程序上下文注册了SchemaRegistryClient Bean的应用程序，Spring Cloud Stream会自动配置Apache Avro消息转换器以进行模式管理。由于接收消息的应用程序可以轻松访问可以与自己的读取器模式进行协调的写入器模式，因此这简化了模式的演变。</p><p>对于出站邮件，如果通道的内容类型设置为<code class="literal">application/*+avro</code> ， <code class="literal">MessageConverter</code>被激活，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.stream.bindings.output.contentType</span>=application/*+avro</pre><p>在出站转换期间，消息转换器尝试推断每个出站消息的模式（基于其类型），并使用以下命令将其注册到主题（基于有效负载类型） <code class="literal">SchemaRegistryClient</code> 。如果已经找到相同的模式，则将检索对其的引用。如果不是，则注册架构，并提供新的版本号。邮件发送时带有<code class="literal">contentType</code>标头使用以下方案： <code class="literal">application/[prefix].[subject].v[version]+avro</code> ，在哪里<code class="literal">prefix</code>是可配置的<code class="literal">subject</code>从有效载荷类型推导得出。</p><p>例如，以下类型的消息<code class="literal">User</code>可能以内容类型为<code class="literal">application/vnd.user.v2+avro</code> ，在哪里<code class="literal">user</code>是主题， <code class="literal">2</code>是版本号。</p><p>接收消息时，转换器从传入消息的头中推断模式引用，并尝试检索它。该模式在反序列化过程中用作编写器模式。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_avro_schema_registry_message_converter_properties" href="#_avro_schema_registry_message_converter_properties"></a> 33.2.1 Avro Schema注册表消息转换器属性</h3></div></div></div><p>如果通过设置启用了基于Avro的架构注册表客户端<code class="literal">spring.cloud.stream.bindings.output.contentType=application/*+avro</code> ，您可以通过设置以下属性来自定义注册行为。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</span></dt><dd><p class="simpara">如果希望转换器使用反射从POJO推断模式，则启用。</p><p class="simpara">默认：<code class="literal">false</code></p></dd><dt><span class="term">spring.cloud.stream.schema.avro.readerSchema</span></dt><dd>Avro通过查看写入器模式（原始有效负载）和读取器模式（您的应用程序有效负载）来比较模式版本。有关更多信息，请参见<a class="link" href="https://avro.apache.org/docs/1.7.6/spec.html" target="_top">Avro文档</a> 。如果设置，它将覆盖模式服务器上的所有查找，并将本地模式用作读取器模式。默认：<code class="literal">null</code></dd><dt><span class="term">spring.cloud.stream.schema.avro.schema位置</span></dt><dd><p class="simpara">注册任何<code class="literal">.avsc</code>模式服务器中此属性中列出的文件。</p><p class="simpara">默认：<code class="literal">empty</code></p></dd><dt><span class="term">spring.cloud.stream.schema.avro.prefix</span></dt><dd><p class="simpara">Content-Type标头上要使用的前缀。</p><p class="simpara">默认：<code class="literal">vnd</code></p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_apache_avro_message_converters" href="#_apache_avro_message_converters"></a> 33.3 Apache Avro消息转换器</h2></div></div></div><p>Spring Cloud Stream通过其Spring Cloud Stream支持基于模式的消息转换器<code class="literal">spring-cloud-stream-schema</code>模块。当前，基于模式的消息转换器唯一支持的开箱即用的序列化格式是Apache Avro，将来的版本中将添加更多格式。</p><p>的<code class="literal">spring-cloud-stream-schema</code>模块包含可用于Apache Avro序列化的两种消息转换器：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">转换器使用序列化或反序列化对象的类信息或在启动时具有已知位置的模式。</li><li class="listitem">使用架构注册表的转换器。它们在运行时定位架构，并随着域对象的发展动态注册新架构。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_converters_with_schema_support" href="#_converters_with_schema_support"></a> 33.4具有模式支持的转换器</h2></div></div></div><p>的<code class="literal">AvroSchemaMessageConverter</code>通过使用预定义的架构或使用类中可用的架构信息（以反射方式或包含在<code class="literal">SpecificRecord</code> ）。如果提供自定义转换器，则不会创建默认的AvroSchemaMessageConverter bean。以下示例显示了一个自定义转换器：</p><p>要使用自定义转换器，只需将其添加到应用程序上下文中，可以选择指定一个或多个<code class="literal">MimeTypes</code>与之关联。默认值<code class="literal">MimeType</code>是<code class="literal">application/avro</code> 。</p><p>如果转化的目标类型是<code class="literal">GenericRecord</code> ，必须设置一个架构。</p><p>以下示例显示如何通过注册Apache Avro在接收器应用程序中配置转换器<code class="literal">MessageConverter</code>没有预定义的架构。在此示例中，请注意，MIME类型值是<code class="literal">avro/bytes</code> ，而不是默认值<code class="literal">application/avro</code> 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

  ...

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter userMessageConverter() {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AvroSchemaMessageConverter(MimeType.valueOf(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"avro/bytes"</span>));
  }
}</pre><p>相反，以下应用程序使用预定义的架构（在类路径上找到）注册一个转换器：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SinkApplication {

  ...

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageConverter userMessageConverter() {
      AvroSchemaMessageConverter converter = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AvroSchemaMessageConverter(MimeType.valueOf(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"avro/bytes"</span>));
      converter.setSchemaLocation(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClassPathResource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"schemas/User.avro"</span>));
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> converter;
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_schema_registry_server" href="#_schema_registry_server"></a> 33.5架构注册表服务器</h2></div></div></div><p>Spring Cloud Stream提供了架构注册表服务器实现。要使用它，您可以添加<code class="literal">spring-cloud-stream-schema-server</code>项目的工件，并使用<code class="literal">@EnableSchemaRegistryServer</code>注释，它将架构注册表服务器REST控制器添加到您的应用程序。该注释旨在与Spring Boot Web应用程序一起使用，并且服务器的侦听端口由<code class="literal">server.port</code>属性。的<code class="literal">spring.cloud.stream.schema.server.path</code>属性可以用于控制模式服务器的根路径（尤其是当它嵌入在其他应用程序中时）。的<code class="literal">spring.cloud.stream.schema.server.allowSchemaDeletion</code>布尔属性允许删除架构。默认情况下，这是禁用的。</p><p>架构注册表服务器使用关系数据库来存储架构。默认情况下，它使用嵌入式数据库。您可以使用<a class="link" href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-sql" target="_top">Spring Boot SQL数据库和JDBC配置选项</a>来自定义模式存储。</p><p>以下示例显示了启用架构注册表的Spring Boot应用程序：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableSchemaRegistryServer</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SchemaRegistryServerApplication {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        SpringApplication.run(SchemaRegistryServerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
    }
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_schema_registry_server_api" href="#_schema_registry_server_api"></a> 33.5.1架构注册表服务器API</h3></div></div></div><p>Schema Registry Server API包含以下操作：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">POST /</code> —请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-registering-new-schema" title="注册新架构">称为“注册新架构”的部分</a></span> ”</span></li><li class="listitem">'GET / {subject} / {format} / {version}'-参见<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version" title="通过主题，格式和版本检索现有架构">称为“按主题，格式和版本检索现有模式的部分”</a></span> ”</span></li><li class="listitem"><code class="literal">GET /{subject}/{format}</code> —请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-retrieve-schema-subject-format" title="通过主题和格式检索现有模式">称为“按主题和格式检索现有模式的部分”</a></span> ”</span></li><li class="listitem"><code class="literal">GET /schemas/{id}</code> —请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-retrieve-schema-id" title="Retrieving an Existing Schema by ID">称为“通过ID检索现有模式</a></span> ” <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-retrieve-schema-id" title="通过ID检索现有架构">的部分”</a></span> ”</span></li><li class="listitem"><code class="literal">DELETE /{subject}/{format}/{version}</code> —请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-deleting-schema-subject-format-version" title="按主题，格式和版本删除架构">名为“按主题，格式和版本删除架构的部分”</a></span> ”</span></li><li class="listitem"><code class="literal">DELETE /schemas/{id}</code> —请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-deleting-schema-id" title="Deleting a Schema by ID">称为“通过ID删除架构</a></span> ” <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-deleting-schema-id" title="通过ID删除架构">的部分”</a></span> ”</span></li><li class="listitem"><code class="literal">DELETE /{subject}</code> —请参阅<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-deleting-schema-subject" title="按主题删除架构">称为“按主题删除架构的部分”</a></span> ”</span></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-registering-new-schema" href="#spring-cloud-stream-overview-registering-new-schema"></a>注册新架构</h4></div></div></div><p>要注册新架构，请发送<code class="literal">POST</code>要求<code class="literal">/</code>端点。</p><p>的<code class="literal">/</code>接受具有以下字段的JSON有效负载：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">subject</code> ：架构主题</li><li class="listitem"><code class="literal">format</code> ：架构格式</li><li class="listitem"><code class="literal">definition</code> ：模式定义</li></ul></div><p>它的响应是JSON中的架构对象，具有以下字段：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">id</code> ：模式ID</li><li class="listitem"><code class="literal">subject</code> ：架构主题</li><li class="listitem"><code class="literal">format</code> ：架构格式</li><li class="listitem"><code class="literal">version</code> ：模式版本</li><li class="listitem"><code class="literal">definition</code> ：模式定义</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-retrieve-schema-subject-format-version" href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version"></a>通过主题，格式和版本检索现有架构</h4></div></div></div><p>要按主题，格式和版本检索现有模式，请发送<code class="literal">GET</code>要求<code class="literal">/{subject}/{format}/{version}</code>端点。</p><p>它的响应是JSON中的架构对象，具有以下字段：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">id</code> ：模式ID</li><li class="listitem"><code class="literal">subject</code> ：架构主题</li><li class="listitem"><code class="literal">format</code> ：架构格式</li><li class="listitem"><code class="literal">version</code> ：模式版本</li><li class="listitem"><code class="literal">definition</code> ：模式定义</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-retrieve-schema-subject-format" href="#spring-cloud-stream-overview-retrieve-schema-subject-format"></a>通过主题和格式检索现有模式</h4></div></div></div><p>要按主题和格式检索现有架构，请发送<code class="literal">GET</code>要求<code class="literal">/subject/format</code>端点。</p><p>它的响应是JSON中每个模式对象的模式列表，其中包含以下字段：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">id</code> ：模式ID</li><li class="listitem"><code class="literal">subject</code> ：架构主题</li><li class="listitem"><code class="literal">format</code> ：架构格式</li><li class="listitem"><code class="literal">version</code> ：模式版本</li><li class="listitem"><code class="literal">definition</code> ：模式定义</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-retrieve-schema-id" href="#spring-cloud-stream-overview-retrieve-schema-id"></a>通过ID检索现有架构</h4></div></div></div><p>要通过其ID检索架构，请发送一个<code class="literal">GET</code>要求<code class="literal">/schemas/{id}</code>端点。</p><p>它的响应是JSON中的架构对象，具有以下字段：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">id</code> ：模式ID</li><li class="listitem"><code class="literal">subject</code> ：架构主题</li><li class="listitem"><code class="literal">format</code> ：架构格式</li><li class="listitem"><code class="literal">version</code> ：模式版本</li><li class="listitem"><code class="literal">definition</code> ：模式定义</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-deleting-schema-subject-format-version" href="#spring-cloud-stream-overview-deleting-schema-subject-format-version"></a>按主题，格式和版本删除架构</h4></div></div></div><p>要删除由其主题，格式和版本标识的架构，请发送<code class="literal">DELETE</code>要求<code class="literal">/{subject}/{format}/{version}</code>端点。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-deleting-schema-id" href="#spring-cloud-stream-overview-deleting-schema-id"></a>通过ID删除架构</h4></div></div></div><p>要通过其ID删除架构，请发送一个<code class="literal">DELETE</code>要求<code class="literal">/schemas/{id}</code>端点。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-stream-overview-deleting-schema-subject" href="#spring-cloud-stream-overview-deleting-schema-subject"></a>按主题删除架构</h4></div></div></div><p><code class="literal">DELETE /{subject}</code></p><p>按主题删除现有架构。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>本说明适用于Spring Cloud Stream 1.1.0的用户。仅发布。Spring Cloud Stream 1.1.0。使用表名RELEASE， <code class="literal">schema</code> ，用于存储<code class="literal">Schema</code>对象。 <code class="literal">Schema</code>是许多数据库实现中的关键字。为了避免将来发生任何冲突，从1.1.1开始。发布，我们选择了这个名字<code class="literal">SCHEMA_REPOSITORY</code>用于存储表。任何Spring Cloud Stream 1.1.0。升级的RELEASE用户应在升级之前将其现有模式迁移到新表。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_confluents_schema_registry" href="#_using_confluents_schema_registry"></a> 33.5.2使用Confluent的架构注册表</h3></div></div></div><p>默认配置会创建一个<code class="literal">DefaultSchemaRegistryClient</code> bean 。如果要使用Confluent模式注册表，则需要创建一个类型为bean的bean。 <code class="literal">ConfluentSchemaRegistryClient</code> ，它取代了框架默认配置的框架。以下示例显示了如何创建这样的bean：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SchemaRegistryClient schemaRegistryClient(<em><span class="hl-annotation" style="color: gray">@Value("${spring.cloud.stream.schemaRegistryClient.endpoint}")</span></em> String endpoint){
  ConfluentSchemaRegistryClient client = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ConfluentSchemaRegistryClient();
  client.setEndpoint(endpoint);
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> client;
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>ConfluentSchemaRegistryClient已针对Confluent平台4.0.0版进行了测试。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_schema_registration_and_resolution" href="#_schema_registration_and_resolution"></a> 33.6模式注册和解析</h2></div></div></div><p>为了更好地了解Spring Cloud Stream如何注册和解析新模式及其对Avro模式比较功能的使用，我们提供了两个单独的小节：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-schema-registration-process" title="33.6.1模式注册过程（序列化）">第33.6.1节“模式注册过程（序列化）”</a></span> ”</span></li><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-schema-resolution-process" title="33.6.2模式解析过程（反序列化）">第33.6.2节“模式解析过程（反序列化）”</a></span> ”</span></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-overview-schema-registration-process" href="#spring-cloud-stream-overview-schema-registration-process"></a> 33.6.1模式注册过程（序列化）</h3></div></div></div><p>注册过程的第一部分是从通过通道发送的有效负载中提取模式。Avro类型，例如<code class="literal">SpecificRecord</code>要么<code class="literal">GenericRecord</code>已经包含一个架构，可以从实例中立即检索该架构。对于POJO，如果<code class="literal">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</code>属性设置为<code class="literal">true</code> （默认）。</p><div class="figure"><a name="d0e11681" href="#d0e11681"></a><p class="title"><b>图33.1模式编写器解析过程</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/schema_resolution.png" align="middle" alt="模式解析"></div></div></div><br class="figure-break"><p>获得一个模式，转换器从远程服务器加载其元数据（版本）。首先，它查询本地缓存。如果未找到结果，它将数据提交给服务器，服务器将提供版本信息。转换器始终缓存结果，以避免为每个需要序列化的新消息查询Schema Server的开销。</p><div class="figure"><a name="d0e11692" href="#d0e11692"></a><p class="title"><b>图33.2模式注册过程</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/registration.png" align="middle" alt="注册"></div></div></div><br class="figure-break"><p>利用架构版本信息，转换器将设置<code class="literal">contentType</code>消息的标题，以携带版本信息，例如： <code class="literal">application/vnd.user.v1+avro</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-overview-schema-resolution-process" href="#spring-cloud-stream-overview-schema-resolution-process"></a> 33.6.2模式解析过程（反序列化）</h3></div></div></div><p>阅读包含版本信息的消息时（即， <code class="literal">contentType</code>如果标头具有<span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-schema-registration-process" title="33.6.1模式注册过程（序列化）">第33.6.1节“模式注册过程（序列化）</a></span> ”</span> ）中所述的方案，则转换器将查询模式服务器以获取消息的编写者模式。一旦找到了传入消息的正确架构，它将检索阅读器架构，并使用Avro的架构解析支持将其读入阅读器定义（设置默认值和所有缺少的属性）。</p><div class="figure"><a name="d0e11720" href="#d0e11720"></a><p class="title"><b>图33.3模式阅读解析过程</b></p><div class="figure-contents"><div class="mediaobject" align="center"><img src="images/schema_reading.png" align="middle" alt="模式阅读"></div></div></div><br class="figure-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您应该了解写者模式（编写消息的应用程序）和阅读器模式（接收应用程序）之间的区别。我们建议<a class="link" href="https://avro.apache.org/docs/1.7.6/spec.html" target="_top">花点时间</a>阅读<a class="link" href="https://avro.apache.org/docs/1.7.6/spec.html" target="_top">Avro术语</a>并了解其过程。Spring Cloud Stream始终会获取编写者架构，以确定如何读取消息。如果您想获得Avro的架构演变支持，则需要确保<code class="literal">readerSchema</code>已为您的应用正确设置。</p></td></tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_inter_application_communication" href="#_inter_application_communication"></a> 34。应用间通信</h2></div></div></div><p>Spring Cloud Stream支持应用程序之间的通信。应用程序间通信是一个涉及多个问题的复杂问题，如以下主题所述：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-connecting-multiple-application-instances" title="34.1连接多个应用程序实例">第34.1节“连接多个应用程序实例”</a></span> ”</span></li><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-instance-index-instance-count" title="34.2实例索引和实例计数">第34.2节“实例索引和实例计数”</a></span> ”</span></li><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-partitioning" title="34.3分区">第34.3节“分区”</a></span> ”</span></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-connecting-multiple-application-instances" href="#spring-cloud-stream-overview-connecting-multiple-application-instances"></a> 34.1连接多个应用程序实例</h2></div></div></div><p>虽然Spring Cloud Stream使单个Spring Boot应用程序易于连接到消息传递系统，但Spring Cloud Stream的典型方案是创建多应用程序管道，在该管道中，微服务应用程序会相互发送数据。您可以通过关联<span class="quote">“ <span class="quote">相邻</span> ”</span>应用程序的输入和输出目标来实现此方案。</p><p>假设设计要求Time Source应用程序将数据发送到Log Sink应用程序。您可以使用一个名为<code class="literal">ticktock</code>用于两个应用程序中的绑定。</p><p>时间来源（具有频道名称<code class="literal">output</code> ）将设置以下属性：</p><pre class="screen">spring.cloud.stream.bindings.output.destination=ticktock</pre><p>日志接收器（具有通道名称<code class="literal">input</code> ）将设置以下属性：</p><pre class="screen">spring.cloud.stream.bindings.input.destination=ticktock</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-instance-index-instance-count" href="#spring-cloud-stream-overview-instance-index-instance-count"></a> 34.2实例索引和实例计数</h2></div></div></div><p>在扩展Spring Cloud Stream应用程序时，每个实例都可以接收有关同一应用程序还存在多少其他实例以及它自己的实例索引是什么的信息。Spring Cloud Stream通过<code class="literal">spring.cloud.stream.instanceCount</code>和<code class="literal">spring.cloud.stream.instanceIndex</code>属性。例如，如果存在HDFS接收器应用程序的三个实例，则所有三个实例都具有<code class="literal">spring.cloud.stream.instanceCount</code>调成<code class="literal">3</code> ，并且各个应用程序都有<code class="literal">spring.cloud.stream.instanceIndex</code>调成<code class="literal">0</code> ， <code class="literal">1</code>和<code class="literal">2</code> ， 分别。</p><p>当通过Spring Cloud Data Flow部署Spring Cloud Stream应用程序时，这些属性会自动配置。当独立启动Spring Cloud Stream应用程序时，必须正确设置这些属性。默认， <code class="literal">spring.cloud.stream.instanceCount</code>是<code class="literal">1</code>和<code class="literal">spring.cloud.stream.instanceIndex</code>是<code class="literal">0</code> 。</p><p>在按比例放大的方案中，正确地配置这两个属性通常对于解决分区行为很重要（请参见下文），并且某些绑定程序（例如，Kafka绑定程序）始终需要这两个属性，以确保数据在多个使用者实例之间正确划分。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-stream-overview-partitioning" href="#spring-cloud-stream-overview-partitioning"></a> 34.3分区</h2></div></div></div><p>在Spring Cloud Stream中进行分区包括两个任务：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning" title="34.3.1配置用于分区的输出绑定">第34.3.1节“配置用于分区的输出绑定”</a></span> ”</span></li><li class="listitem"><span class="quote">“ <span class="quote"><a class="xref" href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning" title="34.3.2配置用于分区的输入绑定">第34.3.2节“配置用于分区的输入绑定”</a></span> ”</span></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-overview-configuring-output-bindings-partitioning" href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning"></a> 34.3.1配置用于分区的输出绑定</h3></div></div></div><p>您可以通过设置输出绑定中的一个和仅一个来配置输出绑定以发送分区数据<code class="literal">partitionKeyExpression</code>要么<code class="literal">partitionKeyExtractorName</code>属性及其<code class="literal">partitionCount</code>属性。</p><p>例如，以下是有效的典型配置：</p><pre class="screen">spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id
spring.cloud.stream.bindings.output.producer.partitionCount=5</pre><p>基于该示例配置，通过使用以下逻辑将数据发送到目标分区。</p><p>根据发送给分区输出通道的每条消息计算分区键的值<code class="literal">partitionKeyExpression</code> 。的<code class="literal">partitionKeyExpression</code>是一个SpEL表达式，该表达式根据出站消息进行评估以提取分区键。</p><p>如果SpEL表达式不足以满足您的需要，则可以通过提供以下实现来计算分区键值： <code class="literal">org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>并将其配置为Bean（通过使用<code class="literal">@Bean</code>注解）。如果您有一个以上类型的bean <code class="literal">org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>在“应用程序上下文”中可用，您可以通过使用<code class="literal">partitionKeyExtractorName</code>属性，如以下示例所示：</p><pre class="screen">--spring.cloud.stream.bindings.output.producer.partitionKeyExtractorName=customPartitionKeyExtractor
--spring.cloud.stream.bindings.output.producer.partitionCount=5
. . .
@Bean
public CustomPartitionKeyExtractorClass customPartitionKeyExtractor() {
    return new CustomPartitionKeyExtractorClass();
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在以前的Spring Cloud Stream版本中，您可以指定<code class="literal">org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>通过设置<code class="literal">spring.cloud.stream.bindings.output.producer.partitionKeyExtractorClass</code>属性。从2.0版开始，不推荐使用此属性，并且在将来的版本中将删除对此属性的支持。</p></td></tr></tbody></table></div><p>计算完消息密钥后，分区选择过程会将目标分区确定为<code class="literal">0</code>和<code class="literal">partitionCount - 1</code> 。适用于大多数情况的默认计算基于以下公式： <code class="literal">key.hashCode() % partitionCount</code> 。可以在绑定上进行自定义，方法是将SpEL表达式设置为针对“键”进行评估（通过<code class="literal">partitionSelectorExpression</code>属性）或通过配置以下实现<code class="literal">org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code>作为bean（通过使用@Bean批注）。类似于<code class="literal">PartitionKeyExtractorStrategy</code> ，您可以使用<code class="literal">spring.cloud.stream.bindings.output.producer.partitionSelectorName</code>当应用程序上下文中有多个这种类型的bean可用时，此属性，如以下示例所示：</p><pre class="screen">--spring.cloud.stream.bindings.output.producer.partitionSelectorName=customPartitionSelector
. . .
@Bean
public CustomPartitionSelectorClass customPartitionSelector() {
    return new CustomPartitionSelectorClass();
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在以前的Spring Cloud Stream版本中，您可以指定<code class="literal">org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code>通过设置<code class="literal">spring.cloud.stream.bindings.output.producer.partitionSelectorClass</code>属性。从2.0版开始，不推荐使用此属性，并且在将来的版本中将不再支持该属性。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-stream-overview-configuring-input-bindings-partitioning" href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning"></a> 34.3.2配置用于分区的输入绑定</h3></div></div></div><p>输入绑定（带有频道名称<code class="literal">input</code> ）配置为通过设置分区数据来接收分区数据<code class="literal">partitioned</code>财产以及<code class="literal">instanceIndex</code>和<code class="literal">instanceCount</code>应用程序本身的属性，如以下示例所示：</p><pre class="screen">spring.cloud.stream.bindings.input.consumer.partitioned=true
spring.cloud.stream.instanceIndex=3
spring.cloud.stream.instanceCount=5</pre><p>的<code class="literal">instanceCount</code> value表示应在其之间分区数据的应用程序实例的总数。的<code class="literal">instanceIndex</code>在多个实例中必须是唯一值，且介于<code class="literal">0</code>和<code class="literal">instanceCount - 1</code> 。实例索引可帮助每个应用程序实例识别从中接收数据的唯一分区。活页夹要求使用不支持本地分区的技术。例如，对于RabbitMQ，每个分区都有一个队列，该队列名称包含实例索引。如果使用Kafka， <code class="literal">autoRebalanceEnabled</code>是<code class="literal">true</code> （默认），Kafka负责在实例之间分配分区，并且不需要这些属性。如果<code class="literal">autoRebalanceEnabled</code>设置为false， <code class="literal">instanceCount</code>和<code class="literal">instanceIndex</code>绑定程序使用来确定实例预订的分区（您必须拥有至少与实例一样多的分区）。活页夹分配分区而不是Kafka。如果您希望特定分区的消息始终发送到同一实例，这可能会很有用。当活页夹配置需要它们时，重要的是正确设置两个值，以确保使用所有数据并确保应用程序实例接收互斥的数据集。</p><p>尽管在单独情况下使用多个实例进行分区数据处理可能会很复杂，但Spring Cloud Dataflow可以通过正确填充输入和输出值以及让您依赖运行时基础架构来显着简化流程。提供有关实例索引和实例计数的信息。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_testing" href="#_testing"></a> 35岁测试中</h2></div></div></div><p>Spring Cloud Stream支持在不连接消息传递系统的情况下测试您的微服务应用程序。您可以使用<code class="literal">TestSupportBinder</code>由...提供<code class="literal">spring-cloud-stream-test-support</code>库，可以作为测试依赖项添加到应用程序中，如以下示例所示：</p><pre class="programlisting">   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-test-support<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
       <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">TestSupportBinder</code>使用Spring Boot自动配置机制取代在类路径上找到的其他绑定器。因此，在添加活页夹作为依赖项时，必须确保<code class="literal">test</code>作用域正在被使用。</p></td></tr></tbody></table></div><p>的<code class="literal">TestSupportBinder</code>使您可以与绑定的通道进行交互，并检查应用程序发送和接收的所有消息。</p><p>对于出站邮件渠道， <code class="literal">TestSupportBinder</code>注册一个订户，并将应用程序发出的消息保留在<code class="literal">MessageCollector</code> 。在测试期间可以检索它们，并针对它们进行断言。</p><p>您还可以将消息发送到入站消息通道，以便使用者应用程序可以使用消息。以下示例显示了如何在处理器上测试输入和输出通道：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ExampleTest {

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Processor processor;

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MessageCollector messageCollector;

  <em><span class="hl-annotation" style="color: gray">@Test</span></em>
  <em><span class="hl-annotation" style="color: gray">@SuppressWarnings("unchecked")</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> testWiring() {
    Message&lt;String&gt; message = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GenericMessage&lt;&gt;(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"hello"</span>);
    processor.input().send(message);
    Message&lt;String&gt; received = (Message&lt;String&gt;) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"hello world"</span>));
  }


  <em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
  <em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyProcessor {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Processor channels;

    <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String transform(String in) {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> in + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" world"</span>;
    }
  }
}</pre><p>在前面的示例中，我们创建了一个具有输入通道和输出通道的应用程序，它们都通过<code class="literal">Processor</code>接口。绑定的接口被注入到测试中，以便我们可以访问两个通道。我们在输入通道上发送一条消息，然后使用<code class="literal">MessageCollector</code>由Spring Cloud Stream的测试支持提供，以捕获消息已作为结果发送到输出通道。收到消息后，我们可以验证组件是否正常运行。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_disabling_the_test_binder_autoconfiguration" href="#_disabling_the_test_binder_autoconfiguration"></a> 35.1禁用测试绑定程序自动配置</h2></div></div></div><p>测试绑定程序背后的目的是取代类路径上的所有其他绑定程序，以使其易于测试您的应用程序而无需更改生产依赖性。在某些情况下（例如，集成测试），可以使用实际的生产绑定程序来代替，这需要禁用测试绑定程序自动配置。为此，您可以排除<code class="literal">org.springframework.cloud.stream.test.binder.TestSupportBinderAutoConfiguration</code>通过使用Spring Boot自动配置排除机制之一来实现类，如以下示例所示：</p><pre class="programlisting">    <em><span class="hl-annotation" style="color: gray">@SpringBootApplication(exclude = TestSupportBinderAutoConfiguration.class)</span></em>
    <em><span class="hl-annotation" style="color: gray">@EnableBinding(Processor.class)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyProcessor {

        <em><span class="hl-annotation" style="color: gray">@Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)</span></em>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String transform(String in) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> in + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" world"</span>;
        }
    }</pre><p>禁用自动配置后，测试绑定程序可在类路径及其上使用<code class="literal">defaultCandidate</code>属性设置为<code class="literal">false</code>因此它不会干扰常规用户配置。可以在名称下引用它， <code class="literal">test</code> ，如以下示例所示：</p><p><code class="literal">spring.cloud.stream.defaultBinder=test</code></p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_health_indicator_5" href="#_health_indicator_5"></a> 36。健康指标</h2></div></div></div><p>Spring Cloud Stream为活页夹提供了健康指标。它以名称注册<code class="literal">binders</code>并可以通过设置<code class="literal">management.health.binders.enabled</code>属性。</p><p>默认<code class="literal">management.health.binders.enabled</code>被设定为<code class="literal">false</code> 。设置<code class="literal">management.health.binders.enabled</code>至<code class="literal">true</code>启用运行状况指示器，使您可以访问<code class="literal">/health</code>端点以获取活页夹健康指标。</p><p>健康指标是特定于活页夹的，某些活页夹实现不一定提供健康指标。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-stream-overview-metrics-emitter" href="#spring-cloud-stream-overview-metrics-emitter"></a> 37。公制发射器</h2></div></div></div><p>Spring Boot Actuator为<a class="link" href="https://micrometer.io/" target="_top">Micrometer</a>提供了依赖项管理和自动配置， <a class="link" href="https://micrometer.io/" target="_top">Micrometer</a>是一种支持多种<a class="link" href="https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#production-ready-metrics" target="_top">监视系统</a>的应用程序指标外观。</p><p>Spring Cloud Stream提供了将任何可用的基于千分尺的度量标准发送到绑定目标的支持，从而允许从流应用程序定期收集度量标准数据，而无需依赖于轮询各个端点。</p><p>通过定义<code class="literal">spring.cloud.stream.bindings.applicationMetrics.destination</code>属性，它指定当前绑定程序用于发布度量标准消息的绑定目标的名称。</p><p>例如：</p><pre class="programlisting">spring.cloud.stream.bindings.applicationMetrics.destination=myMetricDestination</pre><p>前面的示例指示活页夹绑定到<code class="literal">myMetricDestination</code> （即Rabbit交流，Kafka主题等）。</p><p>以下属性可用于自定义指标的发出：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.metrics.key</span></dt><dd><p class="simpara">发出的度量标准的名称。每个应用程序应为唯一值。</p><p class="simpara">默认：<code class="literal">${spring.application.name:${vcap.application.name:${spring.config.name:application}}}</code></p></dd><dt><span class="term">spring.cloud.stream.metrics.properties</span></dt><dd><p class="simpara">允许白名单应用程序属性添加到度量有效负载</p><p class="simpara">默认值：null。</p></dd><dt><span class="term">spring.cloud.stream.metrics.meter-filter</span></dt><dd><p class="simpara">控制要捕获的“仪表”的模式。例如，指定<code class="literal">spring.integration.*</code>捕获名称以“。”开头的仪表的度量标准信息<code class="literal">spring.integration.</code></p><p class="simpara">默认值：捕获所有“仪表”。</p></dd><dt><span class="term">spring.cloud.stream.metrics.schedule-interval</span></dt><dd><p class="simpara">控制发布度量标准数据的速率的时间间隔。</p><p class="simpara">默认值：1分钟</p></dd></dl></div><p>考虑以下：</p><pre class="programlisting">java -jar time-source.jar \
    --spring.cloud.stream.bindings.applicationMetrics.destination=someMetrics \
    --spring.cloud.stream.metrics.properties=spring.application** \
    --spring.cloud.stream.metrics.meter-filter=spring.integration.*</pre><p>下面的示例显示由于上述命令而发布到绑定目标的数据的有效负载：</p><pre class="programlisting">{
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application"</span>,
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"createdTime"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2018-03-23T14:48:12.700Z"</span>,
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"properties"</span>: {
	},
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"metrics"</span>: [
		{
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>: {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring.integration.send"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tags"</span>: [
					{
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"key"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"exception"</span>,
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"value"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"none"</span>
					},
					{
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"key"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>,
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"value"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"input"</span>
					},
					{
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"key"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"result"</span>,
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"value"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"success"</span>
					},
					{
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"key"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"type"</span>,
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"value"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"channel"</span>
					}
				],
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"TIMER"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"description"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Send processing time"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"baseUnit"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"milliseconds"</span>
			},
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"timestamp"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2018-03-23T14:48:12.697Z"</span>,
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"sum"</span>: <span class="hl-number">130.340546</span>,
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"count"</span>: <span class="hl-number">6</span>,
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"mean"</span>: <span class="hl-number">21.72342433333333</span>,
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"upper"</span>: <span class="hl-number">116.176299</span>,
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"total"</span>: <span class="hl-number">130.340546</span>
		}
	]
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>鉴于在迁移到Micrometer后，“公制”消息的格式已略有更改，因此发布的消息还将具有一个<code class="literal">STREAM_CLOUD_STREAM_VERSION</code>标头设置为<code class="literal">2.x</code>以帮助区分旧版Spring Cloud Stream中的Metric消息。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_samples" href="#_samples"></a> 38。样品</h2></div></div></div><p>有关Spring Cloud Stream示例，请参阅GitHub上的<a class="link" href="https://github.com/spring-cloud/spring-cloud-stream-samples" target="_top">spring-cloud-stream-samples</a>存储库。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_deploying_stream_applications_on_cloudfoundry" href="#_deploying_stream_applications_on_cloudfoundry"></a> 38.1在CloudFoundry上部署流应用程序</h2></div></div></div><p>在CloudFoundry上，通常通过称为<a class="link" href="https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES" target="_top">VCAP_SERVICES</a>的特殊环境变量来公开服务。</p><p>配置活页夹连接时，可以使用环境变量中的值，如<a class="link" href="http://docs.spring.io/spring-cloud-dataflow-server-cloudfoundry/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-ups" target="_top">数据流Cloud Foundry Server</a>文档中所述。</p></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_binder_implementations" href="#_binder_implementations"></a>第六部分活页夹实现</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_apache_kafka_binder" href="#_apache_kafka_binder"></a> 39。Apache Kafka活页夹</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_usage" href="#_usage"></a> 39.1使用</h2></div></div></div><p>要使用Apache Kafka活页夹，您需要添加<code class="literal">spring-cloud-stream-binder-kafka</code>作为对Spring Cloud Stream应用程序的依赖关系，如以下Maven示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-binder-kafka<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>另外，您也可以使用Spring Cloud Stream Kafka Starter，如以下针对Maven的示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-stream-kafka<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_apache_kafka_binder_overview" href="#_apache_kafka_binder_overview"></a> 39.2 Apache Kafka Binder概述</h2></div></div></div><p>下图显示了Apache Kafka活页夹的工作方式的简化图：</p><div class="figure"><a name="d0e12212" href="#d0e12212"></a><p class="title"><b>图39.1。卡夫卡·宾德</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/images/kafka-binder.png" alt="卡夫卡粘合剂"></div></div></div><br class="figure-break"><p>Apache Kafka Binder实现将每个目标映射到一个Apache Kafka主题。消费者组直接映射到相同的Apache Kafka概念。分区也直接映射到Apache Kafka分区。</p><p>资料夹目前使用Apache Kafka <code class="literal">kafka-clients</code> 1.0.0 jar，旨在与至少该版本的代理一起使用。该客户端可以与较旧的代理进行通信（请参阅Kafka文档），但是某些功能可能不可用。例如，对于低于0.11.xx的版本，不支持本机头。此外，0.11.xx不支持<code class="literal">autoAddPartitions</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_options_2" href="#_configuration_options_2"></a> 39.3配置选项</h2></div></div></div><p>本节包含Apache Kafka活页夹使用的配置选项。</p><p>常见配置选项和属性有关粘合剂，请参阅<a class="link" href="#binding-properties" title="31.2绑定属性">核心文档</a> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_kafka_binder_properties" href="#_kafka_binder_properties"></a> 39.3.1 Kafka活页夹属性</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.kafka.binder.brokers</span></dt><dd><p class="simpara">Kafka活页夹连接到的经纪人列表。</p><p class="simpara">默认： <code class="literal">localhost</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.defaultBrokerPort</span></dt><dd><p class="simpara"><code class="literal">brokers</code>允许指定带有或不带有端口信息的主机（例如， <code class="literal">host1,host2:port2</code> ）。当代理列表中未配置任何端口时，这将设置默认端口。</p><p class="simpara">默认： <code class="literal">9092</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.configuration</span></dt><dd><p class="simpara">客户端属性（生产者和消费者）的键/值映射传递给绑定程序创建的所有客户端。由于生产者和消费者都使用了这些属性，因此应将使用限制为通用属性，例如安全性设置。此处的属性取代引导中设置的所有属性。</p><p class="simpara">默认值：空地图。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.consumerProperties</span></dt><dd><p class="simpara">任意Kafka客户端使用者属性的键/值映射。此处的属性将取代引导和<code class="literal">configuration</code>上面的属性。</p><p class="simpara">默认值：空地图。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.headers</span></dt><dd><p class="simpara">活页夹传输的自定义标头列表。仅当与较旧的应用程序（⇐1.3.x）进行通信时，才需要<code class="literal">kafka-clients</code>版本<0.11.0.0。较新的版本本机支持标头。</p><p class="simpara">默认值：空。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.healthTimeout</span></dt><dd><p class="simpara">等待获取分区信息的时间，以秒为单位。如果此计时器到期，运行状况将报告为已关闭。</p><p class="simpara">默认值：10</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.requiredAcks</span></dt><dd><p class="simpara">代理程序上所需的确认数。请参阅生产者的Kafka文档<code class="literal">acks</code>属性。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.minPartitionCount</span></dt><dd><p class="simpara">仅在以下情况下有效<code class="literal">autoCreateTopics</code>要么<code class="literal">autoAddPartitions</code>被设置。活页夹在生成或使用数据的主题上配置的全局最小分区数。它可以被<code class="literal">partitionCount</code>生产者的设置或按<code class="literal">instanceCount * concurrency</code>生产者的设置（如果较大）。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.producer属性</span></dt><dd><p class="simpara">任意Kafka客户端生产者属性的键/值映射。此处的属性将取代引导和<code class="literal">configuration</code>上面的属性。</p><p class="simpara">默认值：空地图。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.replicationFactor</span></dt><dd><p class="simpara">自动创建的主题的复制因子是否<code class="literal">autoCreateTopics</code>活跃。可以在每个绑定上覆盖。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.autoCreateTopics</span></dt><dd><p class="simpara">如果设置为<code class="literal">true</code> ，活页夹将自动创建新主题。如果设置为<code class="literal">false</code> ，活页夹依赖于已经配置的主题。在后一种情况下，如果主题不存在，则活页夹无法启动。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>此设置独立于<code class="literal">auto.topic.create.enable</code>经纪人的设置，并且不影响它。如果服务器设置为自动创建主题，则可以使用默认代理设置将它们作为元数据检索请求的一部分进行创建。</p></td></tr></tbody></table></div><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.autoAddPartitions</span></dt><dd><p class="simpara">如果设置为<code class="literal">true</code> ，活页夹会根据需要创建新的分区。如果设置为<code class="literal">false</code> ，活页夹依赖于已配置的主题的分区大小。如果目标主题的分区数小于预期值，则活页夹无法启动。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.transaction.transactionIdPrefix</span></dt><dd><p class="simpara">在活页夹中启用事务。看到<code class="literal">transaction.id</code>在Kafka文档和<a class="link" href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#transactions" target="_top">Transactions</a>中<code class="literal">spring-kafka</code>文档。启用交易后，个人<code class="literal">producer</code>属性会被忽略，所有生产者都会使用<code class="literal">spring.cloud.stream.kafka.binder.transaction.producer.*</code>属性。</p><p class="simpara">默认<code class="literal">null</code> （无交易）</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.transaction.producer。*</span></dt><dd><p class="simpara">交易绑定中生产者的全球生产者属性。看到<code class="literal">spring.cloud.stream.kafka.binder.transaction.transactionIdPrefix</code>和<a class="xref" href="#kafka-producer-properties" title="39.3.3 Kafka生产者属性">第39.3.3节“ Kafka生产者属性”</a>以及所有粘合剂支持的一般生产者属性。</p><p class="simpara">默认值：请参见各个生产者属性。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.headerMapperBeanName</span></dt><dd><p class="simpara">一个的bean名称<code class="literal">KafkaHeaderMapper</code>用于映射<code class="literal">spring-messaging</code>与Kafka标头之间的标头。例如，如果您希望在<code class="literal">DefaultKafkaHeaderMapper</code>使用JSON反序列化的标头。</p><p class="simpara">默认值：无。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kafka-consumer-properties" href="#kafka-consumer-properties"></a> 39.3.2 Kafka消费者属性</h3></div></div></div><p>以下属性仅适用于Kafka使用者，并且必须加上前缀<code class="literal">spring.cloud.stream.kafka.bindings.<channelName>.consumer.</code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">管理员配置</span></dt><dd><p class="simpara">一种<code class="literal">Map</code>设置主题时使用的Kafka主题属性的集合-例如，<code class="literal">spring.cloud.stream.kafka.bindings.input.consumer.admin.configuration.message.format.version=0.9.0.0</code></p><p class="simpara">默认值：无。</p></dd><dt><span class="term">管理员副本分配</span></dt><dd><p class="simpara"><integer, list<integer="">副本分配的 Map <integer, list<integer="">>，键为分区，值为分配。在配置新主题时使用。见<code class="literal">NewTopic</code>中的Javadocs <code class="literal">kafka-clients</code>罐。</integer,></integer,></p><p class="simpara">默认值：无。</p></dd><dt><span class="term">管理员复制因子</span></dt><dd><p class="simpara">设置主题时要使用的复制因子。覆盖活页夹范围的设置。忽略是否<code class="literal">replicas-assignments</code>存在。</p><p class="simpara">默认值：无（使用资料夹范围的默认值1）。</p></dd><dt><span class="term">autoRebalanceEnabled</span></dt><dd><p class="simpara">什么时候<code class="literal">true</code> ，主题分区会自动在使用者组的成员之间重新平衡。什么时候<code class="literal">false</code> ，则根据以下情况为每个使用者分配固定的分区集： <code class="literal">spring.cloud.stream.instanceCount</code>和<code class="literal">spring.cloud.stream.instanceIndex</code> 。这需要<code class="literal">spring.cloud.stream.instanceCount</code>和<code class="literal">spring.cloud.stream.instanceIndex</code>在每个启动的实例上适当设置的属性。的价值<code class="literal">spring.cloud.stream.instanceCount</code>在这种情况下，属性通常必须大于1。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">ackEachRecord</span></dt><dd><p class="simpara">什么时候<code class="literal">autoCommitOffset</code>是<code class="literal">true</code> ，此设置指示在处理每个记录后是否提交偏移量。默认情况下，偏移量是在由返回的记录批次中的所有记录之后提交的<code class="literal">consumer.poll()</code>已处理。轮询返回的记录数可以用<code class="literal">max.poll.records</code>卡夫卡财产，由消费者设定<code class="literal">configuration</code>属性。设置为<code class="literal">true</code>可能会导致性能下降，但是这样做会减少发生故障时重新传送记录的可能性。另外，请参阅活页夹<code class="literal">requiredAcks</code>属性，这也会影响提交偏移量的性能。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">autoCommitOffset</span></dt><dd><p class="simpara">处理消息后是否自动提交偏移量。如果设置为<code class="literal">false</code> ，带有键的标题<code class="literal">kafka_acknowledgment</code>类型的<code class="literal">org.springframework.kafka.support.Acknowledgment</code>标头出现在入站消息中。应用程序可以使用此标头来确认消息。有关详细信息，请参见示例部分。当此属性设置为<code class="literal">false</code> ，Kafka活页夹将ack模式设置为<code class="literal">org.springframework.kafka.listener.AbstractMessageListenerContainer.AckMode.MANUAL</code>该应用程序负责确认记录。另见<code class="literal">ackEachRecord</code> 。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">autoCommitOnError</span></dt><dd><p class="simpara">仅在以下情况下有效<code class="literal">autoCommitOffset</code>被设定为<code class="literal">true</code> 。如果设置为<code class="literal">false</code> ，它会抑制导致错误的消息的自动提交，并且仅对成功的消息进行提交。如果持续出现故障，它允许流从上次成功处理的消息自动重播。如果设置为<code class="literal">true</code> ，它将始终自动提交（如果启用了自动提交）。如果未设置（默认值），则其有效值与<code class="literal">enableDlq</code> ，如果将错误消息发送到DLQ，则自动提交错误消息，否则不提交。</p><p class="simpara">默认值：未设置。</p></dd><dt><span class="term">resetOffsets</span></dt><dd><p class="simpara">是否将使用者的偏移量重置为startOffset提供的值。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">startOffset</span></dt><dd><p class="simpara">新组的起始偏移量。允许值： <code class="literal">earliest</code>和<code class="literal">latest</code> 。如果为消费者“绑定”明确设置了消费者组（通过<code class="literal">spring.cloud.stream.bindings.<channelName>.group</code> ），“ startOffset”设置为<code class="literal">earliest</code> 。否则，它设置为<code class="literal">latest</code>为了<code class="literal">anonymous</code>消费群体。另见<code class="literal">resetOffsets</code> （在此列表的前面）。</p><p class="simpara">默认值：null（等效于<code class="literal">earliest</code> ）。</p></dd><dt><span class="term">enableDlq</span></dt><dd><p class="simpara">设置为true时，它将为使用者启用DLQ行为。默认情况下，导致错误的消息将转发到名为<code class="literal">error.<destination>.<group></code> 。DLQ主题名称可以通过设置<code class="literal">dlqName</code>属性。当错误数量相对较少并且重放整个原始主题可能太麻烦时，这为更常见的Kafka重播方案提供了一个替代选项。见<a class="xref" href="#kafka-dlq-processing" title="39.6死信主题处理">节39.6，“死信主题处理”</a>的处理以获取更多信息。从2.0版开始，发送到DLQ主题的消息通过以下标头得到增强： <code class="literal">x-original-topic</code> ， <code class="literal">x-exception-message</code>和<code class="literal">x-exception-stacktrace</code>如<code class="literal">byte[]</code> 。
<span class="strong"><strong>何时不允许<code class="literal">destinationIsPattern</code>是<code class="literal">true</code> 。</strong></span></p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">组态</span></dt><dd><p class="simpara">使用包含通用Kafka使用者属性的键/值对进行映射。</p><p class="simpara">默认值：空地图。</p></dd><dt><span class="term">dlqName</span></dt><dd><p class="simpara">接收错误消息的DLQ主题的名称。</p><p class="simpara">默认值：null（如果未指定，则导致错误的消息将转发到名为<code class="literal">error.<destination>.<group></code> ）。</p></dd><dt><span class="term">dlqProducerProperties</span></dt><dd><p class="simpara">使用此功能，可以设置特定于DLQ的生产者属性。通过kafka生产者属性可以使用的所有属性都可以通过该属性设置。</p><p class="simpara">默认值：默认的Kafka生产者属性。</p></dd><dt><span class="term">标头</span></dt><dd><p class="simpara">指示入站通道适配器填充哪些标准头。允许值： <code class="literal">none</code> ， <code class="literal">id</code> ， <code class="literal">timestamp</code> ， 要么<code class="literal">both</code> 。如果使用本机反序列化并且第一个组件接收消息需要<code class="literal">id</code> （例如配置为使用JDBC消息存储库的聚合器）。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">converterBeanName</span></dt><dd><p class="simpara">实现的bean的名称<code class="literal">RecordMessageConverter</code> 。用于入站通道适配器以替换默认适配器<code class="literal">MessagingMessageConverter</code> 。</p><p class="simpara">默认：<code class="literal">null</code></p></dd><dt><span class="term">idleEventInterval</span></dt><dd><p class="simpara">事件之间的间隔（以毫秒为单位），指示最近未接收到任何消息。使用<code class="literal">ApplicationListener<ListenerContainerIdleEvent></code>接收这些事件。见<a class="xref" href="#pause-resume" title="示例：暂停和恢复使用方">称为章节“实施例：暂停和恢复消费者”</a>为一个使用示例。</p><p class="simpara">默认：<code class="literal">30000</code></p></dd><dt><span class="term">destinationIsPattern</span></dt><dd><p class="simpara">如果为true，则将目的地视为正则表达式<code class="literal">Pattern</code>用于由代理匹配主题名称。如果为true，则不设置主题，并且<code class="literal">enableDlq</code>不允许，因为绑定者在供应阶段不知道主题名称。请注意，检测与模式匹配的新主题所花费的时间由消费者属性控制<code class="literal">metadata.max.age.ms</code> ，（在撰写本文时）默认为300,000ms（5分钟）。可以使用<code class="literal">configuration</code>上面的属性。</p><p class="simpara">默认：<code class="literal">false</code></p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kafka-producer-properties" href="#kafka-producer-properties"></a> 39.3.3 Kafka生产者属性</h3></div></div></div><p>以下属性仅适用于Kafka生产者，并且必须使用前缀<code class="literal">spring.cloud.stream.kafka.bindings.<channelName>.producer.</code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">管理员配置</span></dt><dd><p class="simpara">一种<code class="literal">Map</code>设置新主题时使用的Kafka主题属性的集合-例如，<code class="literal">spring.cloud.stream.kafka.bindings.input.consumer.admin.configuration.message.format.version=0.9.0.0</code></p><p class="simpara">默认值：无。</p></dd><dt><span class="term">管理员副本分配</span></dt><dd><p class="simpara"><integer, list<integer="">副本分配的 Map <integer, list<integer="">>，键为分区，值为分配。在配置新主题时使用。看到<code class="literal">NewTopic</code>中的javadocs <code class="literal">kafka-clients</code>罐。</integer,></integer,></p><p class="simpara">默认值：无。</p></dd><dt><span class="term">管理员复制因子</span></dt><dd><p class="simpara">设置新主题时要使用的复制因子。覆盖活页夹范围的设置。忽略是否<code class="literal">replicas-assignments</code>存在。</p><p class="simpara">默认值：无（使用资料夹范围的默认值1）。</p></dd><dt><span class="term">缓冲区大小</span></dt><dd><p class="simpara">Kafka生产者在发送前尝试分批处理的数据量的上限（以字节为单位）。</p><p class="simpara">默认： <code class="literal">16384</code> 。</p></dd><dt><span class="term">同步</span></dt><dd><p class="simpara">生产者是否同步。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">batchTimeout</span></dt><dd><p class="simpara">生产者在发送消息之前要等待多长时间才能在同一批中累积更多消息。（通常，生产者根本不等待，仅发送在上一次发送过程中累积的所有消息。）非零值可能会增加吞吐量，但会增加延迟。</p><p class="simpara">默认： <code class="literal">0</code> 。</p></dd><dt><span class="term">messageKeyExpression</span></dt><dd><p class="simpara">根据用于填充产生的Kafka消息密钥的传出消息评估SpEL表达式-例如， <code class="literal">headers['myKey']</code> 。有效负载无法使用，因为在计算此表达式时，有效负载已经采用了<code class="literal">byte[]</code> 。</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">headerPatterns</span></dt><dd><p class="simpara">以逗号分隔的简单模式列表，以匹配要映射到Kafka的Spring消息头。 <code class="literal">Headers</code>在里面<code class="literal">ProducerRecord</code> 。模式可以以通配符（星号）开头或结尾。可以使用前缀前缀来否定模式<code class="literal">!</code> 。比赛在第一个比赛（正数或负数）之后停止。例如<code class="literal">!ask,as*</code>将通过<code class="literal">ash</code>但不是<code class="literal">ask</code> 。
<code class="literal">id</code>和<code class="literal">timestamp</code>永远不会被映射。</p><p class="simpara">默认： <code class="literal">*</code> （所有标头-除了<code class="literal">id</code>和<code class="literal">timestamp</code> ）</p></dd><dt><span class="term">组态</span></dt><dd><p class="simpara">使用包含通用Kafka生产者属性的键/值对进行映射。</p><p class="simpara">默认值：空地图。</p></dd></dl></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Kafka活页夹使用<code class="literal">partitionCount</code>生产者的设置，以提示创建具有给定分区数的主题（与<code class="literal">minPartitionCount</code> ，两个中的最大值就是所使用的值）。同时配置两者时请小心<code class="literal">minPartitionCount</code>用于粘合剂和<code class="literal">partitionCount</code>对于应用程序，使用较大的值。如果一个主题已经存在且分区数较小，并且<code class="literal">autoAddPartitions</code>如果禁用（默认），则绑定器无法启动。如果一个主题已经存在且分区数较小，并且<code class="literal">autoAddPartitions</code>启用后，将添加新分区。如果已经存在一个主题，且其分区数量大于（ <code class="literal">minPartitionCount</code>要么<code class="literal">partitionCount</code> ），则使用现有分区计数。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_usage_examples" href="#_usage_examples"></a> 39.3.4使用示例</h3></div></div></div><p>在本节中，我们显示了针对特定场景使用前面的属性。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_example_setting_autocommitoffset_to_false_and_relying_on_manual_acking" href="#_example_setting_autocommitoffset_to_false_and_relying_on_manual_acking"></a>示例：设置<code class="literal">autoCommitOffset</code>至<code class="literal">false</code>和依靠手工起搏</h4></div></div></div><p>此示例说明了如何在用户应用程序中手动确认偏移。</p><p>这个例子要求<code class="literal">spring.cloud.stream.kafka.bindings.input.consumer.autoCommitOffset</code>设置为<code class="literal">false</code> 。在您的示例中使用相应的输入通道名称。</p><pre class="screen">@SpringBootApplication
@EnableBinding(Sink.class)
public class ManuallyAcknowdledgingConsumer {

 public static void main(String[] args) {
     SpringApplication.run(ManuallyAcknowdledgingConsumer.class, args);
 }

 @StreamListener(Sink.INPUT)
 public void process(Message&lt;?&gt; message) {
     Acknowledgment acknowledgment = message.getHeaders().get(KafkaHeaders.ACKNOWLEDGMENT, Acknowledgment.class);
     if (acknowledgment != null) {
         System.out.println("Acknowledgment provided");
         acknowledgment.acknowledge();
     }
 }
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_example_security_configuration" href="#_example_security_configuration"></a>示例：安全配置</h4></div></div></div><p>Apache Kafka 0.9支持客户端和代理之间的安全连接。要利用此功能，请遵循<a class="link" href="http://kafka.apache.org/090/documentation.html#security_configclients" target="_top">Apache Kafka文档</a>中的<a class="link" href="http://docs.confluent.io/2.0.0/kafka/security.html" target="_top">准则以及Confluent文档中</a>的Kafka 0.9 <a class="link" href="http://docs.confluent.io/2.0.0/kafka/security.html" target="_top">安全准则</a> 。使用<code class="literal">spring.cloud.stream.kafka.binder.configuration</code>选项，为活页夹创建的所有客户端设置安全属性。</p><p>例如，设置<code class="literal">security.protocol</code>至<code class="literal">SASL_SSL</code> ，设置以下属性：</p><pre class="screen">spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_SSL</pre><p>可以以类似方式设置所有其他安全属性。</p><p>使用Kerberos时，请遵循<a class="link" href="http://kafka.apache.org/090/documentation.html#security_sasl_clientconfig" target="_top">参考文档</a>中的<a class="link" href="http://kafka.apache.org/090/documentation.html#security_sasl_clientconfig" target="_top">说明</a>来创建和引用JAAS配置。</p><p>Spring Cloud Stream支持通过使用JAAS配置文件和Spring Boot属性将JAAS配置信息传递到应用程序。</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_using_jaas_configuration_files" href="#_using_jaas_configuration_files"></a>使用JAAS配置文件</h5></div></div></div><p>可以使用系统属性为Spring Cloud Stream应用程序设置JAAS和（可选）krb5文件位置。以下示例显示如何通过使用JAAS配置文件使用SASL和Kerberos启动Spring Cloud Stream应用程序：</p><pre class="programlisting"> java -Djava.security.auth.login.config=/path.to/kafka_client_jaas.conf -jar log.jar \
   --spring.cloud.stream.kafka.binder.brokers=secure.server:<span class="hl-number">9092</span> \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="_using_spring_boot_properties" href="#_using_spring_boot_properties"></a>使用Spring Boot属性</h5></div></div></div><p>作为使用JAAS配置文件的替代方法，Spring Cloud Stream提供了一种通过使用Spring Boot属性为Spring Cloud Stream应用程序设置JAAS配置的机制。</p><p>以下属性可用于配置Kafka客户端的登录上下文：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.kafka.binder.jaas.loginModule</span></dt><dd><p class="simpara">登录模块名称。正常情况下无需设置。</p><p class="simpara">默认： <code class="literal">com.sun.security.auth.module.Krb5LoginModule</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.jaas.controlFlag</span></dt><dd><p class="simpara">登录模块的控制标志。</p><p class="simpara">默认： <code class="literal">required</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.binder.jaas.options</span></dt><dd><p class="simpara">使用包含登录模块选项的键/值对进行映射。</p><p class="simpara">默认值：空地图。</p></dd></dl></div><p>以下示例显示如何通过使用Spring Boot配置属性使用SASL和Kerberos启动Spring Cloud Stream应用程序：</p><pre class="programlisting"> java --spring.cloud.stream.kafka.binder.brokers=secure.server:<span class="hl-number">9092</span> \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.autoCreateTopics=false \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT \
   --spring.cloud.stream.kafka.binder.jaas.options.useKeyTab=true \
   --spring.cloud.stream.kafka.binder.jaas.options.storeKey=true \
   --spring.cloud.stream.kafka.binder.jaas.options.keyTab=/etc/security/keytabs/kafka_client.keytab \
   --spring.cloud.stream.kafka.binder.jaas.options.principal=kafka-client-<span class="hl-number">1</span>@EXAMPLE.COM</pre><p>前面的示例表示以下JAAS文件的等效项：</p><pre class="screen">KafkaClient {
    com.sun.security.auth.module.Krb5LoginModule required
    useKeyTab=true
    storeKey=true
    keyTab="/etc/security/keytabs/kafka_client.keytab"
    principal="kafka-client-1@EXAMPLE.COM";
};</pre><p>如果所需的主题已经存在于代理上或将由管理员创建，则可以关闭自动创建，仅需要发送客户端JAAS属性。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>不要在同一应用程序中混合使用JAAS配置文件和Spring Boot属性。如果<code class="literal">-Djava.security.auth.login.config</code>系统属性已经存在，Spring Cloud Stream会忽略Spring Boot属性。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>使用时要小心<code class="literal">autoCreateTopics</code>和<code class="literal">autoAddPartitions</code>使用Kerberos。通常，应用程序可能使用在Kafka和Zookeeper中没有管理权限的主体。因此，依靠Spring Cloud Stream创建/修改主题可能会失败。在安全的环境中，我们强烈建议您使用Kafka工具创建主题并以管理方式管理ACL。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="pause-resume" href="#pause-resume"></a>示例：暂停和恢复使用方</h4></div></div></div><p>如果您希望暂停使用但不引起分区重新平衡，则可以暂停并恢复使用方。通过添加<code class="literal">Consumer</code>作为您的参数<code class="literal">@StreamListener</code> 。要恢复，您需要<code class="literal">ApplicationListener</code>对于<code class="literal">ListenerContainerIdleEvent</code>实例。事件的发布频率由<code class="literal">idleEventInterval</code>属性。由于使用者不是线程安全的，因此必须在调用线程上调用这些方法。</p><p>以下简单的应用程序显示了如何暂停和恢复：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
	}

	<em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> in(String in, <em><span class="hl-annotation" style="color: gray">@Header(KafkaHeaders.CONSUMER)</span></em> Consumer&lt;?, ?&gt; consumer) {
		System.out.println(in);
		consumer.pause(Collections.singleton(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TopicPartition(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myTopic"</span>, <span class="hl-number">0</span>)));
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ApplicationListener&lt;ListenerContainerIdleEvent&gt; idleListener() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> event -&gt; {
			System.out.println(event);
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (event.getConsumer().paused().size() &gt; <span class="hl-number">0</span>) {
				event.getConsumer().resume(event.getConsumer().paused());
			}
		};
	}

}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="kafka-error-channels" href="#kafka-error-channels"></a> 39.4错误通道</h2></div></div></div><p>从版本1.3开始，绑定程序无条件地将异常发送到每个使用者目标的错误通道，也可以将其配置为将异步生产者发送失败消息发送到错误通道。有关更多信息<a class="xref" href="#spring-cloud-stream-overview-error-handling" title="29.4 Error Handling">，</a>请参见<a class="xref" href="#spring-cloud-stream-overview-error-handling" title="29.4错误处理">第29.4节“错误处理”</a> 。</p><p>的有效载荷<code class="literal">ErrorMessage</code>发送失败是<code class="literal">KafkaSendFailureException</code>具有属性：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">failedMessage</code> ：春季消息<code class="literal">Message<?></code>无法发送。</li><li class="listitem"><code class="literal">record</code> ：原始<code class="literal">ProducerRecord</code>从创建的<code class="literal">failedMessage</code></li></ul></div><p>没有生产者异常的自动处理（例如发送到<a class="link" href="#kafka-dlq-processing" title="39.6死信主题处理">Dead-Letter队列</a> ）。您可以使用自己的Spring Integration流使用这些异常。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="kafka-metrics" href="#kafka-metrics"></a> 39.5卡夫卡指标</h2></div></div></div><p>Kafka活页夹模块公开以下指标：</p><p><code class="literal">spring.cloud.stream.binder.kafka.offset</code> ：此指标指示给定的消费群体尚未从给定的活页夹主题中消费多少消息。提供的指标基于Mircometer指标库。度量标准包含消费者组信息，主题以及与主题上的最新偏移量有关的承诺偏移量的实际滞后时间。该指标对于向PaaS平台提供自动缩放反馈特别有用。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="kafka-dlq-processing" href="#kafka-dlq-processing"></a> 39.6死信主题处理</h2></div></div></div><p>因为您无法预期用户将如何处置死信，所以该框架没有提供任何标准机制来处理它们。如果死信的原因是短暂的，则您可能希望将消息路由回原始主题。但是，如果问题是永久性问题，则可能导致无限循环。本主题中的示例Spring Boot应用程序是如何将这些消息路由回原始主题的示例，但是在尝试了三遍之后，它将它们移动到了<span class="quote">“ <span class="quote">停车场</span> ”</span>主题。该应用程序是另一个从死信主题中读取的spring-cloud-stream应用程序。5秒钟未收到任何消息时，它将终止。</p><p>这些示例假定原始目的地是<code class="literal">so8400out</code>而消费群是<code class="literal">so8400</code> 。</p><p>有两种策略可供考虑：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">考虑仅在主应用程序未运行时才运行重新路由。否则，瞬态错误的重试会很快用完。</li><li class="listitem">或者，使用两阶段方法：使用此应用程序将路由到第三个主题，将另一个应用程序路由到第三个主题。</li></ul></div><p>以下代码清单显示了示例应用程序：</p><p><b>application.properties。</b>
</p><pre class="screen">spring.cloud.stream.bindings.input.group=so8400replay
spring.cloud.stream.bindings.input.destination=error.so8400out.so8400

spring.cloud.stream.bindings.output.destination=so8400out
spring.cloud.stream.bindings.output.producer.partitioned=true

spring.cloud.stream.bindings.parkingLot.destination=so8400in.parkingLot
spring.cloud.stream.bindings.parkingLot.producer.partitioned=true

spring.cloud.stream.kafka.binder.configuration.auto.offset.reset=earliest

spring.cloud.stream.kafka.binder.headers=x-retries</pre><p>
</p><p><b>应用。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(TwoOutputProcessor.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ReRouteDlqKApplication <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> CommandLineRunner {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_RETRIES_HEADER = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-retries"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        SpringApplication.run(ReRouteDlqKApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args).close();
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> AtomicInteger processed = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AtomicInteger();

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MessageChannel parkingLot;

    <em><span class="hl-annotation" style="color: gray">@StreamListener(Processor.INPUT)</span></em>
    <em><span class="hl-annotation" style="color: gray">@SendTo(Processor.OUTPUT)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Message&lt;?&gt; reRoute(Message&lt;?&gt; failed) {
        processed.incrementAndGet();
        Integer retries = failed.getHeaders().get(X_RETRIES_HEADER, Integer.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retries == null) {
            System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"First retry for "</span> + failed);
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Integer(<span class="hl-number">1</span>))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retries.intValue() &lt; <span class="hl-number">3</span>) {
            System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Another retry for "</span> + failed);
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Integer(retries.intValue() + <span class="hl-number">1</span>))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> {
            System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Retries exhausted for "</span> + failed);
            parkingLot.send(MessageBuilder.fromMessage(failed)
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build());
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> run(String... args) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> (true) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> count = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.processed.get();
            Thread.sleep(<span class="hl-number">5000</span>);
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (count == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.processed.get()) {
                System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Idle, terminating"</span>);
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>;
            }
        }
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TwoOutputProcessor <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Processor {

        <em><span class="hl-annotation" style="color: gray">@Output("parkingLot")</span></em>
        MessageChannel parkingLot();

    }

}</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_partitioning_with_the_kafka_binder" href="#_partitioning_with_the_kafka_binder"></a> 39.7使用Kafka活页夹进行分区</h2></div></div></div><p>Apache Kafka本机支持主题分区。</p><p>有时，将数据发送到特定的分区是有好处的-例如，当您要严格订购消息处理时（特定客户的所有消息应转到同一分区）。</p><p>以下示例显示了如何配置生产方和消费者方：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> KafkaPartitionProducerApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Random RANDOM = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Random(System.currentTimeMillis());

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String[] data = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> String[] {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux1"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo2"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar2"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux2"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo3"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar3"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux3"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo4"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar4"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux4"</span>,
            };

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(KafkaPartitionProducerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Message&lt;?&gt; generate() {
        String value = data[RANDOM.nextInt(data.length)];
        System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Sending: "</span> + value);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> MessageBuilder.withPayload(value)
                .setHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"partitionKey"</span>, value)
                .build();
    }

}</pre><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    stream</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      bindings</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        output</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          destination</span>: partitioned.topic
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          producer</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            partitioned</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            partition-key-expression</span>: headers[<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'partitionKey'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            partition-count</span>: <span class="hl-number">12</span></pre><p>
</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>必须为该主题提供足够的分区，以实现所有消费者组所需的并发性。上面的配置最多支持12个使用者实例（如果有6个使用者实例， <code class="literal">concurrency</code>如果它们的并发是3，则为2、4，依此类推）。通常最好<span class="quote">“ <span class="quote">过量供应</span> ”</span>分区，以便将来增加使用方或并发性。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>前面的配置使用默认分区（ <code class="literal">key.hashCode() % partitionCount</code> ）。根据键值，这可能会或可能不会提供适当的平衡算法。您可以使用<code class="literal">partitionSelectorExpression</code>要么<code class="literal">partitionSelectorClass</code>属性。</p></td></tr></tbody></table></div><p>由于分区是由Kafka本地处理的，因此在用户端不需要特殊配置。Kafka在实例之间分配分区。</p><p>以下Spring Boot应用程序侦听Kafka流并打印（到控制台）每条消息去往的分区ID：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> KafkaPartitionConsumerApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(KafkaPartitionConsumerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> listen(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String in, <em><span class="hl-annotation" style="color: gray">@Header(KafkaHeaders.RECEIVED_PARTITION_ID)</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> partition) {
        System.out.println(in + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" received from partition "</span> + partition);
    }

}</pre><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    stream</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      bindings</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        input</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          destination</span>: partitioned.topic
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          group</span>: myGroup</pre><p>
</p><p>您可以根据需要添加实例。Kafka重新平衡分区分配。如果实例计数（或<code class="literal">instance count * concurrency</code> ）超出了分区数量，一些使用者处于闲置状态。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_apache_kafka_streams_binder" href="#_apache_kafka_streams_binder"></a> 40Apache Kafka Streams活页夹</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_usage_2" href="#_usage_2"></a> 40.1使用</h2></div></div></div><p>要使用Kafka Streams绑定程序，只需使用以下Maven坐标将其添加到Spring Cloud Stream应用程序中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-binder-kafka-streams<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_kafka_streams_binder_overview" href="#_kafka_streams_binder_overview"></a> 40.2 Kafka Streams Binder概述</h2></div></div></div><p>Spring Cloud Stream的Apache Kafka支持还包括明确为Apache Kafka Streams绑定设计的绑定器实现。通过这种本机集成，Spring Cloud Stream“处理器”应用程序可以在核心业务逻辑中直接使用<a class="link" href="https://kafka.apache.org/documentation/streams/developer-guide" target="_top">Apache Kafka Streams</a> API。</p><p>Kafka Streams活页夹实现基于<a class="link" href="http://docs.spring.io/spring-kafka/reference/html/_reference.html#kafka-streams" target="_top">Spring Kafka</a>项目中<a class="link" href="http://docs.spring.io/spring-kafka/reference/html/_reference.html#kafka-streams" target="_top">Kafka Streams</a>提供的基础。</p><p>Kafka Streams活页夹为Kafka Streams中的三种主要类型（KStream，KTable和GlobalKTable）提供了绑定功能。</p><p>作为本机集成的一部分，Kafka Streams API提供的高级<a class="link" href="https://docs.confluent.io/current/streams/developer-guide/dsl-api.html" target="_top">Streams DSL</a>可用于业务逻辑。</p><p>还提供了<a class="link" href="https://docs.confluent.io/current/streams/developer-guide/processor-api.html" target="_top">处理器API</a>支持的早期版本。</p><p>如前所述，Spring Cloud Stream中的Kafka Streams支持仅在处理器模型中严格可用。可以应用一种模型，在该模型中，可以从入站主题读取消息，进行业务处理，然后可以将转换后的消息写入出站主题。它也可以用于无出站目的地的处理器应用程序中。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_streams_dsl" href="#_streams_dsl"></a> 40.2.1流DSL</h3></div></div></div><p>此应用程序使用Kafka主题中的数据（例如， <code class="literal">words</code> ），在5秒的时间窗口内为每个唯一字计算字数，然后将计算结果发送到下游主题（例如， <code class="literal">counts</code> ）进行进一步处理。</p><pre class="screen">@SpringBootApplication
@EnableBinding(KStreamProcessor.class)
public class WordCountProcessorApplication {

	@StreamListener("input")
	@SendTo("output")
	public KStream&lt;?, WordCount&gt; process(KStream&lt;?, String&gt; input) {
		return input
                .flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split("\\W+")))
                .groupBy((key, value) -&gt; value)
                .windowedBy(TimeWindows.of(5000))
                .count(Materialized.as("WordCounts-multi"))
                .toStream()
                .map((key, value) -&gt; new KeyValue&lt;&gt;(null, new WordCount(key.key(), value, new Date(key.window().start()), new Date(key.window().end()))));
    }

	public static void main(String[] args) {
		SpringApplication.run(WordCountProcessorApplication.class, args);
	}</pre><p>一旦构建为超级jar（例如， <code class="literal">wordcount-processor.jar</code> ），则可以像下面一样运行上面的示例。</p><pre class="screen">java -jar wordcount-processor.jar  --spring.cloud.stream.bindings.input.destination=words --spring.cloud.stream.bindings.output.destination=counts</pre><p>此应用程序将使用来自Kafka主题的消息<code class="literal">words</code>并将计算结果发布到输出主题<code class="literal">counts</code> 。</p><p>Spring Cloud Stream将确保来自传入和传出主题的消息都自动绑定为KStream对象。作为开发人员，您可以专注于代码的业务方面，即编写处理器中所需的逻辑。框架自动处理设置Kafka Streams基础架构所需的Streams DSL特定配置。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_options_3" href="#_configuration_options_3"></a> 40.3配置选项</h2></div></div></div><p>本节包含Kafka Streams绑定程序使用的配置选项。</p><p>有关与活页夹有关的常见配置选项和属性，请参阅<a class="link" href="#binding-properties" title="31.2绑定属性">核心文档</a> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_kafka_streams_properties" href="#_kafka_streams_properties"></a> 40.3.1 Kafka Streams属性</h3></div></div></div><p>以下属性在活页夹级别可用，并且必须带有前缀<code class="literal">spring.cloud.stream.kafka.streams.binder.</code>文字。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">组态</span></dt><dd>使用包含与Apache Kafka Streams API有关的属性的键/值对进行映射。此属性必须以开头<code class="literal">spring.cloud.stream.kafka.streams.binder.</code> 。以下是使用此属性的一些示例。</dd></dl></div><pre class="screen">spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kafka.streams.binder.configuration.commit.interval.ms=1000</pre><p>有关可能用于流配置的所有属性的更多信息，请参阅Apache Kafka Streams文档中的StreamsConfig JavaDocs。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">经纪人</span></dt><dd><p class="simpara">经纪人网址</p><p class="simpara">默认：<code class="literal">localhost</code></p></dd><dt><span class="term">zkNodes</span></dt><dd><p class="simpara">Zookeeper URL</p><p class="simpara">默认：<code class="literal">localhost</code></p></dd><dt><span class="term">serdeError</span></dt><dd><p class="simpara">反序列化错误处理程序类型。可能的值为- <code class="literal">logAndContinue</code> ， <code class="literal">logAndFail</code>要么<code class="literal">sendToDlq</code></p><p class="simpara">默认：<code class="literal">logAndFail</code></p></dd><dt><span class="term">applicationId</span></dt><dd><p class="simpara">在绑定程序级别全局设置Kafka Streams应用程序的application.id的简便方法。如果应用程序包含多个<code class="literal">StreamListener</code>方法，然后应在每个输入绑定的绑定级别设置application.id。</p><p class="simpara">默认：<code class="literal">none</code></p></dd></dl></div><p>以下属性<span class="emphasis"><em>仅</em></span>适用于Kafka Streams生产者，并且必须使用前缀<code class="literal">spring.cloud.stream.kafka.streams.bindings.<binding name>.producer.</code>文字。为了方便起见，如果存在多个输出绑定并且它们都需要一个公共值，则可以使用前缀进行配置<code class="literal">spring.cloud.stream.kafka.streams.default.producer.</code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">钥匙串</span></dt><dd><p class="simpara">要使用的密钥序列</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">valueSerde</span></dt><dd><p class="simpara">使用价值服务</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">useNativeEncoding</span></dt><dd><p class="simpara">标志以启用本机编码</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd></dl></div><p>以下属性<span class="emphasis"><em>仅</em></span>适用于Kafka Streams使用者，并且必须使用前缀<code class="literal">spring.cloud.stream.kafka.streams.bindings.<binding name>.consumer.`literal. For convenience, if there multiple input bindings and they all require a common value, that can be configured by using the prefix `spring.cloud.stream.kafka.streams.default.consumer.</code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">applicationId</span></dt><dd><p class="simpara">设置每个输入绑定的application.id。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">钥匙串</span></dt><dd><p class="simpara">要使用的密钥序列</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">valueSerde</span></dt><dd><p class="simpara">使用价值服务</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">物化为</span></dt><dd><p class="simpara">状态存储在使用传入的KTable类型时实现</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">useNativeDecoding</span></dt><dd><p class="simpara">标志以启用本机解码</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">dlqName</span></dt><dd><p class="simpara">DLQ主题名称。</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_timewindow_properties" href="#_timewindow_properties"></a> 40.3.2 TimeWindow属性：</h3></div></div></div><p>窗口化是流处理应用程序中的重要概念。以下属性可用于配置时间窗口计算。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.kafka.streams.timeWindow.length</span></dt><dd><p class="simpara">赋予此属性后，您可以自动连接<code class="literal">TimeWindows</code> bean进入应用程序。该值以毫秒为单位。</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd><dt><span class="term">spring.cloud.stream.kafka.streams.timeWindow.advanceBy</span></dt><dd><p class="simpara">值以毫秒为单位。</p><p class="simpara">默认： <code class="literal">none</code> 。</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_multiple_input_bindings" href="#_multiple_input_bindings"></a> 40.4多个输入绑定</h2></div></div></div><p>对于需要多个传入KStream对象或KStream和KTable对象的组合的用例，Kafka Streams绑定程序提供了多个绑定支持。</p><p>让我们来看看它的作用。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_multiple_input_bindings_as_a_sink" href="#_multiple_input_bindings_as_a_sink"></a> 40.4.1多个输入绑定作为接收器</h3></div></div></div><pre class="screen">@EnableBinding(KStreamKTableBinding.class)
.....
.....
@StreamListener
public void process(@Input("inputStream") KStream&lt;String, PlayEvent&gt; playEvents,
                    @Input("inputTable") KTable&lt;Long, Song&gt; songTable) {
                    ....
                    ....
}

interface KStreamKTableBinding {

    @Input("inputStream")
    KStream&lt;?, ?&gt; inputStream();

    @Input("inputTable")
    KTable&lt;?, ?&gt; inputTable();
}</pre><p>在上面的示例中，应用程序被编写为接收器，即没有输出绑定，并且应用程序必须决定有关下游处理的内容。当您以这种方式编写应用程序时，您可能需要向下游发送信息或将其存储在状态存储中（有关可查询状态存储，请参见下文）。</p><p>对于传入的KTable，如果要将计算具体化为状态存储，则必须通过以下属性将其表示。</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.inputTable.consumer.materializedAs: all-songs</pre><p>上面的示例显示了使用KTable作为输入绑定。绑定器还支持GlobalKTable的输入绑定。当您必须确保应用程序的所有实例都可以访问主题中的数据更新时，GlobalKTable绑定非常有用。KTable和GlobalKTable绑定仅在输入上可用。活页夹支持KStream的输入和输出绑定。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_multiple_input_bindings_as_a_processor" href="#_multiple_input_bindings_as_a_processor"></a> 40.4.2作为处理器的多个输入绑定</h3></div></div></div><pre class="screen">@EnableBinding(KStreamKTableBinding.class)
....
....

@StreamListener
@SendTo("output")
public KStream&lt;String, Long&gt; process(@Input("input") KStream&lt;String, Long&gt; userClicksStream,
                                     @Input("inputTable") KTable&lt;String, String&gt; userRegionsTable) {
....
....
}

interface KStreamKTableBinding extends KafkaStreamsProcessor {

    @Input("inputX")
    KTable&lt;?, ?&gt; inputTable();
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_multiple_output_bindings_aka_branching" href="#_multiple_output_bindings_aka_branching"></a> 40.5多个输出绑定（又名分支）</h2></div></div></div><p>Kafka Streams允许根据某些谓词将出站数据分为多个主题。Kafka Streams绑定程序提供对此功能的支持，而不会损害通过以下方式公开的编程模型<code class="literal">StreamListener</code>在最终用户应用程序中。</p><p>您可以按照上面在字数示例中展示的常用方法编写应用程序。但是，使用分支功能时，您需要做一些事情。首先，您需要确保您的返回类型为<code class="literal">KStream[]</code>而不是常规<code class="literal">KStream</code> 。其次，您需要使用<code class="literal">SendTo</code>按顺序包含输出绑定的注释（请参见下面的示例）。对于这些输出绑定中的每一个，您都需要配置目标，内容类型等，并符合标准Spring Cloud Stream期望。</p><p>这是一个例子：</p><pre class="screen">@EnableBinding(KStreamProcessorWithBranches.class)
@EnableAutoConfiguration
public static class WordCountProcessorApplication {

    @Autowired
    private TimeWindows timeWindows;

    @StreamListener("input")
    @SendTo({"output1","output2","output3})
    public KStream&lt;?, WordCount&gt;[] process(KStream&lt;Object, String&gt; input) {

			Predicate&lt;Object, WordCount&gt; isEnglish = (k, v) -&gt; v.word.equals("english");
			Predicate&lt;Object, WordCount&gt; isFrench =  (k, v) -&gt; v.word.equals("french");
			Predicate&lt;Object, WordCount&gt; isSpanish = (k, v) -&gt; v.word.equals("spanish");

			return input
					.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split("\\W+")))
					.groupBy((key, value) -&gt; value)
					.windowedBy(timeWindows)
					.count(Materialized.as("WordCounts-1"))
					.toStream()
					.map((key, value) -&gt; new KeyValue&lt;&gt;(null, new WordCount(key.key(), value, new Date(key.window().start()), new Date(key.window().end()))))
					.branch(isEnglish, isFrench, isSpanish);
    }

    interface KStreamProcessorWithBranches {

    		@Input("input")
    		KStream&lt;?, ?&gt; input();

    		@Output("output1")
    		KStream&lt;?, ?&gt; output1();

    		@Output("output2")
    		KStream&lt;?, ?&gt; output2();

    		@Output("output3")
    		KStream&lt;?, ?&gt; output3();
    	}
}</pre><p>特性：</p><pre class="screen">spring.cloud.stream.bindings.output1.contentType: application/json
spring.cloud.stream.bindings.output2.contentType: application/json
spring.cloud.stream.bindings.output3.contentType: application/json
spring.cloud.stream.kafka.streams.binder.configuration.commit.interval.ms: 1000
spring.cloud.stream.kafka.streams.binder.configuration:
  default.key.serde: org.apache.kafka.common.serialization.Serdes$StringSerde
  default.value.serde: org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.bindings.output1:
  destination: foo
  producer:
    headerMode: raw
spring.cloud.stream.bindings.output2:
  destination: bar
  producer:
    headerMode: raw
spring.cloud.stream.bindings.output3:
  destination: fox
  producer:
    headerMode: raw
spring.cloud.stream.bindings.input:
  destination: words
  consumer:
    headerMode: raw</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_message_conversion" href="#_message_conversion"></a> 40.6消息转换</h2></div></div></div><p>类似于基于消息通道的活页夹应用程序一样，Kafka Streams活页夹可适应现成的内容类型转换，而不会做出任何妥协。</p><p>对于Kafka Streams操作而言，通常要知道用于正确转换键和值的SerDe类型。因此，在入站和出站转换时依靠Apache Kafka Streams库本身提供的SerDe工具可能比使用框架提供的内容类型转换更为自然。另一方面，您可能已经熟悉框架提供的内容类型转换模式，并且您希望继续用于入站和出站转换。</p><p>Kafka Streams联编程序实现支持这两个选项。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_outbound_serialization" href="#_outbound_serialization"></a> 40.6.1出站序列化</h3></div></div></div><p>如果禁用本机编码（这是默认设置），则框架将使用用户设置的contentType转换消息（否则，默认<code class="literal">application/json</code>将被应用）。在这种情况下，它将忽略出站上设置的任何SerDe，以进行出站序列化。</p><p>这是在出站上设置contentType的属性。</p><pre class="screen">spring.cloud.stream.bindings.output.contentType: application/json</pre><p>这是启用本地编码的属性。</p><pre class="screen">spring.cloud.stream.bindings.output.nativeEncoding: true</pre><p>如果在输出绑定上启用了本地编码（用户必须如上所述明确地启用它），则框架将在出站上跳过任何形式的自动消息转换。在这种情况下，它将切换到用户设置的Serde。的<code class="literal">valueSerde</code>将使用在实际输出绑定上设置的属性。这是一个例子。</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.output.producer.valueSerde: org.apache.kafka.common.serialization.Serdes$StringSerde</pre><p>如果未设置此属性，则它将使用“默认” SerDe： <code class="literal">spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde</code> 。</p><p>值得一提的是，Kafka Streams活页夹不会在出站上序列化密钥-它仅依赖于Kafka本身。因此，您必须指定<code class="literal">keySerde</code>绑定上的属性，否则它将默认为应用程序范围的通用<code class="literal">keySerde</code> 。</p><p>绑定级别键序列号：</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.output.producer.keySerde</pre><p>公用密钥序列：</p><pre class="screen">spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde</pre><p>如果使用分支，则需要使用多个输出绑定。例如，</p><pre class="screen">interface KStreamProcessorWithBranches {

    		@Input("input")
    		KStream&lt;?, ?&gt; input();

    		@Output("output1")
    		KStream&lt;?, ?&gt; output1();

    		@Output("output2")
    		KStream&lt;?, ?&gt; output2();

    		@Output("output3")
    		KStream&lt;?, ?&gt; output3();
    	}</pre><p>如果<code class="literal">nativeEncoding</code>设置，然后您可以在各个输出绑定上设置不同的SerDe，如下所示。</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.output1.producer.valueSerde=IntegerSerde
spring.cloud.stream.kafka.streams.bindings.output2.producer.valueSerde=StringSerde
spring.cloud.stream.kafka.streams.bindings.output3.producer.valueSerde=JsonSerde</pre><p>那如果你有<code class="literal">SendTo</code>像这样@SendTo（{“ output1”，“ output2”，“ output3”}）， <code class="literal">KStream[]</code>分支中的对象将应用上面定义的适当的SerDe对象。如果您不启用<code class="literal">nativeEncoding</code> ，则可以如下在输出绑定上设置不同的contentType值。在这种情况下，框架将使用适当的消息转换器来转换消息，然后再发送给Kafka。</p><pre class="screen">spring.cloud.stream.bindings.output1.contentType: application/json
spring.cloud.stream.bindings.output2.contentType: application/java-serialzied-object
spring.cloud.stream.bindings.output3.contentType: application/octet-stream</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_deserialization" href="#_inbound_deserialization"></a> 40.6.2入站反序列化</h3></div></div></div><p>类似的规则适用于入站数据反序列化。</p><p>如果禁用本机解码（默认设置），则框架将使用用户设置的contentType转换消息（否则，默认设置为<code class="literal">application/json</code>将被应用）。在这种情况下，它将针对入站反序列化而忽略入站上设置的任何SerDe。</p><p>这是在入站上设置contentType的属性。</p><pre class="screen">spring.cloud.stream.bindings.input.contentType: application/json</pre><p>这是启用本机解码的属性。</p><pre class="screen">spring.cloud.stream.bindings.input.nativeDecoding: true</pre><p>如果在输入绑定上启用了本机解码（用户必须如上所述明确启用它），则框架将跳过对入站进行的任何消息转换。在这种情况下，它将切换到用户设置的SerDe。的<code class="literal">valueSerde</code>将使用在实际输出绑定上设置的属性。这是一个例子。</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.input.consumer.valueSerde: org.apache.kafka.common.serialization.Serdes$StringSerde</pre><p>如果未设置此属性，它将使用默认的SerDe： <code class="literal">spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde</code> 。</p><p>值得一提的是，Kafka Streams绑定程序不会反序列化入站密钥-它仅依赖于Kafka本身。因此，您必须指定<code class="literal">keySerde</code>绑定上的属性，否则它将默认为应用程序范围的通用<code class="literal">keySerde</code> 。</p><p>绑定级别键序列号：</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.input.consumer.keySerde</pre><p>公用密钥序列：</p><pre class="screen">spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde</pre><p>与在出站上进行KStream分支的情况一样，为每个绑定设置值SerDe的好处是，如果您有多个输入绑定（多个KStreams对象），并且它们都需要单独的值SerDe，则可以分别配置它们。如果使用通用配置方法，则此功能将不适用。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_error_handling" href="#_error_handling"></a> 40.7错误处理</h2></div></div></div><p>Apache Kafka Streams提供了本机处理反序列化错误引起的异常的功能。有关该支持的详细信息，请参阅<a class="link" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-161%3A+streams+deserialization+exception+handlers" target="_top">本</a>开箱，Apache的卡夫卡流提供2种反序列化异常处理的- <code class="literal">logAndContinue</code>和<code class="literal">logAndFail</code> 。顾名思义，前者将记录错误并继续处理下一条记录，而后者将记录错误并失败。 <code class="literal">LogAndFail</code>是默认的反序列化异常处理程序。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_handling_deserialization_exceptions" href="#_handling_deserialization_exceptions"></a> 40.7.1处理反序列化异常</h3></div></div></div><p>Kafka Streams活页夹通过以下属性支持选择异常处理程序。</p><pre class="screen">spring.cloud.stream.kafka.streams.binder.serdeError: logAndContinue</pre><p>除了以上两个反序列化异常处理程序外，绑定程序还提供了第三个用于将错误记录（毒丸）发送到DLQ主题的代理。这是启用此DLQ异常处理程序的方法。</p><pre class="screen">spring.cloud.stream.kafka.streams.binder.serdeError: sendToDlq</pre><p>设置上述属性后，所有反序列化错误记录都会自动发送到DLQ主题。</p><pre class="screen">spring.cloud.stream.kafka.streams.bindings.input.consumer.dlqName: foo-dlq</pre><p>如果已设置，则错误记录将发送到主题<code class="literal">foo-dlq</code> 。如果未设置，它将创建一个名称为DLQ的主题<code class="literal">error.<input-topic-name>.<group-name></code> 。</p><p>在Kafka Streams活页夹中使用异常处理功能时，需要记住两件事。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">物业<code class="literal">spring.cloud.stream.kafka.streams.binder.serdeError</code>适用于整个应用程序。这意味着如果有多个<code class="literal">StreamListener</code>在同一应用程序中的方法，此属性将应用于所有方法。</li><li class="listitem">反序列化的异常处理与本机反序列化和框架提供的消息转换一致。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_handling_non_deserialization_exceptions" href="#_handling_non_deserialization_exceptions"></a> 40.7.2处理非反序列化异常</h3></div></div></div><p>对于Kafka Streams联编程序中的常规错误处理，最终用户应用程序可以处理应用程序级错误。作为为反序列化异常处理程序提供DLQ的副作用，Kafka Streams绑定程序提供了一种直接从您的应用程序访问DLQ发送bean的方法。一旦访问了该bean，就可以以编程方式将任何异常记录从应用程序发送到DLQ。</p><p>使用高级DSL仍然难以进行强大的错误处理。 Kafka Streams本身还不支持错误处理。</p><p>但是，当您在应用程序中使用低级处理器API时，有一些选项可以控制此行为。见下文。</p><pre class="screen">@Autowired
private SendToDlqAndContinue dlqHandler;

@StreamListener("input")
@SendTo("output")
public KStream&lt;?, WordCount&gt; process(KStream&lt;Object, String&gt; input) {

    input.process(() -&gt; new Processor() {
    			ProcessorContext context;

    			@Override
    			public void init(ProcessorContext context) {
    				this.context = context;
    			}

    			@Override
    			public void process(Object o, Object o2) {

    			    try {
    			        .....
    			        .....
    			    }
    			    catch(Exception e) {
    			        //explicitly provide the kafka topic corresponding to the input binding as the first argument.
                        //DLQ handler will correctly map to the dlq topic from the actual incoming destination.
                        dlqHandler.sendToDlq("topic-name", (byte[]) o1, (byte[]) o2, context.partition());
    			    }
    			}

    			.....
    			.....
    });
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_state_store" href="#_state_store"></a> 40.8国立商店</h2></div></div></div><p>使用DSL时，Kafka Streams会自动创建状态存储。使用处理器API时，您需要手动注册状态存储。为此，您可以使用<code class="literal">KafkaStreamsStateStore</code>注解。您可以指定存储的名称和类型，用于控制日志和禁用高速缓存的标志等。一旦在引导阶段由绑定程序创建了存储，就可以通过处理器API访问此状态存储。以下是一些执行此操作的原语。</p><p>创建状态存储：</p><pre class="screen">@KafkaStreamsStateStore(name="mystate", type= KafkaStreamsStateStoreProperties.StoreType.WINDOW, lengthMs=300000)
public void process(KStream&lt;Object, Product&gt; input) {
    ...
}</pre><p>访问状态存储：</p><pre class="screen">Processor&lt;Object, Product&gt;() {

    WindowStore&lt;Object, String&gt; state;

    @Override
    public void init(ProcessorContext processorContext) {
        state = (WindowStore)processorContext.getStateStore("mystate");
    }
    ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_interactive_queries" href="#_interactive_queries"></a> 40.9交互式查询</h2></div></div></div><p>作为公开的Kafka Streams绑定程序API的一部分，我们公开了一个名为<code class="literal">InteractiveQueryService</code> 。您可以在应用程序中将其作为Spring bean访问。从您的应用程序访问该bean的一种简单方法是“自动装配”该bean。</p><pre class="screen">@Autowired
private InteractiveQueryService interactiveQueryService;</pre><p>一旦获得了对该bean的访问权限，就可以查询您感兴趣的特定状态存储。见下文。</p><pre class="screen">ReadOnlyKeyValueStore&lt;Object, Object&gt; keyValueStore =
						interactiveQueryService.getQueryableStoreType("my-store", QueryableStoreTypes.keyValueStore());</pre><p>如果有多个Kafka Streams应用程序实例正在运行，则在以交互方式查询它们之前，您需要确定哪个应用程序实例承载密钥。
<code class="literal">InteractiveQueryService</code> API提供了识别主机信息的方法。</p><p>为了使其正常工作，您必须配置属性<code class="literal">application.server</code>如下：</p><pre class="screen">spring.cloud.stream.kafka.streams.binder.configuration.application.server: &lt;server&gt;:&lt;port&gt;</pre><p>以下是一些代码段：</p><pre class="screen">org.apache.kafka.streams.state.HostInfo hostInfo = interactiveQueryService.getHostInfo("store-name",
						key, keySerializer);

if (interactiveQueryService.getCurrentHostInfo().equals(hostInfo)) {

    //query from the store that is locally available
}
else {
    //query from the remote host
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_accessing_the_underlying_kafkastreams_object" href="#_accessing_the_underlying_kafkastreams_object"></a> 40.10访问基础的KafkaStreams对象</h2></div></div></div><p><code class="literal">StreamBuilderFactoryBean</code>来自spring-kafka，负责构建<code class="literal">KafkaStreams</code>可以通过编程方式访问对象。每<code class="literal">StreamBuilderFactoryBean</code>注册为<code class="literal">stream-builder</code>并附加<code class="literal">StreamListener</code>方法名称。如果你的<code class="literal">StreamListener</code>方法命名为<code class="literal">process</code>例如，流构建器bean的名称为<code class="literal">stream-builder-process</code> 。由于这是工厂bean，因此应在前面加上一个＆符号（ <code class="literal">&</code> ）以编程方式访问它。以下是一个示例，并假设<code class="literal">StreamListener</code>方法命名为<code class="literal">process</code></p><pre class="screen">StreamsBuilderFactoryBean streamsBuilderFactoryBean = context.getBean("&amp;stream-builder-process", StreamsBuilderFactoryBean.class);
			KafkaStreams kafkaStreams = streamsBuilderFactoryBean.getKafkaStreams();</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_state_cleanup" href="#_state_cleanup"></a> 40.11状态清理</h2></div></div></div><p>默认情况下， <code class="literal">Kafkastreams.cleanup()</code>绑定停止时调用方法。请参阅<a class="link" href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#_configuration" target="_top">Spring Kafka文档</a> 。要修改此行为，只需添加一个<code class="literal">CleanupConfig</code><code class="literal">@Bean</code> （配置为在启动，停止或不启动时清除）到应用程序上下文；该bean将被检测到并连接到工厂bean中。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_rabbitmq_binder" href="#_rabbitmq_binder"></a> 41。RabbitMQ活页夹</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_usage_3" href="#_usage_3"></a> 41.1使用</h2></div></div></div><p>要使用RabbitMQ绑定器，可以通过使用以下Maven坐标将其添加到Spring Cloud Stream应用程序中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-binder-rabbit<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>另外，您可以使用Spring Cloud Stream RabbitMQ Starter，如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-stream-rabbit<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rabbitmq_binder_overview" href="#_rabbitmq_binder_overview"></a> 41.2 RabbitMQ活页夹概述</h2></div></div></div><p>以下简化图显示了RabbitMQ绑定程序的工作方式：</p><div class="figure"><a name="d0e13958" href="#d0e13958"></a><p class="title"><b>图41.1。RabbitMQ活页夹</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/rabbit-binder.png" alt="兔子粘合剂"></div></div></div><br class="figure-break"><p>默认情况下，RabbitMQ Binder实现将每个目标映射到一个<code class="literal">TopicExchange</code> 。对于每个消费群体， <code class="literal">Queue</code>必然会<code class="literal">TopicExchange</code> 。每个使用者实例都有一个对应的RabbitMQ <code class="literal">Consumer</code>其组的实例<code class="literal">Queue</code> 。对于分区的生产者和使用者，队列带有分区索引后缀，并将分区索引用作路由键。对于匿名消费者（没有<code class="literal">group</code>属性），则使用自动删除队列（具有随机的唯一名称）。</p><p>通过使用可选<code class="literal">autoBindDlq</code>选项，您可以配置活页夹以创建和配置死信队列（DLQ）（以及死信交换<code class="literal">DLX</code> ，以及路由基础结构）。默认情况下，死信队列具有目标名称，后跟<code class="literal">.dlq</code> 。如果启用了重试（ <code class="literal">maxAttempts > 1</code> ），则在重试用尽后，失败的消息将传递到DLQ。如果重试被禁用（ <code class="literal">maxAttempts = 1</code> ），您应该设置<code class="literal">requeueRejected</code>至<code class="literal">false</code> （默认设置），以便将失败的消息路由到DLQ，而不是重新排队。此外， <code class="literal">republishToDlq</code>使绑定程序将失败的消息发布到DLQ（而不是拒绝它）。此功能可让其他信息（例如<code class="literal">x-exception-stacktrace</code>标头）添加到标头中的邮件中。此选项不需要启用重试。只需尝试一次，您就可以重新发布失败的消息。从1.2版开始，您可以配置重新发布邮件的传递模式。见<a class="link" href="#spring-cloud-stream-rabbit-republish-delivery-mode"><code class="literal">republishDeliveryMode</code>财产</a> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>设置<code class="literal">requeueRejected</code>至<code class="literal">true</code> （与<code class="literal">republishToDlq=false</code> ）导致消息被重新排队并连续重新发送，除非失败的原因是短暂的，否则这可能不是您想要的。通常，您应该通过设置<code class="literal">maxAttempts</code>大于一或通过设置<code class="literal">republishToDlq</code>至<code class="literal">true</code> 。</p></td></tr></tbody></table></div><p>有关这些属性的更多信息<a class="xref" href="#rabbit-binder-properties" title="41.3.1 RabbitMQ Binder Properties">，</a>请参见<a class="xref" href="#rabbit-binder-properties" title="41.3.1 RabbitMQ活页夹属性">第41.3.1节“ RabbitMQ活页夹属性”</a> 。</p><p>该框架没有提供任何标准机制来使用死信消息（或将其重新路由回主队列）。<a class="xref" href="#rabbit-dlq-processing" title="41.6死信队列处理">第41.6节“死信队列处理”</a>中介绍了一些选项。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>当在Spring Cloud Stream应用程序中使用多个RabbitMQ绑定器时，重要的是禁用“ RabbitAutoConfiguration”，以避免来自<code class="literal">RabbitAutoConfiguration</code>应用于两种粘合剂。您可以使用<code class="literal">@SpringBootApplication</code>注解。</p></td></tr></tbody></table></div><p>从2.0版开始， <code class="literal">RabbitMessageChannelBinder</code>设置<code class="literal">RabbitTemplate.userPublisherConnection</code>财产<code class="literal">true</code>这样，非事务生产方就可以避免对使用者造成死锁，如果由于代理上的<a class="link" href="https://www.rabbitmq.com/memory.html" target="_top">内存警报</a>而阻止了缓存的连接，则可能会发生死锁。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>目前， <code class="literal">multiplex</code>消费者（单个消费者正在收听多个队列）仅受消息驱动的消费者支持；被轮询的使用者只能从单个队列中检索消息。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_options_4" href="#_configuration_options_4"></a> 41.3配置选项</h2></div></div></div><p>本节包含特定于RabbitMQ活页夹和绑定通道的设置。</p><p>有关常规绑定配置选项和属性，请参阅<a class="link" href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-core-docs/src/main/asciidoc/spring-cloud-stream-overview.adoc#configuration-options" target="_top">Spring Cloud Stream核心文档</a> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rabbit-binder-properties" href="#rabbit-binder-properties"></a> 41.3.1 RabbitMQ活页夹属性</h3></div></div></div><p>默认情况下，RabbitMQ绑定程序使用Spring Boot的<code class="literal">ConnectionFactory</code> 。一致地，它支持RabbitMQ的所有Spring Boot配置选项。 （有关参考，请参阅<a class="link" href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties" target="_top">Spring Boot文档</a> ）。RabbitMQ配置选项使用<code class="literal">spring.rabbitmq</code>字首。</p><p>除了Spring Boot选项之外，RabbitMQ绑定器还支持以下属性：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">spring.cloud.stream.rabbit.binder.adminAddresses</span></dt><dd><p class="simpara">以逗号分隔的RabbitMQ管理插件URL列表。仅在以下情况下使用<code class="literal">nodes</code>包含多个条目。此列表中的每个条目都必须在<code class="literal">spring.rabbitmq.addresses</code> 。仅当您使用RabbitMQ集群并希望从托管队列的节点使用时才需要。有关更多信息，请参见<a class="link" href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#queue-affinity" target="_top">队列亲和力和LocalizedQueueConnectionFactory</a> 。</p><p class="simpara">默认值：空。</p></dd><dt><span class="term">spring.cloud.stream.rabbit.binder.nodes</span></dt><dd><p class="simpara">以逗号分隔的RabbitMQ节点名称列表。多个条目时，用于定位队列所在的服务器地址。此列表中的每个条目都必须在<code class="literal">spring.rabbitmq.addresses</code> 。仅当您使用RabbitMQ集群并希望从托管队列的节点使用时才需要。有关更多信息，请参见<a class="link" href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#queue-affinity" target="_top">队列亲和力和LocalizedQueueConnectionFactory</a> 。</p><p class="simpara">默认值：空。</p></dd><dt><span class="term">spring.cloud.stream.rabbit.binder.compressionLevel</span></dt><dd><p class="simpara">压缩绑定的压缩级别。看到<code class="literal">java.util.zip.Deflater</code> 。</p><p class="simpara">默认： <code class="literal">1</code> （BEST_LEVEL）。</p></dd><dt><span class="term">spring.cloud.stream.binder.connection-name-prefix</span></dt><dd><p class="simpara">连接名称前缀，用于命名此绑定程序创建的连接。名称是此前缀，后跟<code class="literal">#n</code> ，在哪里<code class="literal">n</code>每次打开新连接时递增。</p><p class="simpara">默认值：无（Spring AMQP默认值）。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rabbitmq_consumer_properties" href="#_rabbitmq_consumer_properties"></a> 41.3.2 RabbitMQ消费者属性</h3></div></div></div><p>以下属性仅适用于Rabbit消费者，并且必须加上前缀<code class="literal">spring.cloud.stream.rabbit.bindings.<channelName>.consumer.</code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">确认模式</span></dt><dd><p class="simpara">确认模式。</p><p class="simpara">默认： <code class="literal">AUTO</code> 。</p></dd><dt><span class="term">autoBindDlq</span></dt><dd><p class="simpara">是否自动声明DLQ并将其绑定到绑定器DLX。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">bindingRoutingKey</span></dt><dd><p class="simpara">用于将队列绑定到交换的路由密钥（如果<code class="literal">bindQueue</code>是<code class="literal">true</code> ）。对于分区的目的地， <code class="literal">-<instanceIndex></code>附加。</p><p class="simpara">默认： <code class="literal">#</code> 。</p></dd><dt><span class="term">bindQueue</span></dt><dd><p class="simpara">是否将队列绑定到目标交换机。设置为<code class="literal">false</code>如果您已经建立了自己的基础架构，并且先前已经创建并绑定了队列。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">ConsumerTagPrefix</span></dt><dd><p class="simpara">用于创建消费者标签；将被附加<code class="literal">#n</code>哪里<code class="literal">n</code>创建的每个消费者的增量。例： <code class="literal">${spring.application.name}-${spring.cloud.stream.bindings.input.group}-${spring.cloud.stream.instance-index}</code> 。</p><p class="simpara">默认值：无-经纪人将生成随机的消费者标签。</p></dd><dt><span class="term">deadLetterQueueName</span></dt><dd><p class="simpara">DLQ的名称</p><p class="simpara">默认：<code class="literal">prefix+destination.dlq</code></p></dd><dt><span class="term">deadLetterExchange</span></dt><dd><p class="simpara">分配给队列的DLX。仅在以下情况下相关<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。</p><p class="simpara">默认值：“ prefix + DLX”</p></dd><dt><span class="term">deadLetterExchangeType</span></dt><dd><p class="simpara">分配给队列的DLX的类型。仅在以下情况下相关<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。</p><p class="simpara">默认值：“直接”</p></dd><dt><span class="term">deadLetterRoutingKey</span></dt><dd><p class="simpara">分配给队列的死信路由键。仅在以下情况下相关<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。</p><p class="simpara">默认：<code class="literal">destination</code></p></dd><dt><span class="term">声明Dlx</span></dt><dd><p class="simpara">是否声明目的地交换死信。仅在以下情况下相关<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。调成<code class="literal">false</code>如果您有预配置的DLX。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">声明交换</span></dt><dd><p class="simpara">是否声明目的地交换。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">延迟交易</span></dt><dd><p class="simpara">是否将交易所声明为<code class="literal">Delayed Message Exchange</code> 。在代理上需要延迟的消息交换插件。的<code class="literal">x-delayed-type</code>参数设置为<code class="literal">exchangeType</code> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">dlqDeadLetterExchange</span></dt><dd><p class="simpara">如果声明了DLQ，则分配给该队列的DLX。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqDeadLetterRoutingKey</span></dt><dd><p class="simpara">如果声明了DLQ，则分配给该队列的死信路由密钥。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqExpires</span></dt><dd><p class="simpara">删除未使用的死信队列的时间（以毫秒为单位）。</p><p class="simpara">默认：<code class="literal">no expiration</code></p></dd><dt><span class="term">dlqLazy</span></dt><dd><p class="simpara">用声明死信队列<code class="literal">x-queue-mode=lazy</code>论点。请参阅<a class="link" href="https://www.rabbitmq.com/lazy-queues.html" target="_top"><span class="quote">“ <span class="quote">惰性队列</span> ”</span></a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">dlqMaxLength</span></dt><dd><p class="simpara">死信队列中的最大消息数。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">dlqMaxLengthBytes</span></dt><dd><p class="simpara">所有消息中的死信队列中的最大总字节数。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">dlqMaxPriority</span></dt><dd><p class="simpara">死信队列中消息的最大优先级（0-255）。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqOverflow行为</span></dt><dd><p class="simpara">何时采取行动<code class="literal">dlqMaxLength</code>要么<code class="literal">dlqMaxLengthBytes</code>被超过;目前<code class="literal">drop-head</code>要么<code class="literal">reject-publish</code>但请参阅RabbitMQ文档。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqTtl</span></dt><dd><p class="simpara">声明时应用于死信队列的默认生存时间（以毫秒为单位）。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">持久订阅</span></dt><dd><p class="simpara">订阅是否应持久。仅在以下情况下有效<code class="literal">group</code>也设置。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">exchangeAutoDelete</span></dt><dd><p class="simpara">如果<code class="literal">declareExchange</code>是否为真，即是否应自动删除交换（即在删除最后一个队列之后将其删除）。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">耐用</span></dt><dd><p class="simpara">如果<code class="literal">declareExchange</code>确实如此，交换是否应该持久（即，在代理重新启动后仍然存在）。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">exchangeType</span></dt><dd><p class="simpara">交换类型： <code class="literal">direct</code> ， <code class="literal">fanout</code>要么<code class="literal">topic</code>适用于非分区目的地<code class="literal">direct</code>要么<code class="literal">topic</code>用于分区的目的地。</p><p class="simpara">默认： <code class="literal">topic</code> 。</p></dd><dt><span class="term">独家</span></dt><dd><p class="simpara">是否创建独家消费者。并发应为1 <code class="literal">true</code> 。通常在需要严格订购但使热备用实例在发生故障后接管时使用。看到<code class="literal">recoveryInterval</code> ，它控制备用实例尝试使用的频率。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">过期</span></dt><dd><p class="simpara">删除未使用的队列的时间（以毫秒为单位）。</p><p class="simpara">默认：<code class="literal">no expiration</code></p></dd><dt><span class="term">failedDeclarationRetryInterval</span></dt><dd><p class="simpara">丢失队列时尝试消耗队列之间的时间间隔（以毫秒为单位）。</p><p class="simpara">默认值：5000</p></dd><dt><span class="term">headerPatterns</span></dt><dd><p class="simpara">从入站邮件映射标头的模式。</p><p class="simpara">默认： <code class="literal">['*']</code> （所有标头）。</p></dd><dt><span class="term">懒</span></dt><dd><p class="simpara">用声明队列<code class="literal">x-queue-mode=lazy</code>论点。请参阅<a class="link" href="https://www.rabbitmq.com/lazy-queues.html" target="_top"><span class="quote">“ <span class="quote">惰性队列</span> ”</span></a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">maxConcurrency</span></dt><dd><p class="simpara">最大消费者数。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">最长长度</span></dt><dd><p class="simpara">队列中的最大消息数。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">maxLengthBytes</span></dt><dd><p class="simpara">来自所有消息的队列中的最大总字节数。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">maxPriority</span></dt><dd><p class="simpara">队列中消息的最大优先级（0-255）。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">missingQueuesFatal</span></dt><dd><p class="simpara">当找不到队列时，是否将条件视为致命并停止侦听器容器。默认为<code class="literal">false</code>这样容器就可以继续尝试从队列中使用数据，例如，在使用群集且承载非HA队列的节点关闭时。</p><p class="simpara">默认：<code class="literal">false</code></p></dd><dt><span class="term">溢出行为</span></dt><dd><p class="simpara">何时采取行动<code class="literal">maxLength</code>要么<code class="literal">maxLengthBytes</code>被超过;目前<code class="literal">drop-head</code>要么<code class="literal">reject-publish</code>但请参阅RabbitMQ文档。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">预取</span></dt><dd><p class="simpara">预取计数。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd><dt><span class="term">字首</span></dt><dd><p class="simpara">要添加到名称的前缀<code class="literal">destination</code>和队列。</p><p class="simpara">默认值：“”。</p></dd><dt><span class="term">queueDeclarationRetries</span></dt><dd><p class="simpara">缺少队列时重试消耗的次数。仅当<code class="literal">missingQueuesFatal</code>是<code class="literal">true</code> 。否则，容器将无限期地重试。</p><p class="simpara">默认：<code class="literal">3</code></p></dd><dt><span class="term">queueNameGroupOnly</span></dt><dd><p class="simpara">如果为true，请从名称等于<code class="literal">group</code> 。否则，队列名称为<code class="literal">destination.group</code> 。例如，在使用Spring Cloud Stream从现有RabbitMQ队列中使用时，这很有用。</p><p class="simpara">默认值：false。</p></dd><dt><span class="term">recoveryInterval</span></dt><dd><p class="simpara">连接恢复尝试之间的时间间隔（以毫秒为单位）。</p><p class="simpara">默认： <code class="literal">5000</code> 。</p></dd><dt><span class="term">重新排队</span></dt><dd><p class="simpara">禁用重试时，是否应重新排定传送失败的队列，或者<code class="literal">republishToDlq</code>是<code class="literal">false</code> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd></dl></div><div class="variablelist"><a name="spring-cloud-stream-rabbit-republish-delivery-mode" href="#spring-cloud-stream-rabbit-republish-delivery-mode"></a><dl class="variablelist"><dt><span class="term">republishDeliveryMode</span></dt><dd><p class="simpara">什么时候<code class="literal">republishToDlq</code>是<code class="literal">true</code> ，指定重新发布的邮件的传递方式。</p><p class="simpara">默认：<code class="literal">DeliveryMode.PERSISTENT</code></p></dd><dt><span class="term">republishToDlq</span></dt><dd><p class="simpara">默认情况下，拒绝重试后失败的消息将被拒绝。如果配置了死信队列（DLQ），RabbitMQ会将失败的消息（未更改）路由到DLQ。如果设置为<code class="literal">true</code> ，活页夹将带有其他标头的失败消息重新发布到DLQ，包括异常消息和来自最终失败原因的堆栈跟踪。</p><p class="simpara">默认值：false</p></dd><dt><span class="term">交易的</span></dt><dd><p class="simpara">是否使用交易渠道。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">ttl</span></dt><dd><p class="simpara">声明时应用于队列的默认生存时间（以毫秒为单位）。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">txSize</span></dt><dd><p class="simpara">两次之间的分娩次数。</p><p class="simpara">默认： <code class="literal">1</code> 。</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_advanced_listener_container_configuration" href="#_advanced_listener_container_configuration"></a> 41.3.3高级侦听器容器配置</h3></div></div></div><p>要设置未作为绑定程序或绑定属性公开的侦听器容器属性，请添加一个类型为的bean <code class="literal">ListenerContainerCustomizer</code>到应用程序上下文。将设置活页夹和绑定属性，然后将调用定制程序。定制器（ <code class="literal">configure()</code>方法）提供了队列名称以及使用者组作为参数。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rabbit_producer_properties" href="#_rabbit_producer_properties"></a> 41.3.4兔生产者属性</h3></div></div></div><p>以下属性仅适用于Rabbit生产者，并且必须加上前缀<code class="literal">spring.cloud.stream.rabbit.bindings.<channelName>.producer.</code> 。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">autoBindDlq</span></dt><dd><p class="simpara">是否自动声明DLQ并将其绑定到绑定器DLX。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">batchingEnabled</span></dt><dd><p class="simpara">是否启用生产者的邮件批处理。根据以下属性（在此列表的下三个条目中进行了描述），将消息批量处理为一条消息：'batchSize'， <code class="literal">batchBufferLimit</code>和<code class="literal">batchTimeout</code> 。有关更多信息，请参见<a class="link" href="https://docs.spring.io/spring-amqp//reference/html/_reference.html#template-batching" target="_top">批处理</a> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">batchSize</span></dt><dd><p class="simpara">启用批处理时要缓冲的消息数。</p><p class="simpara">默认： <code class="literal">100</code> 。</p></dd><dt><span class="term">batchBufferLimit</span></dt><dd><p class="simpara">启用批处理时的最大缓冲区大小。</p><p class="simpara">默认： <code class="literal">10000</code> 。</p></dd><dt><span class="term">batchTimeout</span></dt><dd><p class="simpara">启用批处理时的批处理超时。</p><p class="simpara">默认： <code class="literal">5000</code> 。</p></dd><dt><span class="term">bindingRoutingKey</span></dt><dd><p class="simpara">用于将队列绑定到交换的路由密钥（如果<code class="literal">bindQueue</code>是<code class="literal">true</code> ）。仅适用于未分区的目的地。仅适用于<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认： <code class="literal">#</code> 。</p></dd><dt><span class="term">bindQueue</span></dt><dd><p class="simpara">是否将队列绑定到目标交换机。设置为<code class="literal">false</code>如果您已经建立了自己的基础架构，并且先前已经创建并绑定了队列。仅适用于<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">压缩</span></dt><dd><p class="simpara">发送时是否应压缩数据。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">deadLetterQueueName</span></dt><dd><p class="simpara">DLQ的名称仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">prefix+destination.dlq</code></p></dd><dt><span class="term">deadLetterExchange</span></dt><dd><p class="simpara">分配给队列的DLX。仅当<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认值：“ prefix + DLX”</p></dd><dt><span class="term">deadLetterExchangeType</span></dt><dd><p class="simpara">分配给队列的DLX的类型。仅在以下情况下相关<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认值：“直接”</p></dd><dt><span class="term">deadLetterRoutingKey</span></dt><dd><p class="simpara">分配给队列的死信路由键。仅当<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">destination</code></p></dd><dt><span class="term">声明Dlx</span></dt><dd><p class="simpara">是否声明目的地交换死信。仅在以下情况下相关<code class="literal">autoBindDlq</code>是<code class="literal">true</code> 。调成<code class="literal">false</code>如果您有预配置的DLX。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">声明交换</span></dt><dd><p class="simpara">是否声明目的地交换。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">delayExpression</span></dt><dd><p class="simpara">SpEL表达式，用于评估应用于消息的延迟（ <code class="literal">x-delay</code>标头）。如果交换不是延迟的消息交换，则无效。</p><p class="simpara">默认值：否<code class="literal">x-delay</code>标头已设置。</p></dd><dt><span class="term">延迟交易</span></dt><dd><p class="simpara">是否将交易所声明为<code class="literal">Delayed Message Exchange</code> 。在代理上需要延迟的消息交换插件。的<code class="literal">x-delayed-type</code>参数设置为<code class="literal">exchangeType</code> 。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">deliveryMode</span></dt><dd><p class="simpara">交付方式。</p><p class="simpara">默认： <code class="literal">PERSISTENT</code> 。</p></dd><dt><span class="term">dlqDeadLetterExchange</span></dt><dd><p class="simpara">声明DLQ后，将分配给该队列的DLX。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqDeadLetterRoutingKey</span></dt><dd><p class="simpara">声明DLQ后，分配给该队列的死信路由密钥。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqExpires</span></dt><dd><p class="simpara">删除未使用的死信队列之前的时间（以毫秒为单位）。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no expiration</code></p></dd><dt><span class="term">dlqLazy</span></dt><dd>用声明死信队列<code class="literal">x-queue-mode=lazy</code>论点。请参阅<a class="link" href="https://www.rabbitmq.com/lazy-queues.html" target="_top"><span class="quote">“ <span class="quote">惰性队列</span> ”</span></a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</dd><dt><span class="term">dlqMaxLength</span></dt><dd><p class="simpara">死信队列中的最大消息数。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">dlqMaxLengthBytes</span></dt><dd><p class="simpara">所有消息中的死信队列中的最大总字节数。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">dlqMaxPriority</span></dt><dd><p class="simpara">死信队列中邮件的最大优先级（0-255）仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">dlqTtl</span></dt><dd><p class="simpara">声明时应用于死信队列的默认生存时间（以毫秒为单位）。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">exchangeAutoDelete</span></dt><dd><p class="simpara">如果<code class="literal">declareExchange</code>是<code class="literal">true</code> ，是否应该自动删除交换（在删除最后一个队列后将其删除）。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">耐用</span></dt><dd><p class="simpara">如果<code class="literal">declareExchange</code>是<code class="literal">true</code> ，该交换是否应该持久（在代理重新启动后生存）。</p><p class="simpara">默认： <code class="literal">true</code> 。</p></dd><dt><span class="term">exchangeType</span></dt><dd><p class="simpara">交换类型： <code class="literal">direct</code> ， <code class="literal">fanout</code>要么<code class="literal">topic</code>适用于非分区目的地<code class="literal">direct</code>要么<code class="literal">topic</code>用于分区的目的地。</p><p class="simpara">默认： <code class="literal">topic</code> 。</p></dd><dt><span class="term">过期</span></dt><dd><p class="simpara">删除未使用的队列之前的时间（以毫秒为单位）。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no expiration</code></p></dd><dt><span class="term">headerPatterns</span></dt><dd><p class="simpara">标头要映射到出站邮件的模式。</p><p class="simpara">默认： <code class="literal">['*']</code> （所有标头）。</p></dd><dt><span class="term">懒</span></dt><dd><p class="simpara">用声明队列<code class="literal">x-queue-mode=lazy</code>论点。请参阅<a class="link" href="https://www.rabbitmq.com/lazy-queues.html" target="_top"><span class="quote">“ <span class="quote">惰性队列</span> ”</span></a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">最长长度</span></dt><dd><p class="simpara">队列中的最大消息数。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">maxLengthBytes</span></dt><dd><p class="simpara">来自所有消息的队列中的最大总字节数。仅适用于<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd><dt><span class="term">maxPriority</span></dt><dd><p class="simpara">队列中消息的最大优先级（0-255）。仅适用于<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">none</code></p></dd><dt><span class="term">字首</span></dt><dd><p class="simpara">要添加到名称的前缀<code class="literal">destination</code>交换。</p><p class="simpara">默认值：“”。</p></dd><dt><span class="term">queueNameGroupOnly</span></dt><dd><p class="simpara">什么时候<code class="literal">true</code> ，从名称等于<code class="literal">group</code> 。否则，队列名称为<code class="literal">destination.group</code> 。例如，在使用Spring Cloud Stream从现有RabbitMQ队列中使用时，这很有用。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认值：false。</p></dd><dt><span class="term">routingKeyExpression</span></dt><dd><p class="simpara">一个SpEL表达式，用于确定发布消息时要使用的路由密钥。对于固定的路由键，请使用文字表达式，例如<code class="literal">routingKeyExpression='my.routingKey'</code>在属性文件中或<code class="literal">routingKeyExpression: '''my.routingKey'''</code>在YAML文件中。</p><p class="simpara">默认： <code class="literal">destination</code>要么<code class="literal">destination-<partition></code>用于分区的目的地。</p></dd><dt><span class="term">交易的</span></dt><dd><p class="simpara">是否使用交易渠道。</p><p class="simpara">默认： <code class="literal">false</code> 。</p></dd><dt><span class="term">ttl</span></dt><dd><p class="simpara">声明时适用于队列的默认生存时间（以毫秒为单位）。仅在以下情况下适用<code class="literal">requiredGroups</code>提供，然后仅提供给这些组。</p><p class="simpara">默认：<code class="literal">no limit</code></p></dd></dl></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>对于RabbitMQ，可以由外部应用程序设置内容类型标头。Spring Cloud Stream支持它们作为扩展的内部协议的一部分，该协议用于任何类型的传输，包括Kafka（0.11之前的版本）之类的传输，其本身并不支持标头。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_retry_with_the_rabbitmq_binder" href="#_retry_with_the_rabbitmq_binder"></a> 41.4使用RabbitMQ粘合剂重试</h2></div></div></div><p>当在活页夹中启用重试时，侦听器容器线程将在配置的任何退避期间暂停。当需要单个消费者进行严格订购时，这可能很重要。但是，对于其他用例，它阻止在该线程上处理其他消息。使用活页夹重试的另一种方法是设置带有时间的无效字母，以保留在无效字母队列（DLQ）上，以及在DLQ本身上进行无效字母配置。有关此处讨论的属性的更多信息<span class="quote"><span class="quote"><a class="xref" href="#rabbit-binder-properties" title="41.3.1 RabbitMQ Binder Properties">，</a></span></span>请参见<span class="quote">“ <span class="quote"><a class="xref" href="#rabbit-binder-properties" title="41.3.1 RabbitMQ活页夹属性">第41.3.1节“ RabbitMQ粘合剂属性”</a></span> ”</span> 。您可以使用以下示例配置来启用此功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">组<code class="literal">autoBindDlq</code>至<code class="literal">true</code> 。活页夹创建一个DLQ。 （可选）您可以在中指定名称<code class="literal">deadLetterQueueName</code> 。</li><li class="listitem">组<code class="literal">dlqTtl</code>您想要在重新交付之间等待的退避时间。</li><li class="listitem">设置<code class="literal">dlqDeadLetterExchange</code>到默认交换。来自DLQ的过期消息被路由到原始队列，因为默认<code class="literal">deadLetterRoutingKey</code>是队列名称（ <code class="literal">destination.group</code> ）。设置为默认交换是通过将属性设置为无值来实现的，如下例所示。</li></ul></div><p>要强制对消息进行死信处理，请抛出一个<code class="literal">AmqpRejectAndDontRequeueException</code>或设置<code class="literal">requeueRejected</code>至<code class="literal">true</code> （默认）并抛出任何异常。</p><p>循环无休止地继续进行，这对于瞬态问题很好，但是您可能需要在尝试几次后放弃。幸运的是，RabbitMQ提供了<code class="literal">x-death</code>标头，可让您确定发生了多少个周期。</p><p>要在放弃后确认消息，请抛出<code class="literal">ImmediateAcknowledgeAmqpException</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_putting_it_all_together" href="#_putting_it_all_together"></a> 41.4.1整合在一起</h3></div></div></div><p>以下配置创建了一个交换<code class="literal">myDestination</code>有队列<code class="literal">myDestination.consumerGroup</code>用通配符路由键绑定到主题交换<code class="literal">#</code> ：</p><pre class="screen">---
spring.cloud.stream.bindings.input.destination=myDestination
spring.cloud.stream.bindings.input.group=consumerGroup
#disable binder retries
spring.cloud.stream.bindings.input.consumer.max-attempts=1
#dlx/dlq setup
spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-ttl=5000
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-dead-letter-exchange=
---</pre><p>此配置创建绑定到直接交换的DLQ（ <code class="literal">DLX</code> ）的路由键为<code class="literal">myDestination.consumerGroup</code> 。当邮件被拒绝时，它们将被路由到DLQ。 5秒后，该消息到期，并通过使用队列名称作为路由键将其路由到原始队列，如以下示例所示：</p><p><b>Spring Boot应用程序。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> XDeathApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        SpringApplication.run(XDeathApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
    }

    <em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> listen(String in, <em><span class="hl-annotation" style="color: gray">@Header(name = "x-death", required = false)</span></em> Map&lt;?,?&gt; death) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (death != null &amp;&amp; death.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"count"</span>).equals(<span class="hl-number">3L</span>)) {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// giving up - don't send to DLX</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throw</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ImmediateAcknowledgeAmqpException(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Failed after 4 attempts"</span>);
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throw</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AmqpRejectAndDontRequeueException(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"failed"</span>);
    }

}</pre><p>
</p><p>请注意， <code class="literal">x-death</code>标头是一个<code class="literal">Long</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="rabbit-error-channels" href="#rabbit-error-channels"></a> 41.5错误通道</h2></div></div></div><p>从版本1.3开始，绑定程序无条件地将异常发送到每个使用者目标的错误通道，也可以将其配置为将异步生产者发送失败消息发送到错误通道。参见<span class="quote">“ <span class="quote"><a class="xref" href="#">???</a></span> ”</span> 想要查询更多的信息。</p><p>RabbitMQ有两种类型的发送失败：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">返回的消息，</li><li class="listitem">负面认可的<a class="link" href="https://www.rabbitmq.com/confirms.html" target="_top">出版商确认</a> 。</li></ul></div><p>后者很少见。根据RabbitMQ文档，“ [仅在负责队列的Erlang进程中发生内部错误时，才会传递[nack]”。</p><p>除了启用生产者错误通道（如<span class="quote">“ <span class="quote"><a class="xref" href="#">???</a></span> ”中所述</span> ）之外，RabbitMQ绑定器仅在正确配置连接工厂的情况下，才将消息发送到通道，如下所示：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">ccf.setPublisherConfirms(true);</code></li><li class="listitem"><code class="literal">ccf.setPublisherReturns(true);</code></li></ul></div><p>将Spring Boot配置用于连接工厂时，请设置以下属性：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">spring.rabbitmq.publisher-confirms</code></li><li class="listitem"><code class="literal">spring.rabbitmq.publisher-returns</code></li></ul></div><p>的有效载荷<code class="literal">ErrorMessage</code>对于返回的消息是<code class="literal">ReturnedAmqpMessageException</code>具有以下属性：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">failedMessage</code> ：春季信息<code class="literal">Message<?></code>无法发送。</li><li class="listitem"><code class="literal">amqpMessage</code> ：原始的spring-amqp <code class="literal">Message</code> 。</li><li class="listitem"><code class="literal">replyCode</code> ：表示失败原因的整数值（例如312-无路由）。</li><li class="listitem"><code class="literal">replyText</code> ：指示失败原因的文本值（例如， <code class="literal">NO_ROUTE</code> ）。</li><li class="listitem"><code class="literal">exchange</code> ：发布消息的交易所。</li><li class="listitem"><code class="literal">routingKey</code> ：发布消息时使用的路由密钥。</li></ul></div><p>对于否定确认的确认，有效载荷为<code class="literal">NackedAmqpMessageException</code>具有以下属性：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">failedMessage</code> ：春季信息<code class="literal">Message<?></code>无法发送。</li><li class="listitem"><code class="literal">nackReason</code> ：原因（如果有的话，您可能需要检查代理日志以获取更多信息）。</li></ul></div><p>没有对这些异常的自动处理（例如发送到<a class="link" href="#rabbit-dlq-processing" title="41.6死信队列处理">死信队列</a> ）。您可以使用自己的Spring Integration流使用这些异常。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="rabbit-dlq-processing" href="#rabbit-dlq-processing"></a> 41.6死信队列处理</h2></div></div></div><p>因为您无法预期用户将如何处置死信，所以该框架没有提供任何标准机制来处理它们。如果死信的原因是暂时的，则您可能希望将消息路由回原始队列。但是，如果问题是永久性问题，则可能导致无限循环。下面的Spring Boot应用程序显示了一个示例，该示例演示如何将这些消息路由回原始队列，但在尝试三次后将其移至第三个<span class="quote">“ <span class="quote">停车场</span> ”</span>队列。第二个示例使用<a class="link" href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/" target="_top">RabbitMQ延迟消息交换</a>为重新排队的消息引入延迟。在此示例中，每次尝试的延迟都会增加。这些示例使用<code class="literal">@RabbitListener</code>接收来自DLQ的消息。您也可以使用<code class="literal">RabbitTemplate.receive()</code>分批处理。</p><p>这些示例假定原始目的地是<code class="literal">so8400in</code>而消费群是<code class="literal">so8400</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_non_partitioned_destinations" href="#_non_partitioned_destinations"></a> 41.6.1非分区目标</h3></div></div></div><p>前两个示例适用于目标<span class="strong"><strong>未</strong></span>分区的情况：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ReRouteDlqApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String ORIGINAL_QUEUE = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"so8400in.so8400"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String DLQ = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".dlq"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String PARKING_LOT = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".parkingLot"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_RETRIES_HEADER = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-retries"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
        System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hit enter to terminate"</span>);
        System.in.read();
        context.close();
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RabbitTemplate rabbitTemplate;

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = DLQ)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> rePublish(Message failedMessage) {
        Integer retriesHeader = (Integer) failedMessage.getMessageProperties().getHeaders().get(X_RETRIES_HEADER);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader == null) {
            retriesHeader = Integer.valueOf(<span class="hl-number">0</span>);
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader &lt; <span class="hl-number">3</span>) {
            failedMessage.getMessageProperties().getHeaders().put(X_RETRIES_HEADER, retriesHeader + <span class="hl-number">1</span>);
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(ORIGINAL_QUEUE, failedMessage);
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Queue parkingLot() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Queue(PARKING_LOT);
    }

}</pre><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ReRouteDlqApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String ORIGINAL_QUEUE = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"so8400in.so8400"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String DLQ = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".dlq"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String PARKING_LOT = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".parkingLot"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_RETRIES_HEADER = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-retries"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String DELAY_EXCHANGE = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"dlqReRouter"</span>;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
        System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hit enter to terminate"</span>);
        System.in.read();
        context.close();
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RabbitTemplate rabbitTemplate;

    <em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = DLQ)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> rePublish(Message failedMessage) {
        Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader == null) {
            retriesHeader = Integer.valueOf(<span class="hl-number">0</span>);
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader &lt; <span class="hl-number">3</span>) {
            headers.put(X_RETRIES_HEADER, retriesHeader + <span class="hl-number">1</span>);
            headers.put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-delay"</span>, <span class="hl-number">5000</span> * retriesHeader);
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(DELAY_EXCHANGE, ORIGINAL_QUEUE, failedMessage);
        }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> DirectExchange delayExchange() {
        DirectExchange exchange = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> DirectExchange(DELAY_EXCHANGE);
        exchange.setDelayed(true);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> exchange;
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Binding bindOriginalToDelay() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> BindingBuilder.bind(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Queue(ORIGINAL_QUEUE)).to(delayExchange()).with(ORIGINAL_QUEUE);
    }

    <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Queue parkingLot() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Queue(PARKING_LOT);
    }

}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_partitioned_destinations" href="#_partitioned_destinations"></a> 41.6.2分区目标</h3></div></div></div><p>对于分区目标，所有分区都有一个DLQ。我们根据标题确定原始队列。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_republishtodlqfalse" href="#_republishtodlqfalse"></a><code class="literal">republishToDlq=false</code></h4></div></div></div><p>什么时候<code class="literal">republishToDlq</code>是<code class="literal">false</code> ，RabbitMQ使用以下命令将消息发布到DLX / DLQ： <code class="literal">x-death</code>标头，其中包含有关原始目的地的信息，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ReRouteDlqApplication {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String ORIGINAL_QUEUE = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"so8400in.so8400"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String DLQ = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".dlq"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String PARKING_LOT = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".parkingLot"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_DEATH_HEADER = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-death"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_RETRIES_HEADER = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-retries"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
		System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hit enter to terminate"</span>);
		System.in.read();
		context.close();
	}

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RabbitTemplate rabbitTemplate;

	<em><span class="hl-annotation" style="color: gray">@SuppressWarnings("unchecked")</span></em>
	<em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = DLQ)</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader == null) {
			retriesHeader = Integer.valueOf(<span class="hl-number">0</span>);
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader &lt; <span class="hl-number">3</span>) {
			headers.put(X_RETRIES_HEADER, retriesHeader + <span class="hl-number">1</span>);
			List&lt;Map&lt;String, ?&gt;&gt; xDeath = (List&lt;Map&lt;String, ?&gt;&gt;) headers.get(X_DEATH_HEADER);
			String exchange = (String) xDeath.get(<span class="hl-number">0</span>).get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"exchange"</span>);
			List&lt;String&gt; routingKeys = (List&lt;String&gt;) xDeath.get(<span class="hl-number">0</span>).get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"routing-keys"</span>);
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(exchange, routingKeys.get(<span class="hl-number">0</span>), failedMessage);
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Queue parkingLot() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Queue(PARKING_LOT);
	}

}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_republishtodlqtrue" href="#_republishtodlqtrue"></a><code class="literal">republishToDlq=true</code></h4></div></div></div><p>什么时候<code class="literal">republishToDlq</code>是<code class="literal">true</code> ，重新发布的恢复程序会将原始交换和路由密钥添加到标头中，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ReRouteDlqApplication {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String ORIGINAL_QUEUE = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"so8400in.so8400"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String DLQ = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".dlq"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String PARKING_LOT = ORIGINAL_QUEUE + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".parkingLot"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_RETRIES_HEADER = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-retries"</span>;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_ORIGINAL_EXCHANGE_HEADER = RepublishMessageRecoverer.X_ORIGINAL_EXCHANGE;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String X_ORIGINAL_ROUTING_KEY_HEADER = RepublishMessageRecoverer.X_ORIGINAL_ROUTING_KEY;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
		System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hit enter to terminate"</span>);
		System.in.read();
		context.close();
	}

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RabbitTemplate rabbitTemplate;

	<em><span class="hl-annotation" style="color: gray">@RabbitListener(queues = DLQ)</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> rePublish(Message failedMessage) {
		Map&lt;String, Object&gt; headers = failedMessage.getMessageProperties().getHeaders();
		Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader == null) {
			retriesHeader = Integer.valueOf(<span class="hl-number">0</span>);
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (retriesHeader &lt; <span class="hl-number">3</span>) {
			headers.put(X_RETRIES_HEADER, retriesHeader + <span class="hl-number">1</span>);
			String exchange = (String) headers.get(X_ORIGINAL_EXCHANGE_HEADER);
			String originalRoutingKey = (String) headers.get(X_ORIGINAL_ROUTING_KEY_HEADER);
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(exchange, originalRoutingKey, failedMessage);
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.rabbitTemplate.send(PARKING_LOT, failedMessage);
		}
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Queue parkingLot() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Queue(PARKING_LOT);
	}

}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_partitioning_with_the_rabbitmq_binder" href="#_partitioning_with_the_rabbitmq_binder"></a> 41.7使用RabbitMQ活页夹进行分区</h2></div></div></div><p>RabbitMQ不支持本地分区。</p><p>有时，将数据发送到特定分区是有利的-例如，当您要严格订购消息处理时，特定客户的所有消息都应转到同一分区。</p><p>的<code class="literal">RabbitMessageChannelBinder</code>通过将每个分区的队列绑定到目标交换机来提供分区。</p><p>以下Java和YAML示例显示了如何配置生产者：</p><p><b>制片人。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Source.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> RabbitPartitionProducerApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Random RANDOM = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Random(System.currentTimeMillis());

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String[] data = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> String[] {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"abc1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"def1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux1"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"abc2"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"def2"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux2"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"abc3"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"def3"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux3"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"abc4"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"def4"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"qux4"</span>,
            };

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(RabbitPartitionProducerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Message&lt;?&gt; generate() {
        String value = data[RANDOM.nextInt(data.length)];
        System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Sending: "</span> + value);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> MessageBuilder.withPayload(value)
                .setHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"partitionKey"</span>, value)
                .build();
    }

}</pre><p>
</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        stream</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          bindings</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            output</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              destination</span>: partitioned.destination
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              producer</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                partitioned</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                partition-key-expression</span>: headers[<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'partitionKey'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                partition-count</span>: <span class="hl-number">2</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                required-groups</span>:
                - myGroup</pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>先前示例中的配置使用默认分区（ <code class="literal">key.hashCode() % partitionCount</code> ）。根据键值，这可能会或可能不会提供适当的平衡算法。您可以使用<code class="literal">partitionSelectorExpression</code>要么<code class="literal">partitionSelectorClass</code>属性。</p><p>的<code class="literal">required-groups</code>只有在部署生产方时需要供应方队列时才需要该属性。否则，发送到分区的所有消息都将丢失，直到部署了相应的使用者为止。</p></td></tr></tbody></table></div><p>以下配置提供了主题交换：</p><div class="informalfigure"><div class="mediaobject"><img src="images/part-exchange.png" alt="零件交换"></div></div><p>该交换绑定了以下队列：</p><div class="informalfigure"><div class="mediaobject"><img src="images/part-queues.png" alt="部分队列"></div></div><p>以下绑定将队列与交换关联：</p><div class="informalfigure"><div class="mediaobject"><img src="images/part-bindings.png" alt="零件绑定"></div></div><p>以下Java和YAML示例延续了前面的示例，并显示了如何配置使用者：</p><p><b>消费者。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableBinding(Sink.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> RabbitPartitionConsumerApplication {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(RabbitPartitionConsumerApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)
            .web(false)
            .run(args);
    }

    <em><span class="hl-annotation" style="color: gray">@StreamListener(Sink.INPUT)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> listen(<em><span class="hl-annotation" style="color: gray">@Payload</span></em> String in, <em><span class="hl-annotation" style="color: gray">@Header(AmqpHeaders.CONSUMER_QUEUE)</span></em> String queue) {
        System.out.println(in + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" received from queue "</span> + queue);
    }

}</pre><p>
</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        stream</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          bindings</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            input</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              destination</span>: partitioned.destination
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              group</span>: myGroup
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              consumer</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                partitioned</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                instance-index</span>: <span class="hl-number">0</span></pre><p>
</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">RabbitMessageChannelBinder</code>不支持动态缩放。每个分区至少必须有一个使用方。消费者的<code class="literal">instanceIndex</code>用于指示使用哪个分区。诸如Cloud Foundry之类的平台只能具有一个实例<code class="literal">instanceIndex</code> 。</p></td></tr></tbody></table></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_bus" href="#_spring_cloud_bus"></a>第七部分spring-cloud-bus</h1></div></div></div><div class="partintro"><div></div><p>Spring Cloud Bus将轻量级消息代理程序链接到分布式系统的节点。然后可以使用此代理来广播状态更改（例如配置更改）或其他管理指令。一个关键的想法是，总线就像是横向扩展的Spring Boot应用程序的分布式执行器。但是，它也可以用作应用之间的通信渠道。该项目为AMQP经纪人或Kafka提供了入门服务。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a class="link" href="https://github.com/spring-cloud/spring-cloud-config/tree/master/docs/src/main/asciidoc" target="_top">github</a>的项目中找到源代码和问题跟踪程序。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_quick_start_3" href="#_quick_start_3"></a> 42。快速开始</h2></div></div></div><p>如果Spring Cloud Bus在类路径中检测到自身，则通过添加Spring Boot autconfiguration来工作。要启用总线，请添加<code class="literal">spring-cloud-starter-bus-amqp</code>要么<code class="literal">spring-cloud-starter-bus-kafka</code>到您的依赖管理。Spring Cloud负责其余的工作。确保代理（RabbitMQ或Kafka）可用并且已配置。在本地主机上运行时，您无需执行任何操作。如果您是远程运行，请使用Spring Cloud Connectors或Spring Boot约定定义代理凭据，如Rabbit的以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  rabbitmq:
    host: mybroker.com
    port: 5672
    username: user
    password: secret</pre><p>
</p><p>总线当前支持向所有侦听节点或特定服务的所有节点发送消息（由Eureka定义）。的<code class="literal">/bus/*</code>执行器名称空间具有一些HTTP端点。当前，有两个已实现。首先， <code class="literal">/bus/env</code> ，发送键/值对以更新每个节点的Spring Environment。第二， <code class="literal">/bus/refresh</code> ，重新加载每个应用程序的配置，就好像它们都被ping通了<code class="literal">/refresh</code>端点。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Bus入门文章涵盖Rabbit和Kafka，因为它们是两个最常见的实现。但是，Spring Cloud Stream非常灵活，并且绑定程序可以与<code class="literal">spring-cloud-bus</code> 。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_bus_endpoints" href="#_bus_endpoints"></a> 43。总线端点</h2></div></div></div><p>Spring Cloud Bus提供了两个端点， <code class="literal">/actuator/bus-refresh</code>和<code class="literal">/actuator/bus-env</code>对应于Spring Cloud Commons中的各个执行器端点， <code class="literal">/actuator/refresh</code>和<code class="literal">/actuator/env</code>分别。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_bus_refresh_endpoint" href="#_bus_refresh_endpoint"></a> 43.1总线刷新端点</h2></div></div></div><p>的<code class="literal">/actuator/bus-refresh</code>端点清除<code class="literal">RefreshScope</code>缓存并重新绑定<code class="literal">@ConfigurationProperties</code> 。有关更多信息，请参见<a class="link" href="#refresh-scope" title="2.9刷新范围">刷新作用域</a>文档。</p><p>揭露<code class="literal">/actuator/bus-refresh</code>端点，您需要向应用程序添加以下配置：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">management.endpoints.web.exposure.include</span>=bus-refresh</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_bus_env_endpoint" href="#_bus_env_endpoint"></a> 43.2总线环境端点</h2></div></div></div><p>的<code class="literal">/actuator/bus-env</code>端点使用跨多个实例的指定键/值对更新每个实例环境。</p><p>揭露<code class="literal">/actuator/bus-env</code>端点，您需要向应用程序添加以下配置：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">management.endpoints.web.exposure.include</span>=bus-env</pre><p>的<code class="literal">/actuator/bus-env</code>端点接受<code class="literal">POST</code>具有以下形状的请求：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"key1"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"value"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"value1"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_addressing_an_instance" href="#_addressing_an_instance"></a> 44。寻址实例</h2></div></div></div><p>该应用程序的每个实例都有一个服务ID，其值可以通过<code class="literal">spring.cloud.bus.id</code>并且其值应按标识符的冒号分隔列表（从最低到最高）排列。默认值是根据环境构造而成的， <code class="literal">spring.application.name</code>和<code class="literal">server.port</code> （要么<code class="literal">spring.application.index</code> （如果已设置）。ID的默认值以以下形式构造： <code class="literal">app:index:id</code> ，其中：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">app</code>是个<code class="literal">vcap.application.name</code> ，如果存在，或者<code class="literal">spring.application.name</code></li><li class="listitem"><code class="literal">index</code>是个<code class="literal">vcap.application.instance_index</code> ，如果存在， <code class="literal">spring.application.index</code> ， <code class="literal">local.server.port</code> ， <code class="literal">server.port</code> ， 要么<code class="literal">0</code> （以该顺序）。</li><li class="listitem"><code class="literal">id</code>是个<code class="literal">vcap.application.instance_id</code> ，如果存在，则为一个随机值。</li></ul></div><p>HTTP端点接受<span class="quote">“ <span class="quote">destination</span> ”</span>路径参数，例如<code class="literal">/bus-refresh/customers:9000</code> ，在哪里<code class="literal">destination</code>是服务ID。如果该ID由总线上的一个实例拥有，它将处理该消息，而所有其他实例将忽略它。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_addressing_all_instances_of_a_service" href="#_addressing_all_instances_of_a_service"></a> 45。处理服务的所有实例</h2></div></div></div><p>在Spring中使用<span class="quote">“ <span class="quote">destination</span> ”</span>参数<code class="literal">PathMatcher</code> （以路径分隔符作为冒号- <code class="literal">:</code> ），以确定实例是否处理该消息。使用前面的示例， <code class="literal">/bus-env/customers:**</code>定位<span class="quote">“ <span class="quote">客户</span> ”</span>服务的所有实例，而与其余服务ID无关。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_service_id_must_be_unique" href="#_service_id_must_be_unique"></a> 46。服务ID必须唯一</h2></div></div></div><p>总线尝试两次以消除对事件的处理-一次来自原始事件<code class="literal">ApplicationEvent</code>然后一次从队列中为此，它将对照当前服务ID检查发送服务ID。如果服务的多个实例具有相同的ID，则不会处理事件。在本地计算机上运行时，每个服务都在不同的端口上，并且该端口是ID的一部分。 Cloud Foundry提供了一个区分索引。为确保ID在Cloud Foundry之外是唯一的，请设置<code class="literal">spring.application.index</code>对于每个服务实例都是唯一的。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_customizing_the_message_broker" href="#_customizing_the_message_broker"></a> 47。自定义消息代理</h2></div></div></div><p>Spring Cloud Bus使用<a class="link" href="https://cloud.spring.io/spring-cloud-stream" target="_top">Spring Cloud Stream</a>广播消息。因此，要使消息流动，您只需要在类路径中包括您选择的活页夹实现即可。带有AMQP（RabbitMQ）和Kafka（ <code class="literal">spring-cloud-starter-bus-[amqp|kafka]</code> ）。一般来说，Spring Cloud Stream依赖于Spring Boot自动配置约定来配置中间件。例如，可以使用以下方式更改AMQP经纪人地址<code class="literal">spring.rabbitmq.*</code>配置属性。Spring Cloud Bus在以下方面具有少数本机配置属性<code class="literal">spring.cloud.bus.*</code> （例如， <code class="literal">spring.cloud.bus.destination</code>是用作外部中间件的主题的名称）。通常，默认值就足够了。</p><p>要了解有关如何自定义消息代理设置的更多信息，请参阅Spring Cloud Stream文档。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_tracing_bus_events" href="#_tracing_bus_events"></a> 48。追踪巴士事件</h2></div></div></div><p>公交事件（的子类<code class="literal">RemoteApplicationEvent</code>可以通过设置来跟踪<code class="literal">spring.cloud.bus.trace.enabled=true</code> 。如果您这样做的话，Spring Boot <code class="literal">TraceRepository</code> （如果存在）显示每个发送的事件以及每个服务实例的所有通知。以下示例来自<code class="literal">/trace</code>端点：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"timestamp"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2015-11-26T10:24:44.411+0000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"info"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"signal"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring.cloud.bus.ack"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"RefreshRemoteApplicationEvent"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"c4d374b7-58ea-4928-a312-31984def293b"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"origin"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stores:8081"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"destination"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*:**"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"timestamp"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2015-11-26T10:24:41.864+0000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"info"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"signal"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring.cloud.bus.sent"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"RefreshRemoteApplicationEvent"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"c4d374b7-58ea-4928-a312-31984def293b"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"origin"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customers:9000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"destination"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*:**"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"timestamp"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2015-11-26T10:24:41.862+0000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"info"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"signal"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring.cloud.bus.ack"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"RefreshRemoteApplicationEvent"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"c4d374b7-58ea-4928-a312-31984def293b"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"origin"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customers:9000"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"destination"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*:**"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>上面的迹线表明<code class="literal">RefreshRemoteApplicationEvent</code>来自<code class="literal">customers:9000</code> ，广播给所有服务，并被接收（确认） <code class="literal">customers:9000</code>和<code class="literal">stores:8081</code> 。</p><p>要自己处理确认信号，您可以添加一个<code class="literal">@EventListener</code>为了<code class="literal">AckRemoteApplicationEvent</code>和<code class="literal">SentApplicationEvent</code>键入您的应用（并启用跟踪）。或者，您可以点击<code class="literal">TraceRepository</code>并从那里挖掘数据。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>任何Bus应用程序都可以跟踪acks。但是，有时，在中央服务中执行此操作很有用，该服务可以对数据执行更复杂的查询，或将其转发给专门的跟踪服务。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_broadcasting_your_own_events" href="#_broadcasting_your_own_events"></a> 49。广播自己的活动</h2></div></div></div><p>巴士可以携带任何类型的事件<code class="literal">RemoteApplicationEvent</code> 。默认传输是JSON，解串器需要提前知道将要使用哪些类型。要注册新类型，必须将其放在以下子包中<code class="literal">org.springframework.cloud.bus.event</code> 。</p><p>要自定义事件名称，可以使用<code class="literal">@JsonTypeName</code>在您的自定义类上还是依靠默认策略，即使用该类的简单名称。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>生产者和消费者都需要访问类定义。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_events_in_custom_packages" href="#_registering_events_in_custom_packages"></a> 49.1在自定义程序包中注册事件</h2></div></div></div><p>如果您不能或不想使用以下子包<code class="literal">org.springframework.cloud.bus.event</code>对于您的自定义事件，必须指定要扫描哪些程序包以查找类型的事件<code class="literal">RemoteApplicationEvent</code>通过使用<code class="literal">@RemoteApplicationEventScan</code>注解。指定的套件<code class="literal">@RemoteApplicationEventScan</code>包括子包。</p><p>例如，考虑以下自定义事件，即<code class="literal">MyEvent</code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.acme;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyEvent <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> RemoteApplicationEvent {
    ...
}</pre><p>您可以通过以下方式在解串器中注册该事件：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.acme;

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@RemoteApplicationEventScan</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BusConfiguration {
    ...
}</pre><p>在不指定值的情况下，该类的包<code class="literal">@RemoteApplicationEventScan</code>用于注册。在这个例子中<code class="literal">com.acme</code>通过使用以下软件包注册<code class="literal">BusConfiguration</code> 。</p><p>您还可以使用来明确指定要扫描的软件包<code class="literal">value</code> ， <code class="literal">basePackages</code>要么<code class="literal">basePackageClasses</code>的属性<code class="literal">@RemoteApplicationEventScan</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.acme;

<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//@RemoteApplicationEventScan({"com.acme", "foo.bar"})</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//@RemoteApplicationEventScan(basePackages = {"com.acme", "foo.bar", "fizz.buzz"})</span>
<em><span class="hl-annotation" style="color: gray">@RemoteApplicationEventScan(basePackageClasses = BusConfiguration.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BusConfiguration {
    ...
}</pre><p>以上所有示例<code class="literal">@RemoteApplicationEventScan</code>是等效的，因为<code class="literal">com.acme</code>通过显式指定软件包来注册软件包<code class="literal">@RemoteApplicationEventScan</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您可以指定多个要扫描的基本软件包。</p></td></tr></tbody></table></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_sleuth" href="#_spring_cloud_sleuth"></a>第八部分 Spring Cloud Sleuth </h1></div></div></div><div class="partintro"><div></div><p>阿德里安·科尔（Adrian Cole），斯宾塞·吉布（Spencer Gibb），玛琳·格热兹兹克（Marcin Grzejszczak），戴夫·瑟（Dave Syer），杰伊·布莱恩特（Jay Bryant）</p><p><span class="strong"><strong>格林威治。SR4</strong></span></p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_introduction" href="#_introduction"></a> 50介绍</h2></div></div></div><p>Spring Cloud Sleuth为<a class="link" href="https://cloud.spring.io" target="_top">Spring Cloud</a>实现了分布式跟踪解决方案。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_terminology" href="#_terminology"></a> 50.1术语</h2></div></div></div><p>Spring Cloud Sleuth借用了<a class="link" href="https://research.google.com/pubs/pub36356.html" target="_top">Dapper的</a>术语。</p><p><span class="strong"><strong>跨度</strong></span> ：基本工作单位。例如，发送RPC是一个新的跨度，就像发送响应到RPC一样。跨度由跨度的唯一64位ID和跨度所属的跟踪的另一个64位ID标识。跨区还具有其他数据，例如描述，带有时间戳的事件，键值批注（标签），引起跨度的跨区ID和进程ID（通常为IP地址）。</p><p>跨度可以启动和停止，并且可以跟踪其时序信息。创建跨度后，您必须在将来的某个时间点将其停止。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>开始跟踪的初始跨度称为<code class="literal">root span</code> 。该跨度的ID的值等于跟踪ID。</p></td></tr></tbody></table></div><p><span class="strong"><strong>迹线：</strong></span>一组形成树状结构的跨度。例如，如果您运行分布式大数据存储，则跟踪可能由<code class="literal">PUT</code>请求。</p><p><span class="strong"><strong>注释：</strong></span>用于及时记录事件的存在。使用<a class="link" href="https://github.com/openzipkin/brave" target="_top">Brave</a>工具，我们不再需要为<a class="link" href="https://zipkin.io/" target="_top">Zipkin</a>设置特殊事件来了解客户端和服务器是谁，请求在哪里开始以及在哪里结束。但是，出于学习目的，我们标记这些事件以突出显示发生了哪种操作。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>cs</strong></span> ：客户端已发送。客户提出了要求。此注释指示跨度的开始。</li><li class="listitem"><span class="strong"><strong>sr</strong></span> ：接收到服务器：服务器端收到了请求并开始处理它。减去<code class="literal">cs</code>此时间戳中的时间戳显示了网络延迟。</li><li class="listitem"><span class="strong"><strong>ss</strong></span> ：服务器已发送。在请求处理完成时进行注释（当响应被发送回客户端时）。减去<code class="literal">sr</code>此时间戳中的时间戳显示了服务器端处理请求所需的时间。</li><li class="listitem"><span class="strong"><strong>cr</strong></span> ：收到客户。表示跨度结束。客户端已成功收到服务器端的响应。减去<code class="literal">cs</code>此时间戳中的时间戳显示了客户端从服务器接收响应所需的整个时间。</li></ul></div><p>下图显示了<span class="strong"><strong>Span</strong></span>和<span class="strong"><strong>Trace</strong></span>在系统中的外观以及Zipkin批注：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/trace-id.png" alt="跟踪信息传播"></div></div><p>音符的每种颜色表示一个跨度（有七个跨度-从<span class="strong"><strong>A</strong></span>到<span class="strong"><strong>G</strong></span> ）。请考虑以下注意事项：</p><pre class="screen">Trace Id = X
Span Id = D
Client Sent</pre><p>此注释表示当前跨度已将“ <span class="strong"><strong>跟踪ID”</strong></span>设置为<span class="strong"><strong>X</strong></span>并将“ <span class="strong"><strong>跨度ID”</strong></span>设置为<span class="strong"><strong>D。</strong></span>另外， <code class="literal">Client Sent</code>事件发生了。</p><p>下图显示了跨度的父子关系：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/parents.png" alt="亲子关系"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_purpose" href="#_purpose"></a> 50.2目的</h2></div></div></div><p>以下各节引用上图中显示的示例。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_distributed_tracing_with_zipkin" href="#_distributed_tracing_with_zipkin"></a> 50.2.1使用Zipkin进行分布式跟踪</h3></div></div></div><p>本示例有七个跨度。如果转到Zipkin中的跟踪，则可以在第二个跟踪中看到此数字，如下图所示：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-traces.png" alt="痕迹"></div></div><p>但是，如果选择特定的轨迹，则可以看到四个跨度，如下图所示：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-ui.png" alt="跟踪信息传播"></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>选择特定轨迹时，会看到合并的跨度。这意味着，如果有两个跨度发送到Zipkin，且带有“服务器已接收和服务器已发送”或“客户端已接收和客户端已发送”注释，则它们将显示为单个跨度。</p></td></tr></tbody></table></div><p>在这种情况下，为什么七个跨度和四个跨度有区别？</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">一个跨度来自<code class="literal">http:/start</code>跨度。它已收到服务器（ <code class="literal">sr</code> ）和已发送的服务器（ <code class="literal">ss</code> ）注释。</li><li class="listitem">来自两个RPC调用的两个范围<code class="literal">service1</code>至<code class="literal">service2</code>到<code class="literal">http:/foo</code>端点。客户已发送（ <code class="literal">cs</code> ），并收到客户（ <code class="literal">cr</code> ）事件发生在<code class="literal">service1</code>侧。服务器已收到（ <code class="literal">sr</code> ）和已发送的服务器（ <code class="literal">ss</code> ）事件发生在<code class="literal">service2</code>侧。这两个跨度形成一个与RPC调用相关的逻辑跨度。</li><li class="listitem">来自两个RPC调用的两个范围<code class="literal">service2</code>至<code class="literal">service3</code>到<code class="literal">http:/bar</code>端点。客户已发送（ <code class="literal">cs</code> ），并收到客户（ <code class="literal">cr</code> ）事件发生在<code class="literal">service2</code>侧。服务器收到（ <code class="literal">sr</code> ）和已发送的服务器（ <code class="literal">ss</code> ）事件发生在<code class="literal">service3</code>侧。这两个跨度形成一个与RPC调用相关的逻辑跨度。</li><li class="listitem">来自两个RPC调用的两个范围<code class="literal">service2</code>至<code class="literal">service4</code>到<code class="literal">http:/baz</code>端点。客户已发送（ <code class="literal">cs</code> ），并收到客户（ <code class="literal">cr</code> ）事件发生在<code class="literal">service2</code>侧。服务器已收到（ <code class="literal">sr</code> ）和已发送的服务器（ <code class="literal">ss</code> ）事件发生在<code class="literal">service4</code>侧。这两个跨度形成一个与RPC调用相关的逻辑跨度。</li></ul></div><p>因此，如果我们计算物理跨度，则有一个<code class="literal">http:/start</code> ，两个来自<code class="literal">service1</code>呼唤<code class="literal">service2</code> ，两个来自<code class="literal">service2</code>呼唤<code class="literal">service3</code>和两个来自<code class="literal">service2</code>呼唤<code class="literal">service4</code> 。总而言之，我们共有七个跨度。</p><p>从逻辑上讲，我们看到四个跨度的信息，因为我们有一个跨度与传入请求有关<code class="literal">service1</code>和与RPC调用相关的三个范围。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_visualizing_errors" href="#_visualizing_errors"></a> 50.2.2可视化错误</h3></div></div></div><p>Zipkin使您可以可视化跟踪中的错误。当引发异常但未捕获到异常时，我们在跨度上设置了适当的标签，然后Zipkin可以正确着色。您可以在迹线列表中看到一条红色的迹线。之所以出现，是因为引发了异常。</p><p>如果单击该跟踪，将看到类似的图片，如下所示：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-error-traces.png" alt="错误痕迹"></div></div><p>如果您再单击其中一个跨度，则会看到以下内容</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-error-trace-screenshot.png" alt="错误跟踪信息传播"></div></div><p>跨度显示了错误的原因以及与之相关的整个堆栈跟踪。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_distributed_tracing_with_brave" href="#_distributed_tracing_with_brave"></a> 50.2.3勇敢的分布式跟踪</h3></div></div></div><p>从版本开始<code class="literal">2.0.0</code> ，Spring Cloud Sleuth使用<a class="link" href="https://github.com/openzipkin/brave" target="_top">Brave</a>作为跟踪库。因此，Sleuth不再负责存储上下文，而是将工作委托给Brave。</p><p>由于Sleuth与Brave具有不同的命名和标记约定，因此我们决定从现在开始遵循Brave的约定。但是，如果您想使用传统的Sleuth方法，则可以设置<code class="literal">spring.sleuth.http.legacy.enabled</code>财产<code class="literal">true</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_live_examples" href="#_live_examples"></a> 50.2.4现场示例</h3></div></div></div><div class="figure"><a name="d0e16534" href="#d0e16534"></a><p class="title"><b>图50.1。单击“ Pivotal Web服务”图标可实时观看！</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/pws.png" alt="Zipkin部署在Pivotal Web Services上"></div></div></div><br class="figure-break"><p><a class="link" href="https://docssleuth-zipkin-server.cfapps.io/" target="_top">点击此处观看直播！</a></p><p>Zipkin中的依赖关系图应类似于下图：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/dependencies.png" alt="依存关系"></div></div><div class="figure"><a name="d0e16555" href="#d0e16555"></a><p class="title"><b>图50.2。单击“ Pivotal Web服务”图标可实时观看！</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/pws.png" alt="Zipkin部署在Pivotal Web Services上"></div></div></div><br class="figure-break"><p><a class="link" href="https://docssleuth-zipkin-server.cfapps.io/dependency" target="_top">点击此处观看直播！</a></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_log_correlation" href="#_log_correlation"></a> 50.2.5日志关联</h3></div></div></div><p>使用grep通过扫描等于（例如）的跟踪ID读取这四个应用程序的日志时<code class="literal">2485ec27856c56f4</code> ，您将获得类似于以下内容的输出：</p><pre class="screen">service1.log:2016-02-26 11:15:47.561  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Hello from service1. Calling service2
service2.log:2016-02-26 11:15:47.710  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Hello from service2. Calling service3 and then service4
service3.log:2016-02-26 11:15:47.895  INFO [service3,2485ec27856c56f4,1210be13194bfe5,true] 68060 --- [nio-8083-exec-1] i.s.c.sleuth.docs.service3.Application   : Hello from service3
service2.log:2016-02-26 11:15:47.924  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service3 [Hello from service3]
service4.log:2016-02-26 11:15:48.134  INFO [service4,2485ec27856c56f4,1b1845262ffba49d,true] 68061 --- [nio-8084-exec-1] i.s.c.sleuth.docs.service4.Application   : Hello from service4
service2.log:2016-02-26 11:15:48.156  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service4 [Hello from service4]
service1.log:2016-02-26 11:15:48.182  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Got response from service2 [Hello from service2, response from service3 [Hello from service3] and from service4 [Hello from service4]]</pre><p>如果您使用日志汇总工具（例如<a class="link" href="https://www.elastic.co/products/kibana" target="_top">Kibana</a> ， <a class="link" href="https://www.splunk.com/" target="_top">Splunk</a>和其他工具），则可以对发生的事件进行排序。来自Kibana的示例类似于下图：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/kibana.png" alt="与Kibana的对数关联"></div></div><p>如果要使用<a class="link" href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_top">Logstash</a> ，以下清单显示了Logstash的Grok模式：</p><pre class="screen">filter {
       # pattern matching logback pattern
       grok {
              match =&gt; { "message" =&gt; "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果要将Grok与Cloud Foundry的日志一起使用，则必须使用以下模式：</p></td></tr></tbody></table></div><pre class="screen">filter {
       # pattern matching logback pattern
       grok {
              match =&gt; { "message" =&gt; "(?m)OUT\s+%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_json_logback_with_logstash" href="#_json_logback_with_logstash"></a>使用Logstash进行JSON Logback</h4></div></div></div><p>通常，您不想将日志存储在文本文件中，而是存储在Logstash可以立即选择的JSON文件中。为此，您必须执行以下操作（出于可读性考虑，我们在<code class="literal">groupId:artifactId:version</code>符号）。</p><p><span class="strong"><strong>依赖关系设置</strong></span></p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">确保Logback位于类路径（ <code class="literal">ch.qos.logback:logback-core</code> ）。</li><li class="listitem">添加Logstash Logback编码。例如，使用版本<code class="literal">4.6</code> ，添加<code class="literal">net.logstash.logback:logstash-logback-encoder:4.6</code> 。</li></ol></div><p><span class="strong"><strong>登录设置</strong></span></p><p>考虑以下Logback配置文件示例（名为<a class="link" href="https://github.com/spring-cloud-samples/sleuth-documentation-apps/blob/master/service1/src/main/resources/logback-spring.xml" target="_top">logback-spring.xml</a> ）。</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">resource</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"org/springframework/boot/logging/logback/defaults.xml"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>
	&#8203;
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;springProperty</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">scope</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"context"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"springAppName"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">source</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"spring.application.name"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Example for logging into the build folder of your project --&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;property</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"LOG_FILE"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">value</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"${BUILD_FOLDER:-build}/${springAppName}"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>&#8203;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- You can override this to have a custom pattern --&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;property</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"CONSOLE_LOG_PATTERN"</span>
			  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">value</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Appender to log to console --&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"console"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.ConsoleAppender"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;filter</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.classic.filter.ThresholdFilter"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Minimum logging level to be presented in the console logs--&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;level&gt;</span>DEBUG<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/level&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/filter&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;encoder&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pattern&gt;</span>${CONSOLE_LOG_PATTERN}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pattern&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;charset&gt;</span>utf8<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/charset&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/encoder&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appender&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Appender to log to file --&gt;</span>&#8203;
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"flatfile"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.rolling.RollingFileAppender"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;file&gt;</span>${LOG_FILE}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/file&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;rollingPolicy</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileNamePattern&gt;</span>${LOG_FILE}.%d{yyyy-MM-dd}.gz<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileNamePattern&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;maxHistory&gt;</span>7<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/maxHistory&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/rollingPolicy&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;encoder&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pattern&gt;</span>${CONSOLE_LOG_PATTERN}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pattern&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;charset&gt;</span>utf8<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/charset&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/encoder&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appender&gt;</span>
	&#8203;
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Appender to log to file in a JSON format --&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"logstash"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.rolling.RollingFileAppender"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;file&gt;</span>${LOG_FILE}.json<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/file&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;rollingPolicy</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileNamePattern&gt;</span>${LOG_FILE}.json.%d{yyyy-MM-dd}.gz<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileNamePattern&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;maxHistory&gt;</span>7<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/maxHistory&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/rollingPolicy&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;encoder</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;providers&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;timestamp&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;timeZone&gt;</span>UTC<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/timeZone&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/timestamp&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pattern&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pattern&gt;</span>
						{
						"severity": "%level",
						"service": "${springAppName:-}",
						"trace": "%X{X-B3-TraceId:-}",
						"span": "%X{X-B3-SpanId:-}",
						"parent": "%X{X-B3-ParentSpanId:-}",
						"exportable": "%X{X-Span-Export:-}",
						"pid": "${PID:-}",
						"thread": "%thread",
						"class": "%logger{40}",
						"rest": "%message"
						}
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pattern&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pattern&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/providers&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/encoder&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appender&gt;</span>
	&#8203;
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;root</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">level</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"INFO"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender-ref</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ref</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"console"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- uncomment this to have also JSON logs --&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;appender-ref ref="logstash"/&gt;--&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;appender-ref ref="flatfile"/&gt;--&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/root&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span></pre><p>该Logback配置文件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">将应用程序中的信息以JSON格式记录到<code class="literal">build/${spring.application.name}.json</code>文件。</li><li class="listitem">注释了两个附加的附加程序：控制台和标准日志文件。</li><li class="listitem">具有与上一部分相同的日志记录模式。</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您使用自定义<code class="literal">logback-spring.xml</code> ，您必须通过<code class="literal">spring.application.name</code>在里面<code class="literal">bootstrap</code>而不是<code class="literal">application</code>属性文件。否则，您的自定义登录文件将无法正确读取该属性。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_propagating_span_context" href="#_propagating_span_context"></a> 50.2.6传播跨度上下文</h3></div></div></div><p>跨度上下文是必须跨进程边界传播到任何子跨度的状态。跨度上下文的一部分是行李。跟踪和跨度ID是跨度上下文的必需部分。行李是可选部件。</p><p>行李是存储在span上下文中的一组key：value对。行李与踪迹一起旅行，并附着在每个跨度上。Spring Cloud Sleuth理解，如果HTTP标头带有前缀，则标头与行李相关<code class="literal">baggage-</code>对于消息传递，它从<code class="literal">baggage_</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>当前对行李物品的数量或大小没有限制。但是，请记住，太多会降低系统吞吐量或增加RPC延迟。在极端情况下，由于超出传输级别的消息或标头容量，过多的行李可能会使应用程序崩溃。</p></td></tr></tbody></table></div><p>以下示例显示跨度设置行李：</p><pre class="programlisting">Span initialSpan = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.nextSpan().name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"span"</span>).start();
ExtraFieldPropagation.set(initialSpan.context(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>);
ExtraFieldPropagation.set(initialSpan.context(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UPPER_CASE"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"someValue"</span>);</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_baggage_versus_span_tags" href="#_baggage_versus_span_tags"></a>行李与跨度标签</h4></div></div></div><p>行李随身携带（每个孩子跨度都包含其父母的行李）。Zipkin不了解行李，也不会收到该信息。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>从Sleuth 2.0.0开始，您必须在项目配置中显式传递行李密钥名称。了解更多关于该设置<a class="link" href="#prefixed-fields" title="54.1.1前缀字段">在这里</a></p></td></tr></tbody></table></div><p>标签被附加到特定范围。换句话说，它们仅针对该特定跨度显示。但是，您可以按标签搜索以找到轨迹，前提是存在一个具有所搜索标签值的跨度。</p><p>如果您希望能够基于行李查找跨度，则应在根跨度中添加相应的条目作为标签。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>范围必须在范围内。</p></td></tr></tbody></table></div><p>以下清单显示了使用行李的集成测试：</p><p><b>设置。</b>
</p><pre class="programlisting">spring.sleuth:
  baggage-keys:
    - baz
    - bizarrecase
  propagation-keys:
    - foo
    - upper_case</pre><p>
</p><p><b>代码。</b>
</p><pre class="programlisting">initialSpan.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>,
		ExtraFieldPropagation.get(initialSpan.context(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>));
initialSpan.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UPPER_CASE"</span>,
		ExtraFieldPropagation.get(initialSpan.context(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UPPER_CASE"</span>));</pre><p>
</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="sleuth-adding-project" href="#sleuth-adding-project"></a> 50.3在项目中添加侦探</h2></div></div></div><p>本节介绍如何使用Maven或Gradle将Sleuth添加到项目中。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>为确保您的应用名称正确显示在Zipkin中，请设置<code class="literal">spring.application.name</code>财产<code class="literal">bootstrap.yml</code> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_only_sleuth_log_correlation" href="#_only_sleuth_log_correlation"></a> 50.3.1仅侦探（对数关联）</h3></div></div></div><p>如果您只想使用Spring Cloud Sleuth而没有Zipkin集成，请添加<code class="literal">spring-cloud-starter-sleuth</code>模块到您的项目。</p><p>下面的示例演示如何使用Maven添加Sleuth：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span> <a name="CO1-1" href="#CO1-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${release.train.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span> <a name="CO1-2" href="#CO1-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-sleuth<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO1-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>将依赖项添加到<code class="literal">spring-cloud-starter-sleuth</code> 。</p></td></tr></tbody></table></div><p>下面的示例演示如何使用Gradle添加Sleuth：</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">dependencyManagement { <a name="CO2-1" href="#CO2-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
    imports {
        mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"</span>
    }
}

dependencies { <a name="CO2-2" href="#CO2-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    compile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-starter-sleuth"</span>
}</pre><p class="secondary">
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO2-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO2-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>将依赖项添加到<code class="literal">spring-cloud-starter-sleuth</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_sleuth_with_zipkin_via_http" href="#_sleuth_with_zipkin_via_http"></a> 50.3.2通过HTTP与Zipkin一起侦探</h3></div></div></div><p>如果您同时需要Sleuth和Zipkin，请添加<code class="literal">spring-cloud-starter-zipkin</code>依赖性。</p><p>以下示例显示了如何对Maven执行此操作：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span> <a name="CO3-1" href="#CO3-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${release.train.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span> <a name="CO3-2" href="#CO3-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-zipkin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO3-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO3-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>将依赖项添加到<code class="literal">spring-cloud-starter-zipkin</code> 。</p></td></tr></tbody></table></div><p>以下示例显示了如何对Gradle进行操作：</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">dependencyManagement { <a name="CO4-1" href="#CO4-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
    imports {
        mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"</span>
    }
}

dependencies { <a name="CO4-2" href="#CO4-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    compile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-starter-zipkin"</span>
}</pre><p class="secondary">
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO4-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO4-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>将依赖项添加到<code class="literal">spring-cloud-starter-zipkin</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_sleuth_with_zipkin_over_rabbitmq_or_kafka" href="#_sleuth_with_zipkin_over_rabbitmq_or_kafka"></a> 50.3.3通过RabbitMQ或Kafka用Zipkin侦探</h3></div></div></div><p>如果您要使用RabbitMQ或Kafka而不是HTTP，请添加<code class="literal">spring-rabbit</code>要么<code class="literal">spring-kafka</code>依赖性。默认目的地名称是<code class="literal">zipkin</code> 。</p><p>如果使用Kafka，则必须设置属性<code class="literal">spring.zipkin.sender.type</code>相应的属性：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.zipkin.sender.type</span>: kafka</pre><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p><code class="literal">spring-cloud-sleuth-stream</code>已不推荐使用，并且与这些目的地不兼容。</p></td></tr></tbody></table></div><p>如果要让Sleuth优于RabbitMQ，请添加<code class="literal">spring-cloud-starter-zipkin</code>和<code class="literal">spring-rabbit</code>依赖性。</p><p>以下示例显示了如何对Gradle进行操作：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span> <a name="CO5-1" href="#CO5-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${release.train.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span> <a name="CO5-2" href="#CO5-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-zipkin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span> <a name="CO5-3" href="#CO5-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.amqp<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-rabbit<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO5-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO5-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>将依赖项添加到<code class="literal">spring-cloud-starter-zipkin</code> 。这样，所有嵌套的依赖项都将被下载。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO5-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>要自动配置RabbitMQ，请添加<code class="literal">spring-rabbit</code>依赖性。</p></td></tr></tbody></table></div><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">dependencyManagement { <a name="CO6-1" href="#CO6-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
    imports {
        mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"</span>
    }
}

dependencies {
    compile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-starter-zipkin"</span> <a name="CO6-2" href="#CO6-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
    compile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.amqp:spring-rabbit"</span> <a name="CO6-3" href="#CO6-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
}</pre><p class="secondary">
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO6-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO6-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>将依赖项添加到<code class="literal">spring-cloud-starter-zipkin</code> 。这样，所有嵌套的依赖项都将被下载。</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO6-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>要自动配置RabbitMQ，请添加<code class="literal">spring-rabbit</code>依赖性。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_overriding_the_auto_configuration_of_zipkin" href="#_overriding_the_auto_configuration_of_zipkin"></a> 50.4覆盖Zipkin的自动配置</h2></div></div></div><p>从2.1.0版开始，Spring Cloud Sleuth支持将跟踪发送到多个跟踪系统。为了使它起作用，每个跟踪系统都需要有一个<code class="literal">Reporter<Span></code>和<code class="literal">Sender</code> 。如果要覆盖提供的bean，则需要给它们指定一个特定的名称。为此，您可以分别使用<code class="literal">ZipkinAutoConfiguration.REPORTER_BEAN_NAME</code>和<code class="literal">ZipkinAutoConfiguration.SENDER_BEAN_NAME</code> 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfig {

	<em><span class="hl-annotation" style="color: gray">@Bean(ZipkinAutoConfiguration.REPORTER_BEAN_NAME)</span></em>
	Reporter&lt;zipkin2.Span&gt; myReporter() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> AsyncReporter.create(mySender());
	}

	<em><span class="hl-annotation" style="color: gray">@Bean(ZipkinAutoConfiguration.SENDER_BEAN_NAME)</span></em>
	MySender mySender() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> MySender();
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MySender <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Sender {

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> spanSent = false;

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> isSpanSent() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spanSent;
		}

		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Encoding encoding() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Encoding.JSON;
		}

		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> messageMaxBytes() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Integer.MAX_VALUE;
		}

		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> messageSizeInBytes(List&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; encodedSpans) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> encoding().listSizeInBytes(encodedSpans);
		}

		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Call&lt;Void&gt; sendSpans(List&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; encodedSpans) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spanSent = true;
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Call.create(null);
		}

	}

}</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_additional_resources" href="#_additional_resources"></a> 51。其他资源</h2></div></div></div><p><a class="link" href="https://content.pivotal.io/springone-platform-2017/distributed-tracing-latency-analysis-for-your-microservices-grzejszczak-krishna" target="_top">单击此处，</a>您可以观看<a class="link" href="https://twitter.com/reshmi9k" target="_top">Reshmi Krishna</a>和<a class="link" href="https://twitter.com/mgrzejszczak" target="_top">Marcin Grzejszczak</a>谈论有关Spring Cloud Sleuth和Zipkin <a class="link" href="https://content.pivotal.io/springone-platform-2017/distributed-tracing-latency-analysis-for-your-microservices-grzejszczak-krishna" target="_top">的视频</a> 。</p><p>您可以检查警犬和勇敢的不同设置<a class="link" href="https://github.com/openzipkin/sleuth-webmvc-example" target="_top">在openzipkin /侦探-webmvc，例如仓库</a> 。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_features_2" href="#_features_2"></a> 52。特征</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">将跟踪和跨度ID添加到Slf4J MDC，因此您可以在日志聚合器中从给定的跟踪或跨度提取所有日志，如以下示例日志所示：</p><pre class="screen">2016-02-02 15:30:57.902  INFO [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:30:58.372 ERROR [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:31:01.936  INFO [bar,46ab0d418373cbc9,46ab0d418373cbc9,false] 23030 --- [nio-8081-exec-4] ...</pre><p class="simpara">注意<code class="literal">[appname,traceId,spanId,exportable]</code>来自MDC的条目：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><span class="strong"><strong><code class="literal">spanId</code></strong></span> ：发生的特定操作的ID。</li><li class="listitem"><span class="strong"><strong><code class="literal">appname</code></strong></span> ：记录跨度的应用程序的名称。</li><li class="listitem"><span class="strong"><strong><code class="literal">traceId</code></strong></span> ：包含跨度的延迟图的ID。</li><li class="listitem"><span class="strong"><strong><code class="literal">exportable</code></strong></span> ：是否应将日志导出到Zipkin。您何时希望跨度不可导出？当您要将某些操作包装在Span中并将其仅写入日志时。</li></ul></div></li><li class="listitem">提供对常见的分布式跟踪数据模型的抽象：跟踪，跨度（形成DAG），注释和键值注释。Spring Cloud Sleuth宽松地基于HTrace，但与Zipkin（Dapper）兼容。</li><li class="listitem">Sleuth记录计时信息以帮助进行延迟分析。通过使用侦探，您可以查明应用程序中延迟的原因。</li><li class="listitem"><p class="simpara">编写Sleuth时不要过多记录日志，也不会导致生产应用程序崩溃。为此，Sleuth：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">在带内传播有关调用图的结构数据，并在带外传播其余数据。</li><li class="listitem">包括对诸如HTTP之类的层的自觉检测。</li><li class="listitem">包括用于管理数量的采样策略。</li><li class="listitem">可以报告给Zipkin系统进行查询和可视化。</li></ul></div></li><li class="listitem">从Spring应用程序（Servlet过滤器，异步端点，Rest模板，调度的动作，消息通道，Zuul过滤器和Feign客户端）检测常见的入口和出口点。</li><li class="listitem">Sleuth包含默认逻辑以跨HTTP或消息传递边界加入跟踪。例如，HTTP传播在与Zipkin兼容的请求标头上工作。</li><li class="listitem">侦查可以在进程之间传播上下文（也称为行李）。因此，如果您在Span上设置了行李元素，则会通过HTTP或消息传递将其下游发送到其他进程。</li><li class="listitem">提供一种创建或继续跨度以及通过注释添加标签和日志的方法。</li><li class="listitem"><p class="simpara">如果<code class="literal">spring-cloud-sleuth-zipkin</code>在类路径上，该应用程序会生成并收集与Zipkin兼容的跟踪。默认情况下，它通过HTTP将它们发送到本地主机（端口9411）上的Zipkin服务器。您可以通过设置配置服务的位置<code class="literal">spring.zipkin.baseUrl</code> 。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">如果你依靠<code class="literal">spring-rabbit</code> ，您的应用会将跟踪发送到RabbitMQ代理，而不是HTTP。</li><li class="listitem">如果你依靠<code class="literal">spring-kafka</code> ，并设置<code class="literal">spring.zipkin.sender.type: kafka</code> ，您的应用会将跟踪发送到Kafka代理，而不是HTTP。</li></ul></div></li></ul></div><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p><code class="literal">spring-cloud-sleuth-stream</code>已弃用，不应再使用。</p></td></tr></tbody></table></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">Spring Cloud Sleuth与<a class="link" href="https://opentracing.io/" target="_top">OpenTracing</a>兼容。</li></ul></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您使用Zipkin，请通过设置配置导出跨度的概率<code class="literal">spring.sleuth.sampler.probability</code> （默认值：0.1，即10％）。否则，您可能会认为Sleuth无法正常工作，因为它忽略了一些跨度。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>始终设置SLF4J MDC，并且按先前显示的示例，登录用户可以立即在日志中看到跟踪和跨度ID。其他日志记录系统必须配置自己的格式化程序才能获得相同的结果。默认值如下： <code class="literal">logging.pattern.level</code>调成<code class="literal">%5p [${spring.zipkin.service.name:${spring.application.name:-}},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}]</code> （这是Logback用户的Spring Boot功能）。如果您不使用SLF4J，则不会自动应用此模式。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_introduction_to_brave" href="#_introduction_to_brave"></a> 52.1勇敢简介</h2></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>从版本开始<code class="literal">2.0.0</code> ，Spring Cloud Sleuth使用<a class="link" href="https://github.com/openzipkin/brave" target="_top">Brave</a>作为跟踪库。为了您的方便，我们在此处嵌入了Brave文档的一部分。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>在大多数情况下，您只需要使用<code class="literal">Tracer</code>要么<code class="literal">SpanCustomizer</code> Sleuth提供的Brave中的咖啡 bean 。以下文档高度概述了Brave是什么以及它如何工作。</p></td></tr></tbody></table></div><p>勇敢是一个库，用于捕获有关分布式操作的延迟信息并将其报告给Zipkin。大多数用户不直接使用Brave。他们使用库或框架，而不是代表他们使用Brave。</p><p>该模块包括一个跟踪器，该跟踪器创建并连接跨度，以模拟潜在的分布式工作的延迟。它还包括用于在网络边界上传播跟踪上下文的库（例如，使用HTTP标头）。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_tracing" href="#_tracing"></a> 52.1.1跟踪</h3></div></div></div><p>最重要的是，您需要<code class="literal">brave.Tracer</code> ，配置为<a class="link" href="https://github.com/openzipkin/zipkin-reporter-java" target="_top">向Zipkin报告</a> 。</p><p>以下示例安装程序通过HTTP（与Kafka相对）将跟踪数据（跨度）发送到Zipkin：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyClass {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Tracer tracer;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Tracer will be autowired</span>
    MyClass(Tracer tracer) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer = tracer;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doSth() {
        Span span = tracer.newTrace().name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"encode"</span>).start();
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
    }
}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您的跨度包含的名称长于50个字符，则该名称将被截断为50个字符。您的姓名必须明确明确。知名人士会导致延迟问题，有时甚至会引发异常。</p></td></tr></tbody></table></div><p>跟踪器创建并连接跨度，以对潜在的分布式工作的延迟进行建模。它可以采用采样来减少处理过程中的开销，减少发送到Zipkin的数据量或两者。</p><p>跟踪器返回的跨距在完成后将数据报告给Zipkin，如果未采样则不执行任何操作。开始跨度后，您可以注释感兴趣的事件或添加包含详细信息或查找键的标签。</p><p>跨度具有包括跟踪标识符的上下文，该标识符将跨度放置在代表分布式操作的树中的正确位置。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_local_tracing" href="#_local_tracing"></a> 52.1.2本地跟踪</h3></div></div></div><p>跟踪永远不会离开进程的代码时，请在范围范围内运行它。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Start a new trace or a span within an existing trace representing an operation</span>
ScopedSpan span = tracer.startScopedSpan(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"encode"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// The span is in "scope" meaning downstream code such as loggers can see trace IDs</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> encoder.encode();
} <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">catch</span> (RuntimeException | Error e) {
  span.error(e); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Unless you handle exceptions, you might not know the operation failed!</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throw</span> e;
} <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> {
  span.finish(); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// always finish the span</span>
}</pre><p>当您需要更多功能或更好的控制时，请使用<code class="literal">Span</code>类型：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Start a new trace or a span within an existing trace representing an operation</span>
Span span = tracer.nextSpan().name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"encode"</span>).start();
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Put the span in "scope" so that downstream code such as loggers can see trace IDs</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (SpanInScope ws = tracer.withSpanInScope(span)) {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> encoder.encode();
} <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">catch</span> (RuntimeException | Error e) {
  span.error(e); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Unless you handle exceptions, you might not know the operation failed!</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throw</span> e;
} <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> {
  span.finish(); <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// note the scope is independent of the span. Always finish a span.</span>
}</pre><p>上面的两个示例都报告了完全相同的跨度！</p><p>在上面的示例中，范围将是新的根范围或现有跟踪中的下一个子级。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_customizing_spans" href="#_customizing_spans"></a> 52.1.3自定义跨度</h3></div></div></div><p>一旦具有跨度，就可以向其添加标签。标记可用作查找键或详细信息。例如，您可以在运行时版本中添加标签，如以下示例所示：</p><pre class="programlisting">span.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"clnt/finagle.version"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"6.36.0"</span>);</pre><p>向第三方公开自定义跨度的功能时，请优先使用<code class="literal">brave.SpanCustomizer</code>相对于<code class="literal">brave.Span</code> 。前者更易于理解和测试，不会用跨度生命周期挂钩吸引用户。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> MyTraceCallback {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> request(Request request, SpanCustomizer customizer);
}</pre><p>以来<code class="literal">brave.Span</code>贯彻<code class="literal">brave.SpanCustomizer</code> ，您可以将其传递给用户，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> (MyTraceCallback callback : userCallbacks) {
  callback.request(request, span);
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_implicitly_looking_up_the_current_span" href="#_implicitly_looking_up_the_current_span"></a> 52.1.4隐式查找当前跨度</h3></div></div></div><p>有时，您不知道跟踪是否正在进行，并且您不希望用户执行空检查。
<code class="literal">brave.CurrentSpanCustomizer</code>通过将数据添加到正在进行或删除的任何跨度中来解决此问题，如以下示例所示：</p><p>例如</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// The user code can then inject this without a chance of it being null.</span>
<em><span class="hl-annotation" style="color: gray">@Autowired</span></em> SpanCustomizer span;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> userCode() {
  span.annotate(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tx.started"</span>);
  ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rpc_tracing" href="#_rpc_tracing"></a> 52.1.5 RPC跟踪</h3></div></div></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>在滚动自己的RPC工具之前，请检查<a class="link" href="https://github.com/openzipkin/brave/tree/master/instrumentation" target="_top">此处编写</a>的<a class="link" href="https://github.com/openzipkin/brave/tree/master/instrumentation" target="_top">工具</a>以及<a class="link" href="https://zipkin.io/pages/existing_instrumentations.html" target="_top">Zipkin的列表</a> 。</p></td></tr></tbody></table></div><p>RPC跟踪通常由拦截器自动完成。它们在幕后添加了与其在RPC操作中的角色相关的标签和事件。</p><p>以下示例显示如何添加客户端范围：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracing tracing;
<em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// before you send a request, add metadata that describes the operation</span>
span = tracer.nextSpan().name(service + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/"</span> + method).kind(CLIENT);
span.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"myrpc.version"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"1.0.0"</span>);
span.remoteServiceName(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"backend"</span>);
span.remoteIpAndPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"172.3.4.1"</span>, <span class="hl-number">8108</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Add the trace context to the request, so it can be propagated in-band</span>
tracing.propagation().injector(Request::addHeader)
                     .inject(span.context(), request);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when the request is scheduled, start the span</span>
span.start();

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// if there is an error, tag the span</span>
span.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"error"</span>, error.getCode());
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// or if there is an exception</span>
span.error(exception);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when the response is complete, finish the span</span>
span.finish();</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_one_way_tracing" href="#_one_way_tracing"></a>单向跟踪</h4></div></div></div><p>有时，您需要对有请求但无响应的异步操作进行建模。在普通的RPC跟踪中，您使用<code class="literal">span.finish()</code>表示已收到回复。在单向跟踪中，您使用<code class="literal">span.flush()</code>相反，因为您不希望得到响应。</p><p>下面的示例显示客户端如何建模单向操作：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracing tracing;
<em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// start a new span representing a client request</span>
oneWaySend = tracer.nextSpan().name(service + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/"</span> + method).kind(CLIENT);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Add the trace context to the request, so it can be propagated in-band</span>
tracing.propagation().injector(Request::addHeader)
                     .inject(oneWaySend.context(), request);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// fire off the request asynchronously, totally dropping any response</span>
request.execute();

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// start the client side and flush instead of finish</span>
oneWaySend.start().flush();</pre><p>以下示例显示服务器如何处理单向操作：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracing tracing;
<em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// pull the context out of the incoming request</span>
extractor = tracing.propagation().extractor(Request::getHeader);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// convert that context to a span which you can name and add tags to</span>
oneWayReceive = nextSpan(tracer, extractor.extract(request))
    .name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"process-request"</span>)
    .kind(SERVER)
    ... add tags etc.

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// start the server side and flush instead of finish</span>
oneWayReceive.start().flush();

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// you should not modify this span anymore as it is complete. However,</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// you can create children to represent follow-up work.</span>
next = tracer.newSpan(oneWayReceive.context()).name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"step2"</span>).start();</pre></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_sampling" href="#_sampling"></a> 53。采样</h2></div></div></div><p>可以采用采样来减少收集和报告的过程外数据。如果未对跨度进行采样，则不会增加开销（无操作）。</p><p>采样是一项前期决策，这意味着报告数据的决策是在跟踪的第一个操作中做出的，并且该决策会向下游传播。</p><p>默认情况下，全局采样器将单个速率应用于所有跟踪的操作。
<code class="literal">Tracer.Builder.sampler</code>控制此设置，它默认为跟踪每个请求。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_declarative_sampling" href="#_declarative_sampling"></a> 53.1声明式采样</h2></div></div></div><p>一些应用程序需要根据java方法的类型或注释进行采样。</p><p>大多数用户使用框架拦截器来自动化这种策略。以下示例显示了它如何在内部工作：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// derives a sample rate from an annotation on a java method</span>
DeclarativeSampler&lt;Traced&gt; sampler = DeclarativeSampler.create(Traced::sampleRate);

<em><span class="hl-annotation" style="color: gray">@Around("@annotation(traced)")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Object traceThing(ProceedingJoinPoint pjp, Traced traced) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Throwable {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// When there is no trace in progress, this decides using an annotation</span>
  Sampler decideUsingAnnotation = declarativeSampler.toSampler(traced);
  Tracer tracer = tracer.withSampler(decideUsingAnnotation);

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// This code looks the same as if there was no declarative override</span>
  ScopedSpan span = tracer.startScopedSpan(spanName(pjp));
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> pjp.proceed();
  } <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">catch</span> (RuntimeException | Error e) {
    span.error(e);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throw</span> e;
  } <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> {
    span.finish();
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_custom_sampling" href="#_custom_sampling"></a> 53.2自定义采样</h2></div></div></div><p>根据操作的不同，您可能需要应用不同的策略。例如，您可能不想跟踪对静态资源（例如图像）的请求，或者您想跟踪所有对新API的请求。</p><p>大多数用户使用框架拦截器来自动化这种策略。以下示例显示了它如何在内部工作：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;
<em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Sampler fallback;

Span nextSpan(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Request input) {
  Sampler requestBased = Sampler() {
    <em><span class="hl-annotation" style="color: gray">@Override</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> isSampled(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> traceId) {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (input.url().startsWith(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/experimental"</span>)) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> true;
      } <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (input.url().startsWith(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/static"</span>)) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> false;
      }
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> fallback.isSampled(traceId);
    }
  };
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> tracer.withSampler(requestBased).nextSpan();
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sampling_in_spring_cloud_sleuth" href="#_sampling_in_spring_cloud_sleuth"></a> 53.3在Spring Cloud Sleuth中采样</h2></div></div></div><p>默认情况下，Spring Cloud Sleuth将所有范围设置为不可导出。这意味着跟踪将出现在日志中，但不会出现在任何远程存储中。测试默认值通常就足够了，如果仅使用日志（例如，使用ELK聚合器），则可能只需要它即可。如果您将跨度数据导出到Zipkin，则还有一个<code class="literal">Sampler.ALWAYS_SAMPLE</code>设置导出所有内容， <code class="literal">ProbabilityBasedSampler</code>设置对固定范围的一部分采样。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">ProbabilityBasedSampler</code>是默认值，如果您使用<code class="literal">spring-cloud-sleuth-zipkin</code> 。您可以通过设置配置导出<code class="literal">spring.sleuth.sampler.probability</code> 。传递的值必须是的两倍<code class="literal">0.0</code>至<code class="literal">1.0</code> 。</p></td></tr></tbody></table></div><p>可以通过创建bean定义来安装采样器，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Sampler defaultSampler() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Sampler.ALWAYS_SAMPLE;
}</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>您可以设置HTTP标头<code class="literal">X-B3-Flags</code>至<code class="literal">1</code> ，或者，在进行消息传递时，您可以设置<code class="literal">spanFlags</code>标头<code class="literal">1</code> 。这样做将强制电流跨度可导出，而不管采样决定如何。</p></td></tr></tbody></table></div><p>为了使用限速采样器，请设置<code class="literal">spring.sleuth.sampler.rate</code>属性，以选择每秒钟间隔要接受的跟踪量。最小数字为0，最大数字为2,147,483,647（最大整数）。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_propagation" href="#_propagation"></a> 54。传播</h2></div></div></div><p>需要进行传播以确保源自同一根的活动被收集到同一条迹线中。最常见的传播方法是通过将RPC请求发送到接收它的服务器来从客户端复制跟踪上下文。</p><p>例如，进行下游HTTP调用时，其跟踪上下文被编码为请求标头，并与请求标头一起发送，如下图所示：</p><pre class="screen">   Client Span                                                Server Span
&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;                                       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
&#9474;                  &#9474;                                       &#9474;                  &#9474;
&#9474;   TraceContext   &#9474;           Http Request Headers        &#9474;   TraceContext   &#9474;
&#9474; &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9474;          &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;        &#9474; &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9474;
&#9474; &#9474; TraceId      &#9474; &#9474;          &#9474; X&#9472;B3&#9472;TraceId      &#9474;        &#9474; &#9474; TraceId      &#9474; &#9474;
&#9474; &#9474;              &#9474; &#9474;          &#9474;                   &#9474;        &#9474; &#9474;              &#9474; &#9474;
&#9474; &#9474; ParentSpanId &#9474; &#9474; Extract  &#9474; X&#9472;B3&#9472;ParentSpanId &#9474; Inject &#9474; &#9474; ParentSpanId &#9474; &#9474;
&#9474; &#9474;              &#9500;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&gt;&#9474;                   &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&gt;&#9474;              &#9474; &#9474;
&#9474; &#9474; SpanId       &#9474; &#9474;          &#9474; X&#9472;B3&#9472;SpanId       &#9474;        &#9474; &#9474; SpanId       &#9474; &#9474;
&#9474; &#9474;              &#9474; &#9474;          &#9474;                   &#9474;        &#9474; &#9474;              &#9474; &#9474;
&#9474; &#9474; Sampled      &#9474; &#9474;          &#9474; X&#9472;B3&#9472;Sampled      &#9474;        &#9474; &#9474; Sampled      &#9474; &#9474;
&#9474; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9474;          &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;        &#9474; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9474;
&#9474;                  &#9474;                                       &#9474;                  &#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;                                       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;</pre><p>上面的名称来自<a class="link" href="https://github.com/openzipkin/b3-propagation" target="_top">B3 Propagation</a> ，它内置于Brave，并具有许多语言和框架的实现。</p><p>大多数用户使用框架拦截器来自动化传播。接下来的两个示例显示了这对于客户端和服务器的工作方式。</p><p>以下示例显示了客户端传播如何工作：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracing tracing;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// configure a function that injects a trace context into a request</span>
injector = tracing.propagation().injector(Request.Builder::addHeader);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// before a request is sent, add the current span's context to it</span>
injector.inject(span.context(), request);</pre><p>以下示例显示了服务器端传播的工作方式：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracing tracing;
<em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// configure a function that extracts the trace context from a request</span>
extractor = tracing.propagation().extractor(Request::getHeader);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when a server receives a request, it joins or starts a new trace</span>
span = tracer.nextSpan(extractor.extract(request));</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_propagating_extra_fields" href="#_propagating_extra_fields"></a> 54.1传播额外的字段</h2></div></div></div><p>有时您需要传播其他字段，例如请求ID或备用跟踪上下文。例如，如果您处于Cloud Foundry环境中，则可能要传递请求ID，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when you initialize the builder, define the extra field you want to propagate</span>
Tracing.newBuilder().propagationFactory(
  ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-vcap-request-id"</span>)
);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// later, you can tag that request ID or use it in log correlation</span>
requestId = ExtraFieldPropagation.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-vcap-request-id"</span>);</pre><p>您可能还需要传播未使用的跟踪上下文。例如，您可能处于Amazon Web Services环境中，但没有向X-Ray报告数据。为确保X射线可以正确共存，请传递其跟踪标头，如以下示例所示：</p><pre class="programlisting">tracingBuilder.propagationFactory(
  ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-amzn-trace-id"</span>)
);</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>在Spring Cloud Sleuth中，跟踪构建器的所有元素<code class="literal">Tracing.newBuilder()</code>被定义为bean。因此，如果您想通过自定义<code class="literal">PropagationFactory</code> ，您只要创建一个这种类型的bean就足够了，我们将在<code class="literal">Tracing</code> bean 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="prefixed-fields" href="#prefixed-fields"></a> 54.1.1前缀字段</h3></div></div></div><p>如果它们遵循通用模式，则还可以在字段前面加上前缀。以下示例说明了如何传播<code class="literal">x-vcap-request-id</code>原样发送该字段，但发送<code class="literal">country-code</code>和<code class="literal">user-id</code>电线上的字段为<code class="literal">x-baggage-country-code</code>和<code class="literal">x-baggage-user-id</code> ， 分别：</p><pre class="programlisting">Tracing.newBuilder().propagationFactory(
  ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)
                       .addField(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-vcap-request-id"</span>)
                       .addPrefixedFields(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-baggage-"</span>, Arrays.asList(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"country-code"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user-id"</span>))
                       .build()
);</pre><p>以后，您可以调用以下代码来影响当前跟踪上下文的国家/地区代码：</p><pre class="programlisting">ExtraFieldPropagation.set(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-country-code"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FO"</span>);
String countryCode = ExtraFieldPropagation.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-country-code"</span>);</pre><p>或者，如果您有对跟踪上下文的引用，则可以显式使用它，如以下示例所示：</p><pre class="programlisting">ExtraFieldPropagation.set(span.context(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-country-code"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FO"</span>);
String countryCode = ExtraFieldPropagation.get(span.context(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"x-country-code"</span>);</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>与以前版本的Sleuth的不同之处在于，使用Brave，您必须传递行李钥匙列表。有两个属性可以实现此目的。随着<code class="literal">spring.sleuth.baggage-keys</code> ，您可以设置以开头的键<code class="literal">baggage-</code>用于HTTP调用和<code class="literal">baggage_</code>用于消息传递。您也可以使用<code class="literal">spring.sleuth.propagation-keys</code>属性以传递前缀列表的前缀，该列表被列入白名单而没有任何前缀。请注意，没有<code class="literal">x-</code>在标题键前面。</p></td></tr></tbody></table></div><p>为了自动将行李值设置为Slf4j的MDC，您必须设置<code class="literal">spring.sleuth.log.slf4j.whitelisted-mdc-keys</code>属性，其中包含列入白名单的行李和传播密钥的列表。例如<code class="literal">spring.sleuth.log.slf4j.whitelisted-mdc-keys=foo</code>将设置<code class="literal">foo</code>放进MDC。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>请记住，将条目添加到MDC可能会大大降低应用程序的性能！</p></td></tr></tbody></table></div><p>如果要将行李条目添加为标签，则可以通过行李条目搜索跨度，可以将值设置为<code class="literal">spring.sleuth.propagation.tag.whitelisted-keys</code>以及列入白名单的行李钥匙清单。要禁用该功能，您必须通过<code class="literal">spring.sleuth.propagation.tag.enabled=false</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_extracting_a_propagated_context" href="#_extracting_a_propagated_context"></a> 54.1.2提取传播的上下文</h3></div></div></div><p>的<code class="literal">TraceContext.Extractor<C></code>从传入的请求或消息中读取跟踪标识符和采样状态。载体通常是一个请求对象或标头。</p><p>此实用程序用于标准仪器（例如<code class="literal">HttpServerHandler</code> ），但也可用于自定义RPC或消息传递代码。</p><p><code class="literal">TraceContextOrSamplingFlags</code>通常仅与<code class="literal">Tracer.nextSpan(extracted)</code> ，除非您要在客户端和服务器之间共享范围ID。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_sharing_span_ids_between_client_and_server" href="#_sharing_span_ids_between_client_and_server"></a> 54.1.3在客户端和服务器之间共享范围ID</h3></div></div></div><p>正常的检测模式是创建一个跨度，该跨度代表RPC的服务器端。 <code class="literal">Extractor.extract</code>当应用于传入的客户端请求时，可能会返回完整的跟踪上下文。 <code class="literal">Tracer.joinSpan</code>尝试继续此跟踪，如果支持，则使用相同的跨度ID，否则，创建一个子跨度。当跨度ID被共享时，报告的数据包括这样的标记。</p><p>下图显示了B3传播的示例：</p><pre class="screen">                              &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;      &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
 Incoming Headers             &#9474;   TraceContext    &#9474;      &#9474;   TraceContext    &#9474;
&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;(extract)&#9474; &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9474;(join)&#9474; &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9474;
&#9474; X&#9472;B3-TraceId      &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; TraceId      &#9474; &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; TraceId      &#9474; &#9474;
&#9474;                   &#9474;         &#9474; &#9474;               &#9474; &#9474;      &#9474; &#9474;               &#9474; &#9474;
&#9474; X&#9472;B3-ParentSpanId &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; ParentSpanId &#9474; &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; ParentSpanId &#9474; &#9474;
&#9474;                   &#9474;         &#9474; &#9474;               &#9474; &#9474;      &#9474; &#9474;               &#9474; &#9474;
&#9474; X&#9472;B3-SpanId       &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; SpanId       &#9474; &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; SpanId       &#9474; &#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;         &#9474; &#9474;               &#9474; &#9474;      &#9474; &#9474;               &#9474; &#9474;
                              &#9474; &#9474;               &#9474; &#9474;      &#9474; &#9474;  Shared: true &#9474; &#9474;
                              &#9474; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9474;      &#9474; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9474;
                              &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;      &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;</pre><p>某些传播系统仅转发父范围ID，在<code class="literal">Propagation.Factory.supportsJoin() == false</code> 。在这种情况下，始终提供新的跨度ID，而传入上下文确定父ID。</p><p>下图显示了AWS传播的示例：</p><pre class="screen">                              &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;      &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;
 x-amzn-trace-id              &#9474;   TraceContext    &#9474;      &#9474;   TraceContext    &#9474;
&#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;(extract)&#9474; &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9474;(join)&#9474; &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488; &#9474;
&#9474; Root              &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; TraceId      &#9474; &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; TraceId      &#9474; &#9474;
&#9474;                   &#9474;         &#9474; &#9474;               &#9474; &#9474;      &#9474; &#9474;               &#9474; &#9474;
&#9474; Parent            &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; SpanId       &#9474; &#9474;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9532;&gt; ParentSpanId &#9474; &#9474;
&#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;         &#9474; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9474;      &#9474; &#9474;               &#9474; &#9474;
                              &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;      &#9474; &#9474;  SpanId: New  &#9474; &#9474;
                                                         &#9474; &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496; &#9474;
                                                         &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;</pre><p>注意：某些跨度报告程序不支持共享跨度ID。例如，如果您设置<code class="literal">Tracing.Builder.spanReporter(amazonXrayOrGoogleStackdrive)</code> ，您应该通过设置禁用加入<code class="literal">Tracing.Builder.supportsJoin(false)</code> 。这样做会迫使一个新孩子跨过<code class="literal">Tracer.joinSpan()</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_implementing_propagation" href="#_implementing_propagation"></a> 54.1.4实施传播</h3></div></div></div><p><code class="literal">TraceContext.Extractor<C></code>由一个<code class="literal">Propagation.Factory</code>插入。在内部，此代码创建联合类型， <code class="literal">TraceContextOrSamplingFlags</code> ，其中之一：* <code class="literal">TraceContext</code>如果存在跟踪和跨度ID。* <code class="literal">TraceIdContext</code>如果存在跟踪ID，但不存在跨度ID。* <code class="literal">SamplingFlags</code>如果不存在标识符。</p><p>一些<code class="literal">Propagation</code>实现从提取（例如，读取传入的标头）到注入（例如，写入传出的标头）的角度携带额外的数据。例如，它可能带有一个请求ID。当实现中有多余的数据时，它们将按以下方式处理：*如果<code class="literal">TraceContext</code>被提取，添加额外的数据为<code class="literal">TraceContext.extra()</code> 。*否则，将其添加为<code class="literal">TraceContextOrSamplingFlags.extra()</code> ， 哪一个<code class="literal">Tracer.nextSpan</code>处理。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_current_tracing_component" href="#_current_tracing_component"></a> 55。当前跟踪组件</h2></div></div></div><p>勇敢支持<span class="quote">“ <span class="quote">当前跟踪组件</span> ”</span>的概念，当你有没有其他的方式来获得一个参考其只应使用。这样做是针对JDBC连接的，因为它们通常在跟踪组件之前进行初始化。</p><p>可以通过以下方式获得实例化的最新跟踪组件： <code class="literal">Tracing.current()</code> 。您也可以使用<code class="literal">Tracing.currentTracer()</code>仅获取示踪剂。如果使用这两种方法之一，请不要缓存结果。而是在每次需要它们时查找它们。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_current_span" href="#_current_span"></a> 56。当前跨度</h2></div></div></div><p>Brave支持代表飞行中操作的<span class="quote">“ <span class="quote">当前跨度</span> ”</span>概念。您可以使用<code class="literal">Tracer.currentSpan()</code>将自定义标签添加到跨度和<code class="literal">Tracer.nextSpan()</code>在飞行中创造一个孩子</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>在Sleuth中，您可以自动连接<code class="literal">Tracer</code> Bean通过检索当前范围<code class="literal">tracer.currentSpan()</code>方法。要检索当前上下文，只需调用<code class="literal">tracer.currentSpan().context()</code> 。要以字符串形式获取当前跟踪ID，可以使用<code class="literal">traceIdString()</code>像这样的方法： <code class="literal">tracer.currentSpan().context().traceIdString()</code> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_setting_a_span_in_scope_manually" href="#_setting_a_span_in_scope_manually"></a> 56.1手动设置范围</h2></div></div></div><p>在编写新的检测时，将您创建的跨度作为当前跨度放置在示波器中很重要。这样做不仅使用户可以使用<code class="literal">Tracer.currentSpan()</code> ，但它也允许自定义设置（例如SLF4J MDC）查看当前的跟踪ID。</p><p><code class="literal">Tracer.withSpanInScope(Span)</code>通过使用try-with-resources惯用语可以简化此过程，并且使用起来最方便。每当可能调用外部代码（例如进行拦截器或其他操作）时，请将范围放在范围内，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (SpanInScope ws = tracer.withSpanInScope(span)) {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> inboundRequest.invoke();
} <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// note the scope is independent of the span</span>
  span.finish();
}</pre><p>在极端情况下，您可能需要暂时清除当前范围（例如，启动不应该与当前请求关联的任务）。为此，请将null传递给<code class="literal">withSpanInScope</code> ，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> Tracer tracer;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (SpanInScope cleared = tracer.withSpanInScope(null)) {
  startBackgroundThread();
}</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_instrumentation" href="#_instrumentation"></a> 57。仪器仪表</h2></div></div></div><p>Spring Cloud Sleuth会自动检测所有Spring应用程序，因此您无需执行任何操作即可激活它。通过根据可用的堆栈使用多种技术来添加检测。例如，对于Servlet Web应用程序，我们使用<code class="literal">Filter</code> ，对于Spring Integration，我们使用<code class="literal">ChannelInterceptors</code> 。</p><p>您可以自定义跨度标签中使用的键。为了限制范围数据的数量，默认情况下，HTTP请求仅使用少量元数据（例如状态码，主机和URL）进行标记。您可以通过配置添加请求标头<code class="literal">spring.sleuth.keys.http.headers</code> （标题名称列表）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>仅在存在以下情况时才收集和导出标签<code class="literal">Sampler</code>允许它。默认情况下，没有这样的<code class="literal">Sampler</code> ，以确保在不进行任何配置的情况下不存在意外收集过多数据的危险）。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_span_lifecycle" href="#_span_lifecycle"></a> 58。跨度生命周期</h2></div></div></div><p>您可以通过以下方式在Span上执行以下操作： <code class="literal">brave.Tracer</code> ：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="#creating-and-finishing-spans" title="58.1创建和整理跨度">start</a> ：开始跨度时，将分配其名称并记录开始时间戳。</li><li class="listitem"><a class="link" href="#creating-and-finishing-spans" title="58.1创建和整理跨度">close</a> ：跨度已完成（记录了跨度的结束时间），并且，如果对跨度进行了采样，则可以进行收集（例如，收集到Zipkin）。</li><li class="listitem"><a class="link" href="#continuing-spans" title="58.2连续跨度">继续</a> ：创建跨度的一个新实例。它是继续的副本。</li><li class="listitem"><a class="link" href="#continuing-spans" title="58.2连续跨度">detach</a> ：跨度不会停止或关闭。它只会从当前线程中删除。</li><li class="listitem"><a class="link" href="#creating-spans-with-explicit-parent" title="58.3使用显式父级创建跨度">使用显式父项创建</a> ：您可以创建一个新的跨度并为其设置一个显式父项。</li></ul></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Sleuth创建一个实例<code class="literal">Tracer</code>为了你。为了使用它，您可以对其进行自动接线。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="creating-and-finishing-spans" href="#creating-and-finishing-spans"></a> 58.1创建和整理跨度</h2></div></div></div><p>您可以使用<code class="literal">Tracer</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Start a span. If there was a span present in this thread it will become</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the `newSpan`'s parent.</span>
Span newSpan = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.nextSpan().name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"calculateTax"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (Tracer.SpanInScope ws = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.withSpanInScope(newSpan.start())) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You can tag a span</span>
	newSpan.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"taxValue"</span>, taxValue);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You can log an event on a span</span>
	newSpan.annotate(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"taxCalculated"</span>);
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Once done remember to finish the span. This will allow collecting</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the span to send it to Zipkin</span>
	newSpan.finish();
}</pre><p>在前面的示例中，我们可以看到如何创建跨度的新实例。如果此线程中已经有一个跨度，它将成为新跨度的父级。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>创建跨度后，请始终保持清洁。另外，请始终完成要发送给Zipkin的所有跨度。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您的跨度包含的名称大于50个字符，则该名称将被截断为50个字符。您的姓名必须明确明确。知名人士会导致延迟问题，有时甚至会引发例外情况。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="continuing-spans" href="#continuing-spans"></a> 58.2连续跨度</h2></div></div></div><p>有时，您不想创建一个新跨度，但想继续一个跨度。这种情况的示例如下：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>AOP</strong></span> ：如果在到达方面之前已经创建了一个跨度，则您可能不想创建新的跨度。</li><li class="listitem"><span class="strong"><strong>Hystrix</strong></span> ：执行Hystrix命令很可能是当前处理的逻辑部分。实际上，它仅仅是技术实现细节，您不一定要在跟踪中将其反映为一个单独的实体。</li></ul></div><p>要继续跨度，您可以使用<code class="literal">brave.Tracer</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// let's assume that we're in a thread Y and we've received</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the `initialSpan` from thread X</span>
Span continuedSpan = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.toSpan(newSpan.context());
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You can tag a span</span>
	continuedSpan.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"taxValue"</span>, taxValue);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You can log an event on a span</span>
	continuedSpan.annotate(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"taxCalculated"</span>);
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Once done remember to flush the span. That means that</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// it will get reported but the span itself is not yet finished</span>
	continuedSpan.flush();
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="creating-spans-with-explicit-parent" href="#creating-spans-with-explicit-parent"></a> 58.3使用显式父级创建跨度</h2></div></div></div><p>您可能要开始一个新的跨度并提供该跨度的显式父项。假定范围的父级在一个线程中，而您想在另一个线程中开始一个新的范围。在《勇敢传说》中，每当您致电<code class="literal">nextSpan()</code> ，它会参考当前范围的跨度创建一个跨度。您可以将范围放在范围中，然后调用<code class="literal">nextSpan()</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// let's assume that we're in a thread Y and we've received</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the `initialSpan` from thread X. `initialSpan` will be the parent</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// of the `newSpan`</span>
Span newSpan = null;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (Tracer.SpanInScope ws = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.withSpanInScope(initialSpan)) {
	newSpan = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.nextSpan().name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"calculateCommission"</span>);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You can tag a span</span>
	newSpan.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"commissionValue"</span>, commissionValue);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You can log an event on a span</span>
	newSpan.annotate(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"commissionCalculated"</span>);
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">finally</span> {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Once done remember to finish the span. This will allow collecting</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the span to send it to Zipkin. The tags and events set on the</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// newSpan will not be present on the parent</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (newSpan != null) {
		newSpan.finish();
	}
}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>创建这样的跨度后，必须完成它。否则，不会报告（例如，向Zipkin报告）。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_naming_spans" href="#_naming_spans"></a> 59。命名范围</h2></div></div></div><p>选择一个跨度名称不是一件容易的事。跨度名称应描述一个操作名称。该名称应为低基数，因此不应包含标识符。</p><p>由于正在进行很多检测，因此一些跨度名称是人为的：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">controller-method-name</code>由控制器接收的方法名称为<code class="literal">controllerMethodName</code></li><li class="listitem"><code class="literal">async</code>使用包装完成的异步操作<code class="literal">Callable</code>和<code class="literal">Runnable</code>接口。</li><li class="listitem">用注释的方法<code class="literal">@Scheduled</code>返回类的简单名称。</li></ul></div><p>幸运的是，对于异步处理，您可以提供显式命名。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spanname_annotation" href="#_spanname_annotation"></a> 59.1 <code class="literal">@SpanName</code>注解</h2></div></div></div><p>您可以使用<code class="literal">@SpanName</code>注释，如以下示例所示：</p><pre class="programlisting">	<em><span class="hl-annotation" style="color: gray">@SpanName("calculateTax")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TaxCountingRunnable <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> Runnable {

		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> run() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// perform logic</span>
		}

	}

}</pre><p>在这种情况下，按以下方式处理时，将跨度命名为<code class="literal">calculateTax</code> ：</p><pre class="programlisting">Runnable runnable = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TraceRunnable(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracing, spanNamer,
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TaxCountingRunnable());
Future&lt;?&gt; future = executorService.submit(runnable);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ... some additional logic ...</span>
future.get();</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_tostring_method" href="#_tostring_method"></a> 59.2 <code class="literal">toString()</code>方法</h2></div></div></div><p>为以下情况创建单独的类非常罕见<code class="literal">Runnable</code>要么<code class="literal">Callable</code> 。通常，创建一个匿名类的实例。您不能注释此类。为了克服该限制，如果没有<code class="literal">@SpanName</code>注释存在，我们检查该类是否具有自定义实现<code class="literal">toString()</code>方法。</p><p>运行这样的代码将导致创建一个名为<code class="literal">calculateTax</code> ，如以下示例所示：</p><pre class="programlisting">Runnable runnable = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TraceRunnable(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracing, spanNamer, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Runnable() {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> run() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// perform logic</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String toString() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"calculateTax"</span>;
	}
});
Future&lt;?&gt; future = executorService.submit(runnable);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ... some additional logic ...</span>
future.get();</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_managing_spans_with_annotations" href="#_managing_spans_with_annotations"></a> 60使用注释管理跨度</h2></div></div></div><p>您可以使用各种注释来管理跨度。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rationale" href="#_rationale"></a> 60.1基础</h2></div></div></div><p>使用注释管理跨区有很多充分的理由，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">与API无关的方法可以与跨度进行协作。使用注释使用户可以添加到跨度，而跨度api不依赖库。这样，Sleuth可以更改其核心API，以减少对用户代码的影响。</li><li class="listitem">基本跨度操作减少了表面积。如果没有此功能，则必须使用span api，该api的生命周期命令可能无法正确使用。通过仅公开作用域，标记和日志功能，您可以进行协作而不会意外中断跨度生命周期。</li><li class="listitem">与运行时生成的代码协作。使用诸如Spring Data和Feign之类的库，可以在运行时生成接口的实现。因此，对象的跨度包裹是乏味的。现在，您可以在接口和这些接口的参数上提供注释。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_creating_new_spans" href="#_creating_new_spans"></a> 60.2创建新的跨度</h2></div></div></div><p>如果您不想手动创建本地范围，则可以使用<code class="literal">@NewSpan</code>注解。另外，我们提供<code class="literal">@SpanTag</code>注释以自动方式添加标签。</p><p>现在我们可以考虑一些用法示例。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@NewSpan</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> testMethod();</pre><p>在不带任何参数的情况下对方法进行注释会导致创建一个新的跨度，该跨度的名称等于带注释的方法名称。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@NewSpan("customNameOnTestMethod4")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> testMethod4();</pre><p>如果您在注释中提供值（直接或通过设置<code class="literal">name</code>参数），创建的跨度将提供的值作为名称。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// method declaration</span>
<em><span class="hl-annotation" style="color: gray">@NewSpan(name = "customNameOnTestMethod5")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> testMethod5(<em><span class="hl-annotation" style="color: gray">@SpanTag("testTag")</span></em> String param);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and method execution</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.testBean.testMethod5(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"test"</span>);</pre><p>您可以同时使用名称和标签。让我们专注于后者。在这种情况下，带注释的方法的参数运行时值的值将成为标签的值。在我们的示例中，标记键为<code class="literal">testTag</code> ，而标记值为<code class="literal">test</code> 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@NewSpan(name = "customNameOnTestMethod3")</span></em>
<em><span class="hl-annotation" style="color: gray">@Override</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> testMethod3() {
}</pre><p>您可以将<code class="literal">@NewSpan</code>在类和接口上的注释。如果您覆盖接口的方法并为该接口提供不同的值<code class="literal">@NewSpan</code>注释，最具体的一个获胜（在这种情况下<code class="literal">customNameOnTestMethod3</code>设置）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_continuing_spans" href="#_continuing_spans"></a> 60.3连续跨度</h2></div></div></div><p>如果要将标签和注释添加到现有范围，则可以使用<code class="literal">@ContinueSpan</code>注释，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// method declaration</span>
<em><span class="hl-annotation" style="color: gray">@ContinueSpan(log = "testMethod11")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> testMethod11(<em><span class="hl-annotation" style="color: gray">@SpanTag("testTag11")</span></em> String param);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// method execution</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.testBean.testMethod11(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"test"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.testBean.testMethod13();</pre><p>（请注意，与<code class="literal">@NewSpan</code>注释，您也可以使用<code class="literal">log</code>参数。）</p><p>这样，跨度将继续，并且：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">日志条目名为<code class="literal">testMethod11.before</code>和<code class="literal">testMethod11.after</code>被创建。</li><li class="listitem">如果引发异常，则名为<code class="literal">testMethod11.afterFailure</code>也被创建。</li><li class="listitem">标记为<code class="literal">testTag11</code>和值为<code class="literal">test</code>被建造。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_advanced_tag_setting" href="#_advanced_tag_setting"></a> 60.4高级标签设置</h2></div></div></div><p>有3种不同的方法可以将标签添加到跨度。所有这些都由<code class="literal">SpanTag</code>注解。优先级如下：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">尝试一下<code class="literal">TagValueResolver</code>类型和提供的名称。</li><li class="listitem">如果未提供Bean名称，请尝试评估表达式。我们搜索一个<code class="literal">TagValueExpressionResolver</code> bean 。默认实现使用SPEL表达式解析。
<span class="strong"><strong>重要事项</strong></span>您只能从SPEL表达式中引用属性。由于安全限制，不允许执行方法。</li><li class="listitem">如果我们找不到任何要求值的表达式，则返回<code class="literal">toString()</code>参数的值。</li></ol></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_extractor" href="#_custom_extractor"></a> 60.4.1定制提取器</h3></div></div></div><p>以下方法的标记值是通过实现<code class="literal">TagValueResolver</code>接口。它的类名必须作为<code class="literal">resolver</code>属性。</p><p>考虑以下带注释的方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@NewSpan</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> getAnnotationForTagValueResolver(
		<em><span class="hl-annotation" style="color: gray">@SpanTag(key = "test", resolver = TagValueResolver.class)</span></em> String test) {
}</pre><p>现在进一步考虑以下<code class="literal">TagValueResolver</code> bean实现：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean(name = "myCustomTagValueResolver")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> TagValueResolver tagValueResolver() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> parameter -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Value from myCustomTagValueResolver"</span>;
}</pre><p>前面的两个示例导致将标签值设置为等于<code class="literal">Value from myCustomTagValueResolver</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_resolving_expressions_for_a_value" href="#_resolving_expressions_for_a_value"></a> 60.4.2解析一个值的表达式</h3></div></div></div><p>考虑以下带注释的方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@NewSpan</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> getAnnotationForTagValueExpression(
		<em><span class="hl-annotation" style="color: gray">@SpanTag(key = "test", expression = "'hello' + ' characters'")</span></em> String test) {
}</pre><p>没有自定义实现<code class="literal">TagValueExpressionResolver</code>导致对SPEL表达式进行评估，并获得一个值为的标签<code class="literal">4 characters</code>在跨度上设置。如果要使用其他表达式解析机制，则可以创建自己的bean实现。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_the_tostring_method" href="#_using_the_tostring_method"></a> 60.4.3使用<code class="literal">toString()</code>方法</h3></div></div></div><p>考虑以下带注释的方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@NewSpan</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> getAnnotationForArgumentToString(<em><span class="hl-annotation" style="color: gray">@SpanTag("test")</span></em> Long param) {
}</pre><p>以值运行前面的方法<code class="literal">15</code>导致设置一个字符串值为<code class="literal">"15"</code> 。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_customizations" href="#_customizations"></a> 61。客制化</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizers" href="#_customizers"></a> 61.1定制器</h2></div></div></div><p>使用Brave 5.7，您可以使用多种选项为项目提供定制程序。勇敢与</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">TracingCustomizer</code> -允许配置插件协作构建实例<code class="literal">Tracing</code> 。</li><li class="listitem"><code class="literal">CurrentTraceContextCustomizer</code> -允许配置插件协作构建实例<code class="literal">CurrentTraceContext</code> 。</li><li class="listitem"><code class="literal">ExtraFieldCustomizer</code> -允许配置插件协作构建实例<code class="literal">ExtraFieldPropagation.Factory</code> 。</li></ul></div><p>Sleuth将搜索那些类型的bean并自动应用定制。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_http" href="#_http"></a> 61.2 HTTP</h2></div></div></div><p>如果需要定制与HTTP相关范围的客户端/服务器解析，只需注册一个类型为bean的bean <code class="literal">brave.http.HttpClientParser</code>要么<code class="literal">brave.http.HttpServerParser</code> 。如果需要客户机/服务器采样，只需注册一个类型为的bean <code class="literal">brave.sampler.SamplerFunction<HttpRequest></code>并命名 bean <code class="literal">sleuthHttpClientSampler</code>用于客户采样器和<code class="literal">sleuthHttpServerSampler</code>用于服务器采样器。</p><p>为了您的方便<code class="literal">@HttpClientSampler</code>和<code class="literal">@HttpServerSampler</code>批注可用于注入适当的bean或通过其静态String引用bean名称<code class="literal">NAME</code>领域。</p><p>查阅Brave的代码，以查看有关如何制作基于路径的采样器的示例<a class="link" href="https://github.com/openzipkin/brave/tree/master/instrumentation/http#sampling-policy" target="_top">https://github.com/openzipkin/brave/tree/master/instrumentation/http#sampling-policy</a></p><p>如果您要完全重写<code class="literal">HttpTracing</code> bean 你可以用<code class="literal">SkipPatternProvider</code>检索URL的界面<code class="literal">Pattern</code>对于不应采样的跨度。您可以在下面看到使用示例<code class="literal">SkipPatternProvider</code>在服务器端， <code class="literal">Sampler<HttpRequest></code> 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {
  <em><span class="hl-annotation" style="color: gray">@Bean(name = HttpServerSampler.NAME)</span></em>
  SamplerFunction&lt;HttpRequest&gt; myHttpSampler(SkipPatternProvider provider) {
  	Pattern pattern = provider.skipPattern();
  	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> request -&gt; {
  		String url = request.path();
  		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> shouldSkip = pattern.matcher(url).matches();
  		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (shouldSkip) {
  			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> false;
  		}
  		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
  	};
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_tracingfilter" href="#_tracingfilter"></a> 61.3<code class="literal">TracingFilter</code></h2></div></div></div><p>您还可以修改<code class="literal">TracingFilter</code> ，它是负责处理输入的HTTP请求并基于HTTP响应添加标签的组件。您可以通过注册自己的实例来自定义标签或修改响应标题。 <code class="literal">TracingFilter</code> bean 。</p><p>在以下示例中，我们注册了<code class="literal">TracingFilter</code> bean ，添加<code class="literal">ZIPKIN-TRACE-ID</code>响应标头，其中包含当前Span的跟踪ID，并添加带有标签的标签<code class="literal">custom</code>和一个值<code class="literal">tag</code>到跨度。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<em><span class="hl-annotation" style="color: gray">@Order(TraceWebServletAutoConfiguration.TRACING_FILTER_ORDER + 1)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> GenericFilterBean {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Tracer tracer;

	MyFilter(Tracer tracer) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer = tracer;
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException, ServletException {
		Span currentSpan = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracer.currentSpan();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (currentSpan == null) {
			chain.doFilter(request, response);
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>;
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// for readability we're returning trace id in a hex form</span>
		((HttpServletResponse) response).addHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"ZIPKIN-TRACE-ID"</span>,
				currentSpan.context().traceIdString());
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// we can also add some custom tags</span>
		currentSpan.tag(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"custom"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"tag"</span>);
		chain.doFilter(request, response);
	}

}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rpc" href="#_rpc"></a> 61.4 RPC</h2></div></div></div><p>Sleuth自动配置<code class="literal">RpcTracing</code>用作gRPC或Dubbo等RPC工具的基础的bean。</p><p>如果需要自定义RPC跟踪的客户端/服务器采样，只需注册一个类型为bean的bean <code class="literal">brave.sampler.SamplerFunction<RpcRequest></code>并命名 bean <code class="literal">sleuthRpcClientSampler</code>用于客户采样器和<code class="literal">sleuthRpcServerSampler</code>用于服务器采样器。</p><p>为了您的方便<code class="literal">@RpcClientSampler</code>和<code class="literal">@RpcServerSampler</code>批注可用于注入适当的bean或通过其静态String引用bean名称<code class="literal">NAME</code>领域。</p><p>例如这是一个每秒跟踪100个“ GetUserToken”服务器请求的采样器。这不会启动对运行状况检查服务的请求的新跟踪。其他请求将使用全局采样配置。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {
  <em><span class="hl-annotation" style="color: gray">@Bean(name = RpcServerSampler.NAME)</span></em>
  SamplerFunction&lt;RpcRequest&gt; myRpcSampler() {
  	Matcher&lt;RpcRequest&gt; userAuth = and(serviceEquals(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"users.UserService"</span>),
  			methodEquals(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"GetUserToken"</span>));
  	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RpcRuleSampler.newBuilder()
  			.putRule(serviceEquals(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"grpc.health.v1.Health"</span>), Sampler.NEVER_SAMPLE)
  			.putRule(userAuth, RateLimitingSampler.create(<span class="hl-number">100</span>)).build();
  }
}</pre><p>有关更多信息，请参见<a class="link" href="https://github.com/openzipkin/brave/tree/master/instrumentation/rpc#sampling-policy" target="_top">https://github.com/openzipkin/brave/tree/master/instrumentation/rpc#sampling-policy</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_custom_service_name" href="#_custom_service_name"></a> 61.5定制服务名称</h2></div></div></div><p>默认情况下，Sleuth假定，当您向Zipkin发送跨度时，您希望跨度的服务名称等于<code class="literal">spring.application.name</code>属性。但是，并非总是如此。在某些情况下，您想为来自应用程序的所有范围显式提供不同的服务名称。为此，您可以将以下属性传递给应用程序以覆盖该值（该示例适用于名为<code class="literal">myService</code> ）：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.zipkin.service.name</span>: myService</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customization_of_reported_spans" href="#_customization_of_reported_spans"></a> 61.6报告跨度的定制</h2></div></div></div><p>在报告跨度之前（例如，向Zipkin报告），您可能需要以某种方式修改该跨度。您可以使用<code class="literal">FinishedSpanHandler</code>接口。</p><p>在Sleuth中，我们生成具有固定名称的跨度。一些用户希望根据标签的值来修改名称。您可以实施<code class="literal">FinishedSpanHandler</code>更改名称的界面。</p><p>以下示例说明如何注册两个实现的bean <code class="literal">FinishedSpanHandler</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
FinishedSpanHandler handlerOne() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FinishedSpanHandler() {
		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> handle(TraceContext traceContext, MutableSpan span) {
			span.name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> true; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// keep this span</span>
		}
	};
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
FinishedSpanHandler handlerTwo() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FinishedSpanHandler() {
		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> handle(TraceContext traceContext, MutableSpan span) {
			span.name(span.name() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" bar"</span>);
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> true; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// keep this span</span>
		}
	};
}</pre><p>前面的示例导致将报告的跨度的名称更改为<code class="literal">foo bar</code> ，直到它被报告（例如，Zipkin）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_host_locator" href="#_host_locator"></a> 61.7主机定位器</h2></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本节是关于通过服务发现定义<span class="strong"><strong>主机</strong></span> 。这是<span class="strong"><strong>不是</strong></span>通过服务发现找到基普金。</p></td></tr></tbody></table></div><p>要定义与特定跨度相对应的主机，我们需要解析主机名和端口。默认方法是从服务器属性中获取这些值。如果未设置，则尝试从网络接口检索主机名。</p><p>如果启用了发现客户端，并且希望从服务注册表中的已注册实例中检索主机地址，则必须设置<code class="literal">spring.zipkin.locator.discovery.enabled</code>属性（适用于基于HTTP和基于流的跨度报告），如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.zipkin.locator.discovery.enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_sending_spans_to_zipkin" href="#_sending_spans_to_zipkin"></a> 62。发送跨区到Zipkin</h2></div></div></div><p>默认情况下，如果您添加<code class="literal">spring-cloud-starter-zipkin</code>作为对项目的依赖项，当跨度关闭时，它将通过HTTP发送到Zipkin。通信是异步的。您可以通过设置网址来配置网址<code class="literal">spring.zipkin.baseUrl</code>属性，如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.zipkin.baseUrl</span>: https://<span class="hl-number">192.168</span>.<span class="hl-number">99.100</span>:<span class="hl-number">9411</span>/</pre><p>如果要通过服务发现来找到Zipkin，可以在URL内传递Zipkin的服务ID，如以下示例所示： <code class="literal">zipkinserver</code>服务编号：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.zipkin.baseUrl</span>: http://zipkinserver/</pre><p>要禁用此功能，只需设置<code class="literal">spring.zipkin.discoveryClientEnabled</code>为`false。</p><p>启用发现客户端功能后，Sleuth会使用<code class="literal">LoadBalancerClient</code>查找Zipkin服务器的URL。这意味着您可以例如通过功能区来设置负载平衡配置。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">zipkinserver</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ribbon</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    ListOfServers</span>: host1,host2</pre><p>如果您在类路径中同时使用了web，rabbit或kafka，则可能需要选择将跨度发送到zipkin的方法。为此，请设置<code class="literal">web</code> ， <code class="literal">rabbit</code> ， 要么<code class="literal">kafka</code>到<code class="literal">spring.zipkin.sender.type</code>属性。以下示例显示了如何设置发件人类型<code class="literal">web</code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.zipkin.sender.type</span>: web</pre><p>自定义<code class="literal">RestTemplate</code>通过HTTP发送跨度到Zipkin，您可以注册<code class="literal">ZipkinRestTemplateCustomizer</code> bean 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyConfig {
	<em><span class="hl-annotation" style="color: gray">@Bean</span></em> ZipkinRestTemplateCustomizer myCustomizer() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ZipkinRestTemplateCustomizer() {
			<em><span class="hl-annotation" style="color: gray">@Override</span></em>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> customize(RestTemplate restTemplate) {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// customize the RestTemplate</span>
			}
		};
	}
}</pre><p>但是，如果您想控制创建<code class="literal">RestTemplate</code>对象，则必须创建一个<code class="literal">zipkin2.reporter.Sender</code>类型。</p><pre class="programlisting">	<em><span class="hl-annotation" style="color: gray">@Bean</span></em> Sender myRestTemplateSender(ZipkinProperties zipkin,
			ZipkinRestTemplateCustomizer zipkinRestTemplateCustomizer) {
		RestTemplate restTemplate = mySuperCustomRestTemplate();
		zipkinRestTemplateCustomizer.customize(restTemplate);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> myCustomSender(zipkin, restTemplate);
	}</pre></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_zipkin_stream_span_consumer" href="#_zipkin_stream_span_consumer"></a> 63。Zipkin流跨度消费者</h2></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>我们建议使用Zipkin的本机支持进行基于消息的跨度发送。从Edgware版本开始，不建议使用Zipkin Stream服务器。在Finchley版本中，将其删除。</p></td></tr></tbody></table></div><p>如果出于某种原因需要创建不赞成使用的Stream Zipkin服务器，请参阅<a class="link" href="https://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi__span_data_as_messages.html#_zipkin_consumer" target="_top">Dalston文档</a> 。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_integrations" href="#_integrations"></a> 64。整合方式</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_opentracing" href="#_opentracing"></a> 64.1 OpenTracing</h2></div></div></div><p>Spring Cloud Sleuth与<a class="link" href="https://opentracing.io/" target="_top">OpenTracing</a>兼容。如果您在类路径上有OpenTracing，我们会自动注册OpenTracing <code class="literal">Tracer</code> bean 。如果您要禁用此功能，请设置<code class="literal">spring.sleuth.opentracing.enabled</code>至<code class="literal">false</code></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_runnable_and_callable" href="#_runnable_and_callable"></a> 64.2可运行和可调用</h2></div></div></div><p>如果你把逻辑包装进去<code class="literal">Runnable</code>要么<code class="literal">Callable</code> ，您可以将这些类包装在其Sleuth代表中，如以下示例所示<code class="literal">Runnable</code> ：</p><pre class="programlisting">Runnable runnable = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Runnable() {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> run() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// do some work</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String toString() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spanNameFromToStringMethod"</span>;
	}
};
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Manual `TraceRunnable` creation with explicit "calculateTax" Span name</span>
Runnable traceRunnable = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TraceRunnable(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracing, spanNamer, runnable,
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"calculateTax"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Wrapping `Runnable` with `Tracing`. That way the current span will be available</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// in the thread of `Runnable`</span>
Runnable traceRunnableFromTracer = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracing.currentTraceContext()
		.wrap(runnable);</pre><p>以下示例显示了如何针对<code class="literal">Callable</code> ：</p><pre class="programlisting">Callable&lt;String&gt; callable = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Callable&lt;String&gt;() {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String call() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> someLogic();
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String toString() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spanNameFromToStringMethod"</span>;
	}
};
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Manual `TraceCallable` creation with explicit "calculateTax" Span name</span>
Callable&lt;String&gt; traceCallable = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TraceCallable&lt;&gt;(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracing, spanNamer,
		callable, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"calculateTax"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Wrapping `Callable` with `Tracing`. That way the current span will be available</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// in the thread of `Callable`</span>
Callable&lt;String&gt; traceCallableFromTracer = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tracing.currentTraceContext()
		.wrap(callable);</pre><p>这样，您可以确保为每个执行创建并关闭新的跨度。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_hystrix" href="#_hystrix"></a> 64.3 Hystrix</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_concurrency_strategy" href="#_custom_concurrency_strategy"></a> 64.3.1自定义并发策略</h3></div></div></div><p>我们注册一个习俗<a class="link" href="https://github.com/Netflix/Hystrix/wiki/Plugins#concurrencystrategy" target="_top"><code class="literal">HystrixConcurrencyStrategy</code></a>叫<code class="literal">TraceCallable</code>包裹所有<code class="literal">Callable</code> Sleuth代表的实例。该策略将开始或继续跨度，具体取决于在调用Hystrix命令之前是否已经在进行跟踪。要禁用自定义Hystrix并发策略，请设置<code class="literal">spring.sleuth.hystrix.strategy.enabled</code>至<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_manual_command_setting" href="#_manual_command_setting"></a> 64.3.2手动命令设置</h3></div></div></div><p>假设您具有以下<code class="literal">HystrixCommand</code> ：</p><pre class="programlisting">HystrixCommand&lt;String&gt; hystrixCommand = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HystrixCommand&lt;String&gt;(setter) {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> String run() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> someLogic();
	}
};</pre><p>要传递跟踪信息，您必须在Sleuth版本的Sleuth中包装相同的逻辑<code class="literal">HystrixCommand</code> ， 这就是所谓的<code class="literal">TraceCommand</code> ，如以下示例所示：</p><pre class="programlisting">TraceCommand&lt;String&gt; traceCommand = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TraceCommand&lt;String&gt;(tracer, setter) {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doRun() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> someLogic();
	}
};</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rxjava" href="#_rxjava"></a> 64.4 RxJava</h2></div></div></div><p>我们注册一个自定义<a class="link" href="https://github.com/ReactiveX/RxJava/wiki/Plugins#rxjavaschedulershook" target="_top"><code class="literal">RxJavaSchedulersHook</code></a>包裹所有<code class="literal">Action0</code> Sleuth代表中的实例，称为<code class="literal">TraceAction</code> 。挂钩将开始或继续跨度，具体取决于在计划操作之前是否已经进行了跟踪。禁用自定义<code class="literal">RxJavaSchedulersHook</code> ，将<code class="literal">spring.sleuth.rxjava.schedulers.hook.enabled</code>至<code class="literal">false</code> 。</p><p>您可以为不希望为其创建跨度的线程名称定义一个正则表达式列表。为此，请在列表中提供逗号分隔的正则表达式列表。 <code class="literal">spring.sleuth.rxjava.schedulers.ignoredthreads</code>属性。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>建议的反应式编程和Sleuth方法是使用Reactor支持。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_http_integration" href="#_http_integration"></a> 64.5 HTTP集成</h2></div></div></div><p>可以通过设置<code class="literal">spring.sleuth.web.enabled</code>属性值等于<code class="literal">false</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_http_filter" href="#_http_filter"></a> 64.5.1 HTTP筛选器</h3></div></div></div><p>通过<code class="literal">TracingFilter</code> ，所有采样的传入请求均会创建跨度。那个Span的名字是<code class="literal">http:</code> +请求发送到的路径。例如，如果请求已发送至<code class="literal">/this/that</code>那么名称将是<code class="literal">http:/this/that</code> 。您可以通过设置以下网址来配置要跳过的URI： <code class="literal">spring.sleuth.web.skipPattern</code>属性。如果你有<code class="literal">ManagementServerProperties</code>在类路径上，其值<code class="literal">contextPath</code>被附加到提供的跳过模式中。如果您想重用Sleuth的默认跳过模式并追加自己的模式，请使用<code class="literal">spring.sleuth.web.additionalSkipPattern</code> 。</p><p>默认情况下，所有Spring Boot Actuator端点都会自动添加到跳过模式中。如果要禁用此行为集<code class="literal">spring.sleuth.web.ignore-auto-configured-skip-patterns</code>至<code class="literal">true</code> 。</p><p>要更改跟踪过滤器注册的顺序，请设置<code class="literal">spring.sleuth.web.filter-order</code>属性。</p><p>要禁用记录未捕获异常的过滤器，您可以禁用<code class="literal">spring.sleuth.web.exception-throwing-filter-enabled</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_handlerinterceptor" href="#_handlerinterceptor"></a> 64.5.2 HandlerInterceptor</h3></div></div></div><p>由于我们希望范围名称精确，因此我们使用<code class="literal">TraceHandlerInterceptor</code>要么包装一个现有的<code class="literal">HandlerInterceptor</code>或直接添加到现有列表中<code class="literal">HandlerInterceptors</code> 。的<code class="literal">TraceHandlerInterceptor</code>向给定添加一个特殊的请求属性<code class="literal">HttpServletRequest</code> 。如果<code class="literal">TracingFilter</code>没有看到此属性，它将创建一个<span class="quote">“ <span class="quote">fallback</span> ”</span>跨度，这是在服务器端创建的一个附加跨度，以便在UI中正确显示跟踪。如果发生这种情况，可能是缺少仪器。在这种情况下，请在Spring Cloud Sleuth中提出问题。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_async_servlet_support" href="#_async_servlet_support"></a> 64.5.3异步Servlet支持</h3></div></div></div><p>如果您的控制器返回一个<code class="literal">Callable</code>或<code class="literal">WebAsyncTask</code> ，Spring Cloud Sleuth会继续现有范围，而不是创建一个新范围。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_webflux_support" href="#_webflux_support"></a> 64.5.4 WebFlux支持</h3></div></div></div><p>通过<code class="literal">TraceWebFilter</code> ，所有采样的传入请求都将创建跨度。那个Span的名字是<code class="literal">http:</code> +请求发送到的路径。例如，如果请求已发送至<code class="literal">/this/that</code> ， 名字是<code class="literal">http:/this/that</code> 。您可以使用来配置要跳过的URI。 <code class="literal">spring.sleuth.web.skipPattern</code>属性。如果你有<code class="literal">ManagementServerProperties</code>在类路径上，其值<code class="literal">contextPath</code>被附加到提供的跳过模式中。如果您想重用Sleuth的默认跳过模式并添加自己的跳过模式，请使用<code class="literal">spring.sleuth.web.additionalSkipPattern</code> 。</p><p>要更改跟踪过滤器注册的顺序，请设置<code class="literal">spring.sleuth.web.filter-order</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_dubbo_rpc_support" href="#_dubbo_rpc_support"></a> 64.5.5 Dubbo RPC支持</h3></div></div></div><p>通过与Brave的集成，Spring Cloud Sleuth支持<a class="link" href="https://dubbo.apache.org/" target="_top">Dubbo</a> 。只需添加<code class="literal">brave-instrumentation-dubbo</code>依赖关系：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>io.zipkin.brave<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>brave-instrumentation-dubbo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>您还需要设置一个<code class="literal">dubbo.properties</code>包含以下内容的文件：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">dubbo.provider.filter</span>=tracing
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">dubbo.consumer.filter</span>=tracing</pre><p>您可以<a class="link" href="https://github.com/openzipkin/brave/tree/master/instrumentation/dubbo-rpc" target="_top">在此处</a>阅读有关Brave-Dubbo集成的更多信息。可以在<a class="link" href="https://github.com/openzipkin/sleuth-webmvc-example/compare/add-dubbo-tracing" target="_top">此处</a>找到Spring Cloud Sleuth和Dubbo的示例。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_http_client_integration" href="#_http_client_integration"></a> 64.6 HTTP客户端集成</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_synchronous_rest_template" href="#_synchronous_rest_template"></a> 64.6.1同步休息模板</h3></div></div></div><p>我们注入一个<code class="literal">RestTemplate</code>拦截器，以确保将所有跟踪信息传递给请求。每次拨打电话时，都会创建一个新的跨度。收到响应后关闭。阻止同步<code class="literal">RestTemplate</code>功能集<code class="literal">spring.sleuth.web.client.enabled</code>至<code class="literal">false</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您必须注册<code class="literal">RestTemplate</code>作为一个bean，以便拦截器被注入。如果您创建一个<code class="literal">RestTemplate</code>具有一个的实例<code class="literal">new</code>关键字，则检测无效。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_asynchronous_rest_template" href="#_asynchronous_rest_template"></a> 64.6.2异步休息模板</h3></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>从侦探开始<code class="literal">2.0.0</code> ，我们不再注册的Bean <code class="literal">AsyncRestTemplate</code>类型。创建此类Bean由您自己决定。然后我们对其进行检测。</p></td></tr></tbody></table></div><p>阻止<code class="literal">AsyncRestTemplate</code>功能集<code class="literal">spring.sleuth.web.async.client.enabled</code>至<code class="literal">false</code> 。禁用默认设置<code class="literal">TraceAsyncClientHttpRequestFactoryWrapper</code> ，设定<code class="literal">spring.sleuth.web.async.client.factory.enabled</code>至<code class="literal">false</code> 。如果您不想创建<code class="literal">AsyncRestClient</code>设置好了<code class="literal">spring.sleuth.web.async.client.template.enabled</code>至<code class="literal">false</code> 。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_multiple_asynchronous_rest_templates" href="#_multiple_asynchronous_rest_templates"></a>多个异步休息模板</h4></div></div></div><p>有时您需要使用异步实现模板的多个实现。在以下代码段中，您可以看到有关如何设置此类自定义代码的示例<code class="literal">AsyncRestTemplate</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {

	<em><span class="hl-annotation" style="color: gray">@Bean(name = "customAsyncRestTemplate")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> AsyncRestTemplate traceAsyncRestTemplate() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AsyncRestTemplate(asyncClientFactory(),
				clientHttpRequestFactory());
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ClientHttpRequestFactory clientHttpRequestFactory() {
		ClientHttpRequestFactory clientHttpRequestFactory = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> CustomClientHttpRequestFactory();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// CUSTOMIZE HERE</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> clientHttpRequestFactory;
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> AsyncClientHttpRequestFactory asyncClientFactory() {
		AsyncClientHttpRequestFactory factory = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> CustomAsyncClientHttpRequestFactory();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// CUSTOMIZE HERE</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> factory;
	}

}</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_webclient" href="#_webclient"></a> 64.6.3<code class="literal">WebClient</code></h3></div></div></div><p>我们注入一个<code class="literal">ExchangeFilterFunction</code>创建跨度并通过成功和错误时回调的实现，负责关闭客户端跨度。</p><p>要阻止此功能，请设置<code class="literal">spring.sleuth.web.client.enabled</code>至<code class="literal">false</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您必须注册<code class="literal">WebClient</code>作为bean，以便应用跟踪工具。如果您创建一个<code class="literal">WebClient</code>具有一个的实例<code class="literal">new</code>关键字，则检测无效。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_traverson" href="#_traverson"></a> 64.6.4特拉弗森</h3></div></div></div><p>如果您使用<a class="link" href="https://docs.spring.io/spring-hateoas/docs/current/reference/html/#client.traverson" target="_top">Traverson</a>库，则可以注入一个<code class="literal">RestTemplate</code>作为到Traverson对象中的bean。以来<code class="literal">RestTemplate</code>已被拦截，您将完全支持在客户端中进行跟踪。以下伪代码显示了如何执行此操作：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em> RestTemplate restTemplate;

Traverson traverson = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Traverson(URI.create(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://some/address"</span>),
    MediaType.APPLICATION_JSON, MediaType.APPLICATION_JSON_UTF8).setRestOperations(restTemplate);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// use Traverson</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_apache_httpclientbuilder_and_httpasyncclientbuilder" href="#_apache_httpclientbuilder_and_httpasyncclientbuilder"></a> 64.6.5阿帕奇<code class="literal">HttpClientBuilder</code>和<code class="literal">HttpAsyncClientBuilder</code></h3></div></div></div><p>我们对<code class="literal">HttpClientBuilder</code>和<code class="literal">HttpAsyncClientBuilder</code>以便将跟踪上下文注入到已发送的请求中。</p><p>要阻止这些功能，请设置<code class="literal">spring.sleuth.web.client.enabled</code>至<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_netty_httpclient" href="#_netty_httpclient"></a> 64.6.6净值<code class="literal">HttpClient</code></h3></div></div></div><p>我们对Netty的<code class="literal">HttpClient</code> 。</p><p>要阻止此功能，请设置<code class="literal">spring.sleuth.web.client.enabled</code>至<code class="literal">false</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您必须注册<code class="literal">HttpClient</code>作为bean，以便进行检测。如果您创建一个<code class="literal">HttpClient</code>具有一个的实例<code class="literal">new</code>关键字，则检测无效。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_userinforesttemplatecustomizer" href="#_userinforesttemplatecustomizer"></a> 64.6.7<code class="literal">UserInfoRestTemplateCustomizer</code></h3></div></div></div><p>我们对Spring Security的<code class="literal">UserInfoRestTemplateCustomizer</code> 。</p><p>要阻止此功能，请设置<code class="literal">spring.sleuth.web.client.enabled</code>至<code class="literal">false</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_feign" href="#_feign"></a> 64.7假装</h2></div></div></div><p>默认情况下，Spring Cloud Sleuth通过以下方式与Feign集成<code class="literal">TraceFeignClientAutoConfiguration</code> 。您可以通过设置完全禁用它<code class="literal">spring.sleuth.feign.enabled</code>至<code class="literal">false</code> 。如果这样做，则不会进行任何与Feign相关的检测。</p><p>Feign仪器的一部分通过<code class="literal">FeignBeanPostProcessor</code> 。您可以通过设置禁用它<code class="literal">spring.sleuth.feign.processor.enabled</code>至<code class="literal">false</code> 。如果设置为<code class="literal">false</code> ，Spring Cloud Sleuth不会检测您的任何定制Feign组件。但是，所有默认工具仍然存在。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_grpc" href="#_grpc"></a> 64.8 gRPC</h2></div></div></div><p>Spring Cloud Sleuth通过以下方式为<a class="link" href="https://grpc.io/" target="_top">gRPC</a>提供工具<code class="literal">TraceGrpcAutoConfiguration</code> 。您可以通过设置完全禁用它<code class="literal">spring.sleuth.grpc.enabled</code>至<code class="literal">false</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variant_1" href="#_variant_1"></a> 64.8.1变体1</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_dependencies" href="#_dependencies"></a>依存关系</h4></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>gRPC集成依赖于两个外部库来检测客户端和服务器，并且这两个库都必须在类路径上才能启用检测。</p></td></tr></tbody></table></div><p>Maven：</p><pre class="screen">		&lt;dependency&gt;
			&lt;groupId&gt;io.github.lognet&lt;/groupId&gt;
			&lt;artifactId&gt;grpc-spring-boot-starter&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;io.zipkin.brave&lt;/groupId&gt;
			&lt;artifactId&gt;brave-instrumentation-grpc&lt;/artifactId&gt;
		&lt;/dependency&gt;</pre><p>摇篮：</p><pre class="screen">    compile("io.github.lognet:grpc-spring-boot-starter")
    compile("io.zipkin.brave:brave-instrumentation-grpc")</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_server_instrumentation" href="#_server_instrumentation"></a>服务器检测</h4></div></div></div><p>Spring Cloud Sleuth利用grpc-spring-boot-starter向带有注释的所有服务注册Brave的gRPC服务器拦截器<code class="literal">@GRpcService</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_client_instrumentation" href="#_client_instrumentation"></a>客户端工具</h4></div></div></div><p>gRPC客户端利用<code class="literal">ManagedChannelBuilder</code>构造一个<code class="literal">ManagedChannel</code>用于与gRPC服务器通信。本地人<code class="literal">ManagedChannelBuilder</code>提供静态方法作为构建的入口点<code class="literal">ManagedChannel</code>但是，这种实例不在Spring应用程序上下文的影响范围之内。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Sleuth提供了<code class="literal">SpringAwareManagedChannelBuilder</code>可以通过Spring应用程序上下文进行自定义，并由gRPC客户端注入。<span class="strong"><strong>创建时必须使用此构建器<code class="literal">ManagedChannel</code>实例。</strong></span></p></td></tr></tbody></table></div><p>侦探创造一个<code class="literal">TracingManagedChannelBuilderCustomizer</code>将Brave的客户端拦截器注入到<code class="literal">SpringAwareManagedChannelBuilder</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_variant_2" href="#_variant_2"></a> 64.8.2变体2</h3></div></div></div><p><a class="link" href="https://github.com/yidongnan/grpc-spring-boot-starter" target="_top">Grpc Spring Boot Starter</a>自动检测Spring Cloud Sleuth和brave的gRPC工具的存在，并注册必要的客户端和/或服务器工具。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_asynchronous_communication" href="#_asynchronous_communication"></a> 64.9异步通信</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_async_annotated_methods" href="#_async_annotated_methods"></a> 64.9.1 <code class="literal">@Async</code>带注释的方法</h3></div></div></div><p>在Spring Cloud Sleuth中，我们检测与异步相关的组件，以便在线程之间传递跟踪信息。您可以通过设置以下值来禁用此行为： <code class="literal">spring.sleuth.async.enabled</code>至<code class="literal">false</code> 。</p><p>如果您用<code class="literal">@Async</code> ，我们将自动创建具有以下特征的新跨度：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">如果该方法带有注释<code class="literal">@SpanName</code> ，注释的值是Span的名称。</li><li class="listitem">如果该方法未使用注释<code class="literal">@SpanName</code> ，Span名称是带注释的方法名称。</li><li class="listitem">该范围用方法的类名和方法名标记。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_scheduled_annotated_methods" href="#_scheduled_annotated_methods"></a> 64.9.2 <code class="literal">@Scheduled</code>带注释的方法</h3></div></div></div><p>在Spring Cloud Sleuth中，我们对调度的方法执行进行检测，以便在线程之间传递跟踪信息。您可以通过设置以下值来禁用此行为： <code class="literal">spring.sleuth.scheduled.enabled</code>至<code class="literal">false</code> 。</p><p>如果您用<code class="literal">@Scheduled</code> ，我们将自动创建具有以下特征的新跨度：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">跨度名称是带注释的方法名称。</li><li class="listitem">该范围用方法的类名和方法名标记。</li></ul></div><p>如果您要跳过跨度创建一些<code class="literal">@Scheduled</code>带注释的类，您可以设置<code class="literal">spring.sleuth.scheduled.skipPattern</code>使用与表达式的完全限定名称匹配的正则表达式<code class="literal">@Scheduled</code>带注释的类。如果您使用<code class="literal">spring-cloud-sleuth-stream</code>和<code class="literal">spring-cloud-netflix-hystrix-stream</code>在一起，将为每个Hystrix指标创建一个范围并将其发送给Zipkin。此行为可能很烦人。这就是为什么默认情况下<code class="literal">spring.sleuth.scheduled.skipPattern=org.springframework.cloud.netflix.hystrix.stream.HystrixStreamTask</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executor_executorservice_and_scheduledexecutorservice" href="#_executor_executorservice_and_scheduledexecutorservice"></a> 64.9.3 Executor，ExecutorService和ScheduledExecutorService</h3></div></div></div><p>我们提供<code class="literal">LazyTraceExecutor</code> ， <code class="literal">TraceableExecutorService</code>和<code class="literal">TraceableScheduledExecutorService</code> 。每次提交，调用或计划新任务时，这些实现都会创建跨度。</p><p>以下示例显示如何通过以下方式传递跟踪信息： <code class="literal">TraceableExecutorService</code>当与<code class="literal">CompletableFuture</code> ：</p><pre class="programlisting">CompletableFuture&lt;Long&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// perform some logic</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">1</span>_<span class="hl-number">000</span>_<span class="hl-number">000L</span>;
}, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TraceableExecutorService(beanFactory, executorService,
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// 'calculateTax' explicitly names the span - this param is optional</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"calculateTax"</span>));</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>侦探不适用于<code class="literal">parallelStream()</code>盒子外面。如果要使跟踪信息通过流传播，则必须将方法与<code class="literal">supplyAsync(…​)</code> ，如先前所示。</p></td></tr></tbody></table></div><p>如果有实现<code class="literal">Executor</code>您要从跨度创建中排除的界面，可以使用<code class="literal">spring.sleuth.async.ignored-beans</code>属性，您可以在其中提供Bean名称列表。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_customization_of_executors" href="#_customization_of_executors"></a>定制执行者</h4></div></div></div><p>有时，您需要设置一个自定义实例<code class="literal">AsyncExecutor</code> 。以下示例显示了如何设置这样的自定义<code class="literal">Executor</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAsync</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// add the infrastructure role to ensure that the bean gets auto-proxied</span>
<em><span class="hl-annotation" style="color: gray">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomExecutorConfig <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AsyncConfigurerSupport {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	BeanFactory beanFactory;

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Executor getAsyncExecutor() {
		ThreadPoolTaskExecutor executor = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ThreadPoolTaskExecutor();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// CUSTOMIZE HERE</span>
		executor.setCorePoolSize(<span class="hl-number">7</span>);
		executor.setMaxPoolSize(<span class="hl-number">42</span>);
		executor.setQueueCapacity(<span class="hl-number">11</span>);
		executor.setThreadNamePrefix(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"MyExecutor-"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// DON'T FORGET TO INITIALIZE</span>
		executor.initialize();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LazyTraceExecutor(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.beanFactory, executor);
	}

}</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>为确保您的配置得到后期处理，请记住添加<code class="literal">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</code>在你的<code class="literal">@Configuration</code>类</p></td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_messaging" href="#_messaging"></a> 64.10消息传递</h2></div></div></div><p>可以通过设置<code class="literal">spring.sleuth.messaging.enabled</code>属性值等于<code class="literal">false</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_integration_and_spring_cloud_stream" href="#_spring_integration_and_spring_cloud_stream"></a> 64.10.1 Spring集成和Spring Cloud Stream</h3></div></div></div><p>Spring Cloud Sleuth与<a class="link" href="https://projects.spring.io/spring-integration/" target="_top">Spring Integration集成</a> 。它为发布和订阅事件创建跨度。要禁用Spring Integration工具，请设置<code class="literal">spring.sleuth.integration.enabled</code>至<code class="literal">false</code> 。</p><p>您可以提供<code class="literal">spring.sleuth.integration.patterns</code>模式以显式提供要包括在跟踪中的通道的名称。默认情况下，除<code class="literal">hystrixStreamOutput</code>包括频道。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>使用时<code class="literal">Executor</code>建立一个Spring Integration <code class="literal">IntegrationFlow</code> ，您必须使用未跟踪的<code class="literal">Executor</code> 。使用以下方法装饰Spring Integration Executor通道<code class="literal">TraceableExecutorService</code>导致跨度未正确关闭。</p></td></tr></tbody></table></div><p>如果要定制从消息头读取和写入跟踪上下文的方式，就足以注册类型的bean：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">Propagation.Setter<MessageHeaderAccessor, String></code> -用于将标头写入消息</li><li class="listitem"><code class="literal">Propagation.Getter<MessageHeaderAccessor, String></code> -从邮件中读取标题</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_rabbitmq" href="#_spring_rabbitmq"></a> 64.10.2春季RabbitMq</h3></div></div></div><p>我们对<code class="literal">RabbitTemplate</code>以便将跟踪标头注入到消息中。</p><p>要阻止此功能，请设置<code class="literal">spring.sleuth.messaging.rabbit.enabled</code>至<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_kafka" href="#_spring_kafka"></a> 64.10.3 Spring Kafka </h3></div></div></div><p>我们对春季卡夫卡的<code class="literal">ProducerFactory</code>和<code class="literal">ConsumerFactory</code>以便将跟踪标头注入到创建的Spring Kafka的<code class="literal">Producer</code>和<code class="literal">Consumer</code> 。</p><p>要阻止此功能，请设置<code class="literal">spring.sleuth.messaging.kafka.enabled</code>至<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_jms" href="#_spring_jms"></a> 64.10.4 Spring JMS</h3></div></div></div><p>我们对<code class="literal">JmsTemplate</code>以便将跟踪标头注入到消息中。我们也支持<code class="literal">@JmsListener</code>消费者方的注释方法。</p><p>要阻止此功能，请设置<code class="literal">spring.sleuth.messaging.jms.enabled</code>至<code class="literal">false</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>我们不支持JMS的行李运送</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_zuul_2" href="#_zuul_2"></a> 64.11祖尔</h2></div></div></div><p>我们通过使用跟踪信息丰富功能区请求来检测Zuul功能区集成。要禁用Zuul支持，请设置<code class="literal">spring.sleuth.zuul.enabled</code>财产<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_project_reactor" href="#_project_reactor"></a> 64.12项目反应堆</h2></div></div></div><p>对于依赖Project Reactor的项目，例如Spring Cloud Gateway，我们建议将<code class="literal">spring.sleuth.reactor.decorate-on-each</code>选择<code class="literal">false</code> 。这样，与标准仪器机制相比，应观察到性能提高。该选项的作用是包装装饰<code class="literal">onLast</code>运算符代替<code class="literal">onEach</code>这将导致创建更少的对象。缺点是，当Project Reactor更改线程时，跟踪传播将继续而不会出现问题，但是任何依赖于<code class="literal">ThreadLocal</code>例如MDC条目可能有问题。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_running_examples" href="#_running_examples"></a> 65。运行示例</h2></div></div></div><p>您可以看到在<a class="link" href="https://run.pivotal.io/" target="_top">Pivotal Web Services中</a>部署的正在运行的示例。在以下链接中查看它们：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://docssleuth-zipkin-server.cfapps.io/" target="_top">Zipkin的应用程序在示例中呈现到顶部</a> 。首先向<a class="link" href="https://docssleuth-service1.cfapps.io/start" target="_top">服务1</a>发出请求，然后在Zipkin中签出跟踪。</li><li class="listitem"><a class="link" href="https://docsbrewing-zipkin-server.cfapps.io/" target="_top">Zipkin for PWS的啤酒厂</a> ，其<a class="link" href="https://github.com/spring-cloud-samples/brewery" target="_top">Github代码</a> 。确保选择了7天的回溯期。如果没有痕迹，请转到“ <a class="link" href="https://docsbrewing-presenting.cfapps.io/" target="_top">呈现应用程序”</a>并订购一些啤酒。然后检查Zipkin是否有痕迹。</li></ul></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_consul" href="#_spring_cloud_consul"></a>第九部分spring-cloud-consul</h1></div></div></div><div class="partintro"><div></div><p><span class="strong"><strong>格林威治。SR4</strong></span></p><p>该项目通过自动配置并绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供Consul集成。通过一些简单的注释，您可以快速启用和配置应用程序内部的通用模式，并使用基于Consul的组件构建大型分布式系统。提供的模式包括服务发现，控制总线和配置。通过与Spring Cloud Netflix集成提供智能路由（Zuul）和客户端负载平衡（Ribbon），断路器（Hystrix）。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-install" href="#spring-cloud-consul-install"></a> 66。安装领事</h2></div></div></div><p>请参阅<a class="link" href="https://www.consul.io/intro/getting-started/install.html" target="_top">安装文档</a>以获取有关如何安装Consul的说明。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-agent" href="#spring-cloud-consul-agent"></a> 67。领事代理</h2></div></div></div><p>Consul Agent客户端必须对所有Spring Cloud Consul应用程序都可用。默认情况下，代理客户端应位于<code class="literal">localhost:8500</code> 。有关如何启动代理客户端以及如何连接到Consul代理服务器群集的详细信息，请参阅<a class="link" href="https://consul.io/docs/agent/basics.html" target="_top">代理文档</a> 。为了进行开发，在安装consul之后，可以使用以下命令启动Consul代理：</p><pre class="screen">./src/main/bash/local_run_consul.sh</pre><p>这将在服务器模式下的端口8500上启动代理，并且ui可从<a class="link" href="http://localhost:8500" target="_top">http：// localhost：8500获得。</a></p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-discovery" href="#spring-cloud-consul-discovery"></a> 68。领事服务发现</h2></div></div></div><p>服务发现是基于微服务的体系结构的关键原则之一。尝试手动配置每个客户端或某种形式的约定可能非常困难并且非常脆弱。领事通过<a class="link" href="https://www.consul.io/docs/agent/http.html" target="_top">HTTP API</a>和<a class="link" href="https://www.consul.io/docs/agent/dns.html" target="_top">DNS</a>提供服务发现服务。Spring Cloud Consul利用HTTP API进行服务注册和发现。这不会阻止非Spring Cloud应用程序利用DNS接口。Consul Agents服务器在<a class="link" href="https://www.consul.io/docs/internals/architecture.html" target="_top">群集中</a>运行，该<a class="link" href="https://www.consul.io/docs/internals/architecture.html" target="_top">群集</a>通过<a class="link" href="https://www.consul.io/docs/internals/gossip.html" target="_top">八卦协议进行通信</a>并使用<a class="link" href="https://www.consul.io/docs/internals/consensus.html" target="_top">Raft共识协议</a> 。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_to_activate" href="#_how_to_activate"></a> 68.1如何激活</h2></div></div></div><p>要激活Consul Service Discovery，请使用带有启动器的组<code class="literal">org.springframework.cloud</code>和工件ID <code class="literal">spring-cloud-starter-consul-discovery</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_with_consul" href="#_registering_with_consul"></a> 68.2向领事注册</h2></div></div></div><p>当客户端向Consul注册时，它将提供有关其自身的元数据，例如主机和端口，id，名称和标签。默认情况下会创建一个HTTP <a class="link" href="https://www.consul.io/docs/agent/checks.html" target="_top">Check</a> ，Consul会点击<code class="literal">/health</code>每10秒终结一次端点。如果运行状况检查失败，则将该服务实例标记为关键。</p><p>领事客户端示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String home() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello world"</span>;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).web(true).run(args);
    }

}</pre><p>（即完全正常的Spring Boot应用）。如果领事客户不在其他地方<code class="literal">localhost:8500</code> ，则需要进行配置才能找到客户端。例：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      host: localhost
      port: 8500</pre><p>
</p><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果您使用<a class="link" href="#spring-cloud-consul-config" title="69。使用Consul进行分布式配置">Spring Cloud Consul Config</a> ，则需要将上述值放在<code class="literal">bootstrap.yml</code>代替<code class="literal">application.yml</code> 。</p></td></tr></tbody></table></div><p>默认服务名称，实例ID和端口，取自<code class="literal">Environment</code> ， 是<code class="literal">${spring.application.name}</code> ，Spring Context ID和<code class="literal">${server.port}</code>分别。</p><p>要禁用Consul Discovery Client，您可以设置<code class="literal">spring.cloud.consul.discovery.enabled</code>至<code class="literal">false</code> 。Consul Discovery Client在以下情况下也将被禁用<code class="literal">spring.cloud.discovery.enabled</code>被设定为<code class="literal">false</code> 。</p><p>要禁用服务注册，您可以设置<code class="literal">spring.cloud.consul.discovery.register</code>至<code class="literal">false</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_registering_management_as_a_separate_service" href="#_registering_management_as_a_separate_service"></a> 68.2.1将管理注册为单独的服务</h3></div></div></div><p>通过将管理服务器端口设置为与应用程序端口不同的端口时<code class="literal">management.server.port</code>财产，管理服务将被注册为与应用程序服务不同的服务。例如：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  application:
    name: myApp
management:
  server:
    port: 4452</pre><p>
</p><p>以上配置将注册以下两项服务：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">申请服务：</li></ul></div><pre class="screen">ID: myApp
Name: myApp</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">管理服务：</li></ul></div><pre class="screen">ID: myApp-management
Name: myApp-management</pre><p>管理服务将继承其<code class="literal">instanceId</code>和<code class="literal">serviceName</code>从应用程序服务。例如：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  application:
    name: myApp
management:
  server:
    port: 4452
spring:
  cloud:
    consul:
      discovery:
        instance-id: custom-service-id
        serviceName: myprefix-${spring.application.name}</pre><p>
</p><p>以上配置将注册以下两项服务：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">申请服务：</li></ul></div><pre class="screen">ID: custom-service-id
Name: myprefix-myApp</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">管理服务：</li></ul></div><pre class="screen">ID: custom-service-id-management
Name: myprefix-myApp-management</pre><p>通过以下属性可以进行进一步的自定义：</p><pre class="screen">/** Port to register the management service under (defaults to management port) */
spring.cloud.consul.discovery.management-port

/** Suffix to use when registering management service (defaults to "management" */
spring.cloud.consul.discovery.management-suffix

/** Tags to use when registering management service (defaults to "management" */
spring.cloud.consul.discovery.management-tags</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_http_health_check" href="#_http_health_check"></a> 68.3 HTTP运行状况检查</h2></div></div></div><p>Consul实例的运行状况检查默认为“ / health”，这是Spring Boot Actuator应用程序中有用端点的默认位置。即使您使用非默认上下文路径或servlet路径（例如，对于Actuator应用程序），也需要更改这些设置<code class="literal">server.servletPath=/foo</code> ）或管理端点路径（例如<code class="literal">management.server.servlet.context-path=/admin</code> ）。还可以配置Consul用于检查运行状况终结点的时间间隔。 “ 10s”和“ 1m”分别代表10秒和1分钟。例：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      discovery:
        healthCheckPath: ${management.server.servlet.context-path}/health
        healthCheckInterval: 15s</pre><p>
</p><p>您可以通过设置禁用健康检查<code class="literal">management.health.consul.enabled=false</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_metadata_and_consul_tags" href="#_metadata_and_consul_tags"></a> 68.3.1元数据和领事标签</h3></div></div></div><p>领事尚不支持有关服务的元数据。Spring Cloud的<code class="literal">ServiceInstance</code>有个<code class="literal">Map<String, String> metadata</code>领域。Spring Cloud Consul使用Consul标签来近似元数据，直到Consul正式支持元数据。带有形式的标签<code class="literal">key=value</code>将被拆分并用作<code class="literal">Map</code>键和值。没有相等的标签<code class="literal">=</code>符号，将同时用作键和值。</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      discovery:
        tags: foo=bar, baz</pre><p>
</p><p>上面的配置将生成带有<code class="literal">foo→bar</code>和<code class="literal">baz→baz</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_making_the_consul_instance_id_unique" href="#_making_the_consul_instance_id_unique"></a> 68.3.2使领事实例ID唯一</h3></div></div></div><p>默认情况下，领事实例的ID等于其Spring Application Context ID。默认情况下，Spring Application Context ID为<code class="literal">${spring.application.name}:comma,separated,profiles:${server.port}</code> 。在大多数情况下，这将允许一项服务的多个实例在一台计算机上运行。如果需要进一步的唯一性，则可以使用Spring Cloud通过在<code class="literal">spring.cloud.consul.discovery.instanceId</code> 。例如：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      discovery:
        instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre><p>
</p><p>有了此元数据，并且在本地主机上部署了多个服务实例，随机值将在其中插入以使实例唯一。在Cloudfoundry中<code class="literal">vcap.application.instance_id</code>将在Spring Boot应用程序中自动填充，因此将不需要随机值。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_applying_headers_to_health_check_requests" href="#_applying_headers_to_health_check_requests"></a> 68.3.3将标头应用于健康检查请求</h3></div></div></div><p>标头可以应用于健康检查请求。例如，如果您尝试注册使用<a class="link" href="https://github.com/spring-cloud/spring-cloud-config/blob/master/docs/src/main/asciidoc/spring-cloud-config.adoc#vault-backend" target="_top">Vault Backend</a>的<a class="link" href="https://cloud.spring.io/spring-cloud-config/" target="_top">Spring Cloud Config</a>服务器：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      discovery:
        health-check-headers:
          X-Config-Token: 6442e58b-d1ea-182e-cfa5-cf9cddef0722</pre><p>
</p><p>根据HTTP标准，每个标头可以具有多个值，在这种情况下，可以提供一个数组：</p><p><b>application.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      discovery:
        health-check-headers:
          X-Config-Token:
            - "6442e58b-d1ea-182e-cfa5-cf9cddef0722"
            - "Some other value"</pre><p>
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_looking_up_services" href="#_looking_up_services"></a> 68.4查找服务</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_ribbon" href="#_using_ribbon"></a> 68.4.1使用功能区</h3></div></div></div><p>Spring Cloud支持<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign" target="_top">Feign</a> （REST客户端构建器）以及<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon" target="_top">Spring <code class="literal">RestTemplate</code></a>用于使用逻辑服务名称/ ID而非物理URL查找服务。 Feign和可发现发现的RestTemplate都使用<a class="link" href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon" target="_top">Ribbon</a>进行客户端负载平衡。</p><p>如果要使用RestTemplate访问服务STORES，只需声明：</p><pre class="screen">@LoadBalanced
@Bean
public RestTemplate loadbalancedRestTemplate() {
     new RestTemplate();
}</pre><p>并以这种方式使用它（注意我们如何使用Consul的STORES服务名称/ id代替完全限定的域名）：</p><pre class="screen">@Autowired
RestTemplate restTemplate;

public String getFirstProduct() {
   return this.restTemplate.getForObject("https://STORES/products/1", String.class);
}</pre><p>如果您在多个数据中心中拥有Consul群集，并且要访问另一个数据中心中的服务，则仅靠服务名称/ id是不够的。在这种情况下，您使用财产<code class="literal">spring.cloud.consul.discovery.datacenters.STORES=dc-west</code>哪里<code class="literal">STORES</code>是服务名称/ ID，并且<code class="literal">dc-west</code>是STORES服务所在的数据中心。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_using_the_discoveryclient" href="#_using_the_discoveryclient"></a> 68.4.2使用DiscoveryClient</h3></div></div></div><p>您也可以使用<code class="literal">org.springframework.cloud.client.discovery.DiscoveryClient</code>它为发现客户端提供了一个不特定于Netflix的简单API，例如</p><pre class="screen">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances("STORES");
    if (list != null &amp;&amp; list.size() &gt; 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_consul_catalog_watch" href="#_consul_catalog_watch"></a> 68.5Consul Catalog Watch</h2></div></div></div><p>领事目录监视利用领事<a class="link" href="https://www.consul.io/docs/agent/watches.html#services" target="_top">监视服务</a>的能力。Catalog Watch进行了阻塞的Consul HTTP API调用，以确定是否有任何服务已更改。如果有新的服务数据，则会发布心跳事件。</p><p>更改配置监视被称为更改的频率<code class="literal">spring.cloud.consul.config.discovery.catalog-services-watch-delay</code> 。默认值为1000，以毫秒为单位。延迟是上一次调用结束与下一次调用开始之间的时间量。</p><p>禁用目录监视集<code class="literal">spring.cloud.consul.discovery.catalogServicesWatch.enabled=false</code> 。</p><p>watch 使用 Spring <code class="literal">TaskScheduler</code>安排致电领事。默认情况下是<code class="literal">ThreadPoolTaskScheduler</code>与一个<code class="literal">poolSize</code>共1。改变<code class="literal">TaskScheduler</code> ，创建一个类型的bean <code class="literal">TaskScheduler</code>以命名<code class="literal">ConsulDiscoveryClientConfiguration.CATALOG_WATCH_TASK_SCHEDULER_NAME</code>不变。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-config" href="#spring-cloud-consul-config"></a> 69。使用Consul进行分布式配置</h2></div></div></div><p>领事提供<a class="link" href="https://consul.io/docs/agent/http/kv.html" target="_top">密钥/值存储，</a>用于存储配置和其他元数据。Spring Cloud Consul Config是<a class="link" href="https://github.com/spring-cloud/spring-cloud-config" target="_top">Config Server和Client</a>的替代方案。在特殊的“引导”阶段将配置加载到Spring环境中。配置存储在<code class="literal">/config</code>文件夹默认情况下。多<code class="literal">PropertySource</code>实例是根据应用程序的名称和模仿Spring Cloud Config解析属性顺序的活动配置文件创建的。例如，名称为“ testApp”且配置文件为“ dev”的应用程序将创建以下属性源：</p><pre class="screen">config/testApp,dev/
config/testApp/
config/application,dev/
config/application/</pre><p>最具体的属性来源在顶部，最不具体的属性在底部。中的属性<code class="literal">config/application</code>该文件夹适用于使用领事进行配置的所有应用程序。中的属性<code class="literal">config/testApp</code>文件夹仅可用于名为“ testApp”的服务的实例。</p><p>当前在启动应用程序时读取配置。发送HTTP POST到<code class="literal">/refresh</code>将导致重新加载配置。<a class="xref" href="#spring-cloud-consul-config-watch" title="69.3配置观察">第69.3节“ Config Watch”</a>还将自动检测更改并重新加载应用程序上下文。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_to_activate_2" href="#_how_to_activate_2"></a> 69.1如何激活</h2></div></div></div><p>要开始使用Consul Configuration，请使用带有starter的组<code class="literal">org.springframework.cloud</code>和工件ID <code class="literal">spring-cloud-starter-consul-config</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><p>这将启用自动配置，该自动配置将设置Spring Cloud Consul Config。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizing" href="#_customizing"></a> 69.2定制</h2></div></div></div><p>Consul Config可以使用以下属性来自定义：</p><p><b>bootstrap.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      config:
        enabled: true
        prefix: configuration
        defaultContext: apps
        profileSeparator: '::'</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为“ false”将禁用Consul Config</li><li class="listitem"><code class="literal">prefix</code>设置配置值的基本文件夹</li><li class="listitem"><code class="literal">defaultContext</code>设置所有应用程序使用的文件夹名称</li><li class="listitem"><code class="literal">profileSeparator</code>设置用于在属性源和配置文件中分隔配置文件名称的分隔符的值</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-consul-config-watch" href="#spring-cloud-consul-config-watch"></a> 69.3配置观察</h2></div></div></div><p>Consul Config Watch利用consul <a class="link" href="https://www.consul.io/docs/agent/watches.html#keyprefix" target="_top">监视键前缀的功能</a> 。Config Watch进行阻塞Consul HTTP API调用，以确定当前应用程序的任何相关配置数据是否已更改。如果有新的配置数据，则会发布刷新事件。这等效于调用<code class="literal">/refresh</code>执行器端点。</p><p>更改配置监视被称为更改的频率<code class="literal">spring.cloud.consul.config.watch.delay</code> 。默认值为1000，以毫秒为单位。延迟是上一次调用结束与下一次调用开始之间的时间量。</p><p>禁用配置监视集<code class="literal">spring.cloud.consul.config.watch.enabled=false</code> 。</p><p>watch 使用 Spring <code class="literal">TaskScheduler</code>安排致电领事。默认情况下是<code class="literal">ThreadPoolTaskScheduler</code>与一个<code class="literal">poolSize</code>共1。改变<code class="literal">TaskScheduler</code> ，创建一个类型的bean <code class="literal">TaskScheduler</code>以命名<code class="literal">ConsulConfigAutoConfiguration.CONFIG_WATCH_TASK_SCHEDULER_NAME</code>不变。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-consul-config-format" href="#spring-cloud-consul-config-format"></a> 69.4 YAML或具有配置的属性</h2></div></div></div><p>与单个键/值对相反，以YAML或“属性”格式存储属性的对象可能更方便。设置<code class="literal">spring.cloud.consul.config.format</code>财产<code class="literal">YAML</code>要么<code class="literal">PROPERTIES</code> 。例如使用YAML：</p><p><b>bootstrap.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      config:
        format: YAML</pre><p>
</p><p>必须在适当的位置设置YAML <code class="literal">data</code>领事的关键。使用上面的默认值，键看起来像：</p><pre class="screen">config/testApp,dev/data
config/testApp/data
config/application,dev/data
config/application/data</pre><p>您可以将YAML文档存储在上面列出的任何键中。</p><p>您可以使用更改数据密钥<code class="literal">spring.cloud.consul.config.data-key</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-consul-config-git2consul" href="#spring-cloud-consul-config-git2consul"></a> 69.5 git2consul与配置</h2></div></div></div><p>git2consul是一个Consul社区项目，该项目将git存储库中的文件加载到Consul的各个键中。默认情况下，键的名称是文件的名称。YAML和属性文件受以下文件扩展名的支持<code class="literal">.yml</code>和<code class="literal">.properties</code>分别。设置<code class="literal">spring.cloud.consul.config.format</code>财产<code class="literal">FILES</code> 。例如：</p><p><b>bootstrap.yml。</b>
</p><pre class="screen">spring:
  cloud:
    consul:
      config:
        format: FILES</pre><p>
</p><p>给定以下键<code class="literal">/config</code> ， <code class="literal">development</code>配置文件和应用程序名称<code class="literal">foo</code> ：</p><pre class="screen">.gitignore
application.yml
bar.properties
foo-development.properties
foo-production.yml
foo.properties
master.ref</pre><p>将创建以下属性源：</p><pre class="screen">config/foo-development.properties
config/foo.properties
config/application.yml</pre><p>每个键的值必须是格式正确的YAML或属性文件。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-consul-failfast" href="#spring-cloud-consul-failfast"></a> 69.6快速失败</h2></div></div></div><p>如果领事不可用于配置，则在某些情况下（例如本地开发或某些测试方案）可能会很方便而不会失败。设置<code class="literal">spring.cloud.consul.config.failFast=false</code>在<code class="literal">bootstrap.yml</code>将导致配置模块记录警告而不是引发异常。这将允许应用程序继续正常启动。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-retry" href="#spring-cloud-consul-retry"></a> 70Consul 重试</h2></div></div></div><p>如果您希望在应用启动时领事代理有时不可用，则可以要求它在失败后继续尝试。您需要添加<code class="literal">spring-retry</code>和<code class="literal">spring-boot-starter-aop</code>到你的classpath。默认行为是重试6次，初始回退间隔为1000ms，随后的回退的指数乘数为1.1。您可以使用以下命令配置这些属性（和其他属性） <code class="literal">spring.cloud.consul.retry.*</code>配置属性。这适用于Spring Cloud Consul Config和Discovery注册。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>要完全控制重试，请添加一个<code class="literal">@Bean</code>类型的<code class="literal">RetryOperationsInterceptor</code> ID为“ consulRetryInterceptor”。Spring Retry有一个<code class="literal">RetryInterceptorBuilder</code>这样就很容易创建一个。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-bus" href="#spring-cloud-consul-bus"></a> 71。带 Consul 的Spring Cloud Bus</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_to_activate_3" href="#_how_to_activate_3"></a> 71.1如何激活</h2></div></div></div><p>要开始使用Consul Bus，请使用带有启动器的组<code class="literal">org.springframework.cloud</code>和工件ID <code class="literal">spring-cloud-starter-consul-bus</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><p>请参阅<a class="link" href="https://cloud.spring.io/spring-cloud-bus/" target="_top">Spring Cloud Bus</a>文档以获取可用的执行器端点和如何发送自定义消息。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-hystrix" href="#spring-cloud-consul-hystrix"></a> 72。Hystrix断路器</h2></div></div></div><p>通过在项目pom.xml中包含此启动器，应用程序可以使用Spring Cloud Netflix项目提供的Hystrix断路器： <code class="literal">spring-cloud-starter-hystrix</code> 。Hystrix不依赖Netflix Discovery Client。的<code class="literal">@EnableHystrix</code>注释应放在配置类（通常是主类）上。然后方法可以用<code class="literal">@HystrixCommand</code>由断路器保护。有关更多详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients" target="_top">文档</a> 。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-consul-turbine" href="#spring-cloud-consul-turbine"></a> 73。Hystrix指标通过Turbine和Consul进行聚合</h2></div></div></div><p>Turbine（由Spring Cloud Netflix项目提供）汇总了多个实例Hystrix指标流，因此仪表板可以显示汇总视图。涡轮使用<code class="literal">DiscoveryClient</code>查找相关实例的接口。要将Turbine与Spring Cloud Consul一起使用，请以类似于以下示例的方式配置Turbine应用程序：</p><p><b>pom.xml。</b>
</p><pre class="screen">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-netflix-turbine&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>
</p><p>请注意，Turbine依赖项不是启动器。涡轮启动器包括对Netflix Eureka的支持。</p><p><b>application.yml。</b>
</p><pre class="screen">spring.application.name: turbine
applications: consulhystrixclient
turbine:
  aggregator:
    clusterConfig: ${applications}
  appConfig: ${applications}</pre><p>
</p><p>的<code class="literal">clusterConfig</code>和<code class="literal">appConfig</code>部分必须匹配，因此将以逗号分隔的服务ID列表放入单独的配置属性中很有用。</p><p><b>Turbine.java。</b>
</p><pre class="screen">@EnableTurbine
@SpringBootApplication
public class Turbine {
    public static void main(String[] args) {
        SpringApplication.run(DemoturbinecommonsApplication.class, args);
    }
}</pre><p>
</p></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_zookeeper" href="#_spring_cloud_zookeeper"></a>第十部分：Spring Cloud Zookeeper</h1></div></div></div><div class="partintro"><div></div><p>该项目通过自动配置以及绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供Zookeeper集成。通过一些注释，您可以快速启用和配置应用程序内部的通用模式，并使用基于Zookeeper的组件构建大型分布式系统。提供的模式包括服务发现和配置。与Spring Cloud的集成Netflix提供了智能路由（Zuul），客户端负载平衡（Ribbon）和断路器（Hystrix）。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-install" href="#spring-cloud-zookeeper-install"></a> 74。安装Zookeeper</h2></div></div></div><p>请参阅<a class="link" href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html" target="_top">安装文档</a>以获取有关如何安装Zookeeper的说明。</p><p>Spring Cloud Zookeeper在后台使用Apache Curator。尽管Zookeeper开发团队仍将Zookeeper 3.5.x视为“测试版”，但现实是许多用户在生产中使用了它。但是，Zookeeper 3.4.x也用于生产中。在Apache Curator 4.0之前，两个版本的Apache Curator支持两种版本的Zookeeper。从Curator 4.0开始，通过相同的Curator库支持两个版本的Zookeeper。</p><p>如果要与版本3.4集成，则需要更改随附的Zookeeper依赖项<code class="literal">curator</code> ， 因此<code class="literal">spring-cloud-zookeeper</code> 。为此，只需排除该依赖关系并添加如下所示的3.4.x版本。</p><p><b>专家。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-zookeeper-all<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusion&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.apache.zookeeper<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>zookeeper<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusion&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.apache.zookeeper<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>zookeeper<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>3.4.12<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusion&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.slf4j<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>slf4j-log4j12<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusion&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>
</p><p><b>摇篮。</b>
</p><pre class="programlisting">compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud:spring-cloud-starter-zookeeper-all'</span>) {
  exclude group: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.apache.zookeeper'</span>, module: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'zookeeper'</span>
}
compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.apache.zookeeper:zookeeper:3.4.12'</span>) {
  exclude group: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.slf4j'</span>, module: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'slf4j-log4j12'</span>
}</pre><p>
</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-discovery" href="#spring-cloud-zookeeper-discovery"></a> 75。Zookeeper的服务发现</h2></div></div></div><p>服务发现是基于微服务的体系结构的关键原则之一。尝试手动配置每个客户端或某种形式的约定可能很困难并且很脆弱。<a class="link" href="https://curator.apache.org" target="_top">Curator</a> （Zookeeper的Java库）通过<a class="link" href="https://curator.apache.org/curator-x-discovery/" target="_top">Service Discovery Extension</a>提供服务发现。Spring Cloud Zookeeper使用此扩展进行服务注册和发现。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_activating" href="#_activating"></a> 75.1激活</h2></div></div></div><p>包括对<code class="literal">org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</code>启用自动配置以设置Spring Cloud Zookeeper Discovery。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>对于网络功能，您仍然需要包括<code class="literal">org.springframework.boot:spring-boot-starter-web</code> 。</p></td></tr></tbody></table></div><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>使用Zookeeper 3.4版时，您需要按<a class="link" href="#spring-cloud-zookeeper-install" title="74。安装Zookeeper">此处</a>所述更改包含依赖项的方式。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_with_zookeeper" href="#_registering_with_zookeeper"></a> 75.2向Zookeeper注册</h2></div></div></div><p>客户端向Zookeeper注册时，它会提供有关其自身的元数据（例如主机和端口，ID和名称）。</p><p>以下示例显示了Zookeeper客户端：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String home() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello world"</span>;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpringApplicationBuilder(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).web(true).run(args);
    }

}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>前面的示例是一个普通的Spring Boot应用程序。</p></td></tr></tbody></table></div><p>如果Zookeeper位于除<code class="literal">localhost:2181</code> ，配置必须提供服务器的位置，如以下示例所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting">spring:
  cloud:
    zookeeper:
      connect-string: localhost:2181</pre><p>
</p><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果您使用<a class="link" href="#spring-cloud-zookeeper-config" title="80。Zookeeper的分布式配置">Spring Cloud Zookeeper Config</a> ，则上一个示例中显示的值必须位于<code class="literal">bootstrap.yml</code>代替<code class="literal">application.yml</code> 。</p></td></tr></tbody></table></div><p>默认服务名称，实例ID和端口（取自<code class="literal">Environment</code> ） 是<code class="literal">${spring.application.name}</code> ，Spring Context ID和<code class="literal">${server.port}</code> ， 分别。</p><p>有<code class="literal">spring-cloud-starter-zookeeper-discovery</code>在类路径上的，使该应用程序同时成为Zookeeper的<span class="quote">“ <span class="quote">服务</span> ”</span> （即它自己注册）和<span class="quote">“ <span class="quote">客户端</span> ”</span> （即，它可以查询Zookeeper来定位其他服务）。</p><p>如果要禁用Zookeeper Discovery Client，可以设置<code class="literal">spring.cloud.zookeeper.discovery.enabled</code>至<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_discoveryclient_2" href="#_using_the_discoveryclient_2"></a> 75.3使用DiscoveryClient</h2></div></div></div><p>Spring Cloud支持<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign" target="_top">Feign</a> （REST客户端构建器）和<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon" target="_top">Spring <code class="literal">RestTemplate</code></a> ，使用逻辑服务名称而不是物理网址。</p><p>您也可以使用<code class="literal">org.springframework.cloud.client.discovery.DiscoveryClient</code> ，它为发现客户端提供了一个不特定于Netflix的简单API，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> DiscoveryClient discoveryClient;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String serviceUrl() {
    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"STORES"</span>);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (list != null &amp;&amp; list.size() &gt; <span class="hl-number">0</span> ) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> list.get(<span class="hl-number">0</span>).getUri().toString();
    }
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null;
}</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-netflix" href="#spring-cloud-zookeeper-netflix"></a> 76。将Spring Cloud Zookeeper与Spring Cloud Netflix组件一起使用</h2></div></div></div><p>Spring Cloud Netflix提供有用的工具，无论使用哪种工具<code class="literal">DiscoveryClient</code>您使用的实现。Feign，Turbine，Ribbon和Zuul均与Spring Cloud Zookeeper一起使用。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_ribbon_with_zookeeper" href="#_ribbon_with_zookeeper"></a> 76.1带Zookeeper的功能区</h2></div></div></div><p>Spring Cloud Zookeeper提供了Ribbon的实现<code class="literal">ServerList</code> 。当您使用<code class="literal">spring-cloud-starter-zookeeper-discovery</code> ，功能区已自动配置为使用<code class="literal">ZookeeperServerList</code>默认。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-service-registry" href="#spring-cloud-zookeeper-service-registry"></a> 77。Spring Cloud Zookeeper和服务注册表</h2></div></div></div><p>Spring Cloud Zookeeper实现了<code class="literal">ServiceRegistry</code>接口，让开发人员以编程方式注册任意服务。</p><p>的<code class="literal">ServiceInstanceRegistration</code>课程提供<code class="literal">builder()</code>创建一个方法<code class="literal">Registration</code>可以使用的对象<code class="literal">ServiceRegistry</code> ，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ZookeeperServiceRegistry serviceRegistry;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> registerThings() {
    ZookeeperRegistration registration = ServiceInstanceRegistration.builder()
            .defaultUriSpec()
            .address(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"anyUrl"</span>)
            .port(<span class="hl-number">10</span>)
            .name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/a/b/c/d/anotherservice"</span>)
            .build();
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.serviceRegistry.register(registration);
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_instance_status" href="#_instance_status"></a> 77.1实例状态</h2></div></div></div><p>Netflix Eureka支持具有以下实例<code class="literal">OUT_OF_SERVICE</code>在服务器上注册。这些实例不作为活动服务实例返回。这对于诸如蓝色/绿色部署之类的行为很有用。（请注意，“ Curator服务发现”食谱不支持此行为。）利用灵活的有效负载，Spring Cloud Zookeeper得以实现<code class="literal">OUT_OF_SERVICE</code>通过更新一些特定的元数据，然后在功能区中对该元数据进行过滤<code class="literal">ZookeeperServerList</code> 。的<code class="literal">ZookeeperServerList</code>过滤掉所有不相等的非空实例状态<code class="literal">UP</code> 。如果实例状态字段为空，则认为是<code class="literal">UP</code>向后兼容。要更改实例的状态，请<code class="literal">POST</code>与<code class="literal">OUT_OF_SERVICE</code>到<code class="literal">ServiceRegistry</code>实例状态执行器端点，如以下示例所示：</p><pre class="programlisting">$ http POST http://localhost:8081/service-registry status=OUT_OF_SERVICE</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>前面的示例使用<code class="literal">http</code>来自<a class="link" href="https://httpie.org" target="_top">https://httpie.org的</a>命令。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-dependencies" href="#spring-cloud-zookeeper-dependencies"></a> 78。Zookeeper依赖关系</h2></div></div></div><p>以下主题介绍了如何使用Spring Cloud Zookeeper依赖项：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-zookeeper-dependencies-using" title="78.1使用Zookeeper依赖关系">第78.1节“使用Zookeeper依赖关系”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-zookeeper-dependencies-activating" title="78.2激活Zookeeper依赖关系">第78.2节“激活Zookeeper依赖关系”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-zookeeper-dependencies-setting-up" title="78.3设置Zookeeper依赖关系">第78.3节“设置Zookeeper依赖关系”</a></li><li class="listitem"><a class="xref" href="#spring-cloud-zookeeper-dependencies-configuring" title="78.4配置Spring Cloud Zookeeper依赖关系">第78.4节“配置Spring Cloud Zookeeper依赖关系”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-zookeeper-dependencies-using" href="#spring-cloud-zookeeper-dependencies-using"></a> 78.1使用Zookeeper依赖关系</h2></div></div></div><p>Spring Cloud Zookeeper使您可以将应用程序的依赖项作为属性提供。作为依赖项，您可以了解在Zookeeper中注册的其他应用程序，以及您希望通过<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign" target="_top">Feign</a> （REST客户端生成器）和<a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon" target="_top">Spring</a>调用的其他应用程序。 <a class="link" href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon" target="_top"><code class="literal">RestTemplate</code></a> 。</p><p>您还可以使用Zookeeper依赖关系观察器功能来控制和监视依赖关系的状态。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-zookeeper-dependencies-activating" href="#spring-cloud-zookeeper-dependencies-activating"></a> 78.2激活Zookeeper依赖关系</h2></div></div></div><p>包括对<code class="literal">org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</code>启用自动配置以设置Spring Cloud Zookeeper依赖关系。即使您在属性中提供了依赖关系，也可以关闭依赖关系。为此，请设置<code class="literal">spring.cloud.zookeeper.dependency.enabled</code>属性为false（默认为<code class="literal">true</code> ）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-zookeeper-dependencies-setting-up" href="#spring-cloud-zookeeper-dependencies-setting-up"></a> 78.3设置Zookeeper依赖关系</h2></div></div></div><p>考虑下面的依赖关系表示示例：</p><p><b>application.yml。</b>
</p><pre class="programlisting">spring.application.name: yourServiceName
spring.cloud.zookeeper:
  dependencies:
    newsletter:
      path: /path/where/newsletter/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.newsletter.$version+json
      version: v1
      headers:
        header1:
            - value1
        header2:
            - value2
      required: false
      stubs: org.springframework:foo:stubs
    mailing:
      path: /path/where/mailing/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.mailing.$version+json
      version: v1
      required: true</pre><p>
</p><p>接下来的几节将逐一介绍依赖关系的每个部分。根属性名称是<code class="literal">spring.cloud.zookeeper.dependencies</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-zookeeper-dependencies-setting-up-aliases" href="#spring-cloud-zookeeper-dependencies-setting-up-aliases"></a> 78.3.1别名</h3></div></div></div><p>在root属性下，您必须将每个依赖项表示为别名。这是由于Ribbon的约束所致，它要求将应用程序ID放在URL中。因此，您无法通过任何复杂的路径，例如<code class="literal">/myApp/myRoute/name</code> ）。别名是您使用的名称，而不是<code class="literal">serviceId</code>对于<code class="literal">DiscoveryClient</code> ， <code class="literal">Feign</code> ， 要么<code class="literal">RestTemplate</code> 。</p><p>在前面的示例中，别名为<code class="literal">newsletter</code>和<code class="literal">mailing</code> 。以下示例显示了伪装用法与<code class="literal">newsletter</code>别名：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@FeignClient("newsletter")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> NewsletterService {
        <em><span class="hl-annotation" style="color: gray">@RequestMapping(method = RequestMethod.GET, value = "/newsletter")</span></em>
        String getNewsletters();
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_path" href="#_path"></a> 78.3.2路径</h3></div></div></div><p>路径由<code class="literal">path</code> YAML属性，是在Zookeeper下注册依赖项的路径。如上<a class="link" href="#spring-cloud-zookeeper-dependencies-setting-up-aliases" title="78.3.1别名">一节所述</a> ，Ribbon在URL上运行。结果，该路径不符合其要求。这就是为什么Spring Cloud Zookeeper将别名映射到正确的路径。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_load_balancer_type" href="#_load_balancer_type"></a> 78.3.3负载均衡器类型</h3></div></div></div><p>负载均衡器的类型表示为<code class="literal">loadBalancerType</code> YAML属性。</p><p>如果您知道在调用此特定依赖项时必须应用哪种负载平衡策略，则可以在YAML文件中提供它，并自动应用它。您可以选择以下负载平衡策略之一：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">STICKY：选择后，将始终调用该实例。</li><li class="listitem">随机：随机选择一个实例。</li><li class="listitem">ROUND_ROBIN：反复遍历实例。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_content_type_template_and_version" href="#_content_type_template_and_version"></a> 78.3.4 <code class="literal">Content-Type</code>模板和版本</h3></div></div></div><p>的<code class="literal">Content-Type</code>模板和版本由<code class="literal">contentTypeTemplate</code>和<code class="literal">version</code> YAML属性。</p><p>如果您在<code class="literal">Content-Type</code>标头中，您不想将此标头添加到每个请求中。另外，如果您要调用API的新版本，则不想在代码中漫游以提高API版本。因此，您可以提供<code class="literal">contentTypeTemplate</code>特别的<code class="literal">$version</code>占位符。该占位符将由<code class="literal">version</code> YAML属性。考虑以下示例<code class="literal">contentTypeTemplate</code> ：</p><pre class="screen">application/vnd.newsletter.$version+json</pre><p>进一步考虑以下<code class="literal">version</code> ：</p><pre class="screen">v1</pre><p>的结合<code class="literal">contentTypeTemplate</code>和版本导致创建一个<code class="literal">Content-Type</code>每个请求的标头，如下所示：</p><pre class="screen">application/vnd.newsletter.v1+json</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_default_headers" href="#_default_headers"></a> 78.3.5默认标题</h3></div></div></div><p>默认标题由<code class="literal">headers</code>在YAML中映射。</p><p>有时，每次对依赖项的调用都需要设置一些默认头。要在代码中不要这样做，可以在YAML文件中进行设置，如以下示例所示<code class="literal">headers</code>部分：</p><pre class="programlisting">headers:
    Accept:
        - text/html
        - application/xhtml+xml
    Cache-Control:
        - no-cache</pre><p>那<code class="literal">headers</code>部分导致添加<code class="literal">Accept</code>和<code class="literal">Cache-Control</code>标头，其中包含HTTP请求中相应的值列表。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_required_dependencies" href="#_required_dependencies"></a> 78.3.6所需的依赖关系</h3></div></div></div><p>所需的依赖项表示为<code class="literal">required</code> YAML中的属性。</p><p>如果在应用程序启动时需要建立依赖关系之一，则可以设置<code class="literal">required: true</code> YAML文件中的属性。</p><p>如果您的应用程序在启动期间无法本地化所需的依赖项，则会引发异常，并且Spring Context无法设置。换句话说，如果所需的依赖项未在Zookeeper中注册，则您的应用程序将无法启动。</p><p>您可以<a class="link" href="#spring-cloud-zookeeper-dependency-watcher-presence-checker" title="79.3使用状态检查器">在本文档的后面部分</a>阅读有关Spring Cloud Zookeeper在线状态检查器的更多信息。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_stubs" href="#_stubs"></a> 78.3.7存根</h3></div></div></div><p>您可以提供一个冒号分隔的包含依赖项存根的JAR路径，如以下示例所示：</p><p><code class="literal">stubs: org.springframework:myApp:stubs</code></p><p>哪里：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">org.springframework</code>是个<code class="literal">groupId</code> 。</li><li class="listitem"><code class="literal">myApp</code>是个<code class="literal">artifactId</code> 。</li><li class="listitem"><code class="literal">stubs</code>是分类器。（注意<code class="literal">stubs</code>是默认值。）</li></ul></div><p>因为<code class="literal">stubs</code>是默认分类器，前面的示例等于以下示例：</p><p><code class="literal">stubs: org.springframework:myApp</code></p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-zookeeper-dependencies-configuring" href="#spring-cloud-zookeeper-dependencies-configuring"></a> 78.4配置Spring Cloud Zookeeper依赖关系</h2></div></div></div><p>您可以设置以下属性来启用或禁用部分Zookeeper依赖关系功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">spring.cloud.zookeeper.dependencies</code>注意：如果不设置此属性，则不能使用Zookeeper依赖关系。</li><li class="listitem"><code class="literal">spring.cloud.zookeeper.dependency.ribbon.enabled</code> （默认情况下启用）：功能区需要显式全局配置或特定的依赖项配置。通过启用此属性，可以实现运行时负载平衡策略解析，并且您可以使用<code class="literal">loadBalancerType</code> Zookeeper依赖关系部分。需要此属性的配置具有以下实现<code class="literal">LoadBalancerClient</code>委托给<code class="literal">ILoadBalancer</code>在下一个项目符号中介绍。</li><li class="listitem"><code class="literal">spring.cloud.zookeeper.dependency.ribbon.loadbalancer</code> （默认情况下启用）：由于有了此属性，自定义<code class="literal">ILoadBalancer</code>知道传递给Ribbon的URI部分实际上可能是必须在Zookeeper中解析为正确路径的别名。没有此属性，您将无法在嵌套路径下注册应用程序。</li><li class="listitem"><code class="literal">spring.cloud.zookeeper.dependency.headers.enabled</code> （默认启用）：此属性注册一个<code class="literal">RibbonClient</code>如Dependency配置所示，它会自动在其标题后附加适当的标题和内容类型。没有此设置，这两个参数将不起作用。</li><li class="listitem"><code class="literal">spring.cloud.zookeeper.dependency.resttemplate.enabled</code> （默认情况下启用）：启用后，此属性会修改<code class="literal">@LoadBalanced</code> -带注释<code class="literal">RestTemplate</code>这样就可以传递标头和内容类型以及在依赖项配置中设置的版本。没有此设置，这两个参数将不起作用。</li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-dependency-watcher" href="#spring-cloud-zookeeper-dependency-watcher"></a> 79。Spring Cloud Zookeeper依赖性观察程序</h2></div></div></div><p>Dependency Watcher机制使您可以将侦听器注册到您的依赖项。该功能实际上是<code class="literal">Observator</code>图案。当依赖项发生变化时，其状态（变为UP或DOWN）可以应用一些自定义逻辑。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_activating_2" href="#_activating_2"></a> 79.1激活</h2></div></div></div><p>需要启用Spring Cloud Zookeeper依赖关系功能，才能使用Dependency Watcher机制。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_a_listener" href="#_registering_a_listener"></a> 79.2注册侦听器</h2></div></div></div><p>要注册一个侦听器，您必须实现一个名为<code class="literal">org.springframework.cloud.zookeeper.discovery.watcher.DependencyWatcherListener</code>并将其注册为bean。该接口为您提供了一种方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> stateChanged(String dependencyName, DependencyState newState);</pre><p>如果您要注册特定依赖项的侦听器，则<code class="literal">dependencyName</code>将是您具体实施的区分因素。 <code class="literal">newState</code>向您提供有关您的依赖关系是否已更改为<code class="literal">CONNECTED</code>要么<code class="literal">DISCONNECTED</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="spring-cloud-zookeeper-dependency-watcher-presence-checker" href="#spring-cloud-zookeeper-dependency-watcher-presence-checker"></a> 79.3使用状态检查器</h2></div></div></div><p>依赖关系监视程序绑定的是称为状态检查器的功能。它使您可以在应用程序启动时提供自定义行为，以根据依赖项的状态做出反应。</p><p>抽象的默认实现<code class="literal">org.springframework.cloud.zookeeper.discovery.watcher.presence.DependencyPresenceOnStartupVerifier</code>类是<code class="literal">org.springframework.cloud.zookeeper.discovery.watcher.presence.DefaultDependencyPresenceOnStartupVerifier</code> ，其工作方式如下。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">如果依赖性标记为我们<code class="literal">required</code>并且不在Zookeeper中，当您的应用程序启动时，它会引发异常并关闭。</li><li class="listitem">如果不依赖<code class="literal">required</code> ， <code class="literal">org.springframework.cloud.zookeeper.discovery.watcher.presence.LogMissingDependencyChecker</code>记录缺少依赖项<code class="literal">WARN</code>水平。</li></ol></div><p>因为<code class="literal">DefaultDependencyPresenceOnStartupVerifier</code>仅当没有类型的bean时才注册<code class="literal">DependencyPresenceOnStartupVerifier</code> ，此功能可以被覆盖。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-zookeeper-config" href="#spring-cloud-zookeeper-config"></a> 80。Zookeeper的分布式配置</h2></div></div></div><p>Zookeeper提供了一个<a class="link" href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace" target="_top">分层的名称空间</a> ，该<a class="link" href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace" target="_top">名称空间</a>使客户端可以存储任意数据，例如配置数据。Spring Cloud Zookeeper Config是<a class="link" href="https://github.com/spring-cloud/spring-cloud-config" target="_top">Config Server和Client</a>的替代方案。配置是在特殊的<span class="quote">“ <span class="quote">引导</span> ”</span>阶段加载到Spring环境。配置存储在<code class="literal">/config</code>默认情况下命名空间。多<code class="literal">PropertySource</code>根据应用程序名称和活动配置文件创建实例，以模拟解析属性的Spring Cloud Config顺序。例如，名称为<code class="literal">testApp</code>并与<code class="literal">dev</code>配置文件具有为其创建的以下属性源：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">config/testApp,dev</code></li><li class="listitem"><code class="literal">config/testApp</code></li><li class="listitem"><code class="literal">config/application,dev</code></li><li class="listitem"><code class="literal">config/application</code></li></ul></div><p>最具体的属性来源在顶部，最不具体的属性在底部。中的属性<code class="literal">config/application</code>名称空间适用于所有使用zookeeper进行配置的应用程序。中的属性<code class="literal">config/testApp</code>名称空间仅适用于名为的服务实例<code class="literal">testApp</code> 。</p><p>当前在启动应用程序时读取配置。发送HTTP <code class="literal">POST</code>请求<code class="literal">/refresh</code>导致重新加载配置。当前未实现监视配置名称空间（Zookeeper支持）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_activating_3" href="#_activating_3"></a> 80.1激活</h2></div></div></div><p>包括对<code class="literal">org.springframework.cloud:spring-cloud-starter-zookeeper-config</code>启用自动配置以设置Spring Cloud Zookeeper Config。</p><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>使用Zookeeper 3.4版时，您需要按<a class="link" href="#spring-cloud-zookeeper-install" title="74。安装Zookeeper">此处</a>所述更改包含依赖项的方式。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customizing_2" href="#_customizing_2"></a> 80.2定制</h2></div></div></div><p>可以通过设置以下属性来自定义Zookeeper Config：</p><p><b>bootstrap.yml。</b>
</p><pre class="programlisting">spring:
  cloud:
    zookeeper:
      config:
        enabled: true
        root: configuration
        defaultContext: apps
        profileSeparator: '::'</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code> ：将此值设置为<code class="literal">false</code>禁用Zookeeper Config。</li><li class="listitem"><code class="literal">root</code> ：设置配置名称。</li><li class="listitem"><code class="literal">defaultContext</code> ：设置所有应用程序使用的名称。</li><li class="listitem"><code class="literal">profileSeparator</code> ：设置分隔符的值，该分隔符用于在带有配置文件的属性源中分隔配置文件名称。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_access_control_lists_acls" href="#_access_control_lists_acls"></a> 80.3访问控制列表（ACL）</h2></div></div></div><p>您可以通过以下方式添加Zookeeper ACL的身份验证信息： <code class="literal">addAuthInfo</code>方法<code class="literal">CuratorFramework</code> bean 。实现此目的的一种方法是提供自己的<code class="literal">CuratorFramework</code> bean，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@BoostrapConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomCuratorFrameworkConfig {

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> CuratorFramework curatorFramework() {
    CuratorFramework curator = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> CuratorFramework();
    curator.addAuthInfo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"digest"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user:password"</span>.getBytes());
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> curator;
  }

}</pre><p>咨询<a class="link" href="https://github.com/spring-cloud/spring-cloud-zookeeper/blob/master/spring-cloud-zookeeper-core/src/main/java/org/springframework/cloud/zookeeper/ZookeeperAutoConfiguration.java" target="_top">ZookeeperAutoConfiguration类</a>以了解如何<code class="literal">CuratorFramework</code> bean的默认配置。</p><p>或者，您可以从依赖现有类的类中添加凭据<code class="literal">CuratorFramework</code> bean，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@BoostrapConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DefaultCuratorFrameworkConfig {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ZookeeperConfig(CuratorFramework curator) {
    curator.addAuthInfo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"digest"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user:password"</span>.getBytes());
  }

}</pre><p>此bean的创建必须在boostrapping阶段进行。您可以使用以下注释来注册要在此阶段运行的配置类： <code class="literal">@BootstrapConfiguration</code>并将它们包含在以逗号分隔的列表中，您将该列表设置为<code class="literal">org.springframework.cloud.bootstrap.BootstrapConfiguration</code>物业<code class="literal">resources/META-INF/spring.factories</code>文件，如以下示例所示：</p><p><b>资源/META-INF/spring.factories。</b>
</p><pre class="screen">org.springframework.cloud.bootstrap.BootstrapConfiguration=\
my.project.CustomCuratorFrameworkConfig,\
my.project.DefaultCuratorFrameworkConfig</pre><p>
</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_security" href="#_spring_cloud_security"></a>第十一部分。 Spring Cloud安全性</h1></div></div></div><div class="partintro"><div></div><p>Spring Cloud Security提供了一组原语，用于以最少的麻烦构建安全的应用程序和服务。可以在外部（或中央）进行大量配置的声明性模型，通常可以通过中央身份管理服务来实现大型的，相互协作的远程组件系统。在Cloud Foundry等服务平台中使用它也非常容易。在Spring Boot和Spring Security OAuth2的基础上，我们可以快速创建实现通用模式（如单点登录，令牌中继和令牌交换）的系统。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a class="link" href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/asciidoc" target="_top">github</a>的项目中找到源代码和问题跟踪程序。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_quickstart" href="#_quickstart"></a> 81。快速开始</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_oauth2_single_sign_on" href="#_oauth2_single_sign_on"></a> 81.1 OAuth2单点登录</h2></div></div></div><p>这是一个具有HTTP Basic身份验证和单个用户帐户的Spring Cloud“ Hello World”应用程序：</p><p><b>app.groovy。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Grab('spring-boot-starter-security')</span></em>
<em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

  <em><span class="hl-annotation" style="color: gray">@RequestMapping('/')</span></em>
  String home() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Hello World'</span>
  }

}</pre><p>
</p><p>您可以使用<code class="literal">spring run app.groovy</code>并查看日志中的密码（用户名是“ user”）。到目前为止，这只是Spring Boot应用程序的默认设置。</p><p>这是带有OAuth2 SSO的Spring Cloud应用程序：</p><p><b>app.groovy。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableOAuth2Sso</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

  <em><span class="hl-annotation" style="color: gray">@RequestMapping('/')</span></em>
  String home() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Hello World'</span>
  }

}</pre><p>
</p><p>指出不同？该应用程序实际上将与上一个应用程序完全相同，因为它尚不知道它是OAuth2凭据。</p><p>您可以很容易地在github中注册一个应用程序，因此如果您想在自己的域上使用生产应用程序，请尝试使用该应用程序。如果您愿意在localhost：8080上进行测试，请在应用程序配置中设置以下属性：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">security</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  oauth2</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    client</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      clientId</span>: bd1c0a783ccdd1c9b9e4
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      clientSecret</span>: <span class="hl-number">1</span>a9030fbca47a5b2c28e92f19050bb77824b5ad1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      accessTokenUri</span>: https://github.com/login/oauth/access_token
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      userAuthorizationUri</span>: https://github.com/login/oauth/authorize
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      clientAuthenticationScheme</span>: form
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    resource</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      userInfoUri</span>: https://api.github.com/user
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      preferTokenInfo</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre><p>
</p><p>运行上面的应用程序，它将重定向到github进行授权。如果您已经登录github，您甚至不会注意到它已通过身份验证。仅当您的应用程序在端口8080上运行时，这些凭据才有效。</p><p>要限制客户端在获取访问令牌时要求的范围，可以设置<code class="literal">security.oauth2.client.scope</code> （逗号分隔或YAML中的数组）。默认情况下，作用域为空，并且由授权服务器决定默认值是什么，通常取决于它所拥有的客户端注册中的设置。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>上面的示例都是Groovy脚本。如果要用Java（或Groovy）编写相同的代码，则需要将Spring Security OAuth2添加到类路径中（例如，参见<a class="link" href="https://github.com/spring-cloud-samples/sso" target="_top">此处</a>的<a class="link" href="https://github.com/spring-cloud-samples/sso" target="_top">示例</a> ）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_oauth2_protected_resource" href="#_oauth2_protected_resource"></a> 81.2 OAuth2受保护的资源</h2></div></div></div><p>您想使用OAuth2令牌保护API资源吗？这是一个简单的示例（与上面的客户端配对）：</p><p><b>app.groovy。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Grab('spring-cloud-starter-security')</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableResourceServer</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

  <em><span class="hl-annotation" style="color: gray">@RequestMapping('/')</span></em>
  def home() {
    [message: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Hello World'</span>]
  }

}</pre><p>
</p><p>和</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">security</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  oauth2</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    resource</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      userInfoUri</span>: https://api.github.com/user
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      preferTokenInfo</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre><p>
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_more_detail" href="#_more_detail"></a> 82。更多详情</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_single_sign_on" href="#_single_sign_on"></a> 82.1单点登录</h2></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>所有OAuth2 SSO和资源服务器功能已在1.3版中移至Spring Boot。您可以在<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_top">Spring Boot用户指南中</a>找到文档。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_token_relay" href="#_token_relay"></a> 82.2令牌中继</h2></div></div></div><p>令牌中继是OAuth2使用者充当客户端并将传入令牌转发到传出资源请求的地方。使用者可以是纯客户端（如SSO应用程序）或资源服务器。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_client_token_relay_in_spring_cloud_gateway" href="#_client_token_relay_in_spring_cloud_gateway"></a> 82.2.1 Spring Cloud Gateway中的客户端令牌中继</h3></div></div></div><p>如果您的应用程序还具有<a class="link" href="https://cloud.spring.io/spring-cloud-static/current/single/spring-cloud.html#_spring_cloud_gateway" target="_top">Spring Cloud Gateway</a>嵌入式反向代理，则可以要求它向下游转发OAuth2访问令牌到它正在代理的服务。因此，可以像下面这样简单地增强上面的SSO应用程序：</p><p><b>App.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> TokenRelayGatewayFilterFactory filterFactory;

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> builder.routes()
            .route(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"resource"</span>, r -&gt; r.path(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>)
                    .filters(f -&gt; f.filter(filterFactory.apply()))
                    .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:9000"</span>))
            .build();
}</pre><p>
</p><p>或这个</p><p><b>application.yaml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: resource
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://localhost:<span class="hl-number">9000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/resource
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - TokenRelay</span>=</pre><p>
</p><p>并且它将（除了登录用户并获取令牌之外）还将身份验证令牌传递给服务下游（在这种情况下， <code class="literal">/resource</code> ）。</p><p>要为Spring Cloud Gateway启用此功能，请添加以下依赖项</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">org.springframework.boot:spring-boot-starter-oauth2-client</code></li><li class="listitem"><code class="literal">org.springframework.cloud:spring-cloud-starter-security</code></li></ul></div><p>它是如何工作的？<a class="link" href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/gateway/TokenRelayGatewayFilterFactory.java" target="_top">过滤器</a>从当前经过身份验证的用户中提取访问令牌，并将其放入下游请求的请求标头中。</p><p>对于一个完整的工作示例看到<a class="link" href="https://github.com/spring-cloud-samples/sample-gateway-oauth2login" target="_top">这个项目</a> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认实现<code class="literal">ReactiveOAuth2AuthorizedClientService</code>被...使用<code class="literal">TokenRelayGatewayFilterFactory</code>使用内存中的数据存储。您将需要提供自己的实现<code class="literal">ReactiveOAuth2AuthorizedClientService</code>如果您需要更强大的解决方案。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_client_token_relay" href="#_client_token_relay"></a> 82.2.2客户端令牌中继</h3></div></div></div><p>如果您的应用是面向OAuth2客户端的用户（即已声明<code class="literal">@EnableOAuth2Sso</code>要么<code class="literal">@EnableOAuth2Client</code> ），然后有一个<code class="literal">OAuth2ClientContext</code>在Spring Boot的请求范围内。您可以创建自己的<code class="literal">OAuth2RestTemplate</code>从这个上下文和自动连线<code class="literal">OAuth2ProtectedResourceDetails</code> ，然后上下文将始终将访问令牌转发到下游，如果过期，访问令牌也会自动刷新。（这些是Spring Security和Spring Boot的功能。）</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Boot（1.4.1）不会创建<code class="literal">OAuth2ProtectedResourceDetails</code>如果您正在使用，则自动<code class="literal">client_credentials</code>令牌。在这种情况下，您需要创建自己的<code class="literal">ClientCredentialsResourceDetails</code>并配置它<code class="literal">@ConfigurationProperties("security.oauth2.client")</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_client_token_relay_in_zuul_proxy" href="#_client_token_relay_in_zuul_proxy"></a> 82.2.3 Zuul代理中的客户端令牌中继</h3></div></div></div><p>如果您的应用程序还具有<a class="link" href="https://cloud.spring.io/spring-cloud.html#netflix-zuul-reverse-proxy" target="_top">Spring Cloud Zuul</a>嵌入式反向代理（使用<code class="literal">@EnableZuulProxy</code> ），则可以要求其将OAuth2访问令牌下游转发到它正在代理的服务。因此，可以像下面这样简单地增强上面的SSO应用程序：</p><p><b>app.groovy。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Controller</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableOAuth2Sso</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableZuulProxy</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

}</pre><p>
</p><p>并且它将（除了登录用户并获取令牌外）还将身份验证令牌下游传递给<code class="literal">/proxy/*</code>服务。如果这些服务是通过<code class="literal">@EnableResourceServer</code>那么他们将在正确的标头中获得有效的令牌。</p><p>它是如何工作的？的<code class="literal">@EnableOAuth2Sso</code>注解引入<code class="literal">spring-cloud-starter-security</code> （您可以在传统应用中手动执行此操作），然后触发一些自动配置<code class="literal">ZuulFilter</code> ，因为Zuul在类路径上（通过<code class="literal">@EnableZuulProxy</code> ）。<a class="link" href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/OAuth2TokenRelayFilter.java" target="_top">过滤器</a>仅从当前已认证的用户中提取访问令牌，并将其放入下游请求的请求标头中。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Boot不会创建一个<code class="literal">OAuth2RestOperations</code>自动需要<code class="literal">refresh_token</code> 。在这种情况下，您需要创建自己的<code class="literal">OAuth2RestOperations</code>所以<code class="literal">OAuth2TokenRelayFilter</code>可以根据需要刷新令牌。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_resource_server_token_relay" href="#_resource_server_token_relay"></a> 82.2.4资源服务器令牌中继</h3></div></div></div><p>如果您的应用有<code class="literal">@EnableResourceServer</code>您可能需要将传入令牌下游中继到其他服务。如果您使用<code class="literal">RestTemplate</code>联系下游服务，那么这只是如何在正确的上下文中创建模板的问题。</p><p>如果您的服务使用<code class="literal">UserInfoTokenServices</code>验证传入令牌（即它正在使用<code class="literal">security.oauth2.user-info-uri</code>配置），那么您只需创建一个<code class="literal">OAuth2RestTemplate</code>使用自动接线<code class="literal">OAuth2ClientContext</code> （它将在到达后端代码之前由身份验证过程填充）。同样（使用Spring Boot 1.4），您可以注入一个<code class="literal">UserInfoRestTemplateFactory</code>抓住它<code class="literal">OAuth2RestTemplate</code>在您的配置中。例如：</p><p><b>MyConfiguration.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> OAuth2RestTemplate restTemplate(UserInfoRestTemplateFactory factory) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> factory.getUserInfoRestTemplate();
}</pre><p>
</p><p>其余模板将具有相同的<code class="literal">OAuth2ClientContext</code> （请求范围）供身份验证过滤器使用，因此您可以使用它来发送具有相同访问令牌的请求。</p><p>如果您的应用未使用<code class="literal">UserInfoTokenServices</code>但仍然是客户（即它声明<code class="literal">@EnableOAuth2Client</code>要么<code class="literal">@EnableOAuth2Sso</code> ），然后使用Spring Security Cloud <code class="literal">OAuth2RestOperations</code>用户从<code class="literal">@Autowired</code><code class="literal">OAuth2Context</code>还将转发令牌。默认情况下，此功能作为MVC处理程序拦截器实现，因此仅在Spring MVC中有效。如果您不使用MVC，则可以使用自定义过滤器或AOP拦截器来包装<code class="literal">AccessTokenContextRelay</code>提供相同的功能。</p><p>这是一个基本示例，展示了如何使用在其他位置创建的自动关联的休息模板（“ foo.com”是接受与周围应用程序相同的令牌的资源服务器）：</p><p><b>MyController.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> OAuth2RestOperations restTemplate;

<em><span class="hl-annotation" style="color: gray">@RequestMapping("/relay")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String relay() {
    ResponseEntity&lt;String&gt; response =
      restTemplate.getForEntity(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://foo.com/bar"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Success! ("</span> + response.getBody() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">")"</span>;
}</pre><p>
</p><p>如果您不希望转发令牌（这是一个正确的选择，因为您可能想扮演自己的角色，而不是发送令牌的客户端），那么您只需要创建自己的令牌即可<code class="literal">OAuth2Context</code>而不是自动装配默认值。</p><p>假冒客户还会选择使用<code class="literal">OAuth2ClientContext</code>如果有的话，那么他们还应该在任何<code class="literal">RestTemplate</code>将。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_configuring_authentication_downstream_of_a_zuul_proxy" href="#_configuring_authentication_downstream_of_a_zuul_proxy"></a> 83。配置Zuul代理的下游身份验证</h2></div></div></div><p>您可以控制授权行为的下游<code class="literal">@EnableZuulProxy</code>通过<code class="literal">proxy.auth.*</code>设置。例：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">proxy</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  auth</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      customers</span>: oauth2
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      stores</span>: passthru
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      recommendations</span>: none</pre><p>
</p><p>在此示例中，“客户”服务获取OAuth2令牌中继，“商店”服务获取直通（授权标头仅向下游传递），而“推荐”服务则删除其授权标头。默认行为是在有令牌可用时进行令牌中继，否则通过。</p><p>有关完整的详细信息，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/ProxyAuthenticationProperties" target="_top">ProxyAuthenticationProperties</a> 。</p></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_for_cloud_foundry" href="#_spring_cloud_for_cloud_foundry"></a>第十二部分。 Spring Cloud for Cloud Foundry</h1></div></div></div><div class="partintro"><div></div><p>Spring Cloud为Cloudfoundry可以很容易地运行<a class="link" href="https://github.com/spring-cloud" target="_top">春季云</a>中的应用程序<a class="link" href="https://github.com/cloudfoundry" target="_top">的Cloud Foundry</a> （平台即服务）。Cloud Foundry具有“服务”的概念，即您“绑定”到应用程序的中间件，本质上为它提供了一个包含凭证的环境变量（例如，用于服务的位置和用户名）。</p><p>的<code class="literal">spring-cloud-cloudfoundry-commons</code>该模块可配置基于Reactor的Cloud Foundry Java客户端v 3.0，并且可以独立使用。</p><p>的<code class="literal">spring-cloud-cloudfoundry-web</code>该项目为Cloud Foundry中的Webapp的某些增强功能提供了基本支持：自动绑定到单点登录服务，并可以选择启用粘性路由进行发现。</p><p>的<code class="literal">spring-cloud-cloudfoundry-discovery</code>该项目提供了Spring Cloud Commons的实现<code class="literal">DiscoveryClient</code>这样你就可以<code class="literal">@EnableDiscoveryClient</code>并提供您的凭据<code class="literal">spring.cloud.cloudfoundry.discovery.[username,password]</code> （也<code class="literal">*.url</code>如果您没有连接到<a class="link" href="https://run.pivotal.io" target="_top">Pivotal Web Services</a> ），则可以使用<code class="literal">DiscoveryClient</code>直接或通过<code class="literal">LoadBalancerClient</code> 。</p><p>首次使用它时，发现客户端可能会变慢，原因是它必须从Cloud Foundry获取访问令牌。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_discovery" href="#_discovery"></a> 84。发现</h2></div></div></div><p>这是带有Cloud Foundry发现的Spring Cloud应用程序：</p><p><b>app.groovy。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Grab('org.springframework.cloud:spring-cloud-cloudfoundry')</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableDiscoveryClient</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  DiscoveryClient client

  <em><span class="hl-annotation" style="color: gray">@RequestMapping('/')</span></em>
  String home() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Hello from '</span> + client.getLocalServiceInstance()
  }

}</pre><p>
</p><p>如果运行时没有任何服务绑定：</p><pre class="screen">$ spring jar app.jar app.groovy
$ cf push -p app.jar</pre><p>它将在首页中显示其应用名称。</p><p>的<code class="literal">DiscoveryClient</code>可以根据进行身份验证的凭据列出一个空间中的所有应用程序，其中该空间默认为客户端正在其中运行的应用程序（如果有）。如果未配置组织和空间，则它们将根据Cloud Foundry中用户的配置文件默认设置。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_single_sign_on_2" href="#_single_sign_on_2"></a> 85。单点登录</h2></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>所有OAuth2 SSO和资源服务器功能已在1.3版中移至Spring Boot。您可以在<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_top">Spring Boot用户指南中</a>找到文档。</p></td></tr></tbody></table></div><p>该项目提供了从CloudFoundry服务凭据到Spring Boot功能的自动绑定。例如，如果您有一个名为“ sso”的CloudFoundry服务，其凭证包含“ client_id”，“ client_secret”和“ auth_domain”，它将自动绑定到您通过以下方式启用的Spring OAuth2客户端<code class="literal">@EnableOAuth2Sso</code> （来自Spring Boot）。服务名称可以使用<code class="literal">spring.oauth2.sso.serviceId</code> 。</p></div></div><div class="part"><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_contract" href="#_spring_cloud_contract"></a>第十三部分。Spring Cloud Contract</h1></div></div></div><div class="partintro"><div></div><p><span class="emphasis"><em>文档作者：Adam Dudczak，MathiasDüsterhöft，Marcin Grzejszczak，Dennis Kieselhorst，JakubKubryński，Karol Lassak，Olga Maciaszek-Sharma，MariuszSmykuła，Dave Syer，Jay Bryant</em></span></p><p>格林威治。SR4</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_2" href="#_spring_cloud_contract_2"></a> 86。Spring Cloud Contract</h2></div></div></div><p>在将新功能推到分布式系统中的新应用程序或服务时，您需要信心。该项目为Spring应用程序中的消费者驱动的合同和服务模式提供了支持（用于HTTP和基于消息的交互），涵盖了编写测试，将其作为资产发布以及断言生产者和消费者保持合同的一系列选项。 。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_verifier_introduction" href="#_spring_cloud_contract_verifier_introduction"></a> 87。Spring Cloud Contract Verifier简介</h2></div></div></div><p>Spring Cloud Contract Verifier支持基于JVM的应用程序的消费者驱动合同（CDC）开发。它将TDD移至软件体系结构级别。</p><p>Spring Cloud Contract Verifier随附<span class="emphasis"><em>合同定义语言</em></span> （CDL）。合同定义用于产生以下资源：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">在客户端代码上进行集成测试（ <span class="emphasis"><em>客户端测试</em></span> ）时，WireMock将使用JSON存根定义。测试代码仍然必须是手工编写的，并且测试数据是由Spring Cloud Contract Verifier生成的。</li><li class="listitem">消息传递路由（如果您正在使用消息传递服务）。我们与Spring Integration，Spring Cloud Stream，Spring AMQP和Apache Camel集成。您还可以设置自己的集成。</li><li class="listitem">验收测试（在JUnit 4，JUnit 5或Spock中）用于验证API的服务器端实现是否符合合同（ <span class="emphasis"><em>服务器测试</em></span> ）。完整的测试由Spring Cloud Contract Verifier生成。</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_history" href="#_history"></a> 87.1历史</h2></div></div></div><p>在成为Spring Cloud Contract之前，该项目称为<a class="link" href="https://github.com/Codearte/accurest" target="_top">Accurest</a> 。它是由（ <a class="link" href="https://github.com/Codearte" target="_top">Codearte）的</a> <a class="link" href="https://twitter.com/mgrzejszczak" target="_top">Marcin Grzejszczak</a>和<a class="link" href="https://twitter.com/jkubrynski" target="_top">Jakub Kubrynski</a>创建的。</p><p>的<code class="literal">0.1.0</code>发布于2015年1月26日发布，并在<code class="literal">1.0.0</code>发布于2016年2月29日。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_why_a_contract_verifier" href="#_why_a_contract_verifier"></a> 87.2为什么要使用合同验证者？</h2></div></div></div><p>假设我们有一个包含多个微服务的系统：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/2.1.x/docs/src/main/asciidoc/images/Deps.png" alt="微服务架构"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_testing_issues" href="#_testing_issues"></a> 87.2.1测试问题</h3></div></div></div><p>如果我们想在左上角测试该应用程序以确定它是否可以与其他服务通信，则可以执行以下两项操作之一：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">部署所有微服务并执行端到端测试。</li><li class="listitem">在单元/集成测试中模拟其他微服务。</li></ul></div><p>两者都有优点，也有很多缺点。</p><p><span class="strong"><strong>部署所有微服务并执行端到端测试</strong></span></p><p>好处：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">模拟生产。</li><li class="listitem">测试服务之间的真实通信。</li></ul></div><p>缺点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">要测试一个微服务，我们必须部署6个微服务，几个数据库等。</li><li class="listitem">测试运行的环境被锁定为单个测试套件（其他人将无法同时运行测试）。</li><li class="listitem">他们需要很长时间才能运行。</li><li class="listitem">反馈在此过程中非常晚。</li><li class="listitem">他们很难调试。</li></ul></div><p><span class="strong"><strong>在单元/集成测试中模拟其他微服务</strong></span></p><p>好处：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">他们提供了非常快速的反馈。</li><li class="listitem">他们没有基础架构要求。</li></ul></div><p>缺点：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">服务的实现者创建的存根可能与现实无关。</li><li class="listitem">您可以通过测试并通过失败的生产。</li></ul></div><p>为了解决上述问题，创建了带有Stub Runner的Spring Cloud Contract Verifier。主要思想是为您提供非常快速的反馈，而无需建立整个微服务世界。如果使用存根，则仅需要应用程序直接使用的那些应用程序。</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/2.1.x/docs/src/main/asciidoc/images/Stubs2.png" alt="存根服务"></div></div><p>Spring Cloud Contract Verifier可确保您使用的存根是由您正在调用的服务创建的。另外，如果可以使用它们，则意味着它们已针对生产者方面进行了测试。简而言之，您可以信任这些存根。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_purposes" href="#_purposes"></a> 87.3目的</h2></div></div></div><p>带有Stub Runner的Spring Cloud Contract Verifier的主要目的是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">为了确保WireMock / Messaging存根（在开发客户端时使用）完全执行实际的服务器端实现。</li><li class="listitem">推广ATDD方法和微服务架构风格。</li><li class="listitem">提供一种发布合同更改的方法，该更改在双方立即可见。</li><li class="listitem">生成要在服务器端使用的样板测试代码。</li></ul></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Contract Verifier的目的不是开始在合同中编写业务功能。假设我们有一个欺诈检查的业务用例。如果某个用户可能出于100种不同的原因而成为欺诈行为，那么我们假设您将创建2个合同，其中一个用于肯定案件，一个用于否定案件。合同测试用于测试应用程序之间的合同，而不是模拟完整的行为。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_it_works" href="#_how_it_works"></a> 87.4工作原理</h2></div></div></div><p>本节探讨了具有Stub Runner的Spring Cloud Contract Verifier的工作方式。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-contract-verifier-intro-three-second-tour" href="#spring-cloud-contract-verifier-intro-three-second-tour"></a> 87.4.1三秒游</h3></div></div></div><p>这个非常简短的导览将介绍如何使用Spring Cloud Contract：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-contract-verifier-intro-three-second-tour-producer" title="在生产者方面">名为“在生产者端”的部分</a></li><li class="listitem"><a class="xref" href="#spring-cloud-contract-verifier-intro-three-second-tour-consumer" title="在消费者方面">“消费者方面”一节</a></li></ul></div><p>您可以<a class="link" href="#spring-cloud-contract-verifier-intro-three-minute-tour" title="87.4.2三分钟游">在这里</a>找到更长的行程。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-contract-verifier-intro-three-second-tour-producer" href="#spring-cloud-contract-verifier-intro-three-second-tour-producer"></a>在生产者方面</h4></div></div></div><p>要开始使用Spring Cloud Contract，请使用<code class="literal">REST/</code> Groovy DSL或YAML中表示的消息传递合同到合同目录，该目录由<code class="literal">contractsDslDir</code>属性。默认情况下是<code class="literal">$rootDir/src/test/resources/contracts</code> 。</p><p>然后将Spring Cloud Contract Verifier依赖项和插件添加到您的构建文件中，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-verifier<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>以下清单显示了如何添加插件，该插件应放在文件的build / plugins部分中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>跑步<code class="literal">./mvnw clean install</code>自动生成测试，以验证应用程序是否符合添加的合同。默认情况下，在以下条件下生成测试<code class="literal">org.springframework.cloud.contract.verifier.tests.</code> 。</p><p>由于尚不存在合同描述的功能的实现，因此测试失败。</p><p>要使它们通过，您必须添加处理HTTP请求或消息的正确实现。另外，您必须为自动生成的测试添加正确的基础测试类。该类由所有自动生成的测试扩展，并且应包含运行它们所需的所有设置（例如<code class="literal">RestAssuredMockMvc</code>控制器设置或消息传递测试设置）。</p><p>一旦实现和测试基类就位，测试就会通过，并且将应用程序和存根构件都构建并安装在本地Maven存储库中。现在可以合并更改，并且可以在在线存储库中发布应用程序和存根工件。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-contract-verifier-intro-three-second-tour-consumer" href="#spring-cloud-contract-verifier-intro-three-second-tour-consumer"></a>在消费者方面</h4></div></div></div><p><code class="literal">Spring Cloud Contract Stub Runner</code>可以在集成测试中使用，以获取正在运行的WireMock实例或模拟实际服务的消息传递路由。</p><p>为此，将依赖项添加到<code class="literal">Spring Cloud Contract Stub Runner</code> ，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-stub-runner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>您可以通过以下两种方式之一在Maven资源库中安装生产者端存根：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">通过检出生产者端存储库并添加合同并通过运行以下命令来生成存根：</p><pre class="programlisting">$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> local-http-server-repo
$ ./mvnw clean install -DskipTests</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>由于生产者方合同实施尚未到位，因此跳过了测试，因此自动生成的合同测试失败。</p></td></tr></tbody></table></div></li><li class="listitem"><p class="simpara">通过从远程存储库获取已经存在的生产者服务存根。为此，请将存根工件ID和工件存储库URL传递为<code class="literal">Spring Cloud Contract Stub Runner</code>属性，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ids</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'com.example:http-server-dsl:+:stubs:8080'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  repositoryRoot</span>: https://repo.spring.io/libs-snapshot</pre></li></ul></div><p>现在，您可以使用<code class="literal">@AutoConfigureStubRunner</code> 。在注释中，提供<code class="literal">group-id</code>和<code class="literal">artifact-id</code>的值<code class="literal">Spring Cloud Contract Stub Runner</code>为您运行协作者的存根，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment=WebEnvironment.NONE)</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"},
		stubsMode = StubRunnerProperties.StubsMode.LOCAL)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> LoanApplicationServiceTests {</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>使用<code class="literal">REMOTE</code><code class="literal">stubsMode</code>从在线存储库下载存根时，以及<code class="literal">LOCAL</code>进行离线工作。</p></td></tr></tbody></table></div><p>现在，在集成测试中，您可以接收预期由协作服务发出的HTTP响应或消息的存根版本。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spring-cloud-contract-verifier-intro-three-minute-tour" href="#spring-cloud-contract-verifier-intro-three-minute-tour"></a> 87.4.2三分钟游</h3></div></div></div><p>这个简短的导览将逐步介绍如何使用Spring Cloud Contract：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#spring-cloud-contract-verifier-intro-three-minute-tour-producer" title="在生产者方面">名为“在生产者端”的部分</a></li><li class="listitem"><a class="xref" href="#spring-cloud-contract-verifier-intro-three-minute-tour-consumer" title="在消费者方面">“消费者方面”一节</a></li></ul></div><p>您可以<a class="link" href="#spring-cloud-contract-verifier-intro-three-second-tour" title="87.4.1三秒游">在这里</a>找到更简短的导览。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-contract-verifier-intro-three-minute-tour-producer" href="#spring-cloud-contract-verifier-intro-three-minute-tour-producer"></a>在生产者方面</h4></div></div></div><p>开始使用<code class="literal">Spring Cloud Contract</code> ，使用添加文件<code class="literal">REST/</code> Groovy DSL或YAML中表示的消息传递合同到合同目录，该目录由<code class="literal">contractsDslDir</code>属性。默认情况下是<code class="literal">$rootDir/src/test/resources/contracts</code> 。</p><p>对于HTTP存根，合同定义了应为给定请求返回的响应类型（考虑到HTTP方法，URL，标头，状态码等）。下面的示例显示了Groovy DSL中的HTTP存根如何收缩：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> contracts

org.springframework.cloud.contract.spec.Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PUT'</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/fraudcheck'</span>
		body([
			   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"client.id"</span>: $(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{10}'</span>)),
			   loanAmount: <span class="hl-number">99999</span>
		])
		headers {
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
		}
	}
	response {
		status OK()
		body([
			   fraudCheckStatus: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>,
			   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"rejection.reason"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>
		])
		headers {
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
		}
	}
}</pre><p>YAML中表示的相同合同应类似于以下示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">request</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  method</span>: PUT
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  url</span>: /fraudcheck
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  body</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    "client.id"</span>: <span class="hl-number">1234567890</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    loanAmount</span>: <span class="hl-number">99999</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  headers</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    Content-Type</span>: application/json
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  matchers</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    body</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - path</span>: $.[<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'client.id'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        type</span>: by_regex
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        value</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{10}"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">response</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  status</span>: <span class="hl-number">200</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  body</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    fraudCheckStatus</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    "rejection.reason"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  headers</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    Content-Type</span>: application/json;charset=UTF-<span class="hl-number">8</span></pre><p>对于消息传递，可以定义：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">可以定义输入和输出消息（考虑发送消息的位置和位置，消息正文和标头）。</li><li class="listitem">收到消息后应调用的方法。</li><li class="listitem">调用时应触发消息的方法。</li></ul></div><p>以下示例显示了用Groovy DSL表示的骆驼消息传递协定：</p><pre class="programlisting">			def contractDsl = Contract.make {
				label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
				input {
					messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:delete'</span>)
					messageBody([
							bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
					])
					messageHeaders {
						header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
					}
					assertThat(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookWasDeleted()'</span>)
				}
			}</pre><p>以下示例显示了用YAML表示的同一合同：</p><pre class="programlisting">label: some_label
input:
  messageFrom: jms:delete
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
  assertThat: bookWasDeleted()</pre><p>然后，您可以将Spring Cloud Contract Verifier依赖项和插件添加到您的构建文件中，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-verifier<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>以下清单显示了如何添加插件，该插件应放在文件的build / plugins部分中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>跑步<code class="literal">./mvnw clean install</code>自动生成测试，以验证应用程序是否符合添加的合同。默认情况下，生成的测试处于<code class="literal">org.springframework.cloud.contract.verifier.tests.</code> 。</p><p>以下示例显示了自动生成的HTTP合同测试示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_shouldMarkClientAsFraud() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
        MockMvcRequestSpecification request = given()
                .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json"</span>)
                .body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"client.id\":\"1234567890\",\"loanAmount\":99999}"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
        ResponseOptions response = given().spec(request)
                .put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
        assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
        assertThat(response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1.json.*"</span>);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['fraudCheckStatus']"</span>).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[A-Z]{5}"</span>);
        assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['rejection.reason']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>);
}</pre><p>前面的示例使用Spring的<code class="literal">MockMvc</code>运行测试。这是HTTP合同的默认测试模式。但是，也可以使用JAX-RS客户端和显式HTTP调用。（为此，请更改<code class="literal">testMode</code>插件的属性<code class="literal">JAX-RS</code>要么<code class="literal">EXPLICIT</code> ， 分别。）</p><p>从2.1.0版本开始，也可以使用<code class="literal">RestAssuredWebTestClient`with Spring’s reactive `WebTestClient</code>在引擎盖下运行。与Reactive一起使用时，特别推荐这样做， <code class="literal">Web-Flux</code>基于应用程序。为了使用<code class="literal">WebTestClient</code>组<code class="literal">testMode</code>至<code class="literal">WEBTESTCLIENT</code> 。</p><p>这是在<code class="literal">WEBTESTCLIENT</code>测试模式：</p><pre class="literallayout">[source,java,indent=0]</pre><pre class="screen">@Test
	public void validate_shouldRejectABeerIfTooYoung() throws Exception {
		// given:
			WebTestClientRequestSpecification request = given()
					.header("Content-Type", "application/json")
					.body("{\"age\":10}");

		// when:
			WebTestClientResponse response = given().spec(request)
					.post("/check");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
			assertThat(response.header("Content-Type")).matches("application/json.*");
		// and:
			DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
			assertThatJson(parsedJson).field("['status']").isEqualTo("NOT_OK");
	}</pre><p>除了默认的JUnit 4，您还可以通过设置插件来使用JUnit 5或Spock测试。 <code class="literal">testFramework</code>财产给<code class="literal">JUNIT5</code>要么<code class="literal">Spock</code> 。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>现在，您还可以基于合同生成WireMock方案，方法是在合同文件名的开头添加订单号，后跟下划线。</p></td></tr></tbody></table></div><p>以下示例显示了在Spock中为消息存根合约自动生成的测试：</p><pre class="literallayout">[source,groovy,indent=0]</pre><pre class="screen">given:
	 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
		\'\'\'{"bookName":"foo"}\'\'\',
		['sample': 'header']
	)

when:
	 contractVerifierMessaging.send(inputMessage, 'jms:delete')

then:
	 noExceptionThrown()
	 bookWasDeleted()</pre><p>由于尚不存在合同描述的功能的实现，因此测试失败。</p><p>要使它们通过，您必须添加处理HTTP请求或消息的正确实现。另外，您必须为自动生成的测试添加正确的基础测试类。该类由所有自动生成的测试扩展，并且应包含运行它们所需的所有设置（例如， <code class="literal">RestAssuredMockMvc</code>控制器设置或消息传递测试设置）。</p><p>一旦实现和测试基类就位，测试就会通过，并且将应用程序和存根构件都构建并安装在本地Maven存储库中。有关将存根jar安装到本地存储库的信息显示在日志中，如以下示例所示：</p><pre class="programlisting">[INFO] --- spring-cloud-contract-maven-plugin:<span class="hl-number">1.0</span>.<span class="hl-number">0.</span>BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:<span class="hl-number">2.6</span>:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:<span class="hl-number">1.5</span>.<span class="hl-number">5.</span>BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:<span class="hl-number">2.5</span>.<span class="hl-number">2</span>:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar</pre><p>现在，您可以合并更改，并在在线存储库中发布应用程序和存根工件。</p><p><span class="strong"><strong>Docker项目</strong></span></p><p>为了在使用非JVM技术创建应用程序时启用合同， <code class="literal">springcloud/spring-cloud-contract</code> Docker镜像已创建。它包含一个项目，该项目会自动为HTTP合同生成测试并在中执行<code class="literal">EXPLICIT</code>测试模式。然后，如果测试通过，它将生成Wiremock存根并将其发布到工件管理器（可选）。为了使用该图像，您可以将合同安装到<code class="literal">/contracts</code>目录并设置一些环境变量。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="spring-cloud-contract-verifier-intro-three-minute-tour-consumer" href="#spring-cloud-contract-verifier-intro-three-minute-tour-consumer"></a>在消费者方面</h4></div></div></div><p><code class="literal">Spring Cloud Contract Stub Runner</code>可以在集成测试中使用，以获取正在运行的WireMock实例或模拟实际服务的消息传递路由。</p><p>首先，将依赖项添加到<code class="literal">Spring Cloud Contract Stub Runner</code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-stub-runner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>您可以通过以下两种方式之一在Maven资源库中安装生产者端存根：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">通过检出生产者端存储库并添加合同并通过运行以下命令来生成存根：</p><pre class="programlisting">$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> local-http-server-repo
$ ./mvnw clean install -DskipTests</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>由于生产者方合同实施尚未到位，因此跳过了测试，因此自动生成的合同测试失败。</p></td></tr></tbody></table></div></li><li class="listitem"><p class="simpara">从远程存储库获取已经存在的生产者服务存根。为此，请将存根工件ID和工件存储库UR1传递为<code class="literal">Spring Cloud Contract Stub Runner</code>属性，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ids</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'com.example:http-server-dsl:+:stubs:8080'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  repositoryRoot</span>: https://repo.spring.io/libs-snapshot</pre></li></ul></div><p>现在，您可以使用<code class="literal">@AutoConfigureStubRunner</code> 。在注释中，提供<code class="literal">group-id</code>和<code class="literal">artifact-id</code>对于<code class="literal">Spring Cloud Contract Stub Runner</code>为您运行协作者的存根，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment=WebEnvironment.NONE)</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"},
		stubsMode = StubRunnerProperties.StubsMode.LOCAL)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> LoanApplicationServiceTests {</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>使用<code class="literal">REMOTE</code><code class="literal">stubsMode</code>从在线存储库下载存根时，以及<code class="literal">LOCAL</code>进行离线工作。</p></td></tr></tbody></table></div><p>在集成测试中，您可以接收HTTP响应的残存版本或预期由协作服务发出的消息。您可以在构建日志中看到类似于以下内容的条目：</p><pre class="programlisting"><span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.403</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.438</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is <span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.439</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT using remote repositories []
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.451</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.465</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar]
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.475</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/<span class="hl-number">0</span>p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">27.737</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT:stubs=<span class="hl-number">8080</span>}]</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_defining_the_contract" href="#_defining_the_contract"></a> 87.4.3定义合同</h3></div></div></div><p>作为服务的使用者，我们需要定义要实现的目标。我们需要制定我们的期望。这就是为什么我们签订合同的原因。</p><p>假设您要发送一个包含客户公司ID以及它要向我们借款的金额的请求。您还希望通过PUT方法将其发送到/ fraudcheck URL。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> contracts

org.springframework.cloud.contract.spec.Contract.make {
	request { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (1)</span>
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PUT'</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (2)</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/fraudcheck'</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (3)</span>
		body([ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (4)</span>
			   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"client.id"</span>: $(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{10}'</span>)),
			   loanAmount : <span class="hl-number">99999</span>
		])
		headers { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (5)</span>
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
		}
	}
	response { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (6)</span>
		status OK() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (7)</span>
		body([ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (8)</span>
			   fraudCheckStatus  : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>,
			   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"rejection.reason"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>
		])
		headers { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (9)</span>
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
		}
	}
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/json.*`
 */</span></pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request: # (1)
  method: PUT # (2)
  url: /fraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json;charset=UTF-8


#From the Consumer perspective, when shooting a request in the integration test:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(6) - and a `client.id` json entry matches the regular expression `[0-9]{10}`
#(7) - then the response will be sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test:
#
#(1) - A request will be sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id` `1234567890`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(7) - then the test will assert if the response has been sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json;charset=UTF-8`</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_client_side" href="#_client_side"></a> 87.4.4客户端</h3></div></div></div><p>Spring Cloud Contract会生成存根，您可以在客户端测试期间使用该存根。您将获得一个模拟该服务的正在运行的WireMock实例/消息传递路由。您想使用适当的存根定义来提供该实例。</p><p>在某个时间点，您需要向欺诈检测服务发送请求。</p><pre class="programlisting">ResponseEntity&lt;FraudServiceResponse&gt; response = restTemplate.exchange(
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:"</span> + port + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>, HttpMethod.PUT,
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpEntity&lt;&gt;(request, httpHeaders), FraudServiceResponse.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);</pre><p>使用以下注释您的测试课<code class="literal">@AutoConfigureStubRunner</code> 。在批注中，提供Stub Runner的组ID和工件ID，以下载协作者的Stub。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.NONE)</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(ids = {
		"com.example:http-server-dsl:+:stubs:6565" }, stubsMode = StubRunnerProperties.StubsMode.LOCAL)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> LoanApplicationServiceTests {</pre><p>之后，在测试期间，Spring Cloud Contract将在Maven存储库中自动找到存根（模拟真实服务），并将其暴露在已配置（或随机）的端口上。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_server_side" href="#_server_side"></a> 87.4.5服务器端</h3></div></div></div><p>由于您正在开发存根，因此需要确保它实际上类似于您的具体实现。您不能存在存根以一种方式运行而应用程序以不同方式运行的情况，尤其是在生产环境中。</p><p>为确保您的应用程序符合您在存根中定义的方式，将从提供的存根中生成测试。</p><p>自动生成的测试或多或少看起来像这样：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_shouldMarkClientAsFraud() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
        MockMvcRequestSpecification request = given()
                .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json"</span>)
                .body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"client.id\":\"1234567890\",\"loanAmount\":99999}"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
        ResponseOptions response = given().spec(request)
                .put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
        assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
        assertThat(response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1.json.*"</span>);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['fraudCheckStatus']"</span>).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[A-Z]{5}"</span>);
        assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['rejection.reason']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>);
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_step_by_step_guide_to_consumer_driven_contracts_cdc" href="#_step_by_step_guide_to_consumer_driven_contracts_cdc"></a> 87.5消费者主导合同（CDC）分步指南</h2></div></div></div><p>考虑一个欺诈检测和贷款发行过程的示例。业务场景是这样的，我们希望向人们发放贷款，但又不想他们从我们那里窃取钱财。我们系统当前的实施情况是向所有人提供贷款。</p><p>假使，假设<code class="literal">Loan Issuance</code>是该客户<code class="literal">Fraud Detection</code>服务器。在当前的Sprint中，我们必须开发一个新功能：如果客户想要借太多钱，那么我们会将客户标记为欺诈。</p><p>技术说明-欺诈检测具有<code class="literal">artifact-id</code>的<code class="literal">http-server</code> ，而“贷款发行”的工件ID为<code class="literal">http-client</code> ，并且都有一个<code class="literal">group-id</code>的<code class="literal">com.example</code> 。</p><p>社交评论-客户和服务器开发团队都需要在整个过程中直接沟通并讨论更改。CDC完全是关于沟通的。</p><p><a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/tree/2.1.x/samples/standalone/dsl/http-server" target="_top">服务器端代码在这里可用</a> ， <a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/tree/2.1.x/samples/standalone/dsl/http-client" target="_top">客户端代码在这里</a> 。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>在这种情况下，生产者拥有合同。实际上，所有合同都在生产者的资料库中。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_technical_note" href="#_technical_note"></a> 87.5.1技术说明</h3></div></div></div><p>如果使用<span class="strong"><strong>SNAPSHOT</strong></span> / <span class="strong"><strong>Milestone</strong></span> / <span class="strong"><strong>Release Candidate</strong></span>版本，请在构建中添加以下部分：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repositories&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepositories&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">repositories {
	mavenCentral()
	mavenLocal()
	maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/snapshot"</span> }
	maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/milestone"</span> }
	maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/release"</span> }
}</pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer_side_loan_issuance" href="#_consumer_side_loan_issuance"></a> 87.5.2消费者方（发放贷款）</h3></div></div></div><p>作为贷款发行服务的开发人员（欺诈检测服务器的使用者），您可以执行以下步骤：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">通过为您的功能编写测试来开始进行TDD。</li><li class="listitem">编写缺少的实现。</li><li class="listitem">在本地克隆欺诈检测服务存储库。</li><li class="listitem">在欺诈检测服务的仓库中本地定义合同。</li><li class="listitem">添加Spring Cloud Contract Verifier插件。</li><li class="listitem">运行集成测试。</li><li class="listitem">提出拉取请求。</li><li class="listitem">创建一个初始实现。</li><li class="listitem">接管请求请求。</li><li class="listitem">编写缺少的实现。</li><li class="listitem">部署您的应用程序。</li><li class="listitem">在线工作。</li></ol></div><p><span class="strong"><strong>通过为您的功能编写测试来开始进行TDD。</strong></span></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> shouldBeRejectedDueToAbnormalLoanAmount() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
	LoanApplication application = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LoanApplication(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Client(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"1234567890"</span>),
			<span class="hl-number">99999</span>);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
	LoanApplicationResult loanApplication = service.loanApplication(application);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
	assertThat(loanApplication.getLoanApplicationStatus())
			.isEqualTo(LoanApplicationStatus.LOAN_APPLICATION_REJECTED);
	assertThat(loanApplication.getRejectionReason()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>);
}</pre><p>假设您已经编写了新功能的测试。如果收到大量贷款申请，则系统应拒绝该贷款申请并提供一些说明。</p><p><span class="strong"><strong>编写缺少的实现。</strong></span></p><p>在某个时间点，您需要向欺诈检测服务发送请求。假设您需要发送包含客户ID和客户希望借入的金额的请求。您要将其发送到<code class="literal">/fraudcheck</code>通过网址<code class="literal">PUT</code>方法。</p><pre class="programlisting">ResponseEntity&lt;FraudServiceResponse&gt; response = restTemplate.exchange(
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:"</span> + port + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>, HttpMethod.PUT,
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpEntity&lt;&gt;(request, httpHeaders), FraudServiceResponse.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);</pre><p>为简单起见，欺诈检测服务的端口设置为<code class="literal">8080</code> ，并且应用程序在<code class="literal">8090</code> 。</p><p>如果此时开始测试，则会中断测试，因为当前端口上没有运行任何服务<code class="literal">8080</code> 。</p><p><span class="strong"><strong>在本地克隆欺诈检测服务存储库。</strong></span></p><p>您可以从服务器端合同开始。为此，您必须首先克隆它。</p><pre class="programlisting">$ git clone https://your-git-server.com/server-side.git local-http-server-repo</pre><p><span class="strong"><strong>在欺诈检测服务的仓库中本地定义合同。</strong></span></p><p>作为消费者，您需要定义要实现的目标。您需要制定自己的期望。为此，请编写以下合同：</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>将合同放在<code class="literal">src/test/resources/contracts/fraud</code>夹。的<code class="literal">fraud</code>文件夹很重要，因为生产者的测试基类名称引用了该文件夹。</p></td></tr></tbody></table></div><p><b>Groovy DSL。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> contracts

org.springframework.cloud.contract.spec.Contract.make {
	request { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (1)</span>
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PUT'</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (2)</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/fraudcheck'</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (3)</span>
		body([ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (4)</span>
			   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"client.id"</span>: $(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{10}'</span>)),
			   loanAmount : <span class="hl-number">99999</span>
		])
		headers { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (5)</span>
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
		}
	}
	response { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (6)</span>
		status OK() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (7)</span>
		body([ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (8)</span>
			   fraudCheckStatus  : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>,
			   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"rejection.reason"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>
		])
		headers { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (9)</span>
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
		}
	}
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/json.*`
 */</span></pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request: # (1)
  method: PUT # (2)
  url: /fraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json;charset=UTF-8


#From the Consumer perspective, when shooting a request in the integration test:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(6) - and a `client.id` json entry matches the regular expression `[0-9]{10}`
#(7) - then the response will be sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test:
#
#(1) - A request will be sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a field `client.id` `1234567890`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(7) - then the test will assert if the response has been sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json;charset=UTF-8`</pre><p>
</p><p>YML合同很简单。但是，当您查看使用静态类型的Groovy DSL编写的Contract时-您可能会想知道<code class="literal">value(client(…​), server(…​))</code>零件是。通过使用这种表示法，Spring Cloud Contract可让您定义JSON块，URL等动态的部分。如果是标识符或时间戳，则无需对值进行硬编码。您要允许一些不同的值范围。要启用值范围，可以为使用者方设置与这些值匹配的正则表达式。您可以通过地图符号或带插值的字符串来提供主体。有关更多信息<a class="xref" href="#contract-dsl" title="94. Contract DSL">，</a>请参见<a class="xref" href="#contract-dsl" title="94。合约DSL">第94章，“ <i>合同DSL”</i></a>部分。我们强烈建议您使用地图符号！</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>您必须了解地图符号才能设置合同。请阅读<a class="link" href="https://groovy-lang.org/json.html" target="_top">有关JSON</a>的<a class="link" href="https://groovy-lang.org/json.html" target="_top">Groovy文档</a> 。</p></td></tr></tbody></table></div><p>前面显示的合同是双方之间的协议，其中：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">如果HTTP请求与所有</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">一种<code class="literal">PUT</code>上的方法<code class="literal">/fraudcheck</code>端点</li><li class="listitem">带有<code class="literal">client.id</code>与正则表达式匹配<code class="literal">[0-9]{10}</code>和<code class="literal">loanAmount</code>等于<code class="literal">99999</code> ，</li><li class="listitem">和一个<code class="literal">Content-Type</code>标头值为<code class="literal">application/vnd.fraud.v1+json</code> ，</li></ul></div></li><li class="listitem"><p class="simpara">然后将HTTP响应发送给使用者</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">有状态<code class="literal">200</code> ，</li><li class="listitem">包含JSON正文， <code class="literal">fraudCheckStatus</code>包含值的字段<code class="literal">FRAUD</code>和<code class="literal">rejectionReason</code>有价值的领域<code class="literal">Amount too high</code> ，</li><li class="listitem">和一个<code class="literal">Content-Type</code>标头值为<code class="literal">application/vnd.fraud.v1+json</code> 。</li></ul></div></li></ul></div><p>一旦准备好在集成测试中实际检查API，就需要在本地安装存根。</p><p><span class="strong"><strong>添加Spring Cloud Contract Verifier插件。</strong></span></p><p>我们可以添加Maven或Gradle插件。在此示例中，您将看到如何添加Maven。首先，添加<code class="literal">Spring Cloud Contract</code> BOM。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-release.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span></pre><p>接下来，添加<code class="literal">Spring Cloud Contract Verifier</code> Maven插件</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;packageWithBaseClasses&gt;</span>com.example.fraud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/packageWithBaseClasses&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;convertToYaml&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/convertToYaml&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>由于添加了插件，您将获得<code class="literal">Spring Cloud Contract Verifier</code>从提供的合同中获得的功能：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">生成并运行测试</li><li class="listitem">制作并安装存根</li></ul></div><p>您不想生成测试，因为作为消费者，您只想玩存根。您需要跳过测试的生成和执行。执行时：</p><pre class="programlisting">$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> local-http-server-repo
$ ./mvnw clean install -DskipTests</pre><p>在日志中，您将看到以下内容：</p><pre class="programlisting">[INFO] --- spring-cloud-contract-maven-plugin:<span class="hl-number">1.0</span>.<span class="hl-number">0.</span>BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:<span class="hl-number">2.6</span>:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:<span class="hl-number">1.5</span>.<span class="hl-number">5.</span>BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:<span class="hl-number">2.5</span>.<span class="hl-number">2</span>:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar</pre><p>以下行非常重要：</p><pre class="programlisting">[INFO] Installing /some/path/http-server/target/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar</pre><p>它确认了<code class="literal">http-server</code>已安装在本地存储库中。</p><p><span class="strong"><strong>运行集成测试。</strong></span></p><p>为了从自动存根下载的Spring Cloud Contract Stub Runner功能中获利，您必须在用户端项目中执行以下操作（ <code class="literal">Loan Application service</code> ）：</p><p>添加<code class="literal">Spring Cloud Contract</code> BOM：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-release-train.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span></pre><p>将依赖项添加到<code class="literal">Spring Cloud Contract Stub Runner</code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-stub-runner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>使用以下注释您的测试课<code class="literal">@AutoConfigureStubRunner</code> 。在注释中，提供<code class="literal">group-id</code>和<code class="literal">artifact-id</code>供存根赛跑者下载协作者的存根。（可选步骤）由于您是与离线协作者一起玩，因此您还可以提供离线工作切换器（ <code class="literal">StubRunnerProperties.StubsMode.LOCAL</code> ）。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.NONE)</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(ids = {
		"com.example:http-server-dsl:+:stubs:6565" }, stubsMode = StubRunnerProperties.StubsMode.LOCAL)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> LoanApplicationServiceTests {</pre><p>现在，当您运行测试时，您将看到类似以下的内容：</p><pre class="programlisting"><span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.403</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.438</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is <span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.439</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT using remote repositories []
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.451</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.465</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT/http-server-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar]
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">25.475</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/<span class="hl-number">0</span>p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
<span class="hl-number">2016</span>-<span class="hl-number">07</span>-<span class="hl-number">19</span> <span class="hl-number">14</span>:<span class="hl-number">22</span>:<span class="hl-number">27.737</span>  INFO <span class="hl-number">41050</span> --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT:stubs=<span class="hl-number">8080</span>}]</pre><p>此输出意味着Stub Runner已找到您的存根，并使用组ID为您的应用启动了服务器<code class="literal">com.example</code> ，工件ID <code class="literal">http-server</code>带版本<code class="literal">0.0.1-SNAPSHOT</code>存根和<code class="literal">stubs</code>港口分类器<code class="literal">8080</code> 。</p><p><span class="strong"><strong>提出拉取请求。</strong></span></p><p>到目前为止，您所做的是一个迭代过程。您可以试用合同，将其安装在本地，然后在用户端工作，直到合同按您的意愿运行。</p><p>对结果满意并通过测试后，将拉取请求发布到服务器端。目前，消费者方面的工作已经完成。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer_side_fraud_detection_server" href="#_producer_side_fraud_detection_server"></a> 87.5.3生产方（欺诈检测服务器）</h3></div></div></div><p>作为欺诈检测服务器（贷款发放服务的服务器）的开发人员：</p><p><span class="strong"><strong>创建一个初始实现。</strong></span></p><p>提醒一下，您可以在此处看到初始实现：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RequestMapping(value = "/fraudcheck", method = PUT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> FraudCheckResult fraudCheck(<em><span class="hl-annotation" style="color: gray">@RequestBody</span></em> FraudCheck fraudCheck) {
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</pre><p><span class="strong"><strong>接管请求请求。</strong></span></p><pre class="programlisting">$ git checkout -b contract-change-pr master
$ git pull https://your-git-server.com/server-side-fork.git contract-change-pr</pre><p>您必须添加自动生成的测试所需的依赖项：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-verifier<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>在Maven插件的配置中，传递<code class="literal">packageWithBaseClasses</code>属性</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;packageWithBaseClasses&gt;</span>com.example.fraud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/packageWithBaseClasses&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;convertToYaml&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/convertToYaml&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本示例通过设置“ <code class="literal">packageWithBaseClasses</code>属性。这样做意味着最后两个软件包组合在一起以成为基础测试类的名称。在我们的案例中，合同被置于<code class="literal">src/test/resources/contracts/fraud</code> 。由于您没有从<code class="literal">contracts</code>文件夹，只选择一个，应该是<code class="literal">fraud</code> 。添加<code class="literal">Base</code>后缀和大写<code class="literal">fraud</code> 。那给你<code class="literal">FraudBase</code>测试类别名称。</p></td></tr></tbody></table></div><p>所有生成的测试都扩展了该类。在那儿，您可以设置您的Spring Context或任何必要的东西。在这种情况下，请使用<a class="link" href="https://github.com/rest-assured/rest-assured" target="_top">Rest Assured MVC</a>启动服务器端<code class="literal">FraudDetectionController</code> 。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example.fraud;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.module.mockmvc.RestAssuredMockMvc;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FraudBase {

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FraudDetectionController(),
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FraudStatsController(stubbedStatsProvider()));
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> StatsProvider stubbedStatsProvider() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> fraudType -&gt; {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">switch</span> (fraudType) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">case</span> DRUNKS:
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">100</span>;
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">case</span> ALL:
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">200</span>;
			}
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span class="hl-number">0</span>;
		};
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> assertThatRejectionReasonIsNull(Object rejectionReason) {
		assert rejectionReason == null;
	}

}</pre><p>现在，如果您运行<code class="literal">./mvnw clean install</code> ，您将获得如下内容：</p><pre class="programlisting">Results :

Tests in error:
  ContractVerifierTest.validate_shouldMarkClientAsFraud:<span class="hl-number">32</span> &raquo; IllegalState Parsed...</pre><p>发生此错误的原因是您有一个新合同，从中生成了一个测试，但由于未实现该功能而失败了。自动生成的测试如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_shouldMarkClientAsFraud() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
        MockMvcRequestSpecification request = given()
                .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json"</span>)
                .body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"client.id\":\"1234567890\",\"loanAmount\":99999}"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
        ResponseOptions response = given().spec(request)
                .put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
        assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
        assertThat(response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1.json.*"</span>);
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['fraudCheckStatus']"</span>).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[A-Z]{5}"</span>);
        assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['rejection.reason']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>);
}</pre><p>如果您使用了Groovy DSL，则可以看到所有<code class="literal">producer()</code>合同中存在于<code class="literal">value(consumer(…​), producer(…​))</code>块被注入到测试中。如果使用YAML，则同样适用于<code class="literal">matchers</code>的部分<code class="literal">response</code> 。</p><p>请注意，在生产者方面，您也在执行TDD。期望以测试的形式表达。此测试使用合同中定义的URL，标头和正文向我们自己的应用程序发送请求。它还期望在响应中精确定义值。换句话说，您拥有<code class="literal">red</code>部分<code class="literal">red</code> ， <code class="literal">green</code>和<code class="literal">refactor</code> 。现在是时候转换<code class="literal">red</code>进入<code class="literal">green</code> 。</p><p><span class="strong"><strong>编写缺少的实现。</strong></span></p><p>因为您知道预期的输入和预期的输出，所以可以编写缺少的实现：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RequestMapping(value = "/fraudcheck", method = PUT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> FraudCheckResult fraudCheck(<em><span class="hl-annotation" style="color: gray">@RequestBody</span></em> FraudCheck fraudCheck) {
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (amountGreaterThanThreshold(fraudCheck)) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FraudCheckResult(FraudCheckStatus.FRAUD, AMOUNT_TOO_HIGH);
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</pre><p>执行时<code class="literal">./mvnw clean install</code>再次，测试通过了。自从<code class="literal">Spring Cloud Contract Verifier</code>插件将测试添加到<code class="literal">generated-test-sources</code> ，您实际上可以从IDE运行这些测试。</p><p><span class="strong"><strong>部署您的应用程序。</strong></span></p><p>完成工作后，即可部署更改。首先，合并分支：</p><pre class="programlisting">$ git checkout master
$ git merge --no-ff contract-change-pr
$ git push origin master</pre><p>您的CI可能会运行类似<code class="literal">./mvnw clean deploy</code> ，这将同时发布应用程序和存根工件。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer_side_loan_issuance_final_step" href="#_consumer_side_loan_issuance_final_step"></a> 87.5.4消费者方（贷款发行）最后一步</h3></div></div></div><p>作为贷款发行服务的开发人员（欺诈检测服务器的使用者）：</p><p><span class="strong"><strong>合并分支以掌握。</strong></span></p><pre class="programlisting">$ git checkout master
$ git merge --no-ff contract-change-pr</pre><p><span class="strong"><strong>在线工作。</strong></span></p><p>现在，您可以禁用Spring Cloud Contract Stub Runner的脱机工作，并指定包含您的存根的存储库所在的位置。此时，服务器端的存根会自动从Nexus / Artifactory下载。您可以设置的值<code class="literal">stubsMode</code>至<code class="literal">REMOTE</code> 。以下代码显示了通过更改属性来实现相同目的的示例。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ids</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'com.example:http-server-dsl:+:stubs:8080'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  repositoryRoot</span>: https://repo.spring.io/libs-snapshot</pre><p>而已！</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_dependencies_2" href="#_dependencies_2"></a> 87.6依赖项</h2></div></div></div><p>添加依赖项的最佳方法是使用适当的<code class="literal">starter</code>依赖性。</p><p>对于<code class="literal">stub-runner</code> ， 使用<code class="literal">spring-cloud-starter-stub-runner</code> 。使用插件时，添加<code class="literal">spring-cloud-starter-contract-verifier</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_additional_links" href="#_additional_links"></a> 87.7其他链接</h2></div></div></div><p>这里有一些与Spring Cloud Contract Verifier和Stub Runner相关的资源。请注意，有些可能已经过时，因为Spring Cloud Contract Verifier项目正在不断开发中。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spring_cloud_contract_video" href="#_spring_cloud_contract_video"></a> 87.7.1 Spring Cloud Contract视频</h3></div></div></div><p>您可以从Warsaw JUG观看有关Spring Cloud Contract的视频：</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_readings" href="#_readings"></a> 87.7.2阅读</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.slideshare.net/MarcinGrzejszczak/stick-to-the-rules-consumer-driven-contracts-201507-confitura" target="_top">Marcin Grzejszczak关于Accurest的演讲的幻灯片</a></li><li class="listitem"><a class="link" href="https://toomuchcoding.com/blog/categories/accurest/" target="_top">Marcin Grzejszczak博客中与Accurest相关的文章</a></li><li class="listitem"><a class="link" href="https://toomuchcoding.com/blog/categories/spring-cloud-contract/" target="_top">Marcin Grzejszczak博客中的Spring Cloud Contract相关文章</a></li><li class="listitem"><a class="link" href="https://groovy-lang.org/json.html" target="_top">关于JSON的Groovy文档</a></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_samples_2" href="#_samples_2"></a> 87.8个样本</h2></div></div></div><p>您可以在<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples" target="_top">样本中</a>找到一些<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples" target="_top">样本</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_faq" href="#_spring_cloud_contract_faq"></a> 88。Spring Cloud Contract常见问题解答</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_why_use_spring_cloud_contract_verifier_and_not_x" href="#_why_use_spring_cloud_contract_verifier_and_not_x"></a> 88.1为什么使用Spring Cloud Contract Verifier而不使用X？</h2></div></div></div><p>目前，Spring Cloud Contract是基于JVM的工具。因此，当您已经为JVM创建软件时，它可能是您的首选。该项目具有许多非常有趣的功能，但是尤其是其中的许多功能无疑使Spring Cloud Contract Verifier在消费者驱动合同（CDC）工具的“市场”上脱颖而出。最有趣的是：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">通过消息进行CDC的可能性</li><li class="listitem">清晰易用的静态类型DSL</li><li class="listitem">可以将您当前的JSON文件复制粘贴到合同中，并仅编辑其元素</li><li class="listitem">根据定义的合同自动生成测试</li><li class="listitem">Stub Runner功能-存根会在运行时从Nexus / Artifactory自动下载</li><li class="listitem">Spring Cloud集成-集成测试不需要发现服务</li><li class="listitem">Spring Cloud Contract可以与Pact集成在一起，并提供简单的挂钩来扩展其功能</li><li class="listitem">通过Docker添加了对使用的任何语言和框架的支持</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_i_dont_want_to_write_a_contract_in_groovy" href="#_i_dont_want_to_write_a_contract_in_groovy"></a> 88.2我不想用Groovy编写合同！</h2></div></div></div><p>没问题。您可以在YAML中写合同！</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_what_is_this_valueconsumer_producer" href="#_what_is_this_valueconsumer_producer"></a> 88.3这个值是什么（consumer（），producer（））？</h2></div></div></div><p>与存根相关的最大挑战之一是它们的可重用性。只有将它们广泛使用，它们才能达到目的。通常使困难的是请求/响应元素的硬编码值。例如日期或ID。想象以下JSON请求</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2016-10-10 20:10:15"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>和JSON响应</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2016-10-10 21:10:15"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"c4231e1f-3ca9-48d3-b7e7-567d55f0d051"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>想象一下设置适当值的痛苦<code class="literal">time</code>字段（假设此内容由数据库生成）可以通过更改系统中的时钟或提供数据提供程序的存根实现来实现。与此有关的领域<code class="literal">id</code> 。您将创建UUID生成器的存根实现吗？毫无意义...</p><p>因此，作为消费者，您希望发送与任何时间形式或任何UUID相匹配的请求。这样，您的系统将照常运行-会生成数据，而您无需存根任何东西。假设在上述JSON的情况下，最重要的部分是<code class="literal">body</code>领域。您可以专注于此并为其他字段提供匹配。换句话说，您希望存根像这样工作：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SOMETHING THAT MATCHES TIME"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SOMETHING THAT MATCHES UUID"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>就消费者的反应而言，您需要一个可操作的具体价值。因此，这样的JSON是有效的</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2016-10-10 21:10:15"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"c4231e1f-3ca9-48d3-b7e7-567d55f0d051"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>正如您在前面的部分中所看到的，我们根据合同生成测试。因此，从生产者的角度来看，情况似乎大不相同。我们正在解析提供的合同，并且在测试中我们想向您的端点发送真实请求。因此，对于请求的生产者而言，我们无法进行任何形式的匹配。我们需要生产者后端可以使用的具体价值。这样的JSON是有效的：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"2016-10-10 20:10:15"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>另一方面，从合同有效性的角度来看，回应不一定包含具体的价值。 <code class="literal">time</code>要么<code class="literal">id</code> 。假设您是在生产者端生成的-再次，您必须进行大量的存根操作以确保始终返回相同的值。因此，从生产者的角度来看，您可能想要以下响应：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"time"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SOMETHING THAT MATCHES TIME"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SOMETHING THAT MATCHES UUID"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>那么，您如何才能一次为消费者提供匹配者，为生产者提供具体价值，反之亦然？在Spring Cloud Contract中，我们允许您提供<span class="strong"><strong>动态价值</strong></span> 。这意味着通信的双方可能会有所不同。您可以传递值：</p><p>通过<code class="literal">value</code>方法</p><pre class="programlisting">value(consumer(...), producer(...))
value(stub(...), test(...))
value(client(...), server(...))</pre><p>或使用<code class="literal">$()</code>方法</p><pre class="programlisting">$(consumer(...), producer(...))
$(stub(...), test(...))
$(client(...), server(...))</pre><p>您可以在<a class="xref" href="#contract-dsl" title="94。合约DSL">第94章“ <i>合同DSL”</i></a>部分中了解有关此内容的更多信息。</p><p>呼唤<code class="literal">value()</code>要么<code class="literal">$()</code>告诉Spring Cloud Contract您将传递动态值。在 - 的里面<code class="literal">consumer()</code>方法，您传递应该在使用者方（在生成的存根中）使用的值。在 - 的里面<code class="literal">producer()</code>方法，您传递应该在生产方（在生成的测试中）使用的值。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如果一侧传递了正则表达式，而另一侧则没有传递，则另一侧将自动生成。</p></td></tr></tbody></table></div><p>大多数情况下，您会将该方法与<code class="literal">regex</code>辅助方法。例如<code class="literal">consumer(regex('[0-9]{10}'))</code> 。</p><p>概括起来，上述情况的合同看起来或多或少像这样（时间和UUID的正则表达式已简化，很可能无效，但在此示例中，我们希望保持非常简单）：</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
				request {
					method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>
					url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/someUrl'</span>
					body([
					    time : value(consumer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]'</span>)),
					    id: value(consumer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'</span>))
					    body: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>
					])
				}
			response {
				status OK()
				body([
					    time : value(producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{4}-[0-9]{2}-[0-9]{2} [0-2][0-9]-[0-5][0-9]-[0-5][0-9]'</span>)),
					    id: value([producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9a-zA-z]{8}-[0-9a-zA-z]{4}-[0-9a-zA-z]{4}-[0-9a-zA-z]{12}'</span>))
					    body: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>
					])
			}
}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>请阅读<a class="link" href="https://groovy-lang.org/json.html" target="_top">与JSON相关</a>的<a class="link" href="https://groovy-lang.org/json.html" target="_top">Groovy文档，</a>以了解如何正确构造请求/响应主体。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_to_do_stubs_versioning" href="#_how_to_do_stubs_versioning"></a> 88.4如何进行存根版本控制？</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_api_versioning" href="#_api_versioning"></a> 88.4.1 API版本控制</h3></div></div></div><p>让我们尝试回答一个问题，即版本控制的真正含义。如果您指的是API版本，则有不同的方法。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">使用超媒体，链接，并且不以任何方式对您的API进行版本控制</li><li class="listitem">通过标题/网址传递版本</li></ul></div><p>我不会尝试回答哪种方法更好的问题。应该选择适合您需求并允许您产生业务价值的任何东西。</p><p>假设您对API进行了版本控制。在这种情况下，您应提供与所支持版本一样多的合同。您可以为每个版本创建一个子文件夹，也可以将其附加到合同名称之后-更加适合您。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_jar_versioning" href="#_jar_versioning"></a> 88.4.2 JAR版本控制</h3></div></div></div><p>如果用版本控制来表示包含存根的JAR版本，则基本上有两种主要方法。</p><p>假设您正在执行持续交付/部署，这意味着您每次通过管道都将生成一个新版本的jar，并且该jar可以随时投入生产。例如，您的jar版本如下所示（它建立于20.10.2016 at 20:15:21）：</p><pre class="programlisting"><span class="hl-number">1.0</span>.<span class="hl-number">0.20161020</span>-<span class="hl-number">201521</span>-RELEASE</pre><p>在这种情况下，您生成的存根罐将如下所示。</p><pre class="programlisting"><span class="hl-number">1.0</span>.<span class="hl-number">0.20161020</span>-<span class="hl-number">201521</span>-RELEASE-stubs.jar</pre><p>在这种情况下，您应该在<code class="literal">application.yml</code>要么<code class="literal">@AutoConfigureStubRunner</code>引用存根时，请提供最新版本的存根。您可以通过传递<code class="literal">+</code>标志。例</p><pre class="programlisting">@AutoConfigureStubRunner(ids = {<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:http-server-dsl:+:stubs:8080"</span>})</pre><p>如果版本是固定的（例如<code class="literal">1.0.4.RELEASE</code>要么<code class="literal">2.1.1</code> ），则必须设置jar版本的具体值。2.1.1的示例。</p><pre class="programlisting">@AutoConfigureStubRunner(ids = {<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:http-server-dsl:2.1.1:stubs:8080"</span>})</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_dev_or_prod_stubs" href="#_dev_or_prod_stubs"></a> 88.4.3开发或生产存根</h3></div></div></div><p>您可以操纵分类器，以针对其他服务或已部署到生产中的服务的存根的当前开发版本运行测试。如果您更改构建以通过以下方式部署存根<code class="literal">prod-stubs</code>分类器一旦进入生产部署，就可以在一种情况下使用开发存根运行测试，而在一种情况下使用产品存根运行测试。</p><p>使用存根开发版本的测试示例</p><pre class="programlisting">@AutoConfigureStubRunner(ids = {<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:http-server-dsl:+:stubs:8080"</span>})</pre><p>使用生产版本的存根进行测试的示例</p><pre class="programlisting">@AutoConfigureStubRunner(ids = {<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:http-server-dsl:+:prod-stubs:8080"</span>})</pre><p>您还可以通过部署管道中的属性传递这些值。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_common_repo_with_contracts" href="#_common_repo_with_contracts"></a> 88.5合同通用回购</h2></div></div></div><p>除了与生产者签订合同之外，存储合同的另一种方法是将合同放在一个共同的地方。这可能与安全问题有关，在这些安全问题中，消费者无法克隆生产者的代码。同样，如果您将合同放在一个地方，那么作为生产者，您将知道您有多少个消费者，以及将因本地变更而中断的消费者。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_repo_structure" href="#_repo_structure"></a> 88.5.1回购结构</h3></div></div></div><p>假设我们有一个带有坐标的生产者<code class="literal">com.example:server</code>和3个消费者： <code class="literal">client1</code> ， <code class="literal">client2</code> ， <code class="literal">client3</code> 。然后，在具有通用合同的存储库中，您将具有以下设置（您可以<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/tree/2.1.x/samples/standalone/contracts" target="_top">在此处</a>签出）：</p><pre class="programlisting">&#9500;&#9472;&#9472; com
&#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; example
&#9474;&nbsp;&nbsp;     &#9492;&#9472;&#9472; server
&#9474;&nbsp;&nbsp;         &#9500;&#9472;&#9472; client1
&#9474;&nbsp;&nbsp;         &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; expectation.groovy
&#9474;&nbsp;&nbsp;         &#9500;&#9472;&#9472; client2
&#9474;&nbsp;&nbsp;         &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; expectation.groovy
&#9474;&nbsp;&nbsp;         &#9500;&#9472;&#9472; client3
&#9474;&nbsp;&nbsp;         &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; expectation.groovy
&#9474;&nbsp;&nbsp;         &#9492;&#9472;&#9472; pom.xml
&#9500;&#9472;&#9472; mvnw
&#9500;&#9472;&#9472; mvnw.cmd
&#9500;&#9472;&#9472; pom.xml
&#9492;&#9472;&#9472; src
    &#9492;&#9472;&#9472; assembly
        &#9492;&#9472;&#9472; contracts.xml</pre><p>如您所见，以斜杠分隔的groupid <code class="literal">/</code>工件ID文件夹（ <code class="literal">com/example/server</code> ）您对3个消费者有期望（ <code class="literal">client1</code> ， <code class="literal">client2</code>和<code class="literal">client3</code> ）。期望是本文档中所述的标准Groovy DSL合同文件。该存储库必须产生一个JAR文件，该文件将仓库内容一一对应。</p><p>一个例子<code class="literal">pom.xml</code>在 - 的里面<code class="literal">server</code>夹。</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;project</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:xsi</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
		 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/POM/4.0.0"</span>
		 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xsi:schemaLocation</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;modelVersion&gt;</span>4.0.0<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/modelVersion&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>server<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>0.0.1-SNAPSHOT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Server Stubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;description&gt;</span>POM used to install locally stubs for consumer side<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/description&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;parent&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-parent<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>2.1.10.RELEASE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;relativePath/&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/parent&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;properties&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/project.build.sourceEncoding&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;java.version&gt;</span>1.8<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/java.version&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;spring-cloud-contract.version&gt;</span>2.1.5.BUILD-SNAPSHOT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/spring-cloud-contract.version&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;spring-cloud-release.version&gt;</span>Greenwich.BUILD-SNAPSHOT
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/spring-cloud-release.version&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;excludeBuildFolders&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/excludeBuildFolders&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/properties&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-release.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;build&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugins&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- By default it would search under src/test/resources/ --&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsDirectory&gt;</span>${project.basedir}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsDirectory&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugins&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/build&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repositories&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepositories&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepositories&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/project&gt;</span></pre><p>如您所见，除了Spring Cloud Contract Maven插件之外，没有其他依赖项。这些pom对于消费者而言是必需的<code class="literal">mvn clean install -DskipTests</code>在本地安装生产者项目的存根。</p><p>的<code class="literal">pom.xml</code>根文件夹中的内容如下所示：</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;project</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:xsi</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
		 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/POM/4.0.0"</span>
		 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xsi:schemaLocation</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;modelVersion&gt;</span>4.0.0<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/modelVersion&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example.standalone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>0.0.1-SNAPSHOT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;description&gt;</span>Contains all the Spring Cloud Contracts, well, contracts. JAR used by the
		producers to generate tests and stubs
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/description&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;properties&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/project.build.sourceEncoding&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/properties&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;build&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugins&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>maven-assembly-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;phase&gt;</span>prepare-package<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/phase&gt;</span>
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
							<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>single<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
							<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;attach&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/attach&gt;</span>
							<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;descriptor&gt;</span>${basedir}/src/assembly/contracts.xml<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/descriptor&gt;</span>
							<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- If you want an explicit classifier remove the following line --&gt;</span>
							<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appendAssemblyId&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appendAssemblyId&gt;</span>
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugins&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/build&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/project&gt;</span></pre><p>它使用Assembly插件来构建包含所有合同的JAR。这种设置的示例在这里：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;assembly</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:xsi</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
		  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"</span>
		  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xsi:schemaLocation</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>project<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;formats&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;format&gt;</span>jar<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/format&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/formats&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includeBaseDirectory&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includeBaseDirectory&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSets&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>${project.basedir}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;useDefaultExcludes&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/useDefaultExcludes&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;excludes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclude&gt;</span>**/${project.build.directory}/**<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclude&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclude&gt;</span>mvnw<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclude&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclude&gt;</span>mvnw.cmd<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclude&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclude&gt;</span>.mvn/**<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclude&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclude&gt;</span>src/**<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclude&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/excludes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSets&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/assembly&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_workflow" href="#_workflow"></a> 88.5.2工作流程</h3></div></div></div><p>该工作流程看起来类似于在<code class="literal">Step by step guide to CDC</code> 。唯一的区别是，生产者不再拥有合同。因此，消费者和生产者必须在公用存储库中处理公用合同。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer" href="#_consumer"></a> 88.5.3消费者</h3></div></div></div><p>当<span class="strong"><strong>消费者</strong></span>希望脱机处理合同时，而不是克隆生产者代码，消费者团队将克隆公共存储库，转到所需的生产者文件夹（例如<code class="literal">com/example/server</code> ）并运行<code class="literal">mvn clean install -DskipTests</code>在本地安装从合同转换而来的存根。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>您需要在<a class="link" href="https://maven.apache.org/download.cgi" target="_top">本地安装Maven</a></p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer" href="#_producer"></a> 88.5.4生产者</h3></div></div></div><p>作为<span class="strong"><strong>生产者</strong></span> ，足以更改Spring Cloud Contract Verifier以提供URL和包含合同的JAR依赖项：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsMode&gt;</span>REMOTE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsMode&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsRepositoryUrl&gt;</span>
			https://link/to/your/nexus/or/artifactory/or/sth
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsRepositoryUrl&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractDependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example.standalone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractDependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>通过此设置，具有groupid的JAR <code class="literal">com.example.standalone</code>和神器<code class="literal">contracts</code>将从下载<code class="literal"><a class="link" href="http://link/to/your/nexus/or/artifactory/or/sth" target="_top">http://link/to/your/nexus/or/artifactory/or/sth</a></code> 。然后将其解压缩到本地临时文件夹中，并在<code class="literal">com/example/server</code>将被选作生成测试和存根的工具。根据该约定，当完成一些不兼容的更改时，生产者团队将知道哪些消费者团队将被破坏。</p><p>其余流程看起来相同。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_can_i_define_messaging_contracts_per_topic_not_per_producer" href="#_how_can_i_define_messaging_contracts_per_topic_not_per_producer"></a> 88.5.5如何按主题而不是按生产者定义消息传递合同？</h3></div></div></div><p>为了避免通用仓库中的消息合同重复，当很少有生产者将消息写到一个主题时，我们可以创建一个结构，将其余合同放置在每个生产者的文件夹中，并将消息合同放置在每个主题的文件夹中。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_for_maven_project" href="#_for_maven_project"></a>对于Maven项目</h4></div></div></div><p>为了能够在生产者端进行工作，我们应该指定一个包含模式，通过我们感兴趣的消息传递主题来过滤公共存储库jar。 <code class="literal"><code class="literal">includedFiles</code></code>的财产<code class="literal"><code class="literal">Maven Spring Cloud Contract plugin</code></code>允许我们这样做。也<code class="literal"><code class="literal">contractsPath</code></code>需要指定，因为默认路径将是公共存储库<code class="literal"><code class="literal">groupid/artifactid</code></code> 。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsMode&gt;</span>REMOTE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsMode&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsRepositoryUrl&gt;</span>http://link/to/your/nexus/or/artifactory/or/sth<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsRepositoryUrl&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractDependency&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>common-repo-with-contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>+<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractDependency&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsPath&gt;</span>/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsPath&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMappings&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMapping&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractPackageRegex&gt;</span>.*messaging.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractPackageRegex&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassFQN&gt;</span>com.example.services.MessagingBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassFQN&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMapping&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMapping&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractPackageRegex&gt;</span>.*rest.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractPackageRegex&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassFQN&gt;</span>com.example.services.TestBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassFQN&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMapping&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMappings&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includedFiles&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includedFile&gt;</span>**/${project.artifactId}/**<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includedFile&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includedFile&gt;</span>**/${first-topic}/**<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includedFile&gt;</span>
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includedFile&gt;</span>**/${second-topic}/**<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includedFile&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includedFiles&gt;</span>
   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_for_gradle_project" href="#_for_gradle_project"></a>对于Gradle项目</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">为common-repo依赖项添加定制配置：</li></ul></div><pre class="programlisting">ext {
    conractsGroupId = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example"</span>
    contractsArtifactId = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"common-repo"</span>
    contractsVersion = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"1.2.3"</span>
}

configurations {
    contracts {
        transitive = false
    }
}</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">将common-repo依赖项添加到您的类路径中：</li></ul></div><pre class="programlisting">dependencies {
    contracts <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${conractsGroupId}:${contractsArtifactId}:${contractsVersion}"</span>
    testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${conractsGroupId}:${contractsArtifactId}:${contractsVersion}"</span>
}</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">将依赖项下载到适当的文件夹：</li></ul></div><pre class="programlisting">task getContracts(type: Copy) {
    from configurations.contracts
    into <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> File(project.buildDir, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"downloadedContracts"</span>)
}</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">解压缩JAR：</li></ul></div><pre class="programlisting">task unzipContracts(type: Copy) {
    def zipFile = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> File(project.buildDir, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"downloadedContracts/${contractsArtifactId}-${contractsVersion}.jar"</span>)
    def outputDir = file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${buildDir}/unpackedContracts"</span>)

    from zipTree(zipFile)
    into outputDir
}</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">清理未使用的合同：</li></ul></div><pre class="programlisting">task deleteUnwantedContracts(type: Delete) {
    delete fileTree(dir: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${buildDir}/unpackedContracts"</span>,
        include: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"**/*"</span>,
        excludes: [
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"**/${project.name}/**"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",
</span>            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"**/${first-topic}/**"</span>,
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"**/${second-topic}/**"</span>])
}</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">创建任务依赖项：</li></ul></div><pre class="programlisting">unzipContracts.dependsOn(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"getContracts"</span>)
deleteUnwantedContracts.dependsOn(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"unzipContracts"</span>)
build.dependsOn(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"deleteUnwantedContracts"</span>)</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">通过使用以下命令指定包含合同的目录来配置插件<code class="literal">contractsDslDir</code>属性</li></ul></div><pre class="programlisting">contracts {
    contractsDslDir = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> File(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${buildDir}/unpackedContracts"</span>)
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_do_i_need_a_binary_storage_cant_i_use_git" href="#_do_i_need_a_binary_storage_cant_i_use_git"></a> 88.6我需要二进制存储吗？我不能使用Git吗？</h2></div></div></div><p>在多语言的世界中，有些语言不使用二进制存储，例如Artifactory或Nexus。从Spring Cloud Contract版本2.0.0开始，我们提供了在SCM存储库中存储合同和存根的机制。当前唯一支持的SCM是Git。</p><p>存储库必须进行以下设置（您可以<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.1.x/contracts_git/" target="_top">在此处</a>检出）：</p><pre class="screen">.
&#9492;&#9472;&#9472; META-INF
    &#9492;&#9472;&#9472; com.example
        &#9492;&#9472;&#9472; beer-api-producer-git
            &#9492;&#9472;&#9472; 0.0.1-SNAPSHOT
                &#9500;&#9472;&#9472; contracts
                &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; beer-api-consumer
                &#9474;&nbsp;&nbsp;     &#9500;&#9472;&#9472; messaging
                &#9474;&nbsp;&nbsp;     &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; shouldSendAcceptedVerification.groovy
                &#9474;&nbsp;&nbsp;     &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; shouldSendRejectedVerification.groovy
                &#9474;&nbsp;&nbsp;     &#9492;&#9472;&#9472; rest
                &#9474;&nbsp;&nbsp;         &#9500;&#9472;&#9472; shouldGrantABeerIfOldEnough.groovy
                &#9474;&nbsp;&nbsp;         &#9492;&#9472;&#9472; shouldRejectABeerIfTooYoung.groovy
                &#9492;&#9472;&#9472; mappings
                    &#9492;&#9472;&#9472; beer-api-consumer
                        &#9492;&#9472;&#9472; rest
                            &#9500;&#9472;&#9472; shouldGrantABeerIfOldEnough.json
                            &#9492;&#9472;&#9472; shouldRejectABeerIfTooYoung.json</pre><p>下<code class="literal">META-INF</code>夹：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">我们通过以下方式对应用程序进行分组<code class="literal">groupId</code> （例如<code class="literal">com.example</code> ）</li><li class="listitem">然后通过<code class="literal">artifactId</code> （例如<code class="literal">beer-api-producer-git</code> ）</li><li class="listitem"><p class="simpara">接下来，是应用程序的版本（例如<code class="literal">0.0.1-SNAPSHOT</code> ）。从Spring Cloud Contract版本开始<code class="literal">2.1.0</code> ，您可以指定以下版本（假设您的版本遵循语义版本控制）</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><p class="simpara"><code class="literal">+</code>要么<code class="literal">latest</code> -查找存根的最新版本（假设快照始终是给定修订版本的最新工件）。这意味着：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:square"><li class="listitem">如果您有版本<code class="literal">1.0.0.RELEASE</code> ， <code class="literal">2.0.0.BUILD-SNAPSHOT</code>和<code class="literal">2.0.0.RELEASE</code>我们将假设最新的是<code class="literal">2.0.0.BUILD-SNAPSHOT</code></li><li class="listitem">如果您有版本<code class="literal">1.0.0.RELEASE</code>和<code class="literal">2.0.0.RELEASE</code>我们将假设最新的是<code class="literal">2.0.0.RELEASE</code></li><li class="listitem">如果您有一个名为<code class="literal">latest</code>要么<code class="literal">+</code>我们将选择该文件夹</li></ul></div></li><li class="listitem"><p class="simpara"><code class="literal">release</code> -查找存根的最新版本。这意味着：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:square"><li class="listitem">如果您有版本<code class="literal">1.0.0.RELEASE</code> ， <code class="literal">2.0.0.BUILD-SNAPSHOT</code>和<code class="literal">2.0.0.RELEASE</code>我们将假设最新的是<code class="literal">2.0.0.RELEASE</code></li><li class="listitem">如果您有一个名为<code class="literal">release</code>我们将选择该文件夹</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">最后，有两个文件夹：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">contracts</code> -优良作法是将每个消费者所需的合同与消费者名称一起存储在文件夹中（例如<code class="literal">beer-api-consumer</code> ）。这样您就可以使用<code class="literal">stubs-per-consumer</code>特征。进一步的目录结构是任意的。</li><li class="listitem"><code class="literal">mappings</code> -在此文件夹中，Maven / Gradle Spring Cloud Contract插件将推送存根服务器映射。在使用者方面，Stub Runner将扫描此文件夹以使用存根定义启动存根服务器。文件夹结构将是在<code class="literal">contracts</code>子文件夹。</li></ul></div></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_protocol_convention" href="#_protocol_convention"></a> 88.6.1协议约定</h3></div></div></div><p>为了控制合同来源的类型和位置（无论是二进制存储还是SCM存储库），可以在存储库URL中使用协议。Spring Cloud Contract遍历已注册的协议解析器，并尝试（通过插件）或Stub（通过Stub Runner）获取合同。</p><p>目前，对于SCM功能，我们支持Git存储库。要使用它，在属性中需要放置存储库URL的位置，您只需在连接URL前面加上前缀<code class="literal">git://</code> 。在这里您可以找到几个示例：</p><pre class="screen">git://file:///foo/bar
git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git
git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer_2" href="#_producer_2"></a> 88.6.2生产者</h3></div></div></div><p>对于生产者，要使用SCM方法，我们可以重用与外部合同相同的机制。我们通过包含以下内容的URL路由Spring Cloud Contract以使用SCM实现<code class="literal">git://</code>协议。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您必须手动添加<code class="literal">pushStubsToScm</code>在Maven中实现目标或执行（绑定） <code class="literal">pushStubsToScm</code> Gradle中的任务。我们不会将存根推送到<code class="literal">origin</code>开箱即用的git存储库。</p></td></tr></tbody></table></div><p><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Base class mappings etc. --&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We want to pick contracts from a Git repository --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsRepositoryUrl&gt;</span>git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsRepositoryUrl&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractDependency&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>${project.groupId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>${project.artifactId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${project.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractDependency&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- The contracts mode can't be classpath --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsMode&gt;</span>REMOTE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsMode&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;phase&gt;</span>package<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/phase&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal --&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>pushStubsToScm<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>
</p><p><b>摇篮。</b>
</p><pre class="programlisting">contracts {
	// We want to pick contracts from a Git repository
	contractDependency {
		stringNotation = "${project.group}:${project.name}:${project.version}"
	}
	/*
	We reuse the contract dependency section to set up the path
	to the folder that contains the contract definitions. In our case the
	path will be /groupId/artifactId/version/contracts
	 */
	contractRepository {
		repositoryUrl = "git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git"
	}
	// The mode can't be classpath
	contractsMode = "REMOTE"
	// Base class mappings etc.
}

/*
In this scenario we want to publish stubs to SCM whenever
the `publish` task is executed
*/
publish.dependsOn("publishStubsToScm")</pre><p>
</p><p>通过这样的设置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">Git项目将被克隆到一个临时目录</li><li class="listitem">SCM存根下载器将转到<code class="literal">META-INF/groupId/artifactId/version/contracts</code>文件夹中查找合同。例如<code class="literal">com.example:foo:1.0.0</code>路径将是<code class="literal">META-INF/com.example/foo/1.0.0/contracts</code></li><li class="listitem">将根据合同生成测试</li><li class="listitem">将根据合同创建存根</li><li class="listitem">测试通过后，存根将在克隆的存储库中提交</li><li class="listitem">最后，将推动该回购协议的<code class="literal">origin</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer_with_contracts_stored_locally" href="#_producer_with_contracts_stored_locally"></a> 88.6.3生产者，合同在本地存储</h3></div></div></div><p>将SCM用作存根和合同目的地的另一种选择是与生产者一起在本地存储合同，并且仅将合同和存根推送到SCM。在下面，您可以找到使用Maven和Gradle实现此目的所需的设置。</p><p><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- In the default configuration, we want to use the contracts stored locally --&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMappings&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMapping&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractPackageRegex&gt;</span>.*messaging.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractPackageRegex&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassFQN&gt;</span>com.example.BeerMessagingBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassFQN&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMapping&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMapping&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractPackageRegex&gt;</span>.*rest.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractPackageRegex&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassFQN&gt;</span>com.example.BeerRestBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassFQN&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMapping&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMappings&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;basePackageForTests&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/basePackageForTests&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;phase&gt;</span>package<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/phase&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- By default we will not push the stubs back to SCM,
				you have to explicitly add it as a goal --&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>pushStubsToScm<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We want to pick contracts from a Git repository --&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsRepositoryUrl&gt;</span>git://file://${env.ROOT}/target/contract_empty_git/
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsRepositoryUrl&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Example of URL via git protocol --&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;contractsRepositoryUrl&gt;git://git@github.com:spring-cloud-samples/spring-cloud-contract-samples.git&lt;/contractsRepositoryUrl&gt;--&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Example of URL via http protocol --&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;contractsRepositoryUrl&gt;git://https://github.com/spring-cloud-samples/spring-cloud-contract-samples.git&lt;/contractsRepositoryUrl&gt;--&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We reuse the contract dependency section to set up the path
				to the folder that contains the contract definitions. In our case the
				path will be /groupId/artifactId/version/contracts --&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractDependency&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>${project.groupId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>${project.artifactId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${project.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractDependency&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- The mode can't be classpath --&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsMode&gt;</span>LOCAL<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsMode&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>
</p><p><b>摇篮。</b>
</p><pre class="programlisting">contracts {
		// Base package for generated tests
	basePackageForTests = "com.example"
	baseClassMappings {
		baseClassMapping(".*messaging.*", "com.example.BeerMessagingBase")
		baseClassMapping(".*rest.*", "com.example.BeerRestBase")
	}
}

/*
In this scenario we want to publish stubs to SCM whenever
the `publish` task is executed
*/
publishStubsToScm {
	// We want to modify the default set up of the plugin when publish stubs to scm is called
	customize {
		// We want to pick contracts from a Git repository
		contractDependency {
			stringNotation = "${project.group}:${project.name}:${project.version}"
		}
		/*
		We reuse the contract dependency section to set up the path
		to the folder that contains the contract definitions. In our case the
		path will be /groupId/artifactId/version/contracts
		 */
		contractRepository {
			repositoryUrl = "git://file://${System.getenv("ROOT")}/target/contract_empty_git/"
		}
		// The mode can't be classpath
		contractsMode = "LOCAL"
	}
}

publish.dependsOn("publishStubsToScm")
publishToMavenLocal.dependsOn("publishStubsToScm")</pre><p>
</p><p>通过这样的设置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">违约合同<code class="literal">src/test/resources/contracts</code>将选择目录</li><li class="listitem">将根据合同生成测试</li><li class="listitem">将根据合同创建存根</li><li class="listitem"><p class="simpara">一旦测试通过</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">Git项目将被克隆到一个临时目录</li><li class="listitem">存根和合同将在克隆的存储库中提交</li></ul></div></li><li class="listitem">最后，将推动该回购协议的<code class="literal">origin</code></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_keeping_contracts_with_the_producer_and_stubs_in_an_external_repository" href="#_keeping_contracts_with_the_producer_and_stubs_in_an_external_repository"></a>保持与生产者的合同和存根在外部存储库中</h4></div></div></div><p>也可以将合同保留在生产者存储库中，但将存根保留在外部git repo中。当您想使用基本的消费者-生产者协作流程，但又无法使用工件存储库来存储存根时，这是最有用的。</p><p>为此，请使用通常的生产者设置，然后添加<code class="literal">pushStubsToScm</code>目标和设定<code class="literal">contractsRepositoryUrl</code>到要保留存根的存储库。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer_2" href="#_consumer_2"></a> 88.6.4消费者</h3></div></div></div><p>在消费者方面，通过<code class="literal">repositoryRoot</code>参数，从<code class="literal">@AutoConfigureStubRunner</code>注释，JUnit规则，JUnit 5扩展或属性，足以传递带有协议前缀的SCM存储库的URL。例如</p><pre class="programlisting">@AutoConfigureStubRunner(
    stubsMode=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"REMOTE"</span>,
    repositoryRoot=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git"</span>,
    ids=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:bookstore:0.0.1.RELEASE"</span>
)</pre><p>通过这样的设置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">Git项目将被克隆到一个临时目录</li><li class="listitem">SCM存根下载器将转到<code class="literal">META-INF/groupId/artifactId/version/</code>文件夹以查找存根定义和合同。例如<code class="literal">com.example:foo:1.0.0</code>路径将是<code class="literal">META-INF/com.example/foo/1.0.0/</code></li><li class="listitem">存根服务器将启动并提供映射</li><li class="listitem">将在消息传递测试中读取和使用消息传递定义</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_can_i_use_the_pact_broker" href="#_can_i_use_the_pact_broker"></a> 88.7我可以使用契约代理吗？</h2></div></div></div><p>使用<a class="link" href="https://pact.io/" target="_top">Pact时</a> ，可以使用<a class="link" href="https://github.com/pact-foundation/pact_broker" target="_top">Pact Broker</a>来存储和共享Pact定义。从Spring Cloud Contract 2.0.0开始，您可以从Pact Broker获取Pact文件以生成测试和存根。</p><p>作为前提条件，需要Pact Converter和Pact Stub Downloader。您必须通过添加<code class="literal">spring-cloud-contract-pact</code>依赖性。您可以在<a class="xref" href="#pact-converter" title="96.1.1 Pact转换器">第96.1.1节“协议转换器”</a>部分中了解更多信息。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>条约遵循《消费者合同》约定。这意味着消费者首先创建契约约定，然后与生产者共享文件。这些期望是由消费者的代码产生的，如果不满足期望，则可能破坏生产者。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pact_consumer" href="#_pact_consumer"></a> 88.7.1契约使用者</h3></div></div></div><p>使用者使用Pact框架生成Pact文件。该契约文件将发送到契约代理。可以在<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.1.x/consumer_pact" target="_top">此处</a>找到此类设置的示例。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer_3" href="#_producer_3"></a> 88.7.2生产者</h3></div></div></div><p>对于生产者，要使用Pact Broker中的Pact文件，我们可以重复使用与外部合同相同的机制。我们通过包含以下内容的URL路由Spring Cloud Contract以使用Pact实现： <code class="literal">pact://</code>协议。只需将URL传递给Pact Broker。可以在<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.1.x/producer_pact" target="_top">此处</a>找到此类设置的示例。</p><p><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Base class mappings etc. --&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We want to pick contracts from a Git repository --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsRepositoryUrl&gt;</span>pact://http://localhost:8085<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsRepositoryUrl&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractDependency&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>${project.groupId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>${project.artifactId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- When + is passed, a latest tag will be applied when fetching pacts --&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>+<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractDependency&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- The contracts mode can't be classpath --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsMode&gt;</span>REMOTE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsMode&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Don't forget to add spring-cloud-contract-pact to the classpath! --&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-pact<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>
</p><p><b>摇篮。</b>
</p><pre class="programlisting">buildscript {
	repositories {
		//...
	}

	dependencies {
		// ...
		// Don't forget to add spring-cloud-contract-pact to the classpath!
		classpath "org.springframework.cloud:spring-cloud-contract-pact:${contractVersion}"
	}
}

contracts {
	// When + is passed, a latest tag will be applied when fetching pacts
	contractDependency {
		stringNotation = "${project.group}:${project.name}:+"
	}
	contractRepository {
		repositoryUrl = "pact://http://localhost:8085"
	}
	// The mode can't be classpath
	contractsMode = "REMOTE"
	// Base class mappings etc.
}</pre><p>
</p><p>通过这样的设置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">契约文件将从契约代理下载</li><li class="listitem">Spring Cloud Contract将Pact文件转换为测试和存根</li><li class="listitem">与存根一样的JAR会像往常一样自动创建</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pact_consumer_producer_contract_approach" href="#_pact_consumer_producer_contract_approach"></a> 88.7.3契约消费者（生产者合同法）</h3></div></div></div><p>在您不想执行“消费者合同”方法（为每个消费者定义期望）但您更愿意执行“生产者合同”（生产者提供合同并发布存根）的情况下，使用Spring Cloud Contract就足够了与Stub Runner选项一起使用。可以在<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.1.x/consumer_pact_stubrunner" target="_top">此处</a>找到此类设置的示例。</p><p>首先，请记住添加Stub Runner和Spring Cloud Contract Pact模块作为测试依赖项。</p><p><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Don't forget to add spring-cloud-contract-pact to the classpath! --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- ... --&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-stub-runner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-pact<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre><p>
</p><p><b>摇篮。</b>
</p><pre class="programlisting">dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}

dependencies {
    //...
    testCompile("org.springframework.cloud:spring-cloud-starter-contract-stub-runner")
    // Don't forget to add spring-cloud-contract-pact to the classpath!
    testCompile("org.springframework.cloud:spring-cloud-contract-pact")
}</pre><p>
</p><p>接下来，只需将Pact Broker的URL传递到<code class="literal">repositoryRoot</code> ，以开头<code class="literal">pact://</code>协议。例如<code class="literal">pact://http://localhost:8085</code></p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(stubsMode = StubRunnerProperties.StubsMode.REMOTE,
		ids = "com.example:beer-api-producer-pact",
		repositoryRoot = "pact://http://localhost:8085")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BeerControllerTest {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Inject the port of the running stub</span>
    <em><span class="hl-annotation" style="color: gray">@StubRunnerPort("beer-api-producer-pact")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> producerPort;
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
}</pre><p>通过这样的设置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">契约文件将从契约代理下载</li><li class="listitem">Spring Cloud Contract将Pact文件转换为存根定义</li><li class="listitem">存根服务器将启动并被存入存根</li></ul></div><p>有关Pact支持的更多信息，请转到<a class="xref" href="#pact-stub-downloader" title="96.7使用契约存根下载器">第96.7节“使用Pact存根下载器”</a>部分。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_how_can_i_debug_the_requestresponse_being_sent_by_the_generated_tests_client" href="#_how_can_i_debug_the_requestresponse_being_sent_by_the_generated_tests_client"></a> 88.8如何调试生成的测试客户端发送的请求/响应？</h2></div></div></div><p>生成的测试全部以依赖<a class="link" href="https://hc.apache.org/httpcomponents-client-ga/" target="_top">Apache HttpClient的</a>某种形式或方式归结为RestAssured。HttpClient具有一种称为“ <a class="link" href="https://hc.apache.org/httpcomponents-client-ga/logging.html#Wire_Logging" target="_top">有线记录”的功能</a> ，该功能会将整个请求和响应记录到HttpClient中。Spring Boot具有一个日志记录<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html" target="_top">通用应用程序属性，可</a>用于执行此类操作，只需将其添加到您的应用程序属性中</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">logging.level.org.apache.http.wire</span>=DEBUG</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_can_i_debug_the_mappingrequestresponse_being_sent_by_wiremock" href="#_how_can_i_debug_the_mappingrequestresponse_being_sent_by_wiremock"></a> 88.8.1如何调试WireMock发送的映射/请求/响应？</h3></div></div></div><p>从版本开始<code class="literal">1.2.0</code>我们打开WireMock日志记录到info信息，并打开WireMock通知符以显示详细信息。现在，您将完全知道WireMock服务器收到了什么请求，以及选择了哪个匹配的响应定义。</p><p>要关闭此功能，只需将WireMock日志记录更改为<code class="literal">ERROR</code></p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">logging.level.com.github.tomakehurst.wiremock</span>=ERROR</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_can_i_see_what_got_registered_in_the_http_server_stub" href="#_how_can_i_see_what_got_registered_in_the_http_server_stub"></a> 88.8.2如何查看在HTTP服务器存根中注册了什么？</h3></div></div></div><p>您可以使用<code class="literal">mappingsOutputFolder</code>财产<code class="literal">@AutoConfigureStubRunner</code> ， <code class="literal">StubRunnerRule</code>或`StubRunnerExtension`以按工件ID转储所有映射。另外，将连接启动给定存根服务器的端口。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_can_i_reference_text_from_file" href="#_can_i_reference_text_from_file"></a> 88.8.3我可以引用文件中的文本吗？</h3></div></div></div><p>是!在1.2.0版中，我们添加了这种可能性。打电话就足够了<code class="literal">file(…​)</code> DSL中的方法，并提供相对于合同所在位置的路径。如果您使用的是YAML，请使用<code class="literal">bodyFromFile</code>属性。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_verifier_setup" href="#_spring_cloud_contract_verifier_setup"></a> 89。Spring Cloud Contract Verifier设置</h2></div></div></div><p>您可以通过以下方式设置Spring Cloud Contract Verifier：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="#gradle-project" title="89.1 Gradle项目">作为Gradle项目</a></li><li class="listitem"><a class="link" href="#maven-project" title="90.13 Maven项目">作为Maven项目</a></li><li class="listitem"><a class="link" href="#docker-project" title="90.16 Docker项目">作为Docker项目</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-project" href="#gradle-project"></a> 89.1 Gradle项目</h2></div></div></div><p>要了解如何为Spring Cloud Contract Verifier设置Gradle项目，请阅读以下部分：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#gradle-prerequisites" title="89.1.1前提条件">第89.1.1节“前提条件”</a></li><li class="listitem"><a class="xref" href="#gradle-add-gradle-plugin" title="90添加具有依赖项的Gradle插件">第90章， <i>添加具有依赖性的Gradle插件</i></a></li><li class="listitem"><a class="xref" href="#gradle-and-rest-assured" title="90.1摇篮和休息保证2.0">第90.1节“等级和休息保证2.0”</a></li><li class="listitem"><a class="xref" href="#gradle-snapshot-versions" title="90.2 Gradle的快照版本">第90.2节“ Gradle的快照版本”</a></li><li class="listitem"><a class="xref" href="#gradle-add-stubs" title="90.3添加存根">第90.3节“添加存根”</a></li><li class="listitem"><a class="xref" href="#gradle-default-setup" title="90.5默认设置">第90.5节“默认设置”</a></li><li class="listitem"><a class="xref" href="#gradle-configure-plugin" title="90.6配置插件">第90.6节“配置插件”</a></li><li class="listitem"><a class="xref" href="#gradle-configuration-options" title="90.7配置选项">第90.7节“配置选项”</a></li><li class="listitem"><a class="xref" href="#gradle-single-base-class" title="90.8适用于所有测试的单一基类">第90.8节“所有测试的单一基类”</a></li><li class="listitem"><a class="xref" href="#gradle-different-base-classes" title="90.9合同的不同基本类别">第90.9节“合同的不同基本类别”</a></li><li class="listitem"><a class="xref" href="#gradle-invoking-generated-tests" title="90.10调用生成的测试">第90.10节“调用生成的测试”</a></li><li class="listitem"><a class="xref" href="#gradle-pushing-stubs-to-scm" title="90.11将存根推送到SCM">第90.11节“将存根推送到SCM”</a></li><li class="listitem"><a class="xref" href="#gradle-consumer" title="90.12消费者方的Spring Cloud Contract Verifier">第90.12节“消费者方的Spring Cloud合同验证程序”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="gradle-prerequisites" href="#gradle-prerequisites"></a> 89.1.1前提条件</h3></div></div></div><p>为了在WireMock中使用Spring Cloud Contract Verifier，您必须使用Gradle或Maven插件。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果要在项目中使用Spock，则必须单独添加<code class="literal">spock-core</code>和<code class="literal">spock-spring</code>模块。查看<a class="link" href="https://spockframework.github.io/" target="_top">Spock文档以获取更多信息</a></p></td></tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gradle-add-gradle-plugin" href="#gradle-add-gradle-plugin"></a> 90添加具有依赖项的Gradle插件</h2></div></div></div><p>要添加具有依赖性的Gradle插件，您可以使用类似于以下代码：</p><div class="informalexample"><p class="primary"><b>插件DSL GA版本。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// build.gradle</span>
plugins {
  id <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"groovy"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// this will work only for GA versions of Spring Cloud Contract</span>
  id <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract"</span> version <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${GAVerifierVersion}"</span>
}

dependencyManagement {
	imports {
		mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-dependencies:${GAVerifierVersion}"</span>
	}
}

dependencies {
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.codehaus.groovy:groovy-all:${groovyVersion}"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// example with adding Spock core and Spock Spring</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.spockframework:spock-core:${spockVersion}"</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.spockframework:spock-spring:${spockVersion}"</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud:spring-cloud-starter-contract-verifier'</span>
}</pre><p class="primary">
</p><p class="secondary"><b>插件DSL非GA版本。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// settings.gradle</span>
pluginManagement {
	plugins {
		id <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract"</span> version <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${verifierVersion}"</span>
	}
    repositories {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// to pick from local .m2</span>
        mavenLocal()
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// for snapshots</span>
        maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/snapshot"</span> }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// for milestones</span>
        maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/milestone"</span> }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// for GA versions</span>
        gradlePluginPortal()
    }
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// build.gradle</span>
plugins {
  id <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"groovy"</span>
  id <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract"</span>
}

dependencyManagement {
	imports {
		mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-dependencies:${verifierVersion}"</span>
	}
}

dependencies {
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.codehaus.groovy:groovy-all:${groovyVersion}"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// example with adding Spock core and Spock Spring</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.spockframework:spock-core:${spockVersion}"</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.spockframework:spock-spring:${spockVersion}"</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud:spring-cloud-starter-contract-verifier'</span>
}</pre><p class="secondary">
</p><p class="secondary"><b>旧版插件应用程序。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// build.gradle</span>
buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"</span>
		classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// here you can also pass additional dependencies such as Pact or Kotlin spec e.g.:</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// classpath "org.springframework.cloud:spring-cloud-contract-spec-kotlin:${verifier_version}"</span>
	}
}

apply plugin: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'groovy'</span>
apply plugin: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'spring-cloud-contract'</span>

dependencyManagement {
	imports {
		mavenBom <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-dependencies:${verifier_version}"</span>
	}
}

dependencies {
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.codehaus.groovy:groovy-all:${groovyVersion}"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// example with adding Spock core and Spock Spring</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.spockframework:spock-core:${spockVersion}"</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.spockframework:spock-spring:${spockVersion}"</span>
	testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud:spring-cloud-starter-contract-verifier'</span>
}</pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-and-rest-assured" href="#gradle-and-rest-assured"></a> 90.1摇篮和休息保证2.0</h2></div></div></div><p>默认情况下，Rest Assured 3.x被添加到类路径中。但是，要使用Rest Assured 2.x，可以将其添加到插件的classpath中，如下所示：</p><pre class="programlisting">buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
	    classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"</span>
		classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"</span>
		classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.jayway.restassured:rest-assured:2.5.0"</span>
		classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.jayway.restassured:spring-mock-mvc:2.5.0"</span>
	}
}

depenendencies {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// all dependencies</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// you can exclude rest-assured from spring-cloud-contract-verifier</span>
    testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.jayway.restassured:rest-assured:2.5.0"</span>
    testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.jayway.restassured:spring-mock-mvc:2.5.0"</span>
}</pre><p>这样，该插件会自动看到类路径中存在Rest Assured 2.x，并相应地修改了导入。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-snapshot-versions" href="#gradle-snapshot-versions"></a> 90.2 Gradle的快照版本</h2></div></div></div><p>将其他快照存储库添加到build.gradle以使用快照版本，快照版本在每次成功构建后都会自动上传，如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 We need to use the [buildscript {}] section when we have to modify
 the classpath for the plugins. If that's not the case this section
 can be skipped.

 If you don't need to modify the classpath (e.g. add a Pact dependency),
 then you can just set the [pluginManagement {}] section in [settings.gradle] file.

 // settings.gradle
 pluginManagement {
    repositories {
        // for snapshots
        maven {url "https://repo.spring.io/snapshot"}
        // for milestones
        maven {url "https://repo.spring.io/milestone"}
        // for GA versions
        gradlePluginPortal()
    }
 }

 */</span>
buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/snapshot"</span> }
		maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/milestone"</span> }
		maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/release"</span> }
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-add-stubs" href="#gradle-add-stubs"></a> 90.3添加存根</h2></div></div></div><p>默认情况下，Spring Cloud Contract Verifier会在<code class="literal">src/test/resources/contracts</code>目录。</p><p>包含存根定义的目录被视为类名，每个存根定义均被视为单个测试。 Spring Cloud Contract Verifier假定它至少包含将用作测试类名称的一级目录。如果存在多个嵌套目录，则使用除最后一个嵌套目录以外的所有目录作为包名。例如，具有以下结构：</p><pre class="programlisting">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</pre><p>Spring Cloud Contract Verifier创建一个名为的测试类<code class="literal">defaultBasePackage.MyService</code>有两种方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">shouldCreateUser()</code></li><li class="listitem"><code class="literal">shouldReturnUser()</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-run-plugin" href="#gradle-run-plugin"></a> 90.4运行插件</h2></div></div></div><p>该插件会注册自己，以便在<code class="literal">check</code>任务。如果您希望它成为构建过程的一部分，则无需执行其他任何操作。如果您只想生成测试，请调用<code class="literal">generateContractTests</code>任务。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-default-setup" href="#gradle-default-setup"></a> 90.5默认设置</h2></div></div></div><p>默认的Gradle插件设置创建了以下构建的Gradle部分（以伪代码）：</p><pre class="programlisting">contracts {
    testFramework =<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'JUNIT'</span>
    testMode = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'MockMvc'</span>
    generatedTestSourcesDir = project.file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/generated-test-sources/contracts"</span>)
    generatedTestResourcesDir = project.file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/generated-test-resources/contracts"</span>)
    contractsDslDir = file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.rootDir}/src/test/resources/contracts"</span>)
    basePackageForTests = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.verifier.tests'</span>
    stubsOutputDir = project.file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/stubs"</span>)

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the following properties are used when you want to provide where the JAR with contract lays</span>
    contractDependency {
        stringNotation = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>
    }
    contractsPath = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>
    contractsWorkOffline = false
    contractRepository {
        cacheDownloadedContracts(true)
    }
}

tasks.create(type: Jar, name: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'verifierStubsJar'</span>, dependsOn: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'generateClientStubs'</span>) {
    baseName = project.name
    classifier = contracts.stubsSuffix
    from contractVerifier.stubsOutputDir
}

project.artifacts {
    archives task
}

tasks.create(type: Copy, name: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'copyContracts'</span>) {
    from contracts.contractsDslDir
    into contracts.stubsOutputDir
}

verifierStubsJar.dependsOn <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'copyContracts'</span>

publishing {
    publications {
        stubs(MavenPublication) {
            artifactId project.name
            artifact verifierStubsJar
        }
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-configure-plugin" href="#gradle-configure-plugin"></a> 90.6配置插件</h2></div></div></div><p>要更改默认配置，请添加一个<code class="literal">contracts</code>您的Gradle配置的摘要，如下所示：</p><pre class="programlisting">contracts {
	testMode = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'MockMvc'</span>
	baseClassForTests = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.mycompany.tests'</span>
	generatedTestSourcesDir = project.file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'src/generatedContract'</span>)
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-configuration-options" href="#gradle-configuration-options"></a> 90.7配置选项</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>testMode</strong></span> ：定义验收测试的模式。默认情况下，该模式是MockMvc，它基于Spring的MockMvc。对于真实的HTTP调用，也可以将其更改为<span class="strong"><strong>WebTestClient</strong></span> ， <span class="strong"><strong>JaxRsClient</strong></span>或<span class="strong"><strong>Explicit</strong></span> 。</li><li class="listitem"><span class="strong"><strong>imports</strong></span> ：创建一个带有导入的数组，该数组应包含在生成的测试中（例如['org.myorg。匹配器]]。默认情况下，它将创建一个空数组。</li><li class="listitem"><span class="strong"><strong>staticImports</strong></span> ：使用静态导入创建一个数组，该数组应包含在生成的测试中（例如['org.myorg。匹配器。*']）。默认情况下，它将创建一个空数组。</li><li class="listitem"><span class="strong"><strong>basePackageForTests</strong></span> ：指定所有生成的测试的基本软件包。如果未设置，则从<code class="literal">baseClassForTests’s package and from `packageWithBaseClasses</code> 。如果这些值均未设置，则将该值设置为<code class="literal">org.springframework.cloud.contract.verifier.tests</code> 。</li><li class="listitem"><span class="strong"><strong>baseClassForTests</strong></span> ：为所有生成的测试创建基类。默认情况下，如果使用Spock类，则该类为<code class="literal">spock.lang.Specification</code> 。</li><li class="listitem"><span class="strong"><strong>packageWithBaseClasses</strong></span> ：定义所有基类所在的包。此设置优先于<span class="strong"><strong>baseClassForTests</strong></span> 。</li><li class="listitem"><span class="strong"><strong>baseClassMappings</strong></span> ：明确地将合同包映射到基类的FQN。此设置优先于<span class="strong"><strong>packageWithBaseClasses</strong></span>和<span class="strong"><strong>baseClassForTests</strong></span> 。</li><li class="listitem"><span class="strong"><strong>ruleClassForTests</strong></span> ：指定应添加到生成的测试类的规则。</li><li class="listitem"><span class="strong"><strong>ignoreFiles</strong></span> ：使用一个<code class="literal">Antmatcher</code>允许定义应跳过其处理的存根文件。默认情况下，它是一个空数组。</li><li class="listitem"><span class="strong"><strong>ContractsDslDir</strong></span> ：指定包含使用GroovyDSL编写的合同的目录。默认情况下，其值为<code class="literal">$rootDir/src/test/resources/contracts</code> 。</li><li class="listitem"><span class="strong"><strong>createdTestSourcesDir</strong></span> ：指定应放置从Groovy DSL生成的测试的测试源目录。默认情况下，其值为<code class="literal">$buildDir/generated-test-sources/contracts</code> 。</li><li class="listitem"><span class="strong"><strong>createdTestResourcesDir</strong></span> ：指定测试资源目录，应放置Groovy DSL生成的测试所使用的资源。默认情况下，其值为<code class="literal">$buildDir/generated-test-resources/contracts</code> 。</li><li class="listitem"><span class="strong"><strong>stubsOutputDir</strong></span> ：指定应放置Groovy DSL生成的WireMock存根的目录。</li><li class="listitem"><span class="strong"><strong>testFramework</strong></span> ：指定要使用的目标测试框架。目前，Spock是JUnit 4（ <code class="literal">TestFramework.JUNIT</code> ）和JUnit 5，默认的框架是JUnit 4。</li><li class="listitem"><span class="strong"><strong>contractProperties</strong></span> ：包含要传递给Spring Cloud Contract组件的属性的映射。这些属性可能由内置或自定义存根下载器使用。</li></ul></div><p>当您要指定包含合同的JAR的位置时，使用以下属性：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>contractDependency</strong></span> ：指定提供的依赖关系<code class="literal">groupid:artifactid:version:classifier</code>坐标。您可以使用<code class="literal">contractDependency</code>关闭以进行设置。</li><li class="listitem"><span class="strong"><strong>ContractsPath</strong></span> ：指定jar的路径。如果下载了合同依存关系，则路径默认为<code class="literal">groupid/artifactid</code>哪里<code class="literal">groupid</code>斜线分隔。否则，它将在提供的目录下扫描合同。</li><li class="listitem"><span class="strong"><strong>ContractsMode</strong></span> ：指定下载合同的方式（JAR是否可以脱机使用，远程使用等）。</li><li class="listitem"><span class="strong"><strong>deleteStubsAfterTest</strong></span> ：如果设置为<code class="literal">false</code>不会从临时目录中删除任何下载的合同</li></ul></div><p>您可以在下面找到可以通过插件打开的实验功能的列表：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>convertToYaml</strong></span> ：将所有DSL转换为声明性的YAML格式。当您在Groovy DSL中使用外部库时，这可能非常有用。通过启用此功能（将其设置为<code class="literal">true</code> ），则无需在用户端添加库依赖项。</li><li class="listitem"><span class="strong"><strong>assertJsonSize</strong></span> ：您可以在生成的测试中检查JSON数组的大小。默认情况下禁用此功能。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-single-base-class" href="#gradle-single-base-class"></a> 90.8适用于所有测试的单一基类</h2></div></div></div><p>在默认的MockMvc中使用Spring Cloud Contract Verifier时，您需要为所有生成的验收测试创建基本规范。在此类中，您需要指向一个端点，该端点应进行验证。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BaseMockMvcSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PairIdController())
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> isProperCorrelationId(Integer correlationId) {
		assert correlationId == <span class="hl-number">123456</span>
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> isEmpty(String value) {
		assert value == null
	}

}</pre><p>如果您使用<code class="literal">Explicit</code>模式，您可以使用基类来初始化整个测试的应用程序，就像在常规集成测试中看到的那样。如果您使用<code class="literal">JAXRSCLIENT</code>模式，此基类还应包含一个<code class="literal">protected WebTarget webTarget</code>领域。现在，测试JAX-RS API的唯一选择是启动Web服务器。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-different-base-classes" href="#gradle-different-base-classes"></a> 90.9合同的不同基本类别</h2></div></div></div><p>如果合同之间的基类不同，则可以告诉Spring Cloud Contract插件应通过自动生成的测试扩展哪个类。您有两种选择：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">遵循惯例，提供<code class="literal">packageWithBaseClasses</code></li><li class="listitem">通过提供显式映射<code class="literal">baseClassMappings</code></li></ul></div><p><span class="strong"><strong>按照惯例</strong></span></p><p>约定是，例如，如果您根据（例如） <code class="literal">src/test/resources/contract/foo/bar/baz/</code>并设置<code class="literal">packageWithBaseClasses</code>财产<code class="literal">com.example.base</code> ，则Spring Cloud Contract Verifier假设存在一个<code class="literal">BarBazBase</code>下课<code class="literal">com.example.base</code>包。换句话说，系统将获取程序包的最后两个部分（如果存在），并使用<code class="literal">Base</code>后缀。此规则优先于<span class="strong"><strong>baseClassForTests</strong></span> 。这是一个如何在<code class="literal">contracts</code>关闭：</p><pre class="programlisting">packageWithBaseClasses = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'com.example.base'</span></pre><p><span class="strong"><strong>通过映射</strong></span></p><p>您可以将合同包的正则表达式手动映射到匹配合同的基类的完全限定名称。您必须提供一个名为<code class="literal">baseClassMappings</code>包括<code class="literal">baseClassMapping</code>需要一个<code class="literal">contractPackageRegex</code>至<code class="literal">baseClassFQN</code>映射。考虑以下示例：</p><pre class="programlisting">baseClassForTests = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example.FooBase"</span>
baseClassMappings {
	baseClassMapping(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'.*/com/.*'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'com.example.ComBase'</span>)
	baseClassMapping(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'.*/bar/.*'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'com.example.BarBase'</span>)
}</pre><p>假设您的合同如下- <code class="literal">src/test/resources/contract/com/</code> --<code class="literal">src/test/resources/contract/foo/</code></p><p>通过提供<code class="literal">baseClassForTests</code> ，如果映射不成功，我们会有一个退路。（您也可以提供<code class="literal">packageWithBaseClasses</code>作为备用。）这样，从<code class="literal">src/test/resources/contract/com/</code>合同扩展了<code class="literal">com.example.ComBase</code> ，而其余测试将扩展<code class="literal">com.example.FooBase</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-invoking-generated-tests" href="#gradle-invoking-generated-tests"></a> 90.10调用生成的测试</h2></div></div></div><p>为了确保提供方符合已定义的合同，您需要调用：</p><pre class="programlisting">./gradlew generateContractTests <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-pushing-stubs-to-scm" href="#gradle-pushing-stubs-to-scm"></a> 90.11将存根推送到SCM</h2></div></div></div><p>如果您使用SCM存储库保留合同和存根，则可能要自动化将存根推送到存储库的步骤。为此，只需调用<code class="literal">pushStubsToScm</code>任务。例：</p><pre class="programlisting">$ ./gradlew pushStubsToScm</pre><p>在<a class="xref" href="#scm-stub-downloader" title="96.6使用SCM存根下载器">第96.6节“使用SCM存根下载器”下，</a>您可以找到可以通过以下方式传递的所有可能的配置选项： <code class="literal">contractsProperties</code>领域例如<code class="literal">contracts { contractsProperties = [foo:"bar"] }</code> ，通过<code class="literal">contractsProperties</code>方法，例如<code class="literal">contracts { contractsProperties([foo:"bar"]) }</code> ，系统属性或环境变量。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="gradle-consumer" href="#gradle-consumer"></a> 90.12消费者方的Spring Cloud Contract Verifier</h2></div></div></div><p>在消费服务中，您需要以与提供者相同的方式配置Spring Cloud Contract Verifier插件。如果您不想使用Stub Runner，则需要复制存储在<code class="literal">src/test/resources/contracts</code>并使用以下代码生成WireMock JSON存根：</p><pre class="programlisting">./gradlew generateClientStubs</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">stubsOutputDir</code>必须设置选项以使存根生成工作。</p></td></tr></tbody></table></div><p>如果存在，JSON存根可以用于使用服务的自动化测试中。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration(loader == SpringApplicationContextLoader, classes == Application)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> LoanApplicationServiceSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {

 <em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
 <em><span class="hl-annotation" style="color: gray">@Shared</span></em>
 WireMockClassRule wireMockRule == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> WireMockClassRule()

 <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
 LoanApplicationService sut

 def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should successfully apply for loan'</span>() {
   given:
 	LoanApplication application =
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> LoanApplication(client: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Client(clientPesel: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'12345678901'</span>), amount: <span class="hl-number">123.123</span>)
   when:
	LoanApplicationResult loanApplication == sut.loanApplication(application)
   then:
	loanApplication.loanApplicationStatus == LoanApplicationStatus.LOAN_APPLIED
	loanApplication.rejectionReason == null
 }
}</pre><p><code class="literal">LoanApplication</code>打电话给<code class="literal">FraudDetection</code>服务。由WireMock服务器处理此请求，该服务器配置有Spring Cloud Contract Verifier生成的存根。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="maven-project" href="#maven-project"></a> 90.13 Maven项目</h2></div></div></div><p>要了解如何为Spring Cloud Contract Verifier设置Maven项目，请阅读以下部分：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#maven-add-plugin" title="90.13.1添加Maven插件">第90.13.1节“添加maven插件”</a></li><li class="listitem"><a class="xref" href="#maven-rest-assured" title="90.13.2 Maven和安心保障2.0">第90.13.2节“ Maven and Rest Assured 2.0”</a></li><li class="listitem"><a class="xref" href="#maven-snapshot-versions" title="90.13.3 Maven的快照版本">第90.13.3节“ Maven的快照版本”</a></li><li class="listitem"><a class="xref" href="#maven-add-stubs" title="90.13.4添加存根">第90.13.4节“添加存根”</a></li><li class="listitem"><a class="xref" href="#maven-run-plugin" title="90.13.5运行插件">第90.13.5节“运行插件”</a></li><li class="listitem"><a class="xref" href="#maven-configure-plugin" title="90.13.6配置插件">第90.13.6节“配置插件”</a></li><li class="listitem"><a class="xref" href="#maven-configuration-options" title="90.13.7配置选项">第90.13.7节“配置选项”</a></li><li class="listitem"><a class="xref" href="#maven-single-base" title="90.13.8所有测试的单一基类">第90.13.8节“所有测试的单一基类”</a></li><li class="listitem"><a class="xref" href="#maven-different-base" title="90.13.9合同的不同基类">第90.13.9节“合同的不同基类”</a></li><li class="listitem"><a class="xref" href="#maven-invoking-generated-tests" title="90.13.10调用生成的测试">第90.13.10节，“调用生成的测试”</a></li><li class="listitem"><a class="xref" href="#maven-pushing-stubs-to-scm" title="90.13.11将存根推送到SCM">第90.13.11节，“将存根推送到SCM”</a></li><li class="listitem"><a class="xref" href="#maven-sts" title="90.13.12 Maven插件和STS">第90.13.12节，“ Maven插件和STS”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-add-plugin" href="#maven-add-plugin"></a> 90.13.1添加Maven插件</h3></div></div></div><p>以类似于以下方式添加Spring Cloud Contract BOM：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-release.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span></pre><p>接下来，添加<code class="literal">Spring Cloud Contract Verifier</code> Maven插件：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;packageWithBaseClasses&gt;</span>com.example.fraud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/packageWithBaseClasses&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;convertToYaml&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/convertToYaml&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>您可以在<a class="link" href="https://cloud.spring.io/spring-cloud-static/spring-cloud-contract/2.0.0.RELEASE/spring-cloud-contract-maven-plugin/" target="_top">Spring Cloud Contract Maven插件文档（例如<code class="literal">2.0.0.RELEASE</code>版本）</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-rest-assured" href="#maven-rest-assured"></a> 90.13.2 Maven和安心保障2.0</h3></div></div></div><p>默认情况下，Rest Assured 3.x被添加到类路径中。但是，您可以通过将Rest Assured 2.x添加到插件类路径中来使用它，如下所示：</p><pre class="programlisting">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;packageWithBaseClasses&gt;com.example&lt;/packageWithBaseClasses&gt;
    &lt;/configuration&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-contract-verifier&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
           &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
           &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
           &lt;version&gt;<span class="hl-number">2.5</span>.<span class="hl-number">0</span>&lt;/version&gt;
           &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
           &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
           &lt;artifactId&gt;spring-mock-mvc&lt;/artifactId&gt;
           &lt;version&gt;<span class="hl-number">2.5</span>.<span class="hl-number">0</span>&lt;/version&gt;
           &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;

&lt;dependencies&gt;
    &lt;!-- all dependencies --&gt;
    &lt;!-- you can exclude rest-assured from spring-cloud-contract-verifier --&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
       &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;
       &lt;version&gt;<span class="hl-number">2.5</span>.<span class="hl-number">0</span>&lt;/version&gt;
       &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
       &lt;groupId&gt;com.jayway.restassured&lt;/groupId&gt;
       &lt;artifactId&gt;spring-mock-mvc&lt;/artifactId&gt;
       &lt;version&gt;<span class="hl-number">2.5</span>.<span class="hl-number">0</span>&lt;/version&gt;
       &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre><p>这样，插件会自动看到类路径中存在Rest Assured 3.x，并相应地修改了导入。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-snapshot-versions" href="#maven-snapshot-versions"></a> 90.13.3 Maven的快照版本</h3></div></div></div><p>对于Snapshot和Milestone版本，您必须将以下部分添加到您的<code class="literal">pom.xml</code> ，如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repositories&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepositories&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-add-stubs" href="#maven-add-stubs"></a> 90.13.4添加存根</h3></div></div></div><p>默认情况下，Spring Cloud Contract Verifier会在<code class="literal">src/test/resources/contracts</code>目录。包含存根定义的目录被视为类名，每个存根定义均被视为单个测试。我们假定它至少包含一个目录用作测试类名称。如果嵌套目录有多个级别，则使用除最后一个嵌套目录以外的所有目录作为包名。例如，具有以下结构：</p><pre class="programlisting">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</pre><p>Spring Cloud Contract Verifier创建一个名为的测试类<code class="literal">defaultBasePackage.MyService</code>有两种方法</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">shouldCreateUser()</code></li><li class="listitem"><code class="literal">shouldReturnUser()</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-run-plugin" href="#maven-run-plugin"></a> 90.13.5运行插件</h3></div></div></div><p>插件目标<code class="literal">generateTests</code>分配给在以下阶段调用<code class="literal">generate-test-sources</code> 。如果您希望它成为构建过程的一部分，则无需执行任何操作。如果您只想生成测试，请调用<code class="literal">generateTests</code>目标。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-configure-plugin" href="#maven-configure-plugin"></a> 90.13.6配置插件</h3></div></div></div><p>要更改默认配置，只需添加一个<code class="literal">configuration</code>插件定义或<code class="literal">execution</code>定义，如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>convert<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>generateStubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>generateTests<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;basePackageForTests&gt;</span>org.springframework.cloud.verifier.twitter.place<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/basePackageForTests&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassForTests&gt;</span>org.springframework.cloud.verifier.twitter.place.BaseMockMvcSpec<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassForTests&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-configuration-options" href="#maven-configuration-options"></a> 90.13.7配置选项</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>testMode</strong></span> ：定义验收测试的模式。默认情况下，该模式是MockMvc，它基于Spring的MockMvc。对于真实的HTTP调用，也可以将其更改为<span class="strong"><strong>WebTestClient</strong></span> ， <span class="strong"><strong>JaxRsClient</strong></span>或<span class="strong"><strong>Explicit</strong></span> 。</li><li class="listitem"><span class="strong"><strong>basePackageForTests</strong></span> ：指定所有生成的测试的基本软件包。如果未设置，则从<code class="literal">baseClassForTests’s package and from `packageWithBaseClasses</code> 。如果这些值均未设置，则将该值设置为<code class="literal">org.springframework.cloud.contract.verifier.tests</code> 。</li><li class="listitem"><span class="strong"><strong>ruleClassForTests</strong></span> ：指定应添加到生成的测试类的规则。</li><li class="listitem"><span class="strong"><strong>baseClassForTests</strong></span> ：为所有生成的测试创建基类。默认情况下，如果使用Spock类，则该类为<code class="literal">spock.lang.Specification</code> 。</li><li class="listitem"><span class="strong"><strong>contractDirectory</strong></span> ：指定一个目录，其中包含用GroovyDSL编写的合同。默认目录是<code class="literal">/src/test/resources/contracts</code> 。</li><li class="listitem"><span class="strong"><strong>createdTestSourcesDir</strong></span> ：指定应放置从Groovy DSL生成的测试的测试源目录。默认情况下，其值为<code class="literal">$buildDir/generated-test-sources/contracts</code> 。</li><li class="listitem"><span class="strong"><strong>createdTestResourcesDir</strong></span> ：指定测试资源目录，在该目录中生成测试使用的资源</li><li class="listitem"><span class="strong"><strong>testFramework</strong></span> ：指定要使用的目标测试框架。目前，Spock是JUnit 4（ <code class="literal">TestFramework.JUNIT</code> ）和JUnit 5，默认的框架是JUnit 4。</li><li class="listitem"><span class="strong"><strong>packageWithBaseClasses</strong></span> ：定义所有基类所在的包。此设置优先于<span class="strong"><strong>baseClassForTests</strong></span> 。约定是这样的，如果您根据（例如）有合同<code class="literal">src/test/resources/contract/foo/bar/baz/</code>并设置<code class="literal">packageWithBaseClasses</code>财产<code class="literal">com.example.base</code> ，则Spring Cloud Contract Verifier假设存在一个<code class="literal">BarBazBase</code>下课<code class="literal">com.example.base</code>包。换句话说，系统将获取程序包的最后两个部分（如果存在），并使用<code class="literal">Base</code>后缀。</li><li class="listitem"><span class="strong"><strong>baseClassMappings</strong></span> ：指定提供以下内容的基类映射的列表<code class="literal">contractPackageRegex</code> ，并根据合同所在的包裹检查该包裹，以及<code class="literal">baseClassFQN</code> ，它映射到匹配合同的基类的完全限定名称。例如，如果您根据<code class="literal">src/test/resources/contract/foo/bar/baz/</code>并绘制属性<code class="literal">.* → com.example.base.BaseClass</code> ，则从这些合同生成的测试类将扩展<code class="literal">com.example.base.BaseClass</code> 。此设置优先于<span class="strong"><strong>packageWithBaseClasses</strong></span>和<span class="strong"><strong>baseClassForTests</strong></span> 。</li><li class="listitem"><span class="strong"><strong>contractProperties</strong></span> ：包含要传递给Spring Cloud Contract组件的属性的映射。这些属性可能由内置或自定义存根下载器使用。</li></ul></div><p>如果要从Maven存储库下载合同定义，则可以使用以下选项：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>contractDependency</strong></span> ：包含所有打包合同的合同依赖关系。</li><li class="listitem"><span class="strong"><strong>ContractsPath</strong></span> ：具有打包合同的JAR中具体合同的路径。默认为<code class="literal">groupid/artifactid</code>哪里<code class="literal">gropuid</code>斜线分隔。</li><li class="listitem"><span class="strong"><strong>ContractsMode</strong></span> ：选择将要找到并注册存根的模式</li><li class="listitem"><span class="strong"><strong>deleteStubsAfterTest</strong></span> ：如果设置为<code class="literal">false</code>不会从临时目录中删除任何下载的合同</li><li class="listitem"><span class="strong"><strong>contractRepositoryUrl</strong></span> ：包含合同的工件的仓库的URL。如果未提供，请使用当前的Maven。</li><li class="listitem"><span class="strong"><strong>contractRepositoryUsername</strong></span> ：用于通过合同连接到仓库的用户名。</li><li class="listitem"><span class="strong"><strong>contractRepositoryPassword</strong></span> ：用于通过合同连接到仓库的密码。</li><li class="listitem"><span class="strong"><strong>contractRepositoryProxyHost</strong></span> ：用于通过合同连接到仓库的代理主机。</li><li class="listitem"><span class="strong"><strong>ContractsRepositoryProxyPort</strong></span> ：用于通过合同连接到仓库的代理端口。</li></ul></div><p>我们仅缓存非快照的显式提供的版本（例如<code class="literal">+</code>要么<code class="literal">1.0.0.BUILD-SNAPSHOT</code>不会被缓存）。默认情况下，此功能处于打开状态。</p><p>您可以在下面找到可以通过插件打开的实验功能的列表：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>convertToYaml</strong></span> ：将所有DSL转换为声明性的YAML格式。当您在Groovy DSL中使用外部库时，这可能非常有用。通过启用此功能（将其设置为<code class="literal">true</code> ），则无需在用户端添加库依赖项。</li><li class="listitem"><span class="strong"><strong>assertJsonSize</strong></span> ：您可以在生成的测试中检查JSON数组的大小。默认情况下禁用此功能。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-single-base" href="#maven-single-base"></a> 90.13.8所有测试的单一基类</h3></div></div></div><p>在默认的MockMvc中使用Spring Cloud Contract Verifier时，您需要为所有生成的验收测试创建基本规范。在此类中，您需要指向一个端点，该端点应进行验证。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.mycompany.tests

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.mycompany.ExampleSpringController
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.jayway.restassured.module.mockmvc.RestAssuredMockMvc
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> spock.lang.Specification

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MvcSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {
  def setup() {
   RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ExampleSpringController())
  }
}</pre><p>如果需要，您还可以设置整个上下文。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.module.mockmvc.RestAssuredMockMvc;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.runner.RunWith;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.web.context.WebApplicationContext;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, classes = SomeConfig.class, properties="some=property")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BaseTestClass {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	WebApplicationContext context;

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssuredMockMvc.webAppContextSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.context);
	}
}</pre><p>如果您使用<code class="literal">EXPLICIT</code>模式，您可以使用基类类似地初始化整个测试应用程序，就像在常规集成测试中可能会发现的那样。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.RestAssured;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.runner.RunWith;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.boot.web.server.LocalServerPort
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.web.context.WebApplicationContext;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, classes = SomeConfig.class, properties="some=property")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BaseTestClass {

	<em><span class="hl-annotation" style="color: gray">@LocalServerPort</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> port;

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssured.baseURI = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:"</span> + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.port;
	}
}</pre><p>如果您使用<code class="literal">JAXRSCLIENT</code>模式，此基类还应包含一个<code class="literal">protected WebTarget webTarget</code>领域。现在，测试JAX-RS API的唯一选择是启动Web服务器。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-different-base" href="#maven-different-base"></a> 90.13.9合同的不同基类</h3></div></div></div><p>如果合同之间的基类不同，则可以告诉Spring Cloud Contract插件应通过自动生成的测试扩展哪个类。您有两种选择：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">遵循惯例，提供<code class="literal">packageWithBaseClasses</code></li><li class="listitem">通过提供显式映射<code class="literal">baseClassMappings</code></li></ul></div><p><span class="strong"><strong>按照惯例</strong></span></p><p>约定是，例如，如果您根据（例如） <code class="literal">src/test/resources/contract/foo/bar/baz/</code>并设置<code class="literal">packageWithBaseClasses</code>财产<code class="literal">com.example.base</code> ，则Spring Cloud Contract Verifier假设存在一个<code class="literal">BarBazBase</code>下课<code class="literal">com.example.base</code>包。换句话说，系统将获取程序包的最后两个部分（如果存在），并使用<code class="literal">Base</code>后缀。此规则优先于<span class="strong"><strong>baseClassForTests</strong></span> 。这是一个如何在<code class="literal">contracts</code>关闭：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;packageWithBaseClasses&gt;</span>hello<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/packageWithBaseClasses&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p><span class="strong"><strong>通过映射</strong></span></p><p>您可以将合同包的正则表达式手动映射到匹配合同的基类的完全限定名称。您必须提供一个名为<code class="literal">baseClassMappings</code>包括<code class="literal">baseClassMapping</code>需要一个<code class="literal">contractPackageRegex</code>至<code class="literal">baseClassFQN</code>映射。考虑以下示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassForTests&gt;</span>com.example.FooBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassForTests&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMappings&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMapping&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractPackageRegex&gt;</span>.*com.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractPackageRegex&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassFQN&gt;</span>com.example.TestBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassFQN&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMapping&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMappings&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>假设您在以下两个地点有合同：* <code class="literal">src/test/resources/contract/com/</code> *<code class="literal">src/test/resources/contract/foo/</code></p><p>通过提供<code class="literal">baseClassForTests</code> ，如果映射不成功，我们会有一个退路。（您还可以提供<code class="literal">packageWithBaseClasses</code>作为备用。）这样，从<code class="literal">src/test/resources/contract/com/</code>合同扩展了<code class="literal">com.example.ComBase</code> ，而其余测试将扩展<code class="literal">com.example.FooBase</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-invoking-generated-tests" href="#maven-invoking-generated-tests"></a> 90.13.10调用生成的测试</h3></div></div></div><p>Spring Cloud Contract Maven插件在名为的目录中生成验证代码<code class="literal">/generated-test-sources/contractVerifier</code>并将此目录附加到<code class="literal">testCompile</code>目标。</p><p>对于Groovy Spock代码，请使用以下代码：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.codehaus.gmavenplus<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>gmavenplus-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>1.5<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>testCompile<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;testSources&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;testSource&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>${project.basedir}/src/test/groovy<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**/*.groovy<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/testSource&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;testSource&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>${project.build.directory}/generated-test-sources/contractVerifier<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**/*.groovy<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/testSource&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/testSources&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>为了确保提供方符合已定义的合同，您需要调用<code class="literal">mvn generateTest test</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-pushing-stubs-to-scm" href="#maven-pushing-stubs-to-scm"></a> 90.13.11将存根推送到SCM</h3></div></div></div><p>如果您使用SCM存储库保留合同和存根，则可能要自动化将存根推送到存储库的步骤。为此，只需添加<code class="literal">pushStubsToScm</code>目标。例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Base class mappings etc. --&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We want to pick contracts from a Git repository --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsRepositoryUrl&gt;</span>git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsRepositoryUrl&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractDependency&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>${project.groupId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>${project.artifactId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${project.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractDependency&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- The contracts mode can't be classpath --&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractsMode&gt;</span>REMOTE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractsMode&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;phase&gt;</span>package<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/phase&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal --&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>pushStubsToScm<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p>在<a class="xref" href="#scm-stub-downloader" title="96.6使用SCM存根下载器">第96.6节“使用SCM存根下载器”下，</a>您可以找到可以通过以下方式传递的所有可能的配置选项： <code class="literal"><configuration><contractProperties></code>映射，系统属性或环境变量。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="maven-sts" href="#maven-sts"></a> 90.13.12 Maven插件和STS</h3></div></div></div><p>如果在使用STS时看到以下异常：</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-contract/2.1.x/docs/src/main/asciidoc/images/sts_exception.png" alt="STS异常"></div></div><p>当您单击错误标记时，您应该看到类似以下内容：</p><pre class="programlisting"> plugin:<span class="hl-number">1.1</span>.<span class="hl-number">0.</span>M1:convert:default-convert:process-<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>-resources) org.apache.maven.plugin.PluginExecutionException: Execution default-convert of goal org.springframework.cloud:spring-
 cloud-contract-maven-plugin:<span class="hl-number">1.1</span>.<span class="hl-number">0.</span>M1:convert failed. at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:<span class="hl-number">145</span>) at
 org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:<span class="hl-number">331</span>) at org.eclipse.m2e.core.internal.embedder.MavenImpl$<span class="hl-number">11.</span>call(MavenImpl.java:<span class="hl-number">1362</span>) at
...
 org.eclipse.core.internal.jobs.Worker.run(Worker.java:<span class="hl-number">55</span>) Caused by: java.lang.NullPointerException at
 org.eclipse.m2e.core.internal.builder.plexusbuildapi.EclipseIncrementalBuildContext.hasDelta(EclipseIncrementalBuildContext.java:<span class="hl-number">53</span>) at
 org.sonatype.plexus.build.incremental.ThreadBuildContext.hasDelta(ThreadBuildContext.java:<span class="hl-number">59</span>) at</pre><p>为了解决此问题，请在您的<code class="literal">pom.xml</code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;build&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginManagement&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugins&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--This plugin's configuration is used to store Eclipse m2e settings
                only. It has no influence on the Maven build itself. --&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.eclipse.m2e<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>lifecycle-mapping<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>1.0.0<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;lifecycleMappingMetadata&gt;</span>
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginExecutions&gt;</span>
                             <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginExecution&gt;</span>
                                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginExecutionFilter&gt;</span>
                                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
                                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
                                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;versionRange&gt;</span>[1.0,)<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/versionRange&gt;</span>
                                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
                                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>convert<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
                                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
                                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginExecutionFilter&gt;</span>
                                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;action&gt;</span>
                                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execute /&gt;</span>
                                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/action&gt;</span>
                             <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginExecution&gt;</span>
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginExecutions&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/lifecycleMappingMetadata&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugins&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginManagement&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/build&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_maven_plugin_with_spock_tests" href="#_maven_plugin_with_spock_tests"></a> 90.13.13具有Spock测试的Maven插件</h3></div></div></div><p>您可以选择<a class="link" href="http://spockframework.org/" target="_top">Spock框架</a>来使用Maven和Gradle插件创建和执行自动生成的合同验证测试。但是，尽管使用Gradle非常简单，但是在Maven中，您将需要一些其他设置才能使测试正确编译和执行。</p><p>首先，您将必须使用诸如<a class="link" href="https://github.com/groovy/GMavenPlus" target="_top">GMavenPlus</a>插件之类的插件将Groovy添加到您的项目中。在GMavenPlus插件中，您将需要显式设置测试源，包括定义基本测试类的路径和添加了生成的合同测试的路径。请参考以下示例：</p><pre class="programlisting"></pre><p>如果您坚持以以下形式结束测试类名称的Spock约定： <code class="literal">Spec</code> ，您还需要调整Maven Surefire插件设置，如以下示例所示：</p><pre class="programlisting"></pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stubs_and_transitive_dependencies" href="#_stubs_and_transitive_dependencies"></a> 90.14存根和传递依赖项</h2></div></div></div><p>Maven和Gradle插件添加了为您创建存根jar的任务。出现的一个问题是，当重用存根时，您可能会错误地导入该存根的所有依赖项。构建Maven工件时，即使您有几个不同的jar，它们都共享一个pom：</p><pre class="programlisting">&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-<span class="hl-number">20160903.075506</span>-<span class="hl-number">1</span>-stubs.jar
&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-<span class="hl-number">20160903.075506</span>-<span class="hl-number">1</span>-stubs.jar.sha1
&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-<span class="hl-number">20160903.075655</span>-<span class="hl-number">2</span>-stubs.jar
&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-<span class="hl-number">20160903.075655</span>-<span class="hl-number">2</span>-stubs.jar.sha1
&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-SNAPSHOT.jar
&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-SNAPSHOT.pom
&#9500;&#9472;&#9472; github-webhook-<span class="hl-number">0.0</span>.<span class="hl-number">1.</span>BUILD-SNAPSHOT-stubs.jar
&#9500;&#9472;&#9472; ...
&#9492;&#9472;&#9472; ...</pre><p>使用这些依赖项有三种可能性，以使传递依赖项没有任何问题：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">将所有应用程序依赖项标记为可选</li><li class="listitem">为存根创建一个单独的artifactid</li><li class="listitem">排除消费者方面的依赖</li></ul></div><p><span class="strong"><strong>将所有应用程序依赖项标记为可选</strong></span></p><p>如果，在<code class="literal">github-webhook</code>应用程序，当您包含<code class="literal">github-webhook</code>然后，由于所有依赖项都是可选的，因此不会下载另一个应用程序中的存根（或当Stub Runner下载该依赖项时）。</p><p><span class="strong"><strong>创建一个单独的<code class="literal">artifactid</code>存根</strong></span></p><p>如果您创建一个单独的<code class="literal">artifactid</code> ，那么您可以按照自己的方式进行设置。例如，您可能决定完全没有依赖项。</p><p><span class="strong"><strong>排除消费者方面的依赖</strong></span></p><p>作为使用者，如果将存根依赖项添加到类路径中，则可以显式排除不需要的依赖项。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_scenarios" href="#_scenarios"></a> 90.15场景</h2></div></div></div><p>您可以使用Spring Cloud Contract Verifier处理方案。您需要做的就是在创建合同时遵循正确的命名约定。约定要求在订货号后加上下划线。无论您使用的是YAML还是Groovy，这都将起作用。例：</p><pre class="screen">my_contracts_dir\
  scenario1\
    1_login.groovy
    2_showCart.groovy
    3_logout.groovy</pre><p>这样的树使Spring Cloud Contract Verifier生成名称为的WireMock场景<code class="literal">scenario1</code>以及以下三个步骤：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">登录标记为<code class="literal">Started</code>指向...</li><li class="listitem">showCart标记为<code class="literal">Step1</code>指向...</li><li class="listitem">注销标记为<code class="literal">Step2</code>这将关闭方案。</li></ol></div><p>有关WireMock方案的更多详细信息， <a class="link" href="https://wiremock.org/docs/stateful-behaviour/" target="_top">请</a>参见<a class="link" href="https://wiremock.org/docs/stateful-behaviour/" target="_top">https://wiremock.org/docs/stateful-behaviour/</a></p><p>Spring Cloud Contract Verifier还会生成具有保证执行顺序的测试。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="docker-project" href="#docker-project"></a> 90.16 Docker项目</h2></div></div></div><p>我们正在发布<code class="literal">springcloud/spring-cloud-contract</code>包含用于生成测试并在其中执行测试的项目的Docker映像<code class="literal">EXPLICIT</code>模式针对正在运行的应用程序。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">EXPLICIT</code>模式意味着从合同生成的测试将发送真实的请求，而不是模拟的请求。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_short_intro_to_maven_jars_and_binary_storage" href="#_short_intro_to_maven_jars_and_binary_storage"></a> 90.16.1 Maven，JAR和二进制存储的简短介绍</h3></div></div></div><p>由于Docker映像可由非JVM项目使用，因此最好解释一下Spring Cloud Contract打包默认设置背后的基本术语。</p><p>以下定义的一部分来自<a class="link" href="https://maven.apache.org/glossary.html" target="_top">Maven词汇表</a></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">Project</code> ：Maven考虑项目。您将构建的所有内容都是项目。这些项目遵循定义明确的“项目对象模型”。项目可以依赖于其他项目，在这种情况下，后者称为“依赖项”。一个项目可能与几个子项目一致，但是这些子项目仍被视为项目。</li><li class="listitem"><code class="literal">Artifact</code> ：工件是项目产生或使用的东西。Maven为项目生成的工件示例包括：JAR，源代码和二进制发行版。每个工件都由组ID和组内唯一的工件ID唯一标识。</li><li class="listitem"><code class="literal">JAR</code> ：JAR表示Java ARchive。这是一种基于ZIP文件格式的格式。Spring Cloud Contract将合同和生成的存根打包在JAR文件中。</li><li class="listitem"><code class="literal">GroupId</code> ：组ID是项目的通用唯一标识符。尽管这通常只是项目名称（例如commons-collections），但使用完全限定的软件包名称将其与具有类似名称的其他项目（例如org.apache.maven）区分开来会很有帮助。通常，当发布到工件管理器时， <code class="literal">GroupId</code>将以斜杠分隔并构成URL的一部分。例如组ID <code class="literal">com.example</code>和工件ID <code class="literal">application</code>将会<code class="literal">/com/example/application/</code> 。</li><li class="listitem"><code class="literal">Classifier</code> ：Maven依赖项表示法如下所示： <code class="literal">groupId:artifactId:version:classifier</code> 。分类器是传递给依赖项的附加后缀。例如<code class="literal">stubs</code> ， <code class="literal">sources</code> 。相同的依赖关系，例如<code class="literal">com.example:application</code>可以使用分类器产生多个彼此不同的工件。</li><li class="listitem"><code class="literal">Artifact manager</code> ：当您生成二进制文件/源代码/软件包时，您希望它们可供其他人下载/引用或重用。在JVM的情况下，这些工件将是JAR，对于Ruby而言，它们是宝石，对于Docker，则是Docker映像。您可以将这些工件存储在管理器中。此类管理器的示例可以是<a class="link" href="https://jfrog.com/artifactory/" target="_top">Artifactory</a>或<a class="link" href="https://www.sonatype.org/nexus/" target="_top">Nexus</a> 。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_it_works_2" href="#_how_it_works_2"></a> 90.16.2工作原理</h3></div></div></div><p>该图像在<code class="literal">/contracts</code>夹。运行测试的输出将在以下位置提供<code class="literal">/spring-cloud-contract/build</code>文件夹（对于调试目的很有用）。</p><p>您安装合同，传递环境变量就足够了，该映像将：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">生成合同测试</li><li class="listitem">针对提供的URL执行测试</li><li class="listitem">生成<a class="link" href="https://github.com/tomakehurst/wiremock" target="_top">WireMock</a>存根</li><li class="listitem">（可选-默认情况下处于启用状态）将存根发布到Artifact Manager</li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_environment_variables" href="#_environment_variables"></a>环境变量</h4></div></div></div><p>Docker映像需要一些环境变量以指向您正在运行的应用程序，工件管理器实例等。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">PROJECT_GROUP</code> -您的项目的组ID。默认为<code class="literal">com.example</code></li><li class="listitem"><code class="literal">PROJECT_VERSION</code> -您项目的版本。默认为<code class="literal">0.0.1-SNAPSHOT</code></li><li class="listitem"><code class="literal">PROJECT_NAME</code> -工件ID。默认为<code class="literal">example</code></li><li class="listitem"><code class="literal">REPO_WITH_BINARIES_URL</code> -Artifact Manager的网址。默认为<code class="literal"><a class="link" href="http://localhost:8081/artifactory/libs-release-local" target="_top">http://localhost:8081/artifactory/libs-release-local</a></code>这是本地运行的<a class="link" href="https://jfrog.com/artifactory/" target="_top">Artifactory</a>的默认URL</li><li class="listitem"><code class="literal">REPO_WITH_BINARIES_USERNAME</code> -（在Artifact Manager被保护的情况下）（可选）用户名</li><li class="listitem"><code class="literal">REPO_WITH_BINARIES_PASSWORD</code> -（固定的）Artifact Manager安全的密码</li><li class="listitem"><code class="literal">PUBLISH_ARTIFACTS</code> -如果设置为<code class="literal">true</code>然后将工件发布到二进制存储。默认为<code class="literal">true</code> 。</li></ul></div><p>当合同位于外部存储库中时，将使用这些环境变量。要启用此功能，您必须设置<code class="literal">EXTERNAL_CONTRACTS_ARTIFACT_ID</code>环境变量。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_GROUP_ID</code> -带有合同的项目的组ID。默认为<code class="literal">com.example</code></li><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_ARTIFACT_ID</code> -带有合同的项目的工件ID。</li><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_CLASSIFIER</code> -带有合同的项目分类。默认为空</li><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_VERSION</code> -带有合同的项目版本。默认为<code class="literal">+</code> ，相当于选择最新的</li><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_URL</code> -Artifact Manager的网址。默认值为<code class="literal">REPO_WITH_BINARIES_URL</code>环境变量如果未设置，则默认为<code class="literal"><a class="link" href="http://localhost:8081/artifactory/libs-release-local" target="_top">http://localhost:8081/artifactory/libs-release-local</a></code>这是本地运行的<a class="link" href="https://jfrog.com/artifactory/" target="_top">Artifactory</a>的默认URL</li><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_PATH</code> -给定项目的合同路径，包含合同的项目内部。默认为斜杠分隔<code class="literal">EXTERNAL_CONTRACTS_GROUP_ID</code>与<code class="literal">/</code>和<code class="literal">EXTERNAL_CONTRACTS_ARTIFACT_ID</code> 。例如组ID <code class="literal">foo.bar</code>和工件ID <code class="literal">baz</code> ，会导致<code class="literal">foo/bar/baz</code>合约路径。</li><li class="listitem"><code class="literal">EXTERNAL_CONTRACTS_WORK_OFFLINE</code> -如果设置为<code class="literal">true</code>然后将从容器的<code class="literal">.m2</code> 。挂载您的本地<code class="literal">.m2</code>作为容器的可用体积<code class="literal">/root/.m2</code>路径。您不能同时设置<code class="literal">EXTERNAL_CONTRACTS_WORK_OFFLINE</code>和<code class="literal">EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_URL</code> 。</li></ul></div><p>执行测试时使用以下环境变量：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">APPLICATION_BASE_URL</code> -应针对其执行测试的网址。请记住，它必须可以从Docker容器访问（例如<code class="literal">localhost</code>不管用）</li><li class="listitem"><code class="literal">APPLICATION_USERNAME</code> -（可选）用于对应用程序进行基本身份验证的用户名</li><li class="listitem"><code class="literal">APPLICATION_PASSWORD</code> -（可选）用于对应用程序进行基本身份验证的密码</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_example_of_usage" href="#_example_of_usage"></a> 90.16.3使用示例</h3></div></div></div><p>让我们看一个简单的MVC应用程序</p><pre class="programlisting">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> bookstore</pre><p>合同可在<code class="literal">/contracts</code>夹。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="docker-server-side" href="#docker-server-side"></a> 90.16.4服务器端（nodejs）</h3></div></div></div><p>因为我们要运行测试，所以我们可以执行：</p><pre class="programlisting">$ npm <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span></pre><p>但是，出于学习目的，让我们将其分为几部分：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Stop docker infra (nodejs, artifactory)</span>
$ ./stop_infra.sh
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Start docker infra (nodejs, artifactory)</span>
$ ./setup_infra.sh

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Kill &amp; Run app</span>
$ pkill -f <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"node app"</span>
$ nohup node app &amp;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Prepare environment variables</span>
$ SC_CONTRACT_DOCKER_VERSION=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"..."</span>
$ APP_IP=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"192.168.0.100"</span>
$ APP_PORT=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"3000"</span>
$ ARTIFACTORY_PORT=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"8081"</span>
$ APPLICATION_BASE_URL=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://${APP_IP}:${APP_PORT}"</span>
$ ARTIFACTORY_URL=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://${APP_IP}:${ARTIFACTORY_PORT}/artifactory/libs-release-local"</span>
$ CURRENT_DIR=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$( pwd )"</span>
$ CURRENT_FOLDER_NAME=${PWD<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">##*/}</span>
$ PROJECT_VERSION=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"0.0.1.RELEASE"</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Execute contract tests</span>
$ docker run  --rm -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"APPLICATION_BASE_URL=${APPLICATION_BASE_URL}"</span> -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"PUBLISH_ARTIFACTS=true"</span> -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"PROJECT_NAME=${CURRENT_FOLDER_NAME}"</span> -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"REPO_WITH_BINARIES_URL=${ARTIFACTORY_URL}"</span> -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"PROJECT_VERSION=${PROJECT_VERSION}"</span> -v <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${CURRENT_DIR}/contracts/:/contracts:ro"</span> -v <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${CURRENT_DIR}/node_modules/spring-cloud-contract/output:/spring-cloud-contract-output/"</span> springcloud/spring-cloud-contract:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${SC_CONTRACT_DOCKER_VERSION}"</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Kill app</span>
$ pkill -f <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"node app"</span></pre><p>将会发生的是通过bash脚本：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">基础设施将被建立（MongoDb，Artifactory）。在现实生活中，您只需运行带有模拟数据库的NodeJS应用程序。在此示例中，我们想展示如何立即受益于Spring Cloud Contract。</li><li class="listitem"><p class="simpara">由于这些限制，合同也代表了有状态的情况</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">第一个请求是<code class="literal">POST</code>导致将数据插入数据库</li><li class="listitem">第二个请求是<code class="literal">GET</code>返回具有1个先前插入的元素的数据列表</li></ul></div></li><li class="listitem">NodeJS应用程序将启动（在端口上<code class="literal">3000</code> ）</li><li class="listitem"><p class="simpara">合同测试将通过Docker生成，并且测试将针对正在运行的应用程序执行</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">合同将从<code class="literal">/contracts</code>夹。</li><li class="listitem">测试执行的输出在下<code class="literal">node_modules/spring-cloud-contract/output</code> 。</li></ul></div></li><li class="listitem">存根将被上传到Artifactory。您可以在<a class="link" href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/" target="_top">http：// localhost：8081 / artifactory / libs-release-local / com / example / bookstore / 0.0.1.RELEASE /中检出它们</a> 。存根将在此处<a class="link" href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/bookstore-0.0.1.RELEASE-stubs.jar" target="_top">http：// localhost：8081 / artifactory / libs-release-local / com / example / bookstore / 0.0.1.RELEASE / bookstore-0.0.1.RELEASE-stubs.jar</a> 。</li></ul></div><p>要查看客户端的外观，请查看<a class="xref" href="#stubrunner-docker" title="92.9 Stub Runner Docker">第92.9节“ Stub Runner Docker”</a>部分。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_verifier_messaging" href="#_spring_cloud_contract_verifier_messaging"></a> 91。Spring Cloud Contract Verifier消息传递</h2></div></div></div><p>Spring Cloud Contract Verifier使您可以验证使用消息传递作为通信手段的应用程序。本文档中显示的所有集成都可以与Spring一起使用，但是您也可以创建自己的一个并使用它。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_integrations_2" href="#_integrations_2"></a> 91.1集成</h2></div></div></div><p>您可以使用以下四种集成配置之一：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">阿帕奇骆驼</li><li class="listitem"> Spring Integration </li><li class="listitem"> Spring Cloud Stream </li><li class="listitem"> Spring AMQP </li></ul></div><p>由于我们使用Spring Boot，因此，如果您已将这些库之一添加到类路径中，则会自动设置所有消息传递配置。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>记得放<code class="literal">@AutoConfigureMessageVerifier</code>在您生成的测试的基类上。否则，Spring Cloud Contract Verifier的消息传递部分将不起作用。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果要使用Spring Cloud Stream，请记住添加对<code class="literal">org.springframework.cloud:spring-cloud-stream-test-support</code> ，如下所示：</p></td></tr></tbody></table></div><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-test-support<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-stream-test-support"</span></pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_manual_integration_testing" href="#_manual_integration_testing"></a> 91.2手动集成测试</h2></div></div></div><p>测试使用的主要界面是<code class="literal">org.springframework.cloud.contract.verifier.messaging.MessageVerifier</code> 。它定义了如何发送和接收消息。您可以创建自己的实现以实现相同的目标。</p><p>在测试中，您可以注入一个<code class="literal">ContractVerifierMessageExchange</code>发送和接收遵循合同的消息。然后加<code class="literal">@AutoConfigureMessageVerifier</code>测试。这是一个例子：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringTestRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureMessageVerifier</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MessagingContractTests {

  <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MessageVerifier verifier;
  ...
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您的测试也需要存根，则<code class="literal">@AutoConfigureStubRunner</code>包括消息传递配置，因此您只需要一个注释。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_publisher_side_test_generation" href="#_publisher_side_test_generation"></a> 91.3发布者方测试生成</h2></div></div></div><p>有<code class="literal">input</code>要么<code class="literal">outputMessage</code> DSL中的小节会在发布商方面创建测试。默认情况下，将创建JUnit 4测试。但是，也可以创建JUnit 5或Spock测试。</p><p>我们应该考虑3种主要情况：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">方案1：没有输入消息会生成输出消息。输出消息由应用程序内部的组件（例如，调度程序）触发。</li><li class="listitem">方案2：输入消息触发输出消息。</li><li class="listitem">方案3：输入消息已被使用，没有输出消息。</li></ul></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>目的地已传递至<code class="literal">messageFrom</code>要么<code class="literal">sentTo</code>对于不同的消息传递实现，可以具有不同的含义。对于<span class="strong"><strong>流</strong></span>和<span class="strong"><strong>集成</strong></span> ，首先<span class="strong"><strong>将</strong></span>其解析为<code class="literal">destination</code>频道那如果没有<code class="literal">destination</code>它被解析为频道名称。对于<span class="strong"><strong>Camel来说</strong></span> ，这是一定的组成部分（例如， <code class="literal">jms</code> ）。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_scenario_1_no_input_message" href="#_scenario_1_no_input_message"></a> 91.3.1方案1：无输入消息</h3></div></div></div><p>对于给定的合同：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">			def contractDsl = Contract.make {
				label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
				input {
					triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookReturnedTriggered()'</span>)
				}
				outputMessage {
					sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'activemq:output'</span>)
					body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "bookName" : "foo" }'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
					headers {
						header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
						messagingContentType(applicationJson())
					}
				}
			}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">label: some_label
input:
  triggeredBy: bookReturnedTriggered
outputMessage:
  sentTo: activemq:output
  body:
    bookName: foo
  headers:
    BOOK-NAME: foo
    contentType: application/json</pre><p>
</p><p>创建了以下JUnit测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
  bookReturnedTriggered();

 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
  ContractVerifierMessage response = contractVerifierMessaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"activemq:output"</span>);
  assertThat(response).isNotNull();
  assertThat(response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"BOOK-NAME"</span>)).isNotNull();
  assertThat(response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"BOOK-NAME"</span>).toString()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
  assertThat(response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"contentType"</span>)).isNotNull();
  assertThat(response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"contentType"</span>).toString()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>);
 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
  assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bookName"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre><p>然后将创建以下Spock测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span> when:
  bookReturnedTriggered()

 then:
  ContractVerifierMessage response = contractVerifierMessaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'activemq:output'</span>)
  assert response != null
  response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>)?.toString()  == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
  response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'contentType'</span>)?.toString()  == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>
 and:
  DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
  assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bookName"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>)

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_scenario_2_output_triggered_by_input" href="#_scenario_2_output_triggered_by_input"></a> 91.3.2场景2：由输入触发的输出</h3></div></div></div><p>对于给定的合同：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">			def contractDsl = Contract.make {
				label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
				input {
					messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:input'</span>)
					messageBody([
							bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
					])
					messageHeaders {
						header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
					}
				}
				outputMessage {
					sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>)
					body([
							bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
					])
					headers {
						header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
					}
				}
			}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">label: some_label
input:
  messageFrom: jms:input
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
outputMessage:
  sentTo: jms:output
  body:
    bookName: foo
  headers:
    BOOK-NAME: foo</pre><p>
</p><p>创建了以下JUnit测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\\"</span>bookName\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span>foo\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"}"</span>
, headers()
  .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"sample"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"header"</span>));

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
 contractVerifierMessaging.send(inputMessage, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"jms:input"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
 ContractVerifierMessage response = contractVerifierMessaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"jms:output"</span>);
 assertThat(response).isNotNull();
 assertThat(response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"BOOK-NAME"</span>)).isNotNull();
 assertThat(response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"BOOK-NAME"</span>).toString()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
 DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bookName"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre><p>然后将创建以下Spock测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\
</span>given:
   ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{"bookName":"foo"}'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>,
    [<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>]
  )

when:
   contractVerifierMessaging.send(inputMessage, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:input'</span>)

then:
   ContractVerifierMessage response = contractVerifierMessaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>)
   assert response !- null
   response.getHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>)?.toString()  == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
and:
   DocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.payload))
   assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bookName"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_scenario_3_no_output_message" href="#_scenario_3_no_output_message"></a> 91.3.3方案3：无输出消息</h3></div></div></div><p>对于给定的合同：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">			def contractDsl = Contract.make {
				label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
				input {
					messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:delete'</span>)
					messageBody([
							bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
					])
					messageHeaders {
						header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
					}
					assertThat(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookWasDeleted()'</span>)
				}
			}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">label: some_label
input:
  messageFrom: jms:delete
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
  assertThat: bookWasDeleted()</pre><p>
</p><p>创建了以下JUnit测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\\"</span>bookName\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span>foo\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"}"</span>
, headers()
	.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"sample"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"header"</span>));

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
 contractVerifierMessaging.send(inputMessage, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"jms:delete"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
 bookWasDeleted();
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre><p>然后将创建以下Spock测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span>given:
	 ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
		\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'\'\'{"bookName":"foo"}\'\'\',
</span>		[<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>]
	)

when:
	 contractVerifierMessaging.send(inputMessage, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:delete'</span>)

then:
	 noExceptionThrown()
	 bookWasDeleted()
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_consumer_stub_generation" href="#_consumer_stub_generation"></a> 91.4消费者存根生成</h2></div></div></div><p>与HTTP部分不同，在消息传递中，我们需要使用存根在JAR内发布Groovy DSL。然后在用户端对其进行解析，并创建正确的存根路由。</p><p>有关更多信息，请参见<a class="xref" href="#stub-runner-for-messaging" title="93。消息传送存根">第93章， <i>消息传递的存根运行器</i></a>部分。</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-stream-rabbit<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-stub-runner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-test-support<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>Greenwich.BUILD-SNAPSHOT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">ext {
	contractsDir = file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"mappings"</span>)
	stubsOutputDirRoot = file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/production/${project.name}-stubs/"</span>)
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Automatically added by plugin:</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// copyContracts - copies contracts to the output folder from which JAR will be created</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// verifierStubsJar - JAR with a provided stub suffix</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the presented publication is also added by the plugin but you can modify it as you wish</span>

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.name}-stubs"</span>
			artifact verifierStubsJar
		}
	}
}</pre><p class="secondary">
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_stub_runner" href="#_spring_cloud_contract_stub_runner"></a> 92。Spring Cloud Contract存根转轮</h2></div></div></div><p>使用Spring Cloud Contract Verifier时可能遇到的问题之一是将生成的WireMock JSON存根从服务器端传递到客户端（或传递到各种客户端）。在客户端生成消息方面也发生了同样的事情。</p><p>复制JSON文件并设置客户端手动进行消息传递是不可能的。这就是为什么我们引入了Spring Cloud Contract Stub Runner。它可以自动为您下载并运行存根。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_snapshot_versions" href="#_snapshot_versions"></a> 92.1快照版本</h2></div></div></div><p>将其他快照存储库添加到您的<code class="literal">build.gradle</code>文件以使用快照版本，快照版本在每次成功构建后都会自动上传：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;repository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repository&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/repositories&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepositories&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Snapshots<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/snapshot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Milestones<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/milestone<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pluginRepository&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>spring-releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;name&gt;</span>Spring Releases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/name&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;url&gt;</span>https://repo.spring.io/release<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/url&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;snapshots&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;enabled&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/enabled&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/snapshots&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepository&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pluginRepositories&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 We need to use the [buildscript {}] section when we have to modify
 the classpath for the plugins. If that's not the case this section
 can be skipped.

 If you don't need to modify the classpath (e.g. add a Pact dependency),
 then you can just set the [pluginManagement {}] section in [settings.gradle] file.

 // settings.gradle
 pluginManagement {
    repositories {
        // for snapshots
        maven {url "https://repo.spring.io/snapshot"}
        // for milestones
        maven {url "https://repo.spring.io/milestone"}
        // for GA versions
        gradlePluginPortal()
    }
 }

 */</span>
buildscript {
	repositories {
		mavenCentral()
		mavenLocal()
		maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/snapshot"</span> }
		maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/milestone"</span> }
		maven { url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://repo.spring.io/release"</span> }
	}</pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="publishing-stubs-as-jars" href="#publishing-stubs-as-jars"></a> 92.2将存根发布为JAR</h2></div></div></div><p>最简单的方法是集中存根的保存方式。例如，您可以将它们作为jar保存在Maven存储库中。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>对于Maven和Gradle，该设置即可使用。但是，您可以根据需要自定义它。</p></td></tr></tbody></table></div><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- First disable the default jar setup in the properties section --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- we don't want the verifier to do a jar for us --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;spring.cloud.contract.verifier.skip&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/spring.cloud.contract.verifier.skip&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Next add the assembly plugin to your build --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- we want the assembly plugin to generate the JAR --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>maven-assembly-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>stub<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;phase&gt;</span>prepare-package<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/phase&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>single<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;inherited&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/inherited&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;attach&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/attach&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;descriptors&gt;</span>
					$../../../../src/assembly/stub.xml
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/descriptors&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- Finally setup your assembly. Below you can find the contents of src/main/assembly/stub.xml --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;assembly</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:xsi</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xsi:schemaLocation</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>stubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;formats&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;format&gt;</span>jar<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/format&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/formats&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includeBaseDirectory&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includeBaseDirectory&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSets&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>src/main/java<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**com/example/model/*.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>${project.build.directory}/classes<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**com/example/model/*.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>${project.build.directory}/snippets/stubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>META-INF/${project.groupId}/${project.artifactId}/${project.version}/mappings<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**/*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>$../../../../src/test/resources/contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>META-INF/${project.groupId}/${project.artifactId}/${project.version}/contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**/*.groovy<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSets&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/assembly&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">ext {
	contractsDir = file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"mappings"</span>)
	stubsOutputDirRoot = file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/production/${project.name}-stubs/"</span>)
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Automatically added by plugin:</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// copyContracts - copies contracts to the output folder from which JAR will be created</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// verifierStubsJar - JAR with a provided stub suffix</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the presented publication is also added by the plugin but you can modify it as you wish</span>

publishing {
	publications {
		stubs(MavenPublication) {
			artifactId <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.name}-stubs"</span>
			artifact verifierStubsJar
		}
	}
}</pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_core" href="#_stub_runner_core"></a> 92.3 Stub Runner核心</h2></div></div></div><p>为服务合作者运行存根。将存根视为服务合同允许将存根运行器用作<a class="link" href="https://martinfowler.com/articles/consumerDrivenContracts.html" target="_top">消费者驱动合同</a>的实现。</p><p>Stub Runner允许您自动下载提供的依赖项的存根（或从类路径中选择存根），为其启动WireMock服务器，并使用正确的存根定义来提供它们。对于消息传递，定义了特殊的存根路由。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_retrieving_stubs" href="#_retrieving_stubs"></a> 92.3.1检索存根</h3></div></div></div><p>您可以选择以下获取存根的选项</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">基于醚的解决方案，可从Artifactory / Nexus下载带有存根的JAR</li><li class="listitem">类路径扫描解决方案，可通过模式搜索类路径以检索存根</li><li class="listitem">编写自己的实现<code class="literal">org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder</code>完全定制</li></ul></div><p>后一个示例在“ <a class="link" href="#">自定义存根运行器”</a>部分中进行了描述。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stub_downloading" href="#_stub_downloading"></a>存根下载</h4></div></div></div><p>您可以通过来控制存根下载<code class="literal">stubsMode</code>开关。它从<code class="literal">StubRunnerProperties.StubsMode</code>枚举。您可以使用以下选项</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">StubRunnerProperties.StubsMode.CLASSPATH</code> （默认值）-将从类路径中选择存根</li><li class="listitem"><code class="literal">StubRunnerProperties.StubsMode.LOCAL</code> -从本地存储区中选择存根（例如<code class="literal">.m2</code> ）</li><li class="listitem"><code class="literal">StubRunnerProperties.StubsMode.REMOTE</code> -将从远程位置选择存根</li></ul></div><p>例：</p><pre class="programlisting">@AutoConfigureStubRunner(repositoryRoot=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://foo.bar"</span>, ids = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:beer-api-producer:+:stubs:8095"</span>, stubsMode = StubRunnerProperties.StubsMode.LOCAL)</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_classpath_scanning" href="#_classpath_scanning"></a>类路径扫描</h4></div></div></div><p>如果您设定<code class="literal">stubsMode</code>财产<code class="literal">StubRunnerProperties.StubsMode.CLASSPATH</code> （或自<code class="literal">CLASSPATH</code>是默认值），则将扫描classpath。让我们看下面的例子：</p><pre class="programlisting">@AutoConfigureStubRunner(ids = {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:beer-api-producer:+:stubs:8095"</span>,
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example.foo:bar:1.0.0:superstubs:8096"</span>
})</pre><p>如果您已将依赖项添加到类路径中</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>beer-api-producer-restdocs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;classifier&gt;</span>stubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/classifier&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>0.0.1-SNAPSHOT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusion&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusion&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example.foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>bar<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;classifier&gt;</span>superstubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/classifier&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>1.0.0<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;exclusion&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusion&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/exclusions&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">testCompile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:beer-api-producer-restdocs:0.0.1-SNAPSHOT:stubs"</span>) {
    transitive = false
}
testCompile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example.foo:bar:1.0.0:superstubs"</span>) {
    transitive = false
}</pre><p class="secondary">
</p><p>然后，将扫描您的类路径上的以下位置。对于<code class="literal">com.example:beer-api-producer-restdocs</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">/META-INF/com.example/beer-api-producer-restdocs/ <span class="strong"><strong>* /</strong></span> 。*</li><li class="listitem">/contracts/com.example/beer-api-producer-restdocs/ <span class="strong"><strong>* /</strong></span> 。*</li><li class="listitem">/mappings/com.example/beer-api-producer-restdocs/ <span class="strong"><strong>* /</strong></span> 。*</li></ul></div><p>和<code class="literal">com.example.foo:bar</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">/META-INF/com.example.foo/bar/ <span class="strong"><strong>* /</strong></span> 。*</li><li class="listitem">/contracts/com.example.foo/bar/ <span class="strong"><strong>* /</strong></span> 。*</li><li class="listitem">/mappings/com.example.foo/bar/ <span class="strong"><strong>* /</strong></span> 。*</li></ul></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如您所见，打包生产者存根时必须显式提供组和工件ID。</p></td></tr></tbody></table></div><p>生产者将像这样设置合同：</p><pre class="programlisting">&#9492;&#9472;&#9472; src
    &#9492;&#9472;&#9472; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>
        &#9492;&#9472;&#9472; resources
            &#9492;&#9472;&#9472; contracts
             &nbsp;&nbsp; &#9492;&#9472;&#9472; com.example
             &nbsp;&nbsp;  &nbsp;&nbsp; &#9492;&#9472;&#9472; beer-api-producer-restdocs
             &nbsp;&nbsp;  &nbsp;&nbsp;     &#9492;&#9472;&#9472; nested
             &nbsp;&nbsp;  &nbsp;&nbsp;         &#9492;&#9472;&#9472; contract3.groovy</pre><p>要实现正确的存根包装。</p><p>或使用<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/2.1.x/producer_with_restdocs/pom.xml" target="_top">Maven <code class="literal">assembly</code>插件</a>或<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/2.1.x/producer_with_restdocs/build.gradle" target="_top">Gradle Jar</a>任务，您必须在存根jar中创建以下结构。</p><pre class="programlisting">&#9492;&#9472;&#9472; META-INF
    &#9492;&#9472;&#9472; com.example
        &#9492;&#9472;&#9472; beer-api-producer-restdocs
            &#9492;&#9472;&#9472; <span class="hl-number">2.0</span>.<span class="hl-number">0</span>
                &#9500;&#9472;&#9472; contracts
                &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; nested
             &nbsp;&nbsp; &#9474;       &#9492;&#9472;&#9472; contract2.groovy
             &nbsp;&nbsp; &#9492;&#9472;&#9472; mappings
             &nbsp;&nbsp;     &#9492;&#9472;&#9472; mapping.json</pre><p>通过维护此结构，可以扫描类路径，而无需下载工件即可从消息传递/ HTTP存根中受益。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_configuring_http_server_stubs" href="#_configuring_http_server_stubs"></a>配置HTTP服务器存根</h4></div></div></div><p>存根赛跑者有一个概念<code class="literal">HttpServerStub</code>它抽象了HTTP服务器的底层具体实现（例如，WireMock是实现之一）。有时，您需要对存根服务器执行一些其他调整，这对于给定的实现是具体的。为此，Stub Runner为您提供了<code class="literal">httpServerStubConfigurer</code>注释，JUnit规则中可用的属性，可通过系统属性访问该属性，您可以在其中提供对<code class="literal">org.springframework.cloud.contract.stubrunner.HttpServerStubConfigurer</code>接口。这些实现可以更改给定HTTP服务器存根的配置文件。</p><p>Spring Cloud Contract Stub Runner附带了一个可以扩展的实现，用于WireMock- <code class="literal">org.springframework.cloud.contract.stubrunner.provider.wiremock.WireMockHttpServerStubConfigurer</code> 。在里面<code class="literal">configure</code>您可以为给定的存根提供自己的自定义配置方法。用例可能是在HTTPs端口上为给定的工件ID启动WireMock。例：</p><p><b>WireMockHttpServerStubConfigurer实现。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@CompileStatic</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HttpsForFraudDetection <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> WireMockHttpServerStubConfigurer {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Log log = LogFactory.getLog(HttpsForFraudDetection)

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	WireMockConfiguration configure(WireMockConfiguration httpStubConfiguration, HttpServerStubConfiguration httpServerStubConfiguration) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (httpServerStubConfiguration.stubConfiguration.artifactId == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> httpsPort = SocketUtils.findAvailableTcpPort()
			log.info(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Will set HTTPs port ["</span> + httpsPort + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"] for fraud detection server"</span>)
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> httpStubConfiguration
					.httpsPort(httpsPort)
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> httpStubConfiguration
	}
}</pre><p>
</p><p>然后，您可以通过注释重用它</p><pre class="programlisting">@AutoConfigureStubRunner(mappingsOutputFolder = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappings/"</span>,
		httpServerStubConfigurer = HttpsForFraudDetection)</pre><p>只要找到https端口，它将优先于http端口。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_running_stubs" href="#_running_stubs"></a> 92.3.2运行存根</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_running_using_main_app" href="#_running_using_main_app"></a>使用主应用程序运行</h4></div></div></div><p>您可以为主类设置以下选项：</p><pre class="programlisting">-c, --classifier                Suffix <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> the jar containing stubs (e.
                                  g. <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'stubs'</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> the stub jar would
                                  have a <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'stubs'</span> classifier <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> stubs:
                                  foobar-stubs ). Defaults to <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'stubs'</span>
                                  (<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">default</span>: stubs)
--maxPort, --maxp &lt;Integer&gt;     Maximum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  <span class="hl-number">15000</span> (<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">default</span>: <span class="hl-number">15000</span>)
--minPort, --minp &lt;Integer&gt;     Minimum port value to be assigned to
                                  the WireMock instance. Defaults to
                                  <span class="hl-number">10000</span> (<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">default</span>: <span class="hl-number">10000</span>)
-p, --password                  Password to user when connecting to
                                  repository
--phost, --proxyHost            Proxy host to use <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> repository
                                  requests
--pport, --proxyPort [Integer]  Proxy port to use <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> repository
                                  requests
-r, --root                      Location of a Jar containing server
                                  where you keep your stubs (e.g. http:
                                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//nexus.</span>
                                  net/content/repositories/repository)
-s, --stubs                     Comma separated list of Ivy
                                  representation of jars with stubs.
                                  Eg. groupid:artifactid1,groupid2:
                                  artifactid2:classifier
--sm, --stubsMode               Stubs mode to be used. Acceptable values
                                  [CLASSPATH, LOCAL, REMOTE]
-u, --username                  Username to user when connecting to
                                  repository</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_http_stubs" href="#_http_stubs"></a> HTTP存根</h4></div></div></div><p>存根在JSON文档中定义，其语法在<a class="link" href="http://wiremock.org/stubbing.html" target="_top">WireMock文档中</a>定义</p><p>例：</p><pre class="programlisting">{
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span>: {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"GET"</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/ping"</span>
    },
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span>: {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span class="hl-number">200</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"pong"</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span>: {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"text/plain"</span>
        }
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_viewing_registered_mappings" href="#_viewing_registered_mappings"></a>查看注册的映射</h4></div></div></div><p>每个存根协作者都会在下面公开定义的映射列表<code class="literal">__/admin/</code>端点。</p><p>您也可以使用<code class="literal">mappingsOutputFolder</code>属性以将映射转储到文件。对于基于注释的方法，它看起来像这样</p><pre class="programlisting">@AutoConfigureStubRunner(ids=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"a.b.c:loanIssuance,a.b.c:fraudDetectionServer"</span>,
mappingsOutputFolder = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappings/"</span>)</pre><p>对于这样的JUnit方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ClassRule</span></em> <em><span class="hl-annotation" style="color: gray">@Shared</span></em> StubRunnerRule rule = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubRunnerRule()
			.repoRoot(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://some_url"</span>)
			.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"a.b.c"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)
			.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"a.b.c:fraudDetectionServer"</span>)
			.withMappingsOutputFolder(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappings"</span>)</pre><p>然后，如果您检出文件夹<code class="literal">target/outputmappings</code>您将看到以下结构</p><pre class="programlisting">.
&#9500;&#9472;&#9472; fraudDetectionServer_<span class="hl-number">13705</span>
&#9492;&#9472;&#9472; loanIssuance_<span class="hl-number">12255</span></pre><p>这意味着注册了两个存根。 <code class="literal">fraudDetectionServer</code>在港口注册<code class="literal">13705</code>和<code class="literal">loanIssuance</code>在港口<code class="literal">12255</code> 。如果我们看一下其中一个文件，我们将看到（对于WireMock）给定服务器可用的映射：</p><pre class="programlisting">[<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"f9152eb9-bf77-4c38-8289-90be7d10d0d7"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/name"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"GET"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">200</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uuid"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"f9152eb9-bf77-4c38-8289-90be7d10d0d7"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
...
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_messaging_stubs" href="#_messaging_stubs"></a>消息存根</h4></div></div></div><p>根据提供的Stub Runner依赖性和DSL，将自动设置消息传递路由。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_junit_rule_and_stub_runner_junit5_extension" href="#_stub_runner_junit_rule_and_stub_runner_junit5_extension"></a> 92.4 Stub Runner JUnit规则和Stub Runner JUnit5扩展</h2></div></div></div><p>Stub Runner附带了JUnit规则，您可以很容易地为给定的组和工件ID下载并运行存根：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> StubRunnerRule rule = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubRunnerRule().repoRoot(repoRoot())
		.stubsMode(StubRunnerProperties.StubsMode.REMOTE)
		.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)
		.downloadStub(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"</span>);

<em><span class="hl-annotation" style="color: gray">@BeforeClass</span></em>
<em><span class="hl-annotation" style="color: gray">@AfterClass</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setupProps() {
	System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.repository.root"</span>);
	System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.classifier"</span>);
}</pre><p>还有一个<code class="literal">StubRunnerExtension</code>可用于JUnit 5。 <code class="literal">StubRunnerRule</code>和<code class="literal">StubRunnerExtension</code>以非常相似的方式工作执行规则/扩展后，Stub Runner连接到您的Maven存储库，并且对于给定的依赖项列表，尝试执行以下操作：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">下载它们</li><li class="listitem">本地缓存它们</li><li class="listitem">将它们解压缩到一个临时文件夹</li><li class="listitem">从提供的端口范围/提供的端口为随机端口上的每个Maven依赖项启动WireMock服务器</li><li class="listitem">向WireMock服务器提供有效的WireMock定义的所有JSON文件</li><li class="listitem">也可以发送消息（记住要通过<code class="literal">MessageVerifier</code>接口）</li></ul></div><p>Stub Runner使用<a class="link" href="https://wiki.eclipse.org/Aether" target="_top">Eclipse Aether</a>机制下载Maven依赖项。检查他们的<a class="link" href="https://wiki.eclipse.org/Aether" target="_top">文档</a>以获取更多信息。</p><p>自从<code class="literal">StubRunnerRule</code>和<code class="literal">StubRunnerExtension</code>实施<code class="literal">StubFinder</code>它们使您可以找到已启动的存根：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.stubrunner;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> java.net.URL;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> java.util.Collection;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> java.util.Map;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract;

<strong class="hl-tag" style="color: blue">/**
 * Contract for finding registered stubs.
 *
 * @author Marcin Grzejszczak
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StubFinder <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> StubTrigger {

	<strong class="hl-tag" style="color: blue">/**
	 * For the given groupId and artifactId tries to find the matching URL of the running
	 * stub.
	 * @param groupId - might be null. In that case a search only via artifactId takes
	 * place
	 * @param artifactId - artifact id of the stub
	 * @return URL of a running stub or throws exception if not found
	 * @throws StubNotFoundException in case of not finding a stub
	 */</strong>
	URL findStubUrl(String groupId, String artifactId) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> StubNotFoundException;

	<strong class="hl-tag" style="color: blue">/**
	 * For the given Ivy notation {@code [groupId]:artifactId:[version]:[classifier]}
	 * tries to find the matching URL of the running stub. You can also pass only
	 * {@code artifactId}.
	 * @param ivyNotation - Ivy representation of the Maven artifact
	 * @return URL of a running stub or throws exception if not found
	 * @throws StubNotFoundException in case of not finding a stub
	 */</strong>
	URL findStubUrl(String ivyNotation) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> StubNotFoundException;

	<strong class="hl-tag" style="color: blue">/**
	 * @return all running stubs
	 */</strong>
	RunningStubs findAllRunningStubs();

	<strong class="hl-tag" style="color: blue">/**
	 * @return the list of Contracts
	 */</strong>
	Map&lt;StubConfiguration, Collection&lt;Contract&gt;&gt; getContracts();

}</pre><p>Spock测试中的用法示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
<em><span class="hl-annotation" style="color: gray">@Shared</span></em>
StubRunnerRule rule = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubRunnerRule()
		.stubsMode(StubRunnerProperties.StubsMode.REMOTE)
		.repoRoot(StubRunnerRuleSpec.getResource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/m2repo/repository"</span>).toURI().toString())
		.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)
		.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"</span>)
		.withMappingsOutputFolder(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappingsforrule"</span>)


def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should start WireMock servers'</span>() {
	expect: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'WireMocks are running'</span>
		rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) != null
		rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) != null
		rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) == rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>)
		rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer'</span>) != null
	and:
		rule.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>)
		rule.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>)
		rule.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer'</span>)
	and: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Stubs were registered'</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${rule.findStubUrl('loanIssuance').toString()}/name"</span>.toURL().text == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${rule.findStubUrl('fraudDetectionServer').toString()}/name"</span>.toURL().text == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>
}

def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should output mappings to output folder'</span>() {
	when:
		def url = rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>)
	then:
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> File(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappingsforrule"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer_${url.port}"</span>).exists()
}</pre><p>JUnit测试中的用法示例：</p><pre class="programlisting">	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> should_start_wiremock_servers() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// expect: 'WireMocks are running'</span>
		then(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)).isNotNull();
		then(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)).isNotNull();
		then(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)).isEqualTo(rule.findStubUrl(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>));
		then(rule.findStubUrl(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"</span>))
						.isNotNull();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
		then(rule.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)).isTrue();
		then(rule.findAllRunningStubs().isPresent(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>)).isTrue();
		then(rule.findAllRunningStubs().isPresent(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"</span>))
						.isTrue();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and: 'Stubs were registered'</span>
		then(httpGet(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>).toString() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/name"</span>))
				.isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>);
		then(httpGet(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>).toString() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/name"</span>))
				.isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>);
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String httpGet(String url) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (InputStream stream = URI.create(url).toURL().openStream()) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> StreamUtils.copyToString(stream, Charset.forName(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"UTF-8"</span>));
		}
	}

}</pre><p>JUnit 5扩展示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Visible for Junit</span>
<em><span class="hl-annotation" style="color: gray">@RegisterExtension</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> StubRunnerExtension stubRunnerExtension = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubRunnerExtension()
		.repoRoot(repoRoot()).stubsMode(StubRunnerProperties.StubsMode.REMOTE)
		.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)
		.downloadStub(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"</span>)
		.withMappingsOutputFolder(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappingsforrule"</span>);

<em><span class="hl-annotation" style="color: gray">@BeforeAll</span></em>
<em><span class="hl-annotation" style="color: gray">@AfterAll</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setupProps() {
	System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.repository.root"</span>);
	System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.classifier"</span>);
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> String repoRoot() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> StubRunnerRuleJUnitTest.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>.getResource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/m2repo/repository/"</span>)
				.toURI().toString();
	}
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">catch</span> (Exception e) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span>;
	}
}</pre><p>检查<span class="strong"><strong>JUnit和Spring</strong></span>的<span class="strong"><strong>Common属性，</strong></span>以获取有关如何应用Stub Runner的全局配置的更多信息。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>要将JUnit规则或JUnit 5扩展与消息传递一起使用，您必须提供<code class="literal">MessageVerifier</code>与规则生成器的接口（例如<code class="literal">rule.messageVerifier(new MyMessageVerifier())</code> ）。如果不这样做，则每当您尝试发送消息时，都会引发异常。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_maven_settings" href="#_maven_settings"></a> 92.4.1 Maven设置</h3></div></div></div><p>存根下载程序会使用其他本地存储库文件夹的Maven设置。当前不考虑存储库和配置文件的身份验证详细信息，因此您需要使用上述属性进行指定。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_providing_fixed_ports" href="#_providing_fixed_ports"></a> 92.4.2提供固定端口</h3></div></div></div><p>您还可以在固定端口上运行存根。您可以通过两种不同的方式来实现。一种是在属性中传递它，另一种是通过JUnit规则的流畅API。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_fluent_api" href="#_fluent_api"></a> 92.4.3 Fluent API</h3></div></div></div><p>使用时<code class="literal">StubRunnerRule</code>要么<code class="literal">StubRunnerExtension</code>您可以添加一个存根进行下载，然后为上次下载的存根传递端口。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> StubRunnerRule rule = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubRunnerRule().repoRoot(repoRoot())
		.stubsMode(StubRunnerProperties.StubsMode.REMOTE)
		.downloadStub(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>)
		.withPort(<span class="hl-number">12345</span>).downloadStub(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer:12346"</span>);

<em><span class="hl-annotation" style="color: gray">@BeforeClass</span></em>
<em><span class="hl-annotation" style="color: gray">@AfterClass</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setupProps() {
	System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.repository.root"</span>);
	System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.classifier"</span>);
}</pre><p>您可以看到对于此示例，以下测试有效：</p><pre class="programlisting">then(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>))
		.isEqualTo(URI.create(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:12345"</span>).toURL());
then(rule.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>))
		.isEqualTo(URI.create(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:12346"</span>).toURL());</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_stub_runner_with_spring" href="#_stub_runner_with_spring"></a> 92.4.4带弹簧的桩头赛跑者</h3></div></div></div><p>设置Stub Runner项目的Spring配置。</p><p>通过在配置文件中提供存根列表，存根运行器会自动下载并在WireMock中注册所选存根。</p><p>如果要查找存根依赖项的URL，可以自动连接<code class="literal">StubFinder</code>界面并使用其方法，如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(properties = [" stubrunner.cloud.enabled=false",
		'foo=${stubrunner.runningstubs.fraudDetectionServer.port}',
		'fooWithGroup=${stubrunner.runningstubs.org.springframework.cloud.contract.verifier.stubs.fraudDetectionServer.port}'])</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(mappingsOutputFolder = "target/outputmappings/",
		httpServerStubConfigurer = HttpsForFraudDetection)</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("test")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> StubRunnerConfigurationSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	StubFinder stubFinder
	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	Environment environment
	<em><span class="hl-annotation" style="color: gray">@StubRunnerPort("fraudDetectionServer")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> fraudDetectionServerPort
	<em><span class="hl-annotation" style="color: gray">@StubRunnerPort("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> fraudDetectionServerPortWithGroupId
	<em><span class="hl-annotation" style="color: gray">@Value('${foo}')</span></em>
	Integer foo

	<em><span class="hl-annotation" style="color: gray">@BeforeClass</span></em>
	<em><span class="hl-annotation" style="color: gray">@AfterClass</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setupProps() {
		System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.repository.root"</span>)
		System.clearProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.classifier"</span>)
		WireMockHttpServerStubAccessor.clear()
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should mark all ports as random'</span>() {
		expect:
			WireMockHttpServerStubAccessor.everyPortRandom()
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should start WireMock servers'</span>() {
		expect: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'WireMocks are running'</span>
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) != null
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) != null
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) == stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>)
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>) == stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:loanIssuance'</span>)
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT'</span>) == stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs'</span>)
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer'</span>) != null
		and:
			stubFinder.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>)
			stubFinder.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>)
			stubFinder.findAllRunningStubs().isPresent(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer'</span>)
		and: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Stubs were registered'</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${stubFinder.findStubUrl('loanIssuance').toString()}/name"</span>.toURL().text == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name"</span>.toURL().text == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>
		and: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Fraud Detection is an HTTPS endpoint'</span>
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>).toString().startsWith(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https"</span>)
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should throw an exception when stub is not found'</span>() {
		when:
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'nonExistingService'</span>)
		then:
			thrown(StubNotFoundException)
		when:
			stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'nonExistingGroupId'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'nonExistingArtifactId'</span>)
		then:
			thrown(StubNotFoundException)
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should register started servers as environment variables'</span>() {
		expect:
			environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.runningstubs.loanIssuance.port"</span>) != null
			stubFinder.findAllRunningStubs().getPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanIssuance"</span>) == (environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.runningstubs.loanIssuance.port"</span>) as Integer)
		and:
			environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.runningstubs.fraudDetectionServer.port"</span>) != null
			stubFinder.findAllRunningStubs().getPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>) == (environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.runningstubs.fraudDetectionServer.port"</span>) as Integer)
		and:
			environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.runningstubs.fraudDetectionServer.port"</span>) != null
			stubFinder.findAllRunningStubs().getPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>) == (environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"stubrunner.runningstubs.org.springframework.cloud.contract.verifier.stubs.fraudDetectionServer.port"</span>) as Integer)
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should be able to interpolate a running stub in the passed test property'</span>() {
		given:
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> fraudPort = stubFinder.findAllRunningStubs().getPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>)
		expect:
			fraudPort &gt; <span class="hl-number">0</span>
			environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>, Integer) == fraudPort
			environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fooWithGroup"</span>, Integer) == fraudPort
			foo == fraudPort
	}

	<em><span class="hl-annotation" style="color: gray">@Issue("#573")</span></em>
	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should be able to retrieve the port of a running stub via an annotation'</span>() {
		given:
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> fraudPort = stubFinder.findAllRunningStubs().getPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>)
		expect:
			fraudPort &gt; <span class="hl-number">0</span>
			fraudDetectionServerPort == fraudPort
			fraudDetectionServerPortWithGroupId == fraudPort
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should dump all mappings to a file'</span>() {
		when:
			def url = stubFinder.findStubUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>)
		then:
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> File(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/outputmappings/"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer_${url.port}"</span>).exists()
	}

	<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
	<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {}

	<em><span class="hl-annotation" style="color: gray">@CompileStatic</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> HttpsForFraudDetection <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> WireMockHttpServerStubConfigurer {

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Log log = LogFactory.getLog(HttpsForFraudDetection)

		<em><span class="hl-annotation" style="color: gray">@Override</span></em>
		WireMockConfiguration configure(WireMockConfiguration httpStubConfiguration, HttpServerStubConfiguration httpServerStubConfiguration) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (httpServerStubConfiguration.stubConfiguration.artifactId == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudDetectionServer"</span>) {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> httpsPort = SocketUtils.findAvailableTcpPort()
				log.info(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Will set HTTPs port ["</span> + httpsPort + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"] for fraud detection server"</span>)
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> httpStubConfiguration
						.httpsPort(httpsPort)
			}
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> httpStubConfiguration
		}
	}
}</pre><p>对于以下配置文件：</p><pre class="programlisting">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids:
    - org.springframework.cloud.contract.verifier.stubs:loanIssuance
    - org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer
    - org.springframework.cloud.contract.verifier.stubs:bootService
  stubs-mode: remote</pre><p>除了使用属性，您还可以使用<code class="literal">@AutoConfigureStubRunner</code> 。您可以在下面找到通过在注释上设置值来获得相同结果的示例。</p><pre class="programlisting">@AutoConfigureStubRunner(
		ids = [<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:loanIssuance"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:bootService"</span>],
		stubsMode = StubRunnerProperties.StubsMode.REMOTE,
		repositoryRoot = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"classpath:m2repo/repository/"</span>)</pre><p>Stub Runner Spring以下列方式为每个已注册的WireMock服务器注册环境变量。Stub Runner ID的示例<code class="literal">com.example:foo</code> ， <code class="literal">com.example:bar</code> 。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">stubrunner.runningstubs.foo.port</code></li><li class="listitem"><code class="literal">stubrunner.runningstubs.com.example.foo.port</code></li><li class="listitem"><code class="literal">stubrunner.runningstubs.bar.port</code></li><li class="listitem"><code class="literal">stubrunner.runningstubs.com.example.bar.port</code></li></ul></div><p>您可以在代码中引用该代码。</p><p>您也可以使用<code class="literal">@StubRunnerPort</code>注释以注入正在运行的存根的端口。注释的值可以是<code class="literal">groupid:artifactid</code>或只是<code class="literal">artifactid</code> 。Stub Runner ID的示例<code class="literal">com.example:foo</code> ， <code class="literal">com.example:bar</code> 。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@StubRunnerPort("foo")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> fooPort;
<em><span class="hl-annotation" style="color: gray">@StubRunnerPort("com.example:bar")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> barPort;</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_spring_cloud" href="#_stub_runner_spring_cloud"></a> 92.5 Stub Runner春季云</h2></div></div></div><p>Stub Runner可以与Spring Cloud集成。</p><p>对于现实生活中的示例，您可以查看</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.1.x/producer" target="_top">生产者应用样本</a></li><li class="listitem"><a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.1.x/consumer_with_discovery" target="_top">消费者应用样本</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_stubbing_service_discovery" href="#_stubbing_service_discovery"></a> 92.5.1存根服务发现</h3></div></div></div><p>最重要的特点<code class="literal">Stub Runner Spring Cloud</code>它是存根的事实</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">DiscoveryClient</code></li><li class="listitem"><code class="literal">Ribbon</code> <code class="literal">ServerList</code></li></ul></div><p>这意味着无论您使用的是Zookeeper，Consul，Eureka还是其他工具，您都不需要在测试中使用它。我们正在启动依赖项的WireMock实例，并在您使用时告诉您的应用程序<code class="literal">Feign</code> ，负载均衡<code class="literal">RestTemplate</code>要么<code class="literal">DiscoveryClient</code>直接调用那些存根服务器，而不用调用真正的服务发现工具。</p><p>例如，该测试将通过</p><pre class="programlisting">def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should make service discovery work'</span>() {
	expect: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'WireMocks are running'</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${stubFinder.findStubUrl('loanIssuance').toString()}/name"</span>.toURL().text == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name"</span>.toURL().text == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>
	and: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Stubs can be reached via load service discovery'</span>
		restTemplate.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'http://loanIssuance/name'</span>, String) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loanIssuance'</span>
		restTemplate.getForObject(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'http://someNameThatShouldMapFraudDetectionServer/name'</span>, String) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fraudDetectionServer'</span>
}</pre><p>对于以下配置文件</p><pre class="programlisting">stubrunner:
  idsToServiceIds:
    ivyNotation: someValueInsideYourCode
    fraudDetectionServer: someNameThatShouldMapFraudDetectionServer</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_test_profiles_and_service_discovery" href="#_test_profiles_and_service_discovery"></a>测试配置文件和服务发现</h4></div></div></div><p>在集成测试中，您通常既不想调用发现服务（例如Eureka）也不可以调用Config Server。这就是为什么您要创建其他测试配置以禁用这些功能的原因。</p><p>由于以下限制<a class="link" href="https://github.com/spring-cloud/spring-cloud-commons/issues/156" target="_top"><code class="literal">spring-cloud-commons</code></a>为此，您可以通过如下所示的静态块禁用这些属性（例如Eureka的示例）</p><pre class="programlisting">    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Hack to work around https://github.com/spring-cloud/spring-cloud-commons/issues/156</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> {
        System.setProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"eureka.client.enabled"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"false"</span>);
        System.setProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"spring.cloud.config.failFast"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"false"</span>);
    }</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_additional_configuration" href="#_additional_configuration"></a> 92.5.2附加配置</h3></div></div></div><p>您可以使用以下代码将存根的artifactId与应用名称匹配<code class="literal">stubrunner.idsToServiceIds:</code>地图。您可以通过提供以下功能来禁用Stub Runner功能区支持： <code class="literal">stubrunner.cloud.ribbon.enabled</code>等于<code class="literal">false</code>您可以通过提供以下功能来禁用Stub Runner支持： <code class="literal">stubrunner.cloud.enabled</code>等于<code class="literal">false</code></p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>默认情况下，将对所有服务发现进行存根。这意味着无论事实是否存在<code class="literal">DiscoveryClient</code>其结果将被忽略。但是，如果要重用它，只需设置<code class="literal">stubrunner.cloud.delegate.enabled</code>至<code class="literal">true</code>然后你现有的<code class="literal">DiscoveryClient</code>结果将与存根的结果合并。</p></td></tr></tbody></table></div><p>可以通过以下系统属性或环境变量来调整Stub Runner使用的默认Maven配置。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">maven.repo.local</code> -自定义Maven本地存储库位置的路径</li><li class="listitem"><code class="literal">org.apache.maven.user-settings</code> -自定义Maven用户设置位置的路径</li><li class="listitem"><code class="literal">org.apache.maven.global-settings</code> -Maven全局设置位置的路径</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_boot_application" href="#_stub_runner_boot_application"></a> 92.6 Stub Runner引导应用程序</h2></div></div></div><p>Spring Cloud Contract Stub Runner Boot是一个Spring Boot应用程序，它公开REST端点以触发消息传递标签并访问启动的WireMock服务器。</p><p>用例之一是在已部署的应用程序上运行一些冒烟（端到端）测试。您可以查看<a class="link" href="https://github.com/spring-cloud/spring-cloud-pipelines" target="_top">Spring Cloud Pipelines</a>项目以获取更多信息。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_to_use_it" href="#_how_to_use_it"></a> 92.6.1如何使用？</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stub_runner_server" href="#_stub_runner_server"></a>存根转轮服务器</h4></div></div></div><p>只需添加</p><pre class="programlisting">compile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-starter-stub-runner"</span></pre><p>用注释课程<code class="literal">@EnableStubRunnerServer</code> ，建立一个胖子罐，就可以开始了！</p><p>对于属性，请检查<span class="strong"><strong>Stub Runner Spring</strong></span>部分。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stub_runner_server_fat_jar" href="#_stub_runner_server_fat_jar"></a>存根转轮服务器胖子</h4></div></div></div><p>您可以从Maven下载独立的JAR（例如，版本2.0.1）。发布），如下所示：</p><pre class="programlisting">$ wget -O stub-runner.jar <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'https://search.maven.org/remotecontent?filepath=org/springframework/cloud/spring-cloud-contract-stub-runner-boot/2.0.1.RELEASE/spring-cloud-contract-stub-runner-boot-2.0.1.RELEASE.jar'</span>
$ java -jar stub-runner.jar --stubrunner.ids=... --stubrunner.repositoryRoot=...</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spring_cloud_cli" href="#_spring_cloud_cli"></a> Spring Cloud CLI</h4></div></div></div><p>从...开始<code class="literal">1.4.0.RELEASE</code>版本的<a class="link" href="https://cloud.spring.io/spring-cloud-cli" target="_top">Spring Cloud CLI</a>项目，您可以通过执行以下<a class="link" href="https://cloud.spring.io/spring-cloud-cli" target="_top">命令</a>启动Stub Runner Boot <code class="literal">spring cloud stubrunner</code> 。</p><p>为了通过配置，只需创建一个<code class="literal">stubrunner.yml</code>文件在当前工作目录或子目录中<code class="literal">config</code>或在<code class="literal">~/.spring-cloud</code> 。该文件可能如下所示（运行本地安装的存根示例）</p><p><b>stubrunner.yml。</b>
</p><pre class="programlisting">stubrunner:
  stubsMode: LOCAL
  ids:
    - com.example:beer-api-producer:+:9876</pre><p>
</p><p>然后打电话<code class="literal">spring cloud stubrunner</code>从终端窗口启动Stub Runner服务器。它将在港口可用<code class="literal">8750</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_endpoints_2" href="#_endpoints_2"></a> 92.6.2端点</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_http_2" href="#_http_2"></a> HTTP</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">得到<code class="literal">/stubs</code> -返回中所有正在运行的存根的列表<code class="literal">ivy:integer</code>符号</li><li class="listitem">得到<code class="literal">/stubs/{ivy}</code> -返回给定的端口<code class="literal">ivy</code>表示法（调用端点时<code class="literal">ivy</code>也可以是<code class="literal">artifactId</code>只要）</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_messaging_2" href="#_messaging_2"></a>讯息传递</h4></div></div></div><p>对于消息传递</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">得到<code class="literal">/triggers</code> -返回中所有正在运行的标签的列表<code class="literal">ivy : [ label1, label2 …​]</code>符号</li><li class="listitem">开机自检<code class="literal">/triggers/{label}</code> -通过执行触发器<code class="literal">label</code></li><li class="listitem">开机自检<code class="literal">/triggers/{ivy}/{label}</code> -通过执行触发器<code class="literal">label</code>给定的<code class="literal">ivy</code>表示法（调用端点时<code class="literal">ivy</code>也可以是<code class="literal">artifactId</code>只要）</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_example" href="#_example"></a> 92.6.3范例</h3></div></div></div><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = StubRunnerBoot, loader = SpringBootContextLoader)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(properties = "spring.cloud.zookeeper.enabled=false")</span></em>
<em><span class="hl-annotation" style="color: gray">@ActiveProfiles("test")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> StubRunnerBootSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	StubRunning stubRunning

	def setup() {
		RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpStubsController(stubRunning),
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TriggerController(stubRunning))
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should return a list of running stub servers in "full ivy:port" notation'</span>() {
		when:
			String response = RestAssuredMockMvc.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/stubs'</span>).body.asString()
		then:
			def root = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> JsonSlurper().parseText(response)
			root.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">instanceof</span> Integer
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should return a port on which a [#stubId] stub is running'</span>() {
		when:
			def response = RestAssuredMockMvc.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stubs/${stubId}"</span>)
		then:
			response.statusCode == <span class="hl-number">200</span>
			Integer.valueOf(response.body.asString()) &gt; <span class="hl-number">0</span>
		where:
			stubId &lt;&lt; [<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService:+:stubs'</span>,
					   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'</span>,
					   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService:+'</span>,
					   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService'</span>,
					   <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bootService'</span>]
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should return 404 when missing stub was called'</span>() {
		when:
			def response = RestAssuredMockMvc.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/stubs/a:b:c:d"</span>)
		then:
			response.statusCode == <span class="hl-number">404</span>
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should return a list of messaging labels that can be triggered when version and classifier are passed'</span>() {
		when:
			String response = RestAssuredMockMvc.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/triggers'</span>).body.asString()
		then:
			def root = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> JsonSlurper().parseText(response)
			root.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'</span>?.containsAll([<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"delete_book"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"return_book_1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"return_book_2"</span>])
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should trigger a messaging label'</span>() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpStubsController(stubRunning), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/triggers/delete_book"</span>)
		then:
			response.statusCode == <span class="hl-number">200</span>
		and:
			<span class="hl-number">1</span> * stubRunning.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'delete_book'</span>)
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should trigger a messaging label for a stub with [#stubId] ivy notation'</span>() {
		given:
			StubRunning stubRunning = Mock()
			RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HttpStubsController(stubRunning), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TriggerController(stubRunning))
		when:
			def response = RestAssuredMockMvc.post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/triggers/$stubId/delete_book"</span>)
		then:
			response.statusCode == <span class="hl-number">200</span>
		and:
			<span class="hl-number">1</span> * stubRunning.trigger(stubId, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'delete_book'</span>)
		where:
			stubId &lt;&lt; [<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService:stubs'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:bootService'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bootService'</span>]
	}

	def <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'should throw exception when trigger is missing'</span>() {
		when:
			RestAssuredMockMvc.post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/triggers/missing_label"</span>)
		then:
			Exception e = thrown(Exception)
			e.message.contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Exception occurred while trying to return [missing_label] label."</span>)
			e.message.contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Available labels are"</span>)
			e.message.contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs=[]"</span>)
			e.message.contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs="</span>)
	}

}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_stub_runner_boot_with_service_discovery" href="#_stub_runner_boot_with_service_discovery"></a> 92.6.4具有服务发现的存根运行器引导</h3></div></div></div><p>使用Stub Runner Boot的一种可能性是将其用作“烟雾测试”的存根的提要。这是什么意思？假设您不想将50个微服务部署到测试环境中以检查您的应用程序是否运行正常。在构建过程中，您已经执行了一组测试，但是您还想确保应用程序的包装是正确的。您可以做的是将应用程序部署到环境中，启动它并在其上运行一些测试，以查看其是否正常运行。我们可以称这些测试为冒烟测试，因为它们的想法是仅检查少数几个测试场景。</p><p>这种方法的问题在于，如果您正在执行微服务，则很可能正在使用服务发现工具。Stub Runner Boot允许您通过启动所需的stub并将其注册到服务发现工具中来解决此问题。让我们看一下使用Eureka进行此类设置的示例。假设Eureka已经在运行。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableStubRunnerServer</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableEurekaClient</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> StubRunnerBootEurekaExample {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
		SpringApplication.run(StubRunnerBootEurekaExample.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
	}

}</pre><p>如您所见，我们想启动一个Stub Runner Boot服务器<code class="literal">@EnableStubRunnerServer</code> ，启用Eureka客户端<code class="literal">@EnableEurekaClient</code>并且我们想打开存根运行器功能<code class="literal">@AutoConfigureStubRunner</code> 。</p><p>现在假设我们要启动此应用程序，以便存根自动注册。我们可以通过运行应用程序来做到这一点<code class="literal">java -jar ${SYSTEM_PROPS} stub-runner-boot-eureka-example.jar</code>哪里<code class="literal">${SYSTEM_PROPS}</code>将包含以下属性列表</p><pre class="programlisting">* -Dstubrunner.repositoryRoot=https://repo.spring.io/snapshot (<span class="hl-number">1</span>)
* -Dstubrunner.cloud.stubbed.discovery.enabled=false (<span class="hl-number">2</span>)
* -Dstubrunner.ids=org.springframework.cloud.contract.verifier.stubs:loanIssuance,org.
* springframework.cloud.contract.verifier.stubs:fraudDetectionServer,org.springframework.
* cloud.contract.verifier.stubs:bootService (<span class="hl-number">3</span>)
* -Dstubrunner.idsToServiceIds.fraudDetectionServer=
* someNameThatShouldMapFraudDetectionServer (<span class="hl-number">4</span>)
*
* (<span class="hl-number">1</span>) - we tell Stub Runner where all the stubs reside (<span class="hl-number">2</span>) - we don<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'t want the default
* behaviour where the discovery service is stubbed. That'</span>s why the stub registration will
* be picked (<span class="hl-number">3</span>) - we provide a list of stubs to download (<span class="hl-number">4</span>) - we provide a list of</pre><p>这样，您部署的应用程序可以通过服务发现将请求发送到启动的WireMock服务器。默认情况下，最可能设置1-3点<code class="literal">application.yml</code>因为它们不太可能改变。这样，您每次启动Stub Runner Boot时都只能提供要下载的存根列表。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stubs_per_consumer" href="#_stubs_per_consumer"></a>每个消费者92.7个存根</h2></div></div></div><p>在某些情况下，同一端点的2个使用者希望有2个不同的响应。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>这种方法还使您可以立即知道哪个使用者正在使用API的哪一部分。您可以删除API产生的部分响应，并且可以查看哪些自动生成的测试失败。如果没有失败，那么您可以安全地删除响应的那部分，因为没有人使用它。</p></td></tr></tbody></table></div><p>让我们看下面为生产者定义的合同示例<code class="literal">producer</code> 。有2个消费者： <code class="literal">foo-consumer</code>和<code class="literal">bar-consumer</code> 。</p><p><span class="strong"><strong>消费者<code class="literal">foo-service</code></strong></span></p><pre class="programlisting">request {
   url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/foo'</span>
   method GET()
}
response {
    status OK()
    body(
       foo: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>
    }
}</pre><p><span class="strong"><strong>消费者<code class="literal">bar-service</code></strong></span></p><pre class="programlisting">request {
   url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/foo'</span>
   method GET()
}
response {
    status OK()
    body(
       bar: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>
    }
}</pre><p>您不能为同一请求产生2个不同的响应。因此，您可以正确打包合同，然后从中获利<code class="literal">stubsPerConsumer</code>特征。</p><p>在生产者方面，消费者可以拥有一个文件夹，其中仅包含与他们相关的合同。通过设置<code class="literal">stubrunner.stubs-per-consumer</code>标记为<code class="literal">true</code>我们不再注册所有存根，而仅注册与使用者应用程序名称相对应的存根。换句话说，我们将扫描每个存根的路径，如果它在路径中包含带有使用者名称的子文件夹，则它将被注册。</p><p>在<code class="literal">foo</code>生产者方合同看起来像这样</p><pre class="programlisting">.
&#9492;&#9472;&#9472; contracts
    &#9500;&#9472;&#9472; bar-consumer
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookReturnedForBar.groovy
    &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; shouldCallBar.groovy
    &#9492;&#9472;&#9472; foo-consumer
        &#9500;&#9472;&#9472; bookReturnedForFoo.groovy
        &#9492;&#9472;&#9472; shouldCallFoo.groovy</pre><p>作为<code class="literal">bar-consumer</code>消费者，您可以设置<code class="literal">spring.application.name</code>或者<code class="literal">stubrunner.consumer-name</code>至<code class="literal">bar-consumer</code>或按以下方式设置测试：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(properties = ["spring.application.name=bar-consumer"])</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(ids = "org.springframework.cloud.contract.verifier.stubs:producerWithMultipleConsumers",
		repositoryRoot = "classpath:m2repo/repository/",
		stubsMode = StubRunnerProperties.StubsMode.REMOTE,
		stubsPerConsumer = true)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> StubRunnerStubsPerConsumerSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {
...
}</pre><p>然后，仅在包含以下内容的路径下注册的存根<code class="literal">bar-consumer</code>以其名称（即来自<code class="literal">src/test/resources/contracts/bar-consumer/some/contracts/…​</code>文件夹）将被允许引用。</p><p>或明确设置消费者名称</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureStubRunner(ids = "org.springframework.cloud.contract.verifier.stubs:producerWithMultipleConsumers",
		repositoryRoot = "classpath:m2repo/repository/",
		consumerName = "foo-consumer",
		stubsMode = StubRunnerProperties.StubsMode.REMOTE,
		stubsPerConsumer = true)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> StubRunnerStubsPerConsumerWithConsumerNameSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {
...
}</pre><p>然后，仅在包含以下内容的路径下注册的存根<code class="literal">foo-consumer</code>以其名称（即来自<code class="literal">src/test/resources/contracts/foo-consumer/some/contracts/…​</code>文件夹）将被允许引用。</p><p>您可以查看<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/issues/224" target="_top">问题224</a> ，以了解有关此更改背后原因的更多信息。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_common" href="#_common"></a> 92.8共同的</h2></div></div></div><p>本节简要介绍了常用属性，包括：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#common-properties-junit-spring" title="92.8.1 JUnit和Spring的通用属性">第92.8.1节“ JUnit和Spring的通用属性”</a></li><li class="listitem"><a class="xref" href="#stub-runner-stub-ids" title="92.8.2存根运行器存根ID">第92.8.2节“ Stub Runner存根ID”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="common-properties-junit-spring" href="#common-properties-junit-spring"></a> 92.8.1 JUnit和Spring的通用属性</h3></div></div></div><p>您可以使用系统属性或Spring配置属性来设置重复属性。这是它们的名称及其默认值：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">物业名称</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">默认值</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.minPort</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>带存根的已启动WireMock的端口的最小值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.maxPort</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>15000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>带存根的已启动WireMock的端口的最大值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.repositoryRoot</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Maven回购网址。如果为空，则调用本地Maven存储库。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.classifier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>存根</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>存根工件的默认分类器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.stubsMode</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>类路径</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>您想要获取和注册存根的方式</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.ids</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>要下载的常春藤符号存根数组。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.username</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>可选的用户名，用于访问使用存根存储JAR的工具。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>可选密码，用于访问使用存根存储JAR的工具。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.stubsPerConsumer</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>调成<code class="literal">true</code>如果要为每个使用者使用不同的存根，而不是为每个使用者注册所有存根。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>stubrunner.consumerName</p></td><td align="left" valign="top" style="border-right:1px solid"> </td><td align="left" valign="top"><p>如果要为每个使用者使用一个存根并想覆盖使用者名称，只需更改此值即可。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stub-runner-stub-ids" href="#stub-runner-stub-ids"></a> 92.8.2存根运行器存根ID</h3></div></div></div><p>您可以提供存根以通过下载<code class="literal">stubrunner.ids</code>系统属性。他们遵循以下模式：</p><pre class="programlisting">groupId:artifactId:version:classifier:port</pre><p>注意<code class="literal">version</code> ， <code class="literal">classifier</code>和<code class="literal">port</code>是可选的。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">如果您不提供<code class="literal">port</code> ，将随机选择一个。</li><li class="listitem">如果您不提供<code class="literal">classifier</code> ，使用默认值。（请注意，您可以通过以下方式传递空的分类器： <code class="literal">groupId:artifactId:version:</code> ）。</li><li class="listitem">如果您不提供<code class="literal">version</code> ，然后<code class="literal">+</code>将通过并下载最新的。</li></ul></div><p><code class="literal">port</code>表示WireMock服务器的端口。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>从1.0.4版开始，您可以提供希望Stub Runner考虑的一系列版本。您可以<a class="link" href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges" target="_top">在此处</a>阅读有关<a class="link" href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges" target="_top">Aether版本控制范围的</a>更多信息。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="stubrunner-docker" href="#stubrunner-docker"></a> 92.9 Stub Runner Docker</h2></div></div></div><p>我们正在发布<code class="literal">spring-cloud/spring-cloud-contract-stub-runner</code>将启动独立版本的Stub Runner的Docker映像。</p><p>如果您想了解更多有关Maven的基础知识，工件ID，组ID，分类器和工件管理器，请单击此处<a class="xref" href="#docker-project" title="90.16 Docker项目">第90.16节“ Docker项目”</a> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_how_to_use_it_2" href="#_how_to_use_it_2"></a> 92.9.1使用方法</h3></div></div></div><p>只需执行docker镜像即可。您可以将<a class="xref" href="#common-properties-junit-spring" title="92.8.1 JUnit和Spring的通用属性">第92.8.1节“ JUnit和Spring的通用属性”中的</a>任何一个作为环境变量传递。惯例是所有字母都应大写。骆驼箱符号应和点（ <code class="literal">.</code> ）应该通过下划线（ <code class="literal">_</code> ）。例如<code class="literal">stubrunner.repositoryRoot</code>属性应表示为<code class="literal">STUBRUNNER_REPOSITORY_ROOT</code>环境变量。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_example_of_client_side_usage_in_a_non_jvm_project" href="#_example_of_client_side_usage_in_a_non_jvm_project"></a> 92.9.2非JVM项目中的客户端用法示例</h3></div></div></div><p>我们想使用在<a class="xref" href="#docker-server-side" title="90.16.4服务器端（nodejs）">第90.16.4节“服务器端（nodejs）”</a>步骤中创建的存根。假设我们要在端口上运行存根<code class="literal">9876</code> 。NodeJS代码在这里可用：</p><pre class="programlisting">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> bookstore</pre><p>让我们使用存根运行Stub Runner Boot应用程序。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Provide the Spring Cloud Contract Docker version</span>
$ SC_CONTRACT_DOCKER_VERSION=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"..."</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># The IP at which the app is running and Docker container can reach it</span>
$ APP_IP=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"192.168.0.100"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Spring Cloud Contract Stub Runner properties</span>
$ STUBRUNNER_PORT=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"8083"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Stub coordinates 'groupId:artifactId:version:classifier:port'</span>
$ STUBRUNNER_IDS=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:bookstore:0.0.1.RELEASE:stubs:9876"</span>
$ STUBRUNNER_REPOSITORY_ROOT=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://${APP_IP}:8081/artifactory/libs-release-local"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Run the docker with Stub Runner Boot</span>
$ docker run  --rm -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"STUBRUNNER_IDS=${STUBRUNNER_IDS}"</span> -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"STUBRUNNER_REPOSITORY_ROOT=${STUBRUNNER_REPOSITORY_ROOT}"</span> -e <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"STUBRUNNER_STUBS_MODE=REMOTE"</span> -p <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${STUBRUNNER_PORT}:${STUBRUNNER_PORT}"</span> -p <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"9876:9876"</span> springcloud/spring-cloud-contract-stub-runner:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${SC_CONTRACT_DOCKER_VERSION}"</span></pre><p>这是怎么回事</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">一个独立的Stub Runner应用程序已启动</li><li class="listitem">它下载了带有坐标的存根<code class="literal">com.example:bookstore:0.0.1.RELEASE:stubs</code>在港口<code class="literal">9876</code></li><li class="listitem">它是从Artifactory下载的，运行地址为<code class="literal"><a class="link" href="http://192.168.0.100:8081/artifactory/libs-release-local" target="_top">http://192.168.0.100:8081/artifactory/libs-release-local</a></code></li><li class="listitem">一段时间后，Stub Runner将在端口上运行<code class="literal">8083</code></li><li class="listitem">存根将在端口运行<code class="literal">9876</code></li></ul></div><p>在服务器端，我们构建了一个有状态的存根。让我们使用curl声明存根已正确设置。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># let's execute the first request (no response is returned)</span>
$ curl -H <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type:application/json"</span> -X POST --data <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "title" : "Title", "genre" : "Genre", "description" : "Description", "author" : "Author", "publisher" : "Publisher", "pages" : 100, "image_url" : "https://d213dhlpdb53mu.cloudfront.net/assets/pivotal-square-logo-41418bd391196c3022f3cd9f3959b3f6d7764c47873d858583384e759c7db435.svg", "buy_url" : "https://pivotal.io" }'</span> http://localhost:<span class="hl-number">9876</span>/api/books
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Now time for the second request</span>
$ curl -X GET http://localhost:<span class="hl-number">9876</span>/api/books
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># You will receive contents of the JSON</span></pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果要使用在主机上本地构建的存根，则应传递环境变量<code class="literal">-e STUBRUNNER_STUBS_MODE=LOCAL</code>并安装本地m2的音量<code class="literal">-v "${HOME}/.m2/:/root/.m2:ro"</code></p></td></tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="stub-runner-for-messaging" href="#stub-runner-for-messaging"></a> 93。消息传送存根</h2></div></div></div><p>Stub Runner可以在内存中运行已发布的存根。它可以与以下框架集成：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"> Spring Integration </li><li class="listitem"> Spring Cloud Stream </li><li class="listitem">阿帕奇骆驼</li><li class="listitem"> Spring AMQP </li></ul></div><p>它还提供了与市场上任何其他解决方案集成的切入点。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果在类路径上有多个框架，则Stub Runner将需要定义应使用的框架。假设您在类路径上同时具有AMQP，Spring Cloud Stream和Spring Integration。那你需要设置<code class="literal">stubrunner.stream.enabled=false</code>和<code class="literal">stubrunner.integration.enabled=false</code> 。这样，剩下的唯一框架就是Spring AMQP。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_triggering" href="#_stub_triggering"></a> 93.1存根触发</h2></div></div></div><p>要触发消息，请使用<code class="literal">StubTrigger</code>接口：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.stubrunner;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> java.util.Collection;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> java.util.Map;

<strong class="hl-tag" style="color: blue">/**
 * Contract for triggering stub messages.
 *
 * @author Marcin Grzejszczak
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StubTrigger {

	<strong class="hl-tag" style="color: blue">/**
	 * Triggers an event by a given label for a given {@code groupid:artifactid} notation.
	 * You can use only {@code artifactId} too.
	 *
	 * Feature related to messaging.
	 * @param ivyNotation ivy notation of a stub
	 * @param labelName name of the label to trigger
	 * @return true - if managed to run a trigger
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> trigger(String ivyNotation, String labelName);

	<strong class="hl-tag" style="color: blue">/**
	 * Triggers an event by a given label.
	 *
	 * Feature related to messaging.
	 * @param labelName name of the label to trigger
	 * @return true - if managed to run a trigger
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> trigger(String labelName);

	<strong class="hl-tag" style="color: blue">/**
	 * Triggers all possible events.
	 *
	 * Feature related to messaging.
	 * @return true - if managed to run a trigger
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> trigger();

	<strong class="hl-tag" style="color: blue">/**
	 * Feature related to messaging.
	 * @return a mapping of ivy notation of a dependency to all the labels it has.
	 */</strong>
	Map&lt;String, Collection&lt;String&gt;&gt; labels();

}</pre><p>为方便起见， <code class="literal">StubFinder</code>接口扩展<code class="literal">StubTrigger</code> ，因此您只需要在测试中选择一个即可。</p><p><code class="literal">StubTrigger</code>提供以下选项来触发消息：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#trigger-label" title="93.1.1按标签触发">第93.1.1节“按标签触发”</a></li><li class="listitem"><a class="xref" href="#trigger-group-artifact-ids" title="93.1.2按组和工件ID触发">第93.1.2节“按组和工件ID触发”</a></li><li class="listitem"><a class="xref" href="#trigger-artifact-ids" title="93.1.3由工件ID触发">第93.1.3节“由工件ID触发”</a></li><li class="listitem"><a class="xref" href="#trigger-all-messages" title="93.1.4触发所有消息">第93.1.4节“触发所有消息”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-label" href="#trigger-label"></a> 93.1.1按标签触发</h3></div></div></div><pre class="programlisting">stubFinder.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>)</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-group-artifact-ids" href="#trigger-group-artifact-ids"></a> 93.1.2按组和工件ID触发</h3></div></div></div><pre class="programlisting">stubFinder.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.verifier.stubs:streamService'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>)</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-artifact-ids" href="#trigger-artifact-ids"></a> 93.1.3由工件ID触发</h3></div></div></div><pre class="programlisting">stubFinder.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'streamService'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>)</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-all-messages" href="#trigger-all-messages"></a> 93.1.4触发所有消息</h3></div></div></div><pre class="programlisting">stubFinder.trigger()</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_camel" href="#_stub_runner_camel"></a> 93.2存根转轮骆驼</h2></div></div></div><p>Spring Cloud Contract Verifier Stub Runner的消息传递模块为您提供了一种与Apache Camel集成的简便方法。对于提供的工件，它将自动下载存根并注册所需的路由。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_adding_it_to_the_project" href="#_adding_it_to_the_project"></a> 93.2.1将其添加到项目中</h3></div></div></div><p>在类路径上同时安装Apache Camel和Spring Cloud Contract Stub Runner就足够了。记得用以下注释您的测试课<code class="literal">@AutoConfigureStubRunner</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_disabling_the_functionality" href="#_disabling_the_functionality"></a> 93.2.2禁用功能</h3></div></div></div><p>如果您需要禁用此功能，只需通过<code class="literal">stubrunner.camel.enabled=false</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_examples" href="#_examples"></a> 93.2.3例子</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stubs_structure" href="#_stubs_structure"></a>存根结构</h4></div></div></div><p>让我们假设我们有以下Maven存储库，其中包含用于<code class="literal">camelService</code>应用。</p><pre class="programlisting">&#9492;&#9472;&#9472; .m2
    &#9492;&#9472;&#9472; repository
        &#9492;&#9472;&#9472; io
            &#9492;&#9472;&#9472; codearte
                &#9492;&#9472;&#9472; accurest
                    &#9492;&#9472;&#9472; stubs
                        &#9492;&#9472;&#9472; camelService
                            &#9500;&#9472;&#9472; <span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT
                            &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; camelService-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.pom
                            &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; camelService-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
                            &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; maven-metadata-local.xml
                            &#9492;&#9472;&#9472; maven-metadata-local.xml</pre><p>存根包含以下结构：</p><pre class="programlisting">&#9500;&#9472;&#9472; META-INF
&#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; MANIFEST.MF
&#9492;&#9472;&#9472; repository
    &#9500;&#9472;&#9472; accurest
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookDeleted.groovy
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookReturned1.groovy
    &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; bookReturned2.groovy
    &#9492;&#9472;&#9472; mappings</pre><p>让我们考虑以下合同（用<span class="strong"><strong>1</strong></span>编号）：</p><pre class="programlisting">Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>
	input {
		triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookReturnedTriggered()'</span>)
	}
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>)
		body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "bookName" : "foo" }'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
		}
	}
}</pre><p>和数字<span class="strong"><strong>2</strong></span></p><pre class="programlisting">Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_2'</span>
	input {
		messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:input'</span>)
		messageBody([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		messageHeaders {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
		}
	}
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>)
		body([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
		}
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_scenario_1_no_input_message_2" href="#_scenario_1_no_input_message_2"></a>方案1（无输入消息）</h4></div></div></div><p>以便通过触发消息<code class="literal">return_book_1</code>标签，我们将使用<code class="literal">StubTigger</code>界面如下</p><pre class="programlisting">stubFinder.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>)</pre><p>接下来，我们要监听发送到的消息的输出<code class="literal">jms:output</code></p><pre class="programlisting">Exchange receivedMessage = consumerTemplate.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>, <span class="hl-number">5000</span>)</pre><p>并且收到的消息将通过以下断言</p><pre class="programlisting">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_scenario_2_output_triggered_by_input_2" href="#_scenario_2_output_triggered_by_input_2"></a>场景2（输入触发输出）</h4></div></div></div><p>由于已为您设置了路线，仅向该路线发送一条消息就足够了<code class="literal">jms:output</code>目的地。</p><pre class="programlisting">producerTemplate.
		sendBodyAndHeaders(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:input'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BookReturned(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), [sample: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>])</pre><p>接下来，我们要监听发送到的消息的输出<code class="literal">jms:output</code></p><pre class="programlisting">Exchange receivedMessage = consumerTemplate.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>, <span class="hl-number">5000</span>)</pre><p>并且收到的消息将通过以下断言</p><pre class="programlisting">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_scenario_3_input_with_no_output" href="#_scenario_3_input_with_no_output"></a>方案3（输入无输出）</h4></div></div></div><p>由于已为您设置了路线，仅向该路线发送一条消息就足够了<code class="literal">jms:output</code>目的地。</p><pre class="programlisting">producerTemplate.
		sendBodyAndHeaders(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:delete'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BookReturned(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), [sample: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>])</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_integration" href="#_stub_runner_integration"></a> 93.3 Stub Runner集成</h2></div></div></div><p>Spring Cloud Contract Verifier Stub Runner的消息传递模块为您提供了一种与Spring Integration集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_adding_the_runner_to_the_project" href="#_adding_the_runner_to_the_project"></a> 93.3.1将运行器添加到项目</h3></div></div></div><p>您可以在类路径上同时使用Spring Integration和Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code class="literal">@AutoConfigureStubRunner</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_disabling_the_functionality_2" href="#_disabling_the_functionality_2"></a> 93.3.2禁用功能</h3></div></div></div><p>如果您需要禁用此功能，请设置<code class="literal">stubrunner.integration.enabled=false</code>属性。</p><p>假设您具有以下Maven存储库，其中包含针对该Maven部署的存根<code class="literal">integrationService</code>应用：</p><pre class="programlisting">&#9492;&#9472;&#9472; .m2
    &#9492;&#9472;&#9472; repository
        &#9492;&#9472;&#9472; io
            &#9492;&#9472;&#9472; codearte
                &#9492;&#9472;&#9472; accurest
                    &#9492;&#9472;&#9472; stubs
                        &#9492;&#9472;&#9472; integrationService
                            &#9500;&#9472;&#9472; <span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT
                            &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; integrationService-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.pom
                            &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; integrationService-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
                            &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; maven-metadata-local.xml
                            &#9492;&#9472;&#9472; maven-metadata-local.xml</pre><p>进一步假设存根包含以下结构：</p><pre class="programlisting">&#9500;&#9472;&#9472; META-INF
&#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; MANIFEST.MF
&#9492;&#9472;&#9472; repository
    &#9500;&#9472;&#9472; accurest
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookDeleted.groovy
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookReturned1.groovy
    &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; bookReturned2.groovy
    &#9492;&#9472;&#9472; mappings</pre><p>考虑以下合同（编号<span class="strong"><strong>1</strong></span> ）：</p><pre class="programlisting">Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>
	input {
		triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookReturnedTriggered()'</span>)
	}
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'output'</span>)
		body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "bookName" : "foo" }'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
		}
	}
}</pre><p>现在考虑<span class="strong"><strong>2</strong></span> ：</p><pre class="programlisting">Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_2'</span>
	input {
		messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'input'</span>)
		messageBody([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		messageHeaders {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
		}
	}
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'output'</span>)
		body([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
		}
	}
}</pre><p>以及以下Spring Integration Route：</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;beans:beans</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:xsi</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
			 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:beans</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.springframework.org/schema/beans"</span>
			 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.springframework.org/schema/integration"</span>
			 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xsi:schemaLocation</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/integration
			http://www.springframework.org/schema/integration/spring-integration.xsd"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>


	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- REQUIRED FOR TESTING --&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;bridge</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">input-channel</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"output"</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">output-channel</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"outputTest"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;channel</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">id</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"outputTest"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;queue/&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/channel&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/beans:beans&gt;</span></pre><p>这些示例适用于三种情况：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#integration-scenario-1" title="方案1（无输入消息）">称为“方案1（无输入消息）”的部分</a></li><li class="listitem"><a class="xref" href="#integration-scenario-2" title="场景2（输入触发输出）">称为“方案2（由输入触发的输出）”的部分</a></li><li class="listitem"><a class="xref" href="#integration-scenario-3" title="方案3（输入无输出）">称为“方案3（输入无输出）”的部分</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="integration-scenario-1" href="#integration-scenario-1"></a>方案1（无输入消息）</h4></div></div></div><p>通过以下方式触发消息<code class="literal">return_book_1</code>标签，使用<code class="literal">StubTigger</code>界面如下：</p><pre class="programlisting">stubFinder.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>)</pre><p>监听发送到的消息的输出<code class="literal">output</code> ：</p><pre class="programlisting">Message&lt;?&gt; receivedMessage = messaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'outputTest'</span>)</pre><p>收到的消息将通过以下断言：</p><pre class="programlisting">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="integration-scenario-2" href="#integration-scenario-2"></a>场景2（输入触发输出）</h4></div></div></div><p>由于路线是为您设置的，因此您可以向<code class="literal">output</code>目的地：</p><pre class="programlisting">messaging.send(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BookReturned(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), [sample: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>], <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'input'</span>)</pre><p>监听发送到的消息的输出<code class="literal">output</code> ：</p><pre class="programlisting">Message&lt;?&gt; receivedMessage = messaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'outputTest'</span>)</pre><p>收到的消息传递以下断言：</p><pre class="programlisting">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="integration-scenario-3" href="#integration-scenario-3"></a>方案3（输入无输出）</h4></div></div></div><p>由于路线是为您设置的，因此您可以向<code class="literal">input</code>目的地：</p><pre class="programlisting">messaging.send(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BookReturned(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), [sample: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>], <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'delete'</span>)</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_stream" href="#_stub_runner_stream"></a> 93.4 Stub Runner流</h2></div></div></div><p>Spring Cloud Contract Verifier Stub Runner的消息传递模块为您提供了一种与Spring Stream集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果Stub Runner与Stream集成， <code class="literal">messageFrom</code>要么<code class="literal">sentTo</code>字符串首先解析为<code class="literal">destination</code>一个频道，没有这样的<code class="literal">destination</code>存在，将目的地解析为通道名称。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您想使用Spring Cloud Stream，请记住，添加对<code class="literal">org.springframework.cloud:spring-cloud-stream-test-support</code> 。</p></td></tr></tbody></table></div><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-stream-test-support<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-stream-test-support"</span></pre><p class="secondary">
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_adding_the_runner_to_the_project_2" href="#_adding_the_runner_to_the_project_2"></a> 93.4.1将运行器添加到项目</h3></div></div></div><p>您可以在类路径上同时使用Spring Cloud Stream和Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code class="literal">@AutoConfigureStubRunner</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_disabling_the_functionality_3" href="#_disabling_the_functionality_3"></a> 93.4.2禁用功能</h3></div></div></div><p>如果您需要禁用此功能，请设置<code class="literal">stubrunner.stream.enabled=false</code>属性。</p><p>假设您具有以下Maven存储库，其中包含针对该Maven的已部署存根<code class="literal">streamService</code>应用：</p><pre class="programlisting">&#9492;&#9472;&#9472; .m2
    &#9492;&#9472;&#9472; repository
        &#9492;&#9472;&#9472; io
            &#9492;&#9472;&#9472; codearte
                &#9492;&#9472;&#9472; accurest
                    &#9492;&#9472;&#9472; stubs
                        &#9492;&#9472;&#9472; streamService
                            &#9500;&#9472;&#9472; <span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT
                            &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; streamService-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT.pom
                            &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; streamService-<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT-stubs.jar
                            &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; maven-metadata-local.xml
                            &#9492;&#9472;&#9472; maven-metadata-local.xml</pre><p>进一步假设存根包含以下结构：</p><pre class="programlisting">&#9500;&#9472;&#9472; META-INF
&#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; MANIFEST.MF
&#9492;&#9472;&#9472; repository
    &#9500;&#9472;&#9472; accurest
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookDeleted.groovy
    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; bookReturned1.groovy
    &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; bookReturned2.groovy
    &#9492;&#9472;&#9472; mappings</pre><p>考虑以下合同（编号<span class="strong"><strong>1</strong></span> ）：</p><pre class="programlisting">Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>
	input { triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookReturnedTriggered()'</span>) }
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'returnBook'</span>)
		body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "bookName" : "foo" }'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
		headers { header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>) }
	}
}</pre><p>现在考虑<span class="strong"><strong>2</strong></span> ：</p><pre class="programlisting">Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_2'</span>
	input {
		messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookStorage'</span>)
		messageBody([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		messageHeaders { header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>) }
	}
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'returnBook'</span>)
		body([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		headers { header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>) }
	}
}</pre><p>现在考虑以下Spring配置：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner.repositoryRoot</span>: classpath:m2repo/repository/
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner.ids</span>: org.springframework.cloud.contract.verifier.stubs:streamService:<span class="hl-number">0.0</span>.<span class="hl-number">1</span>-SNAPSHOT:stubs
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner.stubs-mode</span>: remote
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    stream</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      bindings</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        output</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          destination</span>: returnBook
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        input</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          destination</span>: bookStorage

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  port</span>: <span class="hl-number">0</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">debug</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><p>这些示例适用于三种情况：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#stream-scenario-1" title="方案1（无输入消息）">称为“方案1（无输入消息）”的部分</a></li><li class="listitem"><a class="xref" href="#stream-scenario-2" title="场景2（输入触发输出）">称为“方案2（由输入触发的输出）”的部分</a></li><li class="listitem"><a class="xref" href="#stream-scenario-3" title="方案3（输入无输出）">称为“方案3（输入无输出）”的部分</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stream-scenario-1" href="#stream-scenario-1"></a>方案1（无输入消息）</h4></div></div></div><p>通过以下方式触发消息<code class="literal">return_book_1</code>标签，使用<code class="literal">StubTrigger</code>界面如下：</p><pre class="programlisting">stubFinder.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'return_book_1'</span>)</pre><p>监听发送到其频道的消息的输出<code class="literal">destination</code>是<code class="literal">returnBook</code> ：</p><pre class="programlisting">Message&lt;?&gt; receivedMessage = messaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'returnBook'</span>)</pre><p>收到的消息传递以下断言：</p><pre class="programlisting">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stream-scenario-2" href="#stream-scenario-2"></a>场景2（输入触发输出）</h4></div></div></div><p>由于路线是为您设置的，因此您可以向<code class="literal">bookStorage</code><code class="literal">destination</code> ：</p><pre class="programlisting">messaging.send(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BookReturned(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), [sample: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>], <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookStorage'</span>)</pre><p>监听发送到的消息的输出<code class="literal">returnBook</code> ：</p><pre class="programlisting">Message&lt;?&gt; receivedMessage = messaging.receive(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'returnBook'</span>)</pre><p>收到的消息传递以下断言：</p><pre class="programlisting">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>) == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stream-scenario-3" href="#stream-scenario-3"></a>方案3（输入无输出）</h4></div></div></div><p>由于路线是为您设置的，因此您可以向<code class="literal">output</code>目的地：</p><pre class="programlisting">messaging.send(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> BookReturned(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), [sample: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>], <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'delete'</span>)</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stub_runner_spring_amqp" href="#_stub_runner_spring_amqp"></a> 93.5 Stub Runner Spring AMQP </h2></div></div></div><p>Spring Cloud Contract Verifier Stub Runner的消息传递模块提供了一种与Spring AMQP的Rabbit模板集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p><p>集成尝试独立工作（即，不与正在运行的RabbitMQ消息代理进行交互）。它期望一个<code class="literal">RabbitTemplate</code>在应用程序上下文中，并将其用作名为<code class="literal">@SpyBean</code> 。结果，它可以使用模仿间谍功能来验证和检查应用程序发送的消息。</p><p>在消息使用者方面，存根赛跑者考虑所有<code class="literal">@RabbitListener</code>带注释的端点和所有<code class="literal">SimpleMessageListenerContainer</code>应用程序上下文中的对象。</p><p>由于通常将消息发送到AMQP中的交易所，因此消息合同包含交易所名称作为目的地。另一端的消息侦听器绑定到队列。绑定将交换连接到队列。如果触发了消息合同，那么Spring AMQP存根运行器集成会在应用程序上下文中查找与该交换匹配的绑定。然后，它从Spring交换收集队列，并尝试查找绑定到这些队列的消息侦听器。将为所有匹配的消息侦听器触发该消息。</p><p>如果您需要使用路由键，则足以通过<code class="literal">amqp_receivedRoutingKey</code>消息头。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_adding_the_runner_to_the_project_3" href="#_adding_the_runner_to_the_project_3"></a> 93.5.1将运行器添加到项目</h3></div></div></div><p>您可以在类路径上同时使用Spring AMQP和Spring Cloud Contract Stub Runner并设置属性<code class="literal">stubrunner.amqp.enabled=true</code> 。记得用以下注释您的测试课<code class="literal">@AutoConfigureStubRunner</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您已经在类路径上安装了Stream和Integration，则需要通过设置<code class="literal">stubrunner.stream.enabled=false</code>和<code class="literal">stubrunner.integration.enabled=false</code>属性。</p></td></tr></tbody></table></div><p>假设您具有以下Maven存储库，其中包含针对该Maven的已部署存根<code class="literal">spring-cloud-contract-amqp-test</code>应用。</p><pre class="programlisting">&#9492;&#9472;&#9472; .m2
    &#9492;&#9472;&#9472; repository
        &#9492;&#9472;&#9472; com
            &#9492;&#9472;&#9472; example
                &#9492;&#9472;&#9472; spring-cloud-contract-amqp-<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>
                    &#9500;&#9472;&#9472; <span class="hl-number">0.4</span>.<span class="hl-number">0</span>-SNAPSHOT
                    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; spring-cloud-contract-amqp-<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>-<span class="hl-number">0.4</span>.<span class="hl-number">0</span>-SNAPSHOT.pom
                    &#9474;&nbsp;&nbsp; &#9500;&#9472;&#9472; spring-cloud-contract-amqp-<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>-<span class="hl-number">0.4</span>.<span class="hl-number">0</span>-SNAPSHOT-stubs.jar
                    &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; maven-metadata-local.xml
                    &#9492;&#9472;&#9472; maven-metadata-local.xml</pre><p>进一步假设存根包含以下结构：</p><pre class="programlisting">&#9500;&#9472;&#9472; META-INF
&#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; MANIFEST.MF
&#9492;&#9472;&#9472; contracts
    &#9492;&#9472;&#9472; shouldProduceValidPersonData.groovy</pre><p>考虑以下合同：</p><pre class="programlisting">Contract.make {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Human readable description</span>
	description <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Should produce valid person data'</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Label by means of which the output message can be triggered</span>
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'contract-test.person.created.event'</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// input to the contract</span>
	input {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the contract will be triggered by a method</span>
		triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'createPerson()'</span>)
	}
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// output message of the contract</span>
	outputMessage {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// destination to which the output message will be sent</span>
		sentTo <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'contract-test.exchange'</span>
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'contentType'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>)
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'__TypeId__'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud.contract.stubrunner.messaging.amqp.Person'</span>)
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the body of the output message</span>
		body([
				id  : $(consumer(<span class="hl-number">9</span>), producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]+"</span>))),
				name: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"me"</span>
		])
	}
}</pre><p>现在考虑以下Spring配置：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  repositoryRoot</span>: classpath:m2repo/repository/
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ids</span>: org.springframework.cloud.contract.verifier.stubs.amqp:spring-cloud-contract-amqp-test:<span class="hl-number">0.4</span>.<span class="hl-number">0</span>-SNAPSHOT:stubs
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  stubs-mode</span>: remote
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  amqp</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  port</span>: <span class="hl-number">0</span></pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_triggering_the_message" href="#_triggering_the_message"></a>触发讯息</h4></div></div></div><p>要使用以上合同触发消息，请使用<code class="literal">StubTrigger</code>界面如下：</p><pre class="programlisting">stubTrigger.trigger(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"contract-test.person.created.event"</span>)</pre><p>该邮件的目的地为<code class="literal">contract-test.exchange</code> ，因此Spring AMQP存根运行器集成会查找与此交换相关的绑定。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Binding binding() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> BindingBuilder.bind(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Queue(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"test.queue"</span>))
			.to(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> DirectExchange(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"contract-test.exchange"</span>)).with(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"#"</span>);
}</pre><p>绑定定义绑定队列<code class="literal">test.queue</code> 。结果，以下侦听器定义将与合同消息匹配并调用。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SimpleMessageListenerContainer simpleMessageListenerContainer(
		ConnectionFactory connectionFactory,
		MessageListenerAdapter listenerAdapter) {
	SimpleMessageListenerContainer container = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SimpleMessageListenerContainer();
	container.setConnectionFactory(connectionFactory);
	container.setQueueNames(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"test.queue"</span>);
	container.setMessageListener(listenerAdapter);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> container;
}</pre><p>此外，以下带注释的侦听器将匹配并被调用：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RabbitListener(bindings = @QueueBinding(value = @Queue("test.queue"), exchange = @Exchange(value = "contract-test.exchange", ignoreDeclarationExceptions = "true")))</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handlePerson(Person person) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.person = person;
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>消息直接移交给<code class="literal">onMessage</code>的方法<code class="literal">MessageListener</code>与匹配相关<code class="literal">SimpleMessageListenerContainer</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spring_amqp_test_configuration" href="#_spring_amqp_test_configuration"></a> Spring AMQP测试配置</h4></div></div></div><p>为了避免Spring AMQP在测试期间尝试连接到正在运行的代理，请配置一个模拟<code class="literal">ConnectionFactory</code> 。</p><p>要禁用模拟的ConnectionFactory，请设置以下属性：<code class="literal">stubrunner.amqp.mockConnection=false</code></p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">stubrunner</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  amqp</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    mockConnection</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="contract-dsl" href="#contract-dsl"></a> 94。合约DSL</h2></div></div></div><p>Spring Cloud Contract支持开箱即用的2种DSL类型。一个写在<code class="literal">Groovy</code>还有一个写在<code class="literal">YAML</code> 。</p><p>如果您决定使用Groovy编写合同，那么如果您以前没有使用过Groovy，请不要感到惊慌。真正不需要该语言的知识，因为Contract DSL仅使用它的一小部分（仅文字，方法调用和闭包）。同样，DSL是静态类型的，以使其在不了解DSL本身的情况下就可以被程序员读取。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>请记住，在Groovy合同文件中，您必须为<code class="literal">Contract</code>类和<code class="literal">make</code>静态导入，例如<code class="literal">org.springframework.cloud.spec.Contract.make { …​ }</code> 。您还可以提供导入到<code class="literal">Contract</code>类： <code class="literal">import org.springframework.cloud.spec.Contract</code>然后打电话<code class="literal">Contract.make { …​ }</code> 。</p></td></tr></tbody></table></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Contract支持在单个文件中定义多个合同。</p></td></tr></tbody></table></div><p>以下是Groovy合同定义的完整示例：</p><pre class="programlisting"></pre><p>以下是YAML合同定义的完整示例：</p><pre class="programlisting">description: Some description
name: some name
priority: 8
ignored: true
request:
  url: /foo
  queryParameters:
    a: b
    b: c
  method: PUT
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
    nullValue: null
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
      - path: $.nullValue
        type: by_null
        value: null
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>您可以使用独立的maven命令将合同编译为存根映射：<code class="literal">mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert</code></p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_limitations" href="#_limitations"></a> 94.1局限性</h2></div></div></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Contract Verifier不正确支持XML。请使用JSON或帮助我们实现此功能。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>验证JSON数组大小的支持是实验性的。如果要打开它，请将以下系统属性的值设置为<code class="literal">true</code> ： <code class="literal">spring.cloud.contract.verifier.assert.size</code> 。默认情况下，此功能设置为<code class="literal">false</code> 。您还可以提供<code class="literal">assertJsonSize</code>插件配置中的属性。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>由于JSON结构可以采用任何形式，因此在使用Groovy DSL和<code class="literal">value(consumer(…​), producer(…​))</code>表示法<code class="literal">GString</code> 。这就是为什么您应该使用Groovy Map表示法的原因。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_common_top_level_elements" href="#_common_top_level_elements"></a> 94.2通用顶级元素</h2></div></div></div><p>以下各节描述了最常见的顶级元素：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#contract-dsl-description" title="94.2.1说明">第94.2.1节“描述”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-name" title="94.2.2名称">第94.2.2节“名称”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-ignoring-contracts" title="94.2.3忽略合同">第94.2.3节“忽略合同”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-passing-values-from-files" title="94.2.4从文件传递值">第94.2.4节“从文件传递值”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-http-top-level-elements" title="94.2.5 HTTP顶级元素">第94.2.5节“ HTTP顶级元素”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-description" href="#contract-dsl-description"></a> 94.2.1说明</h3></div></div></div><p>您可以添加一个<code class="literal">description</code>到您的合同。描述是任意文本。以下代码显示了一个示例：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">			org.springframework.cloud.contract.spec.Contract.make {
				description(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span>given:
	An input
when:
	Sth happens
then:
	Output
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">')
</span>			}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">description: Some description
name: some name
priority: 8
ignored: true
request:
  url: /foo
  queryParameters:
    a: b
    b: c
  method: PUT
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
    nullValue: null
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
      - path: $.nullValue
        type: by_null
        value: null
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-name" href="#contract-dsl-name"></a> 94.2.2名称</h3></div></div></div><p>您可以为合同提供名称。假设您提供了以下名称： <code class="literal">should register a user</code> 。如果这样做，则自动生成的测试的名称为<code class="literal">validate_should_register_a_user</code> 。另外，WireMock存根中的存根名称为<code class="literal">should_register_a_user.json</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您必须确保该名称不包含任何使生成的测试无法编译的字符。另外，请记住，如果为多个合同提供相同的名称，则自动生成的测试将无法编译，并且生成的存根会相互覆盖。</p></td></tr></tbody></table></div><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"some_special_name"</span>)
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">name: some name</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-ignoring-contracts" href="#contract-dsl-ignoring-contracts"></a> 94.2.3忽略合同</h3></div></div></div><p>如果您想忽略合同，则可以在插件配置中设置被忽略合同的值，也可以设置<code class="literal">ignored</code>合同本身的财产：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	ignored()
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">ignored: true</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-passing-values-from-files" href="#contract-dsl-passing-values-from-files"></a> 94.2.4从文件传递值</h3></div></div></div><p>从版本开始<code class="literal">1.2.0</code> ，您可以传递文件中的值。假设您在我们的项目中拥有以下资源。</p><pre class="programlisting">&#9492;&#9472;&#9472; src
&nbsp;&nbsp;&nbsp; &#9492;&#9472;&#9472; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp; &#9492;&#9472;&#9472; resources
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp; &#9492;&#9472;&#9472; contracts
&nbsp;&nbsp;&nbsp;             &#9500;&#9472;&#9472; readFromFile.groovy
&nbsp;&nbsp;&nbsp;             &#9500;&#9472;&#9472; request.json
&nbsp;&nbsp;&nbsp;             &#9492;&#9472;&#9472; response.json</pre><p>进一步假设您的合同如下：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract

Contract.make {
	request {
		method(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PUT'</span>)
		headers {
			contentType(applicationJson())
		}
		body(file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request.json"</span>))
		url(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/1"</span>)
	}
	response {
		status OK()
		body(file(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response.json"</span>))
		headers {
			contentType(applicationJson())
		}
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
  method: GET
  url: /foo
  bodyFromFile: request.json
response:
  status: 200
  bodyFromFile: response.json</pre><p>
</p><p>进一步假设JSON文件如下：</p><p><span class="strong"><strong>request.json</strong></span></p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"REQUEST"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p><span class="strong"><strong>response.json</strong></span></p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"RESPONSE"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>当进行测试或存根生成时，文件的内容将传递到请求或响应的主体。文件名必须是相对于合同所在文件夹的位置的文件。</p><p>如果您需要以二进制形式传递文件的内容，则足以使用<code class="literal">fileAsBytes</code> Groovy DSL中的方法或<code class="literal">bodyFromFileAsBytes</code> YAML中的字段。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract

Contract.make {
	request {
		url(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/1"</span>)
		method(PUT())
		headers {
			contentType(applicationOctetStream())
		}
		body(fileAsBytes(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request.pdf"</span>))
	}
	response {
		status <span class="hl-number">200</span>
		body(fileAsBytes(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response.pdf"</span>))
		headers {
			contentType(applicationOctetStream())
		}
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
  url: /1
  method: PUT
  headers:
    Content-Type: application/octet-stream
  bodyFromFileAsBytes: request.pdf
response:
  status: 200
  bodyFromFileAsBytes: response.pdf
  headers:
    Content-Type: application/octet-stream</pre><p>
</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>每当要使用HTTP和消息传递的二进制有效负载时，都应使用此方法。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-http-top-level-elements" href="#contract-dsl-http-top-level-elements"></a> 94.2.5 HTTP顶级元素</h3></div></div></div><p>在合同定义的顶级闭合中可以调用以下方法。
<code class="literal">request</code>和<code class="literal">response</code>是必须的。 <code class="literal">priority</code>是可选的。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Definition of HTTP request part of the contract</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (this can be a valid request or invalid depending</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// on type of contract being specified).</span>
	request {
		method GET()
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Definition of HTTP response part of the contract</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// (a service implementing this contract should respond</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// with following response after receiving request</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// specified in "request" part above).</span>
	response {
		status <span class="hl-number">200</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Contract priority, which can be used for overriding</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// contracts (1 is highest). Priority is optional.</span>
	priority <span class="hl-number">1</span>
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">priority: 8
request:
...
response:
...</pre><p>
</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您想使合同具有<span class="strong"><strong>较高</strong></span>的优先权价值，则需要将<span class="strong"><strong>较低的</strong></span>数字传递给<code class="literal">priority</code>标签/方法。例如<code class="literal">priority</code>有价值<code class="literal">5</code>具有比<span class="strong"><strong>更高的</strong></span>优先级<code class="literal">priority</code>有价值<code class="literal">10</code> 。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_request" href="#_request"></a> 94.3要求</h2></div></div></div><p>HTTP协议只需要在请求中指定<span class="strong"><strong>方法和URL</strong></span> 。合同的请求定义中必须包含相同的信息。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// HTTP request method (GET/POST/PUT/DELETE).</span>
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Path component of request URL is specified as follows.</span>
		urlPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/users'</span>)
	}

	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		status <span class="hl-number">200</span>
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">method: PUT
url: /foo</pre><p>
</p><p>可以指定一个绝对值而不是相对值<code class="literal">url</code> ，但使用<code class="literal">urlPath</code>是推荐的方法，因为这样做会使测试<span class="strong"><strong>独立</strong></span>于<span class="strong"><strong>主机</strong></span> 。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Specifying `url` and `urlPath` in one contract is illegal.</span>
		url(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'http://localhost:8888/users'</span>)
	}

	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		status <span class="hl-number">200</span>
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
  method: PUT
  urlPath: /foo</pre><p>
</p><p><code class="literal">request</code>可能包含<span class="strong"><strong>查询参数</strong></span> 。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		method GET()

		urlPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/users'</span>) {

			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Each parameter is specified in form</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// `'paramName' : paramValue` where parameter value</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// may be a simple literal or one of matcher functions,</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// all of which are used in this example.</span>
			queryParameters {

				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// If a simple literal is used as value</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// default matcher function is used (equalTo)</span>
				parameter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'limit'</span>: <span class="hl-number">100</span>

				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// `equalTo` function simply compares passed value</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// using identity operator (==).</span>
				parameter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'filter'</span>: equalTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"email"</span>)

				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// `containing` function matches strings</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// that contains passed substring.</span>
				parameter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'gender'</span>: value(consumer(containing(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[mf]"</span>)), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'mf'</span>))

				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// `matching` function tests parameter</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// against passed regular expression.</span>
				parameter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'offset'</span>: value(consumer(matching(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]+"</span>)), producer(<span class="hl-number">123</span>))

				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// `notMatching` functions tests if parameter</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// does not match passed regular expression.</span>
				parameter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loginStartsWith'</span>: value(consumer(notMatching(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".{0,2}"</span>)), producer(<span class="hl-number">3</span>))
			}
		}

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}

	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		status <span class="hl-number">200</span>
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
...
  queryParameters:
    a: b
    b: c
  headers:
    foo: bar
    fooReq: baz
  cookies:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  fixedDelayMilliseconds: 1000
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
    nullValue: null
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
      - path: $.nullValue
        type: by_null
        value: null
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)
    cookies:
      - key: foo2
        regex: bar
      - key: foo3
        predefined:</pre><p>
</p><p><code class="literal">request</code>可能包含其他<span class="strong"><strong>请求标头</strong></span> ，如以下示例所示：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		method GET()
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Each header is added in form `'Header-Name' : 'Header-Value'`.</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// there are also some helper methods</span>
		headers {
			header <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'key'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'value'</span>
			contentType(applicationJson())
		}

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}

	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		status <span class="hl-number">200</span>
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
...
headers:
  foo: bar
  fooReq: baz</pre><p>
</p><p><code class="literal">request</code>可能包含其他<span class="strong"><strong>请求cookie</strong></span> ，如以下示例所示：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		method GET()
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Each Cookies is added in form `'Cookie-Key' : 'Cookie-Value'`.</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// there are also some helper methods</span>
		cookies {
			cookie <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'key'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'value'</span>
			cookie(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'another_key'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'another_value'</span>)
		}

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}

	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		status <span class="hl-number">200</span>
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
...
cookies:
  foo: bar
  fooReq: baz</pre><p>
</p><p><code class="literal">request</code>可能包含一个<span class="strong"><strong>请求正文</strong></span> ：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		method GET()
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Currently only JSON format of request body is supported.</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Format will be determined from a header or body's content.</span>
		body <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "login" : "john", "name": "John The Contract" }'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>
	}

	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		status <span class="hl-number">200</span>
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
...
body:
  foo: bar</pre><p>
</p><p><code class="literal">request</code>可能包含<span class="strong"><strong>多部分</strong></span>元素。要包含多部分元素，请使用<code class="literal">multipart</code>方法/部分，如以下示例所示</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting"></pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
  method: PUT
  url: /multipart
  headers:
    Content-Type: multipart/form-data;boundary=AaB03x
  multipart:
    params:
      # key (parameter name), value (parameter value) pair
      formParameter: '"formParameterValue"'
      someBooleanParameter: true
    named:
      - paramName: file
        fileName: filename.csv
        fileContent: file content
  matchers:
    multipart:
      params:
        - key: formParameter
          regex: ".+"
        - key: someBooleanParameter
          predefined: any_boolean
      named:
        - paramName: file
          fileName:
            predefined: non_empty
          fileContent:
            predefined: non_empty
response:
  status: 200</pre><p>
</p><p>在前面的示例中，我们以两种方式之一定义参数：</p><div class="itemizedlist"><p class="title"><b>Groovy DSL</b></p><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">直接使用地图符号，其中值可以是动态属性（例如<code class="literal">formParameter: $(consumer(…​), producer(…​))</code> ）。</li><li class="listitem">通过使用<code class="literal">named(…​)</code>设置命名参数的方法。命名参数可以设置<code class="literal">name</code>和<code class="literal">content</code> 。您可以通过带有两个参数的方法来调用它，例如<code class="literal">named("fileName", "fileContent")</code> ，或通过地图符号，例如<code class="literal">named(name: "fileName", content: "fileContent")</code> 。</li></ul></div><div class="itemizedlist"><p class="title"><b>YAML</b></p><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">通过以下方式设置多部分参数<code class="literal">multipart.params</code>部分</li><li class="listitem">命名参数（ <code class="literal">fileName</code>和<code class="literal">fileContent</code>对于给定的参数名称）可以通过<code class="literal">multipart.named</code>部分。该部分包含<code class="literal">paramName</code> （参数名称）， <code class="literal">fileName</code> （文件名）， <code class="literal">fileContent</code> （文件内容）字段</li><li class="listitem"><p class="simpara">动态位可以通过设置<code class="literal">matchers.multipart</code>部分</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">对于参数使用<code class="literal">params</code>可以接受的部分<code class="literal">regex</code>或<code class="literal">predefined</code>正则表达式</li><li class="listitem">对于命名参数，请使用<code class="literal">named</code>首先您通过以下部分定义参数名称的部分<code class="literal">paramName</code>然后您可以通过其中一个的参数化<code class="literal">fileName</code>要么<code class="literal">fileContent</code>通过<code class="literal">regex</code>或<code class="literal">predefined</code>正则表达式</li></ul></div></li></ul></div><p>根据该合同，生成的测试如下：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
 MockMvcRequestSpecification request = given()
   .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"multipart/form-data;boundary=AaB03x"</span>)
   .param(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"formParameter"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\"formParameterValue\""</span>)
   .param(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"someBooleanParameter"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"true"</span>)
   .multiPart(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"file"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"filename.csv"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"file content"</span>.getBytes());

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
 ResponseOptions response = given().spec(request)
   .put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/multipart"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
 assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);</pre><p>WireMock存根如下：</p><pre class="programlisting">			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/multipart"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"PUT"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matches"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"multipart/form-data;boundary=AaB03x.*"</span>
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bodyPatterns"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matches"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"</span>formParameter\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\\r\\n(Content-Type: .*\\r\\n)?(Content-Transfer-Encoding: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n\\"</span>.+\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\\r\\n--\\\\1.*"</span>
  		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matches"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"</span>someBooleanParameter\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\\r\\n(Content-Type: .*\\r\\n)?(Content-Transfer-Encoding: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n(true|false)\\r\\n--\\\\1.*"</span>
  		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matches"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"</span>file\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"; filename=\\"</span>[\\\\S\\\\s]+\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\\r\\n(Content-Type: .*\\r\\n)?(Content-Transfer-Encoding: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n[\\\\S\\\\s]+\\r\\n--\\\\1.*"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">200</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transformers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response-template"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo-transformer"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_response" href="#_response"></a> 94.4回应</h2></div></div></div><p>响应必须包含<span class="strong"><strong>HTTP状态代码，</strong></span>并且可能包含其他信息。以下代码显示了一个示例：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		method GET()
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>
	}
	response {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Status code sent by the server</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// in response to request specified above.</span>
		status OK()
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">response:
...
status: 200</pre><p>
</p><p>除了状态之外，响应还可以包含<span class="strong"><strong>标头</strong></span> ， <span class="strong"><strong>cookie</strong></span>和<span class="strong"><strong>主体</strong></span> ，二者的指定方式与请求中的方式相同（请参见上一段）。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>通过Groovy DSL，您可以参考<code class="literal">org.springframework.cloud.contract.spec.internal.HttpStatus</code>提供有意义的状态而不是数字的方法。例如，您可以致电<code class="literal">OK()</code>地位<code class="literal">200</code>要么<code class="literal">BAD_REQUEST()</code>对于<code class="literal">400</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_dynamic_properties" href="#_dynamic_properties"></a> 94.5动态特性</h2></div></div></div><p>合同可以包含一些动态属性：时间戳记，ID等。您不想强迫使用者将自己的时钟设置为总是返回相同的时间值，以使该时间与该存根匹配。</p><p>对于Groovy DSL，您可以通过两种方式在合同中提供动态部分：将其直接传递到主体中，或在单独的部分中进行设置<code class="literal">bodyMatchers</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在2.0.0之前，这些设置使用<code class="literal">testMatchers</code>和<code class="literal">stubMatchers</code> ，请查看<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/wiki/Spring-Cloud-Contract-2.0-Migration-Guide" target="_top">迁移指南</a>以了解更多信息。</p></td></tr></tbody></table></div><p>对于YAML，您只能使用<code class="literal">matchers</code>部分。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_dynamic_properties_inside_the_body" href="#_dynamic_properties_inside_the_body"></a> 94.5.1体内的动态特性</h3></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本节仅对Groovy DSL有效。请查看<a class="xref" href="#contract-matchers" title="94.5.7“匹配器”部分中的动态属性">第94.5.7节“匹配器节中的动态属性”</a>部分，以获取类似功能的YAML示例。</p></td></tr></tbody></table></div><p>您可以使用<code class="literal">value</code>方法，或者，如果您使用Groovy映射符号，请使用<code class="literal">$()</code> 。下面的示例演示如何使用value方法设置动态属性：</p><pre class="programlisting">value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))</pre><p>以下示例显示了如何使用<code class="literal">$()</code> ：</p><pre class="programlisting">$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))</pre><p>两种方法都同样有效。 <code class="literal">stub</code>和<code class="literal">client</code>方法是别名<code class="literal">consumer</code>方法。随后的部分将仔细研究您可以使用这些值做什么。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_regular_expressions" href="#_regular_expressions"></a> 94.5.2正则表达式</h3></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本节仅对Groovy DSL有效。请查看<a class="xref" href="#contract-matchers" title="94.5.7“匹配器”部分中的动态属性">第94.5.7节“匹配器节中的动态属性”</a>部分，以获取类似功能的YAML示例。</p></td></tr></tbody></table></div><p>您可以使用正则表达式在Contract DSL中编写您的请求。当您想要指示应遵循给定模式的请求提供给定响应时，这样做特别有用。此外，在测试和服务器端测试都需要使用模式而不是确切值时，可以使用正则表达式。</p><p>下面的示例演示如何使用正则表达式编写请求：</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>)
		url $(consumer(~/\/[<span class="hl-number">0</span>-<span class="hl-number">9</span>]{<span class="hl-number">2</span>}/), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/12'</span>))
	}
	response {
		status OK()
		body(
				id: $(anyNumber()),
				surname: $(
						consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Kowalsky'</span>),
						producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-zA-Z]+'</span>))
				),
				name: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Jan'</span>,
				created: $(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'2014-02-02 12:23:43'</span>), producer(execute(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'currentDate(it)'</span>))),
				correlationId: value(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'5d1f9fef-e0dc-4f3d-a7e4-72d2220dd827'</span>),
						producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'</span>))
				)
		)
		headers {
			header <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'text/plain'</span>
		}
	}
}</pre><p>您也只能为通信的一侧提供正则表达式。如果这样做，那么合同引擎将自动提供与提供的正则表达式匹配的生成的字符串。以下代码显示了一个示例：</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PUT'</span>
		url value(consumer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/foo/[0-9]{5}'</span>)))
		body([
				requestElement: $(consumer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{5}'</span>)))
		])
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>, $(consumer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application\\/vnd\\.fraud\\.v1\\+json;.*'</span>))))
		}
	}
	response {
		status OK()
		body([
				responseElement: $(producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[0-9]{7}'</span>)))
		])
		headers {
			contentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json"</span>)
		}
	}
}</pre><p>在前面的示例中，通信的另一端具有为请求和响应生成的相应数据。</p><p>Spring Cloud Contract附带了一系列预定义的正则表达式，您可以在合同中使用它们，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern TRUE_OR_FALSE = Pattern.compile(/(true|false)/)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern ALPHA_NUMERIC = Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-zA-Z0-9]+'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern ONLY_ALPHA_UNICODE = Pattern.compile(/[\p{L}]*/)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern NUMBER = Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'-?(\\d*\\.\\d+|\\d+)'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern INTEGER = Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'-?(\\d+)'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern POSITIVE_INT = Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'([1-9]\\d*)'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern DOUBLE = Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'-?(\\d*\\.\\d+)'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern HEX = Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-fA-F0-9]+'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern IP_ADDRESS = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern HOSTNAME_PATTERN = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'((http[s]?|ftp):/)/?([^:/\\s]+)(:[0-9]{1,5})?'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern EMAIL = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern URL = UrlHelper.URL
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern HTTPS_URL = UrlHelper.HTTPS_URL
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern UUID = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern ANY_DATE = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern ANY_DATE_TIME = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern ANY_TIME = Pattern.
		compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])'</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern NON_EMPTY = Pattern.compile(/[\S\s]+/)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern NON_BLANK = Pattern.compile(/^\s*\S[\S\s]*/)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Pattern ISO8601_WITH_OFFSET = Pattern.
		compile(/([<span class="hl-number">0</span>-<span class="hl-number">9</span>]{<span class="hl-number">4</span>})-(<span class="hl-number">1</span>[<span class="hl-number">0</span>-<span class="hl-number">2</span>]|<span class="hl-number">0</span>[<span class="hl-number">1</span>-<span class="hl-number">9</span>])-(<span class="hl-number">3</span>[<span class="hl-number">01</span>]|<span class="hl-number">0</span>[<span class="hl-number">1</span>-<span class="hl-number">9</span>]|[<span class="hl-number">12</span>][<span class="hl-number">0</span>-<span class="hl-number">9</span>])T(<span class="hl-number">2</span>[<span class="hl-number">0</span>-<span class="hl-number">3</span>]|[<span class="hl-number">01</span>][<span class="hl-number">0</span>-<span class="hl-number">9</span>]):([<span class="hl-number">0</span>-<span class="hl-number">5</span>][<span class="hl-number">0</span>-<span class="hl-number">9</span>]):([<span class="hl-number">0</span>-<span class="hl-number">5</span>][<span class="hl-number">0</span>-<span class="hl-number">9</span>])(\.\d{<span class="hl-number">3</span>})?(Z|[+-][<span class="hl-number">01</span>]\d:[<span class="hl-number">0</span>-<span class="hl-number">5</span>]\d)/)

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> Pattern anyOf(String... values) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Pattern.compile(values.collect({ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"^$it\$"</span> }).join(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"|"</span>))
}

RegexProperty onlyAlphaUnicode() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(ONLY_ALPHA_UNICODE).asString()
}

RegexProperty alphaNumeric() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(ALPHA_NUMERIC).asString()
}

RegexProperty number() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(NUMBER).asDouble()
}

RegexProperty positiveInt() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(POSITIVE_INT).asInteger()
}

RegexProperty anyBoolean() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(TRUE_OR_FALSE).asBooleanType()
}

RegexProperty anInteger() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(INTEGER).asInteger()
}

RegexProperty aDouble() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(DOUBLE).asDouble()
}

RegexProperty ipAddress() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(IP_ADDRESS).asString()
}

RegexProperty hostname() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(HOSTNAME_PATTERN).asString()
}

RegexProperty email() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(EMAIL).asString()
}

RegexProperty url() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(URL).asString()
}

RegexProperty httpsUrl() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(HTTPS_URL).asString()
}

RegexProperty uuid() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(UUID).asString()
}

RegexProperty isoDate() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(ANY_DATE).asString()
}

RegexProperty isoDateTime() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(ANY_DATE_TIME).asString()
}

RegexProperty isoTime() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(ANY_TIME).asString()
}

RegexProperty iso8601WithOffset() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(ISO8601_WITH_OFFSET).asString()
}

RegexProperty nonEmpty() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(NON_EMPTY).asString()
}

RegexProperty nonBlank() {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> RegexProperty(NON_BLANK).asString()
}</pre><p>在您的合同中，可以按以下示例所示使用它：</p><pre class="programlisting">Contract dslWithOptionalsInString = Contract.make {
	priority <span class="hl-number">1</span>
	request {
		method POST()
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/users/password'</span>
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'abc@abc.com'</span>)),
				callback_url: $(consumer(regex(hostname())), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'http://partners.com'</span>))
		)
	}
	response {
		status <span class="hl-number">404</span>
		headers {
			contentType(applicationJson())
		}
		body(
				code: value(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"123123"</span>), producer(optional(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"123123"</span>))),
				message: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"User not found by email = [${value(producer(regex(email())), consumer('not.existing@user.com'))}]"</span>
		)
	}
}</pre><p>为了使事情变得更加简单，您可以使用一组预定义的对象，这些对象将自动假定您要传递正则表达式。所有这些方法都始于<code class="literal">any</code>字首：</p><pre class="programlisting">T anyAlphaUnicode()

T anyAlphaNumeric()

T anyNumber()

T anyInteger()

T anyPositiveInt()

T anyDouble()

T anyHex()

T aBoolean()

T anyIpAddress()

T anyHostname()

T anyEmail()

T anyUrl()

T anyHttpsUrl()

T anyUuid()

T anyDate()

T anyDateTime()

T anyTime()

T anyIso8601WithOffset()

T anyNonBlankString()

T anyNonEmptyString()

T anyOf(String... values)</pre><p>这是如何引用这些方法的示例：</p><pre class="programlisting">Contract contractDsl = Contract.make {
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'trigger_event'</span>
	input {
		triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'toString()'</span>)
	}
	outputMessage {
		sentTo <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'topic.rateablequote'</span>
		body([
				alpha            : $(anyAlphaUnicode()),
				number           : $(anyNumber()),
				anInteger        : $(anyInteger()),
				positiveInt      : $(anyPositiveInt()),
				aDouble          : $(anyDouble()),
				aBoolean         : $(aBoolean()),
				ip               : $(anyIpAddress()),
				hostname         : $(anyHostname()),
				email            : $(anyEmail()),
				url              : $(anyUrl()),
				httpsUrl         : $(anyHttpsUrl()),
				uuid             : $(anyUuid()),
				date             : $(anyDate()),
				dateTime         : $(anyDateTime()),
				time             : $(anyTime()),
				iso8601WithOffset: $(anyIso8601WithOffset()),
				nonBlankString   : $(anyNonBlankString()),
				nonEmptyString   : $(anyNonEmptyString()),
				anyOf            : $(anyOf(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bar'</span>))
		])
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_passing_optional_parameters" href="#_passing_optional_parameters"></a> 94.5.3传递可选参数</h3></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本节仅对Groovy DSL有效。请查看<a class="xref" href="#contract-matchers" title="94.5.7“匹配器”部分中的动态属性">第94.5.7节“匹配器节中的动态属性”</a>部分，以获取类似功能的YAML示例。</p></td></tr></tbody></table></div><p>可以在合同中提供可选参数。但是，只能为以下项提供可选参数：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">请求的<span class="emphasis"><em>STUB</em></span>端</li><li class="listitem">回应的<span class="emphasis"><em>测试</em></span>侧</li></ul></div><p>以下示例显示了如何提供可选参数：</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	priority <span class="hl-number">1</span>
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'POST'</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/users/password'</span>
		headers {
			contentType(applicationJson())
		}
		body(
				email: $(consumer(optional(regex(email()))), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'abc@abc.com'</span>)),
				callback_url: $(consumer(regex(hostname())), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'https://partners.com'</span>))
		)
	}
	response {
		status <span class="hl-number">404</span>
		headers {
			header <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>
		}
		body(
				code: value(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"123123"</span>), producer(optional(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"123123"</span>)))
		)
	}
}</pre><p>通过包裹身体的一部分<code class="literal">optional()</code>方法，您将创建一个必须存在0次或多次的正则表达式。</p><p>如果您将Spock用于其中，则将从上一个示例生成以下测试：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"
</span> given:
  def request = given()
    .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>)
    .body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{"email":"abc@abc.com","callback_url":"https://partners.com"}'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)

 when:
  def response = given().spec(request)
    .post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/users/password"</span>)

 then:
  response.statusCode == <span class="hl-number">404</span>
  response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span>)  == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>
 and:
  DocumentContext parsedJson = JsonPath.parse(response.body.asString())
  assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['code']"</span>).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(123123)?"</span>)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"</span></pre><p>还将生成以下存根：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span>{
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/users/password"</span>,
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"POST"</span>,
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bodyPatterns"</span> : [ {
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['email'] =~ /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6})?/)]"</span>
	}, {
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['callback_url'] =~ /((http[s]?|ftp):\\\\/)\\\\/?([^:\\\\/\\\\s]+)(:[0-9]{1,5})?/)]"</span>
	} ],
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : {
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"equalTo"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>
	  }
	}
  },
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">404</span>,
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\\"</span>code\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span><span class="hl-number">123123</span>\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>message\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span>User not found by email == [not.existing<em><span class="hl-annotation" style="color: gray">@user.com]\\"}",</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : {
	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>
	}
  },
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"priority"</span> : <span class="hl-number">1</span>
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_custom_methods_on_the_server_side" href="#_executing_custom_methods_on_the_server_side"></a> 94.5.4在服务器端执行自定义方法</h3></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本节仅对Groovy DSL有效。请查看<a class="xref" href="#contract-matchers" title="94.5.7“匹配器”部分中的动态属性">第94.5.7节“匹配器节中的动态属性”</a>部分，以获取类似功能的YAML示例。</p></td></tr></tbody></table></div><p>您可以定义在测试期间在服务器端执行的方法调用。可以将这种方法添加到配置中定义为“ baseClassForTests”的类中。以下代码显示了测试用例的合同部分的示例：</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PUT'</span>
		url $(consumer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'^/api/[0-9]{2}$'</span>)), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/api/12'</span>))
		headers {
			header <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span>
		}
		body <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'\
</span>			[{
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"text"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Gonna see you at Warsaw"</span>
			}]
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span>	}
	response {
		body(
				path: $(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/api/12'</span>), producer(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'^/api/[0-9]{2}$'</span>))),
				correlationId: $(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'1223456'</span>), producer(execute(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'isProperCorrelationId($it)'</span>)))
		)
		status OK()
	}
}</pre><p>以下代码显示了测试用例的基类部分：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BaseMockMvcSpec <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> Specification {

	def setup() {
		RestAssuredMockMvc.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PairIdController())
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> isProperCorrelationId(Integer correlationId) {
		assert correlationId == <span class="hl-number">123456</span>
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> isEmpty(String value) {
		assert value == null
	}

}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您不能同时使用String和<code class="literal">execute</code>执行串联。例如，打电话<code class="literal">header('Authorization', 'Bearer ' + execute('authToken()'))</code>导致不正确的结果。相反，请致电<code class="literal">header('Authorization', execute('authToken()'))</code>并确保<code class="literal">authToken()</code>方法返回您需要的一切。</p></td></tr></tbody></table></div><p>从JSON读取的对象的类型可以是以下之一，具体取决于JSON路径：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">String</code> ：如果您指向<code class="literal">String</code> JSON中的值。</li><li class="listitem"><code class="literal">JSONArray</code> ：如果您指向<code class="literal">List</code>在JSON中。</li><li class="listitem"><code class="literal">Map</code> ：如果您指向<code class="literal">Map</code>在JSON中。</li><li class="listitem"><code class="literal">Number</code> ：如果您指向<code class="literal">Integer</code> ， <code class="literal">Double</code>等等。</li><li class="listitem"><code class="literal">Boolean</code> ：如果您指向<code class="literal">Boolean</code>在JSON中。</li></ul></div><p>在合同的请求部分，您可以指定<code class="literal">body</code>应该采取一种方法。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您必须同时提供消费者和生产者双方。的<code class="literal">execute</code>部分适用于整个身体-不适用于部分身体。</p></td></tr></tbody></table></div><p>以下示例显示如何从JSON读取对象：</p><pre class="programlisting">Contract contractDsl = Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/something'</span>
		body(
				$(c(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>), p(execute(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'hashCode()'</span>)))
		)
	}
	response {
		status OK()
	}
}</pre><p>前面的示例导致调用<code class="literal">hashCode()</code>请求正文中的方法。它应类似于以下代码：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
 MockMvcRequestSpecification request = given()
   .body(hashCode());

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
 ResponseOptions response = given().spec(request)
   .get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/something"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
 assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_referencing_the_request_from_the_response" href="#_referencing_the_request_from_the_response"></a> 94.5.5引用响应中的请求</h3></div></div></div><p>最好的情况是提供固定值，但是有时您需要在响应中引用一个请求。</p><p>如果您使用Groovy DSL编写合同，则可以使用<code class="literal">fromRequest()</code>方法，可让您从HTTP请求中引用一堆元素。您可以使用以下选项：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">fromRequest().url()</code> ：返回请求网址和查询参数。</li><li class="listitem"><code class="literal">fromRequest().query(String key)</code> ：返回具有给定名称的第一个查询参数。</li><li class="listitem"><code class="literal">fromRequest().query(String key, int index)</code> ：返回具有给定名称的第n个查询参数。</li><li class="listitem"><code class="literal">fromRequest().path()</code> ：返回完整路径。</li><li class="listitem"><code class="literal">fromRequest().path(int index)</code> ：返回第n个路径元素。</li><li class="listitem"><code class="literal">fromRequest().header(String key)</code> ：返回具有给定名称的第一个标头。</li><li class="listitem"><code class="literal">fromRequest().header(String key, int index)</code> ：返回具有给定名称的第n个标头。</li><li class="listitem"><code class="literal">fromRequest().body()</code> ：返回完整的请求正文。</li><li class="listitem"><code class="literal">fromRequest().body(String jsonPath)</code> ：从请求中返回与JSON路径匹配的元素。</li></ul></div><p>如果您使用的是YAML合同定义，则必须使用<a class="link" href="https://handlebarsjs.com/" target="_top">把手</a> <code class="literal">{{{ }}}</code>带有自定义符号的Spring Cloud Contract功能可实现此目的。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">{{{ request.url }}}</code> ：返回请求网址和查询参数。</li><li class="listitem"><code class="literal">{{{ request.query.key.[index] }}}</code> ：返回具有给定名称的第n个查询参数。例如钥匙<code class="literal">foo</code> ，第一个条目<code class="literal">{{{ request.query.foo.[0] }}}</code></li><li class="listitem"><code class="literal">{{{ request.path }}}</code> ：返回完整路径。</li><li class="listitem"><code class="literal">{{{ request.path.[index] }}}</code> ：返回第n个路径元素。例如首次进入<code class="literal">`</code> {{{request.path。[0]}}}</li><li class="listitem"><code class="literal">{{{ request.headers.key }}}</code> ：返回具有给定名称的第一个标头。</li><li class="listitem"><code class="literal">{{{ request.headers.key.[index] }}}</code> ：返回具有给定名称的第n个标头。</li><li class="listitem"><code class="literal">{{{ request.body }}}</code> ：返回完整的请求正文。</li><li class="listitem"><code class="literal">{{{ jsonpath this 'your.json.path' }}}</code> ：从请求中返回与JSON路径匹配的元素。例如json路径<code class="literal">$.foo</code> --<code class="literal">{{{ jsonpath this '$.foo' }}}</code></li></ul></div><p>考虑以下合同：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting"></pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
  method: GET
  url: /api/v1/xxxx
  queryParameters:
    foo:
      - bar
      - bar2
  headers:
    Authorization:
      - secret
      - secret2
  body:
    foo: bar
    baz: 5
response:
  status: 200
  headers:
    Authorization: "foo {{{ request.headers.Authorization.0 }}} bar"
  body:
    url: "{{{ request.url }}}"
    path: "{{{ request.path }}}"
    pathIndex: "{{{ request.path.1 }}}"
    param: "{{{ request.query.foo }}}"
    paramIndex: "{{{ request.query.foo.1 }}}"
    authorization: "{{{ request.headers.Authorization.0 }}}"
    authorization2: "{{{ request.headers.Authorization.1 }}"
    fullBody: "{{{ request.body }}}"
    responseFoo: "{{{ jsonpath this '$.foo' }}}"
    responseBaz: "{{{ jsonpath this '$.baz' }}}"
    responseBaz2: "Bla bla {{{ jsonpath this '$.foo' }}} bla bla"</pre><p>
</p><p>运行JUnit测试生成将导致类似于以下示例的测试：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
 MockMvcRequestSpecification request = given()
   .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Authorization"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret"</span>)
   .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Authorization"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret2"</span>)
   .body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"foo\":\"bar\",\"baz\":5}"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
 ResponseOptions response = given().spec(request)
   .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>,<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>)
   .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>,<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar2"</span>)
   .get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/api/v1/xxxx"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
 assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
 assertThat(response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Authorization"</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo secret bar"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['fullBody']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"foo\":\"bar\",\"baz\":5}"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['authorization']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['authorization2']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret2"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['path']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/api/v1/xxxx"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['param']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['paramIndex']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar2"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['pathIndex']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"v1"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['responseBaz']"</span>).isEqualTo(<span class="hl-number">5</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['responseFoo']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['url']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/api/v1/xxxx?foo=bar&amp;foo=bar2"</span>);
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['responseBaz2']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Bla bla bar bla bla"</span>);</pre><p>如您所见，响应中已正确引用了请求中的元素。</p><p>生成的WireMock存根应类似于以下示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"urlPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/api/v1/xxxx"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"POST"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Authorization"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"equalTo"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret2"</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"queryParameters"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"equalTo"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar2"</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bodyPatterns"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['baz'] == 5)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['foo'] == 'bar')]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">200</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"authorization\":\"{{{request.headers.Authorization.[0]}}}\",\"path\":\"{{{request.path}}}\",\"responseBaz\":{{{jsonpath this '$.baz'}}} ,\"param\":\"{{{request.query.foo.[0]}}}\",\"pathIndex\":\"{{{request.path.[1]}}}\",\"responseBaz2\":\"Bla bla {{{jsonpath this '$.foo'}}} bla bla\",\"responseFoo\":\"{{{jsonpath this '$.foo'}}}\",\"authorization2\":\"{{{request.headers.Authorization.[1]}}}\",\"fullBody\":\"{{{escapejsonbody}}}\",\"url\":\"{{{request.url}}}\",\"paramIndex\":\"{{{request.query.foo.[1]}}}\"}"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Authorization"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{{{request.headers.Authorization.[0]}}};foo"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transformers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response-template"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>发送一个请求，例如<code class="literal">request</code>合同的一部分导致发送以下响应正文：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/api/v1/xxxx?foo=bar&amp;foo=bar2"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"path"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/api/v1/xxxx"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"pathIndex"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"v1"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"param"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"paramIndex"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar2"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"authorization"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"authorization2"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret2"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fullBody"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"foo\":\"bar\",\"baz\":5}"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"responseFoo"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"responseBaz"</span> : <span class="hl-number">5</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"responseBaz2"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Bla bla bar bla bla"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>此功能仅适用于版本大于或等于2.5.1的WireMock。Spring Cloud Contract Verifier使用WireMock的<code class="literal">response-template</code>响应变压器。它使用车把来转换胡子<code class="literal">{{{ }}}</code>模板转换为适当的值。此外，它注册了两个帮助程序功能：</p></td></tr></tbody></table></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">escapejsonbody</code> ：以可嵌入JSON的格式转义请求正文。</li><li class="listitem"><code class="literal">jsonpath</code> ：对于给定的参数，在请求正文中找到一个对象。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_registering_your_own_wiremock_extension" href="#_registering_your_own_wiremock_extension"></a> 94.5.6注册自己的WireMock扩展</h3></div></div></div><p>WireMock允许您注册自定义扩展。默认情况下，Spring Cloud Contract注册该转换器，使您可以引用响应中的请求。如果您想提供自己的扩展程序，则可以注册<code class="literal">org.springframework.cloud.contract.verifier.dsl.wiremock.WireMockExtensions</code>接口。由于我们使用spring.factories扩展方法，因此您可以在<code class="literal">META-INF/spring.factories</code>文件类似于以下内容：</p><pre class="programlisting">org.springframework.cloud.contract.verifier.dsl.wiremock.WireMockExtensions=\
org.springframework.cloud.contract.stubrunner.provider.wiremock.TestWireMockExtensions
org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.stubrunner.TestCustomYamlContractConverter</pre><p>以下是自定义扩展的示例：</p><p><b>TestWireMockExtensions.groovy。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.verifier.dsl.wiremock

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.github.tomakehurst.wiremock.extension.Extension

<strong class="hl-tag" style="color: blue">/**
 * Extension that registers the default transformer and the custom one
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TestWireMockExtensions <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> WireMockExtensions {
	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	List&lt;Extension&gt; extensions() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> [
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> DefaultResponseTransformer(),
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> CustomExtension()
		]
	}
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomExtension <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> Extension {

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	String getName() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo-transformer"</span>
	}
}</pre><p>
</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>记住要覆盖<code class="literal">applyGlobally()</code>方法并将其设置为<code class="literal">false</code>如果您希望仅将转换应用于明确需要转换的映射。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-matchers" href="#contract-matchers"></a> 94.5.7“匹配器”部分中的动态属性</h3></div></div></div><p>如果您使用<a class="link" href="https://docs.pact.io/" target="_top">Pact</a> ，那么以下讨论可能看起来很熟悉。很少有用户习惯于在主体之间进行分隔并设置合同的动态部分。</p><p>您可以使用<code class="literal">bodyMatchers</code>部分有两个原因：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">定义应该以存根结尾的动态值。您可以在<code class="literal">request</code>要么<code class="literal">inputMessage</code>您合同的一部分。</li><li class="listitem">验证测试结果。本节位于<code class="literal">response</code>要么<code class="literal">outputMessage</code>合同一方。</li></ul></div><p>当前，Spring Cloud Contract Verifier仅支持基于JSON路径的匹配器，并具有以下匹配可能性：</p><div class="itemizedlist"><p class="title"><b>Groovy DSL</b></p><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">对于存根（在消费者方面的测试中）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">byEquality()</code> ：通过提供的JSON路径从消费者请求中获取的值必须等于合同中提供的值。</li><li class="listitem"><code class="literal">byRegex(…​)</code> ：通过提供的JSON路径从消费者请求中获取的值必须与正则表达式匹配。您还可以传递期望的匹配值的类型（例如<code class="literal">asString()</code> ， <code class="literal">asLong()</code>等等。）</li><li class="listitem"><code class="literal">byDate()</code> ：通过提供的JSON路径从消费者的请求中获取的值必须与ISO日期值的正则表达式匹配。</li><li class="listitem"><code class="literal">byTimestamp()</code> ：通过提供的JSON路径从消费者请求中获取的值必须与ISO DateTime值的正则表达式匹配。</li><li class="listitem"><code class="literal">byTime()</code> ：通过提供的JSON路径从消费者的请求中获取的值必须与ISO时间值的正则表达式匹配。</li></ul></div></li><li class="listitem"><p class="simpara">进行验证（在生产者方生成的测试中）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">byEquality()</code> ：通过提供的JSON路径从生产者的响应中获取的值必须等于合同中提供的值。</li><li class="listitem"><code class="literal">byRegex(…​)</code> ：通过提供的JSON路径从生产者的响应中获取的值必须与正则表达式匹配。</li><li class="listitem"><code class="literal">byDate()</code> ：通过提供的JSON路径从生产者的响应中获取的值必须与ISO日期值的正则表达式匹配。</li><li class="listitem"><code class="literal">byTimestamp()</code> ：通过提供的JSON路径从生产者的响应中获取的值必须与ISO DateTime值的正则表达式匹配。</li><li class="listitem"><code class="literal">byTime()</code> ：通过提供的JSON路径从生产者的响应中获取的值必须与ISO时间值的正则表达式匹配。</li><li class="listitem"><code class="literal">byType()</code> ：通过提供的JSON路径从生产者的响应中获取的值必须与合同中的响应主体中定义的类型相同。
<code class="literal">byType</code>可以关闭，您可以在其中设置<code class="literal">minOccurrence</code>和<code class="literal">maxOccurrence</code> 。对于请求端，应使用闭包声明集合的大小。这样，您可以声明展平集合的大小。要检查未展平的集合的大小，请对<code class="literal">byCommand(…​)</code> testMatcher。</li><li class="listitem"><p class="simpara"><code class="literal">byCommand(…​)</code> ：通过提供的JSON路径从生产者的响应中获取的值作为输入传递给您提供的自定义方法。例如， <code class="literal">byCommand('foo($it)')</code>导致呼叫<code class="literal">foo</code>与JSON Path匹配的值传递到的方法。从JSON读取的对象的类型可以是以下之一，具体取决于JSON路径：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:square"><li class="listitem"><code class="literal">String</code> ：如果您指向<code class="literal">String</code>值。</li><li class="listitem"><code class="literal">JSONArray</code> ：如果您指向<code class="literal">List</code> 。</li><li class="listitem"><code class="literal">Map</code> ：如果您指向<code class="literal">Map</code> 。</li><li class="listitem"><code class="literal">Number</code> ：如果您指向<code class="literal">Integer</code> ， <code class="literal">Double</code>或其他类型的数字。</li><li class="listitem"><code class="literal">Boolean</code> ：如果您指向<code class="literal">Boolean</code> 。</li></ul></div></li><li class="listitem"><code class="literal">byNull()</code> ：通过提供的JSON路径从响应中获取的值必须为null</li></ul></div></li></ul></div><p><b>YAML。</b> <span class="emphasis"><em>请阅读Groovy部分，以详细了解类型的含义</em></span></p><p>对于YAML，匹配器的结构如下所示</p><pre class="programlisting">- path: $.foo
  type: by_regex
  value: bar
  regexType: as_string</pre><p>或者，如果您想使用预定义的正则表达式之一<code class="literal">[only_alpha_unicode, number, any_boolean, ip_address, hostname, email, url, uuid, iso_date, iso_date_time, iso_time, iso_8601_with_offset, non_empty, non_blank]</code> ：</p><pre class="programlisting">- path: $.foo
  type: by_regex
  predefined: only_alpha_unicode</pre><p>在下面，您可以找到允许的“类型”列表。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara">对于<code class="literal">stubMatchers</code> ：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">by_equality</code></li><li class="listitem"><code class="literal">by_regex</code></li><li class="listitem"><code class="literal">by_date</code></li><li class="listitem"><code class="literal">by_timestamp</code></li><li class="listitem"><code class="literal">by_time</code></li><li class="listitem"><p class="simpara"><code class="literal">by_type</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:square"><li class="listitem">还有2个其他字段： <code class="literal">minOccurrence</code>和<code class="literal">maxOccurrence</code> 。</li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">对于<code class="literal">testMatchers</code> ：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><code class="literal">by_equality</code></li><li class="listitem"><code class="literal">by_regex</code></li><li class="listitem"><code class="literal">by_date</code></li><li class="listitem"><code class="literal">by_timestamp</code></li><li class="listitem"><code class="literal">by_time</code></li><li class="listitem"><p class="simpara"><code class="literal">by_type</code></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:square"><li class="listitem">还有2个其他字段： <code class="literal">minOccurrence</code>和<code class="literal">maxOccurrence</code> 。</li></ul></div></li><li class="listitem"><code class="literal">by_command</code></li><li class="listitem"><code class="literal">by_null</code></li></ul></div></li></ul></div><p>您还可以通过定义正则表达式对应的类型<code class="literal">regexType</code>领域。在下面，您可以找到允许的正则表达式类型列表：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">as_integer</li><li class="listitem">as_double</li><li class="listitem">as_float，</li><li class="listitem">只要</li><li class="listitem">as_short</li><li class="listitem">as_boolean</li><li class="listitem">as_string</li></ul></div><p>考虑以下示例：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">Contract contractDsl = Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>
		urlPath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/get'</span>
		body([
				duck                : <span class="hl-number">123</span>,
				alpha               : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'abc'</span>,
				number              : <span class="hl-number">123</span>,
				aBoolean            : true,
				date                : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'2017-01-01'</span>,
				dateTime            : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'2017-01-01T01:23:45'</span>,
				time                : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'01:02:34'</span>,
				valueWithoutAMatcher: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>,
				valueWithTypeMatch  : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'string'</span>,
				key                 : [
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'complex.key'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
				]
		])
		bodyMatchers {
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.duck'</span>, byRegex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{3}"</span>).asInteger())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.duck'</span>, byEquality())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.alpha'</span>, byRegex(onlyAlphaUnicode()).asString())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.alpha'</span>, byEquality())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.number'</span>, byRegex(number()).asInteger())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.aBoolean'</span>, byRegex(anyBoolean()).asBooleanType())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.date'</span>, byDate())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.dateTime'</span>, byTimestamp())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.time'</span>, byTime())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\$.['key'].['complex.key']"</span>, byEquality())
		}
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status OK()
		body([
				duck                 : <span class="hl-number">123</span>,
				alpha                : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'abc'</span>,
				number               : <span class="hl-number">123</span>,
				positiveInteger      : <span class="hl-number">1234567890</span>,
				negativeInteger      : -<span class="hl-number">1234567890</span>,
				positiveDecimalNumber: <span class="hl-number">123.4567890</span>,
				negativeDecimalNumber: -<span class="hl-number">123.4567890</span>,
				aBoolean             : true,
				date                 : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'2017-01-01'</span>,
				dateTime             : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'2017-01-01T01:23:45'</span>,
				time                 : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"01:02:34"</span>,
				valueWithoutAMatcher : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>,
				valueWithTypeMatch   : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'string'</span>,
				valueWithMin         : [
						<span class="hl-number">1</span>, <span class="hl-number">2</span>, <span class="hl-number">3</span>
				],
				valueWithMax         : [
						<span class="hl-number">1</span>, <span class="hl-number">2</span>, <span class="hl-number">3</span>
				],
				valueWithMinMax      : [
						<span class="hl-number">1</span>, <span class="hl-number">2</span>, <span class="hl-number">3</span>
				],
				valueWithMinEmpty    : [],
				valueWithMaxEmpty    : [],
				key                  : [
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'complex.key'</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
				],
				nullValue            : null
		])
		bodyMatchers {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// asserts the jsonpath value against manual regex</span>
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.duck'</span>, byRegex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{3}"</span>).asInteger())
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// asserts the jsonpath value against the provided value</span>
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.duck'</span>, byEquality())
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// asserts the jsonpath value against some default regex</span>
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.alpha'</span>, byRegex(onlyAlphaUnicode()).asString())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.alpha'</span>, byEquality())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.number'</span>, byRegex(number()).asInteger())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.positiveInteger'</span>, byRegex(anInteger()).asInteger())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.negativeInteger'</span>, byRegex(anInteger()).asInteger())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.positiveDecimalNumber'</span>, byRegex(aDouble()).asDouble())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.negativeDecimalNumber'</span>, byRegex(aDouble()).asDouble())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.aBoolean'</span>, byRegex(anyBoolean()).asBooleanType())
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// asserts vs inbuilt time related regex</span>
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.date'</span>, byDate())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.dateTime'</span>, byTimestamp())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.time'</span>, byTime())
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// asserts that the resulting type is the same as in response body</span>
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.valueWithTypeMatch'</span>, byType())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.valueWithMin'</span>, byType {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// results in verification of size of array (min 1)</span>
				minOccurrence(<span class="hl-number">1</span>)
			})
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.valueWithMax'</span>, byType {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// results in verification of size of array (max 3)</span>
				maxOccurrence(<span class="hl-number">3</span>)
			})
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.valueWithMinMax'</span>, byType {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// results in verification of size of array (min 1 &amp; max 3)</span>
				minOccurrence(<span class="hl-number">1</span>)
				maxOccurrence(<span class="hl-number">3</span>)
			})
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.valueWithMinEmpty'</span>, byType {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// results in verification of size of array (min 0)</span>
				minOccurrence(<span class="hl-number">0</span>)
			})
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.valueWithMaxEmpty'</span>, byType {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// results in verification of size of array (max 0)</span>
				maxOccurrence(<span class="hl-number">0</span>)
			})
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// will execute a method `assertThatValueIsANumber`</span>
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.duck'</span>, byCommand(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'assertThatValueIsANumber($it)'</span>))
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\$.['key'].['complex.key']"</span>, byEquality())
			jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.nullValue'</span>, byNull())
		}
		headers {
			contentType(applicationJson())
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Some-Header'</span>, $(c(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'someValue'</span>), p(regex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'[a-zA-Z]{9}'</span>))))
		}
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">request:
  method: GET
  urlPath: /get/1
  headers:
    Content-Type: application/json
  cookies:
    foo: 2
    bar: 3
  queryParameters:
    limit: 10
    offset: 20
    filter: 'email'
    sort: name
    search: 55
    age: 99
    name: John.Doe
    email: 'bob@email.com'
  body:
    duck: 123
    alpha: "abc"
    number: 123
    aBoolean: true
    date: "2017-01-01"
    dateTime: "2017-01-01T01:23:45"
    time: "01:02:34"
    valueWithoutAMatcher: "foo"
    valueWithTypeMatch: "string"
    key:
      "complex.key": 'foo'
    nullValue: null
    valueWithMin:
      - 1
      - 2
      - 3
    valueWithMax:
      - 1
      - 2
      - 3
    valueWithMinMax:
      - 1
      - 2
      - 3
    valueWithMinEmpty: []
    valueWithMaxEmpty: []
  matchers:
    url:
      regex: /get/[0-9]
      # predefined:
      # execute a method
      #command: 'equals($it)'
    queryParameters:
      - key: limit
        type: equal_to
        value: 20
      - key: offset
        type: containing
        value: 20
      - key: sort
        type: equal_to
        value: name
      - key: search
        type: not_matching
        value: '^[0-9]{2}$'
      - key: age
        type: not_matching
        value: '^\\w*$'
      - key: name
        type: matching
        value: 'John.*'
      - key: hello
        type: absent
    cookies:
      - key: foo
        regex: '[0-9]'
      - key: bar
        command: 'equals($it)'
    headers:
      - key: Content-Type
        regex: "application/json.*"
    body:
      - path: $.duck
        type: by_regex
        value: "[0-9]{3}"
      - path: $.duck
        type: by_equality
      - path: $.alpha
        type: by_regex
        predefined: only_alpha_unicode
      - path: $.alpha
        type: by_equality
      - path: $.number
        type: by_regex
        predefined: number
      - path: $.aBoolean
        type: by_regex
        predefined: any_boolean
      - path: $.date
        type: by_date
      - path: $.dateTime
        type: by_timestamp
      - path: $.time
        type: by_time
      - path: "$.['key'].['complex.key']"
        type: by_equality
      - path: $.nullvalue
        type: by_null
      - path: $.valueWithMin
        type: by_type
        minOccurrence: 1
      - path: $.valueWithMax
        type: by_type
        maxOccurrence: 3
      - path: $.valueWithMinMax
        type: by_type
        minOccurrence: 1
        maxOccurrence: 3
response:
  status: 200
  cookies:
    foo: 1
    bar: 2
  body:
    duck: 123
    alpha: "abc"
    number: 123
    aBoolean: true
    date: "2017-01-01"
    dateTime: "2017-01-01T01:23:45"
    time: "01:02:34"
    valueWithoutAMatcher: "foo"
    valueWithTypeMatch: "string"
    valueWithMin:
      - 1
      - 2
      - 3
    valueWithMax:
      - 1
      - 2
      - 3
    valueWithMinMax:
      - 1
      - 2
      - 3
    valueWithMinEmpty: []
    valueWithMaxEmpty: []
    key:
      'complex.key': 'foo'
    nulValue: null
  matchers:
    headers:
      - key: Content-Type
        regex: "application/json.*"
    cookies:
      - key: foo
        regex: '[0-9]'
      - key: bar
        command: 'equals($it)'
    body:
      - path: $.duck
        type: by_regex
        value: "[0-9]{3}"
      - path: $.duck
        type: by_equality
      - path: $.alpha
        type: by_regex
        predefined: only_alpha_unicode
      - path: $.alpha
        type: by_equality
      - path: $.number
        type: by_regex
        predefined: number
      - path: $.aBoolean
        type: by_regex
        predefined: any_boolean
      - path: $.date
        type: by_date
      - path: $.dateTime
        type: by_timestamp
      - path: $.time
        type: by_time
      - path: $.valueWithTypeMatch
        type: by_type
      - path: $.valueWithMin
        type: by_type
        minOccurrence: 1
      - path: $.valueWithMax
        type: by_type
        maxOccurrence: 3
      - path: $.valueWithMinMax
        type: by_type
        minOccurrence: 1
        maxOccurrence: 3
      - path: $.valueWithMinEmpty
        type: by_type
        minOccurrence: 0
      - path: $.valueWithMaxEmpty
        type: by_type
        maxOccurrence: 0
      - path: $.duck
        type: by_command
        value: assertThatValueIsANumber($it)
      - path: $.nullValue
        type: by_null
        value: null
  headers:
    Content-Type: application/json</pre><p>
</p><p>在前面的示例中，您可以在<code class="literal">matchers</code>部分。对于请求部分，您可以看到，除了<code class="literal">valueWithoutAMatcher</code> ，存根应包含的正则表达式的值已明确设置。为了<code class="literal">valueWithoutAMatcher</code> ，验证的方式与不使用匹配器的方式相同。在这种情况下，测试将执行相等性检查。</p><p>对于响应方面<code class="literal">bodyMatchers</code>部分，我们以类似的方式定义动态部件。唯一的区别是<code class="literal">byType</code>匹配器也存在。验证程序引擎检查四个字段，以验证来自测试的响应是否具有与JSON路径匹配给定字段的值，与响应主体中定义的类型相同的类型，并通过以下检查（基于方法被调用）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">对于<code class="literal">$.valueWithTypeMatch</code> ，引擎会检查类型是否相同。</li><li class="listitem">对于<code class="literal">$.valueWithMin</code> ，引擎检查类型并断言大小是否大于或等于最小出现次数。</li><li class="listitem">对于<code class="literal">$.valueWithMax</code> ，引擎检查类型并断言大小是否小于或等于最大出现次数。</li><li class="listitem">对于<code class="literal">$.valueWithMinMax</code> ，引擎会检查类型并断言大小是否介于最小发生次数和最大发生次数之间。</li></ul></div><p>结果测试类似于以下示例（请注意， <code class="literal">and</code>部分将自动生成的断言和匹配器的断言分开）：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
 MockMvcRequestSpecification request = given()
   .header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>)
   .body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"duck\":123,\"alpha\":\"abc\",\"number\":123,\"aBoolean\":true,\"date\":\"2017-01-01\",\"dateTime\":\"2017-01-01T01:23:45\",\"time\":\"01:02:34\",\"valueWithoutAMatcher\":\"foo\",\"valueWithTypeMatch\":\"string\",\"key\":{\"complex.key\":\"foo\"}}"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
 ResponseOptions response = given().spec(request)
   .get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/get"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
 assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
 assertThat(response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json.*"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['valueWithoutAMatcher']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.duck"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{3}"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.duck"</span>, Integer.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).isEqualTo(<span class="hl-number">123</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.alpha"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[\\p{L}]*"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.alpha"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"abc"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.number"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"-?(\\d*\\.\\d+|\\d+)"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.aBoolean"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(true|false)"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.date"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.dateTime"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])"</span>);
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.time"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])"</span>);
 assertThat((Object) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithTypeMatch"</span>)).isInstanceOf(java.lang.String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
 assertThat((Object) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMin"</span>)).isInstanceOf(java.util.List.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
 assertThat((java.lang.Iterable) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMin"</span>, java.util.Collection.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).as(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMin"</span>).hasSizeGreaterThanOrEqualTo(<span class="hl-number">1</span>);
 assertThat((Object) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMax"</span>)).isInstanceOf(java.util.List.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
 assertThat((java.lang.Iterable) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMax"</span>, java.util.Collection.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).as(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMax"</span>).hasSizeLessThanOrEqualTo(<span class="hl-number">3</span>);
 assertThat((Object) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMinMax"</span>)).isInstanceOf(java.util.List.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
 assertThat((java.lang.Iterable) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMinMax"</span>, java.util.Collection.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).as(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMinMax"</span>).hasSizeBetween(<span class="hl-number">1</span>, <span class="hl-number">3</span>);
 assertThat((Object) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMinEmpty"</span>)).isInstanceOf(java.util.List.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
 assertThat((java.lang.Iterable) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMinEmpty"</span>, java.util.Collection.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).as(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMinEmpty"</span>).hasSizeGreaterThanOrEqualTo(<span class="hl-number">0</span>);
 assertThat((Object) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMaxEmpty"</span>)).isInstanceOf(java.util.List.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
 assertThat((java.lang.Iterable) parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMaxEmpty"</span>, java.util.Collection.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).as(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.valueWithMaxEmpty"</span>).hasSizeLessThanOrEqualTo(<span class="hl-number">0</span>);
 assertThatValueIsANumber(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.duck"</span>));
 assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.['key'].['complex.key']"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>请注意，对于<code class="literal">byCommand</code>方法，该示例调用<code class="literal">assertThatValueIsANumber</code> 。此方法必须在测试基类中定义或静态导入到测试中。请注意<code class="literal">byCommand</code>通话已转换为<code class="literal">assertThatValueIsANumber(parsedJson.read("$.duck"));</code> 。这意味着引擎采用了方法名称，并将正确的JSON路径作为参数传递给它。</p></td></tr></tbody></table></div><p>在下面的示例中，将生成WireMock存根：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"urlPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/get"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"POST"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matches"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json.*"</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bodyPatterns"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.['list'].['some'].['nested'][?(@.['anothervalue'] == 4)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['valueWithoutAMatcher'] == 'foo')]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['valueWithTypeMatch'] == 'string')]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.['list'].['someother'].['nested'][?(@.['json'] == 'with value')]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.['list'].['someother'].['nested'][?(@.['anothervalue'] == 4)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.duck =~ /([0-9]{3})/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.duck == 123)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.alpha =~ /([\\\\p{L}]*)/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.alpha == 'abc')]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.number =~ /(-?(\\\\d*\\\\.\\\\d+|\\\\d+))/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.aBoolean =~ /((true|false))/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.date =~ /((\\\\d\\\\d\\\\d\\\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.dateTime =~ /(([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.time =~ /((2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.list.some.nested[?(@.json =~ /(.*)/)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.valueWithMin.size() &gt;= 1)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.valueWithMax.size() &lt;= 3)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.valueWithMinMax.size() &gt;= 1 &amp;&amp; @.valueWithMinMax.size() &lt;= 3)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.valueWithOccurrence.size() &gt;= 4 &amp;&amp; @.valueWithOccurrence.size() &lt;= 4)]"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">200</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\\"</span>duck\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":123,\\"</span>alpha\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span>abc\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>number\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":123,\\"</span>aBoolean\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":true,\\"</span>date\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span><span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">01</span>\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>dateTime\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span><span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">01</span>T01:<span class="hl-number">23</span>:<span class="hl-number">45</span>\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>time\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span><span class="hl-number">01</span>:<span class="hl-number">02</span>:<span class="hl-number">34</span>\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>valueWithoutAMatcher\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span>foo\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>valueWithTypeMatch\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":\\"</span>string\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">",\\"</span>valueWithMin\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":[1,2,3],\\"</span>valueWithMax\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":[1,2,3],\\"</span>valueWithMinMax\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":[1,2,3],\\"</span>valueWithOccurrence\\<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":[1,2,3,4]}"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transformers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response-template"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果您使用<code class="literal">matcher</code> ，然后在请求和响应部分中<code class="literal">matcher</code>具有JSON路径的地址将从断言中删除。在验证集合的情况下，必须为集合的<span class="strong"><strong>所有</strong></span>元素创建匹配器。</p></td></tr></tbody></table></div><p>考虑以下示例：</p><pre class="programlisting">Contract.make {
    request {
        method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>
        url(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>)
    }
    response {
        status OK()
        body(events: [[
                                 operation          : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'EXPORT'</span>,
                                 eventId            : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'16f1ed75-0bcc-4f0d-a04d-3121798faf99'</span>,
                                 status             : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'OK'</span>
                         ], [
                                 operation          : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'INPUT_PROCESSING'</span>,
                                 eventId            : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'3bb4ac82-6652-462f-b6d1-75e424a0024a'</span>,
                                 status             : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'OK'</span>
                         ]
                ]
        )
        bodyMatchers {
            jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.events[0].operation'</span>, byRegex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'.+'</span>))
            jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.events[0].eventId'</span>, byRegex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})$'</span>))
            jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$.events[0].status'</span>, byRegex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'.+'</span>))
        }
    }
}</pre><p>前面的代码导致创建以下测试（代码块仅显示断言部分）：</p><pre class="programlisting">and:
	DocumentContext parsedJson = JsonPath.parse(response.body.asString())
	assertThatJson(parsedJson).array(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['events']"</span>).contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['eventId']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"16f1ed75-0bcc-4f0d-a04d-3121798faf99"</span>)
	assertThatJson(parsedJson).array(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['events']"</span>).contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['operation']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"EXPORT"</span>)
	assertThatJson(parsedJson).array(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['events']"</span>).contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['operation']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"INPUT_PROCESSING"</span>)
	assertThatJson(parsedJson).array(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['events']"</span>).contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['eventId']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"3bb4ac82-6652-462f-b6d1-75e424a0024a"</span>)
	assertThatJson(parsedJson).array(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['events']"</span>).contains(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['status']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>)
and:
	assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\$.events[0].operation"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".+"</span>)
	assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\$.events[0].eventId"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})\$"</span>)
	assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\$.events[0].status"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".+"</span>)</pre><p>如您所见，断言的格式不正确。仅声明数组的第一个元素。为了解决这个问题，您应该将断言应用于整个<code class="literal">$.events</code>集合并使用<code class="literal">byCommand(…​)</code>方法。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_jax_rs_support" href="#_jax_rs_support"></a> 94.6 JAX-RS支持</h2></div></div></div><p>Spring Cloud Contract Verifier支持JAX-RS 2客户端API。基类需要定义<code class="literal">protected WebTarget webTarget</code>和服务器初始化。测试JAX-RS API的唯一选项是启动Web服务器。同样，带有主体的请求需要设置内容类型。否则，默认为<code class="literal">application/octet-stream</code>被习惯。</p><p>为了使用JAX-RS模式，请使用以下设置：</p><pre class="programlisting">testMode == <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'JAXRSCLIENT'</span></pre><p>以下示例显示了生成的测试API：</p><pre class="programlisting">					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
  Response response = webTarget
    .path(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/users"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"limit"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"10"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"offset"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"20"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"filter"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"email"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"sort"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"search"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"55"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"age"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"99"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Denis.Stepanov"</span>)
    .queryParam(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"email"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bob@email.com"</span>)
    .request()
    .method(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"GET"</span>);

  String responseAsString = response.readEntity(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);

 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
  assertThat(response.getStatus()).isEqualTo(<span class="hl-number">200</span>);
 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
  DocumentContext parsedJson = JsonPath.parse(responseAsString);
  assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['property1']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"a"</span>);
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_async_support" href="#_async_support"></a> 94.7异步支持</h2></div></div></div><p>如果您在服务器端使用异步通信（您的控制器正在返回<code class="literal">Callable</code> ， <code class="literal">DeferredResult</code> ，依此类推），然后，您必须在合同中提供一个<code class="literal">async()</code>中的方法<code class="literal">response</code>部分。以下代码显示了一个示例：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/get'</span>
    }
    response {
        status OK()
        body <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Passed'</span>
        async()
    }
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">response:
    async: true</pre><p>
</p><p>您也可以使用<code class="literal">fixedDelayMilliseconds</code>方法/属性，以增加存根的延迟。</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/get'</span>
    }
    response {
        status <span class="hl-number">200</span>
        body <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Passed'</span>
        fixedDelayMilliseconds <span class="hl-number">1000</span>
    }
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">response:
    fixedDelayMilliseconds: 1000</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_working_with_context_paths" href="#_working_with_context_paths"></a> 94.8使用上下文路径</h2></div></div></div><p>Spring Cloud Contract支持上下文路径。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>完全支持上下文路径所需的唯一更改是<span class="strong"><strong>PRODUCER</strong></span>端的开关。另外，自动生成的测试必须使用<span class="strong"><strong>EXPLICIT</strong></span>模式。消费者方面保持不变。为了使生成的测试通过，您必须使用<span class="strong"><strong>EXPLICIT</strong></span>模式。</p></td></tr></tbody></table></div><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;testMode&gt;</span>EXPLICIT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/testMode&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">contracts {
		testMode = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'EXPLICIT'</span>
}</pre><p class="secondary">
</p><p>这样，您生成的测试<span class="strong"><strong>不</strong></span>使用MockMvc。这意味着您生成了真实的请求，并且需要设置生成的测试的基类以在真实套接字上工作。</p><p>考虑以下合同：</p><pre class="programlisting">org.springframework.cloud.contract.spec.Contract.make {
	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GET'</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/my-context-path/url'</span>
	}
	response {
		status OK()
	}
}</pre><p>以下示例显示如何设置基类和“确保放心”：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.RestAssured;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.boot.web.server.LocalServerPort;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;

<em><span class="hl-annotation" style="color: gray">@SpringBootTest(classes = ContextPathTestingBaseClass.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ContextPathTestingBaseClass {

	<em><span class="hl-annotation" style="color: gray">@LocalServerPort</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> port;

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssured.baseURI = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost"</span>;
		RestAssured.port = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.port;
	}
}</pre><p>如果您这样做：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">自动生成的测试中的所有请求都将发送到包含您的上下文路径的真实端点（例如， <code class="literal">/my-context-path/url</code> ）。</li><li class="listitem">您的合同反映出您具有上下文路径。您生成的存根还具有该信息（例如，在存根中，您必须调用<code class="literal">/my-context-path/url</code> ）。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_working_with_webflux" href="#_working_with_webflux"></a> 94.9使用WebFlux</h2></div></div></div><p>Spring Cloud Contract提供了两种使用WebFlux的方法。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_webflux_with_webtestclient" href="#_webflux_with_webtestclient"></a> 94.9.1使用WebTestClient的WebFlux</h3></div></div></div><p>其中之一是通过<code class="literal">WebTestClient</code>模式。</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;testMode&gt;</span>WEBTESTCLIENT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/testMode&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">contracts {
		testMode = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'WEBTESTCLIENT'</span>
}</pre><p class="secondary">
</p><p>以下示例显示了如何设置<code class="literal">WebTestClient</code>基类和<code class="literal">RestAssured</code>对于WebFlux：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.module.webtestclient.RestAssuredWebTestClient;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BeerRestBase {

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssuredWebTestClient.standaloneSetup(
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ProducerController(personToCheck -&gt; personToCheck.age &gt;= <span class="hl-number">20</span>));
	}
}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_webflux_with_explicit_mode" href="#_webflux_with_explicit_mode"></a> 94.9.2具有显式模式的WebFlux</h3></div></div></div><p>另一种方法是<code class="literal">EXPLICIT</code>模式在生成的测试中使用WebFlux。</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;testMode&gt;</span>EXPLICIT<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/testMode&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">contracts {
		testMode = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'EXPLICIT'</span>
}</pre><p class="secondary">
</p><p>下面的示例显示如何为Web Flux设置基类和“确保放心”：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(classes = BeerRestBase.Config.class,
		webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = "server.port=0")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> BeerRestBase {

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// your tests go here</span>

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// in this config class you define all controllers and mocked services</span>
<em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableAutoConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	PersonCheckingService personCheckingService()  {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> personToCheck -&gt; personToCheck.age &gt;= <span class="hl-number">20</span>;
	}

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	ProducerController producerController() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ProducerController(personCheckingService());
	}
}

}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_xml_support_for_rest" href="#_xml_support_for_rest"></a> 94.10对REST的XML支持</h2></div></div></div><p>对于REST合同，我们还支持XML请求和响应主体。XML主体必须在<code class="literal">body</code>作为一个元素<code class="literal">String</code>要么<code class="literal">GString</code> 。还可以为请求和响应提供身体匹配器。代替<code class="literal">jsonPath(…​)</code>方法， <code class="literal">org.springframework.cloud.contract.spec.internal.BodyMatchers.xPath</code>应该使用所需的方法<code class="literal">xPath</code>作为第一个参数和适当的<code class="literal">MatchingType</code>作为第二。除了所有的身体匹配器<code class="literal">byType()</code>支持。</p><p>这是带有XML响应主体的Groovy DSL合同的示例：</p><pre class="programlisting">					Contract.make {
						request {
							method GET()
							urlPath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/get'</span>
							headers {
								contentType(applicationXml())
							}
						}
						response {
							status(OK())
							headers {
								contentType(applicationXml())
							}
							body <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"
</span>&lt;test&gt;
&lt;duck type=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'xtype'</span>&gt;<span class="hl-number">123</span>&lt;/duck&gt;
&lt;alpha&gt;abc&lt;/alpha&gt;
&lt;list&gt;
&lt;elem&gt;abc&lt;/elem&gt;
&lt;elem&gt;def&lt;/elem&gt;
&lt;elem&gt;ghi&lt;/elem&gt;
&lt;/list&gt;
&lt;number&gt;<span class="hl-number">123</span>&lt;/number&gt;
&lt;aBoolean&gt;true&lt;/aBoolean&gt;
&lt;date&gt;<span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">01</span>&lt;/date&gt;
&lt;dateTime&gt;<span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">01</span>T01:<span class="hl-number">23</span>:<span class="hl-number">45</span>&lt;/dateTime&gt;
&lt;time&gt;<span class="hl-number">01</span>:<span class="hl-number">02</span>:<span class="hl-number">34</span>&lt;/time&gt;
&lt;valueWithoutAMatcher&gt;foo&lt;/valueWithoutAMatcher&gt;
&lt;key&gt;&lt;complex&gt;foo&lt;/complex&gt;&lt;/key&gt;
&lt;/test&gt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"
</span>							bodyMatchers {
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/duck/text()'</span>, byRegex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{3}"</span>))
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/duck/text()'</span>, byCommand(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'test($it)'</span>))
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/duck/xxx'</span>, byNull())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/duck/text()'</span>, byEquality())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/alpha/text()'</span>, byRegex(onlyAlphaUnicode()))
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/alpha/text()'</span>, byEquality())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/number/text()'</span>, byRegex(number()))
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/date/text()'</span>, byDate())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/dateTime/text()'</span>, byTimestamp())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/time/text()'</span>, byTime())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/*/complex/text()'</span>, byEquality())
								xPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/test/duck/@type'</span>, byEquality())
							}
						}
					}</pre><p>下面是带有XML请求和响应主体的YAML合同的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">include</span>::{verifier_core_path}/src/test/resources/yml/contract_rest_xml.yml</pre><p>这是自动生成的XML响应正文测试的示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_xmlMatches() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
	MockMvcRequestSpecification request = given()
				.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/xml"</span>);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
	ResponseOptions response = given().spec(request).get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/get"</span>);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
	assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
	DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance()
					.newDocumentBuilder();
	Document parsedXml = documentBuilder.parse(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> InputSource(
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StringReader(response.getBody().asString())));
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
	assertThat(valueFromXPath(parsedXml, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/list/elem/text()"</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"abc"</span>);
	assertThat(valueFromXPath(parsedXml,<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/list/elem[2]/text()"</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"def"</span>);
	assertThat(valueFromXPath(parsedXml, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/duck/text()"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{3}"</span>);
	assertThat(nodeFromXPath(parsedXml, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/duck/xxx"</span>)).isNull();
	assertThat(valueFromXPath(parsedXml, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/alpha/text()"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[\\p{L}]*"</span>);
	assertThat(valueFromXPath(parsedXml, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/*/complex/text()"</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
	assertThat(valueFromXPath(parsedXml, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/test/duck/@type"</span>)).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"xtype"</span>);
	}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_messaging_top_level_elements" href="#_messaging_top_level_elements"></a> 94.11消息传递顶级元素</h2></div></div></div><p>用于消息传递的DSL与专注于HTTP的DSL看起来有些不同。以下各节说明了差异：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#contract-dsl-output-triggered-method" title="94.11.1方法触发的输出">第94.11.1节“由方法触发的输出”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-output-triggered-message" title="94.11.2消息触发的输出">第94.11.2节“消息触发的输出”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-consumer-producer" title="94.11.3消费者/生产者">第94.11.3节“消费者/生产者”</a></li><li class="listitem"><a class="xref" href="#contract-dsl-common" title="94.11.4共同的">第94.11.4节“公用”</a></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-output-triggered-method" href="#contract-dsl-output-triggered-method"></a> 94.11.1方法触发的输出</h3></div></div></div><p>可以通过调用方法（例如<code class="literal">Scheduler</code>当启动a并发送消息时），如以下示例所示：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">def dsl = Contract.make {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Human readable description</span>
	description <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Some description'</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Label by means of which the output message can be triggered</span>
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// input to the contract</span>
	input {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the contract will be triggered by a method</span>
		triggeredBy(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'bookReturnedTriggered()'</span>)
	}
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// output message of the contract</span>
	outputMessage {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// destination to which the output message will be sent</span>
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'output'</span>)
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the body of the output message</span>
		body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'{ "bookName" : "foo" }'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the headers of the output message</span>
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
		}
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting"># Human readable description
description: Some description
# Label by means of which the output message can be triggered
label: some_label
input:
  # the contract will be triggered by a method
  triggeredBy: bookReturnedTriggered()
# output message of the contract
outputMessage:
  # destination to which the output message will be sent
  sentTo: output
  # the body of the output message
  body:
    bookName: foo
  # the headers of the output message
  headers:
    BOOK-NAME: foo</pre><p>
</p><p>在前面的示例中，输出消息被发送到<code class="literal">output</code>如果一个方法叫做<code class="literal">bookReturnedTriggered</code>被执行。在消息<span class="strong"><strong>发布者</strong></span>方面，我们生成了一个测试，该测试调用该方法来触发消息。在<span class="strong"><strong>消费者</strong></span>方面，您可以使用<code class="literal">some_label</code>触发消息。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-output-triggered-message" href="#contract-dsl-output-triggered-message"></a> 94.11.2消息触发的输出</h3></div></div></div><p>可以通过接收一条消息来触发输出消息，如以下示例所示：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting">def dsl = Contract.make {
	description <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Some Description'</span>
	label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// input is a message</span>
	input {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// the message was received from this destination</span>
		messageFrom(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'input'</span>)
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// has the following body</span>
		messageBody([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and the following headers</span>
		messageHeaders {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
		}
	}
	outputMessage {
		sentTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'output'</span>)
		body([
				bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
		])
		headers {
			header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BOOK-NAME'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>)
		}
	}
}</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting"># Human readable description
description: Some description
# Label by means of which the output message can be triggered
label: some_label
# input is a message
input:
  messageFrom: input
  # has the following body
  messageBody:
    bookName: 'foo'
  # and the following headers
  messageHeaders:
    sample: 'header'
# output message of the contract
outputMessage:
  # destination to which the output message will be sent
  sentTo: output
  # the body of the output message
  body:
    bookName: foo
  # the headers of the output message
  headers:
    BOOK-NAME: foo</pre><p>
</p><p>在前面的示例中，输出消息被发送到<code class="literal">output</code>如果在<code class="literal">input</code>目的地。在消息<span class="strong"><strong>发布者</strong></span>一侧，引擎生成一个测试，将该输入消息发送到定义的目的地。在<span class="strong"><strong>消费者</strong></span>方面，您可以将消息发送到输入目标，也可以使用标签（ <code class="literal">some_label</code>在示例中）触发消息。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-consumer-producer" href="#contract-dsl-consumer-producer"></a> 94.11.3消费者/生产者</h3></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本节仅对Groovy DSL有效。</p></td></tr></tbody></table></div><p>在HTTP中，您有一个概念<code class="literal">client</code> / <code class="literal">stub and `server</code> / <code class="literal">test</code>符号。您也可以在消息传递中使用这些范例。此外，Spring Cloud Contract Verifier还提供了<code class="literal">consumer</code>和<code class="literal">producer</code>方法，如以下示例所示（请注意，您可以使用<code class="literal">$</code>要么<code class="literal">value</code>提供方法<code class="literal">consumer</code>和<code class="literal">producer</code>部分）：</p><pre class="programlisting">					Contract.make {
						label <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'some_label'</span>
						input {
							messageFrom value(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:input'</span>))
							messageBody([
									bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
							])
							messageHeaders {
								header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'sample'</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'header'</span>)
							}
						}
						outputMessage {
							sentTo $(consumer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:input'</span>), producer(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'jms:output'</span>))
							body([
									bookName: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'foo'</span>
							])
						}
					}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="contract-dsl-common" href="#contract-dsl-common"></a> 94.11.4共同的</h3></div></div></div><p>在里面<code class="literal">input</code>要么<code class="literal">outputMessage</code>您可以致电的部分<code class="literal">assertThat</code>名称为<code class="literal">method</code> （例如<code class="literal">assertThatMessageIsOnTheQueue()</code> ），您已经在基类或静态导入中定义了该代码。Spring Cloud Contract将在生成的测试中执行该方法。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_multiple_contracts_in_one_file" href="#_multiple_contracts_in_one_file"></a> 94.12一个文件中有多个合同</h2></div></div></div><p>您可以在一个文件中定义多个合同。这样的合同可能类似于以下示例：</p><p><b>Groovy DSL。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract

[
	Contract.make {
		name(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"should post a user"</span>)
		request {
			method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'POST'</span>
			url(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/users/1'</span>)
		}
		response {
			status OK()
		}
	},
	Contract.make {
		request {
			method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'POST'</span>
			url(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/users/2'</span>)
		}
		response {
			status OK()
		}
	}
]</pre><p>
</p><p><b>YAML。</b>
</p><pre class="programlisting">---
name: should post a user
request:
  method: POST
  url: /users/1
response:
  status: 200
---
request:
  method: POST
  url: /users/2
response:
  status: 200
---
request:
  method: POST
  url: /users/3
response:
  status: 200</pre><p>
</p><p>在前面的示例中，一个合同具有<code class="literal">name</code>字段，其他则不行。这导致生成两个看起来或多或少像这样的测试：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.verifier.tests.com.hello;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.example.TestBase;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.jayway.jsonpath.DocumentContext;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.jayway.jsonpath.JsonPath;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.jayway.restassured.response.ResponseOptions;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Test;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> org.assertj.core.api.Assertions.assertThat;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> V1Test <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> TestBase {

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_should_post_a_user() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
			MockMvcRequestSpecification request = given();

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
			ResponseOptions response = given().spec(request)
					.post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/users/1"</span>);

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
			assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
	}

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_withList_<span class="hl-number">1</span>() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
			MockMvcRequestSpecification request = given();

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
			ResponseOptions response = given().spec(request)
					.post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/users/2"</span>);

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
			assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
	}

}</pre><p>请注意，对于具有<code class="literal">name</code>字段，将生成的测试方法命名为<code class="literal">validate_should_post_a_user</code> 。对于一个没有名字的人，它叫做<code class="literal">validate_withList_1</code> 。它对应于文件名<code class="literal">WithList.groovy</code>以及列表中合同的索引。</p><p>下例显示了生成的存根：</p><pre class="screen">should post a user.json
1_WithList.json</pre><p>如您所见，第一个文件<code class="literal">name</code>合同中的参数。第二个得到合同文件的名称（ <code class="literal">WithList.groovy</code> ）以索引开头（在这种情况下，合同的索引为<code class="literal">1</code>在文件中的合同列表中）。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>如您所见，命名合同会更好，因为这样做会使您的测试更有意义。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_generating_spring_rest_docs_snippets_from_the_contracts" href="#_generating_spring_rest_docs_snippets_from_the_contracts"></a> 94.13从合同中生成Spring REST Docs片段</h2></div></div></div><p>当您想使用Spring REST Docs包含API的请求和响应时，如果您使用的是MockMvc和RestAssuredMockMvc，则只需对设置进行一些小的更改。如果还没有，只需包括以下依赖项。</p><p><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-contract-verifier<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.restdocs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-restdocs-mockmvc<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;optional&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/optional&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>
</p><p><b>摇篮。</b>
</p><pre class="programlisting">testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.cloud:spring-cloud-starter-contract-verifier'</span>
testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'org.springframework.restdocs:spring-restdocs-mockmvc'</span></pre><p>
</p><p>接下来，您需要对基类进行一些更改，例如以下示例。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example.fraud;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.module.mockmvc.RestAssuredMockMvc;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Rule;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.rules.TestName;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.runner.RunWith;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.restdocs.JUnitRestDocumentation;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.web.context.WebApplicationContext;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.documentationConfiguration;

<em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(classes = Application.class)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FraudBaseWithWebAppSetup {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String OUTPUT = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/generated-snippets"</span>;

	<em><span class="hl-annotation" style="color: gray">@Rule</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> JUnitRestDocumentation restDocumentation = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> JUnitRestDocumentation(OUTPUT);

	<em><span class="hl-annotation" style="color: gray">@Rule</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> TestName testName = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TestName();

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> WebApplicationContext context;

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssuredMockMvc.mockMvc(MockMvcBuilders.webAppContextSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.context)
				.apply(documentationConfiguration(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.restDocumentation))
				.alwaysDo(document(
						getClass().getSimpleName() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"_"</span> + testName.getMethodName()))
				.build());
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> assertThatRejectionReasonIsNull(Object rejectionReason) {
		assert rejectionReason == null;
	}

}</pre><p>如果使用的是独立安装程序，则可以这样设置RestAssuredMockMvc：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example.fraud;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> io.restassured.module.mockmvc.RestAssuredMockMvc;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Before;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.Rule;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.junit.rules.TestName;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.restdocs.JUnitRestDocumentation;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.documentationConfiguration;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FraudBaseWithStandaloneSetup {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String OUTPUT = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"target/generated-snippets"</span>;

	<em><span class="hl-annotation" style="color: gray">@Rule</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> JUnitRestDocumentation restDocumentation = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> JUnitRestDocumentation(OUTPUT);

	<em><span class="hl-annotation" style="color: gray">@Rule</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> TestName testName = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> TestName();

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		RestAssuredMockMvc.standaloneSetup(MockMvcBuilders
				.standaloneSetup(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FraudDetectionController())
				.apply(documentationConfiguration(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.restDocumentation))
				.alwaysDo(document(
						getClass().getSimpleName() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"_"</span> + testName.getMethodName())));
	}

}</pre><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>从1.2.0版开始，您无需为生成的代码片段指定输出目录。Spring REST文档的发布。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_customization" href="#_customization"></a> 95。客制化</h2></div></div></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>本部分仅对Groovy DSL有效</p></td></tr></tbody></table></div><p>您可以通过扩展DSL来定制Spring Cloud Contract Verifier，如本节其余部分所示。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_extending_the_dsl" href="#_extending_the_dsl"></a> 95.1扩展DSL</h2></div></div></div><p>您可以为DSL提供自己的功能。此功能的关键要求是保持静态兼容性。在本文档的后面，您可以看到以下示例：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">创建具有可重用类的JAR。</li><li class="listitem">在DSL中引用这些类。</li></ul></div><p>您可以在<a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples" target="_top">此处</a>找到完整的示例。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_common_jar" href="#_common_jar"></a> 95.1.1通用JAR</h3></div></div></div><p>以下示例显示了可以在DSL中重用的三个类。</p><p><span class="strong"><strong>PatternUtils</strong></span>包含<span class="strong"><strong>消费者</strong></span>和<span class="strong"><strong>生产者</strong></span>都使用的函数。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> java.util.regex.Pattern;

<strong class="hl-tag" style="color: blue">/**
 * If you want to use {@link Pattern} directly in your tests
 * then you can create a class resembling this one. It can
 * contain all the {@link Pattern} you want to use in the DSL.
 *
 * &lt;pre&gt;
 * {@code
 * request {
 *     body(
 *         [ age: $(c(PatternUtils.oldEnough()))]
 *     )
 * }
 * &lt;/pre&gt;
 *
 * Notice that we're using both {@code $()} for dynamic values
 * and {@code c()} for the consumer side.
 *
 * @author Marcin Grzejszczak
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//tag::impl[]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> PatternUtils {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> String tooYoung() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-1][0-9]"</span>;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> Pattern oldEnough() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[2-9][0-9]"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}

	<strong class="hl-tag" style="color: blue">/**
	 * Makes little sense but it's just an example ;)
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> Pattern ok() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//end::impl[]</span></pre>
 *
 * Notice that we're using both {@code $()} for dynamic values
 * and {@code c()} for the consumer side.
 *
 * @author Marcin Grzejszczak
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//tag::impl[]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> PatternUtils {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> String tooYoung() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-1][0-9]"</span>;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> Pattern oldEnough() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[2-9][0-9]"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}

	<strong class="hl-tag" style="color: blue">/**
	 * Makes little sense but it's just an example ;)
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> Pattern ok() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Pattern.compile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//end::impl[]</span></pre><p><span class="strong"><strong>ConsumerUtils</strong></span>包含由<span class="strong"><strong>消费者</strong></span>使用的功能。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.internal.ClientDslProperty;

<strong class="hl-tag" style="color: blue">/**
 * DSL Properties passed to the DSL from the consumer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you can have a regular expression.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you have to have a concrete value.
 *
 * @author Marcin Grzejszczak
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//tag::impl[]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ConsumerUtils {
	<strong class="hl-tag" style="color: blue">/**
	 * Consumer side property. By using the {@link ClientDslProperty}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * request {
	 *     body(
	 *         [ age: $(ConsumerUtils.oldEnough())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way it's in the implementation that we decide what value we will pass to the consumer
	 * and which one to the producer.
	 *
	 * @author Marcin Grzejszczak
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> ClientDslProperty oldEnough() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// this example is not the best one and</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// theoretically you could just pass the regex instead of `ServerDslProperty` but</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// it's just to show some new tricks :)</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClientDslProperty(PatternUtils.oldEnough(), <span class="hl-number">40</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}

}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//end::impl[]</span></pre>
	 *
	 * That way it's in the implementation that we decide what value we will pass to the consumer
	 * and which one to the producer.
	 *
	 * @author Marcin Grzejszczak
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> ClientDslProperty oldEnough() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::start[]</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// this example is not the best one and</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// theoretically you could just pass the regex instead of `ServerDslProperty` but</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// it's just to show some new tricks :)</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ClientDslProperty(PatternUtils.oldEnough(), <span class="hl-number">40</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//remove::end[return]</span>
	}

}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//end::impl[]</span></pre><p><span class="strong"><strong>ProducerUtils</strong></span>包含由<span class="strong"><strong>生产者</strong></span>使用的功能。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.internal.ServerDslProperty;

<strong class="hl-tag" style="color: blue">/**
 * DSL Properties passed to the DSL from the producer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you have to have a concrete value.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you can have a regular expression.
 *
 * @author Marcin Grzejszczak
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//tag::impl[]</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ProducerUtils {

	<strong class="hl-tag" style="color: blue">/**
	 * Producer side property. By using the {@link ProducerUtils}
	 * you can omit most of boilerplate code from the perspective
	 * of dynamic values. Example
	 *
	 * &lt;pre&gt;
	 * {@code
	 * response {
	 *     body(
	 *         [ status: $(ProducerUtils.ok())]
	 *     )
	 * }
	 * &lt;/pre&gt;
	 *
	 * That way it's in the implementation that we decide what value we will pass to the consumer
	 * and which one to the producer.
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> ServerDslProperty ok() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// this example is not the best one and</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// theoretically you could just pass the regex instead of `ServerDslProperty` but</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// it's just to show some new tricks :)</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ServerDslProperty( PatternUtils.ok(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>);
	}
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//end::impl[]</span></pre>
	 *
	 * That way it's in the implementation that we decide what value we will pass to the consumer
	 * and which one to the producer.
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> ServerDslProperty ok() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// this example is not the best one and</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// theoretically you could just pass the regex instead of `ServerDslProperty` but</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// it's just to show some new tricks :)</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ServerDslProperty( PatternUtils.ok(), <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"OK"</span>);
	}
}
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//end::impl[]</span></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_adding_the_dependency_to_the_project" href="#_adding_the_dependency_to_the_project"></a> 95.1.2在项目中添加依赖项</h3></div></div></div><p>为了使插件和IDE能够引用常见的JAR类，您需要将依赖项传递给您的项目。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_test_the_dependency_in_the_projects_dependencies" href="#_test_the_dependency_in_the_projects_dependencies"></a> 95.1.3在项目的依存关系中测试依存关系</h3></div></div></div><p>首先，添加公共jar依赖项作为测试依赖项。因为您的合同文件在测试资源路径上可用，所以常见的jar类自动在Groovy文件中可见。以下示例显示如何测试依赖关系：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>beer-common<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${project.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">testCompile(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:beer-common:0.0.1.BUILD-SNAPSHOT"</span>)</pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_test_a_dependency_in_the_plugins_dependencies" href="#_test_a_dependency_in_the_plugins_dependencies"></a> 95.1.4在插件的依赖项中测试依赖项</h3></div></div></div><p>现在，必须添加插件的依赖关系，以便在运行时重用，如以下示例所示：</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;packageWithBaseClasses&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/packageWithBaseClasses&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMappings&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassMapping&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;contractPackageRegex&gt;</span>.*intoxication.*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/contractPackageRegex&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;baseClassFQN&gt;</span>com.example.intoxication.BeerIntoxicationBase<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassFQN&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMapping&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/baseClassMappings&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>com.example<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>beer-common<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${project.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>compile<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"com.example:beer-common:0.0.1.BUILD-SNAPSHOT"</span></pre><p class="secondary">
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_referencing_classes_in_dsls" href="#_referencing_classes_in_dsls"></a> 95.1.5 DSL中的引用类</h3></div></div></div><p>现在，您可以在DSL中引用您的类，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> contracts.beer.rest

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.example.ConsumerUtils
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.example.ProducerUtils
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract

Contract.make {
	description(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"
</span>Represents a successful scenario of getting a beer

```
given:
	client is old enough
when:
	he applies <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> a beer
then:
	we<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'ll grant him the beer
</span>```

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">")
</span>	request {
		method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'POST'</span>
		url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/check'</span>
		body(
				age: $(ConsumerUtils.oldEnough())
		)
		headers {
			contentType(applicationJson())
		}
	}
	response {
		status <span class="hl-number">200</span>
		body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"
</span>			{
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${value(ProducerUtils.ok())}"</span>
			}
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">")
</span>		headers {
			contentType(applicationJson())
		}
	}
}</pre><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>您可以通过设置来设置Spring Cloud Contract插件<code class="literal">convertToYaml</code>至<code class="literal">true</code> 。这样，您将不必将具有扩展功能的依赖项添加到使用方，因为使用方将使用YAML合同而不是Groovy合同。</p></td></tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_using_the_pluggable_architecture" href="#_using_the_pluggable_architecture"></a> 96。使用可插拔架构</h2></div></div></div><p>您可能会遇到用其他格式（例如YAML，RAML或PACT）定义合同的情况。在那些情况下，您仍然想从自动生成测试和存根中受益。您可以添加自己的实现以生成测试和存根。另外，您可以自定义测试的生成方式（例如，可以生成其他语言的测试）和存根的生成方式（例如，可以为其他HTTP服务器实现生成存根）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_custom_contract_converter" href="#_custom_contract_converter"></a> 96.1定制合同转换器</h2></div></div></div><p>的<code class="literal">ContractConverter</code>界面可让您注册自己的合同结构转换器实现。以下代码清单显示了<code class="literal">ContractConverter</code>接口：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.spec

<strong class="hl-tag" style="color: blue">/**
 * Converter to be used to convert FROM {@link File} TO {@link Contract}
 * and from {@link Contract} to {@code T}
 *
 * @param &lt;T &gt;     - type to which we want to convert the contract
 *
 * @author Marcin Grzejszczak
 * @since 1.1.0
 */</strong>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> ContractConverter&lt;T&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> ContractStorer&lt;T&gt; {

	<strong class="hl-tag" style="color: blue">/**
	 * Should this file be accepted by the converter. Can use the file extension
	 * to check if the conversion is possible.
	 *
	 * @param file - file to be considered for conversion
	 * @return - {@code true} if the given implementation can convert the file
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> isAccepted(File file)

	<strong class="hl-tag" style="color: blue">/**
	 * Converts the given {@link File} to its {@link Contract} representation
	 *
	 * @param file - file to convert
	 * @return - {@link Contract} representation of the file
	 */</strong>
	Collection&lt;Contract&gt; convertFrom(File file)

	<strong class="hl-tag" style="color: blue">/**
	 * Converts the given {@link Contract} to a {@link T} representation
	 *
	 * @param contract - the parsed contract
	 * @return - {@link T} the type to which we do the conversion
	 */</strong>
	T convertTo(Collection&lt;Contract&gt; contract)
}</pre><p>您的实现必须定义启动转换的条件。另外，您必须定义如何在两个方向上执行该转换。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>创建实施后，您必须创建一个<code class="literal">/META-INF/spring.factories</code>您在其中提供实施的完全限定名称的文件。</p></td></tr></tbody></table></div><p>以下示例显示了一个典型的<code class="literal">spring.factories</code>文件：</p><pre class="screen">org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.verifier.converter.YamlContractConverter</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pact-converter" href="#pact-converter"></a> 96.1.1 Pact转换器</h3></div></div></div><p>Spring Cloud Contract包括对第4版之前的<a class="link" href="https://docs.pact.io/" target="_top">Pact</a>合同表示的支持。代替使用Groovy DSL，可以使用Pact文件。在本节中，我们介绍如何为您的项目添加Pact支持。但是请注意，并非所有功能都受支持。从v3开始，您可以为同一个元素组合多个匹配器。您可以将匹配器用于正文，标头，请求和路径；您可以使用价值生成器。Spring Cloud Contract当前仅支持使用AND规则逻辑组合的多个匹配器。除此之外，在转换过程中将跳过请求和路径匹配器。当使用具有给定格式的日期，时间或日期时间值生成器时，将跳过给定格式并使用ISO格式。</p><p>为了正确地支持使用Pact进行消息传递的Spring Cloud Contract方法，您必须提供一些其他元数据条目。您可以在下面找到此类条目的列表：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">要定义发送消息的目的地，您必须设置一个<code class="literal">metaData</code>使用密钥在Pact文件中输入<code class="literal">sentTo</code>等于要向其发送消息的目的地。例如<code class="literal">"metaData": { "sentTo": "activemq:output" }</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pact_contract" href="#_pact_contract"></a> 96.1.2契约合同</h3></div></div></div><p>考虑以下契约合同示例，该合同是<code class="literal">src/test/resources/contracts</code>夹。</p><pre class="programlisting">{
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"provider"</span>: {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Provider"</span>
  },
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"consumer"</span>: {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Consumer"</span>
  },
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"interactions"</span>: [
    {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"description"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span>,
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span>: {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"PUT"</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"path"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json"</span>
        },
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"clientId"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"1234567890"</span>,
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"loanAmount"</span>: <span class="hl-number">99999</span>
        },
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"generators"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span>: {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.clientId"</span>: {
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Regex"</span>,
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{10}"</span>
            }
          }
        },
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchingRules"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"header"</span>: {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>: {
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchers"</span>: [
                {
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"match"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>,
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd\\.fraud\\.v1\\+json.*"</span>
                }
              ],
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"combine"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"AND"</span>
            }
          },
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span>: {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.clientId"</span>: {
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchers"</span>: [
                {
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"match"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>,
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[0-9]{10}"</span>
                }
              ],
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"combine"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"AND"</span>
            }
          }
        }
      },
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span>: {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span>: <span class="hl-number">200</span>,
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json;charset=UTF-8"</span>
        },
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fraudCheckStatus"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>,
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"rejectionReason"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>
        },
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchingRules"</span>: {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"header"</span>: {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>: {
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchers"</span>: [
                {
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"match"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>,
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd\\.fraud\\.v1\\+json.*"</span>
                }
              ],
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"combine"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"AND"</span>
            }
          },
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span>: {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.fraudCheckStatus"</span>: {
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchers"</span>: [
                {
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"match"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>,
                  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"regex"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>
                }
              ],
              <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"combine"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"AND"</span>
            }
          }
        }
      }
    }
  ],
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"metadata"</span>: {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"pact-specification"</span>: {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"version"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"3.0.0"</span>
    },
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"pact-jvm"</span>: {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"version"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"3.5.13"</span>
    }
  }
}</pre><p>关于使用Pact的本节的其余部分将参考前面的文件。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pact_for_producers" href="#_pact_for_producers"></a> 96.1.3生产者公约</h3></div></div></div><p>在生产者端，您必须在插件配置中添加两个其他依赖项。一个是Spring Cloud Contract Pact支持，另一个是您使用的当前Pact版本。</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;extensions&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/extensions&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;packageWithBaseClasses&gt;</span>com.example.fraud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/packageWithBaseClasses&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-pact<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${spring-cloud-contract.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">classpath <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-pact:${findProperty('verifierVersion') ?: verifierVersion}"</span></pre><p class="secondary">
</p><p>当您执行应用程序的构建时，将生成一个测试。生成的测试可能如下：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> validate_shouldMarkClientAsFraud() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// given:</span>
		MockMvcRequestSpecification request = given()
				.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json"</span>)
				.body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"clientId\":\"1234567890\",\"loanAmount\":99999}"</span>);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// when:</span>
		ResponseOptions response = given().spec(request)
				.put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then:</span>
		assertThat(response.statusCode()).isEqualTo(<span class="hl-number">200</span>);
		assertThat(response.header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd\\.fraud\\.v1\\+json.*"</span>);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
		DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
		assertThatJson(parsedJson).field(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"['rejectionReason']"</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Amount too high"</span>);
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// and:</span>
		assertThat(parsedJson.read(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.fraudCheckStatus"</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)).matches(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FRAUD"</span>);
}</pre><p>相应的生成的存根可能如下：</p><pre class="programlisting">{
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"996ae5ae-6834-4db6-8fac-358ca187ab62"</span>,
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uuid"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"996ae5ae-6834-4db6-8fac-358ca187ab62"</span>,
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/fraudcheck"</span>,
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"PUT"</span>,
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matches"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd\\.fraud\\.v1\\+json.*"</span>
      }
    },
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bodyPatterns"</span> : [ {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.['loanAmount'] == 99999)]"</span>
    }, {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.clientId =~ /([0-9]{10})/)]"</span>
    } ]
  },
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">200</span>,
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"fraudCheckStatus\":\"FRAUD\",\"rejectionReason\":\"Amount too high\"}"</span>,
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/vnd.fraud.v1+json;charset=UTF-8"</span>
    },
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transformers"</span> : [ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response-template"</span> ]
  },
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pact_for_consumers" href="#_pact_for_consumers"></a> 96.1.4消费者契约</h3></div></div></div><p>在使用者方面，您必须在项目依赖项中添加两个其他依赖项。一个是Spring Cloud Contract Pact支持，另一个是您使用的当前Pact版本。</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-contract-pact<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">testCompile <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"org.springframework.cloud:spring-cloud-contract-pact"</span></pre><p class="secondary">
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_custom_test_generator" href="#_using_the_custom_test_generator"></a> 96.2使用自定义测试生成器</h2></div></div></div><p>如果要针对Java以外的语言生成测试，或者对验证程序构建Java测试的方式不满意，则可以注册自己的实现。</p><p>的<code class="literal">SingleTestGenerator</code>介面可让您注册自己的实作。以下代码清单显示了<code class="literal">SingleTestGenerator</code>接口：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.verifier.builder


<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.verifier.config.ContractVerifierConfigProperties
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.verifier.file.ContractMetadata

<strong class="hl-tag" style="color: blue">/**
 * Builds a single test.
 *
 * @since 1.1.0
 */</strong>
trait SingleTestGenerator {

	<strong class="hl-tag" style="color: blue">/**
	 * Creates contents of a single test class in which all test scenarios from
	 * the contract metadata should be placed.
	 *
	 * @param properties - properties passed to the plugin
	 * @param listOfFiles - list of parsed contracts with additional metadata
	 * @param className - the name of the generated test class
	 * @param classPackage - the name of the package in which the test class should be stored
	 * @param includedDirectoryRelativePath - relative path to the included directory
	 * @return contents of a single test class
	 * @deprecated use{@link SingleTestGenerator#buildClass(ContractVerifierConfigProperties, Collection, String, GeneratedClassData)}
	 */</strong>
	<em><span class="hl-annotation" style="color: gray">@Deprecated</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> String buildClass(ContractVerifierConfigProperties properties,
			Collection&lt;ContractMetadata&gt; listOfFiles, String className, String classPackage, String includedDirectoryRelativePath)

	<strong class="hl-tag" style="color: blue">/**
	 * Creates contents of a single test class in which all test scenarios from
	 * the contract metadata should be placed.
	 *
	 * @param properties - properties passed to the plugin
	 * @param listOfFiles - list of parsed contracts with additional metadata
	 * @param generatedClassData - information about the generated class
	 * @param includedDirectoryRelativePath - relative path to the included directory
	 * @return contents of a single test class
	 */</strong>
	String buildClass(ContractVerifierConfigProperties properties,
			Collection&lt;ContractMetadata&gt; listOfFiles, String includedDirectoryRelativePath, GeneratedClassData generatedClassData) {
		String className = generatedClassData.className
		String classPackage = generatedClassData.classPackage
		String path = includedDirectoryRelativePath
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> buildClass(properties, listOfFiles, className, classPackage, path)
	}

	<strong class="hl-tag" style="color: blue">/**
	 * Extension that should be appended to the generated test class. E.g. {@code .java} or {@code .php}
	 *
	 * @param properties - properties passed to the plugin
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">abstract</span> String fileExtension(ContractVerifierConfigProperties properties)

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GeneratedClassData {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String className
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> String classPackage
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> java.nio.file.Path testClassPath

		GeneratedClassData(String className, String classPackage,
				java.nio.file.Path testClassPath) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.className = className
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.classPackage = classPackage
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.testClassPath = testClassPath
		}
	}
}</pre><p>同样，您必须提供一个<code class="literal">spring.factories</code>文件，如以下示例中所示：</p><pre class="screen">org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_custom_stub_generator" href="#_using_the_custom_stub_generator"></a> 96.3使用自定义存根生成器</h2></div></div></div><p>如果要为WireMock以外的存根服务器生成存根，则可以插入自己的<code class="literal">StubGenerator</code>接口。以下代码清单显示了<code class="literal">StubGenerator</code>接口：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.verifier.converter

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> groovy.transform.CompileStatic

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.verifier.file.ContractMetadata

<strong class="hl-tag" style="color: blue">/**
 * Converts contracts into their stub representation.
 *
 * @since 1.1.0
 */</strong>
<em><span class="hl-annotation" style="color: gray">@CompileStatic</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> StubGenerator {

	<strong class="hl-tag" style="color: blue">/**
	 * @return {@code true} if the converter can handle the file to convert it into a stub.
	 */</strong>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> canHandleFileName(String fileName)

	<strong class="hl-tag" style="color: blue">/**
	 * @return the collection of converted contracts into stubs. One contract can
	 * result in multiple stubs.
	 */</strong>
	Map&lt;Contract, String&gt; convertContents(String rootName, ContractMetadata content)

	<strong class="hl-tag" style="color: blue">/**
	 * @return the name of the converted stub file. If you have multiple contracts
	 * in a single file then a prefix will be added to the generated file. If you
	 * provide the {@link Contract#name} field then that field will override the
	 * generated file name.
	 *
	 * Example: name of file with 2 contracts is {@code foo.groovy}, it will be
	 * converted by the implementation to {@code foo.json}. The recursive file
	 * converter will create two files {@code 0_foo.json} and {@code 1_foo.json}
	 */</strong>
	String generateOutputFileNameForInput(String inputFileName)
}</pre><p>同样，您必须提供一个<code class="literal">spring.factories</code>文件，如以下示例中所示：</p><pre class="screen"># Stub converters
org.springframework.cloud.contract.verifier.converter.StubGenerator=\
org.springframework.cloud.contract.verifier.wiremock.DslToWireMockClientConverter</pre><p>默认实现是WireMock存根生成。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>您可以提供多个存根生成器实现。例如，从单个DSL，您可以同时生成WireMock存根和Pact文件。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_custom_stub_runner" href="#_using_the_custom_stub_runner"></a> 96.4使用自定义存根运行器</h2></div></div></div><p>如果决定使用自定义存根生成，则还需要使用自定义方式与其他存根提供程序一起运行存根。</p><p>假设您使用<a class="link" href="https://github.com/dreamhead/moco" target="_top">Moco</a>来构建存根，并且已经编写了存根生成器并将存根放置在JAR文件中。</p><p>为了使Stub Runner知道如何运行您的存根，您必须定义一个自定义HTTP Stub服务器实现，该实现可能类似于以下示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> org.springframework.cloud.contract.stubrunner.provider.moco

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.github.dreamhead.moco.bootstrap.arg.HttpArgs
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.github.dreamhead.moco.runner.JsonRunner
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> com.github.dreamhead.moco.runner.RunnerSetting
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> groovy.util.logging.Commons

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.stubrunner.HttpServerStub
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.util.SocketUtils

<em><span class="hl-annotation" style="color: gray">@Commons</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MocoHttpServerStub <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> HttpServerStub {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> started
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> JsonRunner runner
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> port

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> port() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (!isRunning()) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> -<span class="hl-number">1</span>
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> port
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> isRunning() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> started
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	HttpServerStub start() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> start(SocketUtils.findAvailableTcpPort())
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	HttpServerStub start(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> port) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.port = port
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	HttpServerStub stop() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span> (!isRunning()) {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>
		}
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.runner.stop()
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	HttpServerStub registerMappings(Collection&lt;File&gt; stubFiles) {
		List&lt;RunnerSetting&gt; settings = stubFiles.findAll { it.name.endsWith(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"json"</span>) }
			.collect {
			log.info(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Trying to parse [${it.name}]"</span>)
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> {
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> RunnerSetting.aRunnerSetting().withStream(it.newInputStream()).
					build()
			}
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">catch</span> (Exception e) {
				log.warn(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Exception occurred while trying to parse file [${it.name}]"</span>, e)
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> null
			}
		}.findAll { it }
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.runner = JsonRunner.newJsonRunnerWithSetting(settings,
			HttpArgs.httpArgs().withPort(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.port).build())
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.runner.run()
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.started = true
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	String registeredMappings() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">""</span>
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> isAccepted(File file) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> file.name.endsWith(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">".json"</span>)
	}
}</pre><p>然后，您可以将其注册到<code class="literal">spring.factories</code>文件，如以下示例所示：</p><pre class="screen">org.springframework.cloud.contract.stubrunner.HttpServerStub=\
org.springframework.cloud.contract.stubrunner.provider.moco.MocoHttpServerStub</pre><p>现在，您可以使用Moco运行存根。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果不提供任何实现，则使用默认（WireMock）实现。如果提供多个，则使用列表中的第一个。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_the_custom_stub_downloader" href="#_using_the_custom_stub_downloader"></a> 96.5使用自定义存根下载器</h2></div></div></div><p>您可以通过创建以下代码的实现来自定义存根的下载方式<code class="literal">StubDownloaderBuilder</code>界面，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">package</span> com.example;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomStubDownloaderBuilder <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> StubDownloaderBuilder {

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> StubDownloader build(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> StubRunnerOptions stubRunnerOptions) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubDownloader() {
			<em><span class="hl-annotation" style="color: gray">@Override</span></em>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Map.Entry&lt;StubConfiguration, File&gt; downloadAndUnpackStubJar(
					StubConfiguration config) {
				File unpackedStubs = retrieveStubs();
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(
						<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> StubConfiguration(config.getGroupId(), config.getArtifactId(), version,
								config.getClassifier()), unpackedStubs);
			}

			File retrieveStubs() {
			    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// here goes your custom logic to provide a folder where all the stubs reside</span>
			}
}</pre><p>然后你可以在你的<code class="literal">spring.factories</code>文件，如以下示例所示：</p><pre class="screen"># Example of a custom Stub Downloader Provider
org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder=\
com.example.CustomStubDownloaderBuilder</pre><p>现在，您可以选择包含存根源的文件夹。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果不提供任何实现，则使用默认设置（扫描类路径）。如果您提供<code class="literal">stubsMode = StubRunnerProperties.StubsMode.LOCAL</code>要么<code class="literal">, stubsMode = StubRunnerProperties.StubsMode.REMOTE</code>那么将使用Aether实施。如果您提供多个，则将使用列表中的第一个。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="scm-stub-downloader" href="#scm-stub-downloader"></a> 96.6使用SCM存根下载器</h2></div></div></div><p>每当<code class="literal">repositoryRoot</code>从SCM协议开始（当前我们仅支持<code class="literal">git://</code> ），存根下载器将尝试克隆存储库，并将其用作生成测试或存根的合同来源。</p><p>通过环境变量，系统属性，插件内部设置的属性或合同存储库配置，您可以调整下载程序的行为。您可以在下面找到属性列表</p><div class="table"><a name="d0e29215" href="#d0e29215"></a><p class="title"><b>表96.1SCM存根下载器属性</b></p><div class="table-contents"><table class="table" summary="SCM Stub Downloader properties" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>物业类型</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>物业名称</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>描述</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">git.branch</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.git.branch</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_GIT_BRANCH</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>主</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>结帐哪个分支</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">git.username</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.git.username</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_GIT_USERNAME</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Git克隆用户名</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">git.password</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.git.password</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_GIT_PASSWORD</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Git克隆密码</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">git.no-of-attempts</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.git.no-of-attempts</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_GIT_NO_OF_ATTEMPTS</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>将提交推送到的尝试次数<code class="literal">origin</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>* <code class="literal">git.wait-between-attempts</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.git.wait-between-attempts</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_GIT_WAIT_BETWEEN_ATTEMPTS</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid"><p>1000</p></td><td align="left" valign="top"><p>两次尝试将提交推送到之间要等待的毫秒数<code class="literal">origin</code></p></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="pact-stub-downloader" href="#pact-stub-downloader"></a> 96.7使用契约存根下载器</h2></div></div></div><p>每当<code class="literal">repositoryRoot</code>以Pact协议开头（以<code class="literal">pact://</code> ），存根下载器将尝试从Pact Broker中获取Pact合同定义。以后设置什么<code class="literal">pact://</code>将被解析为Pact Broker URL。</p><p>通过环境变量，系统属性，插件内部设置的属性或合同存储库配置，您可以调整下载程序的行为。您可以在下面找到属性列表</p><div class="table"><a name="d0e29364" href="#d0e29364"></a><p class="title"><b>表96.2。SCM存根下载器属性</b></p><div class="table-contents"><table class="table" summary="SCM Stub Downloader properties" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>物业名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>默认</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>描述</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.host</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.host</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_HOST</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>主机从URL传递到<code class="literal">repositoryRoot</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Pact Broker的URL是什么</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.port</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.port</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_PORT</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>URL的端口传递到<code class="literal">repositoryRoot</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Pact Broker的端口是什么</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.protocol</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.protocol</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_PROTOCOL</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>URL的协议传递给<code class="literal">repositoryRoot</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Pact Broker的协议是什么</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.tags</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.tags</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_TAGS</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>存根的版本，或<code class="literal">latest</code>如果版本是<code class="literal">+</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该使用什么标签来获取存根</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.auth.scheme</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.auth.scheme</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_AUTH_SCHEME</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Basic</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该使用哪种身份验证来连接到Pact Broker</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.auth.username</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.auth.username</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_AUTH_USERNAME</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用户名传递给<code class="literal">contractsRepositoryUsername</code> （专家）或<code class="literal">contractRepository.username</code> （等级）</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于连接到Pact Broker的用户名</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>* <code class="literal">pactbroker.auth.password</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.auth.password</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_AUTH_PASSWORD</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>密码传递给<code class="literal">contractsRepositoryPassword</code> （专家）或<code class="literal">contractRepository.password</code> （等级）</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于连接Pact Broker的密码</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>* <code class="literal">pactbroker.provider-name-with-group-id</code> （插件道具）</p><p>* <code class="literal">stubrunner.properties.pactbroker.provider-name-with-group-id</code> （系统道具）</p><p>* <code class="literal">STUBRUNNER_PROPERTIES_PACTBROKER_PROVIDER_NAME_WITH_GROUP_ID</code> （环境道具）</p></td><td align="left" valign="top" style="border-right:1px solid"><p>假</p></td><td align="left" valign="top"><p>什么时候<code class="literal">true</code> ，提供者名称将是<code class="literal">groupId:artifactId</code> 。如果<code class="literal">false</code> ，只是<code class="literal">artifactId</code>用来</p></td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_contract_wiremock" href="#_spring_cloud_contract_wiremock"></a> 97。Spring Cloud Contract WireMock</h2></div></div></div><p>Spring Cloud Contract WireMock模块使您可以在Spring Boot应用程序中使用<a class="link" href="https://github.com/tomakehurst/wiremock" target="_top">WireMock</a> 。查看<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/tree/2.1.x/samples" target="_top">样本</a>以获取更多详细信息。</p><p>如果您有一个使用Tomcat作为嵌入式服务器的Spring Boot应用程序（默认情况下是<code class="literal">spring-boot-starter-web</code> ）， 你可以加<code class="literal">spring-cloud-starter-contract-stub-runner</code>到您的类路径并添加<code class="literal">@AutoConfigureWireMock</code>为了能够在您的测试中使用Wiremock。Wiremock作为存根服务器运行，您可以在测试中使用Java API或通过静态JSON声明来注册存根行为。以下代码显示了一个示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureWireMock(port = 0)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> WiremockForDocsTests {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// A service that calls out over HTTP</span>
	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Service service;

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.service.setBase(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:"</span>
				+ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.environment.getProperty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"wiremock.server.port"</span>));
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Using the WireMock APIs in the normal way:</span>
	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Stubbing WireMock</span>
		stubFor(get(urlEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>)).willReturn(aResponse()
				.withHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"text/plain"</span>).withBody(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World!"</span>)));
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// We're asserting if WireMock responded properly</span>
		assertThat(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.service.go()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World!"</span>);
	}

}</pre><p>要在其他端口上启动存根服务器，请使用（例如）， <code class="literal">@AutoConfigureWireMock(port=9999)</code> 。对于随机端口，请使用值<code class="literal">0</code> 。可以在测试应用程序上下文中通过“ wiremock.server.port”属性绑定存根服务器端口。使用<code class="literal">@AutoConfigureWireMock</code>添加一个类型的bean <code class="literal">WiremockConfiguration</code>到您的测试应用程序上下文中，它将被缓存在具有相同上下文的方法和类之间，这与Spring集成测试相同。你也可以注入一个类型的bean <code class="literal">WireMockServer</code>进入您的测试。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_registering_stubs_automatically" href="#_registering_stubs_automatically"></a> 97.1自动注册存根</h2></div></div></div><p>如果您使用<code class="literal">@AutoConfigureWireMock</code> ，它会从文件系统或类路径中注册WireMock JSON存根（默认情况下，从<code class="literal">file:src/test/resources/mappings</code> ）。您可以使用<code class="literal">stubs</code>批注中的属性，它可以是Ant样式的资源模式或目录。如果是目录， <code class="literal"><span class="strong"><strong>*/</strong></span>.json</code>附加。以下代码显示了一个示例：</p><pre class="screen">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWireMock(stubs="classpath:/stubs")
public class WiremockImportApplicationTests {

	@Autowired
	private Service service;

	@Test
	public void contextLoads() throws Exception {
		assertThat(this.service.go()).isEqualTo("Hello World!");
	}

}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>实际上，WireMock总是从<code class="literal">src/test/resources/mappings</code> <span class="strong"><strong>以及</strong></span> stubs属性中的自定义位置。要更改此行为，您还可以指定根文件，如本文档下一节所述。</p></td></tr></tbody></table></div><p>如果您使用的是Spring Cloud Contract的默认存根罐，则您的存根将存储在<code class="literal">/META-INF/group-id/artifact-id/versions/mappings/</code>夹。如果要从该位置，所有嵌入式JAR中注册所有存根，那么使用以下语法就足够了。</p><pre class="programlisting">@AutoConfigureWireMock(port = <span class="hl-number">0</span>, stubs = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"classpath*:/META-INF/**/mappings/**/*.json"</span>)</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_using_files_to_specify_the_stub_bodies" href="#_using_files_to_specify_the_stub_bodies"></a> 97.2使用文件指定存根实体</h2></div></div></div><p>WireMock可以从类路径或文件系统上的文件中读取响应正文。在这种情况下，您可以在JSON DSL中看到响应中包含一个<code class="literal">bodyFileName</code>而不是（文字） <code class="literal">body</code> 。相对于根目录解析文件（默认情况下， <code class="literal">src/test/resources/__files</code> ）。要自定义此位置，您可以设置<code class="literal">files</code>中的属性<code class="literal">@AutoConfigureWireMock</code>父目录位置的注释（换句话说， <code class="literal">__files</code>是一个子目录）。您可以使用Spring资源表示法来引用<code class="literal">file:…​</code>要么<code class="literal">classpath:…​</code>位置。不支持通用网址。可以给出一个值列表，在这种情况下，WireMock会在需要查找响应正文时解析存在的第一个文件。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>当您配置<code class="literal">files</code>根，它也会影响存根的自动加载，因为它们来自子目录“映射”中的根位置。的价值<code class="literal">files</code>对从显式加载的存根没有影响<code class="literal">stubs</code>属性。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_alternative_using_junit_rules" href="#_alternative_using_junit_rules"></a> 97.3替代：使用JUnit规则</h2></div></div></div><p>要获得更常规的WireMock体验，可以使用JUnit <code class="literal">@Rules</code>启动和停止服务器。为此，请使用<code class="literal">WireMockSpring</code>便利班获得<code class="literal">Options</code>实例，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> WiremockForDocsClassRuleTests {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Start WireMock on some dynamic port</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// for some reason `dynamicPort()` is not working properly</span>
	<em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> WireMockClassRule wiremock = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> WireMockClassRule(
			WireMockSpring.options().dynamicPort());

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// A service that calls out over HTTP to wiremock's port</span>
	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Service service;

	<em><span class="hl-annotation" style="color: gray">@Before</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setup() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.service.setBase(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://localhost:"</span> + wiremock.port());
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Using the WireMock APIs in the normal way:</span>
	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Stubbing WireMock</span>
		wiremock.stubFor(get(urlEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>)).willReturn(aResponse()
				.withHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"text/plain"</span>).withBody(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World!"</span>)));
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// We're asserting if WireMock responded properly</span>
		assertThat(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.service.go()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World!"</span>);
	}

}</pre><p>的<code class="literal">@ClassRule</code>表示在运行了此类中的所有方法之后，服务器将关闭。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_relaxed_ssl_validation_for_rest_template" href="#_relaxed_ssl_validation_for_rest_template"></a> 97.4轻松SSL验证其余模板</h2></div></div></div><p>WireMock允许您使用“ https” URL协议对“安全”服务器进行存根。如果您的应用程序希望在集成测试中联系该存根服务器，它将发现SSL证书无效（自安装证书的常见问题）。最好的选择通常是将客户端重新配置为使用“ http”。如果这不是一个选择，则可以要求Spring配置忽略SSL验证错误的HTTP客户端（当然，仅对测试而言如此）。</p><p>为了以最小的麻烦工作，您需要使用Spring Boot <code class="literal">RestTemplateBuilder</code>在您的应用中，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RestTemplate restTemplate(RestTemplateBuilder builder) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> builder.build();
}</pre><p>你需要<code class="literal">RestTemplateBuilder</code>因为构建器是通过回调传递来初始化的，所以此时可以在客户端中设置SSL验证。如果您使用的是<code class="literal">@AutoConfigureWireMock</code>注释或存根运行器。如果您使用JUnit <code class="literal">@Rule</code>方法，您需要添加<code class="literal">@AutoConfigureHttpClient</code>注释，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest("app.baseUrl=https://localhost:6443")</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureHttpClient</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> WiremockHttpsServerApplicationTests {

	<em><span class="hl-annotation" style="color: gray">@ClassRule</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> WireMockClassRule wiremock = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> WireMockClassRule(
			WireMockSpring.options().httpsPort(<span class="hl-number">6443</span>));
...
}</pre><p>如果您正在使用<code class="literal">spring-boot-starter-test</code> ，您的类路径上有Apache HTTP客户端，并且由<code class="literal">RestTemplateBuilder</code>并配置为忽略SSL错误。如果使用默认<code class="literal">java.net</code>客户端，则不需要注释（但不会造成任何伤害）。当前不支持其他客户端，但可能会在将来的版本中添加。</p><p>禁用自定义<code class="literal">RestTemplateBuilder</code> ，将<code class="literal">wiremock.rest-template-ssl-enabled</code>财产<code class="literal">false</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_wiremock_and_spring_mvc_mocks" href="#_wiremock_and_spring_mvc_mocks"></a> 97.5 WireMock和Spring MVC模拟</h2></div></div></div><p>Spring Cloud Contract提供了一个便利类，可以将JSON WireMock存根加载到Spring中<code class="literal">MockRestServiceServer</code> 。以下代码显示了一个示例：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest(webEnvironment = WebEnvironment.NONE)</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> WiremockForDocsMockServerApplicationTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> RestTemplate restTemplate;

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Service service;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// will read stubs classpath</span>
		MockRestServiceServer server = WireMockRestServiceServer.with(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.restTemplate)
				.baseUrl(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://example.org"</span>).stubs(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"classpath:/stubs/resource.json"</span>)
				.build();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// We're asserting if WireMock responded properly</span>
		assertThat(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.service.go()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>);
		server.verify();
	}

}</pre><p>的<code class="literal">baseUrl</code>值将附加到所有模拟调用中，并且<code class="literal">stubs()</code>方法将存根路径资源模式作为参数。在前面的示例中，存根定义为<code class="literal">/stubs/resource.json</code>被加载到模拟服务器中。如果<code class="literal">RestTemplate</code>被要求参观<code class="literal"><a class="link" href="https://example.org/" target="_top">https://example.org/</a></code> ，它将获得在该URL处声明的响应。可以指定多个存根模式，每个存根模式都可以是目录（用于所有“ .json”的递归列表），固定文件名（如上例所示）或Ant样式的模式。JSON格式是标准的WireMock格式，您可以在<a class="link" href="https://wiremock.org/docs/stubbing/" target="_top">WireMock网站上</a>阅读该<a class="link" href="https://wiremock.org/docs/stubbing/" target="_top">格式</a> 。</p><p>当前，Spring Cloud Contract Verifier支持将Tomcat，Jetty和Undertow用作Spring Boot嵌入式服务器，而Wiremock本身对特定版本的Jetty（当前为9.2）具有“本机”支持。要使用本地Jetty，您需要添加本地Wiremock依赖项，并排除Spring Boot容器（如果有）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_customization_of_wiremock_configuration" href="#_customization_of_wiremock_configuration"></a> 97.6自定义WireMock配置</h2></div></div></div><p>您可以注册一个<code class="literal">org.springframework.cloud.contract.wiremock.WireMockConfigurationCustomizer</code>键入以自定义WireMock配置（例如，添加自定义转换器）。例：</p><pre class="programlisting">		<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
		WireMockConfigurationCustomizer optionsCustomizer() {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> WireMockConfigurationCustomizer() {
				<em><span class="hl-annotation" style="color: gray">@Override</span></em>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> customize(WireMockConfiguration options) {
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// perform your customization here</span>
				}
			};
		}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_generating_stubs_using_rest_docs" href="#_generating_stubs_using_rest_docs"></a> 97.7使用REST文档生成存根</h2></div></div></div><p><a class="link" href="https://projects.spring.io/spring-restdocs" target="_top">Spring REST Docs</a>可用于使用Spring MockMvc或HTTP API为HTTP API生成文档（例如，Asciidoctor格式）。 <code class="literal">WebTestClient</code>或放心。在为API生成文档的同时，还可以使用Spring Cloud Contract WireMock生成WireMock存根。为此，请编写常规的REST Docs测试用例并使用<code class="literal">@AutoConfigureRestDocs</code>在REST Docs输出目录中自动生成存根。以下代码显示了一个使用示例<code class="literal">MockMvc</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureRestDocs(outputDir = "target/snippets")</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureMockMvc</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ApplicationTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MockMvc mockMvc;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		mockMvc.perform(get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>))
				.andExpect(content().string(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>))
				.andDo(document(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"resource"</span>));
	}
}</pre><p>此测试在“ target / snippets / stubs / resource.json”处生成WireMock存根。它将所有GET请求与“ / resource”路径匹配。同一个例子<code class="literal">WebTestClient</code> （用于测试Spring WebFlux应用程序）如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureRestDocs(outputDir = "target/snippets")</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureWebTestClient</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ApplicationTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> WebTestClient client;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		client.get().uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>).exchange()
				.expectBody(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span>)
 				.consumeWith(document(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"resource"</span>));
	}
}</pre><p>在没有任何其他配置的情况下，这些测试将创建一个带有HTTP方法的请求匹配器和所有标头（“主机”和“内容长度”除外）的存根。为了更精确地匹配请求（例如，匹配POST或PUT的正文），我们需要显式创建一个请求匹配器。这样做有两个效果：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">创建仅以您指定的方式匹配的存根。</li><li class="listitem">断言测试用例中的请求也匹配相同的条件。</li></ul></div><p>此功能的主要入口点是<code class="literal">WireMockRestDocs.verify()</code> ，可以代替<code class="literal">document()</code>便捷方法，如以下示例所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> org.springframework.cloud.contract.wiremock.restdocs.WireMockRestDocs.verify;</pre><pre class="screen">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

	@Autowired
	private MockMvc mockMvc;

	@Test
	public void contextLoads() throws Exception {
		mockMvc.perform(post("/resource")
                .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
				.andExpect(status().isOk())
				.andDo(verify().jsonPath("$.id"))
                .andDo(document("resource"));
	}
}</pre><p>该合同规定，任何带有“ id”字段的有效POST都会收到此测试中定义的响应。您可以将呼叫链接到<code class="literal">.jsonPath()</code>添加其他匹配器。如果不熟悉JSON Path， <a class="link" href="https://github.com/jayway/JsonPath" target="_top">JayWay文档</a>可以帮助您快速<a class="link" href="https://github.com/jayway/JsonPath" target="_top">入门</a> 。的<code class="literal">WebTestClient</code>此测试的版本具有相似的<code class="literal">verify()</code>您在同一位置插入的静态帮助器。</p><p>而不是<code class="literal">jsonPath</code>和<code class="literal">contentType</code>便捷方法，您还可以使用WireMock API验证请求是否与创建的存根匹配，如以下示例所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> contextLoads() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
	mockMvc.perform(post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>)
               .content(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"id\":\"123456\",\"message\":\"Hello World\"}"</span>))
			.andExpect(status().isOk())
			.andDo(verify()
					.wiremock(WireMock.post(
						urlPathEquals(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span>))
						.withRequestBody(matchingJsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.id"</span>)))
                       .andDo(document(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"post-resource"</span>));
}</pre><p>WireMock API丰富。您可以通过正则表达式以及JSON路径匹配标头，查询参数和请求正文。这些功能可用于创建具有更广泛参数范围的存根。上面的示例生成一个类似于以下示例的存根：</p><p><b>post-resource.json。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"request"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"url"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/resource"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"method"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"POST"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bodyPatterns"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"matchesJsonPath"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$.id"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}]</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">},</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"response"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"status"</span> : <span class="hl-number">200</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"body"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"headers"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"X-Application-Context"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application:-1"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Content-Type"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"text/plain"</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您可以使用<code class="literal">wiremock()</code>方法或<code class="literal">jsonPath()</code>和<code class="literal">contentType()</code>创建请求匹配器的方法，但是您不能同时使用这两种方法。</p></td></tr></tbody></table></div><p>在使用者方面，您可以使本节前面生成的<code class="literal">resource.json</code>在类路径上可用（例如，通过&lt;&lt;publishing-stubs-as-jars],。之后，可以使用WireMock以多种不同方式创建存根，包括使用<code class="literal">@AutoConfigureWireMock(stubs="classpath:resource.json")</code> ，如本文档前面所述。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_generating_contracts_by_using_rest_docs" href="#_generating_contracts_by_using_rest_docs"></a> 97.8使用REST文档生成合同</h2></div></div></div><p>您还可以使用Spring REST Docs生成Spring Cloud Contract DSL文件和文档。如果与Spring Cloud WireMock结合使用，则会同时获得合同和存根。</p><p>您为什么要使用此功能？社区中的一些人询问有关他们希望转向基于DSL的合同定义的情况的问题，但是他们已经进行了许多Spring MVC测试。使用此功能，您可以生成合同文件，以后可以修改合同文件并将其移至文件夹（在配置中定义），以便插件找到它们。</p><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>您可能想知道为什么WireMock模块中有此功能。之所以具有此功能是因为生成合同和存根都是有意义的。</p></td></tr></tbody></table></div><p>考虑以下测试：</p><pre class="programlisting">		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.mockMvc
				.perform(post(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foo"</span>).accept(MediaType.APPLICATION_PDF)
						.accept(MediaType.APPLICATION_JSON)
						.contentType(MediaType.APPLICATION_JSON)
						.content(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"{\"foo\": 23, \"bar\" : \"baz\" }"</span>))
				.andExpect(status().isOk()).andExpect(content().string(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"bar"</span>))
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// first WireMock</span>
				.andDo(WireMockRestDocs.verify().jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.foo &gt;= 20)]"</span>)
						.jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"$[?(@.bar in ['baz','bazz','bazzz'])]"</span>)
						.contentType(MediaType.valueOf(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"application/json"</span>)))
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// then Contract DSL documentation</span>
				.andDo(document(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"index"</span>, SpringCloudContractRestDocs.dslContract()));</pre><p>前面的测试将创建上一部分中介绍的存根，同时生成合同和文档文件。</p><p>合同叫做<code class="literal">index.groovy</code>可能类似于以下示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'POST'</span>
        url <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/foo'</span>
        body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span>            {<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>: <span class="hl-number">23</span> }
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">')
</span>        headers {
            header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Accept'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
            header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
        }
    }
    response {
        status OK()
        body(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'
</span>        bar
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">')
</span>        headers {
            header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'application/json;charset=UTF-8'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
            header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Length'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'3'</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>)
        }
        testMatchers {
            jsonPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'$[?(@.foo &gt;= 20)]'</span>, byType())
        }
    }
}</pre><p>生成的文档（在这种情况下为Asciidoc格式）包含格式化的合同。该文件的位置是<code class="literal">index/dsl-contract.adoc</code> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_migrations" href="#_migrations"></a> 98。移居</h2></div></div></div><div class="tip" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Tip"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[小费]" src="images/tip.png"></td><th align="left">小费</th></tr><tr><td align="left" valign="top"><p>有关最新的迁移指南，请访问项目的<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/wiki/" target="_top">Wiki页面</a> 。</p></td></tr></tbody></table></div><p>本节涵盖了从一个版本的Spring Cloud Contract Verifier迁移到下一个版本。它涵盖以下版本升级路径：</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="cloud-verifier-1.0-1.1" href="#cloud-verifier-1.0-1.1"></a> 98.1 1.0.x→1.1.x</h2></div></div></div><p>本节介绍从1.0版升级到1.1版的过程。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_new_structure_of_generated_stubs" href="#_new_structure_of_generated_stubs"></a> 98.1.1生成的存根的新结构</h3></div></div></div><p>在<code class="literal">1.1.x</code>我们对生成的存根结构进行了更改。如果您一直在使用<code class="literal">@AutoConfigureWireMock</code>符号使用类路径中的存根，它不再起作用。以下示例说明了<code class="literal">@AutoConfigureWireMock</code>常用的符号：</p><pre class="programlisting">@AutoConfigureWireMock(stubs = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"classpath:/customer-stubs/mappings"</span>, port = <span class="hl-number">8084</span>)</pre><p>您必须将存根的位置更改为： <code class="literal">classpath:…​/META-INF/groupId/artifactId/version/mappings</code>或使用新的基于classpath的<code class="literal">@AutoConfigureStubRunner</code> ，如以下示例所示：</p><pre class="programlisting">@AutoConfigureWireMock(stubs = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"classpath:customer-stubs/META-INF/travel.components/customer-contract/1.0.2-SNAPSHOT/mappings/"</span>, port = <span class="hl-number">8084</span>)</pre><p>如果您不想使用<code class="literal">@AutoConfigureStubRunner</code>并且您想保留旧的结构，请相应地设置插件任务。以下示例适用于前一片段中介绍的结构。</p><p class="primary"><b>Maven。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- start of pom.xml --&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;properties&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- we don't want the verifier to do a jar for us --&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;spring.cloud.contract.verifier.skip&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/spring.cloud.contract.verifier.skip&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/properties&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- ... --&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- You need to set up the assembly plugin --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;build&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugins&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>maven-assembly-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;executions&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;execution&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>stub<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;phase&gt;</span>prepare-package<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/phase&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goals&gt;</span>
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;goal&gt;</span>single<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goal&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/goals&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;inherited&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/inherited&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;attach&gt;</span>true<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/attach&gt;</span>
                        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;descriptor&gt;</span>$../../../../src/assembly/stub.xml<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/descriptor&gt;</span>
                    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span>
                <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/execution&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/executions&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugins&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/build&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- end of pom.xml --&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- start of stub.xml--&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;assembly</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xmlns:xsi</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">xsi:schemaLocation</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;id&gt;</span>stubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/id&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;formats&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;format&gt;</span>jar<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/format&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/formats&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includeBaseDirectory&gt;</span>false<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includeBaseDirectory&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSets&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>${project.build.directory}/snippets/stubs<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>customer-stubs/mappings<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**/*<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;fileSet&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;directory&gt;</span>$../../../../src/test/resources/contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/directory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;outputDirectory&gt;</span>customer-stubs/contracts<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/outputDirectory&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;includes&gt;</span>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include&gt;</span>**/*.groovy<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/include&gt;</span>
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/includes&gt;</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSet&gt;</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/fileSets&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/assembly&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- end of stub.xml--&gt;</span></pre><p class="primary">
</p><p class="secondary"><b>摇篮。</b>
</p><pre class="programlisting">task copyStubs(type: Copy, dependsOn: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'generateWireMockClientStubs'</span>) {
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//    Preserve directory structure from 1.0.X of spring-cloud-contract</span>
    from <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/resources/main/customer-stubs/META-INF/${project.group}/${project.name}/${project.version}"</span>
    into <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"${project.buildDir}/resources/main/customer-stubs"</span>
}</pre><p class="secondary">
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="cloud-verifier-1.1-1.2" href="#cloud-verifier-1.1-1.2"></a> 98.2 1.1.x→1.2.x</h2></div></div></div><p>本节介绍从版本1.1升级到版本1.2。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_httpserverstub" href="#_custom_httpserverstub"></a> 98.2.1定制<code class="literal">HttpServerStub</code></h3></div></div></div><p><code class="literal">HttpServerStub</code>包括版本1.1中未提供的方法。方法是<code class="literal">String registeredMappings()</code>如果您有实现的类<code class="literal">HttpServerStub</code> ，您现在必须实施<code class="literal">registeredMappings()</code>方法。它应该返回一个<code class="literal">String</code>表示单个可用的所有映射<code class="literal">HttpServerStub</code> 。</p><p>有关更多详细信息，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/issues/355" target="_top">问题355</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_new_packages_for_generated_tests" href="#_new_packages_for_generated_tests"></a> 98.2.2用于生成测试的新软件包</h3></div></div></div><p>设置生成的测试程序包名称的流程如下所示：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">组<code class="literal">basePackageForTests</code></li><li class="listitem">如果<code class="literal">basePackageForTests</code>尚未设置，请从<code class="literal">baseClassForTests</code></li><li class="listitem">如果<code class="literal">baseClassForTests</code>未设置，选择<code class="literal">packageWithBaseClasses</code></li><li class="listitem">如果未设置任何内容，请选择默认值：<code class="literal">org.springframework.cloud.contract.verifier.tests</code></li></ul></div><p>有关更多详细信息，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/issues/260" target="_top">问题260</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_new_methods_in_templateprocessor" href="#_new_methods_in_templateprocessor"></a> 98.2.3 TemplateProcessor中的新方法</h3></div></div></div><p>为了增加对<code class="literal">fromRequest.path</code> ，则必须将以下方法添加到<code class="literal">TemplateProcessor</code>接口：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">path()</code></li><li class="listitem"><code class="literal">path(int index)</code></li></ul></div><p>有关更多详细信息，请参见<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/issues/388" target="_top">问题388</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_restassured_3_0" href="#_restassured_3_0"></a> 98.2.4 RestAssured 3.0</h3></div></div></div><p>在生成的测试类中使用的“放心的休息”碰到了<code class="literal">3.0</code> 。如果您手动设置Spring Cloud Contract的版本和发行版，可能会看到以下异常：</p><pre class="programlisting">Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:<span class="hl-number">3.1</span>:testCompile (default-testCompile) on project some-project: Compilation failure: Compilation failure:
[ERROR] /some/path/SomeClass.java:[<span class="hl-number">4</span>,<span class="hl-number">39</span>] package com.jayway.restassured.response does not exist</pre><p>由于使用旧版本的插件生成了测试，并且在测试执行时您使用的发行版版本不兼容，因此会发生此异常。</p><p>通过<a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/issues/267" target="_top">问题267</a>完成</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="cloud-verifier-1.2-2.0" href="#cloud-verifier-1.2-2.0"></a> 98.3 1.2.x→2.0.x</h2></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_links" href="#_links"></a> 99。链接</h2></div></div></div><p>以下链接在使用Spring Cloud Contract时可能会有所帮助：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-contract/" target="_top">Spring Cloud Contract Github存储库</a></li><li class="listitem"><a class="link" href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/" target="_top">Spring Cloud合同样本</a></li><li class="listitem"><a class="link" href="https://gitter.im/spring-cloud/spring-cloud-contract" target="_top">spring-cloud-contract的困扰</a></li><li class="listitem"><a class="link" href="https://www.youtube.com/watch?v=sAAklvxmPmk" target="_top">Marcin Grzejszczak的Spring Cloud Contract WJUG演示</a></li></ul></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_vault" href="#_spring_cloud_vault"></a>第十四部分。 Spring Cloud Vault</h1></div></div></div><div class="partintro"><div></div><p>©2016-2019原作者。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><span class="emphasis"><em>本文档的副本可以供您自己使用，也可以分发给他人，但前提是您不对此类副本收取任何费用，并且还应确保每份副本均包含本版权声明（无论是印刷版本还是电子版本）。</em></span></p></td></tr></tbody></table></div><p>Spring Cloud Vault Config为分布式系统中的外部化配置提供了客户端支持。使用<a class="link" href="https://www.vaultproject.io" target="_top">HashiCorp的保管库，</a>您可以在中心位置管理所有环境中应用程序的外部秘密属性。 Vault 可以管理静态和动态机密，例如远程应用程序/资源的用户名/密码，并为外部服务（例如MySQL，PostgreSQL，Apache Cassandra，MongoDB，Consul，AWS等）提供凭据。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_quick_start_4" href="#_quick_start_4"></a> 100快速开始</h2></div></div></div><p><span class="strong"><strong>先决条件</strong></span></p><p>要开始使用Vault和本指南，您需要一个类似* NIX的操作系统，该操作系统提供：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">wget</code> ， <code class="literal">openssl</code>和<code class="literal">unzip</code></li><li class="listitem">至少Java 7和正确配置的<code class="literal">JAVA_HOME</code>环境变量</li></ul></div><p><span class="strong"><strong>安装 Vault </strong></span></p><pre class="programlisting">$ src/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>/bash/install_vault.sh</pre><p><span class="strong"><strong>为 Vault 创建SSL证书</strong></span></p><pre class="programlisting">$ src/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>/bash/create_certificates.sh</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">create_certificates.sh</code>在以下位置创建证书<code class="literal">work/ca</code>和JKS信任库<code class="literal">work/keystore.jks</code> 。如果您想使用此快速入门指南运行Spring Cloud Vault，则需要配置信任库<code class="literal">spring.cloud.vault.ssl.trust-store</code>财产<code class="literal">file:work/keystore.jks</code> 。</p></td></tr></tbody></table></div><p><a name="quickstart.vault.start" href="#quickstart.vault.start"></a> <span class="strong"><strong>启动 Vault 服务器</strong></span></p><pre class="programlisting">$ src/<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">test</span>/bash/local_run_vault.sh</pre><p>保管箱开始监听<code class="literal">0.0.0.0:8200</code>使用<code class="literal">inmem</code>储存和<code class="literal">https</code> 。启动时，保管箱已密封且未初始化。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果要运行测试，请使保管库未初始化。测试将初始化Vault并创建一个根令牌<code class="literal">00000000-0000-0000-0000-000000000000</code> 。</p></td></tr></tbody></table></div><p>如果要为应用程序使用保管箱或尝试使用保管箱，则需要先对其进行初始化。</p><pre class="programlisting">$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">export</span> VAULT_ADDR=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://localhost:8200"</span>
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">export</span> VAULT_SKIP_VERIFY=true <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Don't do this for production</span>
$ vault init</pre><p>您应该看到类似以下内容：</p><pre class="programlisting">Key <span class="hl-number">1</span>: <span class="hl-number">7149</span>c6a2e16b8833f6eb1e76df03e47f6113a3288b3093faf5033d44f0e70fe701
Key <span class="hl-number">2</span>: <span class="hl-number">901</span>c534c7988c18c20435a85213c683bdcf0efcd82e38e2893779f152978c18c02
Key <span class="hl-number">3</span>: <span class="hl-number">03</span>ff3948575b1165a20c20ee7c3e6edf04f4cdbe0e82dbff5be49c63f98bc03a03
Key <span class="hl-number">4</span>: <span class="hl-number">216</span>ae5cc3ddaf93ceb8e1d15bb9fc3176653f5b738f5f3d1ee00cd7dccbe926e04
Key <span class="hl-number">5</span>: b2898fc8130929d569c1677ee69dc5f3be57d7c4b494a6062693ce0b1c4d93d805
Initial Root Token: <span class="hl-number">19</span>aefa97-cccc-bbbb-aaaa-<span class="hl-number">225940</span>e63d76

Vault initialized with <span class="hl-number">5</span> keys and a key threshold of <span class="hl-number">3.</span> Please
securely distribute the above keys. When the Vault is re-sealed,
restarted, or stopped, you must provide at least <span class="hl-number">3</span> of these keys
to unseal it again.

Vault does not store the master key. Without at least <span class="hl-number">3</span> keys,
your Vault will remain permanently sealed.</pre><p>保管箱将初始化并返回一组启封密钥和根令牌。选择3个钥匙并解开 Vault 。将 Vault 令牌存储在<code class="literal">VAULT_TOKEN</code>环境变量。</p><pre class="programlisting">$ vault unseal (Key <span class="hl-number">1</span>)
$ vault unseal (Key <span class="hl-number">2</span>)
$ vault unseal (Key <span class="hl-number">3</span>)
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">export</span> VAULT_TOKEN=(Root token)
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Required to run Spring Cloud Vault tests after manual initialization</span>
$ vault token-create -id=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"00000000-0000-0000-0000-000000000000"</span> -policy=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"root"</span></pre><p>Spring Cloud Vault访问不同的资源。默认情况下，启用秘密后端，该后端可通过JSON端点访问秘密配置设置。</p><p>HTTP服务具有以下形式的资源：</p><pre class="screen">/secret/{application}/{profile}
/secret/{application}
/secret/{defaultContext}/{profile}
/secret/{defaultContext}</pre><p>将“应用程序”作为<code class="literal">spring.application.name</code>在里面<code class="literal">SpringApplication</code> （即常规Spring Boot应用程序中通常的“应用程序”），“配置文件”是活动配置文件（或属性的逗号分隔列表）。从保管库检索到的属性将按原样使用，而无需进一步加前缀属性名称。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_client_side_usage_2" href="#_client_side_usage_2"></a> 101。客户端使用</h2></div></div></div><p>要在应用程序中使用这些功能，只需将其构建为依赖于<code class="literal">spring-cloud-vault-config</code> （例如，查看测试用例）。Maven配置示例：</p><div class="example"><a name="d0e30289" href="#d0e30289"></a><p class="title"><b>示例101.1 pom.xml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;parent&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-parent<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>2.0.0.RELEASE<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;relativePath /&gt;</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- lookup parent from repository --&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/parent&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-vault-config<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{project-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>test<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;build&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugins&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;plugin&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugin&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/plugins&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/build&gt;</span>

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!-- repositories also needed for snapshots and milestones --&gt;</span></pre></div></div><br class="example-break"><p>然后，您可以创建一个标准的Spring Boot应用程序，例如以下简单的HTTP服务器：</p><div class="informalexample"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

    <em><span class="hl-annotation" style="color: gray">@RequestMapping("/")</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String home() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello World!"</span>;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
        SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
    }
}</pre></div><p>运行时，它将从端口上的默认本地Vault服务器获取外部配置<code class="literal">8200</code>如果它正在运行。要修改启动行为，您可以使用以下方法更改Vault服务器的位置<code class="literal">bootstrap.properties</code> （喜欢<code class="literal">application.properties</code>但针对应用程序上下文的引导阶段），例如</p><div class="example"><a name="d0e30310" href="#d0e30310"></a><p class="title"><b>示例101.2 bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    host</span>: localhost
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    port</span>: <span class="hl-number">8200</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    scheme</span>: https
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    uri</span>: https://localhost:<span class="hl-number">8200</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    connection-timeout</span>: <span class="hl-number">5000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    read-timeout</span>: <span class="hl-number">15000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        order</span>: -<span class="hl-number">10</span></pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">host</code>设置Vault主机的主机名。主机名将用于SSL证书验证</li><li class="listitem"><code class="literal">port</code>设置保管库端口</li><li class="listitem"><code class="literal">scheme</code>将方案设置为<code class="literal">http</code>将使用纯HTTP。支持的方案是<code class="literal">http</code>和<code class="literal">https</code> 。</li><li class="listitem"><code class="literal">uri</code>使用URI配置Vault端点。优先于主机/端口/方案配置</li><li class="listitem"><code class="literal">connection-timeout</code>设置连接超时（以毫秒为单位）</li><li class="listitem"><code class="literal">read-timeout</code>设置读取超时（以毫秒为单位）</li><li class="listitem"><code class="literal">config.order</code>设置属性来源的顺序</li></ul></div><p>启用进一步的集成需要附加的依赖关系和配置。根据您设置 Vault 的方式，您可能需要其他配置，例如<a class="link" href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.ssl" target="_top">SSL</a>和<a class="link" href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.authentication" target="_top">身份验证</a> 。</p><p>如果应用程序导入了<code class="literal">spring-boot-starter-actuator</code>项目，可以通过以下方式查看Vault服务器的状态： <code class="literal">/health</code>端点。</p><p>可以通过属性启用或禁用Vault运行状况指示器<code class="literal">management.health.vault.enabled</code> （默认为<code class="literal">true</code> ）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_authentication_2" href="#_authentication_2"></a> 101.1身份验证</h2></div></div></div><p>Vault需要一种<a class="link" href="https://www.vaultproject.io/docs/concepts/auth.html" target="_top">身份验证机制</a>来<a class="link" href="https://www.vaultproject.io/docs/concepts/tokens.html" target="_top">授权客户端请求</a> 。</p><p>Spring Cloud Vault支持多种<a class="link" href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.authentication" target="_top">身份验证机制，</a>以通过Vault验证应用程序。</p><p>为了快速入门，请使用<a class="link" href="#quickstart.vault.start">保管库初始化</a>打印的根令牌。</p><div class="example"><a name="d0e30405" href="#d0e30405"></a><p class="title"><b>示例101.3 bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    token</span>: <span class="hl-number">19</span>aefa97-cccc-bbbb-aaaa-<span class="hl-number">225940e63d</span>76</pre></div></div><br class="example-break"><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>请仔细考虑您的安全要求。如果您想快速开始使用Vault，可以使用静态令牌身份验证，但是静态令牌不再受到任何保护。向非预期方的任何披露都允许 Vault 与关联的令牌角色一起使用。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault.config.authentication" href="#vault.config.authentication"></a> 102。认证方式</h2></div></div></div><p>不同的组织对安全性和身份验证有不同的要求。 Vault 通过提供多种身份验证方法来反映这种需求。Spring Cloud Vault支持令牌和AppId身份验证。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.token" href="#vault.config.authentication.token"></a> 102.1令牌认证</h2></div></div></div><p>令牌是 Vault 中身份验证的核心方法。令牌认证要求使用<a class="link" href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/docs/src/main/asciidoc/spring-cloud-commons.adoc#the-bootstrap-application-context" target="_top">Bootstrap应用程序上下文</a>提供静态令牌。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>令牌认证是默认的认证方法。如果公开了令牌，则意外的一方将获得对 Vault 的访问权，并可以访问目标客户的机密。</p></td></tr></tbody></table></div><div class="example"><a name="d0e30429" href="#d0e30429"></a><p class="title"><b>示例102.1 bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: TOKEN
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    token</span>: <span class="hl-number">00000000</span>-<span class="hl-number">0000</span>-<span class="hl-number">0000</span>-<span class="hl-number">0000</span>-<span class="hl-number">000000000000</span></pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">authentication</code>将此值设置为<code class="literal">TOKEN</code>选择令牌认证方法</li><li class="listitem"><code class="literal">token</code>设置要使用的静态令牌</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/concepts/tokens.html" target="_top"> Vault 文件：令牌</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.appid" href="#vault.config.authentication.appid"></a> 102.2 AppId身份验证</h2></div></div></div><p> Vault 支持由两个难以猜测的令牌组成的<a class="link" href="https://www.vaultproject.io/docs/auth/app-id.html" target="_top">AppId</a>身份验证。AppId默认为<code class="literal">spring.application.name</code>是静态配置的。第二个令牌是UserId，它是应用程序确定的一部分，通常与运行时环境有关。IP地址，Mac地址或Docker容器名称就是很好的例子。Spring Cloud Vault Config支持IP地址，Mac地址和静态UserId（例如，通过系统属性提供）。IP和Mac地址表示为十六进制编码的SHA256哈希。</p><p>基于IP地址的UserId使用本地主机的IP地址。</p><div class="example"><a name="d0e30465" href="#d0e30465"></a><p class="title"><b>示例10.2 bootstrap.yml使用SHA256 IP地址用户ID</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: APPID
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    app-id</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        user-id</span>: IP_ADDRESS</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">authentication</code>将此值设置为<code class="literal">APPID</code>选择AppId身份验证方法</li><li class="listitem"><code class="literal">app-id-path</code>设置要使用的AppId安装的路径</li><li class="listitem"><code class="literal">user-id</code>设置UserId方法。可能的值为<code class="literal">IP_ADDRESS</code> ， <code class="literal">MAC_ADDRESS</code>或实现自定义的类名<code class="literal">AppIdUserIdMechanism</code></li></ul></div><p>从命令行生成IP地址UserId的相应命令是：</p><pre class="screen">$ echo -n 192.168.99.1 | sha256sum</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>包括换行符<code class="literal">echo</code>导致产生不同的哈希值，因此请确保包括<code class="literal">-n</code>旗。</p></td></tr></tbody></table></div><p>基于Mac地址的UserId从本地主机绑定的设备获取其网络设备。该配置还允许指定<code class="literal">network-interface</code>提示选择正确的设备。的价值<code class="literal">network-interface</code>是可选的，可以是接口名称或接口索引（从0开始）。</p><div class="example"><a name="d0e30518" href="#d0e30518"></a><p class="title"><b>示例102.3 bootstrap.yml使用SHA256 Mac-Address用户ID</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: APPID
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    app-id</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        user-id</span>: MAC_ADDRESS
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        network-interface</span>: eth0</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">network-interface</code>设置网络接口以获得物理地址</li></ul></div><p>从命令行生成IP地址UserId的相应命令是：</p><pre class="screen">$ echo -n 0AFEDE1234AC | sha256sum</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Mac地址指定为大写且没有冒号。包括换行符<code class="literal">echo</code>导致产生不同的哈希值，因此请确保包括<code class="literal">-n</code>旗。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_userid" href="#_custom_userid"></a> 102.2.1自定义用户ID</h3></div></div></div><p>UserId生成是一种开放机制。你可以设定<code class="literal">spring.cloud.vault.app-id.user-id</code>设置为任何字符串，配置的值将用作静态UserId。</p><p>更高级的方法可让您设置<code class="literal">spring.cloud.vault.app-id.user-id</code>到一个类名。此类必须在您的类路径上，并且必须实现<code class="literal">org.springframework.cloud.vault.AppIdUserIdMechanism</code>界面和<code class="literal">createUserId</code>方法。Spring Cloud Vault将通过调用获取UserId <code class="literal">createUserId</code>每次它使用AppId进行身份验证以获得令牌时。</p><div class="example"><a name="d0e30564" href="#d0e30564"></a><p class="title"><b>示例102.4 bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: APPID
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    app-id</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        user-id</span>: com.examlple.MyUserIdMechanism</pre></div></div><br class="example-break"><div class="example"><a name="d0e30569" href="#d0e30569"></a><p class="title"><b>示例102.5MyUserIdMechanism.java</b></p><div class="example-contents"><pre class="programlisting">public class MyUserIdMechanism implements AppIdUserIdMechanism <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>

  <em><span class="hl-annotation" style="color: gray">@Override</span></em>
  public String createUserId() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    String userId </span>= ...
    return userId;
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre></div></div><br class="example-break"><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/auth/app-id.html" target="_top">保管库文档：使用App ID auth后端</a></p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_approle_authentication" href="#_approle_authentication"></a> 102.3 AppRole身份验证</h2></div></div></div><p><a class="link" href="https://www.vaultproject.io/docs/auth/app-id.html" target="_top">AppRole</a>用于机器身份验证，例如已弃用的（自Vault 0.6.1起） <a class="xref" href="#vault.config.authentication.appid" title="102.2 AppId身份验证">第102.2节“ AppId身份验证”</a> 。AppRole身份验证包含两个很难猜测（秘密）的令牌：RoleId和SecretId。</p><p>Spring Vault支持各种AppRole方案（推/拉模式和包装）。</p><p>RoleId和可选的SecretId必须由配置提供，Spring Vault不会查找它们或创建自定义SecretId。</p><div class="example"><a name="d0e30591" href="#d0e30591"></a><p class="title"><b>示例102.6具有AppRole身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: APPROLE
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    app-role</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role-id</span>: bde2076b-cccb-<span class="hl-number">3</span>cf0-d57e-bca7b1e83a52</pre></div></div><br class="example-break"><p>支持以下方案以及必需的配置详细信息：</p><div class="table"><a name="d0e30598" href="#d0e30598"></a><p class="title"><b>表102.1。组态</b></p><div class="table-contents"><table class="table" summary="Configuration" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>方法</strong></span></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>角色编号</strong></span></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>SecretId</strong></span></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>角色名</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><span class="strong"><strong>代币</strong></span></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供的RoleId / SecretId</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供的RoleId不带SecretId</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供的RoleId，Pull SecretId</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>提供</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉出RoleId，提供SecretId</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>提供</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>全拉模式</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>提供</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>提供</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包装好的RoleId，提供SecretId</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>提供</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>提供的RoleId，包装好的SecretId</p></td><td align="left" valign="top" style="border-right:1px solid"> </td><td align="left" valign="top" style="border-right:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid"> </td><td align="left" valign="top"><p>提供</p></td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d0e30727" href="#d0e30727"></a><p class="title"><b>表102.2。拉/推/包裹矩阵</b></p><div class="table-contents"><table class="table" summary="Pull/Push/Wrapped Matrix" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>角色编号</strong></span></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><span class="strong"><strong>SecretId</strong></span></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><span class="strong"><strong>支持的</strong></span></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>缺席</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>❌</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>缺席</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>❌</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>提供</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>❌</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>✅</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>包裹</p></td><td align="left" valign="top" style="border-right:1px solid"><p>缺席</p></td><td align="left" valign="top"><p>❌</p></td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您还可以通过提供已配置的配置来使用推/拉/包模式的所有组合<code class="literal">AppRoleAuthentication</code>引导上下文中的bean。Spring Cloud Vault无法从配置属性中导出所有可能的AppRole组合。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>AppRole身份验证仅限于使用反应式基础结构的简单拉模式。Full pull mode is not yet supported. 将Spring Cloud Vault与Spring WebFlux堆栈一起使用可启用Vault的反应式自动配置，可通过设置来禁用<code class="literal">spring.cloud.vault.reactive.enabled=false</code> 。</p></td></tr></tbody></table></div><div class="example"><a name="d0e30880" href="#d0e30880"></a><p class="title"><b>示例102.7具有所有AppRole身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: APPROLE
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    app-role</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role-id</span>: bde2076b-cccb-<span class="hl-number">3</span>cf0-d57e-bca7b1e83a52
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        secret-id</span>: <span class="hl-number">1696536f</span>-<span class="hl-number">1976</span>-<span class="hl-number">73</span>b1-b241-<span class="hl-number">0</span>b4213908d39
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-role
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        app-role-path</span>: approle</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">role-id</code>设置RoleId。</li><li class="listitem"><code class="literal">secret-id</code>设置SecretId。如果在不要求SecretId的情况下配置了AppRole，则可以忽略SecretId（请参见<code class="literal">bind_secret_id</code> ）。</li><li class="listitem"><code class="literal">role</code> ：设置拉动模式的AppRole名称。</li><li class="listitem"><code class="literal">app-role-path</code>设置要使用的方法认证安装的路径。</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/auth/approle.html" target="_top">保管库文档：使用AppRole身份验证后端</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.awsec2" href="#vault.config.authentication.awsec2"></a> 102.4 AWS-EC2身份验证</h2></div></div></div><p><a class="link" href="https://www.vaultproject.io/docs/auth/aws-ec2.html" target="_top">aws-ec2</a> auth后端为AWS EC2实例提供了一种安全的引入机制，允许自动检索Vault令牌。与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。而是将AWS视为受信任的第三方，并使用经过加密签名的动态元数据信息来唯一表示每个EC2实例。</p><div class="example"><a name="d0e30921" href="#d0e30921"></a><p class="title"><b>示例102.8使用AWS-EC2身份验证的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AWS_EC2</pre></div></div><br class="example-break"><p>AWS-EC2身份验证默认使随机数遵循首次使用信任（TOFU）原则。任何有权访问PKCS＃7身份元数据的意外方都可以针对 Vault 进行身份验证。</p><p>在首次登录期间，Spring Cloud Vault会生成一个随机数，该随机数存储在身份验证后端中，与实例ID无关。重新认证要求发送相同的随机数。任何其他方都没有该随机数，可以在 Vault 中发出警报以进行进一步调查。</p><p>随机数保留在内存中，在应用程序重新启动期间丢失。您可以使用配置静态随机数<code class="literal">spring.cloud.vault.aws-ec2.nonce</code> 。</p><p>AWS-EC2身份验证角色是可选的，默认为AMI。您可以通过设置身份验证角色<code class="literal">spring.cloud.vault.aws-ec2.role</code>属性。</p><div class="example"><a name="d0e30940" href="#d0e30940"></a><p class="title"><b>示例102.9具有配置角色的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AWS_EC2
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    aws-ec2</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: application-server</pre></div></div><br class="example-break"><div class="example"><a name="d0e30945" href="#d0e30945"></a><p class="title"><b>示例102.10具有所有AWS EC2身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AWS_EC2
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    aws-ec2</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: application-server
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        aws-ec2-path</span>: aws-ec2
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        identity-document</span>: http://...
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        nonce</span>: my-static-nonce</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">authentication</code>将此值设置为<code class="literal">AWS_EC2</code>选择AWS EC2身份验证方法</li><li class="listitem"><code class="literal">role</code>设置尝试进行登录的角色的名称。</li><li class="listitem"><code class="literal">aws-ec2-path</code>设置要使用的AWS EC2安装的路径</li><li class="listitem"><code class="literal">identity-document</code>设置PKCS＃7 AWS EC2身份文档的URL</li><li class="listitem"><code class="literal">nonce</code>用于AWS-EC2身份验证。空随机数默认为随机数生成</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/auth/aws.html" target="_top">Vault文档：使用aws auth后端</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.awsiam" href="#vault.config.authentication.awsiam"></a> 102.5 AWS-IAM身份验证</h2></div></div></div><p><a class="link" href="https://www.vaultproject.io/docs/auth/aws-ec2.html" target="_top">aws</a>后端为AWS IAM角色提供了一种安全的身份验证机制，从而可以基于正在运行的应用程序的当前IAM角色，通过保管库进行自动身份验证。与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。相反，它将AWS视为受信任的第三方，并使用呼叫者使用其IAM凭据签名的4条信息来验证呼叫者确实在使用该IAM角色。</p><p>应用程序正在其中运行的当前IAM角色是自动计算的。如果您在AWS ECS上运行应用程序，则该应用程序将使用分配给正在运行的容器的ECS任务的IAM角色。如果您在EC2实例上裸身运行应用程序，则使用的IAM角色将是分配给EC2实例的角色。</p><p>使用AWS-IAM身份验证时，您必须在Vault中创建一个角色并将其分配给您的IAM角色。一个空的<code class="literal">role</code>默认为当前IAM角色的友好名称。</p><div class="example"><a name="d0e30998" href="#d0e30998"></a><p class="title"><b>示例102.11具有必需的AWS-IAM身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AWS_IAM</pre></div></div><br class="example-break"><div class="example"><a name="d0e31003" href="#d0e31003"></a><p class="title"><b>示例102.12具有所有AWS-IAM身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AWS_IAM
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    aws-iam</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        aws-path</span>: aws
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        server-id</span>: some.server.name</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">role</code>设置尝试进行登录的角色的名称。这应该与您的IAM角色绑定。如果未提供，则将使用当前IAM用户的友好名称作为保管库角色。</li><li class="listitem"><code class="literal">aws-path</code>设置要使用的AWS装载的路径</li><li class="listitem"><code class="literal">server-id</code>设置要用于的值<code class="literal">X-Vault-AWS-IAM-Server-ID</code>标头可防止某些类型的重放攻击。</li></ul></div><p>AWS-IAM需要AWS Java SDK依赖项（ <code class="literal">com.amazonaws:aws-java-sdk-core</code> ），因为身份验证实现将AWS开发工具包类型用于凭证和请求签名。</p><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/auth/aws.html" target="_top">Vault文档：使用aws auth后端</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.azuremsi" href="#vault.config.authentication.azuremsi"></a> 102.6 Azure MSI身份验证</h2></div></div></div><p><a class="link" href="https://www.vaultproject.io/docs/auth/azure.html" target="_top">天蓝色的</a>身份验证后端为Azure VM实例提供了一种安全的引入机制，允许自动检索 Vault 令牌。与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。而是将Azure视为受信任的第三方，并使用可以绑定到VM实例的托管服务身份和实例元数据信息。</p><div class="example"><a name="d0e31044" href="#d0e31044"></a><p class="title"><b>示例102.13 bootstrap.yml具有必需的Azure身份验证属性</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AZURE_MSI
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    azure-msi</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role</pre></div></div><br class="example-break"><div class="example"><a name="d0e31049" href="#d0e31049"></a><p class="title"><b>示例102.14具有所有Azure身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: AZURE_MSI
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    azure-msi</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        azure-path</span>: azure</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">role</code>设置尝试进行登录的角色的名称。</li><li class="listitem"><code class="literal">azure-path</code>设置要使用的Azure装载的路径</li></ul></div><p>Azure MSI身份验证从实例元数据服务中获取有关虚拟机的环境详细信息（订阅ID，资源组，VM名称）。</p><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/auth/azure.html" target="_top">Vault文档：使用Azure身份验证后端</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.clientcert" href="#vault.config.authentication.clientcert"></a> 102.7 TLS证书认证</h2></div></div></div><p>的<code class="literal">cert</code> auth后端允许使用由CA签名或自签名的SSL / TLS客户端证书进行身份验证。</p><p>启用<code class="literal">cert</code>身份验证您需要：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">使用SSL，请参见<a class="xref" href="#vault.config.ssl" title="108。Vault Client SSL配置">第108章， <i>Vault Client SSL配置</i></a></li><li class="listitem">配置Java <code class="literal">Keystore</code>包含客户端证书和私钥</li><li class="listitem">设置<code class="literal">spring.cloud.vault.authentication</code>至<code class="literal">CERT</code></li></ol></div><div class="example"><a name="d0e31103" href="#d0e31103"></a><p class="title"><b>示例102.15 bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: CERT
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    ssl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        key-store</span>: classpath:keystore.jks
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        key-store-password</span>: changeit
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        cert-auth-path</span>: cert</pre></div></div><br class="example-break"><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/auth/cert.html" target="_top">保管库文档：使用Cert auth后端</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.cubbyhole" href="#vault.config.authentication.cubbyhole"></a> 102.8 Cubbyhole身份验证</h2></div></div></div><p>Cubbyhole身份验证使用保管库原语提供安全的身份验证工作流。Cubbyhole身份验证使用令牌作为主要登录方法。临时令牌用于从Vault的Cubbyhole秘密后端获取第二个登录VaultToken。登录令牌通常使用寿命更长，并用于与 Vault 进行交互。登录令牌将从存储在以下位置的包装响应中检索<code class="literal">/cubbyhole/response</code> 。</p><p><span class="strong"><strong>创建包装的令牌</strong></span></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>用于创建令牌的响应包装需要Vault 0.6.0或更高版本。</p></td></tr></tbody></table></div><div class="example"><a name="d0e31126" href="#d0e31126"></a><p class="title"><b>示例102.16创建和存储令牌</b></p><div class="example-contents"><pre class="programlisting">$ vault token-create -wrap-ttl="10m"
Key                            Value
---                            -----
wrapping_token:                397ccb93-ff6c-b17b-9389-380b01ca2645
wrapping_token_ttl:            0h10m0s
wrapping_token_creation_time:  2016-09-18 20:29:48.652957077 +0200 CEST
wrapped_accessor:              46b6aebb-187f-932a-26d7-4f3d86a68319</pre></div></div><br class="example-break"><div class="example"><a name="d0e31131" href="#d0e31131"></a><p class="title"><b>示例102.17 bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: CUBBYHOLE
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    token</span>: <span class="hl-number">397</span>ccb93-ff6c-b17b-<span class="hl-number">9389</span>-<span class="hl-number">380</span>b01ca2645</pre></div></div><br class="example-break"><p>也可以看看：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.vaultproject.io/docs/concepts/tokens.html" target="_top"> Vault 文档：令牌</a></li><li class="listitem"><a class="link" href="https://www.vaultproject.io/docs/secrets/cubbyhole/index.html" target="_top"> Vault 文件：Cubbyhole秘密后端</a></li><li class="listitem"><a class="link" href="https://www.vaultproject.io/docs/concepts/response-wrapping.html" target="_top"> Vault 文件：响应包装</a></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.gcpgce" href="#vault.config.authentication.gcpgce"></a> 102.9 GCP-GCE认证</h2></div></div></div><p>该<a class="link" href="https://www.vaultproject.io/docs/auth/gcp.html" target="_top">GCP</a> AUTH后端， Vault 登录使用现有的GCP（谷歌云平台）IAM和GCE凭据。</p><p>GCP GCE（Google Compute Engine）身份验证为服务帐户创建JSON Web令牌（JWT）形式的签名。使用<a class="link" href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity" target="_top">实例标识</a>从GCE元数据服务获得Compute Engine实例的JWT。此API创建一个JSON Web令牌，可用于确认实例身份。</p><p>与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。而是将GCP视为受信任的第三方，并使用经过加密签名的动态元数据信息来唯一表示每个GCP服务帐户。</p><div class="example"><a name="d0e31166" href="#d0e31166"></a><p class="title"><b>示例102.18 bootstrap.yml具有必需的GCP-GCE身份验证属性</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: GCP_GCE
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gcp-gce</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role</pre></div></div><br class="example-break"><div class="example"><a name="d0e31171" href="#d0e31171"></a><p class="title"><b>示例102.19具有所有GCP-GCE身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: GCP_GCE
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gcp-gce</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        gcp-path</span>: gcp
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        service-account</span>: my-service@projectid.iam.gserviceaccount.com</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">role</code>设置尝试进行登录的角色的名称。</li><li class="listitem"><code class="literal">gcp-path</code>设置要使用的GCP安装的路径</li><li class="listitem"><code class="literal">service-account</code>允许将服务帐户ID覆盖为特定值。默认为<code class="literal">default</code>服务帐户。</li></ul></div><p>也可以看看：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.vaultproject.io/docs/auth/gcp.html" target="_top"> Vault 文件：使用GCP身份验证后端</a></li><li class="listitem"><a class="link" href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity" target="_top">GCP文档：验证实例的身份</a></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.gcpiam" href="#vault.config.authentication.gcpiam"></a> 102.10 GCP-IAM认证</h2></div></div></div><p>该<a class="link" href="https://www.vaultproject.io/docs/auth/gcp.html" target="_top">GCP</a> AUTH后端， Vault 登录使用现有的GCP（谷歌云平台）IAM和GCE凭据。</p><p>GCP IAM身份验证以JSON Web令牌（JWT）的形式为服务帐户创建签名。通过调用GCP IAM获得服务帐户的JWT <a class="link" href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt" target="_top"><code class="literal">projects.serviceAccounts.signJwt</code></a> API。呼叫者针对GCP IAM进行身份验证，从而证明其身份。该 Vault 后端将GCP视为受信任的第三方。</p><p>可以从运行时环境（特别是<a class="link" href="https://cloud.google.com/docs/authentication/production" target="_top"><code class="literal">GOOGLE_APPLICATION_CREDENTIALS</code></a>环境变量，Google Compute元数据服务，或外部提供，例如JSON或base64编码。JSON是首选形式，因为它带有调用所需的项目ID和服务帐户标识符<code class="literal">projects.serviceAccounts.signJwt</code> 。</p><div class="example"><a name="d0e31229" href="#d0e31229"></a><p class="title"><b>示例102.20 bootstrap.yml具有必需的GCP-IAM身份验证属性</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: GCP_IAM
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gcp-iam</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role</pre></div></div><br class="example-break"><div class="example"><a name="d0e31234" href="#d0e31234"></a><p class="title"><b>示例102.21。具有所有GCP-IAM身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: GCP_IAM
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gcp-iam</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        credentials</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            location</span>: classpath:credentials.json
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            encoded-key</span>: e+KApn0=
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        gcp-path</span>: gcp
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        jwt-validity</span>: <span class="hl-number">15</span>m
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        project-id</span>: my-project-id
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        service-account-id</span>: my-service@projectid.iam.gserviceaccount.com</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">role</code>设置尝试进行登录的角色的名称。</li><li class="listitem"><code class="literal">credentials.location</code>包含JSON格式的Google凭据的凭据资源的路径。</li><li class="listitem"><code class="literal">credentials.encoded-key</code> JSON格式的OAuth2帐户私钥的base64编码内容。</li><li class="listitem"><code class="literal">gcp-path</code>设置要使用的GCP安装的路径</li><li class="listitem"><code class="literal">jwt-validity</code>配置JWT令牌有效性。默认为15分钟。</li><li class="listitem"><code class="literal">project-id</code>允许将项目ID覆盖为特定值。从获得的凭据中默认为项目ID。</li><li class="listitem"><code class="literal">service-account</code>允许将服务帐户ID覆盖为特定值。默认为获取的凭证中的服务帐户。</li></ul></div><p>GCP IAM身份验证需要Google Cloud Java SDK依赖项（ <code class="literal">com.google.apis:google-api-services-iam</code>和<code class="literal">com.google.auth:google-auth-library-oauth2-http</code> ），因为身份验证实现将Google API用于凭据和JWT签名。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Google凭据需要OAuth 2令牌来维护令牌的生命周期。因此，所有API都是同步的， <code class="literal">GcpIamAuthentication</code>不支持<code class="literal">AuthenticationSteps</code>这是被动使用所必需的。</p></td></tr></tbody></table></div><p>也可以看看：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.vaultproject.io/docs/auth/gcp.html" target="_top"> Vault 文件：使用GCP身份验证后端</a></li><li class="listitem"><a class="link" href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt" target="_top">GCP文档：projects.serviceAccounts.signJwt</a><a name="vault.authentication.gcpiam" href="#vault.authentication.gcpiam"></a></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.authentication.kubernetes" href="#vault.config.authentication.kubernetes"></a> 102.11 Kubernetes身份验证</h2></div></div></div><p>Kubernetes身份验证机制（自Vault 0.8.3起）允许使用Kubernetes服务帐户令牌向Vault进行身份验证。身份验证基于角色，并且角色绑定到服务帐户名称和名称空间。</p><p>包含Pod服务帐户的JWT令牌的文件会自动安装在<code class="literal">/var/run/secrets/kubernetes.io/serviceaccount/token</code> 。</p><div class="example"><a name="d0e31314" href="#d0e31314"></a><p class="title"><b>示例102.22具有所有Kubernetes身份验证属性的bootstrap.yml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    authentication</span>: KUBERNETES
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    kubernetes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: my-dev-role
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        kubernetes-path</span>: kubernetes
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        service-account-token-file</span>: /var/run/secrets/kubernetes.io/serviceaccount/token</pre></div></div><br class="example-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">role</code>设置角色。</li><li class="listitem"><code class="literal">kubernetes-path</code>设置要使用的Kubernetes安装的路径。</li><li class="listitem"><code class="literal">service-account-token-file</code>设置包含Kubernetes服务帐户令牌的文件的位置。默认为<code class="literal">/var/run/secrets/kubernetes.io/serviceaccount/token</code> 。</li></ul></div><p>也可以看看：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://www.vaultproject.io/docs/auth/kubernetes.html" target="_top">保管库文件：Kubernetes</a></li><li class="listitem"><a class="link" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/" target="_top">Kubernetes文档：为Pod配置服务帐户</a></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault.config.backends" href="#vault.config.backends"></a> 103。秘密后端</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.generic" href="#vault.config.backends.generic"></a> 103.1通用后端</h2></div></div></div><p>Spring Cloud Vault在基本级别上支持通用秘密后端。通用秘密后端允许将任意值存储为键值存储。单个上下文可以存储一个或多个键值元组。上下文可以按层次进行组织。Spring Cloud Vault允许使用应用程序名称和默认上下文名称（ <code class="literal">application</code> ）与有效配置文件结合使用。</p><pre class="screen">/secret/{application}/{profile}
/secret/{application}
/secret/{default-context}/{profile}
/secret/{default-context}</pre><p>应用程序名称由以下属性确定：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">spring.cloud.vault.generic.application-name</code></li><li class="listitem"><code class="literal">spring.cloud.vault.application-name</code></li><li class="listitem"><code class="literal">spring.application.name</code></li></ul></div><p>可以通过在通用后端中的其他上下文中获取秘密，方法是将其路径添加到应用程序名称中，并用逗号分隔。例如，给定应用程序名称<code class="literal">usefulapp,mysql1,projectx/aws</code> ，将使用以下每个文件夹：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">/secret/usefulapp</code></li><li class="listitem"><code class="literal">/secret/mysql1</code></li><li class="listitem"><code class="literal">/secret/projectx/aws</code></li></ul></div><p>Spring Cloud Vault将所有活动配置文件添加到可能的上下文路径列表中。没有活动的个人资料会跳过使用个人资料名称的访问上下文。</p><p>就像存储属性一样公开属性（即，没有其他前缀）。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    generic</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        profile-separator</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        default-context</span>: application
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        application-name</span>: my-app</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">false</code>禁用秘密后端配置用法</li><li class="listitem"><code class="literal">backend</code>设置要使用的秘密装载的路径</li><li class="listitem"><code class="literal">default-context</code>设置所有应用程序使用的上下文名称</li><li class="listitem"><code class="literal">application-name</code>覆盖在通用后端中使用的应用程序名称</li><li class="listitem"><code class="literal">profile-separator</code>使用配置文件在属性源中将配置文件名称与上下文分开</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>键值秘密后端可以在版本控制（v2）和非版本控制（v1）模式下运行。根据操作模式，需要不同的API来访问机密。确保启用<code class="literal">generic</code>非版本化键值后端的秘密后端用法，以及<code class="literal">kv</code>版本化键值后端的秘密后端用法。</p></td></tr></tbody></table></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/kv/kv-v1.html" target="_top">保管库文档：使用KV秘密引擎-版本1（通用秘密后端）</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.kv.versioned" href="#vault.config.backends.kv.versioned"></a> 103.2版本化键值后端</h2></div></div></div><p>Spring Cloud Vault支持版本化的Key-Value秘密后端。键值后端允许将任意值存储为键值存储。单个上下文可以存储一个或多个键值元组。上下文可以按层次进行组织。Spring Cloud Vault允许使用应用程序名称和默认上下文名称（ <code class="literal">application</code> ）与有效配置文件结合使用。</p><pre class="screen">/secret/{application}/{profile}
/secret/{application}
/secret/{default-context}/{profile}
/secret/{default-context}</pre><p>应用程序名称由以下属性确定：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">spring.cloud.vault.kv.application-name</code></li><li class="listitem"><code class="literal">spring.cloud.vault.application-name</code></li><li class="listitem"><code class="literal">spring.application.name</code></li></ul></div><p>可以通过在键值后端的其他上下文中获取秘密，方法是将其路径添加到应用程序名称中，并用逗号分隔。例如，给定应用程序名称<code class="literal">usefulapp,mysql1,projectx/aws</code> ，将使用以下每个文件夹：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">/secret/usefulapp</code></li><li class="listitem"><code class="literal">/secret/mysql1</code></li><li class="listitem"><code class="literal">/secret/projectx/aws</code></li></ul></div><p>Spring Cloud Vault将所有活动配置文件添加到可能的上下文路径列表中。没有活动的个人资料会跳过使用个人资料名称的访问上下文。</p><p>就像存储属性一样公开属性（即，没有其他前缀）。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Vault添加了<code class="literal">data/</code>安装路径和实际上下文路径之间的上下文。</p></td></tr></tbody></table></div><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    kv</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        profile-separator</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'/'</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        default-context</span>: application
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        application-name</span>: my-app</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">false</code>禁用秘密后端配置用法</li><li class="listitem"><code class="literal">backend</code>设置要使用的秘密装载的路径</li><li class="listitem"><code class="literal">default-context</code>设置所有应用程序使用的上下文名称</li><li class="listitem"><code class="literal">application-name</code>覆盖在通用后端中使用的应用程序名称</li><li class="listitem"><code class="literal">profile-separator</code>使用配置文件在属性源中将配置文件名称与上下文分开</li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>键值秘密后端可以在版本控制（v2）和非版本控制（v1）模式下运行。根据操作模式，需要不同的API来访问机密。确保启用<code class="literal">generic</code>非版本化键值后端的秘密后端用法，以及<code class="literal">kv</code>版本化键值后端的秘密后端用法。</p></td></tr></tbody></table></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/kv/kv-v2.html" target="_top">保管库文档：使用KV Secrets Engine-版本2（版本化的键值后端）</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.consul" href="#vault.config.backends.consul"></a> 103.3领事</h2></div></div></div><p>Spring Cloud Vault可以获取HashiCorp Consul的凭据。领事整合要求<code class="literal">spring-cloud-vault-config-consul</code>依赖性。</p><div class="example"><a name="d0e31550" href="#d0e31550"></a><p class="title"><b>示例103.1 pom.xml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-vault-config-consul<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{project-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre></div></div><br class="example-break"><p>可以通过设置启用集成<code class="literal">spring.cloud.vault.consul.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.consul.role=…</code> 。</p><p>获得的令牌存储在<code class="literal">spring.cloud.consul.token</code>因此使用Spring Cloud Consul无需进一步配置即可获取生成的凭证。您可以通过设置配置属性名称<code class="literal">spring.cloud.vault.consul.token-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    consul</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: consul
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        token-property</span>: spring.cloud.consul.token</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用Consul后端配置用法</li><li class="listitem"><code class="literal">role</code>设置领事角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置使用Consul挂载的路径</li><li class="listitem"><code class="literal">token-property</code>设置存储Consul ACL令牌的属性名称</li></ul></div><p>另请参见： <a class="link" href="https://www.vaultproject.io/docs/secrets/consul/index.html" target="_top">库文件：与库建立领事</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.rabbitmq" href="#vault.config.backends.rabbitmq"></a> 103.4 RabbitMQ</h2></div></div></div><p>Spring Cloud Vault可以获取RabbitMQ的凭据。</p><p>RabbitMQ集成需要<code class="literal">spring-cloud-vault-config-rabbitmq</code>依赖性。</p><div class="example"><a name="d0e31615" href="#d0e31615"></a><p class="title"><b>示例103.2 pom.xml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-vault-config-rabbitmq<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{project-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre></div></div><br class="example-break"><p>可以通过设置启用集成<code class="literal">spring.cloud.vault.rabbitmq.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.rabbitmq.role=…</code> 。</p><p>用户名和密码存储在<code class="literal">spring.rabbitmq.username</code>和<code class="literal">spring.rabbitmq.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.rabbitmq.username-property</code>和<code class="literal">spring.cloud.vault.rabbitmq.password-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    rabbitmq</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: rabbitmq
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        username-property</span>: spring.rabbitmq.username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        password-property</span>: spring.rabbitmq.password</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用RabbitMQ后端配置用法</li><li class="listitem"><code class="literal">role</code>设置RabbitMQ角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的RabbitMQ安装的路径</li><li class="listitem"><code class="literal">username-property</code>设置存储RabbitMQ用户名的属性名称</li><li class="listitem"><code class="literal">password-property</code>设置用于存储RabbitMQ密码的属性名称</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/rabbitmq/index.html" target="_top">Vault文档：使用Vault设置RabbitMQ</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.aws" href="#vault.config.backends.aws"></a> 103.5 AWS</h2></div></div></div><p>Spring Cloud Vault可以获取AWS的凭证。</p><p>AWS集成要求<code class="literal">spring-cloud-vault-config-aws</code>依赖性。</p><div class="example"><a name="d0e31691" href="#d0e31691"></a><p class="title"><b>示例103.3 pom.xml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-vault-config-aws<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{project-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre></div></div><br class="example-break"><p>可以通过设置启用集成<code class="literal">spring.cloud.vault.aws=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.aws.role=…</code> 。</p><p>访问密钥和秘密密钥存储在<code class="literal">cloud.aws.credentials.accessKey</code>和<code class="literal">cloud.aws.credentials.secretKey</code>因此使用Spring Cloud AWS无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.aws.access-key-property</code>和<code class="literal">spring.cloud.vault.aws.secret-key-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    aws</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: aws
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        access-key-property</span>: cloud.aws.credentials.accessKey
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        secret-key-property</span>: cloud.aws.credentials.secretKey</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用AWS后端配置使用</li><li class="listitem"><code class="literal">role</code>设置AWS角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的AWS装载的路径</li><li class="listitem"><code class="literal">access-key-property</code>设置存储AWS访问密钥的属性名称</li><li class="listitem"><code class="literal">secret-key-property</code>设置存储AWS密钥的属性名称</li></ul></div><p>另请参见： <a class="link" href="https://www.vaultproject.io/docs/secrets/aws/index.html" target="_top">库文件：（含保管箱）建立AWS</a></p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault.config.backends.database-backends" href="#vault.config.backends.database-backends"></a> 104。数据库后端</h2></div></div></div><p>Vault支持多个数据库机密后端，以根据配置的角色动态生成数据库凭据。这意味着需要访问数据库的服务不再需要配置凭据：它们可以从Vault请求它们，并使用Vault的租赁机制更轻松地滚动密钥。</p><p>Spring Cloud Vault与以下后端集成：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="xref" href="#vault.config.backends.database" title="104.1数据库">第104.1节“数据库”</a></li><li class="listitem"><a class="xref" href="#vault.config.backends.cassandra" title="104.2 Apache卡桑德拉">第104.2节“ Apache Cassandra”</a></li><li class="listitem"><a class="xref" href="#vault.config.backends.mongodb" title="104.3 MongoDB">第104.3节“ MongoDB”</a></li><li class="listitem"><a class="xref" href="#vault.config.backends.mysql" title="104.4 MySQL">第104.4节“ MySQL”</a></li><li class="listitem"><a class="xref" href="#vault.config.backends.postgresql" title="104.5 PostgreSQL">第104.5节“ PostgreSQL”</a></li></ul></div><p>使用数据库秘密后端需要在配置中启用后端，并且<code class="literal">spring-cloud-vault-config-databases</code>依赖性。</p><p>自0.7.1起，保管箱会专门运送<code class="literal">database</code>允许通过插件集成数据库的秘密后端。您可以通过使用通用数据库后端来使用该特定后端。确保指定适当的后端路径，例如<code class="literal">spring.cloud.vault.mysql.role.backend=database</code> 。</p><div class="example"><a name="d0e31793" href="#d0e31793"></a><p class="title"><b>示例104.1 pom.xml</b></p><div class="example-contents"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-vault-config-databases<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{project-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span></pre></div></div><br class="example-break"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>启用多个JDBC兼容数据库将生成凭据，并且默认情况下将它们存储在相同的属性密钥中，因此需要分别配置JDBC机密的属性名称。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.database" href="#vault.config.backends.database"></a> 104.1数据库</h2></div></div></div><p>Spring Cloud Vault可以获取<a class="link" href="https://www.vaultproject.io/api/secret/databases/index.html" target="_top">https://www.vaultproject.io/api/secret/databases/index.html上</a>列出的任何数据库的凭据。可以通过设置启用集成<code class="literal">spring.cloud.vault.database.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.database.role=…</code> 。</p><p>虽然数据库后端是通用后端， <code class="literal">spring.cloud.vault.database</code>专门针对JDBC数据库。用户名和密码存储在<code class="literal">spring.datasource.username</code>和<code class="literal">spring.datasource.password</code>因此使用Spring Boot将为您获取生成的凭据<code class="literal">DataSource</code>无需进一步配置。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.database.username-property</code>和<code class="literal">spring.cloud.vault.database.password-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    database</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: database
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        username-property</span>: spring.datasource.username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        password-property</span>: spring.datasource.password</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用数据库后端配置用法</li><li class="listitem"><code class="literal">role</code>设置数据库角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的数据库安装路径</li><li class="listitem"><code class="literal">username-property</code>设置存储数据库用户名的属性名称</li><li class="listitem"><code class="literal">password-property</code>设置存储数据库密码的属性名称</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/databases/index.html" target="_top">保管库文档：数据库机密后端</a></p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Vault不支持获取新凭据并配置您的<code class="literal">DataSource</code>与他们达成最大租约时间后。也就是说，如果<code class="literal">max_ttl</code> Vault 中数据库角色的设置为<code class="literal">24h</code>这意味着您的应用程序启动后24小时将无法再通过数据库进行身份验证。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.cassandra" href="#vault.config.backends.cassandra"></a> 104.2 Apache卡桑德拉</h2></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">cassandra</code> Vault 0.7.1已弃用后端，建议使用<code class="literal">database</code>后端并将其安装为<code class="literal">cassandra</code> 。</p></td></tr></tbody></table></div><p>Spring Cloud Vault可以获取Apache Cassandra的凭据。可以通过设置启用集成<code class="literal">spring.cloud.vault.cassandra.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.cassandra.role=…</code> 。</p><p>用户名和密码存储在<code class="literal">spring.data.cassandra.username</code>和<code class="literal">spring.data.cassandra.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.cassandra.username-property</code>和<code class="literal">spring.cloud.vault.cassandra.password-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    cassandra</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: cassandra
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        username-property</span>: spring.data.cassandra.username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        password-property</span>: spring.data.cassandra.password</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用Cassandra后端配置用法</li><li class="listitem"><code class="literal">role</code>设置Cassandra角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的Cassandra安装的路径</li><li class="listitem"><code class="literal">username-property</code>设置存储Cassandra用户名的属性名称</li><li class="listitem"><code class="literal">password-property</code>设置存储Cassandra密码的属性名称</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/cassandra/index.html" target="_top">Vault文档：使用Vault设置Apache Cassandra</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.mongodb" href="#vault.config.backends.mongodb"></a> 104.3 MongoDB</h2></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">mongodb</code> Vault 0.7.1已弃用后端，建议使用<code class="literal">database</code>后端并将其安装为<code class="literal">mongodb</code> 。</p></td></tr></tbody></table></div><p>Spring Cloud Vault可以获取MongoDB的凭据。可以通过设置启用集成<code class="literal">spring.cloud.vault.mongodb.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.mongodb.role=…</code> 。</p><p>用户名和密码存储在<code class="literal">spring.data.mongodb.username</code>和<code class="literal">spring.data.mongodb.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.mongodb.username-property</code>和<code class="literal">spring.cloud.vault.mongodb.password-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    mongodb</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: mongodb
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        username-property</span>: spring.data.mongodb.username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        password-property</span>: spring.data.mongodb.password</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用MongodB后端配置用法</li><li class="listitem"><code class="literal">role</code>设置MongoDB角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的MongoDB安装的路径</li><li class="listitem"><code class="literal">username-property</code>设置存储MongoDB用户名的属性名称</li><li class="listitem"><code class="literal">password-property</code>设置存储MongoDB密码的属性名称</li></ul></div><p>另请参见： <a class="link" href="https://www.vaultproject.io/docs/secrets/mongodb/index.html" target="_top">Vault文档：建立的MongoDB（含保管箱）</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.mysql" href="#vault.config.backends.mysql"></a> 104.4 MySQL</h2></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">mysql</code> Vault 0.7.1已弃用后端，建议使用<code class="literal">database</code>后端并将其安装为<code class="literal">mysql</code> 。配置<code class="literal">spring.cloud.vault.mysql</code>将在以后的版本中删除。</p></td></tr></tbody></table></div><p>Spring Cloud Vault可以获取MySQL的凭据。可以通过设置启用集成<code class="literal">spring.cloud.vault.mysql.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.mysql.role=…</code> 。</p><p>用户名和密码存储在<code class="literal">spring.datasource.username</code>和<code class="literal">spring.datasource.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.mysql.username-property</code>和<code class="literal">spring.cloud.vault.mysql.password-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    mysql</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: mysql
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        username-property</span>: spring.datasource.username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        password-property</span>: spring.datasource.password</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用MySQL后端配置用法</li><li class="listitem"><code class="literal">role</code>设置MySQL角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的MySQL安装的路径</li><li class="listitem"><code class="literal">username-property</code>设置存储MySQL用户名的属性名称</li><li class="listitem"><code class="literal">password-property</code>设置存储MySQL密码的属性名称</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/mysql/index.html" target="_top">保管库文档：使用保管库设置MySQL</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="vault.config.backends.postgresql" href="#vault.config.backends.postgresql"></a> 104.5 PostgreSQL</h2></div></div></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">postgresql</code> Vault 0.7.1已弃用后端，建议使用<code class="literal">database</code>后端并将其安装为<code class="literal">postgresql</code> 。配置<code class="literal">spring.cloud.vault.postgresql</code>将在以后的版本中删除。</p></td></tr></tbody></table></div><p>Spring Cloud Vault可以获取PostgreSQL的凭据。可以通过设置启用集成<code class="literal">spring.cloud.vault.postgresql.enabled=true</code> （默认<code class="literal">false</code> ），并提供角色名称<code class="literal">spring.cloud.vault.postgresql.role=…</code> 。</p><p>用户名和密码存储在<code class="literal">spring.datasource.username</code>和<code class="literal">spring.datasource.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code class="literal">spring.cloud.vault.postgresql.username-property</code>和<code class="literal">spring.cloud.vault.postgresql.password-property</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    postgresql</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        role</span>: readonly
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        backend</span>: postgresql
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        username-property</span>: spring.datasource.username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        password-property</span>: spring.datasource.password</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">enabled</code>将此值设置为<code class="literal">true</code>启用PostgreSQL后端配置用法</li><li class="listitem"><code class="literal">role</code>设置PostgreSQL角色定义的角色名称</li><li class="listitem"><code class="literal">backend</code>设置要使用的PostgreSQL安装的路径</li><li class="listitem"><code class="literal">username-property</code>设置存储PostgreSQL用户名的属性名称</li><li class="listitem"><code class="literal">password-property</code>设置存储PostgreSQL密码的属性名称</li></ul></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/secrets/postgresql/index.html" target="_top">Vault文档：使用Vault设置PostgreSQL</a></p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault.config.backends.configurer" href="#vault.config.backends.configurer"></a> 105。配置<code class="literal">PropertySourceLocator</code>行为</h2></div></div></div><p>Spring Cloud Vault使用基于属性的配置来创建<code class="literal">PropertySource</code>用于通用和发现的秘密后端。</p><p>发现的后端提供<code class="literal">VaultSecretBackendDescriptor</code> bean描述使用秘密后端作为的配置状态<code class="literal">PropertySource</code> 。一种<code class="literal">SecretBackendMetadataFactory</code>需要创建一个<code class="literal">SecretBackendMetadata</code>包含路径，名称和属性转换配置的对象。</p><p><code class="literal">SecretBackendMetadata</code>用于支持特定<code class="literal">PropertySource</code> 。</p><p>您可以注册任意数量的Bean实现<code class="literal">VaultConfigurer</code>用于定制。如果Spring Cloud Vault发现至少一个，则默认的通用和发现的后端注册被禁用<code class="literal">VaultConfigurer</code> bean 。但是，您可以通过以下方式启用默认注册<code class="literal">SecretBackendConfigurer.registerDefaultGenericSecretBackends()</code>和<code class="literal">SecretBackendConfigurer.registerDefaultDiscoveredSecretBackends()</code> 。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomizationBean <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> VaultConfigurer {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> addSecretBackends(SecretBackendConfigurer configurer) {

        configurer.add(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"secret/my-application"</span>);

        configurer.registerDefaultGenericSecretBackends(false);
        configurer.registerDefaultDiscoveredSecretBackends(true);
    }
}</pre></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>所有定制都必须在引导上下文中进行。将配置类添加到<code class="literal">META-INF/spring.factories</code>在<code class="literal">org.springframework.cloud.bootstrap.BootstrapConfiguration</code>在您的应用程序中。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_service_registry_configuration" href="#_service_registry_configuration"></a> 106。服务注册表配置</h2></div></div></div><p>您可以使用<code class="literal">DiscoveryClient</code> （例如来自Spring Cloud Consul）通过设置spring.cloud.vault.discovery.enabled = true（默认值）来定位Vault服务器<code class="literal">false</code> ）。最终结果是您的应用程序需要带有适当发现配置的bootstrap.yml（或环境变量）。好处是，只要发现服务是固定点，保管箱就可以更改其坐标。默认服务ID为<code class="literal">vault</code>但您可以通过以下方式在客户端上进行更改<code class="literal">spring.cloud.vault.discovery.serviceId</code> 。</p><p>发现客户端实现均支持某种元数据映射（例如，对于Eureka，我们拥有eureka.instance.metadataMap）。服务的某些其他属性可能需要在其服务注册元数据中进行配置，以便客户端可以正确连接。没有提供有关传输层安全性详细信息的服务注册表需要提供一个<code class="literal">scheme</code>元数据条目设置为<code class="literal">https</code>要么<code class="literal">http</code> 。如果未配置任何方案，并且该服务未作为安全服务公开，则配置默认为<code class="literal">spring.cloud.vault.scheme</code>这是<code class="literal">https</code>未设置时。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault.discovery</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    service-id</span>: my-vault-service</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault.config.fail-fast" href="#vault.config.fail-fast"></a> 107。Vault Client快速失败</h2></div></div></div><p>在某些情况下，如果服务无法连接到Vault服务器，则可能无法启动服务。如果这是所需的行为，请设置引导程序配置属性<code class="literal">spring.cloud.vault.fail-fast=true</code>并且客户端将因异常而停止。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    fail-fast</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault.config.ssl" href="#vault.config.ssl"></a> 108。Vault Client SSL配置</h2></div></div></div><p>可以通过设置各种属性来声明性地配置SSL。您可以设置<code class="literal">javax.net.ssl.trustStore</code>配置JVM范围的SSL设置，或<code class="literal">spring.cloud.vault.ssl.trust-store</code>仅为Spring Cloud Vault Config设置SSL设置。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    ssl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        trust-store</span>: classpath:keystore.jks
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        trust-store-password</span>: changeit</pre></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">trust-store</code>设置信任库的资源。受SSL保护的保管箱通信将使用指定的信任库验证保管箱SSL证书。</li><li class="listitem"><code class="literal">trust-store-password</code>设置信任库密码</li></ul></div><p>请注意，配置<code class="literal">spring.cloud.vault.ssl.*</code>仅当Apache Http Components或OkHttp客户端在您的类路径上时才可以应用。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="vault-lease-renewal" href="#vault-lease-renewal"></a> 109。租赁生命周期管理（续订和吊销）</h2></div></div></div><p>Vault会利用每个秘密创建一个租约：元数据，其中包含诸如持续时间，可更新性等信息。</p><p>保管箱保证数据在给定的持续时间内或生存时间（TTL）内有效。租约到期后， Vault 可以撤消数据，并且秘密使用方不再可以确定其有效。</p><p>除了创建登录令牌和机密之外，Spring Cloud Vault还维护着租赁生命周期。就是说，与租约相关的登录令牌和机密计划在租约到期之前立即更新，直到终端到期为止。应用程序关闭会撤消获得的登录令牌和可更新的租约。</p><p>秘密服务和数据库后端（例如MongoDB或MySQL）通常会生成可更新的租约，因此在应用程序关闭时将禁用生成的凭据。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>静态令牌不会更新或吊销。</p></td></tr></tbody></table></div><p>租约续订和吊销默认为启用状态，可以通过设置禁用<code class="literal">spring.cloud.vault.config.lifecycle.enabled</code>至<code class="literal">false</code> 。不建议使用此方法，因为租约可能到期，并且Spring Cloud Vault无法再使用生成的凭据访问Vault或服务，并且在应用程序关闭后有效凭据仍处于活动状态。</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.vault</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    config.lifecycle.enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre></div><p>另请参阅： <a class="link" href="https://www.vaultproject.io/docs/concepts/lease.html" target="_top">Vault文档：租赁，续订和吊销</a></p></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_gateway" href="#_spring_cloud_gateway"></a>第十五部分。 Spring Cloud Gateway</h1></div></div></div><div class="partintro"><div></div><p><span class="strong"><strong>格林威治。SR4</strong></span></p><p>该项目提供了一个在Spring生态系统之上构建的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一种简单而有效的方法来路由到API，并为它们提供跨领域的关注，例如：安全性，监视/指标和弹性。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gateway-starter" href="#gateway-starter"></a> 110。如何包括Spring Cloud Gateway</h2></div></div></div><p>要将Spring Cloud Gateway包括在您的项目中，请使用带有以下内容的启动器： <code class="literal">org.springframework.cloud</code>和工件ID <code class="literal">spring-cloud-starter-gateway</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a class="link" href="https://projects.spring.io/spring-cloud/" target="_top">Spring Cloud Project页面</a> 。</p><p>如果包括启动器，但是由于某种原因，您不希望启用网关，请设置<code class="literal">spring.cloud.gateway.enabled=false</code> 。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Gateway是基于<a class="link" href="https://spring.io/projects/spring-boot#learn" target="_top">Spring Boot 2.x</a> ， <a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_top">Spring WebFlux</a>和<a class="link" href="https://projectreactor.io/docs" target="_top">Project Reactor</a> <a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_top">构建的</a> 。因此，在使用Spring Cloud Gateway时，许多不熟悉的同步库（例如，Spring Data和Spring Security）和模式可能不适用。如果您对这些项目不熟悉，建议您在使用Spring Cloud Gateway之前先阅读它们的文档，以熟悉一些新概念。</p></td></tr></tbody></table></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行时。它不能在传统的Servlet容器中或作为WAR构建。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_glossary" href="#_glossary"></a> 111。词汇表</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><span class="strong"><strong>路由</strong></span> ：路由网关的基本构建块。它由ID，目标URI，谓词集合和过滤器集合定义。如果聚合谓词为true，则匹配路由。</li><li class="listitem"><span class="strong"><strong>谓词</strong></span> ：这是<a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html" target="_top">Java 8 Function谓词</a> 。输入类型是<a class="link" href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html" target="_top">Spring Framework <code class="literal">ServerWebExchange</code></a> 。这使开发人员可以匹配HTTP请求中的所有内容，例如标头或参数。</li><li class="listitem"><span class="strong"><strong>筛选器</strong></span> ：这些是<a class="link" href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/GatewayFilter.html" target="_top">Spring Framework 的</a>实例<a class="link" href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/GatewayFilter.html" target="_top"><code class="literal">GatewayFilter</code></a>与特定工厂一起建造。在此，可以在发送下游请求之前或之后修改请求和响应。</li></ul></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gateway-how-it-works" href="#gateway-how-it-works"></a> 112。怎么运行的</h2></div></div></div><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-gateway/master/docs/src/main/asciidoc/images/spring_cloud_gateway_diagram.png" alt="spring-cloud-gateway图"></div></div><p>客户端向Spring Cloud Gateway发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。该处理程序运行通过特定于请求的筛选器链发送请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前或之后执行逻辑。执行所有“前置”过滤器逻辑，然后发出代理请求。发出代理请求后，将执行“发布”过滤器逻辑。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>在没有端口的路由中定义的URI将分别将HTTP和HTTPS URI的默认端口分别设置为80和443。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="gateway-request-predicates-factories" href="#gateway-request-predicates-factories"></a> 113。路线谓词工厂</h2></div></div></div><p>Spring Cloud Gateway将路由作为Spring WebFlux的一部分进行匹配<code class="literal">HandlerMapping</code>基础设施。Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些谓词都与HTTP请求的不同属性匹配。多个路由谓词工厂可以合并，也可以通过逻辑合并<code class="literal">and</code> 。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_after_route_predicate_factory" href="#_after_route_predicate_factory"></a> 113.1路由谓词后工厂</h2></div></div></div><p>After Route Predicate Factory采用一个参数，即日期时间。该谓词匹配在当前日期时间之后发生的请求。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: after_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - After</span>=<span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">20</span>T17:<span class="hl-number">42</span>:<span class="hl-number">47.789</span>-<span class="hl-number">07</span>:<span class="hl-number">00</span>[America/Denver<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>
</p><p>此路线与2017年1月20日17:42山区时间（丹佛）之后的所有请求匹配。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_before_route_predicate_factory" href="#_before_route_predicate_factory"></a> 113.2路由谓词工厂之前</h2></div></div></div><p>路由谓词前工厂采用一个参数，即日期时间。该谓词匹配当前日期时间之前发生的请求。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: before_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Before</span>=<span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">20</span>T17:<span class="hl-number">42</span>:<span class="hl-number">47.789</span>-<span class="hl-number">07</span>:<span class="hl-number">00</span>[America/Denver<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>
</p><p>此路线与2017年1月20日17:42山区时间（丹佛）之前的所有请求匹配。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_between_route_predicate_factory" href="#_between_route_predicate_factory"></a> 113.3路由谓词工厂之间</h2></div></div></div><p>路由谓词间工厂之间有两个参数，datetime1和datetime2。该谓词匹配在datetime1之后和datetime2之前发生的请求。datetime2参数必须在datetime1之后。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: between_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Between</span>=<span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">20</span>T17:<span class="hl-number">42</span>:<span class="hl-number">47.789</span>-<span class="hl-number">07</span>:<span class="hl-number">00</span>[America/Denver]<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> <span class="hl-number">2017</span>-<span class="hl-number">01</span>-<span class="hl-number">21</span>T17:<span class="hl-number">42</span>:<span class="hl-number">47.789</span>-<span class="hl-number">07</span>:<span class="hl-number">00</span>[America/Denver<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>
</p><p>此路线与2017年1月20日山区时间（丹佛）之后和2017年1月21日17:42山时间（丹佛）之后的所有请求匹配。这对于维护时段可能很有用。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_cookie_route_predicate_factory" href="#_cookie_route_predicate_factory"></a> 113.4 Cookie路线谓词工厂</h2></div></div></div><p>Cookie Route Predicate Factory采用两个参数，即cookie名称和正则表达式。该谓词匹配具有给定名称的cookie，并且值匹配正则表达式。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: cookie_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Cookie</span>=chocolate<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> ch.p</pre><p>
</p><p>此路线与请求匹配，且有一个名为<code class="literal">chocolate</code>谁的价值与<code class="literal">ch.p</code>正则表达式。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_header_route_predicate_factory" href="#_header_route_predicate_factory"></a> 113.5标头路由谓词工厂</h2></div></div></div><p>标头路由谓词工厂采用两个参数，标头名称和正则表达式。该谓词与具有给定名称的标头匹配，并且值与正则表达式匹配。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Header</span>=X-Request-Id<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> \d+</pre><p>
</p><p>如果请求的标题为，则此路由匹配<code class="literal">X-Request-Id</code>谁的值与<code class="literal">\d+</code>正则表达式（具有一个或多个数字的值）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_host_route_predicate_factory" href="#_host_route_predicate_factory"></a> 113.6主机路由谓词工厂</h2></div></div></div><p>主机路由谓词工厂采用一个参数：主机名模式列表。该模式是具有<code class="literal">.</code>作为分隔符。这个谓词匹配<code class="literal">Host</code>与模式匹配的标题。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: host_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Host</span>=**.somehost.org,**.anotherhost.org</pre><p>
</p><p>URI模板变量也受支持，例如<code class="literal">{sub}.myhost.org</code> 。</p><p>如果请求中包含一个<code class="literal">Host</code>标头具有值<code class="literal">www.somehost.org</code>要么<code class="literal">beta.somehost.org</code>要么<code class="literal">www.anotherhost.org</code> 。</p><p>该谓词提取URI模板变量（例如<code class="literal">sub</code>在上面的示例中定义）作为名称和值的映射，并将其放置在<code class="literal">ServerWebExchange.getAttributes()</code>用定义在<code class="literal">ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code> 。这些值可供<a class="link" href="#gateway-route-filters">GatewayFilter工厂</a>使用。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_method_route_predicate_factory" href="#_method_route_predicate_factory"></a> 113.7方法路线谓词工厂</h2></div></div></div><p>方法路由谓词工厂使用一个参数：要匹配的HTTP方法。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: method_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Method</span>=GET</pre><p>
</p><p>如果请求方法是<code class="literal">GET</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_path_route_predicate_factory" href="#_path_route_predicate_factory"></a> 113.8路径路线谓词工厂</h2></div></div></div><p>路径路由谓词工厂采用两个参数：Spring列表<code class="literal">PathMatcher</code>模式和一个可选标志<code class="literal">matchOptionalTrailingSeparator</code> 。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: host_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/foo/{segment},/bar/{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>如果请求路径为，则此路由将匹配，例如： <code class="literal">/foo/1</code>要么<code class="literal">/foo/bar</code>要么<code class="literal">/bar/baz</code> 。</p><p>该谓词提取URI模板变量（例如<code class="literal">segment</code>在上面的示例中定义）作为名称和值的映射，并将其放置在<code class="literal">ServerWebExchange.getAttributes()</code>用定义在<code class="literal">ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code> 。这些值然后可用于使用<a class="link" href="#gateway-route-filters">GatewayFilter工厂</a></p><p>可以使用实用程序方法来简化对这些变量的访问。</p><pre class="programlisting">Map&lt;String, String&gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);

String segment = uriVariables.get(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"segment"</span>);</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_query_route_predicate_factory" href="#_query_route_predicate_factory"></a> 113.9查询路由谓词工厂</h2></div></div></div><p>查询路由谓词工厂采用两个参数：必需<code class="literal">param</code>和一个可选的<code class="literal">regexp</code> 。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: query_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Query</span>=baz</pre><p>
</p><p>如果请求包含一个<code class="literal">baz</code>查询参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: query_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Query</span>=foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> ba.</pre><p>
</p><p>如果请求包含一个<code class="literal">foo</code>查询参数，其值与<code class="literal">ba.</code>正则表达式<code class="literal">bar</code>和<code class="literal">baz</code>会匹配。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_remoteaddr_route_predicate_factory" href="#_remoteaddr_route_predicate_factory"></a> 113.10 RemoteAddr路由谓词工厂</h2></div></div></div><p>RemoteAddr路由谓词工厂采用CIDR标记（IPv4或IPv6）字符串的列表（最小大小为1），例如<code class="literal">192.168.0.1/16</code> （哪里<code class="literal">192.168.0.1</code>是IP地址， <code class="literal">16</code>是子网掩码）。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: remoteaddr_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RemoteAddr</span>=<span class="hl-number">192.168</span>.<span class="hl-number">1.1</span>/<span class="hl-number">24</span></pre><p>
</p><p>例如，如果请求的远程地址是<code class="literal">192.168.1.10</code> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_modifying_the_way_remote_addresses_are_resolved" href="#_modifying_the_way_remote_addresses_are_resolved"></a> 113.10.1修改解析远程地址的方式</h3></div></div></div><p>默认情况下，RemoteAddr路由谓词工厂使用传入请求中的远程地址。如果Spring Cloud Gateway位于代理层后面，则此地址可能与实际的客户端IP地址不匹配。</p><p>您可以通过设置自定义来自定义解析远程地址的方式<code class="literal">RemoteAddressResolver</code> 。Spring Cloud Gateway随附了一个基于<a class="link" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For" target="_top">X-Forwarded-For标头的</a>非默认远程地址解析器， <code class="literal">XForwardedRemoteAddressResolver</code> 。</p><p><code class="literal">XForwardedRemoteAddressResolver</code>有两种静态构造方法，它们采用不同的安全性方法：</p><p><code class="literal">XForwardedRemoteAddressResolver::trustAll</code>返回一个<code class="literal">RemoteAddressResolver</code>它始终采用在<code class="literal">X-Forwarded-For</code>标头。这种方法很容易受到欺骗，因为恶意客户端可以为<code class="literal">X-Forwarded-For</code>解析器将接受。</p><p><code class="literal">XForwardedRemoteAddressResolver::maxTrustedIndex</code>取得与Spring Cloud Gateway前面运行的受信任基础架构数量相关的索引。例如，如果只能通过HAProxy访问Spring Cloud Gateway，则应使用值1。如果在访问Spring Cloud Gateway之前需要两跳可信基础架构，则应使用值2。</p><p>给定以下标头值：</p><pre class="screen">X-Forwarded-For: 0.0.0.1, 0.0.0.2, 0.0.0.3</pre><p>的<code class="literal">maxTrustedIndex</code>下面的值将产生以下远程地址。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><code class="literal">maxTrustedIndex</code></th><th align="left" valign="top" style="border-bottom:1px solid">结果</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[ <code class="literal">Integer.MIN_VALUE</code> ，0]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>（无效， <code class="literal">IllegalArgumentException</code>在初始化期间）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0.0.0.3</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0.0.0.2</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>3</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0.0.0.1</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>[4， <code class="literal">Integer.MAX_VALUE</code> ]</p></td><td align="left" valign="top"><p>0.0.0.1</p></td></tr></tbody></table></div><p><a name="gateway-route-filters" href="#gateway-route-filters"></a>使用Java配置：</p><p>网关配置文件</p><pre class="programlisting">RemoteAddressResolver resolver = XForwardedRemoteAddressResolver
    .maxTrustedIndex(<span class="hl-number">1</span>);

...

.route(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"direct-route"</span>,
    r -&gt; r.remoteAddr(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"10.1.1.1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"10.10.1.1/24"</span>)
        .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://downstream1"</span>)
.route(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"proxied-route"</span>,
    r -&gt; r.remoteAddr(resolver,  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"10.10.1.1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"10.10.1.1/24"</span>)
        .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://downstream2"</span>)
)</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_gatewayfilter_factories" href="#_gatewayfilter_factories"></a> 114。GatewayFilter工厂</h2></div></div></div><p>路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路由过滤器适用于特定路由。Spring Cloud Gateway包括许多内置的GatewayFilter工厂。</p><p>注意有关如何使用以下任何过滤器的更多详细示例，请查看<a class="link" href="https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-core/src/test/java/org/springframework/cloud/gateway/filter/factory" target="_top">单元测试</a> 。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_addrequestheader_gatewayfilter_factory" href="#_addrequestheader_gatewayfilter_factory"></a> 114.1 AddRequestHeader GatewayFilter工厂</h2></div></div></div><p>AddRequestHeader GatewayFilter工厂采用名称和值参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: add_request_header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - AddRequestHeader</span>=X-Request-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Bar</pre><p>
</p><p>这将添加<code class="literal">X-Request-Foo:Bar</code>所有匹配请求的下游请求标头的标头。</p><p>AddRequestHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: add_request_header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/foo/{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - AddRequestHeader</span>=X-Request-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Bar-{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_addrequestparameter_gatewayfilter_factory" href="#_addrequestparameter_gatewayfilter_factory"></a> 114.2 AddRequestParameter GatewayFilter工厂</h2></div></div></div><p>AddRequestParameter GatewayFilter工厂采用名称和值参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: add_request_parameter_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - AddRequestParameter</span>=foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> bar</pre><p>
</p><p>这将添加<code class="literal">foo=bar</code>所有匹配请求的下游请求的查询字符串。</p><p>AddRequestParameter知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: add_request_parameter_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Host</span>: {segment}.myhost.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - AddRequestParameter</span>=foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> bar-{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_addresponseheader_gatewayfilter_factory" href="#_addresponseheader_gatewayfilter_factory"></a> 114.3 AddResponseHeader GatewayFilter工厂</h2></div></div></div><p>AddResponseHeader GatewayFilter工厂采用名称和值参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: add_response_header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - AddResponseHeader</span>=X-Response-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Bar</pre><p>
</p><p>这将添加<code class="literal">X-Response-Foo:Bar</code>所有匹配请求的下游响应的标头的标头。</p><p>AddResponseHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: add_response_header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Host</span>: {segment}.myhost.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - AddResponseHeader</span>=foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> bar-{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_deduperesponseheader_gatewayfilter_factory" href="#_deduperesponseheader_gatewayfilter_factory"></a> 114.4 DedupeResponseHeader GatewayFilter工厂</h2></div></div></div><p>DedupeResponseHeader GatewayFilter工厂需要一个<code class="literal">name</code>参数和可选<code class="literal">strategy</code>参数。 <code class="literal">name</code>可以包含标题名称列表，以空格分隔。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: dedupe_response_header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - DedupeResponseHeader</span>=Access-Control-Allow-Credentials Access-Control-Allow-Origin</pre><p>
</p><p>这将删除重复的值<code class="literal">Access-Control-Allow-Credentials</code>和<code class="literal">Access-Control-Allow-Origin</code>网关CORS逻辑和下游CORS逻辑都添加它们时的响应头。</p><p>DedupeResponseHeader过滤器还接受可选<code class="literal">strategy</code>参数。可接受的值为<code class="literal">RETAIN_FIRST</code> （默认）， <code class="literal">RETAIN_LAST</code>和<code class="literal">RETAIN_UNIQUE</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="hystrix" href="#hystrix"></a> 114.5 Hystrix GatewayFilter工厂</h2></div></div></div><p><a class="link" href="https://github.com/Netflix/Hystrix" target="_top">Hystrix</a>是Netflix的一个库，用于实现<a class="link" href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_top">断路器模式</a> 。Hystrix GatewayFilter允许您将断路器引入网关路由，从而保护您的服务免受级联故障的影响，并允许您在下游故障的情况下提供后备响应。</p><p>要在您的项目中启用Hystrix GatewayFilters，请添加对<code class="literal">spring-cloud-starter-netflix-hystrix</code>来自<a class="link" href="https://cloud.spring.io/spring-cloud-netflix/" target="_top">Spring Cloud Netflix</a> 。</p><p>Hystrix GatewayFilter工厂需要一个<code class="literal">name</code>参数，它是名称<code class="literal">HystrixCommand</code> 。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: hystrix_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Hystrix</span>=myCommandName</pre><p>
</p><p>这会将剩余的过滤器包装在<code class="literal">HystrixCommand</code>带有命令名称<code class="literal">myCommandName</code> 。</p><p>Hystrix过滤器也可以接受可选<code class="literal">fallbackUri</code>参数。目前，只有<code class="literal">forward:</code>支持计划的URI。如果调用了后备，则请求将被转发到与URI相匹配的控制器。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: hystrix_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: lb://backing-service:<span class="hl-number">8088</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/consumingserviceendpoint
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: Hystrix
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            name</span>: fallbackcmd
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            fallbackUri</span>: forward:/incaseoffailureusethis
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RewritePath</span>=/consumingserviceendpoint<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> /backingserviceendpoint</pre><p>
</p><p>这将转发给<code class="literal">/incaseoffailureusethis</code>调用Hystrix后备时的URI。请注意，此示例还通过展示了（可选）Spring Cloud Netflix Ribbon负载平衡。 <code class="literal">lb</code>目标URI上的前缀。</p><p>主要方案是使用<code class="literal">fallbackUri</code>到网关应用程序中的内部控制器或处理程序。但是，也可以将请求重新路由到外部应用程序中的控制器或处理程序，如下所示：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: ingredients
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: lb://ingredients
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=//ingredients/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: Hystrix
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            name</span>: fetchIngredients
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            fallbackUri</span>: forward:/fallback
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: ingredients-fallback
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://localhost:<span class="hl-number">9994</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/fallback</pre><p>
</p><p>在这个例子中，没有<code class="literal">fallback</code>网关应用程序中的端点或处理程序，但是，另一个应用程序中有一个端点或处理程序，在<code class="literal"><a class="link" href="http://localhost:9994" target="_top">http://localhost:9994</a></code> 。</p><p>如果将请求转发给后备，Hystrix网关过滤器还会提供<code class="literal">Throwable</code>造成了它。它已添加到<code class="literal">ServerWebExchange</code>作为<code class="literal">ServerWebExchangeUtils.HYSTRIX_EXECUTION_EXCEPTION_ATTR</code>在网关应用程序中处理后备时可以使用的属性。</p><p>对于外部控制器/处理程序方案，可以添加带有异常详细信息的标头。您可以在<a class="link" href="#fallback-headers" title="114.6 FallbackHeaders GatewayFilter工厂">FallbackHeaders GatewayFilter Factory部分中</a>找到有关它的更多信息。</p><p>Hystrix设置（例如超时）可以使用全局默认值配置，也可以使用<a class="link" href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_top">Hystrix Wiki</a>上说明的应用程序属性在<a class="link" href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_top">逐条</a>路由的基础上进行配置。</p><p>要为上述示例路由设置5秒超时，将使用以下配置：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">hystrix.command.fallbackcmd.execution.isolation.thread.timeoutInMilliseconds</span>: <span class="hl-number">5000</span></pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="fallback-headers" href="#fallback-headers"></a> 114.6 FallbackHeaders GatewayFilter工厂</h2></div></div></div><p>的<code class="literal">FallbackHeaders</code>工厂允许您在转发到请求的请求的标头中添加Hystrix执行异常详细信息<code class="literal">fallbackUri</code>在外部应用程序中，例如在以下情况下：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: ingredients
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: lb://ingredients
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=//ingredients/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: Hystrix
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            name</span>: fetchIngredients
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            fallbackUri</span>: forward:/fallback
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: ingredients-fallback
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://localhost:<span class="hl-number">9994</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/fallback
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: FallbackHeaders
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            executionExceptionTypeHeaderName</span>: Test-Header</pre><p>
</p><p>在此示例中，在运行<code class="literal">HystrixCommand</code> ，该请求将转发给<code class="literal">fallback</code>在上运行的应用程序中的终结点或处理程序<code class="literal">localhost:9994</code> 。具有异常类型，消息和-if available-根本原因异常类型和消息的标头将由<code class="literal">FallbackHeaders</code>过滤。</p><p>通过设置下面列出的参数的值及其默认值，可以在配置中覆盖标头的名称：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">executionExceptionTypeHeaderName</code> （ <code class="literal">"Execution-Exception-Type"</code> ）</li><li class="listitem"><code class="literal">executionExceptionMessageHeaderName</code> （ <code class="literal">"Execution-Exception-Message"</code> ）</li><li class="listitem"><code class="literal">rootCauseExceptionTypeHeaderName</code> （ <code class="literal">"Root-Cause-Exception-Type"</code> ）</li><li class="listitem"><code class="literal">rootCauseExceptionMessageHeaderName</code> （ <code class="literal">"Root-Cause-Exception-Message"</code> ）</li></ul></div><p>您可以在<a class="link" href="#hystrix" title="114.5 Hystrix GatewayFilter工厂">Hystrix GatewayFilter Factory部分中</a>找到有关Hystrix如何与Gateway一起工作的更多信息。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_maprequestheader_gatewayfilter_factory" href="#_maprequestheader_gatewayfilter_factory"></a> 114.7 MapRequestHeader GatewayFilter工厂</h2></div></div></div><p>MapRequestHeader GatewayFilter工厂采用'fromHeader'和'toHeader'参数。它创建一个新的命名标头（toHeader），并从传入的HTTP请求中从一个现有的命名标头（fromHeader）中提取值。如果输入标头不存在，则过滤器不起作用。如果新的命名标头已经存在，则其值将使用新值进行扩充。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: map_request_header_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - MapRequestHeader</span>=Bar<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> X-Request-Foo</pre><p>
</p><p>这将添加<code class="literal">X-Request-Foo:<values></code>下游请求的标头，其中包含传入的http请求的更新值<code class="literal">Bar</code>标头。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_prefixpath_gatewayfilter_factory" href="#_prefixpath_gatewayfilter_factory"></a> 114.8 PrefixPath GatewayFilter工厂</h2></div></div></div><p>PrefixPath GatewayFilter工厂需要一个<code class="literal">prefix</code>参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: prefixpath_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - PrefixPath</span>=/mypath</pre><p>
</p><p>这将前缀<code class="literal">/mypath</code>到所有匹配请求的路径。所以要求<code class="literal">/hello</code> ，将被发送到<code class="literal">/mypath/hello</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_preservehostheader_gatewayfilter_factory" href="#_preservehostheader_gatewayfilter_factory"></a> 114.9 PreserveHostHeader GatewayFilter工厂</h2></div></div></div><p>PreserveHostHeader GatewayFilter工厂没有参数。此过滤器设置一个请求属性，路由过滤器将检查该请求属性以确定是否应发送原始主机头，而不是由HTTP客户端确定的主机头。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: preserve_host_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
        - PreserveHostHeader</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_requestratelimiter_gatewayfilter_factory" href="#_requestratelimiter_gatewayfilter_factory"></a> 114.10 RequestRateLimiter GatewayFilter工厂</h2></div></div></div><p>RequestRateLimiter GatewayFilter工厂使用<code class="literal">RateLimiter</code>确定当前请求是否被允许进行的实现。如果不是，则状态为<code class="literal">HTTP 429 - Too Many Requests</code> （默认）返回。</p><p>该过滤器需要一个可选的<code class="literal">keyResolver</code>参数和速率限制器特定的参数（请参见下文）。</p><p><code class="literal">keyResolver</code>是实现了<code class="literal">KeyResolver</code>接口。在配置中，使用SpEL按名称引用bean。 <code class="literal">#{@myKeyResolver}</code>是SpEL表达式，其引用具有以下名称的bean <code class="literal">myKeyResolver</code> 。</p><p><b>KeyResolver.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> KeyResolver {
	Mono&lt;String&gt; resolve(ServerWebExchange exchange);
}</pre><p>
</p><p>的<code class="literal">KeyResolver</code>接口允许可插拔策略派生用于限制请求的密钥。在未来的里程碑中，将会有一些<code class="literal">KeyResolver</code>实现。</p><p>默认实现<code class="literal">KeyResolver</code>是个<code class="literal">PrincipalNameKeyResolver</code>检索<code class="literal">Principal</code>来自<code class="literal">ServerWebExchange</code>和电话<code class="literal">Principal.getName()</code> 。</p><p>默认情况下，如果<code class="literal">KeyResolver</code>找不到密钥，请求将被拒绝。可以使用<code class="literal">spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key</code> （对或错）和<code class="literal">spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code</code>属性。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>无法通过“快捷方式”符号配置RequestRateLimiter。以下示例<span class="emphasis"><em>无效</em></span></p></td></tr></tbody></table></div><p><b>application.properties。</b>
</p><pre class="screen"># INVALID SHORTCUT CONFIGURATION
spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=2, 2, #{@userkeyresolver}</pre><p>
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_redis_ratelimiter" href="#_redis_ratelimiter"></a> 114.10.1 Redis RateLimiter</h3></div></div></div><p>redis实现基于<a class="link" href="https://stripe.com/blog/rate-limiters" target="_top">Stripe</a>所做的工作。它需要使用<code class="literal">spring-boot-starter-data-redis-reactive</code> Spring Boot启动器。</p><p>使用的算法是<a class="link" href="https://en.wikipedia.org/wiki/Token_bucket" target="_top">令牌桶算法</a> 。</p><p>的<code class="literal">redis-rate-limiter.replenishRate</code>是您希望用户每秒允许多少个请求，而没有任何丢弃的请求。这是令牌桶被填充的速率。</p><p>的<code class="literal">redis-rate-limiter.burstCapacity</code>是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以容纳的令牌数。将此值设置为零将阻止所有请求。</p><p>通过设置相同的值可以实现稳定的速率<code class="literal">replenishRate</code>和<code class="literal">burstCapacity</code> 。通过设置可以允许临时连拍<code class="literal">burstCapacity</code>比......高<code class="literal">replenishRate</code> 。在这种情况下，速率限制器需要在两次突发之间留出一些时间（根据<code class="literal">replenishRate</code> ），因为连续2次突发会导致请求丢弃（ <code class="literal">HTTP 429 - Too Many Requests</code> ）。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: requestratelimiter_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: RequestRateLimiter
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            redis-rate-limiter.replenishRate</span>: <span class="hl-number">10</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            redis-rate-limiter.burstCapacity</span>: <span class="hl-number">20</span></pre><p>
</p><p><b>Config.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
KeyResolver userKeyResolver() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"user"</span>));
}</pre><p>
</p><p>这定义了每个用户10的请求速率限制。允许20个突发，但是下一秒只有10个请求可用。的<code class="literal">KeyResolver</code>是一个简单的<code class="literal">user</code>请求参数（注意：不建议在生产中使用）。</p><p>速率限制器也可以定义为实现<code class="literal">RateLimiter</code>接口。在配置中，使用SpEL按名称引用bean。 <code class="literal">#{@myRateLimiter}</code>是SpEL表达式，其引用具有以下名称的bean <code class="literal">myRateLimiter</code> 。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: requestratelimiter_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: RequestRateLimiter
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            rate-limiter</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"#{@myRateLimiter}"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            key-resolver</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"#{@userKeyResolver}"</span></pre><p>
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_redirectto_gatewayfilter_factory" href="#_redirectto_gatewayfilter_factory"></a> 114.11重定向到GatewayFilter工厂</h2></div></div></div><p>RedirectTo GatewayFilter工厂需要一个<code class="literal">status</code>和一个<code class="literal">url</code>参数。状态应该是300系列重定向http代码，例如301。该网址应为有效的网址。这将是<code class="literal">Location</code>标头。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: prefixpath_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RedirectTo</span>=<span class="hl-number">302</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> https://acme.org</pre><p>
</p><p>这将发送状态302和<code class="literal">Location:https://acme.org</code>标头以执行重定向。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_removehopbyhopheadersfilter_gatewayfilter_factory" href="#_removehopbyhopheadersfilter_gatewayfilter_factory"></a> 114.12 RemoveHopByHopHeadersFilter GatewayFilter工厂</h2></div></div></div><p>RemoveHopByHopHeadersFilter GatewayFilter工厂从转发的请求中删除标头。删除的头的默认列表来自<a class="link" href="https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3" target="_top">IETF</a> 。</p><div class="itemizedlist"><p class="title"><b>默认删除的标题是：</b></p><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">连接</li><li class="listitem">活着</li><li class="listitem">代理验证</li><li class="listitem">代理授权</li><li class="listitem">TE</li><li class="listitem">预告片</li><li class="listitem">传输编码</li><li class="listitem">升级</li></ul></div><p>要更改此设置，请设置<code class="literal">spring.cloud.gateway.filter.remove-non-proxy-headers.headers</code>属性以删除标题名称列表。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_removerequestheader_gatewayfilter_factory" href="#_removerequestheader_gatewayfilter_factory"></a> 114.13 RemoveRequestHeader GatewayFilter工厂</h2></div></div></div><p>RemoveRequestHeader GatewayFilter工厂需要一个<code class="literal">name</code>参数。它是要删除的标题的名称。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: removerequestheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RemoveRequestHeader</span>=X-Request-Foo</pre><p>
</p><p>这将删除<code class="literal">X-Request-Foo</code>标头发送到下游之前。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_removeresponseheader_gatewayfilter_factory" href="#_removeresponseheader_gatewayfilter_factory"></a> 114.14 RemoveResponseHeader GatewayFilter工厂</h2></div></div></div><p>RemoveResponseHeader GatewayFilter工厂需要一个<code class="literal">name</code>参数。它是要删除的标题的名称。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: removeresponseheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RemoveResponseHeader</span>=X-Response-Foo</pre><p>
</p><p>这将删除<code class="literal">X-Response-Foo</code>响应的标头，然后返回给网关客户端。</p><p>要删除任何类型的敏感标头，应为可能需要的任何路由配置此过滤器。此外，您可以使用一次配置此过滤器<code class="literal">spring.cloud.gateway.default-filters</code>并将其应用于所有路线。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rewritepath_gatewayfilter_factory" href="#_rewritepath_gatewayfilter_factory"></a> 114.15 RewritePath GatewayFilter工厂</h2></div></div></div><p>RewritePath GatewayFilter工厂采用路径<code class="literal">regexp</code>参数和一个<code class="literal">replacement</code>参数。这使用Java正则表达式提供了一种灵活的方式来重写请求路径。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: rewritepath_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/foo/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RewritePath</span>=/foo(?&lt;segment&gt;/?.*)<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> $\{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>对于的请求路径<code class="literal">/foo/bar</code> ，这会将路径设置为<code class="literal">/bar</code>在发出下游请求之前。注意<code class="literal">$\</code>被替换为<code class="literal">$</code>由于YAML规范。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rewritelocationresponseheader_gatewayfilter_factory" href="#_rewritelocationresponseheader_gatewayfilter_factory"></a> 114.16 RewriteLocationResponseHeader GatewayFilter工厂</h2></div></div></div><p>RewriteLocationResponseHeader GatewayFilter Factory修改的值<code class="literal">Location</code>响应标头，通常摆脱后端特定的细节。它需要<code class="literal">stripVersionMode</code> ， <code class="literal">locationHeaderName</code> ， <code class="literal">hostValue</code>和<code class="literal">protocolsRegex</code>参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: rewritelocationresponseheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RewriteLocationResponseHeader</span>=AS_IN_REQUEST<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Location<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span></pre><p>
</p><p>例如，对于一个请求<code class="literal">POST <a class="link" href="https://api.example.com/some/object/name" target="_top">https://api.example.com/some/object/name</a></code> ， <code class="literal">Location</code>响应头值<code class="literal"><a class="link" href="https://object-service.prod.example.net/v2/some/object/id" target="_top">https://object-service.prod.example.net/v2/some/object/id</a></code>将被重写为<code class="literal"><a class="link" href="https://api.example.com/some/object/id" target="_top">https://api.example.com/some/object/id</a></code> 。</p><p>参数<code class="literal">stripVersionMode</code>具有以下可能的值： <code class="literal">NEVER_STRIP</code> ， <code class="literal">AS_IN_REQUEST</code> （默认）， <code class="literal">ALWAYS_STRIP</code> 。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">NEVER_STRIP</code> -即使原始请求路径不包含任何版本，也不会剥离版本</li><li class="listitem"><code class="literal">AS_IN_REQUEST</code> -仅当原始请求路径不包含版本时，版本才会被剥离</li><li class="listitem"><code class="literal">ALWAYS_STRIP</code> -即使原始请求路径包含版本，也会删除版本</li></ul></div><p>参数<code class="literal">hostValue</code> （如果提供），将用于替换<code class="literal">host:port</code>响应的一部分<code class="literal">Location</code>标头。如果未提供，则<code class="literal">Host</code>请求标头将被使用。</p><p>参数<code class="literal">protocolsRegex</code>必须是有效的正则表达式<code class="literal">String</code> ，协议名称将与之匹配。如果不匹配，过滤器将不执行任何操作。默认为<code class="literal">http|https|ftp|ftps</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_rewriteresponseheader_gatewayfilter_factory" href="#_rewriteresponseheader_gatewayfilter_factory"></a> 114.17 RewriteResponseHeader GatewayFilter工厂</h2></div></div></div><p>RewriteResponseHeader GatewayFilter工厂需要<code class="literal">name</code> ， <code class="literal">regexp</code>和<code class="literal">replacement</code>参数。它使用Java正则表达式以灵活的方式重写响应标头值。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: rewriteresponseheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - RewriteResponseHeader</span>=X-Response-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> password=[^&amp;]+<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> password=***</pre><p>
</p><p>标头值为<code class="literal">/42?user=ford&password=omg!what&flag=true</code> ，它将设置为<code class="literal">/42?user=ford&password=***&flag=true</code>发出下游请求后。请用<code class="literal">$\</code>意思是<code class="literal">$</code>由于YAML规范。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_savesession_gatewayfilter_factory" href="#_savesession_gatewayfilter_factory"></a> 114.18 SaveSession GatewayFilter工厂</h2></div></div></div><p>SaveSession GatewayFilter工厂强制执行<code class="literal">WebSession::save</code> <span class="emphasis"><em>在</em></span>将呼叫转接到下游<span class="emphasis"><em>之前进行</em></span>操作。这在将诸如<a class="link" href="https://projects.spring.io/spring-session/" target="_top">Spring Session之类的内容</a>与惰性数据存储一起使用时特别有用，并且需要确保在进行转发呼叫之前已保存会话状态。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: save_session
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/foo/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
        - SaveSession</pre><p>
</p><p>如果您将<a class="link" href="https://projects.spring.io/spring-security/" target="_top">Spring Security</a>与Spring Session集成在一起，并且想要确保安全性详细信息已转发到远程进程，那么这一点至关重要。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_secureheaders_gatewayfilter_factory" href="#_secureheaders_gatewayfilter_factory"></a> 114.19 SecureHeaders GatewayFilter工厂</h2></div></div></div><p>该SecureHeaders GatewayFilter厂增加了一些头在从建议的答复<a class="link" href="https://blog.appcanary.com/2017/http-security-headers.html" target="_top">这个博客帖子</a> 。</p><div class="itemizedlist"><p class="title"><b>添加了以下标头（以及默认值）：</b></p><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">X-Xss-Protection:1; mode=block</code></li><li class="listitem"><code class="literal">Strict-Transport-Security:max-age=631138519</code></li><li class="listitem"><code class="literal">X-Frame-Options:DENY</code></li><li class="listitem"><code class="literal">X-Content-Type-Options:nosniff</code></li><li class="listitem"><code class="literal">Referrer-Policy:no-referrer</code></li><li class="listitem"><code class="literal">Content-Security-Policy:default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline'</code></li><li class="listitem"><code class="literal">X-Download-Options:noopen</code></li><li class="listitem"><code class="literal">X-Permitted-Cross-Domain-Policies:none</code></li></ul></div><p>要更改默认值，请在<code class="literal">spring.cloud.gateway.filter.secure-headers</code>命名空间：</p><div class="itemizedlist"><p class="title"><b>要更改的属性：</b></p><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">xss-protection-header</code></li><li class="listitem"><code class="literal">strict-transport-security</code></li><li class="listitem"><code class="literal">frame-options</code></li><li class="listitem"><code class="literal">content-type-options</code></li><li class="listitem"><code class="literal">referrer-policy</code></li><li class="listitem"><code class="literal">content-security-policy</code></li><li class="listitem"><code class="literal">download-options</code></li><li class="listitem"><code class="literal">permitted-cross-domain-policies</code></li></ul></div><p>要禁用默认值，请设置属性<code class="literal">spring.cloud.gateway.filter.secure-headers.disable</code>用逗号分隔的值。</p><p><b>例：</b><code class="literal">spring.cloud.gateway.filter.secure-headers.disable=frame-options,download-options</code></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_setpath_gatewayfilter_factory" href="#_setpath_gatewayfilter_factory"></a> 114.20 SetPath GatewayFilter工厂</h2></div></div></div><p>SetPath GatewayFilter工厂采用路径<code class="literal">template</code>参数。通过允许路径的模板段，它提供了一种操作请求路径的简单方法。这使用了Spring Framework中的uri模板。允许多个匹配段。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setpath_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/foo/{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetPath</span>=/{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p><p>对于的请求路径<code class="literal">/foo/bar</code> ，这会将路径设置为<code class="literal">/bar</code>在发出下游请求之前。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_setrequestheader_gatewayfilter_factory" href="#_setrequestheader_gatewayfilter_factory"></a> 114.21 SetRequestHeader GatewayFilter工厂</h2></div></div></div><p>SetRequestHeader GatewayFilter工厂需要<code class="literal">name</code>和<code class="literal">value</code>参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setrequestheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetRequestHeader</span>=X-Request-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Bar</pre><p>
</p><p>该GatewayFilter用给定的名称替换所有标头，而不是添加。因此，如果下游服务器以<code class="literal">X-Request-Foo:1234</code> ，它将被替换为<code class="literal">X-Request-Foo:Bar</code> ，这是下游服务将收到的。</p><p>SetRequestHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setrequestheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Host</span>: {segment}.myhost.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetRequestHeader</span>=foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> bar-{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_setresponseheader_gatewayfilter_factory" href="#_setresponseheader_gatewayfilter_factory"></a> 114.22 SetResponseHeader GatewayFilter工厂</h2></div></div></div><p>SetResponseHeader GatewayFilter工厂需要<code class="literal">name</code>和<code class="literal">value</code>参数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setresponseheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetResponseHeader</span>=X-Response-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Bar</pre><p>
</p><p>该GatewayFilter用给定的名称替换所有标头，而不是添加。因此，如果下游服务器以<code class="literal">X-Response-Foo:1234</code> ，它将被替换为<code class="literal">X-Response-Foo:Bar</code> ，这是网关客户端将收到的。</p><p>SetResponseHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setresponseheader_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Host</span>: {segment}.myhost.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetResponseHeader</span>=foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> bar-{segment<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_setstatus_gatewayfilter_factory" href="#_setstatus_gatewayfilter_factory"></a> 114.23 SetStatus GatewayFilter工厂</h2></div></div></div><p>SetStatus GatewayFilter工厂需要一个<code class="literal">status</code>参数。它必须是有效的Spring <code class="literal">HttpStatus</code> 。可能是整数值<code class="literal">404</code>或枚举的字符串表示形式<code class="literal">NOT_FOUND</code> 。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setstatusstring_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetStatus</span>=BAD_REQUEST
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setstatusint_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetStatus</span>=<span class="hl-number">401</span></pre><p>
</p><p>无论哪种情况，响应的HTTP状态都将设置为401。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_stripprefix_gatewayfilter_factory" href="#_stripprefix_gatewayfilter_factory"></a> 114.24 StripPrefix GatewayFilter工厂</h2></div></div></div><p>StripPrefix GatewayFilter工厂采用一个参数， <code class="literal">parts</code> 。的<code class="literal">parts</code>参数表示在向下游发送请求之前要从请求中剥离的路径中的零件数。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: nameRoot
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://nameservice
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/name/**
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - StripPrefix</span>=<span class="hl-number">2</span></pre><p>
</p><p>通过网关发出请求时<code class="literal">/name/bar/foo</code>要求<code class="literal">nameservice</code>看起来像<code class="literal"><a class="link" href="http://nameservice/foo" target="_top">http://nameservice/foo</a></code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_retry_gatewayfilter_factory" href="#_retry_gatewayfilter_factory"></a> 114.25重试GatewayFilter工厂</h2></div></div></div><p>重试GatewayFilter工厂支持以下参数集：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">retries</code> ：应尝试的重试次数</li><li class="listitem"><code class="literal">statuses</code> ：应重试的HTTP状态代码，用表示<code class="literal">org.springframework.http.HttpStatus</code></li><li class="listitem"><code class="literal">methods</code> ：应重试的HTTP方法，使用表示<code class="literal">org.springframework.http.HttpMethod</code></li><li class="listitem"><code class="literal">series</code> ：要重试的一系列状态代码，用表示<code class="literal">org.springframework.http.HttpStatus.Series</code></li><li class="listitem"><code class="literal">exceptions</code> ：应重试引发的异常列表</li><li class="listitem"><code class="literal">backoff</code> ：为重试配置了指数补偿。重试间隔为<code class="literal">firstBackoff * (factor ^ n)</code>哪里<code class="literal">n</code>是迭代。如果<code class="literal">maxBackoff</code>配置后，应用的最大退避将被限制为<code class="literal">maxBackoff</code> 。如果<code class="literal">basedOnPreviousValue</code>是真实的，退避将使用<code class="literal">prevBackoff * factor</code> 。</li></ul></div><p>为以下配置了默认值<code class="literal">Retry</code>过滤器（如果启用）：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">retries</code> - 3次</li><li class="listitem"><code class="literal">series</code> — 5XX系列</li><li class="listitem"><code class="literal">methods</code> — GET方法</li><li class="listitem"><code class="literal">exceptions</code> - <code class="literal">IOException</code>和<code class="literal">TimeoutException</code></li><li class="listitem"><code class="literal">backoff</code> —禁用</li></ul></div><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: retry_test
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://localhost:<span class="hl-number">8080</span>/flakey
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Host</span>=*.retry.com
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: Retry
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            retries</span>: <span class="hl-number">3</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            statuses</span>: BAD_GATEWAY
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            backoff</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              firstBackoff</span>: <span class="hl-number">10</span>ms
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              maxBackoff</span>: <span class="hl-number">50</span>ms
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              factor</span>: <span class="hl-number">2</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              basedOnPreviousValue</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">false</span></pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>重试过滤器当前不支持使用主体重试（例如，使用主体进行POST或PUT请求）。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>将重试过滤器与<code class="literal">forward:</code>带有前缀URL的目标端点应仔细编写，以便在发生错误的情况下不会执行任何可能导致响应发送到客户端并提交的操作。例如，如果目标端点是带注释的控制器，则目标控制器方法不应返回<code class="literal">ResponseEntity</code>错误状态代码。相反，它应该抛出一个<code class="literal">Exception</code> ，或发出错误信号，例如通过<code class="literal">Mono.error(ex)</code>返回值，可以将重试过滤器配置为通过重试处理。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_requestsize_gatewayfilter_factory" href="#_requestsize_gatewayfilter_factory"></a> 114.26 RequestSize GatewayFilter工厂</h2></div></div></div><p>当请求大小大于允许的限制时，RequestSize GatewayFilter Factory可以限制请求到达下游服务。过滤器需要<code class="literal">RequestSize</code>作为参数，它是请求的允许大小限制（以字节为单位）。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: request_size_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      uri</span>: http://localhost:<span class="hl-number">8080</span>/upload
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - Path</span>=/upload
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - name</span>: RequestSize
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          maxSize</span>: <span class="hl-number">5000000</span></pre><p>
</p><p>RequestSize GatewayFilter Factory将响应状态设置为<code class="literal">413 Payload Too Large</code>带有额外的标题<code class="literal">errorMessage</code>当请求由于大小而被拒绝时。以下是这样一个例子<code class="literal">errorMessage</code> 。</p><p><code class="literal">errorMessage</code> ：<code class="literal">Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB</code></p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果未在路由定义中作为过滤器参数提供，则默认请求大小将设置为5 MB。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_modify_request_body_gatewayfilter_factory" href="#_modify_request_body_gatewayfilter_factory"></a> 114.27修改请求正文GatewayFilter工厂</h2></div></div></div><p><span class="strong"><strong>该过滤器被认为是BETA，API将来可能会更改</strong></span></p><p>此过滤器可用于在网关将请求主体发送到下游之前修改请求主体。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>只能使用Java DSL配置此过滤器</p></td></tr></tbody></table></div><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RouteLocator routes(RouteLocatorBuilder builder) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> builder.routes()
        .route(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"rewrite_request_obj"</span>, r -&gt; r.host(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*.rewriterequestobj.org"</span>)
            .filters(f -&gt; f.prefixPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/httpbin"</span>)
                .modifyRequestBody(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Hello.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, MediaType.APPLICATION_JSON_VALUE,
                    (exchange, s) -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> Mono.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Hello(s.toUpperCase())))).uri(uri))
        .build();
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Hello {
    String message;

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Hello() { }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Hello(String message) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.message = message;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String getMessage() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> message;
    }

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> setMessage(String message) {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.message = message;
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_modify_response_body_gatewayfilter_factory" href="#_modify_response_body_gatewayfilter_factory"></a> 114.28修改响应主体GatewayFilter工厂</h2></div></div></div><p><span class="strong"><strong>该过滤器被认为是BETA，API将来可能会更改</strong></span></p><p>此过滤器可用于在将响应正文发送回客户端之前对其进行修改。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>只能使用Java DSL配置此过滤器</p></td></tr></tbody></table></div><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RouteLocator routes(RouteLocatorBuilder builder) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> builder.routes()
        .route(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"rewrite_response_upper"</span>, r -&gt; r.host(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*.rewriteresponseupper.org"</span>)
            .filters(f -&gt; f.prefixPath(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/httpbin"</span>)
        		.modifyResponseBody(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>,
        		    (exchange, s) -&gt; Mono.just(s.toUpperCase()))).uri(uri)
        .build();
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_default_filters" href="#_default_filters"></a> 114.29默认过滤器</h2></div></div></div><p>如果您想添加过滤器并将其应用于所有路由，则可以使用<code class="literal">spring.cloud.gateway.default-filters</code> 。该属性采用过滤器列表</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      default-filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - AddResponseHeader</span>=X-Response-Default-Foo<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span> Default-Bar
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - PrefixPath</span>=/httpbin</pre><p>
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_global_filters" href="#_global_filters"></a> 115。全局过滤器</h2></div></div></div><p>的<code class="literal">GlobalFilter</code>接口具有与以下相同的签名<code class="literal">GatewayFilter</code> 。这些是特殊过滤器，有条件地应用于所有路由。（此界面和用法可能会在将来的里程碑中更改）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_combined_global_filter_and_gatewayfilter_ordering" href="#_combined_global_filter_and_gatewayfilter_ordering"></a> 115.1组合的全局过滤器和GatewayFilter排序</h2></div></div></div><p>当请求进入（并与路由匹配）时，过滤网络处理程序将添加的所有实例<code class="literal">GlobalFilter</code>以及的所有路由特定实例<code class="literal">GatewayFilter</code>过滤器链。该组合的过滤器链按<code class="literal">org.springframework.core.Ordered</code>接口，可以通过实施<code class="literal">getOrder()</code>方法。</p><p>由于Spring Cloud Gateway区分了执行过滤器逻辑的“前”阶段和“后”阶段（请参阅： <a class="link" href="#gateway-how-it-works" title="112。怎么运行的">工作原理</a> ），因此优先级最高的过滤器将在“前”阶段中处于第一个阶段，而在“后”阶段中处于最后一个阶段“-相。</p><p><b>ExampleConfiguration.java。</b>
</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> GlobalFilter customFilter() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> CustomGlobalFilter();
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> CustomGlobalFilter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> GlobalFilter, Ordered {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"custom global filter"</span>);
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> chain.filter(exchange);
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> getOrder() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> -<span class="hl-number">1</span>;
    }
}</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_forward_routing_filter" href="#_forward_routing_filter"></a> 115.2转发路由过滤器</h2></div></div></div><p>的<code class="literal">ForwardRoutingFilter</code>在交换属性中查找URI <code class="literal">ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 。如果网址中有一个<code class="literal">forward</code>方案（即<code class="literal">forward:///localendpoint</code> ），它将使用Spring <code class="literal">DispatcherHandler</code>处理请求。请求URL的路径部分将被转发URL中的路径覆盖。未经修改的原始网址会附加到列表中<code class="literal">ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_loadbalancerclient_filter" href="#_loadbalancerclient_filter"></a> 115.3 LoadBalancerClient筛选器</h2></div></div></div><p>的<code class="literal">LoadBalancerClientFilter</code>在交换属性中查找URI <code class="literal">ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 。如果网址中有一个<code class="literal">lb</code>方案（即<code class="literal">lb://myservice</code> ），它将使用Spring Cloud <code class="literal">LoadBalancerClient</code>解析名称（ <code class="literal">myservice</code>在上一个示例中）到实际的主机和端口，并替换相同属性中的URI。未经修改的原始网址会附加到列表中<code class="literal">ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性。过滤器还会在<code class="literal">ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>属性以查看是否等于<code class="literal">lb</code>然后适用相同的规则。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: myRoute
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: lb://service
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/service/**</pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认情况下，当无法在<code class="literal">LoadBalancer</code>一种<code class="literal">503</code>将被退回。您可以配置网关以返回<code class="literal">404</code>通过设置<code class="literal">spring.cloud.gateway.loadbalancer.use404=true</code> 。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">isSecure</code>的价值<code class="literal">ServiceInstance</code>从返回<code class="literal">LoadBalancer</code>将覆盖对网关的请求中指定的方案。例如，如果请求通过<code class="literal">HTTPS</code>但是<code class="literal">ServiceInstance</code>表示它不安全，则将向下游请求<code class="literal">HTTP</code> 。相反的情况也可以适用。但是如果<code class="literal">GATEWAY_SCHEME_PREFIX_ATTR</code>在网关配置中为路由指定了，前缀将被删除，路由URL产生的方案将覆盖<code class="literal">ServiceInstance</code>组态。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p><code class="literal">LoadBalancerClientFilter</code>使用阻挡色带<code class="literal">LoadBalancerClient</code>在引擎盖下。我们建议您使用<a class="link" href="#reactive-loadbalancer-client-filter" title="115.4 ReactiveLoadBalancerClientFilter"><code class="literal">ReactiveLoadBalancerClientFilter</code>相反</a> 。您可以通过添加切换到使用它<code class="literal">org.springframework.cloud:spring-cloud-loadbalancer</code>依赖于您的项目并设置<code class="literal">spring.cloud.loadbalancer.ribbon.enabled</code>至<code class="literal">false</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="reactive-loadbalancer-client-filter" href="#reactive-loadbalancer-client-filter"></a> 115.4 ReactiveLoadBalancerClientFilter</h2></div></div></div><p>的<code class="literal">ReactiveLoadBalancerClientFilter</code>在交换属性中查找URI <code class="literal">ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 。如果网址中有一个<code class="literal">lb</code>方案（即<code class="literal">lb://myservice</code> ），它将使用Spring Cloud <code class="literal">ReactorLoadBalancer</code>解析名称（ <code class="literal">myservice</code>在上一个示例中）到实际的主机和端口，并替换相同属性中的URI。未经修改的原始网址会附加到列表中<code class="literal">ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性。过滤器还会在<code class="literal">ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>属性以查看是否等于<code class="literal">lb</code>然后适用相同的规则。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: myRoute
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: lb://service
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/service/**</pre><p>
</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>默认情况下，当服务实例无法通过<code class="literal">ReactorLoadBalancer</code> ， 一种<code class="literal">503</code>将被退回。您可以配置网关以返回<code class="literal">404</code>通过设置<code class="literal">spring.cloud.gateway.loadbalancer.use404=true</code> 。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>的<code class="literal">isSecure</code>的价值<code class="literal">ServiceInstance</code>从返回<code class="literal">ReactiveLoadBalancerClientFilter</code>将覆盖对网关的请求中指定的方案。例如，如果请求通过<code class="literal">HTTPS</code>但是<code class="literal">ServiceInstance</code>表示它不安全，则将向下游请求<code class="literal">HTTP</code> 。相反的情况也可以适用。但是如果<code class="literal">GATEWAY_SCHEME_PREFIX_ATTR</code>在网关配置中为路由指定了，前缀将被删除，路由URL产生的方案将覆盖<code class="literal">ServiceInstance</code>组态。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_netty_routing_filter" href="#_netty_routing_filter"></a> 115.5网元路由过滤器</h2></div></div></div><p>如果网址位于<code class="literal">ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>交换属性有一个<code class="literal">http</code>要么<code class="literal">https</code>方案。它使用净额<code class="literal">HttpClient</code>发出下游代理请求。响应放在<code class="literal">ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code>交换属性，供以后的过滤器使用。（有一个实验性的<code class="literal">WebClientHttpRoutingFilter</code>执行相同的功能，但不需要净值）</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_netty_write_response_filter" href="#_netty_write_response_filter"></a> 115.6 Netty写响应过滤器</h2></div></div></div><p>的<code class="literal">NettyWriteResponseFilter</code>如果有净额，则运行<code class="literal">HttpClientResponse</code>在里面<code class="literal">ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code>交换属性。它在所有其他筛选器完成后运行，并将代理响应写回到网关客户端响应。（有一个实验性的<code class="literal">WebClientWriteResponseFilter</code>执行相同的功能，但不需要净值）</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_routetorequesturl_filter" href="#_routetorequesturl_filter"></a> 115.7 RouteToRequestUrl过滤器</h2></div></div></div><p>的<code class="literal">RouteToRequestUrlFilter</code>如果有<code class="literal">Route</code>中的对象<code class="literal">ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR</code>交换属性。它根据请求URI创建一个新的URI，但使用URI的URI属性进行更新<code class="literal">Route</code>宾语。新的URI放置在<code class="literal">ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>交换属性`。</p><p>如果URI具有方案前缀，例如<code class="literal">lb:ws://serviceid</code> ， <code class="literal">lb</code>方案已从URI中剥离，并放置在<code class="literal">ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>供以后在过滤器链中使用。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_websocket_routing_filter" href="#_websocket_routing_filter"></a> 115.8 Websocket路由过滤器</h2></div></div></div><p>如果Websocket路由过滤器中的网址位于<code class="literal">ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>交换属性有一个<code class="literal">ws</code>要么<code class="literal">wss</code>方案。它使用Spring Web Socket基础结构向下游转发Websocket请求。</p><p>Websocket可以通过在URI前面加上前缀来实现负载均衡<code class="literal">lb</code> ， 如<code class="literal">lb:ws://serviceid</code> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您将<a class="link" href="https://github.com/sockjs" target="_top">SockJS</a>用作常规http的后备，则应配置常规HTTP路由以及Websocket路由。</p></td></tr></tbody></table></div><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># SockJS route</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: websocket_sockjs_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: http://localhost:<span class="hl-number">3001</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/websocket/info/**
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Normwal Websocket route</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: websocket_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: ws://localhost:<span class="hl-number">3001</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        predicates</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - Path</span>=/websocket/**</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_gateway_metrics_filter" href="#_gateway_metrics_filter"></a> 115.9网关指标过滤器</h2></div></div></div><p>要启用网关度量标准，请添加spring-boot-starter-actuator作为项目依赖项。然后，默认情况下，只要该属性运行网关度量过滤器<code class="literal">spring.cloud.gateway.metrics.enabled</code>未设置为<code class="literal">false</code> 。此过滤器添加一个带有以下标记的名为“ gateway.requests”的计时器度量标准：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">routeId</code> ：路线ID</li><li class="listitem"><code class="literal">routeUri</code> ：API将被路由到的URI</li><li class="listitem"><code class="literal">outcome</code> ：按<a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html" target="_top">HttpStatus分类的结果</a><a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html" target="_top">。系列</a></li><li class="listitem"><code class="literal">status</code> ：请求返回给客户端的Http状态</li><li class="listitem"><code class="literal">httpStatusCode</code> ：请求返回给客户端的Http状态</li><li class="listitem"><code class="literal">httpMethod</code> ：用于请求的Http方法</li></ul></div><p>然后可以从这些指标中进行刮取<code class="literal">/actuator/metrics/gateway.requests</code>并且可以轻松地与Prometheus集成以创建<a class="link" href="images/gateway-grafana-dashboard.jpeg" target="_top">Grafana</a> <a class="link" href="gateway-grafana-dashboard.json" target="_top">仪表板</a> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>要启用Prometheus端点，请添加micrometer-registry-prometheus作为项目依赖项。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_marking_an_exchange_as_routed" href="#_marking_an_exchange_as_routed"></a> 115.10将交换标记为已路由</h2></div></div></div><p>网关路由后<code class="literal">ServerWebExchange</code>通过添加，它将标记该交换为“路由” <code class="literal">gatewayAlreadyRouted</code>交换属性。将请求标记为已路由后，其他路由筛选器将不会再次路由请求，实质上会跳过该过滤器。您可以使用多种便捷方法将交换标记为已路由，或者检查交换是否已路由。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">ServerWebExchangeUtils.isAlreadyRouted</code>需要一个<code class="literal">ServerWebExchange</code>对象并检查它是否已被“路由”</li><li class="listitem"><code class="literal">ServerWebExchangeUtils.setAlreadyRouted</code>需要一个<code class="literal">ServerWebExchange</code>对象并将其标记为“已路由”</li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_tls_ssl" href="#_tls_ssl"></a> 116。TLS / SSL</h2></div></div></div><p>网关可以通过遵循常规的Spring服务器配置来侦听https上的请求。例：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">server</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  ssl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    enabled</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    key-alias</span>: scg
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    key-store-password</span>: scg1234
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    key-store</span>: classpath:scg-keystore.p12
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    key-store-type</span>: PKCS12</pre><p>
</p><p>网关路由可以同时路由到http和https后端。如果路由到https后端，则可以使用以下配置将网关配置为信任所有下游证书：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      httpclient</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        ssl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          useInsecureTrustManager</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">true</span></pre><p>
</p><p>使用不安全的信任管理器不适用于生产。对于生产部署，可以为网关配置一组可以通过以下配置信任的已知证书：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      httpclient</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        ssl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          trustedX509Certificates</span>:
          - cert1.pem
          - cert2.pem</pre><p>
</p><p>如果未为Spring Cloud Gateway提供受信任的证书，则会使用默认的信任存储（可以使用系统属性javax.net.ssl.trustStore覆盖）。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_tls_handshake" href="#_tls_handshake"></a> 116.1 TLS握手</h2></div></div></div><p>网关维护一个客户端池，该客户端池用于路由到后端。通过https进行通信时，客户端会启动TLS握手。许多超时与此握手相关联。可以配置以下超时（显示默认值）：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      httpclient</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        ssl</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          handshake-timeout-millis</span>: <span class="hl-number">10000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          close-notify-flush-timeout-millis</span>: <span class="hl-number">3000</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          close-notify-read-timeout-millis</span>: <span class="hl-number">0</span></pre><p>
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_configuration_2" href="#_configuration_2"></a> 117。组态</h2></div></div></div><p>Spring Cloud Gateway的配置由RouteDefinitionLocator的集合驱动。</p><p><b>RouteDefinitionLocator.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> RouteDefinitionLocator {
	Flux&lt;RouteDefinition&gt; getRouteDefinitions();
}</pre><p>
</p><p>默认情况下， <code class="literal">PropertiesRouteDefinitionLocator</code>使用Spring Boot的加载属性<code class="literal">@ConfigurationProperties</code>机制。</p><p>上面的所有配置示例都使用一种快捷方式符号，该快捷方式符号使用位置参数而不是命名参数。以下两个示例是等效的：</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      routes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setstatus_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: SetStatus
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          args</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            status</span>: <span class="hl-number">401</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - id</span>: setstatusshortcut_route
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        uri</span>: https://example.org
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        filters</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - SetStatus</span>=<span class="hl-number">401</span></pre><p>
</p><p>对于网关的某些用法，属性将是足够的，但是某些生产用例将受益于从外部源（例如数据库）加载配置。未来的里程碑版本将具有<code class="literal">RouteDefinitionLocator</code>基于Spring数据存储库的实现，例如：Redis，MongoDB和Cassandra。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_fluent_java_routes_api" href="#_fluent_java_routes_api"></a> 117.1 Fluent Java Routes API</h2></div></div></div><p>为了在Java中进行简单的配置，在<code class="literal">RouteLocatorBuilder</code> bean 。</p><p><b>GatewaySampleApplication.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// static imports from GatewayFilters and RoutePredicates</span>
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> builder.routes()
            .route(r -&gt; r.host(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"**.abc.org"</span>).and().path(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/image/png"</span>)
                .filters(f -&gt;
                        f.addResponseHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"X-TestHeader"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foobar"</span>))
                .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://httpbin.org:80"</span>)
            )
            .route(r -&gt; r.path(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/image/webp"</span>)
                .filters(f -&gt;
                        f.addResponseHeader(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"X-AnotherHeader"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"baz"</span>))
                .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://httpbin.org:80"</span>)
            )
            .route(r -&gt; r.order(-<span class="hl-number">1</span>)
                .host(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"**.throttle.org"</span>).and().path(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/get"</span>)
                .filters(f -&gt; f.filter(throttle.apply(<span class="hl-number">1</span>,
                        <span class="hl-number">1</span>,
                        <span class="hl-number">10</span>,
                        TimeUnit.SECONDS)))
                .uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"http://httpbin.org:80"</span>)
            )
            .build();
}</pre><p>
</p><p>此样式还允许更多自定义谓词断言。谓词定义为<code class="literal">RouteDefinitionLocator</code> bean 结合使用逻辑<code class="literal">and</code> 。通过使用流畅的Java API，您可以使用<code class="literal">and()</code> ， <code class="literal">or()</code>和<code class="literal">negate()</code>运算符<code class="literal">Predicate</code>类。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_discoveryclient_route_definition_locator" href="#_discoveryclient_route_definition_locator"></a> 117.2 DiscoveryClient路由定义定位器</h2></div></div></div><p>可以将网关配置为根据向网络服务提供商注册的服务创建路由。 <code class="literal">DiscoveryClient</code>兼容的服务注册表。</p><p>要启用此功能，请设置<code class="literal">spring.cloud.gateway.discovery.locator.enabled=true</code>并确保<code class="literal">DiscoveryClient</code>实现是在类路径上并启用的（例如Netflix Eureka，Consul或Zookeeper）。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_configuring_predicates_and_filters_for_discoveryclient_routes" href="#_configuring_predicates_and_filters_for_discoveryclient_routes"></a> 117.2.1为DiscoveryClient路由配置谓词和过滤器</h3></div></div></div><p>默认情况下，网关为通过网络创建的路由定义单个谓词和过滤器<code class="literal">DiscoveryClient</code> 。</p><p>默认谓词是使用模式定义的路径谓词<code class="literal">/serviceId/**</code> ，在哪里<code class="literal">serviceId</code>是来自的服务的ID <code class="literal">DiscoveryClient</code> 。</p><p>默认过滤器是使用正则表达式的重写路径过滤器<code class="literal">/serviceId/(?<remaining>.*)</code>和替换<code class="literal">/${remaining}</code> 。这只是在将请求发送到下游之前从路径中剥离服务ID。</p><p>如果您想自定义谓词和/或过滤器使用的过滤器<code class="literal">DiscoveryClient</code>您可以通过设置以下路线<code class="literal">spring.cloud.gateway.discovery.locator.predicates[x]</code>和<code class="literal">spring.cloud.gateway.discovery.locator.filters[y]</code> 。这样做时，如果要保留该功能，则需要确保在上面包含默认谓词和过滤器。以下是此示例的示例。</p><p><b>application.properties。</b>
</p><pre class="screen">spring.cloud.gateway.discovery.locator.predicates[0].name: Path
spring.cloud.gateway.discovery.locator.predicates[0].args[pattern]: "'/'+serviceId+'/**'"
spring.cloud.gateway.discovery.locator.predicates[1].name: Host
spring.cloud.gateway.discovery.locator.predicates[1].args[pattern]: "'**.foo.com'"
spring.cloud.gateway.discovery.locator.filters[0].name: Hystrix
spring.cloud.gateway.discovery.locator.filters[0].args[name]: serviceId
spring.cloud.gateway.discovery.locator.filters[1].name: RewritePath
spring.cloud.gateway.discovery.locator.filters[1].args[regexp]: "'/' + serviceId + '/(?&lt;remaining&gt;.*)'"
spring.cloud.gateway.discovery.locator.filters[1].args[replacement]: "'/${remaining}'"</pre><p>
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_reactor_netty_access_logs" href="#_reactor_netty_access_logs"></a> 118。Reactor Netty访问日志</h2></div></div></div><p>要启用Reactor Netty访问日志，请设置<code class="literal">-Dreactor.netty.http.server.accessLogEnabled=true</code> 。（它必须是Java System属性，而不是Spring Boot属性）。</p><p>日志系统可以配置为具有单独的访问日志文件。以下是示例登录配置：</p><p><b>logback.xml。</b>
</p><pre class="programlisting">    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"accessLog"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.FileAppender"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;file&gt;</span>access_log.log<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/file&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;encoder&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;pattern&gt;</span>%msg%n<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/pattern&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/encoder&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appender&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"async"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.classic.AsyncAppender"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender-ref</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ref</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"accessLog"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag"> /&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appender&gt;</span>

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;logger</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"reactor.netty.http.server.AccessLog"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">level</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"INFO"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">additivity</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"false"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender-ref</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ref</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"async"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/logger&gt;</span></pre><p>
</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_cors_configuration" href="#_cors_configuration"></a> 119。CORS配置</h2></div></div></div><p>可以将网关配置为控制CORS行为。“全局” CORS配置是URL模式到<a class="link" href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html" target="_top">Spring Framework</a>的映射<a class="link" href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html" target="_top"><code class="literal">CorsConfiguration</code></a> 。</p><p><b>application.yml。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    gateway</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      globalcors</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        corsConfigurations</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          '[/**]'</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            allowedOrigins</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"https://docs.spring.io"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            allowedMethods</span>:
            - GET</pre><p>
</p><p>在上面的示例中，将从docs.spring.io发出的所有GET请求路径的请求中允许CORS请求。</p><p>要为某些网关路由谓词未处理的请求提供相同的CORS配置，请设置属性<code class="literal">spring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping</code>等于真实。当尝试支持CORS预检请求并且您的路由谓词未评估为true时，这很有用，因为http方法是<code class="literal">options</code> 。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_actuator_api" href="#_actuator_api"></a> 120。执行器API</h2></div></div></div><p>的<code class="literal">/gateway</code>执行器端点允许监视Spring Cloud Gateway应用程序并与之交互。为了可远程访问，必须在应用程序属性中<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints" target="_top">通过HTTP或JMX</a> <a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints" target="_top">启用</a>和<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints" target="_top">公开</a>端点。</p><p><b>application.properties。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">management.endpoint.gateway.enabled</span>=true <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># default value</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">management.endpoints.web.exposure.include</span>=gateway</pre><p>
</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_verbose_actuator_format" href="#_verbose_actuator_format"></a> 120.1详细执行器格式</h2></div></div></div><p>一种新的，更详细的格式已添加到网关。这为每个路由添加了更多细节，从而允许查看与每个路由关联的谓词和过滤器以及任何可用的配置。</p><p><code class="literal">/actuator/gateway/routes</code></p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"predicate"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"(Hosts: [**.addrequestheader.org] &amp;&amp; Paths: [/headers], match trailing slash: true)"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"route_id"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"add_request_header_test"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"filters"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">[</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[[AddResponseHeader X-Response-Default-Foo = 'Default-Bar'], order = 1]"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[[AddRequestHeader X-Request-Foo = 'Bar'], order = 1]"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"[[PrefixPath prefix = '/httpbin'], order = 2]"</span>
    ]<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"uri"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"lb://testservice"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"order"</span>: <span class="hl-number">0</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">]</span></pre><p>要启用此功能，请设置以下属性：</p><p><b>application.properties。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring.cloud.gateway.actuator.verbose.enabled</span>=true</pre><p>
</p><p>在将来的版本中，它将默认为true。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_retrieving_route_filters" href="#_retrieving_route_filters"></a> 120.2检索路由过滤器</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_global_filters_2" href="#_global_filters_2"></a> 120.2.1全局过滤器</h3></div></div></div><p>要检索应用于所有路线的<a class="link" href="#">全局过滤器</a> ，请<code class="literal">GET</code>请求<code class="literal">/actuator/gateway/globalfilters</code> 。产生的响应类似于以下内容：</p><pre class="screen">{
  "org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@77856cc5": 10100,
  "org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@4f6fd101": 10000,
  "org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@32d22650": -1,
  "org.springframework.cloud.gateway.filter.ForwardRoutingFilter@106459d9": 2147483647,
  "org.springframework.cloud.gateway.filter.NettyRoutingFilter@1fbd5e0": 2147483647,
  "org.springframework.cloud.gateway.filter.ForwardPathFilter@33a71d23": 0,
  "org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@135064ea": 2147483637,
  "org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@23c05889": 2147483646
}</pre><p>该响应包含适当的全局过滤器的详细信息。为每个全局过滤器提供了过滤器对象的字符串表示形式（例如， <code class="literal">org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@77856cc5</code> ）以及过滤器链中的相应<a class="link" href="#_combined_global_filter_and_gatewayfilter_ordering" title="115.1组合的全局过滤器和GatewayFilter排序">顺序</a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_route_filters" href="#_route_filters"></a> 120.2.2路由过滤器</h3></div></div></div><p>要检索应用于路由的<a class="link" href="#">GatewayFilter工厂</a> ，请创建一个<code class="literal">GET</code>请求<code class="literal">/actuator/gateway/routefilters</code> 。产生的响应类似于以下内容：</p><pre class="screen">{
  "[AddRequestHeaderGatewayFilterFactory@570ed9c configClass = AbstractNameValueGatewayFilterFactory.NameValueConfig]": null,
  "[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]": null,
  "[SaveSessionGatewayFilterFactory@4449b273 configClass = Object]": null
}</pre><p>该响应包含应用于任何特定路由的GatewayFilter工厂的详细信息。为每个工厂提供了相应对象的字符串表示形式（例如， <code class="literal">[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]</code> ）。请注意<code class="literal">null</code>该值是由于端点控制器的实现不完整而导致的，因为它尝试设置对象在过滤器链中的顺序，而该顺序不适用于GatewayFilter工厂对象。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_refreshing_the_route_cache" href="#_refreshing_the_route_cache"></a> 120.3刷新路由缓存</h2></div></div></div><p>要清除路由缓存，请<code class="literal">POST</code>请求<code class="literal">/actuator/gateway/refresh</code> 。该请求返回200，但没有响应主体。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_retrieving_the_routes_defined_in_the_gateway" href="#_retrieving_the_routes_defined_in_the_gateway"></a> 120.4检索网关中定义的路由</h2></div></div></div><p>要检索网关中定义的路由，请创建一个<code class="literal">GET</code>请求<code class="literal">/actuator/gateway/routes</code> 。产生的响应类似于以下内容：</p><pre class="screen">[{
  "route_id": "first_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@1e9d7e7d",
    "filters": [
      "OrderedGatewayFilter{delegate=org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactory$$Lambda$436/674480275@6631ef72, order=0}"
    ]
  },
  "order": 0
},
{
  "route_id": "second_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@cd8d298",
    "filters": []
  },
  "order": 0
}]</pre><p>该响应包含网关中定义的所有路由的详细信息。下表描述了响应的每个元素（即路线）的结构。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">路径</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">类型</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">route_id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>串</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>路线编号。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">route_object.predicate</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>宾语</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>路由谓词。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">route_object.filters</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>数组</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="#">GatewayFilter工厂已</a>应用于路由。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">order</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>数</p></td><td align="left" valign="top"><p>路线顺序。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_retrieving_information_about_a_particular_route" href="#_retrieving_information_about_a_particular_route"></a> 120.5检索有关特定路线的信息</h2></div></div></div><p>要检索有关一条路线的信息，请<code class="literal">GET</code>请求<code class="literal">/actuator/gateway/routes/{id}</code> （例如， <code class="literal">/actuator/gateway/routes/first_route</code> ）。产生的响应类似于以下内容：</p><pre class="screen">{
  "id": "first_route",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"/first"}
  }],
  "filters": [],
  "uri": "https://www.uri-destination.org",
  "order": 0
}]</pre><p>下表描述了响应的结构。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">路径</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">类型</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>串</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>路线编号。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">predicates</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>数组</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>路由谓词的集合。每个项目都定义给定谓词的名称和自变量。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">filters</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>数组</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用于路线的过滤器集合。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">uri</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>串</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>路由的目标URI。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">order</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>数</p></td><td align="left" valign="top"><p>路线顺序。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_creating_and_deleting_a_particular_route" href="#_creating_and_deleting_a_particular_route"></a> 120.6创建和删除特定路线</h2></div></div></div><p>要创建路线，请创建一个<code class="literal">POST</code>请求<code class="literal">/gateway/routes/{id_route_to_create}</code>带有指定路由字段的JSON主体（请参见上一小节）。</p><p>要删除路线，请<code class="literal">DELETE</code>请求<code class="literal">/gateway/routes/{id_route_to_delete}</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_recap_list_of_all_endpoints" href="#_recap_list_of_all_endpoints"></a> 120.7总结：所有端点的列表</h2></div></div></div><p>下表总结了Spring Cloud Gateway执行器端点。请注意，每个端点都有<code class="literal">/actuator/gateway</code>作为基本路径。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">ID</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">HTTP方法</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">globalfilters</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>得到</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>显示应用于路由的全局过滤器列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">routefilters</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>得到</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>显示应用于特定路由的GatewayFilter工厂列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">refresh</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>开机自检</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>清除路由缓存。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">routes</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>得到</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>显示网关中定义的路由列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">routes/{id}</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>得到</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>显示有关特定路线的信息。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">routes/{id}</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>开机自检</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>将新路由添加到网关。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">routes/{id}</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>删除</p></td><td align="left" valign="top"><p>从网关删除现有路由。</p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="troubleshooting" href="#troubleshooting"></a> 121。故障排除</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_log_levels" href="#_log_levels"></a> 121.1日志级别</h2></div></div></div><p>以下是一些有用的记录器，其中包含在<code class="literal">DEBUG</code>和<code class="literal">TRACE</code>水平。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">org.springframework.cloud.gateway</code></li><li class="listitem"><code class="literal">org.springframework.http.server.reactive</code></li><li class="listitem"><code class="literal">org.springframework.web.reactive</code></li><li class="listitem"><code class="literal">org.springframework.boot.autoconfigure.web</code></li><li class="listitem"><code class="literal">reactor.netty</code></li><li class="listitem"><code class="literal">redisratelimiter</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_wiretap" href="#_wiretap"></a> 121.2窃听</h2></div></div></div><p>反应堆净值<code class="literal">HttpClient</code>和<code class="literal">HttpServer</code>可以启用监听。与设定<code class="literal">reactor.netty</code>日志级别<code class="literal">DEBUG</code>要么<code class="literal">TRACE</code>将启用信息记录，例如通过电线发送和接收的标题和正文。要启用此功能，请设置<code class="literal">spring.cloud.gateway.httpserver.wiretap=true</code>和/或<code class="literal">spring.cloud.gateway.httpclient.wiretap=true</code>为了<code class="literal">HttpServer</code>和<code class="literal">HttpClient</code>分别。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_developer_guide" href="#_developer_guide"></a> 122。开发人员指南</h2></div></div></div><p>TODO：编写定制集成概述</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_writing_custom_route_predicate_factories" href="#_writing_custom_route_predicate_factories"></a> 122.1编写自定义路由谓词工厂</h2></div></div></div><p>TODO：编写自定义路线谓词工厂的文档</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_writing_custom_gatewayfilter_factories" href="#_writing_custom_gatewayfilter_factories"></a> 122.2编写自定义GatewayFilter工厂</h2></div></div></div><p>为了编写GatewayFilter，您将需要实现<code class="literal">GatewayFilterFactory</code> 。有一个抽象类叫做<code class="literal">AbstractGatewayFilterFactory</code>您可以扩展。</p><p><b>PreGatewayFilterFactory.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> PreGatewayFilterFactory <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AbstractGatewayFilterFactory&lt;PreGatewayFilterFactory.Config&gt; {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> PreGatewayFilterFactory() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>(Config.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> GatewayFilter apply(Config config) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// grab configuration from Config object</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (exchange, chain) -&gt; {
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//If you want to build a "pre" filter you need to manipulate the</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//request before calling chain.filter</span>
            ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//use builder to manipulate the request</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> chain.filter(exchange.mutate().request(request).build());
		};
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Put the configuration properties for your filter here</span>
	}

}</pre><p>
</p><p><b>PostGatewayFilterFactory.java。</b>
</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> PostGatewayFilterFactory <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AbstractGatewayFilterFactory&lt;PostGatewayFilterFactory.Config&gt; {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> PostGatewayFilterFactory() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">super</span>(Config.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
	}

	<em><span class="hl-annotation" style="color: gray">@Override</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> GatewayFilter apply(Config config) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// grab configuration from Config object</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (exchange, chain) -&gt; {
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt; {
				ServerHttpResponse response = exchange.getResponse();
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Manipulate the response in some way</span>
			}));
		};
	}

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Config {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Put the configuration properties for your filter here</span>
	}

}</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_writing_custom_global_filters" href="#_writing_custom_global_filters"></a> 122.3编写自定义全局过滤器</h2></div></div></div><p>为了编写自定义全局过滤器，您需要实现<code class="literal">GlobalFilter</code>接口。这会将过滤器应用于所有请求。</p><p>如何分别设置全局前置和后置过滤器的示例</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> GlobalFilter customGlobalFilter() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (exchange, chain) -&gt; exchange.getPrincipal()
        .map(Principal::getName)
        .defaultIfEmpty(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Default User"</span>)
        .map(userName -&gt; {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//adds header to proxied request</span>
          exchange.getRequest().mutate().header(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CUSTOM-REQUEST-HEADER"</span>, userName).build();
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> exchange;
        })
        .flatMap(chain::filter);
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> GlobalFilter customGlobalPostFilter() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> (exchange, chain) -&gt; chain.filter(exchange)
        .then(Mono.just(exchange))
        .map(serverWebExchange -&gt; {
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//adds header to response</span>
          serverWebExchange.getResponse().getHeaders().set(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"CUSTOM-RESPONSE-HEADER"</span>,
              HttpStatus.OK.equals(serverWebExchange.getResponse().getStatusCode()) ? <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"It worked"</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"It did not work"</span>);
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> serverWebExchange;
        })
        .then();
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_writing_custom_route_locators_and_writers" href="#_writing_custom_route_locators_and_writers"></a> 122.4编写自定义路线定位器和编写器</h2></div></div></div><p>TODO：编写自定义路线定位器和编写器的文档</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_building_a_simple_gateway_using_spring_mvc_or_webflux" href="#_building_a_simple_gateway_using_spring_mvc_or_webflux"></a> 123。使用Spring MVC或Webflux构建简单的网关</h2></div></div></div><p>Spring Cloud Gateway提供了一个名为<code class="literal">ProxyExchange</code>您可以在常规的Spring Web处理程序中将其用作方法参数。它通过镜像HTTP动词的方法支持基本的下游HTTP交换。借助MVC，它还支持通过以下方式转发到本地处理程序： <code class="literal">forward()</code>方法。要使用<code class="literal">ProxyExchange</code>只需在您的类路径中包含正确的模块即可（ <code class="literal">spring-cloud-gateway-mvc</code>要么<code class="literal">spring-cloud-gateway-webflux</code> ）。</p><p>MVC示例（代理对远程服务器下游的“ /测试”请求）：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GatewaySampleApplication {

	<em><span class="hl-annotation" style="color: gray">@Value("${remote.home}")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> URI home;

	<em><span class="hl-annotation" style="color: gray">@GetMapping("/test")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ResponseEntity&lt;?&gt; proxy(ProxyExchange&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; proxy) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> proxy.uri(home.toString() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/image/png"</span>).get();
	}

}</pre><p>与Webflux相同的是：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RestController</span></em>
<em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> GatewaySampleApplication {

	<em><span class="hl-annotation" style="color: gray">@Value("${remote.home}")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> URI home;

	<em><span class="hl-annotation" style="color: gray">@GetMapping("/test")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Mono&lt;ResponseEntity&lt;?&gt;&gt; proxy(ProxyExchange&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; proxy) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> proxy.uri(home.toString() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/image/png"</span>).get();
	}

}</pre><p>有方便的方法<code class="literal">ProxyExchange</code>使处理程序方法能够发现并增强传入请求的URI路径。例如，您可能想提取路径的尾随元素以将它们传递到下游：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@GetMapping("/proxy/path/**")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ResponseEntity&lt;?&gt; proxyPath(ProxyExchange&lt;<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]&gt; proxy) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
  String path = proxy.path(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/proxy/path/"</span>);
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> proxy.uri(home.toString() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/foos/"</span> + path).get();
}</pre><p>网关处理程序方法可以使用Spring MVC或Webflux的所有功能。因此，例如，您可以注入请求标头和查询参数，并且可以使用映射批注中的声明来约束传入的请求。请参阅有关的文档<code class="literal">@RequestMapping</code>有关这些功能的更多详细信息，请参见Spring MVC。</p><p>可以使用以下命令将标头添加到下游响应中<code class="literal">header()</code>方法论<code class="literal">ProxyExchange</code> 。</p><p>您还可以通过将映射器添加到响应标头（以及响应中您喜欢的其他任何内容）来操作<code class="literal">get()</code>等方法。映射器是<code class="literal">Function</code>需要传入<code class="literal">ResponseEntity</code>并将其转换为外发的</p><p>为不传递到下游的“敏感”标头（默认情况下为“ cookie”和“授权”）以及“代理”标头（ <code class="literal">x-forwarded-*</code> ）。</p></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_function_2" href="#_spring_cloud_function_2"></a>第十六部分。spring-cloud-function</h1></div></div></div><div class="partintro"><div></div><p>马克·费舍尔，戴夫·瑟尔，奥列格·朱拉库斯基</p><p></p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_introduction_2" href="#_introduction_2"></a> 124。介绍</h2></div></div></div><p>Spring Cloud Function是一个具有以下高级目标的项目：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">通过功能促进业务逻辑的实现。</li><li class="listitem">将业务逻辑的开发生命周期与任何特定的运行时目标脱钩，以便相同的代码可以作为Web端点，流处理器或任务运行。</li><li class="listitem">支持跨无服务器提供程序的统一编程模型，以及独立运行（本地或在PaaS中）的能力。</li><li class="listitem">在无服务器提供程序上启用Spring Boot功能（自动配置，依赖项注入，指标）。</li></ul></div><p>它抽象出所有传输详细信息和基础结构，使开发人员可以保留所有熟悉的工具和流程，并专注于业务逻辑。</p><p>这是一个完整的，可执行的，可测试的Spring Boot应用程序（实现简单的字符串操作）：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; uppercase() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> flux -&gt; flux.map(value -&gt; value.toUpperCase());
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }
}</pre><p>它只是一个Spring Boot应用程序，因此可以像其他任何Spring Boot应用程序一样在本地以CI构建，运行和测试。的<code class="literal">Function</code>来自<code class="literal">java.util</code>和<code class="literal">Flux</code>是<a class="link" href="https://www.reactive-streams.org/" target="_top">反应流</a> <code class="literal">Publisher</code>来自<a class="link" href="https://projectreactor.io/" target="_top">Project Reactor</a> 。可以通过HTTP或消息传递来访问该功能。</p><p>Spring Cloud Function具有4个主要功能：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">包装纸<code class="literal">@Beans</code>类型的<code class="literal">Function</code> ， <code class="literal">Consumer</code>和<code class="literal">Supplier</code> ，使用RabbitMQ，Kafka等将它们作为HTTP终结点和/或消息流侦听器/发布器公开给外界。</li><li class="listitem">将作为Java函数体的字符串编译为字节码，然后将其转换为<code class="literal">@Beans</code>可以像上面那样包装。</li><li class="listitem">使用隔离的类装入器部署包含此类应用程序上下文的JAR文件，以便可以将它们打包在一起在单个JVM中。</li><li class="listitem">适用于<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws" target="_top">AWS Lambda</a> ， <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure" target="_top">Azure</a> ， <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk" target="_top">Apache OpenWhisk</a>以及其他“无服务器”服务提供商的适配器。</li></ol></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/docs/src/main/asciidoc" target="_top">github</a>的项目中找到源代码和问题跟踪程序。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_getting_started" href="#_getting_started"></a> 125。入门</h2></div></div></div><p>从命令行构建（并“安装”示例）：</p><pre class="screen">$ ./mvnw clean install</pre><p>（如果您想向YOLO添加<code class="literal">-DskipTests</code> ）</p><p>运行其中一个样本，例如</p><pre class="screen">$ java -jar spring-cloud-function-samples/function-sample/target/*.jar</pre><p>这将运行该应用程序并通过HTTP公开其功能，因此您可以将字符串转换为大写，如下所示：</p><pre class="screen">$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d Hello
HELLO</pre><p>您可以转换多个字符串（一个<code class="literal">Flux<String></code> ），用新行分隔</p><pre class="screen">$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d 'Hello
&gt; World'
HELLOWORLD</pre><p>（您可以使用<code class="literal"><sup>Q</sup>J</code>在终端中在这样的文字字符串中插入新行。）</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_building_and_running_a_function" href="#_building_and_running_a_function"></a> 126。建立和运行功能</h2></div></div></div><p>这个样本<code class="literal">@SpringBootApplication</code>上面的函数可以在运行时由Spring Cloud Function修饰为HTTP端点或Stream处理器，例如，使用RabbitMQ，Apache Kafka或JMS。</p><p>的<code class="literal">@Beans</code>可<code class="literal">Function</code> ， <code class="literal">Consumer</code>要么<code class="literal">Supplier</code> （全部来自<code class="literal">java.util</code> ），其参数类型可以是String或POJO。</p><p>功能也可以是<code class="literal">Flux<String></code>要么<code class="literal">Flux<Pojo></code> Spring Cloud Function负责将数据与所需类型之间进行转换，只要它们以纯文本或（对于POJO而言）JSON形式出现即可。也支持<code class="literal">Message<Pojo></code>消息头是从传入事件复制而来的，具体取决于适配器。Web适配器还支持从表单编码的数据转换为<code class="literal">Map</code> ，并且如果您将该功能与Spring Cloud Stream一起使用，则消息有效负载的所有转换和强制功能也将适用。</p><p>可以将功能组合在单个应用程序中，也可以每个jar部署一个。由开发人员选择。具有多种功能的应用程序可以以不同的“个性”多次部署，从而在不同的物理传输方式上暴露出不同的功能。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_function_catalog_and_flexible_function_signatures" href="#_function_catalog_and_flexible_function_signatures"></a> 127。功能目录和灵活的功能签名</h2></div></div></div><p>Spring Cloud Function的主要功能之一是为用户定义的函数适应和支持各种类型签名，同时提供一致的执行模型。这就是为什么所有用户定义的函数都可以通过以下方式转换为规范表示形式的原因<code class="literal">FunctionCatalog</code> ，使用<a class="link" href="https://projectreactor.io/" target="_top">Project Reactor</a>定义的原语（即， <code class="literal">Flux<T></code>和<code class="literal">Mono<T></code> ）。用户可以提供一个类型的bean <code class="literal">Function<String,String></code> ，例如<code class="literal">FunctionCatalog</code>将其包装成一个<code class="literal">Function<Flux<String>,Flux<String>></code> 。</p><p>使用基于Reactor的原语不仅有助于用户定义函数的规范表示，而且还有助于建立更健壮和灵活的（反应性）执行模型。</p><p>尽管用户通常不必关心<code class="literal">FunctionCatalog</code>完全了解用户代码支持哪些功能是很有用的。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_java_8_function_support" href="#_java_8_function_support"></a> 127.1 Java 8功能支持</h2></div></div></div><p>一般而言，用户可以期望，如果他们为普通的旧Java类型（或原始包装器）编写函数，则函数目录会将其包装到<code class="literal">Flux</code>相同类型的。如果用户使用编写函数<code class="literal">Message</code> （通过spring-messaging），它将从任何支持键值元数据的适配器接收和传输头（例如HTTP头）。这是详细信息。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">用户功能</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">目录注册</th><th align="left" valign="top" style="border-bottom:1px solid"> </th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<S,T></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Flux<S>, Flux<T>></code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Message<S>,Message<T>></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Flux<Message<S>>, Flux<Message<T>>></code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Flux<S>, Flux<T>></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Flux<S>, Flux<T>></code> （通过）</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Supplier<T></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Supplier<Flux<T>></code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Supplier<Flux<T>></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Supplier<Flux<T>></code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Consumer<T></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Flux<T>, Mono<Void>></code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Consumer<Message<T>></code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Function<Flux<Message<T>>, Mono<Void>></code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">Consumer<Flux<T>></code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">Consumer<Flux<T>></code></p></td><td align="left" valign="top"> </td></tr></tbody></table></div><p>消费者有点特殊，因为它具有<code class="literal">void</code>返回类型，这意味着至少有可能阻塞。您极有可能不需要写<code class="literal">Consumer<Flux<?>></code> ，但如果确实需要这样做，请记住订阅输入流量。如果您声明<code class="literal">Consumer</code>属于非发布者类型（通常），它将转换为返回发布者的函数，以便可以通过受控方式进行订阅。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_kotlin_lambda_support" href="#_kotlin_lambda_support"></a> 127.2 Kotlin Lambda支持</h2></div></div></div><p>我们还为Kotlin lambdas（自v2.0起）提供支持。考虑以下：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
open fun kotlinSupplier(): () -&gt; String {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>  { <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello from Kotlin"</span> }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
open fun kotlinFunction(): (String) -&gt; String {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>  { it.toUpperCase() }
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
open fun kotlinConsumer(): (String) -&gt; Unit {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span>  { println(it) }
}</pre><p>上面代表配置为Spring bean的Kotlin lambda。每个签名都映射到Java的等价物<code class="literal">Supplier</code> ， <code class="literal">Function</code>和<code class="literal">Consumer</code> ，因此框架支持/识别的签名。尽管Kotlin到Java的映射机制不在本文档的讨论范围之内，但重要的是要理解，此处也适用“ Java 8函数支持”部分中概述的相同的签名转换规则。</p><p>要启用Kotlin支持，您需要添加<code class="literal">spring-cloud-function-kotlin</code>模块到您的类路径，其中包含适当的自动配置和支持的类。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_standalone_web_applications" href="#_standalone_web_applications"></a> 128。独立的Web应用程序</h2></div></div></div><p>的<code class="literal">spring-cloud-function-web</code>模块具有自动配置功能，当将其包含在Spring Boot Web应用程序中（具有MVC支持）时，该配置将激活。还有一个<code class="literal">spring-cloud-starter-function-web</code>收集所有可选的依赖项，以防您只需要简单的入门经验。</p><p>启用网络配置后，您的应用将具有MVC端点（默认情况下位于“ /”上，但可以通过<code class="literal">spring.cloud.function.web.path</code> ），可用于访问应用程序上下文中的功能。支持的内容类型是纯文本和JSON。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"><col class="col_5"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">方法</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">路径</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">请求</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">响应</th><th align="left" valign="top" style="border-bottom:1px solid">状态</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>得到</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/ {供应商}</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>--</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>来自指定供应商的物品</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>200 OK</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>开机自检</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/{消费者}</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>JSON对象或文本</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>镜像输入并将请求主体推入消费者</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>202接受</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>开机自检</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/{消费者}</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>JSON数组或带有新行的文本</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>反映输入并将身体一一推入消费者</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>202接受</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>开机自检</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/{功能}</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>JSON对象或文本</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用命名函数的结果</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>200 OK</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>开机自检</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/{功能}</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>JSON数组或带有新行的文本</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用命名函数的结果</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>200 OK</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>得到</p></td><td align="left" valign="top" style="border-right:1px solid"><p>/ {功能} / {项目}</p></td><td align="left" valign="top" style="border-right:1px solid"><p>--</p></td><td align="left" valign="top" style="border-right:1px solid"><p>将项目转换为对象并返回应用函数的结果</p></td><td align="left" valign="top"><p>200 OK</p></td></tr></tbody></table></div><p>如上表所示，端点的行为取决于方法以及传入请求数据的类型。当传入数据是单值的并且目标函数被声明为显然是单值的（即不返回集合或<code class="literal">Flux</code> ），那么响应也将包含一个值。对于多值响应，客户端可以通过发送“接受：文本/事件流”来请求服务器发送的事件流。</p><p>如果目录中只有一个功能（消费者等），则路径中的名称是可选的。可以使用管道或逗号分隔功能名称来解决复合函数（管道在URL路径中是合法的，但在命令行上键入会有点尴尬）。</p><p>如果目录中只有一个功能，而您想将一个特定功能映射到根路径（例如“ /”），或者您想组合多个功能然后映射到根路径，则可以这样做通过提供<code class="literal">spring.cloud.function.definition</code>该属性实际上由spring- = cloud-function-web模块用来为存在某种类型的冲突（例如，多个可用功能等）提供默认映射。</p><p>例如，</p><pre class="screen">--spring.cloud.function.definition=foo|bar</pre><p>上面的属性将组成'foo'和'bar'函数，并将组成的函数映射到“ /”路径。</p><p>在输入和输出中声明的函数和使用者<code class="literal">Message<?></code>将在输入消息上看到请求标头，并且输出消息标头将转换为HTTP标头。</p><p>在发布文本时，Spring Boot 2.0和更早的版本的响应格式可能会有所不同，具体取决于内容协商（提供内容类型和accpt标头以获得最佳效果）。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_standalone_streaming_applications" href="#_standalone_streaming_applications"></a> 129。独立流媒体应用程序</h2></div></div></div><p>要从代理（例如RabbitMQ或Kafka）发送或接收消息，您可以利用<code class="literal">spring-cloud-stream</code>项目及其与Spring Cloud Function的集成。有关更多详细信息和示例，请参考Spring Cloud Stream参考手册的<a class="link" href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_spring_cloud_function" target="_top">Spring Cloud Function</a>部分。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_deploying_a_packaged_function" href="#_deploying_a_packaged_function"></a> 130。部署打包功能</h2></div></div></div><p>Spring Cloud Function提供了一个“部署程序”库，通过该库，您可以使用隔离的类加载器启动jar文件（或爆炸存档或jar文件集），并公开其中定义的功能。这是一个非常强大的工具，例如，您可以在不更改目标jar文件的情况下，使函数适应各种不同的输入输出适配器。无服务器平台通常内置有这种功能，因此您可以将其视为此类平台中函数调用程序的构建块（实际上， <a class="link" href="https://projectriff.io" target="_top">Riff</a> Java函数调用程序使用此库）。</p><p>API的标准入口是Spring配置注释<code class="literal">@EnableFunctionDeployer</code> 。如果在Spring Boot应用程序中使用了该功能，则部署程序将启动并寻找一些配置以告知其在何处找到功能jar。用户至少必须提供一个<code class="literal">function.location</code>这是包含函数的存档的URL或资源位置。它可以选择使用<code class="literal">maven:</code>前缀以通过依赖关系查找来定位工件（请参见<code class="literal">FunctionProperties</code>有关完整的详细信息）。使用jar文件从jar文件引导Spring Boot应用程序。 <code class="literal">MANIFEST.MF</code>例如，找到一个起始类，以便标准的Spring Boot胖子罐工作良好。如果目标jar可以成功启动，则结果是在主应用程序的<code class="literal">FunctionCatalog</code> 。已注册的函数可以通过主应用程序中的代码来应用，即使它是在隔离的类加载器中创建的（通过deault实现）。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_functional_bean_definitions" href="#_functional_bean_definitions"></a> 131。功能Bean定义</h2></div></div></div><p>对于需要快速启动的小型应用程序，Spring Cloud Function支持“功能性”风格的Bean声明。bean声明的功能样式是Spring Framework 5.0的功能，在5.1中进行了重大增强。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_comparing_functional_with_traditional_bean_definitions" href="#_comparing_functional_with_traditional_bean_definitions"></a> 131.1将功能与传统Bean定义进行比较</h2></div></div></div><p>这是熟悉的普通Spring Cloud Function应用程序<code class="literal">@Configuration</code>和<code class="literal">@Bean</code>声明风格：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoApplication {

  <em><span class="hl-annotation" style="color: gray">@Bean</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; uppercase() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value -&gt; value.toUpperCase();
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(DemoApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

}</pre><p>您可以在无服务器平台（例如AWS Lambda或Azure Functions）中运行以上命令，也可以仅通过包含<code class="literal">spring-cloud-function-starter-web</code>在类路径上。运行main方法将公开可用于ping的终结点<code class="literal">uppercase</code>功能：</p><pre class="screen">$ curl localhost:8080 -d foo
FOO</pre><p>Web适配器在<code class="literal">spring-cloud-function-starter-web</code>使用Spring MVC，因此您需要一个Servlet容器。您也可以在默认服务器为netty的地方使用Webflux（即使您仍然愿意使用Servlet容器也可以）-只需添加<code class="literal">spring-cloud-starter-function-webflux</code>依赖。功能相同，并且两者都可以使用用户应用程序代码。</p><p>现在介绍功能Bean：可以将用户应用程序代码重铸为“功能”形式，如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoApplication <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> ApplicationContextInitializer&lt;GenericApplicationContext&gt; {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    FunctionalSpringApplication.run(DemoApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Function&lt;String, String&gt; uppercase() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value -&gt; value.toUpperCase();
  }

  <em><span class="hl-annotation" style="color: gray">@Override</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> initialize(GenericApplicationContext context) {
    context.registerBean(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"demo"</span>, FunctionRegistration.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>,
        () -&gt; <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FunctionRegistration&lt;&gt;(uppercase())
            .type(FunctionType.from(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).to(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>)));
  }

}</pre><p>主要区别在于：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">主班是<code class="literal">ApplicationContextInitializer</code> 。</li><li class="listitem">的<code class="literal">@Bean</code>方法已转换为对<code class="literal">context.registerBean()</code></li><li class="listitem">的<code class="literal">@SpringBootApplication</code>已被替换为<code class="literal">@SpringBootConfiguration</code>表示我们没有启用Spring Boot自动配置，但仍将该类标记为“入口点”。</li><li class="listitem">的<code class="literal">SpringApplication</code>从Spring Boot已替换为<code class="literal">FunctionalSpringApplication</code>来自Spring Cloud Function（它是一个子类）。</li></ul></div><p>您在Spring Cloud Function应用程序中注册的业务逻辑bean是类型<code class="literal">FunctionRegistration</code> 。这是一个包装，其中包含函数以及有关输入和输出类型的信息。在里面<code class="literal">@Bean</code>可以反射性地导出信息的应用程序形式，但是在功能性bean注册中，除非我们使用<code class="literal">FunctionRegistration</code> 。</p><p>替代使用<code class="literal">ApplicationContextInitializer</code>和<code class="literal">FunctionRegistration</code>是使应用程序本身实现<code class="literal">Function</code> （要么<code class="literal">Consumer</code>要么<code class="literal">Supplier</code> ）。示例（与上述等效）：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootConfiguration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DemoApplication <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> Function&lt;String, String&gt; {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    FunctionalSpringApplication.run(DemoApplication.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }

  <em><span class="hl-annotation" style="color: gray">@Override</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String uppercase(String value) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> value.toUpperCase();
  }

}</pre><p>如果您添加一个单独的独立类型的类，它也将起作用<code class="literal">Function</code>并在<code class="literal">SpringApplication</code>使用另一种形式的<code class="literal">run()</code>方法。最主要的是，泛型类型信息可在运行时通过类声明获得。</p><p>如果添加，该应用程序将在其自己的HTTP服务器中运行<code class="literal">spring-cloud-starter-function-webflux</code> （由于尚未实现嵌入式Servlet容器的功能形式，因此目前无法与MVC启动器一起使用）。该应用程序还可以在AWS Lambda或Azure Functions中正常运行，并且启动时间的改善是巨大的。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>“精简版” Web服务器在以下方面存在一些限制： <code class="literal">Function</code>签名-特别是尚不支持<code class="literal">Message</code>输入和输出，但POJO和任何种类的<code class="literal">Publisher</code>应该没事。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_testing_functional_applications" href="#_testing_functional_applications"></a> 131.2测试功能应用程序</h2></div></div></div><p>Spring Cloud Function还具有一些用于集成测试的实用程序，这些实用程序对于Spring Boot用户而言非常熟悉。例如，这是包装以上应用程序的HTTP服务器的集成测试：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@FunctionalSpringBootTest</span></em>
<em><span class="hl-annotation" style="color: gray">@AutoConfigureWebTestClient</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FunctionalTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> WebTestClient client;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> words() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		client.post().uri(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"/"</span>).body(Mono.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>), String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).exchange()
				.expectStatus().isOk().expectBody(String.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FOO"</span>);
	}

}</pre><p>该测试几乎与您要编写的测试相同<code class="literal">@Bean</code>同一应用的版本-唯一的区别是<code class="literal">@FunctionalSpringBootTest</code>注释，而不是常规<code class="literal">@SpringBootTest</code> 。所有其他作品，例如<code class="literal">@Autowired</code><code class="literal">WebTestClient</code>是标准的Spring Boot功能。</p><p>或者，您可以只使用非HTTP应用编写测试<code class="literal">FunctionCatalog</code> 。例如：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RunWith(SpringRunner.class)</span></em>
<em><span class="hl-annotation" style="color: gray">@FunctionalSpringBootTest</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FunctionalTests {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> FunctionCatalog catalog;

	<em><span class="hl-annotation" style="color: gray">@Test</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> words() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> Exception {
		Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; function = catalog.lookup(Function.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>,
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"function"</span>);
		assertThat(function.apply(Flux.just(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>)).blockFirst()).isEqualTo(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"FOO"</span>);
	}

}</pre><p>（ <code class="literal">FunctionCatalog</code>总是从返回函数<code class="literal">Flux</code>至<code class="literal">Flux</code> ，即使用户使用更简单的签名声明它们。）</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_limitations_of_functional_bean_declaration" href="#_limitations_of_functional_bean_declaration"></a> 131.3功能Bean声明的局限性</h2></div></div></div><p>与整个Spring Boot相比，大多数Spring Cloud Function应用程序的范围相对较小，因此我们能够轻松地使其适应这些功能Bean定义。如果您超出了有限的范围，则可以通过切换回来扩展Spring Cloud Function应用程序<code class="literal">@Bean</code>样式配置，或使用混合方法。例如，如果您想利用Spring Boot自动配置来与外部数据存储区集成，则需要使用<code class="literal">@EnableAutoConfiguration</code> 。如果需要，仍可以使用函数声明来定义函数（即“混合”样式），但是在这种情况下，您将需要使用以下命令显式关闭“全功能模式” <code class="literal">spring.functional.enabled=false</code>这样Spring Boot可以收回控制权。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_dynamic_compilation" href="#_dynamic_compilation"></a> 132。动态编译</h2></div></div></div><p>有一个示例应用程序，它使用函数编译器从配置属性中创建函数。原始的“功能样本”也具有该功能。您可以运行一些脚本来查看编译在运行时发生的情况。要运行这些示例，请更改为<code class="literal">scripts</code>目录：</p><pre class="screen">cd scripts</pre><p>另外，在本地启动RabbitMQ服务器（例如执行<code class="literal">rabbitmq-server</code> ）。</p><p>启动功能注册表服务：</p><pre class="screen">./function-registry.sh</pre><p>注册功能：</p><pre class="screen">./registerFunction.sh -n uppercase -f "f-&gt;f.map(s-&gt;s.toString().toUpperCase())"</pre><p>使用该功能运行REST微服务：</p><pre class="screen">./web.sh -f uppercase -p 9000
curl -H "Content-Type: text/plain" -H "Accept: text/plain" localhost:9000/uppercase -d foo</pre><p>注册供应商：</p><pre class="screen">./registerSupplier.sh -n words -f "()-&gt;Flux.just(\"foo\",\"bar\")"</pre><p>使用该供应商运行REST微服务：</p><pre class="screen">./web.sh -s words -p 9001
curl -H "Accept: application/json" localhost:9001/words</pre><p>注册消费者：</p><pre class="screen">./registerConsumer.sh -n print -t String -f "System.out::println"</pre><p>使用该使用者运行REST微服务：</p><pre class="screen">./web.sh -c print -p 9002
curl -X POST -H "Content-Type: text/plain" -d foo localhost:9002/print</pre><p>运行流处理微服务：</p><p>首先注册流字供应商：</p><pre class="screen">./registerSupplier.sh -n wordstream -f "()-&gt;Flux.interval(Duration.ofMillis(1000)).map(i-&gt;\"message-\"+i)"</pre><p>然后启动源（供应商），处理器（功能）和宿（消费者）应用程序（以相反的顺序）：</p><pre class="screen">./stream.sh -p 9103 -i uppercaseWords -c print
./stream.sh -p 9102 -i words -f uppercase -o uppercaseWords
./stream.sh -p 9101 -s wordstream -o words</pre><p>输出将显示在接收器应用程序的控制台中（每秒一条消息，转换为大写字母）：</p><pre class="screen">MESSAGE-0
MESSAGE-1
MESSAGE-2
MESSAGE-3
MESSAGE-4
MESSAGE-5
MESSAGE-6
MESSAGE-7
MESSAGE-8
MESSAGE-9
...</pre></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_serverless_platform_adapters" href="#_serverless_platform_adapters"></a> 133。无服务器平台适配器</h2></div></div></div><p>除了能够作为独立进程运行之外，Spring Cloud Function应用程序还可以适应运行现有的无服务器平台之一。在项目中，有适用于<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws" target="_top">AWS Lambda</a> ， <a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure" target="_top">Azure</a>和<a class="link" href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk" target="_top">Apache OpenWhisk的适配器</a> 。<a class="link" href="https://github.com/fnproject/fn" target="_top">Oracle Fn平台</a>具有自己的Spring Cloud Function适配器。<a class="link" href="https://projectriff.io" target="_top">Riff</a>支持Java函数，其<a class="link" href="https://github.com/projectriff/java-function-invoker" target="_top">Java Function Invoker</a>本机运行是Spring Cloud Function jar的适配器。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_aws_lambda" href="#_aws_lambda"></a> 133.1 AWS Lambda</h2></div></div></div><p><a class="link" href="https://aws.amazon.com/" target="_top">AWS</a>适配器将使用Spring Cloud Function应用并将其转换为可以在AWS Lambda中运行的表单。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_introduction_3" href="#_introduction_3"></a> 133.1.1简介</h3></div></div></div><p>适配器具有几个可以使用的通用请求处理程序。最通用的是<code class="literal">SpringBootStreamHandler</code> ，它使用杰克逊<code class="literal">ObjectMapper</code>由Spring Boot提供，用于序列化和反序列化函数中的对象。还有一个<code class="literal">SpringBootRequestHandler</code>您可以对其进行扩展，并提供输入和输出类型作为类型参数（使AWS能够检查类并自己进行JSON转换）。</p><p>如果您的应用有多个<code class="literal">@Bean</code>类型的<code class="literal">Function</code>等等，那么您可以通过配置选择要使用的一种<code class="literal">function.name</code> （例如<code class="literal">FUNCTION_NAME</code> AWS中的环境变量）。这些功能是从Spring Cloud中提取的<code class="literal">FunctionCatalog</code> （首先搜索<code class="literal">Function</code>然后<code class="literal">Consumer</code>最后<code class="literal">Supplier</code> ）。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_notes_on_jar_layout" href="#_notes_on_jar_layout"></a> 133.1.2有关JAR布局的注意事项</h3></div></div></div><p>Lambda在运行时不需要Spring Cloud Function Web或Stream适配器，因此在创建发送到AWS的JAR之前，可能需要排除那些适配器。 Lambda应用程序必须着色，但Spring Boot独立应用程序不必着色，因此您可以使用2个单独的jar（根据示例）运行同一应用程序。该示例应用程序将创建2个jar文件，其中一个包含一个<code class="literal">aws</code>用于在Lambda中进行部署的分类器，以及一个包括<code class="literal">spring-cloud-function-web</code>在运行时。Spring Cloud Function将尝试使用JAR文件清单为您找到一个“主类” <code class="literal">Start-Class</code>属性（如果您使用入门级父级，它将由Spring Boot工具为您添加）。如果没有<code class="literal">Start-Class</code>在清单中，您可以使用环境变量<code class="literal">MAIN_CLASS</code>将功能部署到AWS时。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_upload" href="#_upload"></a> 133.1.3上传</h3></div></div></div><p>建立样本<code class="literal">spring-cloud-function-samples/function-sample-aws</code>并上传<code class="literal">-aws</code> jar文件到Lambda。该处理程序可以是<code class="literal">example.Handler</code>要么<code class="literal">org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler</code> （类，而<span class="emphasis"><em>不是</em></span>一个方法参考的FQN，虽然确实LAMBDA法接受的参考文献）。</p><pre class="screen">./mvnw -U clean package</pre><p>使用AWS命令行工具，如下所示：</p><pre class="screen">aws lambda create-function --function-name Uppercase --role arn:aws:iam::[USERID]:role/service-role/[ROLE] --zip-file fileb://function-sample-aws/target/function-sample-aws-2.0.0.BUILD-SNAPSHOT-aws.jar --handler org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler --description "Spring Cloud Function Adapter Example" --runtime java8 --region us-east-1 --timeout 30 --memory-size 1024 --publish</pre><p>AWS示例中函数的输入类型是Foo，它具有一个称为“ value”的单个属性。因此，您需要使用它进行测试：</p><pre class="screen">{
  "value": "test"
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>AWS示例应用程序以“功能”风格编写（作为<code class="literal">ApplicationContextInitializer</code> ）。在Lambda中启动时，这比传统启动要快得多<code class="literal">@Bean</code>样式，所以如果您不需要<code class="literal">@Beans</code> （要么<code class="literal">@EnableAutoConfiguration</code> ），这是一个不错的选择。暖启动不受影响。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_platfom_specific_features" href="#_platfom_specific_features"></a> 133.1.4 Platfom的特定功能</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_http_and_api_gateway" href="#_http_and_api_gateway"></a> HTTP和API网关</h4></div></div></div><p>AWS具有一些特定于平台的数据类型，包括消息批处理，这比单独处理每个数据集要高效得多。要使用这些类型，您可以编写依赖于这些类型的函数。或者您可以依靠Spring从AWS类型中提取数据并将其转换为Spring <code class="literal">Message</code> 。为此，您要告诉AWS函数具有特定的通用处理程序类型（取决于AWS服务），并提供一个类型的bean <code class="literal">Function<Message<S>,Message<T>></code> ，在哪里<code class="literal">S</code>和<code class="literal">T</code>是您的业务数据类型。如果有多个类型的bean <code class="literal">Function</code>您可能还需要配置Spring Boot属性<code class="literal">function.name</code>作为目标bean的名称（例如，使用<code class="literal">FUNCTION_NAME</code>作为环境变量）。</p><p>支持的AWS服务和通用处理程序类型如下：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">服务</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">AWS类型</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">通用处理程序</th><th align="left" valign="top" style="border-bottom:1px solid"> </th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>API网关</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">APIGatewayProxyRequestEvent</code> ，<code class="literal">APIGatewayProxyResponseEvent</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>运动学</p></td><td align="left" valign="top" style="border-right:1px solid"><p>运动事件</p></td><td align="left" valign="top" style="border-right:1px solid"><p>org.springframework.cloud.function.adapter.aws。SpringBootKinesisEventHandler</p></td><td align="left" valign="top"> </td></tr></tbody></table></div><p>例如，要在API网关后面部署，请使用<code class="literal">--handler org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code>在您的AWS命令行中（通过UI）并定义一个<code class="literal">@Bean</code>类型的<code class="literal">Function<Message<Foo>,Message<Bar>></code>哪里<code class="literal">Foo</code>和<code class="literal">Bar</code>是POJO类型（AWS使用Jackson将对数据进行编组和解组）。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_azure_functions" href="#_azure_functions"></a> 133.2 Azure函数</h2></div></div></div><p><a class="link" href="https://azure.microsoft.com" target="_top">Azure</a>适配器引导Spring Cloud Function上下文，并在必要时使用Spring Boot配置将来自Azure框架的函数调用引导到用户函数中。Azure Functions具有一个非常独特但具有侵入性的编程模型，其中涉及特定于平台的用户代码中的注释。在Spring Cloud中使用它的最简单方法是扩展基类并使用<code class="literal">@FunctionName</code>委托给基类方法的注释。</p><p>该项目为Azure上的Spring Cloud Function应用程序提供了一个适配器层。您可以编写一个应用程序<code class="literal">@Bean</code>类型的<code class="literal">Function</code>如果您正确布置了JAR文件，它将可以在Azure中部署。</p><p>有一个<code class="literal">AzureSpringBootRequestHandler</code>您必须对其进行扩展，并提供输入和输出类型作为带注释的方法参数（使Azure能够检查类并创建JSON绑定）。基类有两个有用的方法（ <code class="literal">handleRequest</code>和<code class="literal">handleOutput</code> ），您可以将实际的函数调用委托给该函数，因此大多数情况下，该函数只会有一行。</p><p>例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> FooHandler <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> AzureSpringBootRequestHandler&lt;Foo, Bar&gt; {
	<em><span class="hl-annotation" style="color: gray">@FunctionName("uppercase")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Bar execute(
			<em><span class="hl-annotation" style="color: gray">@HttpTrigger(name = "req", methods = { HttpMethod.GET,
					HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS)</span></em>
                    Foo foo,
			ExecutionContext context) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> handleRequest(foo, context);
	}
}</pre><p>此Azure处理程序将委派给<code class="literal">Function<Foo,Bar></code> bean （或<code class="literal">Function<Publisher<Foo>,Publisher<Bar>></code> ）。一些Azure触发器（例如<code class="literal">@CosmosDBTrigger</code> ）导致输入类型为<code class="literal">List</code>在这种情况下，您可以绑定到<code class="literal">List</code>在Azure处理程序中，或<code class="literal">String</code> （原始JSON）。的<code class="literal">List</code>输入代表<code class="literal">Function</code>输入类型<code class="literal">Map<String,Object></code> ， 要么<code class="literal">Publisher</code>要么<code class="literal">List</code>相同类型的。输出<code class="literal">Function</code>可以是<code class="literal">List</code> （一对一）或单个值（聚合），并且Azure声明中的输出绑定应匹配。</p><p>如果您的应用有多个<code class="literal">@Bean</code>类型的<code class="literal">Function</code>等等，那么您可以通过配置选择要使用的一种<code class="literal">function.name</code> 。或者，如果您使<code class="literal">@FunctionName</code>在Azure处理程序方法中，应使函数名称与该函数名称匹配（也适用于具有多个功能的函数应用程序）。这些功能是从Spring Cloud中提取的<code class="literal">FunctionCatalog</code>因此默认函数名称与Bean名称相同。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_notes_on_jar_layout_2" href="#_notes_on_jar_layout_2"></a> 133.2.1有关JAR布局的注意事项</h3></div></div></div><p>在Azure的运行时中不需要Spring Cloud Function Web，因此可以在创建部署到Azure的JAR之前将其排除在外，但是如果包含它，则不会使用它，因此保留它不会有任何伤害在。Azure上的功能应用程序是由Maven插件生成的存档。该函数位于此项目生成的JAR文件中。该示例使用精简布局将其创建为可执行jar，以便Azure可以找到处理程序类。如果您愿意，可以只使用常规的平面JAR文件。依赖性<span class="strong"><strong>不</strong></span>应该包括在内。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_build" href="#_build"></a> 133.2.2建立</h3></div></div></div><pre class="screen">./mvnw -U clean package</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_running_the_sample" href="#_running_the_sample"></a> 133.2.3运行样本</h3></div></div></div><p>您可以像其他Spring Cloud Function示例一样在本地运行示例：</p><p></p><p></p><p>和<code class="literal">curl -H "Content-Type: text/plain" localhost:8080/function -d '{"value": "hello foobar"}'</code> 。</p><p>您将需要<code class="literal">az</code> CLI应用程序（有关更多详细信息，请参见<a class="link" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven" target="_top">https://docs.microsoft.com/zh-cn/azure/azure-functions/functions-create-first-java-maven</a> ）。要将功能部署在Azure运行时上：</p><pre class="screen">$ az login
$ mvn azure-functions:deploy</pre><p>在另一个终端上，尝试以下操作： <code class="literal">curl <a class="link" href="https://<azure-function-url-from-the-log>/api/uppercase" target="_top">https://<azure-function-url-from-the-log>/api/uppercase</a> -d '{"value": "hello foobar!"}'</code> 。请确保为上述功能使用正确的URL。或者，您可以在Azure仪表板UI中测试该功能（单击功能名称，转到右侧，然后单击“测试”，然后单击右下角的“运行”）。</p><p>Azure示例中函数的输入类型是具有单个属性“ Foo”的Foo。因此，您需要使用以下代码进行测试：</p><pre class="screen">{
  "value": "foobar"
}</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Azure示例应用程序以“非功能性”样式编写（使用<code class="literal">@Bean</code> ）。功能风格（与<code class="literal">Function</code>要么<code class="literal">ApplicationContextInitializer</code> ）在Azure中启动时比传统方式快得多<code class="literal">@Bean</code>样式，所以如果您不需要<code class="literal">@Beans</code> （要么<code class="literal">@EnableAutoConfiguration</code> ），这是一个不错的选择。暖启动不受影响。</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_apache_openwhisk" href="#_apache_openwhisk"></a> 133.3 Apache Openwhisk</h2></div></div></div><p><a class="link" href="https://openwhisk.apache.org/" target="_top">OpenWhisk</a>适配器采用可执行jar的形式，可在docker映像中使用，以部署到Openwhisk。该平台以请求-响应模式工作，侦听特定端点上的端口8080，因此该适配器是一个简单的Spring MVC应用程序。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_quick_start_5" href="#_quick_start_5"></a> 133.3.1快速入门</h3></div></div></div><p>实施POF（请务必使用<code class="literal">functions</code>包）：</p><pre class="screen">package functions;

import java.util.function.Function;

public class Uppercase implements Function&lt;String, String&gt; {

	public String apply(String input) {
		return input.toUpperCase();
	}
}</pre><p>将其安装到本地Maven存储库中：</p><pre class="screen">./mvnw clean install</pre><p>创建一个<code class="literal">function.properties</code>提供其Maven坐标的文件。例如：</p><pre class="screen">dependencies.function: com.example:pof:0.0.1-SNAPSHOT</pre><p>将openwhisk运行程序JAR复制到工作目录（与属性文件相同的目录）：</p><pre class="screen">cp spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk/target/spring-cloud-function-adapter-openwhisk-2.0.0.BUILD-SNAPSHOT.jar runner.jar</pre><p>从生成一个M2回购<code class="literal">--thin.dryrun</code>具有以上属性文件的运行器JAR：</p><pre class="screen">java -jar -Dthin.root=m2 runner.jar --thin.name=function --thin.dryrun</pre><p>使用以下Dockerfile：</p><pre class="screen">FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY m2 /m2
ADD runner.jar .
ADD function.properties .
ENV JAVA_OPTS=""
ENTRYPOINT [ "java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "runner.jar", "--thin.root=/m2", "--thin.name=function", "--function.name=uppercase"]
EXPOSE 8080</pre><div class="blockquote"><blockquote class="blockquote"><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您可以使用Spring Cloud Function应用程序，而不是仅使用带有POF的jar，在这种情况下，您必须更改应用程序在容器中的运行方式，以便它将主类用作源文件。例如，您可以更改<code class="literal">ENTRYPOINT</code>以上并添加<code class="literal">--spring.main.sources=com.example.SampleApplication</code> 。</p></td></tr></tbody></table></div></blockquote></div><p>构建Docker映像：</p><pre class="screen">docker build -t [username/appname] .</pre><p>推送Docker映像：</p><pre class="screen">docker push [username/appname]</pre><p>使用OpenWhisk CLI（例如<code class="literal">vagrant ssh</code> ）创建操作：</p><pre class="screen">wsk action create example --docker [username/appname]</pre><p>调用动作：</p><pre class="screen">wsk action invoke example --result --param payload foo
{
    "result": "FOO"
}</pre></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_spring_cloud_kubernetes" href="#_spring_cloud_kubernetes"></a>第十七部分。 Spring Cloud Kubernetes</h1></div></div></div><div class="partintro"><div></div><p>本参考指南介绍了如何使用Spring Cloud Kubernetes。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_why_do_you_need_spring_cloud_kubernetes" href="#_why_do_you_need_spring_cloud_kubernetes"></a> 134。为什么需要Spring Cloud Kubernetes？</h2></div></div></div><p>Spring Cloud Kubernetes提供了使用Kubernetes本机服务的Spring Cloud通用接口实现。该存储库中提供的项目的主要目的是促进Kubernetes中运行的Spring Cloud和Spring Boot应用程序的集成。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_starters" href="#_starters"></a> 135。初学者</h2></div></div></div><p>入门程序是方便的依赖项描述符，您可以在应用程序中包含它们。包括一个启动器以获取功能集的依赖关系和Spring Boot自动配置。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">起动机</th><th align="left" valign="top" style="border-bottom:1px solid">特征</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-kubernetes<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></td><td align="left" valign="top" style="border-bottom:1px solid"><p>将服务名称解析为Kubernetes Services的<a class="link" href="#_discoveryclient_for_kubernetes" title="136。Kubernetes的DiscoveryClient">Discovery Client</a>实现。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-kubernetes-config<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></td><td align="left" valign="top" style="border-bottom:1px solid"><p>从Kubernetes <a class="link" href="#">ConfigMap</a>和<a class="link" href="#_secrets_propertysource" title="138.2机密PropertySource">Secrets</a>加载应用程序属性。
ConfigMap或Secret更改时， <a class="link" href="#">重新加载</a>应用程序属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-kubernetes-ribbon<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></td><td align="left" valign="top" style="border-bottom:1px solid"><p>从Kubernetes端点获取具有服务器列表的<a class="link" href="#">功能区</a>客户端负载均衡器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-kubernetes-all<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></td><td align="left" valign="top"><p>Spring Cloud Kubernetes的所有功能。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_discoveryclient_for_kubernetes" href="#_discoveryclient_for_kubernetes"></a> 136。Kubernetes的DiscoveryClient</h2></div></div></div><p>该项目提供了<a class="link" href="https://kubernetes.io" target="_top">Kubernetes</a>的<a class="link" href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/DiscoveryClient.java" target="_top">Discovery Client</a>的<a class="link" href="https://kubernetes.io" target="_top">实现</a> 。通过此客户端，您可以按名称查询Kubernetes端点（请参阅<a class="link" href="https://kubernetes.io/docs/user-guide/services/" target="_top">服务</a> ）。Kubernetes API服务器通常将服务公开为代表以下内容的端点的集合： <code class="literal">http</code>和<code class="literal">https</code>地址，客户端可以从作为Pod运行的Spring Boot应用程序访问。Spring Cloud Kubernetes Ribbon项目还使用此发现功能来获取为要进行负载平衡的应用程序定义的端点列表。</p><p>您可以通过在项目内部添加以下依赖项来免费获得这些东西：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-kubernetes<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div><p>启用加载<code class="literal">DiscoveryClient</code> ，添加<code class="literal">@EnableDiscoveryClient</code>到相应的配置或应用程序类，如以下示例所示：</p><div class="informalexample"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<em><span class="hl-annotation" style="color: gray">@EnableDiscoveryClient</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Application {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(String[] args) {
    SpringApplication.run(Application.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, args);
  }
}</pre></div><p>然后，您可以简单地通过自动装配将客户端注入代码中，如以下示例所示：</p><div class="informalexample"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> DiscoveryClient discoveryClient;</pre></div><p>您可以选择启用<code class="literal">DiscoveryClient</code>在所有名称空间中设置以下属性<code class="literal">application.properties</code> ：</p><div class="informalexample"><pre class="screen">spring.cloud.kubernetes.discovery.all-namespaces=true</pre></div><p>如果出于任何原因需要禁用<code class="literal">DiscoveryClient</code> ，您可以在中设置以下属性<code class="literal">application.properties</code> ：</p><div class="informalexample"><pre class="screen">spring.cloud.kubernetes.discovery.enabled=false</pre></div><p>一些Spring Cloud组件使用<code class="literal">DiscoveryClient</code>为了获取有关本地服务实例的信息。为此，您需要将Kubernetes服务名称与<code class="literal">spring.application.name</code>属性。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p><code class="literal">spring.application.name</code>对于在Kubernetes中为该应用程序注册的名称无效</p></td></tr></tbody></table></div><p>Spring Cloud Kubernetes还可以监视Kubernetes服务目录以进行更改并更新<code class="literal">DiscoveryClient</code>相应地实施。为了启用此功能，您需要添加<code class="literal">@EnableScheduling</code>在应用程序中的配置类上。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_kubernetes_native_service_discovery" href="#_kubernetes_native_service_discovery"></a> 137。Kubernetes本机服务发现</h2></div></div></div><p>Kubernetes本身具有（服务器端）服务发现的能力（请参阅： <a class="link" href="https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services" target="_top">https</a> ://kubernetes.io/docs/concepts/services-networking/service/#discovering-services）。使用本机kubernetes服务发现可确保与其他工具的兼容性，例如Istio（ <a class="link" href="https://istio.io" target="_top">https://istio.io</a> ），该服务网具有负载均衡，功能区，断路器，故障转移等功能。</p><p>然后，调用者服务仅需要引用特定Kubernetes群集中可解析的名称。一个简单的实现可以使用spring <code class="literal">RestTemplate</code>指的是完全限定域名（FQDN），例如<code class="literal"><a class="link" href="https://{service-name}.{namespace}.svc.{cluster}.local:{service-port}" target="_top">https://{service-name}.{namespace}.svc.{cluster}.local:{service-port}</a></code> 。</p><p>此外，您可以将Hystrix用于：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">调用方的断路器实现，方法是在Spring Boot应用程序类中添加注释<code class="literal">@EnableCircuitBreaker</code></li><li class="listitem">后备功能，通过使用注释相应的方法<code class="literal">@HystrixCommand(fallbackMethod=</code></li></ul></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_kubernetes_propertysource_implementations" href="#_kubernetes_propertysource_implementations"></a> 138。Kubernetes PropertySource实现</h2></div></div></div><p>配置Spring Boot应用程序的最常见方法是创建一个<code class="literal">application.properties</code>要么<code class="literal">applicaiton.yaml</code>或<code class="literal">application-profile.properties</code>要么<code class="literal">application-profile.yaml</code>包含键值对的文件，这些键值对为您的应用程序或Spring Boot启动器提供自定义值。您可以通过指定系统属性或环境变量来覆盖这些属性。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="configmap-propertysource" href="#configmap-propertysource"></a> 138.1使用<code class="literal">ConfigMap</code> <code class="literal">PropertySource</code></h2></div></div></div><p>Kubernetes提供了一个名为<a class="link" href="https://kubernetes.io/docs/user-guide/configmap/" target="_top"><code class="literal">ConfigMap</code></a>外部化参数以键值对或嵌入式的形式传递到您的应用程序<code class="literal">application.properties</code>要么<code class="literal">application.yaml</code>文件。<a class="link" href="./spring-cloud-kubernetes-config" target="_top">Spring Cloud Kubernetes Config</a>项目使Kubernetes <code class="literal">ConfigMap</code>实例在应用程序引导期间可用，并在检测到发现变化时触发Bean或Spring上下文的热重载<code class="literal">ConfigMap</code>实例。</p><p>默认行为是创建一个<code class="literal">ConfigMapPropertySource</code>基于Kubernetes <code class="literal">ConfigMap</code>有一个<code class="literal">metadata.name</code> Spring应用程序名称的值（由其定义） <code class="literal">spring.application.name</code>属性）或在<code class="literal">bootstrap.properties</code>文件按以下键： <code class="literal">spring.cloud.kubernetes.config.name</code> 。</p><p>但是，可以在其中使用多个配置的情况下进行更高级的配置<code class="literal">ConfigMap</code>实例。的<code class="literal">spring.cloud.kubernetes.config.sources</code>列表使这成为可能。例如，您可以定义以下内容<code class="literal">ConfigMap</code>实例：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    name</span>: cloud-k8s-app
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  cloud</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    kubernetes</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      config</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        name</span>: default-name
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        namespace</span>: default-namespace
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        sources</span>:
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Spring Cloud Kubernetes looks up a ConfigMap named c1 in namespace default-namespace</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">         - name</span>: c1
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Spring Cloud Kubernetes looks up a ConfigMap named default-name in whatever namespace n2</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">         - namespace</span>: n2
         <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># Spring Cloud Kubernetes looks up a ConfigMap named c3 in namespace n3</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">         - namespace</span>: n3
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">           name</span>: c3</pre></div><p>在前面的示例中，如果<code class="literal">spring.cloud.kubernetes.config.namespace</code>尚未设置， <code class="literal">ConfigMap</code>命名<code class="literal">c1</code>将在应用程序运行的名称空间中查找。</p><p>任何匹配<code class="literal">ConfigMap</code>找到的内容按以下方式处理：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">应用单个配置属性。</li><li class="listitem">申请为<code class="literal">yaml</code>任何名为属性的内容<code class="literal">application.yaml</code> 。</li><li class="listitem">将名为以下内容的任何属性的内容用作属性文件<code class="literal">application.properties</code> 。</li></ul></div><p>上述流程的唯一例外是<code class="literal">ConfigMap</code>包含指示所述文件中的<span class="strong"><strong>单个</strong></span>密钥是YAML或属性文件。在这种情况下，密钥的名称不必是<code class="literal">application.yaml</code>要么<code class="literal">application.properties</code> （可以是任何值），并且属性的值已正确处理。此功能有助于在以下情况下使用： <code class="literal">ConfigMap</code>是通过使用以下内容创建的：</p><div class="informalexample"><pre class="screen">kubectl create configmap game-config --from-file=/path/to/app-config.yaml</pre></div><p>假设我们有一个名为Spring Boot的应用程序<code class="literal">demo</code>使用以下属性读取其线程池配置。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">pool.size.core</code></li><li class="listitem"><code class="literal">pool.size.maximum</code></li></ul></div><p>这可以外部化到配置映射中<code class="literal">yaml</code>格式如下：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  pool.size.core</span>: <span class="hl-number">1</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  pool.size.max</span>: <span class="hl-number">16</span></pre></div><p>在大多数情况下，单个属性都可以正常工作。但是，有时嵌入<code class="literal">yaml</code>比较方便在这种情况下，我们使用一个名为<code class="literal">application.yaml</code>嵌入我们的<code class="literal">yaml</code> ， 如下：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application.yaml</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    pool</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      size</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        core</span>: <span class="hl-number">1</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        max</span>:<span class="hl-number">16</span></pre></div><p>以下示例也适用：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  custom-name.yaml</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    pool</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      size</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        core</span>: <span class="hl-number">1</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        max</span>:<span class="hl-number">16</span></pre></div><p>您还可以根据活动配置文件的不同方式配置Spring Boot应用程序，这些活动配置文件在<code class="literal">ConfigMap</code>被读取。您可以使用来为不同的配置文件提供不同的属性值<code class="literal">application.properties</code>要么<code class="literal">application.yaml</code>属性，指定特定于配置文件的值，每个值都在各自的文档中（由<code class="literal">---</code>顺序），如下所示：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application.yml</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Hello to the World
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Goodbye
    ---
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      profiles</span>: development
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Hello to the Developers
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Goodbye to the Developers
    ---
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      profiles</span>: production
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Hello to the Ops</pre></div><p>在上述情况下，配置将通过<code class="literal">development</code>简介如下：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    message</span>: Say Hello to the Developers
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    message</span>: Say Goodbye to the Developers</pre></div><p>但是，如果<code class="literal">production</code>配置文件处于活动状态，配置变为：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    message</span>: Say Hello to the Ops
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    message</span>: Say Goodbye</pre></div><p>如果两个配置文件均处于活动状态，则在<code class="literal">ConfigMap</code>覆盖任何先前的值。</p><p>另一个选择是为每个配置文件创建一个不同的配置映射，Spring Boot会根据活动配置文件自动获取它</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application.yml</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Hello to the World
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Goodbye</pre></div><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo-development
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application.yml</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      profiles</span>: development
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Hello to the Developers
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Goodbye to the Developers</pre></div><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: demo-production
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application.yml</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spring</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      profiles</span>: production
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    greeting</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Hello to the Ops
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    farewell</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      message</span>: Say Goodbye</pre></div><p>告诉Spring Boot哪个<code class="literal">profile</code>如果要在启动时启用，则可以将系统属性传递给Java命令。为此，您可以使用可通过OpenShift定义的环境变量来启动Spring Boot应用程序。 <code class="literal">DeploymentConfig</code>或Kubernetes <code class="literal">ReplicationConfig</code>资源文件，如下：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: DeploymentConfig
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spec</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  replicas</span>: <span class="hl-number">1</span>
  ...
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    spec</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      containers</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">      - env</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: JAVA_APP_DIR
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          value</span>: /deployments
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">        - name</span>: JAVA_OPTIONS
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">          value</span>: -Dspring.profiles.active=developer</pre></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您应该检查安全性配置部分。要从Pod内部访问配置映射，您需要具有正确的Kubernetes服务帐户，角色和角色绑定。</p></td></tr></tbody></table></div><p>使用的另一种选择<code class="literal">ConfigMap</code>实例是通过运行Spring Cloud Kubernetes应用程序并使Spring Cloud Kubernetes从文件系统读取它们来将它们装入Pod。此行为由<code class="literal">spring.cloud.kubernetes.config.paths</code>属性。您可以使用它作为上述机制的补充或替代。您可以在中指定多个（完全）文件路径<code class="literal">spring.cloud.kubernetes.config.paths</code>通过使用<code class="literal">,</code>定界符。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您必须提供每个属性文件的完整确切路径，因为不会递归解析目录。</p></td></tr></tbody></table></div><div class="table"><a name="d0e37112" href="#d0e37112"></a><p class="title"><b>表138.1。特性：</b></p><div class="table-contents"><table class="table" summary="Properties:" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">名称</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">类型</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">默认</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tfoot><tr><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.kubernetes.config.enableApi</code></p></th><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">Boolean</code></p></th><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">true</code></p></th><th align="left" valign="top"><p>启用或禁用消费<code class="literal">ConfigMap</code>通过API实例</p></th></tr></tfoot><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.config.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Boolean</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用ConfigMap<code class="literal">PropertySource</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.config.name</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">String</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">${spring.application.name}</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置名称<code class="literal">ConfigMap</code>去查查看</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.config.namespace</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">String</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>客户端名称空间</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置Kubernetes命名空间的查找位置</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.kubernetes.config.paths</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">List</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">null</code></p></td><td align="left" valign="top"><p>设置路径<code class="literal">ConfigMap</code>实例已安装</p></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_secrets_propertysource" href="#_secrets_propertysource"></a> 138.2机密PropertySource</h2></div></div></div><p>Kubernetes具有用于存储敏感数据（例如密码，OAuth令牌等）的<a class="link" href="https://kubernetes.io/docs/concepts/configuration/secret/" target="_top">秘密</a>的概念。该项目提供了与<code class="literal">Secrets</code>通过Spring Boot应用程序访问机密。您可以通过设置以下选项来显式启用或禁用此功能<code class="literal">spring.cloud.kubernetes.secrets.enabled</code>属性。</p><p>启用后， <code class="literal">SecretsPropertySource</code>查找Kubernetes <code class="literal">Secrets</code>来自以下来源：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">从秘密坐骑递归读取</li><li class="listitem">以应用程序命名（由定义<code class="literal">spring.application.name</code> ）</li><li class="listitem">匹配一些标签</li></ol></div><p><span class="strong"><strong>注意：</strong></span></p><p>默认情况下，出于安全原因， <span class="strong"><strong>未启用</strong></span>通过API消费机密（以上第2点和第3点）。机密上的权限“列表”允许客户端检查指定名称空间中的机密值。此外，我们建议容器通过安装的卷共享机密。</p><p>如果您通过API启用使用机密，我们建议您使用授权策略（例如RBAC）限制对机密的访问。有关通过API使用“机密”时的风险和最佳做法的更多信息，请参阅<a class="link" href="https://kubernetes.io/docs/concepts/configuration/secret/#best-practices" target="_top">此文档</a> 。</p><p>如果找到了机密，则其数据可供应用程序使用。</p><p>假设我们有一个名为Spring Boot的应用程序<code class="literal">demo</code>使用属性读取其数据库配置。我们可以使用以下命令创建Kubernetes机密：</p><div class="informalexample"><pre class="screen">oc create secret generic db-secret --from-literal=username=user --from-literal=password=p455w0rd</pre></div><p>前面的命令将创建以下秘密（您可以使用来查看<code class="literal">oc get secrets db-secret -o yaml</code> ）：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  password</span>: cDQ1NXcwcmQ=
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  username</span>: dXNlcg==
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: Secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  creationTimestamp</span>: <span class="hl-number">2017</span>-<span class="hl-number">07</span>-<span class="hl-number">04</span>T09:<span class="hl-number">15</span>:<span class="hl-number">57</span>Z
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: db-secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  namespace</span>: default
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  resourceVersion</span>: <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"357496"</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  selfLink</span>: /api/v1/namespaces/default/secrets/db-secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  uid</span>: <span class="hl-number">63</span>c89263-<span class="hl-number">6099</span>-<span class="hl-number">11e7</span>-b3da-<span class="hl-number">76d</span>6186905a8
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">type</span>: Opaque</pre></div><p>请注意，数据包含Base64编码版本的文字， <code class="literal">create</code>命令。</p><p>然后，您的应用程序可以使用此机密-例如，通过将机密的值导出为环境变量：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: Deployment
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: ${project.artifactId<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">spec</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">   template</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">     spec</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">       containers</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">         - env</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            - name</span>: DB_USERNAME
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              valueFrom</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                 secretKeyRef</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                   name</span>: db-secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                   key</span>: username
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">            - name</span>: DB_PASSWORD
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">              valueFrom</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                 secretKeyRef</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                   name</span>: db-secret
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">                   key</span>: password</pre></div><p>您可以通过多种方式选择要使用的秘密：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">通过列出映射机密的目录：</p><div class="informalexample"><pre class="programlisting">-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets/db-secret,etc/secrets/postgresql</pre></div><p class="simpara">如果将所有机密映射到公共根，则可以将它们设置为：</p><div class="informalexample"><pre class="programlisting">-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets</pre></div></li><li class="listitem"><p class="simpara">通过设置命名机密：</p><div class="informalexample"><pre class="programlisting">-Dspring.cloud.kubernetes.secrets.name=db-secret</pre></div></li><li class="listitem"><p class="simpara">通过定义标签列表：</p><div class="informalexample"><pre class="programlisting">-Dspring.cloud.kubernetes.secrets.labels.broker=activemq
-Dspring.cloud.kubernetes.secrets.labels.db=postgresql</pre></div></li></ol></div><div class="table"><a name="d0e37324" href="#d0e37324"></a><p class="title"><b>表138.2。特性：</b></p><div class="table-contents"><table class="table" summary="Properties:" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">名称</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">类型</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">默认</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tfoot><tr><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.kubernetes.secrets.enableApi</code></p></th><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">Boolean</code></p></th><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">false</code></p></th><th align="left" valign="top"><p>通过API启用或禁用使用机密（示例2和3）</p></th></tr></tfoot><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.secrets.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Boolean</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用秘密<code class="literal">PropertySource</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.secrets.name</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">String</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">${spring.application.name}</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置要查找的机密名称</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.secrets.namespace</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">String</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>客户端名称空间</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置Kubernetes命名空间的查找位置</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.secrets.labels</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Map</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">null</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置用于查找机密的标签</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.kubernetes.secrets.paths</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">List</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">null</code></p></td><td align="left" valign="top"><p>设置安装机密的路径（示例1）</p></td></tr></tbody></table></div></div><br class="table-break"><p>笔记：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">的<code class="literal">spring.cloud.kubernetes.secrets.labels</code>属性的行为与<a class="link" href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#map-based-binding" target="_top">基于Map的binding</a>定义的行为相同。</li><li class="listitem">的<code class="literal">spring.cloud.kubernetes.secrets.paths</code>属性的行为与<a class="link" href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#collection-based-binding" target="_top">基于Collection的binding</a>定义的行为相同。</li><li class="listitem">出于安全原因，可能会限制通过API访问机密。首选方法是将机密安装到Pod。</li></ul></div><p>您可以找到使用机密的应用程序示例（尽管尚未更新为使用新机密）。 <code class="literal">spring-cloud-kubernetes</code>项目）在<a class="link" href="https://github.com/fabric8-quickstarts/spring-boot-camel-config" target="_top">spring-boot-camel-config</a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_propertysource_reload" href="#_propertysource_reload"></a> 138.3 <code class="literal">PropertySource</code>重装</h2></div></div></div><p>某些应用程序可能需要检测外部属性源上的更改并更新其内部状态以反映新配置。Spring Cloud Kubernetes的重新加载功能能够在相关<code class="literal">ConfigMap</code>要么<code class="literal">Secret</code>变化。</p><p>默认情况下，此功能处于禁用状态。您可以使用<code class="literal">spring.cloud.kubernetes.reload.enabled=true</code>配置属性（例如，在<code class="literal">application.properties</code>文件）。</p><p>支持以下级别的重载（通过设置<code class="literal">spring.cloud.kubernetes.reload.strategy</code>财产）：* <code class="literal">refresh</code> （默认）：仅使用注释的配置Bean <code class="literal">@ConfigurationProperties</code>要么<code class="literal">@RefreshScope</code>重新加载。此重新加载级别利用了Spring Cloud Context的刷新功能。* <code class="literal">restart_context</code> ：整个春天<code class="literal">ApplicationContext</code>正常重启。使用新配置重新创建Bean。* <code class="literal">shutdown</code> ： 春天<code class="literal">ApplicationContext</code>关闭以激活容器的重新启动。使用此级别时，请确保所有非守护程序线程的生命周期都绑定到<code class="literal">ApplicationContext</code>并且复制控制器或副本集已配置为重新启动Pod。</p><p>假设使用默认设置启用了重新加载功能（ <code class="literal">refresh</code>模式），则当配置映射更改时，以下bean会刷新：</p><div class="informalexample"><pre class="screen">@Configuration
@ConfigurationProperties(prefix = "bean")
public class MyConfig {

    private String message = "a message that can be changed live";

    // getter and setters

}</pre></div><p>要查看更改是否有效发生，可以创建另一个Bean，该Bean定期打印消息，如下所示</p><div class="informalexample"><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyBean {

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MyConfig config;

    <em><span class="hl-annotation" style="color: gray">@Scheduled(fixedDelay = 5000)</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> hello() {
        System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"The message is: "</span> + config.getMessage());
    }
}</pre></div><p>您可以使用以下命令更改应用程序打印的消息<code class="literal">ConfigMap</code> ， 如下：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">apiVersion</span>: v1
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">kind</span>: ConfigMap
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">metadata</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  name</span>: reload-example
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">data</span>:
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">  application.properties</span>: |-
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">    bean.message</span>=Hello World!</pre></div><p>对名为属性的任何更改<code class="literal">bean.message</code>在里面<code class="literal">ConfigMap</code>与pod关联的内容会反映在输出中。一般而言，与属性相关联的更改的前缀为<code class="literal">prefix</code>的领域<code class="literal">@ConfigurationProperties</code>注释被检测到并反映在应用程序中。
<a class="link" href="#configmap-propertysource" title="138.1 Using a ConfigMap PropertySource">关联一个<code class="literal">ConfigMap</code></a>本章前面已说明<a class="link" href="#configmap-propertysource" title="138.1使用ConfigMap PropertySource">了带有吊舱的产品</a> 。</p><p>完整的示例在<a class="link" href="https://github.com/fabric8io/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples/kubernetes-reload-example" target="_top"><code class="literal">spring-cloud-kubernetes-reload-example</code></a> 。</p><p>重新加载功能支持两种操作模式：*事件（默认）：使用Kubernetes API（Web套接字）监视配置映射或机密的更改。任何事件都会对配置进行重新检查，并在发生更改的情况下重新加载。的<code class="literal">view</code>为了侦听配置映射更改，需要在服务帐户上具有角色。更高级别的角色（例如<code class="literal">edit</code> ）是机密信息所必需的（默认情况下，机密信息不受监视）。*轮询：从配置上通过配置映射和机密重新创建配置，以查看配置是否已更改。您可以使用以下命令配置轮询周期<code class="literal">spring.cloud.kubernetes.reload.period</code>属性，默认为15秒。它需要与受监视的属性源相同的角色。例如，这意味着对文件挂载的秘密源使用轮询不需要特定的特权。</p><div class="table"><a name="d0e37580" href="#d0e37580"></a><p class="title"><b>表138.3。特性：</b></p><div class="table-contents"><table class="table" summary="Properties:" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">名称</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">类型</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">默认</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tfoot><tr><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.kubernetes.reload.period</code></p></th><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">Duration</code></p></th><th align="left" valign="top" style="border-right:1px solid"><p><code class="literal">15s</code></p></th><th align="left" valign="top"><p>使用<code class="literal">polling</code>战略</p></th></tr></tfoot><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.reload.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Boolean</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">false</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用对属性源的监视和配置重载</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.reload.monitoring-config-maps</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Boolean</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>允许监视配置映射中的更改</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.kubernetes.reload.monitoring-secrets</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Boolean</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">false</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>允许监视机密更改</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.strategy`</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">Enum</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">refresh</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>触发重新加载时使用的策略（ <code class="literal">refresh</code> ， <code class="literal">restart_context</code> ， 要么<code class="literal">shutdown</code> ）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.kubernetes.reload.mode</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">Enum</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">event</code></p></td><td align="left" valign="top"><p>指定如何侦听属性源中的更改（ <code class="literal">event</code>要么<code class="literal">polling</code> ）</p></td></tr></tbody></table></div></div><br class="table-break"><p>注意：*您不应在以下位置使用属性<code class="literal">spring.cloud.kubernetes.reload</code>在配置映射或秘密中。在运行时更改此类属性可能会导致意外结果。*删除属性或整个配置映射不会恢复使用Bean的原始状态<code class="literal">refresh</code>水平。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_ribbon_discovery_in_kubernetes" href="#_ribbon_discovery_in_kubernetes"></a> 139。Kubernetes中的Ribbon发现</h2></div></div></div><p>调用微服务的Spring Cloud客户端应用程序应该对依靠客户端负载平衡功能感兴趣，以便自动发现它可以在哪个端点到达给定服务。该机制已在<a class="link" href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-ribbon" target="_top">spring-cloud-kubernetes-ribbon</a>项目中实现，其中Kubernetes客户端填充了<a class="link" href="https://github.com/Netflix/ribbon" target="_top">Ribbon</a> <code class="literal">ServerList</code>包含有关此类端点的信息。</p><p>该实现是以下启动器的一部分，您可以通过将其依赖项添加到pom文件中来使用该实现：</p><div class="informalexample"><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-starter-kubernetes-ribbon<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>${latest.version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div><p>填充端点列表后，Kubernetes客户端通过匹配功能区客户端注释中定义的服务名称来搜索当前名称空间或项目中存在的已注册端点，如下所示：</p><div class="informalexample"><pre class="programlisting">@RibbonClient(name = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name-service"</span>)</pre></div><p>您可以通过在您的属性中提供属性来配置功能区的行为<code class="literal">application.properties</code> （通过您应用的专用<code class="literal">ConfigMap</code> ），请使用以下格式： <code class="literal"><name of your service>.ribbon.<Ribbon configuration key></code> ，其中：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal"><name of your service></code>对应于您通过功能区访问的服务名称，使用<code class="literal">@RibbonClient</code>注释（例如<code class="literal">name-service</code>在前面的示例中）。</li><li class="listitem"><code class="literal"><Ribbon configuration key></code>是由下式定义的功能区的配置键中的一个<a class="link" href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java" target="_top">功能区的<code class="literal">CommonClientConfigKey</code>上课</a> 。</li></ul></div><p>此外， <code class="literal">spring-cloud-kubernetes-ribbon</code>该项目定义了两个附加的配置键，以进一步控制Ribbon与Kubernetes的交互方式。特别是，如果端点定义了多个端口，则默认行为是使用找到的第一个端口。要更具体地选择在多端口服务中使用哪个端口，可以使用<code class="literal">PortName</code>键。如果您想指定应在哪个Kubernetes命名空间中查找目标服务，则可以使用<code class="literal">KubernetesNamespace</code>密钥，请记住在两种情况下都要在这些密钥前加上您的服务名称和<code class="literal">ribbon</code>前缀，如前所述。</p><p>以下示例使用此模块进行功能区发现：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="./spring-cloud-kubernetes-examples/kubernetes-circuitbreaker-ribbon-example" target="_top">spring-cloud-circuitbreaker和功能区</a></li><li class="listitem"><a class="link" href="https://github.com/fabric8-quickstarts/spring-boot-ribbon" target="_top">fabric8-quickstarts-spring-boot-功能区</a></li><li class="listitem"><a class="link" href="https://github.com/fabric8io/kubeflix/tree/master/examples/loanbroker/bank" target="_top">Kubeflix-贷款经纪人-银行</a></li></ul></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您可以通过设置<code class="literal">spring.cloud.kubernetes.ribbon.enabled=false</code>应用程序属性文件中的密钥。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_kubernetes_ecosystem_awareness" href="#_kubernetes_ecosystem_awareness"></a> 140。Kubernetes生态系统意识</h2></div></div></div><p>无论您的应用程序是否在Kubernetes中运行，本指南前面介绍的所有功能都可以很好地工作。这对于开发和故障排除确实很有帮助。从开发的角度来看，这使您可以启动Spring Boot应用程序并调试属于该项目的模块之一。您无需将其部署在Kubernetes中，因为该项目的代码依赖于<a class="link" href="https://github.com/fabric8io/kubernetes-client" target="_top">Fabric8 Kubernetes Java客户端</a> ，它是一种流利的DSL，可以通过使用以下方式进行通信： <code class="literal">http</code> Kubernetes服务器的REST API的协议。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_kubernetes_profile_autoconfiguration" href="#_kubernetes_profile_autoconfiguration"></a> 140.1 Kubernetes配置文件自动配置</h2></div></div></div><p>当应用程序在Kubernetes中作为Pod运行时，名为Spring的配置文件<code class="literal">kubernetes</code>自动被激活。这使您可以自定义配置，以定义在Kubernetes平台内部署Spring Boot应用程序时要应用的bean（例如，不同的开发和生产配置）。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_istio_awareness" href="#_istio_awareness"></a> 140.2 Istio意识</h2></div></div></div><p>当您包括<code class="literal">spring-cloud-kubernetes-istio</code>模块中的应用程序的类路径，一个新的配置文件被添加到应用程序，所提供的应用程序正在运行一个Kubernetes集群里面<a class="link" href="https://istio.io" target="_top">Istio</a>安装。然后可以使用弹簧<code class="literal">@Profile("istio")</code> Bean中的注释和<code class="literal">@Configuration</code>类。</p><p>Istio意识模块使用<code class="literal">me.snowdrop:istio-client</code>与Istio API进行交互，使我们能够发现流量规则，断路器等，从而使我们的Spring Boot应用程序可以轻松使用此数据，以根据环境动态配置自身。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_pod_health_indicator" href="#_pod_health_indicator"></a> 141。 bean 荚健康指标</h2></div></div></div><p>Spring Boot的用途<a class="link" href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpoint.java" target="_top"><code class="literal">HealthIndicator</code></a>公开有关应用程序运行状况的信息。这使得用于暴露与健康相关的信息给用户它真的有用，使得它非常适合用作<a class="link" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_top">准备探头</a> 。</p><p>Kubernetes运行状况指示器（是核心模块的一部分）提供以下信息：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">窗格名称，IP地址，名称空间，服务帐户，节点名称及其IP地址</li><li class="listitem">一个标志，指示Spring Boot应用程序在Kubernetes内部还是外部</li></ul></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_leader_election" href="#_leader_election"></a> 142。领导人选举</h2></div></div></div><p><tbd></tbd></p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_security_configurations_inside_kubernetes" href="#_security_configurations_inside_kubernetes"></a> 143。Kubernetes内部的安全配置</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_namespace" href="#_namespace"></a> 143.1命名空间</h2></div></div></div><p>该项目中提供的大多数组件都需要知道名称空间。对于Kubernetes（1.3+），名称空间作为服务帐户密码的一部分可供Pod使用，并由客户端自动检测到。对于早期版本，需要将其指定为Pod的环境变量。一种快速的方法如下：</p><div class="informalexample"><pre class="screen">      env:
      - name: "KUBERNETES_NAMESPACE"
        valueFrom:
          fieldRef:
            fieldPath: "metadata.namespace"</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_service_account" href="#_service_account"></a> 143.2服务帐号</h2></div></div></div><p>对于支持集群内基于角色的更细粒度访问的Kubernetes发行版，您需要确保与<code class="literal">spring-cloud-kubernetes</code>有权访问Kubernetes API。对于您分配给部署或Pod的任何服务帐户，您需要确保它们具有正确的角色。例如，您可以添加<code class="literal">cluster-reader</code>您的权限<code class="literal">default</code>服务帐户，具体取决于您所在的项目。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_service_registry_implementation" href="#_service_registry_implementation"></a> 144。服务注册表实施</h2></div></div></div><p>在Kubernetes服务注册由平台控制的情况下，应用程序本身不像其他平台那样控制注册。因此，使用<code class="literal">spring.cloud.service-registry.auto-registration.enabled</code>或设置<code class="literal">@EnableDiscoveryClient(autoRegister=false)</code>在Spring Cloud Kubernetes中将无效。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_examples_2" href="#_examples_2"></a> 145。例子</h2></div></div></div><p>Spring Cloud Kubernetes尝试通过遵循Spring Cloud接口使应用程序使用Kubernetes Native Services透明化。</p><p>在您的应用程序中，您需要添加<code class="literal">spring-cloud-kubernetes-discovery</code>对您的类路径的依赖关系，并删除任何其他包含<code class="literal">DiscoveryClient</code>实施（即Eureka发现客户端）。同样适用于<code class="literal">PropertySourceLocator</code> ，您需要在其中添加类路径<code class="literal">spring-cloud-kubernetes-config</code>并删除任何其他包含<code class="literal">PropertySourceLocator</code>实现（即配置服务器客户端）。</p><p>以下项目重点介绍了这些依赖项的用法，并演示了如何从任何Spring Boot应用程序中使用这些库：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples" target="_top">Spring Cloud Kubernetes示例</a> ：位于此存储<a class="link" href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples" target="_top">库内的示例</a> 。</li><li class="listitem"><p class="simpara">Spring Cloud Kubernetes完整示例：奴才和上司</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem"><a class="link" href="https://github.com/salaboy/spring-cloud-k8s-minion" target="_top">奴才</a></li><li class="listitem"><a class="link" href="https://github.com/salaboy/spring-cloud-k8s-boss" target="_top">老板</a></li></ul></div></li><li class="listitem">Spring Cloud Kubernetes完整示例： <a class="link" href="https://github.com/salaboy/s1p_docs" target="_top">SpringOne Platform Tickets Service</a></li><li class="listitem"><a class="link" href="https://github.com/salaboy/s1p_gateway" target="_top">具有Spring Cloud Kubernetes发现和配置的Spring Cloud Gateway</a></li><li class="listitem"><a class="link" href="https://github.com/salaboy/showcase-admin-tool" target="_top">使用Spring Cloud Kubernetes发现和配置进行Spring Boot Admin</a></li></ul></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_other_resources" href="#_other_resources"></a> 146。其他资源</h2></div></div></div><p>本节列出了其他资源，例如有关Spring Cloud Kubernetes的演示（幻灯片）和视频。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://salaboy.com/2018/09/27/the-s1p-experience/" target="_top">PKS上的S1P Spring Cloud</a></li><li class="listitem"><a class="link" href="https://salaboy.com/2018/07/18/ljc-july-18-spring-cloud-docker-k8s/" target="_top">Spring Cloud，Docker，Kubernetes→伦敦Java社区2018年7月</a></li></ul></div><p>请随时通过拉取请求向<a class="link" href="https://github.com/spring-cloud/spring-cloud-kubernetes" target="_top">此存储库</a>提交其他资源。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_building" href="#_building"></a> 147。建造</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_basic_compile_and_test" href="#_basic_compile_and_test"></a> 147.1基本编译和测试</h2></div></div></div><p>要构建源代码，您将需要安装JDK 1.7。</p><p>Spring Cloud使用Maven进行大多数与构建相关的活动，并且您应该能够通过克隆您感兴趣的项目并键入来快速启动</p><pre class="screen">$ ./mvnw install</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>您也可以自己安装Maven（> = 3.3.3）并运行<code class="literal">mvn</code>命令代替<code class="literal">./mvnw</code>在下面的示例中。如果这样做，您可能还需要添加<code class="literal">-P spring</code>如果您的本地Maven设置不包含Spring预发行项目的存储库声明。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>请注意，您可能需要通过设置以下选项来增加Maven可用的内存量： <code class="literal">MAVEN_OPTS</code>具有以下值的环境变量<code class="literal">-Xmx512m -XX:MaxPermSize=128m</code> 。我们尝试在<code class="literal">.mvn</code>配置，因此，如果发现必须执行此操作才能使构建成功，请提出票证以将设置添加到源代码管理中。</p></td></tr></tbody></table></div><p>有关如何构建项目的提示，请参阅<code class="literal">.travis.yml</code>如果有一个。应该有一个“脚本”甚至“安装”命令。还要查看“服务”部分，以查看是否需要在本地运行任何服务（例如mongo或Rabbit）。忽略您可能在“ before_install”中找到的与git相关的位，因为它们与设置git凭据有关，并且您已经拥有了这些。</p><p>需要中间件的项目通常包括<code class="literal">docker-compose.yml</code> ，因此请考虑使用<a class="link" href="https://docs.docker.com/compose/" target="_top">Docker Compose</a>在Docker容器中运行中间件服务器。有关mongo，rabbit和redis常见情况的特定说明，请参见<a class="link" href="https://github.com/spring-cloud-samples/scripts" target="_top">脚本演示存储库中</a>的README。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果其他所有方法均失败，则使用以下命令构建<code class="literal">.travis.yml</code> （通常<code class="literal">./mvnw install</code> ）。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_documentation" href="#_documentation"></a> 147.2文档</h2></div></div></div><p>spring-cloud-build模块有一个“ docs”配置文件，如果您打开它，将尝试从以下目录构建asciidoc源<code class="literal">src/main/asciidoc</code> 。作为该过程的一部分，它将寻找<code class="literal">README.adoc</code>并通过加载所有包含项进行处理，但不对其进行解析或渲染，只需将其复制到<code class="literal">${main.basedir}</code> （默认为<code class="literal">$../../../..</code> ，即项目的根目录）。如果自述文件有任何更改，它将在Maven构建后以正确的位置显示为修改后的文件。只需提交并推动更改即可。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_working_with_the_code" href="#_working_with_the_code"></a> 147.3使用代码</h2></div></div></div><p>如果您没有IDE偏好设置，我们建议您在使用代码时使用<a class="link" href="https://www.springsource.com/developer/sts" target="_top">Spring Tools Suite</a>或<a class="link" href="https://eclipse.org" target="_top">Eclipse</a> 。我们使用<a class="link" href="https://eclipse.org/m2e/" target="_top">m2eclipse</a> eclipse插件来获得maven支持。只要其他IDE和工具使用Maven 3.3.3或更高版本，它们也应该可以正常工作。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_importing_into_eclipse_with_m2eclipse" href="#_importing_into_eclipse_with_m2eclipse"></a> 147.3.1使用m2eclipse导入eclipse</h3></div></div></div><p>使用eclipse时，我们建议使用<a class="link" href="https://eclipse.org/m2e/" target="_top">m2eclipse</a> eclipse插件。如果尚未安装m2eclipse，则可以从“ eclipse市场”中获得。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>较旧的m2e版本不支持Maven 3.3，因此一旦将项目导入Eclipse，您还需要告诉m2eclipse为项目使用正确的配置文件。如果您在项目中看到许多与POM相关的错误，请检查您是否具有最新的安装。如果您无法升级m2e，请将“ spring”配置文件添加到您的<code class="literal">settings.xml</code> 。或者，您可以将存储库设置从父pom的“ spring”配置文件复制到您的<code class="literal">settings.xml</code> 。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_importing_into_eclipse_without_m2eclipse" href="#_importing_into_eclipse_without_m2eclipse"></a> 147.3.2不使用m2eclipse导入eclipse</h3></div></div></div><p>如果您不想使用m2eclipse，则可以使用以下命令生成eclipse项目元数据：</p><pre class="screen">$ ./mvnw eclipse:eclipse</pre><p>可以通过选择导入生成的Eclipse项目<code class="literal">import existing projects</code>来自<code class="literal">file</code>菜单。</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_contributing" href="#_contributing"></a> 148。贡献</h2></div></div></div><p>Spring Cloud是在非限制性Apache 2.0许可下发布的，并且遵循非常标准的Github开发流程，使用Github跟踪程序解决问题并将合并请求合并到master中。如果您想贡献些微不足道的东西，请不要犹豫，但请遵循以下准则。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sign_the_contributor_license_agreement" href="#_sign_the_contributor_license_agreement"></a> 148.1签署贡献者许可协议</h2></div></div></div><p>在我们接受不重要的补丁或请求请求之前，我们将需要您签署“ <a class="link" href="https://cla.pivotal.io/sign/spring" target="_top">贡献者许可协议”</a> 。签署贡献者协议并不会授予任何人对主存储库的提交权，但这确实意味着我们可以接受您的贡献，如果这样做，您将获得作者的荣誉。可能需要活跃的贡献者加入核心团队，并具有合并合并请求的能力。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_code_of_conduct" href="#_code_of_conduct"></a> 148.2行为准则</h2></div></div></div><p>该项目遵循的贡献者公约<a class="link" href="https://github.com/spring-cloud/spring-cloud-build/blob/master/docs/src/main/asciidoc/code-of-conduct.adoc" target="_top">的行为准则</a> 。通过参与，您将遵守此代码。请向<a class="link" href="mailto:spring-code-of-conduct@pivotal.io" target="_top">spring-code-of-conduct@pivotal.io</a>报告不可接受的行为。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_code_conventions_and_housekeeping" href="#_code_conventions_and_housekeeping"></a> 148.3编码约定和内务管理</h2></div></div></div><p>这些对于拉取请求都不是必不可少的，但它们都会有所帮助。也可以在原始请求请求之后但在合并之前添加它们。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">使用Spring Framework代码格式约定。如果您使用Eclipse，则可以使用<code class="literal">eclipse-code-formatter.xml</code> <a class="link" href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-dependencies-parent/eclipse-code-formatter.xml" target="_top">Spring Cloud Build</a>项目中的文件。如果使用IntelliJ，则可以使用<a class="link" href="https://plugins.jetbrains.com/plugin/6546" target="_top">Eclipse Code Formatter插件</a>来导入相同的文件。</li><li class="listitem">确保所有新<code class="literal">.java</code>文件具有简单的Javadoc类注释，且至少包含一个<code class="literal">@author</code>标签，用于识别您的身份，最好是至少包含有关该类目的的段落。</li><li class="listitem">将ASF许可证标头注释添加到所有新的<code class="literal">.java</code>文件（从项目中的现有文件复制）</li><li class="listitem">将自己添加为<code class="literal">@author</code>到您进行了实质性修改（不仅仅是外观更改）的.java文件。</li><li class="listitem">添加一些Javadocs，如果更改名称空间，则添加一些XSD doc元素。</li><li class="listitem">进行一些单元测试也有很大帮助-有人必须这样做。</li><li class="listitem">如果没有其他人在使用您的分支，请根据当前的主节点（或主项目中的其他目标分支）对其进行重新设置。</li><li class="listitem">编写提交消息时，请遵循<a class="link" href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_top">以下约定</a> ，如果要解决现有问题，请添加<code class="literal">Fixes gh-XXXX</code>在提交消息的末尾（其中XXXX是发行号）。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_checkstyle" href="#_checkstyle"></a> 148.4 Checkstyle</h2></div></div></div><p>Spring Cloud Build带有一组checkstyle规则。您可以在<code class="literal">spring-cloud-build-tools</code>模块。该模块下最值得注意的文件是：</p><p><b>spring-cloud-build-tools /。</b>
</p><pre class="screen">&#9492;&#9472;&#9472; src
 &nbsp;&nbsp; &#9500;&#9472;&#9472; checkstyle
 &nbsp;&nbsp; &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; checkstyle-suppressions.xml <a name="CO7-1" href="#CO7-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
 &nbsp;&nbsp; &#9492;&#9472;&#9472; main
 &nbsp;&nbsp;     &#9492;&#9472;&#9472; resources
 &nbsp;&nbsp;         &#9500;&#9472;&#9472; checkstyle-header.txt <a name="CO7-2" href="#CO7-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
 &nbsp;&nbsp;         &#9492;&#9472;&#9472; checkstyle.xml <a name="CO7-3" href="#CO7-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span></pre><p>
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>默认Checkstyle规则</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>文件头设置</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>默认抑制规则</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_checkstyle_configuration" href="#_checkstyle_configuration"></a> 148.4.1 Checkstyle配置</h3></div></div></div><p>Checkstyle的规则<span class="strong"><strong>默认情况下禁用</strong></span> 。要将checkstyle添加到项目中，只需定义以下属性和插件。</p><p><b>pom.xml。</b>
</p><pre class="screen">&lt;properties&gt;
&lt;maven-checkstyle-plugin.failsOnError&gt;true&lt;/maven-checkstyle-plugin.failsOnError&gt; <a name="CO8-1" href="#CO8-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
        &lt;maven-checkstyle-plugin.failsOnViolation&gt;true
        &lt;/maven-checkstyle-plugin.failsOnViolation&gt; <a name="CO8-2" href="#CO8-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
        &lt;maven-checkstyle-plugin.includeTestSourceDirectory&gt;true
        &lt;/maven-checkstyle-plugin.includeTestSourceDirectory&gt; <a name="CO8-3" href="#CO8-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
&lt;/properties&gt;

&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt; <a name="CO8-4" href="#CO8-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
                &lt;groupId&gt;io.spring.javaformat&lt;/groupId&gt;
                &lt;artifactId&gt;spring-javaformat-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt; <a name="CO8-5" href="#CO8-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

    &lt;reporting&gt;
        &lt;plugins&gt;
            &lt;plugin&gt; <a name="CO8-6" href="#CO8-6"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/reporting&gt;
&lt;/build&gt;</pre><p>
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>因Checkstyle错误而无法构建</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>因Checkstyle违规而无法构建</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>Checkstyle还分析测试源</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left"><p>添加Spring Java Format插件，该插件将重新格式化您的代码以通过大多数Checkstyle格式化规则</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> <a href="#CO8-6"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> </p></td><td valign="top" align="left"><p>将Checkstyle插件添加到构建和报告阶段</p></td></tr></tbody></table></div><p>如果您需要取消某些规则（例如，行长需要更长），那么在下面定义一个文件就足够了<code class="literal">${project.root}/src/checkstyle/checkstyle-suppressions.xml</code>你的压抑。例：</p><p><b>projectRoot / src / checkstyle / checkstyle-suppresions.xml。</b>
</p><pre class="screen">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE suppressions PUBLIC
		"-//Puppy Crawl//DTD Suppressions 1.1//EN"
		"https://www.puppycrawl.com/dtds/suppressions_1_1.dtd"&gt;
&lt;suppressions&gt;
	&lt;suppress files=".*ConfigServerApplication\.java" checks="HideUtilityClassConstructor"/&gt;
	&lt;suppress files=".*ConfigClientWatch\.java" checks="LineLengthCheck"/&gt;
&lt;/suppressions&gt;</pre><p>
</p><p>建议复制<code class="literal">${spring-cloud-build.rootFolder}/.editorconfig</code>和<code class="literal">${spring-cloud-build.rootFolder}/.springformat</code>到您的项目。这样，将应用一些默认格式设置规则。您可以通过运行以下脚本来这样做：</p><pre class="programlisting">$ curl https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/.editorconfig -o .editorconfig
$ touch .springformat</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_ide_setup" href="#_ide_setup"></a> 148.5 IDE设置</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_intellij_idea" href="#_intellij_idea"></a> 148.5.1 Intellij IDEA</h3></div></div></div><p>为了设置Intellij，您应该导入我们的编码约定，检查配置文件并设置checkstyle插件。在<a class="link" href="https://github.com/spring-cloud/spring-cloud-build/tree/master/spring-cloud-build-tools" target="_top">Spring Cloud Build</a>项目中可以找到以下文件。</p><p><b>spring-cloud-build-tools /。</b>
</p><pre class="screen">&#9492;&#9472;&#9472; src
 &nbsp;&nbsp; &#9500;&#9472;&#9472; checkstyle
 &nbsp;&nbsp; &#9474;&nbsp;&nbsp; &#9492;&#9472;&#9472; checkstyle-suppressions.xml <a name="CO9-1" href="#CO9-1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
 &nbsp;&nbsp; &#9492;&#9472;&#9472; main
 &nbsp;&nbsp;     &#9492;&#9472;&#9472; resources
 &nbsp;&nbsp;         &#9500;&#9472;&#9472; checkstyle-header.txt <a name="CO9-2" href="#CO9-2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
 &nbsp;&nbsp;         &#9500;&#9472;&#9472; checkstyle.xml <a name="CO9-3" href="#CO9-3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
 &nbsp;&nbsp;         &#9492;&#9472;&#9472; intellij
 &nbsp;&nbsp;          &nbsp;&nbsp; &#9500;&#9472;&#9472; Intellij_Project_Defaults.xml <a name="CO9-4" href="#CO9-4"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
 &nbsp;&nbsp;          &nbsp;&nbsp; &#9492;&#9472;&#9472; Intellij_Spring_Boot_Java_Conventions.xml <a name="CO9-5" href="#CO9-5"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span></pre><p>
</p><div class="calloutlist"><table border="0" summary="Callout list"><tbody><tr><td width="5%" valign="top" align="left"><p><a href="#CO9-3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>默认Checkstyle规则</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO9-2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>文件头设置</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO9-1"><span><img src="images/callouts/1.png" alt="1个" border="0"></span></a> </p></td><td valign="top" align="left"><p>默认抑制规则</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO9-4"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left"><p>适用于大多数Checkstyle规则的Intellij项目默认值</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO9-5"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> </p></td><td valign="top" align="left"><p>适用于大多数Checkstyle规则的Intellij的项目样式约定</p></td></tr></tbody></table></div><div class="figure"><a name="d0e38338" href="#d0e38338"></a><p class="title"><b>图148.1。代码风格</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-code-style.png" alt="代码风格"></div></div></div><br class="figure-break"><p>去<code class="literal">File</code> → <code class="literal">Settings</code> → <code class="literal">Editor</code> → <code class="literal">Code style</code> 。在那里，单击旁边的图标<code class="literal">Scheme</code>部分。在那里，点击<code class="literal">Import Scheme</code>值并选择<code class="literal">Intellij IDEA code style XML</code>选项。导入<code class="literal">spring-cloud-build-tools/src/main/resources/intellij/Intellij_Spring_Boot_Java_Conventions.xml</code>文件。</p><div class="figure"><a name="d0e38373" href="#d0e38373"></a><p class="title"><b>图148.2。检验概况</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-inspections.png" alt="代码风格"></div></div></div><br class="figure-break"><p>去<code class="literal">File</code> → <code class="literal">Settings</code> → <code class="literal">Editor</code> → <code class="literal">Inspections</code> 。在那里，单击旁边的图标<code class="literal">Profile</code>部分。在那里，点击<code class="literal">Import Profile</code>并导入<code class="literal">spring-cloud-build-tools/src/main/resources/intellij/Intellij_Project_Defaults.xml</code>文件。</p><p><b>Checkstyle。</b>要使Intellij与Checkstyle一起使用，您必须安装<code class="literal">Checkstyle</code>插入。建议也安装<code class="literal">Assertions2Assertj</code>自动转换JUnit断言</p><div class="informalfigure"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-checkstyle.png" alt="Checkstyle"></div></div><p>去<code class="literal">File</code> → <code class="literal">Settings</code> → <code class="literal">Other settings</code> → <code class="literal">Checkstyle</code> 。那里点击<code class="literal">+</code>中的图标<code class="literal">Configuration file</code>部分。在这里，您必须定义应从何处选择checkstyle规则。在上图中，我们从克隆的Spring Cloud Build存储库中选择了规则。但是，您可以指向Spring Cloud Build的GitHub存储库（例如，对于<code class="literal">checkstyle.xml</code> ： <code class="literal"><a class="link" href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml" target="_top">https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml</a></code> ）。我们需要提供以下变量：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">checkstyle.header.file</code> -请指向Spring Cloud Build的<code class="literal">spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</code>文件在您的克隆存储库中或通过<code class="literal"><a class="link" href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt" target="_top">https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</a></code>网址。</li><li class="listitem"><code class="literal">checkstyle.suppressions.file</code> -默认抑制。请把它指向Spring Cloud Build的， <code class="literal">spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</code>文件在您的克隆存储库中或通过<code class="literal"><a class="link" href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml" target="_top">https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</a></code>网址。</li><li class="listitem"><code class="literal">checkstyle.additional.suppressions.file</code> -此变量对应于本地项目中的抑制。例如，您正在从事<code class="literal">spring-cloud-contract</code> 。然后指向<code class="literal">project-root/src/checkstyle/checkstyle-suppressions.xml</code>夹。范例<code class="literal">spring-cloud-contract</code>将会： <code class="literal">/home/username/spring-cloud-contract/src/checkstyle/checkstyle-suppressions.xml</code> 。</li></ul></div><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>请记住设置<code class="literal">Scan Scope</code>至<code class="literal">All sources</code>因为我们将checkstyle规则应用于生产和测试源。</p></td></tr></tbody></table></div></div></div></div></div><div class="part"><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="spring-cloud-gcp-reference" href="#spring-cloud-gcp-reference"></a>第十八部分。 Spring Cloud GCP</h1></div></div></div><div class="partintro"><div></div><p>JoãoAndréMartins； Jisha Abubaker；曾荫权; Mike Eltsufin； Artem Bilan;安德烈亚斯·伯格（Andreas Berger）； Balint Pato;赵成元;德米特里·索洛玛卡（Dmitry Solomakha）;艾琳娜·费尔德（Elena Felder）邹丹妮</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_introduction_4" href="#_introduction_4"></a> 149。介绍</h2></div></div></div><p>Spring Cloud GCP项目使Spring Framework成为Google Cloud Platform（GCP）的一等公民。</p><p>Spring Cloud GCP使您可以利用Spring Framework的强大功能和简单性来：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">使用Google Cloud Vision分析图像中的文本，对象和其他内容</li><li class="listitem">通过Google Cloud IAP使用Spring Security</li><li class="listitem">使用Spring Data Cloud Spanner和Spring Data Cloud Datastore映射对象，关系和集合</li><li class="listitem">发布和订阅Google Cloud Pub / Sub主题</li><li class="listitem">使用一些属性配置Spring JDBC以使用Google Cloud SQL</li><li class="listitem">写入和读取由Google Cloud Storage备份的Spring Resources</li><li class="listitem">在后台使用Google Cloud Pub / Sub与Spring Integration交换消息</li><li class="listitem">使用Spring Cloud Sleuth和Google Stackdriver Trace跟踪应用的执行情况</li><li class="listitem">使用由Google Runtime Configuration API备份的Spring Cloud Config配置您的应用</li><li class="listitem">通过Spring Integration GCS通道适配器消费和产生Google Cloud Storage数据</li></ol></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_dependency_management" href="#_dependency_management"></a> 150。依赖管理</h2></div></div></div><p>Spring Cloud GCP物料清单（BOM）包含其使用的所有依赖项的版本。</p><p>如果您是Maven用户，则将以下内容添加到pom.xml文件中将使您可以不指定任何Spring Cloud GCP依赖版本。取而代之的是，您使用的BOM表的版本确定了所使用依赖项的版本。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencyManagement&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependencies&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-dependencies<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>{project-version}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;type&gt;</span>pom<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/type&gt;</span>
            <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;scope&gt;</span>import<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/scope&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencies&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependencyManagement&gt;</span></pre><p>在以下各节中，将假定您使用的是Spring Cloud GCP BOM，并且依赖项片段将不包含版本。</p><p>Gradle用户可以使用Spring的<a class="link" href="https://github.com/spring-gradle-plugins/dependency-management-plugin" target="_top">dependency-management-plugin</a> Gradle插件来获得相同的BOM体验。为简单起见，本文档其余部分中的Gradle依赖项摘要也将省略其版本。</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_getting_started_2" href="#_getting_started_2"></a> 151。入门</h2></div></div></div><p>有许多可用资源可帮助您尽快了解我们的库。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_initializr" href="#_spring_initializr"></a> 151.1春季Initializr</h2></div></div></div><p><a class="link" href="https://start.spring.io/" target="_top">Spring Initializr</a> for Spring Cloud GCP中有三个条目。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gcp_support" href="#_gcp_support"></a> 151.1.1 GCP支持</h3></div></div></div><p>GCP支持条目包含对每个Spring Cloud GCP集成的自动配置支持。仅当将其他依赖项添加到类路径时，才启用大多数自动配置代码。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">Spring Cloud GCP入门</th><th align="left" valign="top" style="border-bottom:1px solid">所需的依赖项</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>设定档</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-config</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>云扳手</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-data-spanner</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>云数据存储</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-data-datastore</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>记录中</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-logging</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>SQL-MySQL</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-sql-mysql</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>SQL-PostgreSQL</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-sql-postgres</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>跟踪</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-trace</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>视力</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>org.springframework.cloud:spring-cloud-gcp-starter-vision</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>安全性-IAP</p></td><td align="left" valign="top"><p>org.springframework.cloud:spring-cloud-gcp-starter-security-iap</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gcp_messaging" href="#_gcp_messaging"></a> 151.1.2 GCP消息传递</h3></div></div></div><p>“ GCP消息传递”条目添加了“ GCP支持”条目和所有必需的依赖项，因此Google Cloud Pub / Sub集成即开即用。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gcp_storage" href="#_gcp_storage"></a> 151.1.3 GCP存储</h3></div></div></div><p>GCP存储条目会添加GCP支持条目和所有必需的依赖项，以便Google Cloud Storage集成可以立即使用。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_code_samples" href="#_code_samples"></a> 151.2代码示例</h2></div></div></div><p>有可用的<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples" target="_top">代码示例</a>演示了我们所有集成的用法。</p><p>例如， <a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-vision-api-sample" target="_top">Vision API示例</a>显示了如何使用<code class="literal">spring-cloud-gcp-starter-vision</code>自动配置Vision API客户端。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_code_challenges" href="#_code_challenges"></a> 151.3代码挑战</h2></div></div></div><p>在代码挑战中，您将使用一个集成逐步执行任务。<a class="link" href="https://codelabs.developers.google.com/spring" target="_top">Google Developers Codelabs</a>页面中存在许多挑战。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_getting_started_guides" href="#_getting_started_guides"></a> 151.4入门指南</h2></div></div></div><p><a class="link" href="https://spring.io/guides/gs/messaging-gcp-pubsub/" target="_top">Spring Guides</a>提供了有关用于Google Cloud Pub / Sub的Spring Integration Channel Adapters进行消息传递的Spring入门<a class="link" href="https://spring.io/guides/gs/messaging-gcp-pubsub/" target="_top">指南</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="spring-cloud-gcp-core" href="#spring-cloud-gcp-core"></a> 152。Spring Cloud GCP核心</h2></div></div></div><p>每个Spring Cloud GCP模块使用<code class="literal">GcpProjectIdProvider</code>和<code class="literal">CredentialsProvider</code>获取GCP项目ID和访问凭据。</p><p>Spring Cloud GCP提供了一个Spring Boot启动器来自动配置核心组件。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter'
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_project_id" href="#_project_id"></a> 152.1项目ID</h2></div></div></div><p><code class="literal">GcpProjectIdProvider</code>是返回GCP项目ID字符串的功能接口。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> GcpProjectIdProvider {
	String getProjectId();
}</pre><p>Spring Cloud GCP启动器会自动配置一个<code class="literal">GcpProjectIdProvider</code> 。如果一个<code class="literal">spring.cloud.gcp.project-id</code>指定了属性，提供了<code class="literal">GcpProjectIdProvider</code>返回该属性值。</p><pre class="programlisting">spring.cloud.gcp.project-id=my-gcp-project-id</pre><p>否则，将根据<a class="link" href="https://googlecloudplatform.github.io/google-cloud-java/google-cloud-clients/apidocs/com/google/cloud/ServiceOptions.html#getDefaultProjectId--" target="_top">规则</a>的<a class="link" href="https://googlecloudplatform.github.io/google-cloud-java/google-cloud-clients/apidocs/com/google/cloud/ServiceOptions.html#getDefaultProjectId--" target="_top">有序列表</a>来发现项目ID：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">由...指定的项目ID <code class="literal">GOOGLE_CLOUD_PROJECT</code>环境变量</li><li class="listitem">Google App Engine项目ID</li><li class="listitem">在由JSON指向的JSON凭证文件中指定的项目ID <code class="literal">GOOGLE_APPLICATION_CREDENTIALS</code>环境变量</li><li class="listitem">Google Cloud SDK项目ID</li><li class="listitem">来自Google Compute Engine元数据服务器的Google Compute Engine项目ID</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_credentials" href="#_credentials"></a> 152.2凭证</h2></div></div></div><p><code class="literal">CredentialsProvider</code>是一个功能界面，可返回凭据以认证和授权对Google Cloud Client库的调用。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> CredentialsProvider {
  Credentials getCredentials() <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> IOException;
}</pre><p>Spring Cloud GCP启动器会自动配置一个<code class="literal">CredentialsProvider</code> 。它使用<code class="literal">spring.cloud.gcp.credentials.location</code>属性来定位Google服务帐户的OAuth2私钥。请记住，此属性是Spring资源，因此可以从许多<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html#resources-implementations" target="_top">不同的位置（</a>例如文件系统，类路径，URL等）获取凭证文件。下一个示例指定文件系统中的凭证位置属性。</p><pre class="screen">spring.cloud.gcp.credentials.location=file:/usr/local/key.json</pre><p>或者，您可以通过直接指定<code class="literal">spring.cloud.gcp.credentials.encoded-key</code>属性。该值应为JSON格式的base64编码的帐户私钥。</p><p>如果未通过属性指定凭据，则启动程序会尝试从<a class="link" href="https://github.com/GoogleCloudPlatform/google-cloud-java#authentication" target="_top">许多地方</a>发现凭据：</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">凭证文件指向<code class="literal">GOOGLE_APPLICATION_CREDENTIALS</code>环境变量</li><li class="listitem">Google Cloud SDK提供的凭证<code class="literal">gcloud auth application-default login</code>命令</li><li class="listitem">Google App Engine内置凭据</li><li class="listitem">Google Cloud Shell内置凭据</li><li class="listitem">Google Compute Engine内置凭据</li></ol></div><p>如果您的应用程序在Google App Engine或Google Compute Engine上运行，则在大多数情况下，您应该省略<code class="literal">spring.cloud.gcp.credentials.location</code>属性，而是让Spring Cloud GCP Starter获取那些环境的正确凭据。在App Engine Standard上，使用<a class="link" href="https://cloud.google.com/appengine/docs/standard/java/appidentity/" target="_top">App Identity服务帐户凭据</a> ；在App Engine Flexible上，使用<a class="link" href="https://cloud.google.com/appengine/docs/flexible/java/service-account" target="_top">Flexible服务帐户凭据</a> ；在Google Compute Engine上，使用<a class="link" href="https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances#using_the_compute_engine_default_service_account" target="_top">Compute Engine默认服务帐户</a> 。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_scopes" href="#_scopes"></a> 152.2.1范围</h3></div></div></div><p>默认情况下，Spring Cloud GCP Starter提供的凭据包含Spring Cloud GCP支持的每个服务的范围。</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>服务</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>范围</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>扳手</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/spanner.admin" target="_top">https://www.googleapis.com/auth/spanner.admin</a> ， <a class="link" href="https://www.googleapis.com/auth/spanner.data" target="_top">https://www.googleapis.com/auth/spanner.data</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>数据存储</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/datastore" target="_top">https://www.googleapis.com/auth/datastore</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>发布/订阅</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/pubsub" target="_top">https://www.googleapis.com/auth/pubsub</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>存储（只读）</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/devstorage.read_only" target="_top">https://www.googleapis.com/auth/devstorage.read_only</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>存储（写/写）</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/devstorage.read_write" target="_top">https://www.googleapis.com/auth/devstorage.read_write</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>运行时配置</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/cloudruntimeconfig" target="_top">https://www.googleapis.com/auth/cloudruntimeconfig</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>跟踪（附加）</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/trace.append" target="_top">https://www.googleapis.com/auth/trace.append</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>云平台</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/cloud-platform" target="_top">https://www.googleapis.com/auth/cloud-platform</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>视力</p></td><td align="left" valign="top"><p><a class="link" href="https://www.googleapis.com/auth/cloud-vision" target="_top">https://www.googleapis.com/auth/cloud-vision</a></p></td></tr></tbody></table></div><p>Spring Cloud GCP启动程序允许您为提供的凭证配置自定义范围列表。为此，请在<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">窗口中</a>指定以逗号分隔的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">Google OAuth2范围</a>列表<code class="literal">spring.cloud.gcp.credentials.scopes</code>属性。</p><p><code class="literal">spring.cloud.gcp.credentials.scopes</code>是Google Cloud Platform服务的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">Google OAuth2范围</a>的逗号分隔列表，由提供者返回的凭据<code class="literal">CredentialsProvider</code>支持。</p><pre class="screen">spring.cloud.gcp.credentials.scopes=https://www.googleapis.com/auth/pubsub,https://www.googleapis.com/auth/sqlservice.admin</pre><p>您也可以使用<code class="literal">DEFAULT_SCOPES</code>占位符，作为代表入门者默认范围的范围，并附加您需要添加的其他范围。</p><pre class="screen">spring.cloud.gcp.credentials.scopes=DEFAULT_SCOPES,https://www.googleapis.com/auth/cloud-vision</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_environment" href="#_environment"></a> 152.3环境</h2></div></div></div><p><code class="literal">GcpEnvironmentProvider</code>是由Spring Cloud GCP启动程序自动配置的功能接口，它返回一个<code class="literal">GcpEnvironment</code>枚举。提供者可以通过编程帮助确定在哪个GCP环境（App Engine Flexible，App Engine Standard，Kubernetes Engine或Compute Engine）中部署应用程序。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> GcpEnvironmentProvider {
	GcpEnvironment getCurrentEnvironment();
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_initializr_2" href="#_spring_initializr_2"></a> 152.4春季Initializr</h2></div></div></div><p>可以从<a class="link" href="https://start.spring.io/" target="_top">Spring Initializr</a>通过以下途径获得该启动器： <code class="literal">GCP Support</code>条目。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_google_cloud_pubsub" href="#_google_cloud_pubsub"></a> 153。Google Cloud Pub / Sub</h2></div></div></div><p>Spring Cloud GCP提供了一个抽象层，用于发布到Google Cloud Pub / Sub主题和从中订阅，以及创建，列出或删除Google Cloud Pub / Sub主题和订阅。</p><p>提供了一个Spring Boot启动器来自动配置各种必需的Pub / Sub组件。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-pubsub<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-pubsub'
}</pre><p>也可以从<a class="link" href="https://start.spring.io" target="_top">Spring Initializr</a>通过以下途径获得该启动器： <code class="literal">GCP Messaging</code>条目。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_pubsub_operations_template" href="#_pubsub_operations_template"></a> 153.1发布/订阅操作和模板</h2></div></div></div><p><code class="literal">PubSubOperations</code>是一种抽象，允许Spring用户使用Google Cloud Pub / Sub，而无需依赖任何Google Cloud Pub / Sub API语义。它提供了与Google Cloud Pub / Sub交互所需的一组通用操作。
<code class="literal">PubSubTemplate</code>是的默认实现<code class="literal">PubSubOperations</code>并使用<a class="link" href="https://github.com/GoogleCloudPlatform/google-cloud-java/tree/master/google-cloud-pubsub" target="_top">Google Cloud Java Client for Pub / Sub</a>与Google Cloud Pub / Sub进行交互。</p><p><code class="literal">PubSubTemplate</code>取决于<code class="literal">PublisherFactory</code>和一个<code class="literal">SubscriberFactory</code> 。的<code class="literal">PublisherFactory</code>提供用于发布/订阅的Google Cloud Java客户端<code class="literal">Publisher</code> 。的<code class="literal">SubscriberFactory</code>提供<code class="literal">Subscriber</code>用于异步消息提取，以及<code class="literal">SubscriberStub</code>用于同步拉动。适用于GCP Pub / Sub的Spring Boot启动器会自动配置一个<code class="literal">PublisherFactory</code>和<code class="literal">SubscriberFactory</code>使用默认设置并使用<code class="literal">GcpProjectIdProvider</code>和<code class="literal">CredentialsProvider</code>由Spring Boot GCP启动程序自动配置。</p><p>的<code class="literal">PublisherFactory</code> Spring Cloud GCP发布/订阅提供的实施， <code class="literal">DefaultPublisherFactory</code> ，快取<code class="literal">Publisher</code>实例按主题名称命名，以优化资源利用。</p><p>的<code class="literal">PubSubOperations</code>界面实际上是<code class="literal">PubSubPublisherOperations</code>和<code class="literal">PubSubSubscriberOperations</code>与相应的<code class="literal">PubSubPublisherTemplate</code>和<code class="literal">PubSubSubscriberTemplate</code>可以单独使用或通过组合使用<code class="literal">PubSubTemplate</code> 。其余文档参考<code class="literal">PubSubTemplate</code> ，但同样适用于<code class="literal">PubSubPublisherTemplate</code>和<code class="literal">PubSubSubscriberTemplate</code> ，具体取决于我们是在谈论发布还是订阅。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_publishing_to_a_topic" href="#_publishing_to_a_topic"></a> 153.1.1发布到主题</h3></div></div></div><p><code class="literal">PubSubTemplate</code>提供异步方法以将消息发布到Google Cloud Pub / Sub主题。的<code class="literal">publish()</code>方法采用主题名称来将消息发布到通用类型的有效负载，以及（可选）带有消息头的映射。</p><p>这是有关如何将消息发布到Google Cloud Pub / Sub主题的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> publishMessage() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.pubSubTemplate.publish(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"topic"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"your message payload"</span>, ImmutableMap.of(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"key1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"val1"</span>));
}</pre><p>默认情况下， <code class="literal">SimplePubSubMessageConverter</code>用于转换类型的有效载荷<code class="literal">byte[]</code> ， <code class="literal">ByteString</code> ， <code class="literal">ByteBuffer</code>和<code class="literal">String</code>发布/订阅消息。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_json_support" href="#_json_support"></a> JSON支持</h4></div></div></div><p>要使用Jackson JSON对POJO进行序列化和反序列化，请配置一个<code class="literal">JacksonPubSubMessageConverter</code> bean，并且适用于GCP Pub / Sub的Spring Boot入门程序会自动将其连接到<code class="literal">PubSubTemplate</code> 。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Note: The ObjectMapper is used to convert Java POJOs to and from JSON.</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// You will have to configure your own instance if you are unable to depend</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// on the ObjectMapper provided by Spring Boot starters.</span>
<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> JacksonPubSubMessageConverter jacksonPubSubMessageConverter(ObjectMapper objectMapper) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> JacksonPubSubMessageConverter(objectMapper);
}</pre><p>或者，您可以通过调用<code class="literal">setMessageConverter()</code>上的方法<code class="literal">PubSubTemplate</code> 。的其他实现<code class="literal">PubSubMessageConverter</code>也可以以相同的方式配置。</p><p>请参考我们的发布<a class="link" href="../spring-cloud-gcp-samples/spring-cloud-gcp-integration-pubsub-json-sample" target="_top">/订阅JSON有效负载示例应用程序</a> ，以作为使用此功能的参考。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_subscribing_to_a_subscription" href="#_subscribing_to_a_subscription"></a> 153.1.2订阅</h3></div></div></div><p>Google Cloud Pub / Sub允许将许多订阅关联到同一主题。
<code class="literal">PubSubTemplate</code>允许您通过收听订阅<code class="literal">subscribe()</code>方法。它依靠<code class="literal">SubscriberFactory</code>对象，其唯一任务是生成Google Cloud Pub / Sub <code class="literal">Subscriber</code>对象。收听订阅时，将以一定间隔异步地从Google Cloud Pub / Sub中提取消息。</p><p>适用于Google Cloud Pub / Sub的Spring Boot启动器会自动配置一个<code class="literal">SubscriberFactory</code> 。</p><p>如果需要发布/订阅邮件有效负载转换，则可以使用<code class="literal">subscribeAndConvert()</code>方法，它将使用模板中配置的转换器。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_pulling_messages_from_a_subscription" href="#_pulling_messages_from_a_subscription"></a> 153.1.3从订阅中提取消息</h3></div></div></div><p>Google Cloud Pub / Sub支持从订阅中同步提取消息。这与订阅是不同的，在某种意义上，订阅是一个异步任务，它以设置的时间间隔轮询订阅。</p><p>的<code class="literal">pullNext()</code>方法允许从订阅中提取一条消息并自动对其进行确认。的<code class="literal">pull()</code>方法从订阅中提取大量消息，从而允许配置重试设置。收到的任何消息<code class="literal">pull()</code>不会自动确认。相反，因为它们是那种<code class="literal">AcknowledgeablePubsubMessage</code> ，您可以通过致电<code class="literal">ack()</code>方法，或者通过调用<code class="literal">nack()</code>方法。的<code class="literal">pullAndAck()</code>方法与<code class="literal">pull()</code>方法，并确认所有收到的消息。</p><p>的<code class="literal">pullAndConvert()</code>方法与<code class="literal">pull()</code>方法，另外，使用模板中配置的转换器将Pub / Sub二进制有效负载转换为所需类型的对象。</p><p>确认收到来自多个消息<code class="literal">pull()</code>要么<code class="literal">pullAndConvert()</code>您可以立即使用<code class="literal">PubSubTemplate.ack()</code>方法。您也可以使用<code class="literal">PubSubTemplate.nack()</code>用于否定地确认消息。</p><p>使用这些方法批量确认消息比单独确认消息更有效，但是它们<span class="strong"><strong>要求</strong></span>消息集合来自同一项目。</p><p>所有<code class="literal">ack()</code> ， <code class="literal">nack()</code>和<code class="literal">modifyAckDeadline()</code>消息的方法以及<code class="literal">PubSubSubscriberTemplate</code>是异步实现的，返回一个<code class="literal">ListenableFuture<Void></code>以便能够处理异步执行。</p><p><code class="literal">PubSubTemplate</code>使用由其生成的特殊订阅者<code class="literal">SubscriberFactory</code>同步提取消息。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_pubsub_management" href="#_pubsub_management"></a> 153.2发布/订阅管理</h2></div></div></div><p><code class="literal">PubSubAdmin</code>是Spring Cloud GCP提供的用于管理Google Cloud Pub / Sub资源的抽象。它允许创建，删除和列出主题和订阅。</p><p><code class="literal">PubSubAdmin</code>依赖于取决于<code class="literal">GcpProjectIdProvider</code>还有一个<code class="literal">CredentialsProvider</code>或<code class="literal">TopicAdminClient</code>和一个<code class="literal">SubscriptionAdminClient</code> 。如果给一个<code class="literal">CredentialsProvider</code> ，它会创建一个<code class="literal">TopicAdminClient</code>和一个<code class="literal">SubscriptionAdminClient</code>带有用于发布/订阅的Google Cloud Java库的默认设置。适用于GCP Pub / Sub的Spring Boot启动器会自动配置一个<code class="literal">PubSubAdmin</code>使用对象<code class="literal">GcpProjectIdProvider</code>和<code class="literal">CredentialsProvider</code>由Spring Boot GCP Core启动程序自动配置。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_a_topic" href="#_creating_a_topic"></a> 153.2.1创建主题</h3></div></div></div><p><code class="literal">PubSubAdmin</code>实现创建主题的方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Topic createTopic(String topicName)</pre><p>这是有关如何创建Google Cloud Pub / Sub主题的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> newTopic() {
    pubSubAdmin.createTopic(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"topicName"</span>);
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_deleting_a_topic" href="#_deleting_a_topic"></a> 153.2.2删除主题</h3></div></div></div><p><code class="literal">PubSubAdmin</code>实现一种删除主题的方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> deleteTopic(String topicName)</pre><p>这是有关如何删除Google Cloud Pub / Sub主题的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> deleteTopic() {
    pubSubAdmin.deleteTopic(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"topicName"</span>);
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_listing_topics" href="#_listing_topics"></a> 153.2.3列出主题</h3></div></div></div><p><code class="literal">PubSubAdmin</code>实现列出主题的方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> List&lt;Topic&gt; listTopics</pre><p>这是一个如何列出项目中每个Google Cloud Pub / Sub主题名称的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> List&lt;String&gt; listTopics() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> pubSubAdmin
        .listTopics()
        .stream()
        .map(Topic::getNameAsTopicName)
        .map(TopicName::getTopic)
        .collect(Collectors.toList());
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_a_subscription" href="#_creating_a_subscription"></a> 153.2.4创建订阅</h3></div></div></div><p><code class="literal">PubSubAdmin</code>实现一种方法来创建对现有主题的订阅：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Subscription createSubscription(String subscriptionName, String topicName, Integer ackDeadline, String pushEndpoint)</pre><p>以下是有关如何创建Google Cloud Pub / Sub订阅的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> newSubscription() {
    pubSubAdmin.createSubscription(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"subscriptionName"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"topicName"</span>, <span class="hl-number">10</span>, &#8220;https:<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//my.endpoint/push&#8221;);</span>
}</pre><p>提供了具有默认设置的替代方法，以方便使用。的默认值<code class="literal">ackDeadline</code>是10秒。如果<code class="literal">pushEndpoint</code>未指定，则订阅使用消息提取。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Subscription createSubscription(String subscriptionName, String topicName)</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Subscription createSubscription(String subscriptionName, String topicName, Integer ackDeadline)</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Subscription createSubscription(String subscriptionName, String topicName, String pushEndpoint)</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_deleting_a_subscription" href="#_deleting_a_subscription"></a> 153.2.5删除订阅</h3></div></div></div><p><code class="literal">PubSubAdmin</code>实现一种删除订阅的方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> deleteSubscription(String subscriptionName)</pre><p>这是有关如何删除Google Cloud Pub / Sub订阅的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> deleteSubscription() {
    pubSubAdmin.deleteSubscription(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"subscriptionName"</span>);
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_listing_subscriptions" href="#_listing_subscriptions"></a> 153.2.6列表订阅</h3></div></div></div><p><code class="literal">PubSubAdmin</code>实现列出订阅的方法：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> List&lt;Subscription&gt; listSubscriptions()</pre><p>这是一个如何列出项目中每个订阅名称的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> List&lt;String&gt; listSubscriptions() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> pubSubAdmin
        .listSubscriptions()
        .stream()
        .map(Subscription::getNameAsSubscriptionName)
        .map(SubscriptionName::getSubscription)
        .collect(Collectors.toList());
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="pubsub-configuration" href="#pubsub-configuration"></a> 153.3配置</h2></div></div></div><p>Google Cloud Pub / Sub的Spring Boot入门程序提供以下配置选项：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>需要</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用或禁用发布/订阅自动配置</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.subscriber.executor-threads</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>使用的线程数<code class="literal">Subscriber</code>由创建的实例<code class="literal">SubscriberFactory</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>4</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.publisher.executor-threads</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>使用的线程数<code class="literal">Publisher</code>由创建的实例<code class="literal">PublisherFactory</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>4</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.project-id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>托管Google Cloud Pub / Sub API的GCP项目ID（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP Core Module中的</a> ID不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于与Google Cloud Pub / Sub API进行身份验证的OAuth2凭证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a>凭证不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>OAuth2帐户私钥的Base64编码内容，用于与Google Cloud Pub / Sub API进行身份验证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP Core Module中的内容不同）</a></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.credentials.scopes</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Spring Cloud GCP发布/订阅凭据的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">OAuth2范围</a></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/pubsub" target="_top">https://www.googleapis.com/auth/pubsub</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.subscriber.parallel-pull-count</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拉工人数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可用处理器数量</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.subscriber.max-ack-extension-period</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>消息确认截止期限的最长时间（以秒为单位）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.subscriber.pull-endpoint</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>同步拉取消息的端点</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>pubsub.googleapis.com:443</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.total-timeout-seconds</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>TotalTimeout具有最终控制权，该逻辑应继续尝试远程调用直到完全放弃之前应保持多长时间。总超时时间越高，可以尝试的重试次数越多。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.initial-retry-delay-second</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>InitialRetryDelay控制第一次重试之前的延迟。随后的重试将使用根据RetryDelayMultiplier调整的该值。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.retry-delay-multiplier</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>RetryDelayMultiplier控制重试延迟的更改。将前一个呼叫的重试延迟乘以RetryDelayMultiplier，以计算下一个呼叫的重试延迟。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>1个</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.max-retry-delay-seconds</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>MaxRetryDelay设置了重试延迟的值的限制，以便RetryDelayMultiplier不能将重试延迟增加到大于此数量的值。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.max-attempts</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>MaxAttempts定义执行的最大尝试次数。如果此值大于0，并且尝试次数达到此限制，则即使总重试时间仍小于TotalTimeout，逻辑也会放弃重试。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.jittered</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>抖动确定是否应将延迟时间随机化。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>真正</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.initial-rpc-timeout-seconds</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>InitialRpcTimeout控制初始RPC的超时。后续调用将使用根据RpcTimeoutMultiplier调整的该值。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.rpc-timeout-multiplier</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>RpcTimeoutMultiplier控制RPC超时的更改。上一个呼叫的超时时间乘以RpcTimeoutMultiplier，以计算下一个呼叫的超时时间。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>1个</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher].retry.max-rpc-timeout-seconds</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>MaxRpcTimeout对RPC超时值设置了限制，因此RpcTimeoutMultiplier不能将RPC超时增加到高于此值。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher.batching].flow-control.max-outstanding-element-count</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>在执行流控制之前要保留在内存中的未完成元素的最大数量。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>无限</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher.batching].flow-control.max-outstanding-request-bytes</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>强制执行流控制之前要保留在内存中的最大未完成字节数。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>无限</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.[subscriber,publisher.batching].flow-control.limit-exceeded-behavior</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>超过指定限制时的行为。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>块</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.publisher.batching.element-count-threshold</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于批处理的元素计数阈值。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>未设置（阈值不适用）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.publisher.batching.request-byte-threshold</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于批处理的请求字节阈值。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>未设置（阈值不适用）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.publisher.batching.delay-threshold-seconds</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于批处理的延迟阈值。经过这段时间后（从添加的第一个元素开始计数），这些元素将被分批包装并发送。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>未设置（阈值不适用）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.pubsub.publisher.batching.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>启用批处理。</p></td><td align="left" valign="top" style="border-right:1px solid"><p>没有</p></td><td align="left" valign="top"><p>假</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample" href="#_sample"></a> 153.4样本</h2></div></div></div><p>提供了<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-sample" target="_top">示例应用程序</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_resources" href="#_spring_resources"></a> 154。春季资源</h2></div></div></div><p><a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html" target="_top">Spring Resources</a>是许多低级<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html" target="_top">资源</a>的抽象，例如文件系统文件，类路径文件，与Servlet上下文相关的文件等。SpringCloud GCP添加了一种新的资源类型：Google Cloud Storage（GCS）对象。</p><p>提供了一个Spring Boot启动器来自动配置各种存储组件。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-storage<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-storage'
}</pre><p>也可以从<a class="link" href="https://start.spring.io/" target="_top">Spring Initializr</a>通过以下途径获得该启动器： <code class="literal">GCP Storage</code>条目。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_google_cloud_storage" href="#_google_cloud_storage"></a> 154.1 Google云存储</h2></div></div></div><p>Google Cloud Storage的Spring Resource Abstraction允许通过GCS URL使用GCS对象访问GCS对象。 <code class="literal">@Value</code>注解：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Value("gs://[YOUR_GCS_BUCKET]/[GCS_FILE_NAME]")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Resource gcsResource;</pre><p>…或Spring应用程序上下文</p><pre class="programlisting">SpringApplication.run(...).getResource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"gs://[YOUR_GCS_BUCKET]/[GCS_FILE_NAME]"</span>);</pre><p>这创建了一个<code class="literal">Resource</code>可用于读取对象的对象，以及<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/resources.html#resources-resource" target="_top">其他可能的操作</a> 。</p><p>也可以写一个<code class="literal">Resource</code> ，尽管<code class="literal">WriteableResource</code>是必须的。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Value("gs://[YOUR_GCS_BUCKET]/[GCS_FILE_NAME]")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Resource gcsResource;
...
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">try</span> (OutputStream os = ((WritableResource) gcsResource).getOutputStream()) {
  os.write(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>.getBytes());
}</pre><p>与<code class="literal">Resource</code>作为Google Cloud Storage资源，将其投射到<code class="literal">GoogleStorageResource</code> 。</p><p>如果资源路径引用了Google Cloud Storage上的对象（而不是存储桶），则<code class="literal">getBlob</code>可以调用方法来获得<a class="link" href="https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-storage/src/main/java/com/google/cloud/storage/Blob.java" target="_top"><code class="literal">Blob</code></a> 。此类型表示GCS文件，该文件具有可以设置的关联<a class="link" href="https://cloud.google.com/storage/docs/gsutil/addlhelp/WorkingWithObjectMetadata" target="_top">元数据</a> ，例如content-type。的<code class="literal">createSignedUrl</code>方法也可以用于获取GCS对象的<a class="link" href="https://cloud.google.com/storage/docs/access-control/signed-urls" target="_top">签名URL</a> 。但是，创建签名的URL要求使用服务帐户凭据创建资源。</p><p>Google Cloud Storage的Spring Boot Starter会自动配置<code class="literal">Storage</code>所需的bean <code class="literal">spring-cloud-gcp-storage</code>模块，基于<code class="literal">CredentialsProvider</code>由Spring Boot GCP启动程序提供。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_setting_the_content_type" href="#_setting_the_content_type"></a> 154.1.1设置内容类型</h3></div></div></div><p>您可以从相应的Google Cloud Storage文件中设置内容类型<code class="literal">Resource</code>对象：</p><pre class="programlisting">((GoogleStorageResource)gcsResource).getBlob().toBuilder().setContentType(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"text/html"</span>).build().update();</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_3" href="#_configuration_3"></a> 154.2配置</h2></div></div></div><p>Google Cloud Storage的Spring Boot Starter提供了以下配置选项：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>需要</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.storage.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用GCP存储API。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.storage.auto-create-files</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>对不存在的文件进行写入时，在Google Cloud Storage上创建文件和存储桶</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.storage.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于与Google Cloud Storage API进行身份验证的OAuth2凭证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a>凭证不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.storage.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>OAuth2帐户私钥的Base64编码内容，用于与Google Cloud Storage API进行身份验证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP Core Module中的内容不同）</a></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.storage.credentials.scopes</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>Spring Cloud GCP存储凭据的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">OAuth2范围</a></p></td><td align="left" valign="top" style="border-right:1px solid"><p>没有</p></td><td align="left" valign="top"><p><a class="link" href="https://www.googleapis.com/auth/devstorage.read_write" target="_top">https://www.googleapis.com/auth/devstorage.read_write</a></p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_2" href="#_sample_2"></a> 154.3样本</h2></div></div></div><p>提供了一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-storage-resource-sample" target="_top">示例应用程序</a>和一个代码<a class="link" href="https://codelabs.developers.google.com/codelabs/spring-cloud-gcp-gcs/index.html" target="_top">实验室</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_jdbc" href="#_spring_jdbc"></a> 155。Spring JDBC</h2></div></div></div><p>Spring Cloud GCP增加了与<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html" target="_top">Spring JDBC的</a>集成，因此您可以使用Spring JDBC或依赖于它的其他库（如Spring Data JPA）在Google Cloud SQL中运行MySQL或PostgreSQL数据库。</p><p>Spring SQL GCP以两个Spring Boot启动器的形式提供Cloud SQL支持，一个用于MySQL，另一个用于PostgreSQL。入门者的作用是从属性中读取配置并采用默认设置，以便用户体验尽可能简单地连接到MySQL和PostgreSQL。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-sql-mysql<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-sql-postgresql<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-sql-mysql'
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-sql-postgresql'
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_prerequisites" href="#_prerequisites"></a> 155.1先决条件</h2></div></div></div><p>为了将Spring Boot Starters用于Google Cloud SQL，必须在您的GCP项目中启用Google Cloud SQL API。</p><p>为此，请转到Google Cloud Console的<a class="link" href="https://console.cloud.google.com/apis/library" target="_top">API库页面</a> ，搜索“ Cloud SQL API”，单击第一个结果并启用该API。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>有几个类似的“ Cloud SQL”结果。您必须访问一个“ Google Cloud SQL API”并从那里启用该API。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_boot_starter_for_google_cloud_sql" href="#_spring_boot_starter_for_google_cloud_sql"></a> 155.2用于Google Cloud SQL的Spring Boot Starter</h2></div></div></div><p>Google Cloud SQL的Spring Boot Starters提供了自动配置的功能<a class="link" href="https://docs.oracle.com/javase/7/docs/api/javax/sql/DataSource.html" target="_top"><code class="literal">DataSource</code></a>宾语。结合Spring JDBC，它提供了一个<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-JdbcTemplate" target="_top"><code class="literal">JdbcTemplate</code></a>对象Bean，它允许进行诸如查询和修改数据库之类的操作。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; listUsers() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> jdbcTemplate.queryForList(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SELECT * FROM user;"</span>);
}</pre><p>您可以依靠<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-connect-to-production-database" target="_top">Spring Boot数据源自动配置</a>来配置<code class="literal">DataSource</code> bean 。换句话说，诸如SQL用户名， <code class="literal">spring.datasource.username</code>和密码， <code class="literal">spring.datasource.password</code>可以使用。还有一些特定于Google Cloud SQL的配置：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>物业名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.sql.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用或禁用Cloud SQL自动配置</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.sql.database-name</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>要连接的数据库的名称。</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.sql.instance-connection-name</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>包含Google Cloud SQL实例的项目ID，区域和名称的字符串，每个字符串之间用冒号分隔。例如， <code class="literal">my-project-id:my-region:my-instance-name</code> 。</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.sql.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Google OAuth2凭证私钥文件的文件系统路径。用于验证和授权与Google Cloud SQL实例的新连接。</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Spring GCP Boot启动程序提供的默认凭证</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.sql.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>OAuth2帐户私钥的Base64编码内容，采用JSON格式。用于验证和授权与Google Cloud SQL实例的新连接。</p></td><td align="left" valign="top"><p>Spring GCP Boot启动程序提供的默认凭证</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您提供自己的<code class="literal">spring.datasource.url</code> ，除非您使用以下命令禁用Cloud SQL自动配置，否则它将被忽略<code class="literal">spring.cloud.gcp.sql.enabled=false</code> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_datasource_creation_flow" href="#_datasource_creation_flow"></a> 155.2.1 <code class="literal">DataSource</code>创作流程</h3></div></div></div><p>根据之前的属性，用于Google Cloud SQL的Spring Boot入门程序会创建一个<code class="literal">CloudSqlJdbcInfoProvider</code>用于获取实例的JDBC URL和驱动程序类名称的对象。如果您提供自己的<code class="literal">CloudSqlJdbcInfoProvider</code> bean，而是使用它，并且与构建JDBC URL或驱动程序类有关的属性将被忽略。</p><p>的<code class="literal">DataSourceProperties</code>由Spring Boot Autoconfigure提供的object进行了突变，以使用由提供的JDBC URL和驱动程序类名称<code class="literal">CloudSqlJdbcInfoProvider</code> ，除非属性中提供了这些值。它在<code class="literal">DataSourceProperties</code>凭证工厂在系统属性中注册为的突变步骤<code class="literal">SqlCredentialFactory</code> 。</p><p><code class="literal">DataSource</code>创建被委托给<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html" target="_top">Spring Boot</a> 。您可以通过将连接池<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-connect-to-production-database" target="_top">的依赖项添加到classpath中</a>来选择连接池的类型（例如，Tomcat，HikariCP等）。</p><p>使用创建的<code class="literal">DataSource</code>与Spring JDBC结合使用可为您提供完全配置且可操作的<code class="literal">JdbcTemplate</code>可用于与SQL数据库进行交互的对象。您可以使用最少的数据库和实例名称连接到数据库。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_troubleshooting_tips" href="#_troubleshooting_tips"></a> 155.2.2故障排除技巧</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="connection-issues" href="#connection-issues"></a>连接问题</h4></div></div></div><p>如果您无法连接到数据库并看到无限循环<code class="literal">Connecting to Cloud SQL instance […​] on IP […​]</code> ，则可能会以低于记录器级别的级别引发和记录异常。如果您的记录器设置为INFO或更高级别，则HikariCP可能就是这种情况。</p><p>要查看后台发生了什么，您应该添加一个<code class="literal">logback.xml</code>文件到您的应用程序资源文件夹，如下所示：</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">resource</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"org/springframework/boot/logging/logback/base.xml"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;logger</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"com.zaxxer.hikari.pool"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">level</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"DEBUG"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span></pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_errors_like_c_g_cloud_sql_core_sslsocketfactory_re_throwing_cached_exception_due_to_attempt_to_refresh_instance_information_too_soon_after_error" href="#_errors_like_c_g_cloud_sql_core_sslsocketfactory_re_throwing_cached_exception_due_to_attempt_to_refresh_instance_information_too_soon_after_error"></a>像这样的错误<code class="literal">c.g.cloud.sql.core.SslSocketFactory : Re-throwing cached exception due to attempt to refresh instance information too soon after error</code></h4></div></div></div><p>如果您在循环中看到很多类似这样的错误并且无法连接到数据库，则通常是一种征兆，表示在您的凭据权限下出现了某些错误，或者未启用Google Cloud SQL API。验证是否已在Cloud Console中启用了Google Cloud SQL API，并且您的服务帐户具有<a class="link" href="https://cloud.google.com/sql/docs/mysql/project-access-control#roles" target="_top">必要的IAM角色</a> 。</p><p>要找出导致问题的原因，您可以<a class="link" href="#connection-issues" title="连接问题">如上所述</a>启用DEBUG日志记录级别。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_postgresql_java_net_socketexception_already_connected_issue" href="#_postgresql_java_net_socketexception_already_connected_issue"></a> PostgreSQL： <code class="literal">java.net.SocketException: already connected</code>问题</h4></div></div></div><p>如果您的Maven项目的父级是<code class="literal">spring-boot</code>版<code class="literal">1.5.x</code> ，或在任何其他情况下会导致<code class="literal">org.postgresql:postgresql</code>依赖年龄较大（例如， <code class="literal">9.4.1212.jre7</code> ）。</p><p>要解决此问题，请以正确的版本重新声明依赖项。例如，在Maven中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.postgresql<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>postgresql<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;version&gt;</span>42.1.1<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/version&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_samples_3" href="#_samples_3"></a> 155.3个样本</h2></div></div></div><p>可用的示例应用程序和代码实验室：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-sql-mysql-sample" target="_top">Spring Cloud GCP MySQL</a></li><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-sql-postgres-sample" target="_top">Spring Cloud GCP PostgreSQL</a></li><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-data-jpa-sample" target="_top">带有Spring Cloud GCP SQL的Spring Data JPA</a></li><li class="listitem">Codelab： <a class="link" href="https://codelabs.developers.google.com/codelabs/cloud-spring-petclinic-cloudsql/index.html" target="_top">使用Cloud SQL的Spring Pet Clinic</a></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_integration" href="#_spring_integration"></a> 156。 Spring Integration </h2></div></div></div><p>Spring Cloud GCP提供了Spring Integration适配器，使您的应用程序可以使用由Google Cloud Platform服务备份的企业集成模式。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_channel_adapters_for_cloud_pubsub" href="#_channel_adapters_for_cloud_pubsub"></a> 156.1适用于Cloud Pub / Sub的通道适配器</h2></div></div></div><p>Google Cloud Pub / Sub的通道适配器连接您的Spring <a class="link" href="https://docs.spring.io/spring-integration/reference/html/messaging-channels-section.html#channel" target="_top"><code class="literal">MessageChannels</code></a> Google Cloud发布/订阅主题和订阅。这样可以在由Google Cloud Pub / Sub备份的不同流程，应用程序或微服务之间进行消息传递。</p><p>用于Google Cloud Pub / Sub的Spring Integration Channel Adapters包含在<code class="literal">spring-cloud-gcp-pubsub</code>模块。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-pubsub<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.integration<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-integration-core<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-pubsub'
    compile group: 'org.springframework.integration', name: 'spring-integration-core'
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_channel_adapter" href="#_inbound_channel_adapter"></a> 156.1.1入站通道适配器</h3></div></div></div><p><code class="literal">PubSubInboundChannelAdapter</code>是GCP发布/订阅的入站通道适配器，用于侦听GCP发布/订阅的新消息。它将新消息转换为内部Spring <a class="link" href="https://docs.spring.io/spring-integration/reference/html/messaging-construction-chapter.html#message" target="_top"><code class="literal">Message</code></a>然后将其发送到绑定的输出通道。</p><p>Google Pub / Sub将消息有效负载视为字节数组。因此，默认情况下，入站通道适配器将构造Spring <code class="literal">Message</code>与<code class="literal">byte[]</code>作为有效载荷。但是，您可以通过设置<code class="literal">payloadType</code>的属性<code class="literal">PubSubInboundChannelAdapter</code> 。的<code class="literal">PubSubInboundChannelAdapter</code>将转换委托给所需的有效负载类型<code class="literal">PubSubMessageConverter</code>在中配置<code class="literal">PubSubTemplate</code> 。</p><p>要使用入站通道适配器，请<code class="literal">PubSubInboundChannelAdapter</code>必须在用户应用程序端提供和配置。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageChannel pubsubInputChannel() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PublishSubscribeChannel();
}

<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> PubSubInboundChannelAdapter messageChannelAdapter(
    <em><span class="hl-annotation" style="color: gray">@Qualifier("pubsubInputChannel")</span></em> MessageChannel inputChannel,
    SubscriberFactory subscriberFactory) {
    PubSubInboundChannelAdapter adapter =
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PubSubInboundChannelAdapter(subscriberFactory, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"subscriptionName"</span>);
    adapter.setOutputChannel(inputChannel);
    adapter.setAckMode(AckMode.MANUAL);

    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> adapter;
}</pre><p>在示例中，我们首先指定<code class="literal">MessageChannel</code>适配器将向其中写入传入消息的位置。的<code class="literal">MessageChannel</code>在这里实现并不重要。根据您的用例，您可能需要使用<code class="literal">MessageChannel</code>以外<code class="literal">PublishSubscribeChannel</code> 。</p><p>然后，我们声明一个<code class="literal">PubSubInboundChannelAdapter</code> bean 。它需要我们刚刚创建的渠道和<code class="literal">SubscriberFactory</code> ，这创建了<code class="literal">Subscriber</code> Google Cloud Java Client for Pub / Sub中的对象。用于GCP Pub / Sub的Spring Boot启动器提供了一个已配置的<code class="literal">SubscriberFactory</code> 。</p><p>的<code class="literal">PubSubInboundChannelAdapter</code>支持三种确认模式， <code class="literal">AckMode.AUTO</code>为默认值；</p><p>自动确认（ <code class="literal">AckMode.AUTO</code> ）</p><p>如果适配器将消息发送到通道，并且未引发任何异常，则消息将被GCP发布/订阅确认。如果一个<code class="literal">RuntimeException</code>在处理消息时抛出，然后将该消息删除。</p><p>自动确认OK（ <code class="literal">AckMode.AUTO_ACK</code> ）</p><p>如果适配器将消息发送到通道，并且未引发任何异常，则消息将被GCP发布/订阅确认。如果一个<code class="literal">RuntimeException</code>在处理消息时抛出，则消息既不会被确认也不会被拒绝。</p><p>当使用订阅的确认截止时间超时作为重试传递回退机制时，此功能很有用。</p><p>手动确认（ <code class="literal">AckMode.MANUAL</code> ）</p><p>适配器附有一个<code class="literal">BasicAcknowledgeablePubsubMessage</code>反对<code class="literal">Message</code>标头。用户可以提取<code class="literal">BasicAcknowledgeablePubsubMessage</code>使用<code class="literal">GcpPubSubHeaders.ORIGINAL_MESSAGE</code>并使用它来确认消息。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "pubsubInputChannel")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageHandler messageReceiver() {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> message -&gt; {
        LOGGER.info(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Message arrived! Payload: "</span> + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> String((<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[]) message.getPayload()));
        BasicAcknowledgeablePubsubMessage originalMessage =
              message.getHeaders().get(GcpPubSubHeaders.ORIGINAL_MESSAGE, BasicAcknowledgeablePubsubMessage.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
        originalMessage.ack();
    };
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_outbound_channel_adapter" href="#_outbound_channel_adapter"></a> 156.1.2出站通道适配器</h3></div></div></div><p><code class="literal">PubSubMessageHandler</code>是GCP发布/订阅的出站通道适配器，它在Spring上侦听新消息<code class="literal">MessageChannel</code> 。它用<code class="literal">PubSubTemplate</code>将其发布到GCP发布/订阅主题。</p><p>要构造消息的发布/订阅表示，出站通道适配器需要转换Spring <code class="literal">Message</code>有效载荷到Pub / Sub期望的字节数组表示形式。它将这种转换委托给<code class="literal">PubSubTemplate</code> 。要自定义转化，您可以指定一个<code class="literal">PubSubMessageConverter</code>在里面<code class="literal">PubSubTemplate</code>那应该转换<code class="literal">Object</code> Spring的有效负载和标头<code class="literal">Message</code>到<code class="literal">PubsubMessage</code> 。</p><p>要使用出站通道适配器，请<code class="literal">PubSubMessageHandler</code>必须在用户应用程序端提供并配置bean。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "pubsubOutputChannel")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageHandler messageSender(PubSubTemplate pubsubTemplate) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PubSubMessageHandler(pubsubTemplate, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"topicName"</span>);
}</pre><p>提供的<code class="literal">PubSubTemplate</code>包含将消息发布到GCP发布/订阅主题的所有必要配置。</p><p><code class="literal">PubSubMessageHandler</code>默认情况下异步发布消息。可以将发布超时配置为同步发布。如果未提供任何内容，则适配器将无限期等待响应。</p><p>可以为用户设置回调<code class="literal">publish()</code>呼入<code class="literal">PubSubMessageHandler</code>通过<code class="literal">setPublishFutureCallback()</code>方法。如果成功，这些对于处理消息ID很有用，如果抛出错误，则对于处理消息ID很有用。</p><p>要覆盖默认目的地，您可以使用<code class="literal">GcpPubSubHeaders.DESTINATION</code>标头。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> MessageChannel pubsubOutputChannel;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> handleMessage(Message&lt;?&gt; msg) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">throws</span> MessagingException {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Message&lt;?&gt; message = MessageBuilder
        .withPayload(msg.getPayload())
        .setHeader(GcpPubSubHeaders.TOPIC, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"customTopic"</span>).build();
    pubsubOutputChannel.send(message);
}</pre><p>也可以使用设置主题的SpEL表达式<code class="literal">setTopicExpression()</code>要么<code class="literal">setTopicExpressionString()</code>方法。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_header_mapping" href="#_header_mapping"></a> 156.1.3标头映射</h3></div></div></div><p>这些通道适配器包含标头映射器，使您可以将标头从Spring映射或过滤出到Google Cloud Pub / Sub消息，反之亦然。默认情况下，入站通道适配器将Google Cloud Pub / Sub消息上的每个标头映射到适配器产生的Spring消息。出站通道适配器将Spring消息中的每个标头映射到Google Cloud Pub / Sub的标头（由Spring添加的标头除外，例如带有key的标头） <code class="literal">"id"</code> ， <code class="literal">"timestamp"</code>和<code class="literal">"gcp_pubsub_acknowledgement"</code> 。在此过程中，出站映射器还将标头的值转换为字符串。</p><p>每个适配器都声明一个<code class="literal">setHeaderMapper()</code>方法，让您进一步自定义要从Spring映射到Google Cloud Pub / Sub的标题，反之亦然。</p><p>例如，过滤出标题<code class="literal">"foo"</code> ， <code class="literal">"bar"</code>以及所有以“ prefix_”开头的标题，您可以使用<code class="literal">setHeaderMapper()</code>随着<code class="literal">PubSubHeaderMapper</code>此模块提供的实现。</p><pre class="programlisting">PubSubMessageHandler adapter = ...
...
PubSubHeaderMapper headerMapper = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PubSubHeaderMapper();
headerMapper.setOutboundHeaderPatterns(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"!foo"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"!bar"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"!prefix_*"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"*"</span>);
adapter.setHeaderMapper(headerMapper);</pre><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>模式在其中的声明顺序<code class="literal">PubSubHeaderMapper.setOutboundHeaderPatterns()</code>和<code class="literal">PubSubHeaderMapper.setInboundHeaderPatterns()</code>很重要。第一种模式优先于以下模式。</p></td></tr></tbody></table></div><p>在上一个示例中， <code class="literal">"*"</code> pattern表示每个标头都被映射。但是，由于它在列表中排在最后， <a class="link" href="https://docs.spring.io/spring-integration/api/org/springframework/integration/util/PatternMatchUtils.html#smartMatch-java.lang.String-java.lang.String%E2%80%A6%E2%80%8B-" target="_top">因此之前的模式优先</a> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_3" href="#_sample_3"></a> 156.2样本</h2></div></div></div><p>可用的示例：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-integration-pubsub-sample" target="_top">发送者和接收者示例应用程序</a></li><li class="listitem"><a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-integration-pubsub-json-sample" target="_top">JSON有效负载示例应用程序</a></li><li class="listitem"><a class="link" href="https://codelabs.developers.google.com/codelabs/cloud-spring-cloud-gcp-pubsub-integration/index.html" target="_top">代码实验室</a></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_channel_adapters_for_google_cloud_storage" href="#_channel_adapters_for_google_cloud_storage"></a> 156.3用于Google Cloud Storage的通道适配器</h2></div></div></div><p>Google Cloud Storage的通道适配器使您可以通过以下方式向Google Cloud Storage读写文件<code class="literal">MessageChannels</code> 。</p><p>Spring Cloud GCP提供了两个入站适配器， <code class="literal">GcsInboundFileSynchronizingMessageSource</code>和<code class="literal">GcsStreamingMessageSource</code> ，以及一个出站适配器， <code class="literal">GcsMessageHandler</code> 。</p><p>Google Cloud Storage的Spring Integration Channel Adapters包含在<code class="literal">spring-cloud-gcp-storage</code>模块。</p><p>要使用Spring Integration for Spring Cloud GCP的存储部分，还必须提供<code class="literal">spring-integration-file</code>依赖关系，因为它不会传递。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-storage<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.integration<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-integration-file<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-storage'
    compile group: 'org.springframework.integration', name: 'spring-integration-file'
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_channel_adapter_2" href="#_inbound_channel_adapter_2"></a> 156.3.1入站通道适配器</h3></div></div></div><p>Google Cloud Storage入站通道适配器会轮询Google Cloud Storage存储桶以查找新文件，并将每个文件发送到<code class="literal">Message</code>有效载荷<code class="literal">MessageChannel</code>在指定<code class="literal">@InboundChannelAdapter</code>注解。这些文件临时存储在本地文件系统的文件夹中。</p><p>这是有关如何配置Google Cloud Storage入站通道适配器的示例。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = "new-file-channel", poller = @Poller(fixedDelay = "5000"))</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageSource&lt;File&gt; synchronizerAdapter(Storage gcs) {
  GcsInboundFileSynchronizer synchronizer = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsInboundFileSynchronizer(gcs);
  synchronizer.setRemoteDirectory(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"your-gcs-bucket"</span>);

  GcsInboundFileSynchronizingMessageSource synchAdapter =
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsInboundFileSynchronizingMessageSource(synchronizer);
  synchAdapter.setLocalDirectory(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> File(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"local-directory"</span>));

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> synchAdapter;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_inbound_streaming_channel_adapter" href="#_inbound_streaming_channel_adapter"></a> 156.3.2入站流通道适配器</h3></div></div></div><p>入站流通道适配器与普通的入站通道适配器相似，不同之处在于它不需要将文件存储在文件系统中。</p><p>这是有关如何配置Google Cloud Storage入站流式传输通道适配器的示例。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@InboundChannelAdapter(channel = "streaming-channel", poller = @Poller(fixedDelay = "5000"))</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageSource&lt;InputStream&gt; streamingAdapter(Storage gcs) {
  GcsStreamingMessageSource adapter =
          <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsStreamingMessageSource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsRemoteFileTemplate(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsSessionFactory(gcs)));
  adapter.setRemoteDirectory(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"your-gcs-bucket"</span>);
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> adapter;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_outbound_channel_adapter_2" href="#_outbound_channel_adapter_2"></a> 156.3.3出站通道适配器</h3></div></div></div><p>出站通道适配器允许将文件写入Google Cloud Storage。当它收到一个<code class="literal">Message</code>包含类型的有效载荷<code class="literal">File</code> ，它将文件写入适配器中指定的Google Cloud Storage存储桶。</p><p>这是有关如何配置Google Cloud Storage出站通道适配器的示例。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Bean</span></em>
<em><span class="hl-annotation" style="color: gray">@ServiceActivator(inputChannel = "writeFiles")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> MessageHandler outboundChannelAdapter(Storage gcs) {
  GcsMessageHandler outboundChannelAdapter = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsMessageHandler(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> GcsSessionFactory(gcs));
  outboundChannelAdapter.setRemoteDirectoryExpression(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ValueExpression&lt;&gt;(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"your-gcs-bucket"</span>));

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> outboundChannelAdapter;
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_4" href="#_sample_4"></a> 156.4样本</h2></div></div></div><p>提供了<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-integration-storage-sample" target="_top">示例应用程序</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_stream_2" href="#_spring_cloud_stream_2"></a> 157。 Spring Cloud Stream </h2></div></div></div><p>Spring Cloud GCP为Google Cloud Pub / Sub提供了<a class="link" href="https://cloud.spring.io/spring-cloud-stream/" target="_top">Spring Cloud Stream</a>绑定器。</p><p>所提供的资料夹依赖于<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/integration" target="_top">Google Cloud Pub / Sub</a>的<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/integration" target="_top">Spring Integration Channel Adapters</a> 。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-pubsub-stream-binder<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-pubsub-stream-binder'
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_overview_2" href="#_overview_2"></a> 157.1概述</h2></div></div></div><p>该资料夹将生产者绑定到Google Cloud Pub / Sub主题，将消费者绑定到订阅。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>该绑定器当前不支持分区。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_4" href="#_configuration_4"></a> 157.2配置</h2></div></div></div><p>您可以为Google Cloud Pub / Sub配置Spring Cloud Stream Binder以自动生成基础资源，例如针对生产者和消费者的Google Cloud Pub / Sub主题和订阅。为此，您可以使用<code class="literal">spring.cloud.stream.gcp.pubsub.bindings.<channelName>.<consumer|producer>.auto-create-resources</code>属性，默认情况下处于启用状态。</p><p>从1.1版开始，可以为所有绑定全局配置这些和其他绑定程序属性，例如<code class="literal">spring.cloud.stream.gcp.pubsub.default.consumer.auto-create-resources</code> 。</p><p>如果您在Spring Cloud GCP Pub / Sub Starter中使用Pub / Sub自动配置，则应参考<a class="link" href="#pubsub-configuration" title="153.3配置">配置</a>部分以了解其他Pub / Sub参数。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>要将此绑定程序与<a class="link" href="https://cloud.google.com/pubsub/docs/emulator" target="_top">正在运行的仿真器一起使用</a> ，请通过配置它的主机和端口<code class="literal">spring.cloud.gcp.pubsub.emulator-host</code> 。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_producer_destination_configuration" href="#_producer_destination_configuration"></a> 157.2.1生产者目标配置</h3></div></div></div><p>如果打开自动资源创建功能，并且与目标名称对应的主题不存在，则会创建该资源。</p><p>例如，对于以下配置，一个名为<code class="literal">myEvents</code>将被创建。</p><p><b>application.properties。</b>
</p><pre class="screen">spring.cloud.stream.bindings.events.destination=myEvents
spring.cloud.stream.gcp.pubsub.bindings.events.producer.auto-create-resources=true</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer_destination_configuration" href="#_consumer_destination_configuration"></a> 157.2.2使用者目的地配置</h3></div></div></div><p>如果打开了自动资源创建功能，并且对于用户而言不存在订阅和/或主题，则将创建订阅和潜在的主题。主题名称将与目标名称相同，订阅名称将是目标名称，后跟使用者组名称。</p><p>不管<code class="literal">auto-create-resources</code>设置，如果未指定使用者组，则将创建一个匿名用户组，名称为<code class="literal">anonymous.<destinationName>.<randomUUID></code> 。然后，当活页夹关闭时，将自动清除为匿名使用者组创建的所有发布/订阅订阅。</p><p>例如，对于以下配置，一个名为<code class="literal">myEvents</code>和一个名为<code class="literal">myEvents.counsumerGroup1</code>将被创建。如果未指定使用者组，则订阅称为<code class="literal">anonymous.myEvents.a6d83782-c5a3-4861-ac38-e6e2af15a7be</code>将被创建，然后清理。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>如果要手动为使用者创建发布/订阅，请确保它们遵循以下命名约定： <code class="literal"><destinationName>.<consumerGroup></code> 。</p></td></tr></tbody></table></div><p><b>application.properties。</b>
</p><pre class="screen">spring.cloud.stream.bindings.events.destination=myEvents
spring.cloud.stream.gcp.pubsub.bindings.events.consumer.auto-create-resources=true

# specify consumer group, and avoid anonymous consumer group generation
spring.cloud.stream.bindings.events.group=consumerGroup1</pre><p>
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_5" href="#_sample_5"></a> 157.3样本</h2></div></div></div><p>提供了<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-pubsub-binder-sample" target="_top">示例应用程序</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_sleuth_2" href="#_spring_cloud_sleuth_2"></a> 158。 Spring Cloud Sleuth </h2></div></div></div><p><a class="link" href="https://cloud.spring.io/spring-cloud-sleuth/" target="_top">Spring Cloud Sleuth</a>是用于Spring Boot应用程序的工具框架。它捕获跟踪信息，并将跟踪转发到Zipkin之类的服务以进行存储和分析。</p><p>Google Cloud Platform提供了自己的托管分布式跟踪服务，称为<a class="link" href="https://cloud.google.com/trace/" target="_top">Stackdriver Trace</a> 。您可以使用Stackdriver Trace来存储跟踪，查看跟踪详细信息，生成延迟分布图以及生成性能回归报告，而不必运行和维护自己的Zipkin实例和存储。</p><p>该Spring Cloud GCP入门程序无需中间Zipkin服务器即可将Spring Cloud Sleuth跟踪转发到Stackdriver Trace。</p><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-trace<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-trace'
}</pre><p>您必须从Google Cloud Console启用Stackdriver Trace API才能捕获跟踪。导航到项目的<a class="link" href="https://console.cloud.google.com/apis/api/cloudtrace.googleapis.com/overview" target="_top">Stackdriver Trace API</a> ，并确保已启用它。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您已经在使用Zipkin服务器捕获来自多个平台/框架的跟踪信息，则还可以使用<a class="link" href="https://cloud.google.com/trace/docs/zipkin" target="_top">Stackdriver Zipkin代理</a>将这些跟踪转发到Stackdriver Trace，而无需修改现有应用程序。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_tracing_2" href="#_tracing_2"></a> 158.1跟踪</h2></div></div></div><p>Spring Cloud Sleuth使用<a class="link" href="https://github.com/openzipkin/brave" target="_top">Brave跟踪器</a>生成跟踪。这种集成使Brave可以使用<a class="link" href="https://github.com/openzipkin/zipkin-gcp/tree/master/propagation-stackdriver" target="_top"><code class="literal">StackdriverTracePropagation</code></a>传播。</p><p>传播负责从实体（例如HTTP Servlet请求）中提取跟踪上下文，并将跟踪上下文注入到实体中。传播用法的一个典型示例是一个Web服务器，它接收一个HTTP请求，该请求会在将HTTP响应返回给原始调用者之前触发来自该服务器的其他HTTP请求。如果是<code class="literal">StackdriverTracePropagation</code> ，首先它会在<code class="literal">x-cloud-trace-context</code>密钥（例如HTTP请求标头）。的价值<code class="literal">x-cloud-trace-context</code>密钥可以通过三种不同的方式进行格式化：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">x-cloud-trace-context: TRACE_ID</code></li><li class="listitem"><code class="literal">x-cloud-trace-context: TRACE_ID/SPAN_ID</code></li><li class="listitem"><code class="literal">x-cloud-trace-context: TRACE_ID/SPAN_ID;o=TRACE_TRUE</code></li></ul></div><p><code class="literal">TRACE_ID</code>是一个32个字符的十六进制值，它编码一个128位数字。</p><p><code class="literal">SPAN_ID</code>是一个无符号的long。由于Stackdriver Trace不支持跨度连接，因此始终生成一个新的跨度ID，无论在<code class="literal">x-cloud-trace-context</code> 。</p><p><code class="literal">TRACE_TRUE</code>可以是<code class="literal">0</code>如果该实体应该被追踪，或者<code class="literal">1</code>是否应该追踪。该字段强制决定是否跟踪请求。如果省略，则将决定推迟到采样器。</p><p>如果一个<code class="literal">x-cloud-trace-context</code>找不到密钥， <code class="literal">StackdriverTracePropagation</code>回退到使用<a class="link" href="https://github.com/openzipkin/b3-propagation" target="_top">X-B3标头</a>进行跟踪。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_boot_starter_for_stackdriver_trace" href="#_spring_boot_starter_for_stackdriver_trace"></a> 158.2用于Stackdriver Trace的Spring Boot Starter</h2></div></div></div><p>用于Stackdriver Trace的Spring Boot Starter使用Spring Cloud Sleuth并自动配置<a class="link" href="https://github.com/openzipkin/zipkin-gcp/blob/master/sender-stackdriver/src/main/java/zipkin2/reporter/stackdriver/StackdriverSender.java" target="_top">StackdriverSender</a> ，该<a class="link" href="https://github.com/openzipkin/zipkin-gcp/blob/master/sender-stackdriver/src/main/java/zipkin2/reporter/stackdriver/StackdriverSender.java" target="_top">Sender</a>将Sleuth的跟踪信息发送到Stackdriver Trace。</p><p>所有配置都是可选的：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>需要</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>自动配置Spring Cloud Sleuth以将跟踪发送到Stackdriver Trace。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.project-id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>覆盖<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP模块中</a>的项目ID</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>覆盖<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP模块中</a>的凭证位置</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>覆盖<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP模块中</a>的凭据编码密钥</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.credentials.scopes</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>从<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP模块</a>覆盖凭证范围</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.num-executor-threads</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>跟踪执行程序使用的线程数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>4</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.authority</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>通道声称要连接的HTTP / 2权限。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.compression</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>在Trace调用中使用的压缩名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.deadline-ms</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>通话截止时间（以毫秒为单位）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.max-inbound-size</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>入站邮件的最大大小</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.max-outbound-size</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>出站邮件的最大大小</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.trace.wait-for-ready</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="https://github.com/grpc/grpc/blob/master/doc/wait-for-ready.md" target="_top">等待通道准备就绪</a> ，以防出现瞬态故障</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">false</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.trace.messageTimeout</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>将待处理的跨度批量发送到GCP Stackdriver Trace之前的超时时间（以秒为单位）。添加了向前兼容性。</p></td><td align="left" valign="top" style="border-right:1px solid"><p>没有</p></td><td align="left" valign="top"><p><code class="literal">spring.zipkin.messageTimeout</code></p></td></tr></tbody></table></div><p>您可以使用核心Spring Cloud Sleuth属性来控制Sleuth的采样率等。有关Sleuth配置的更多信息，请阅读<a class="link" href="https://cloud.spring.io/spring-cloud-sleuth/" target="_top">Sleuth文档</a> 。</p><p>例如，当您测试以查看走线时，可以将采样率设置为100％。</p><pre class="screen">spring.sleuth.sampler.probability=1                     # Send 100% of the request traces to Stackdriver.
spring.sleuth.web.skipPattern=(^cleanup.*|.+favicon.*)  # Ignore some URL paths.</pre><p>Spring Cloud GCP Trace确实会覆盖一些Sleuth配置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">始终使用128位跟踪ID。这是Stackdriver Trace所必需的。</li><li class="listitem">不使用跨接。跨度联接将在客户端和服务器跨度之间共享跨度ID。Stackdriver要求跟踪中的每个跨度ID都是唯一的，因此不支持跨度联接。</li><li class="listitem">用途<code class="literal">StackdriverHttpClientParser</code>和<code class="literal">StackdriverHttpServerParser</code>默认情况下填充Stackdriver相关字段。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_overriding_the_auto_configuration" href="#_overriding_the_auto_configuration"></a> 158.3覆盖自动配置</h2></div></div></div><p>从2.1.0版开始，Spring Cloud Sleuth支持将跟踪发送到多个跟踪系统。为了使它起作用，每个跟踪系统都需要有一个<code class="literal">Reporter<Span></code>和<code class="literal">Sender</code> 。如果要覆盖提供的bean，则需要给它们指定一个特定的名称。为此，您可以分别使用<code class="literal">StackdriverTraceAutoConfiguration.REPORTER_BEAN_NAME</code>和<code class="literal">StackdriverTraceAutoConfiguration.SENDER_BEAN_NAME</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_integration_with_logging" href="#_integration_with_logging"></a> 158.4与日志集成</h2></div></div></div><p>通过<a class="link" href="logging.adoc" target="_top">Stackdriver Logging支持</a>可以与Stackdriver Logging集成。如果将“跟踪”集成与“日志记录”一起使用，则请求日志将与相应的跟踪相关联。可以通过以下方式查看跟踪日志：转到<a class="link" href="https://console.cloud.google.com/traces/traces" target="_top">Google Cloud Console跟踪列表</a> ，选择一个跟踪，然后按<code class="literal">Logs → View</code>链接<code class="literal">Details</code>部分。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_6" href="#_sample_6"></a> 158.5样本</h2></div></div></div><p>提供了一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-trace-sample" target="_top">示例应用程序</a>和一个代码<a class="link" href="https://codelabs.developers.google.com/codelabs/cloud-spring-cloud-gcp-trace/index.html" target="_top">实验室</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_stackdriver_logging" href="#_stackdriver_logging"></a> 159。Stackdriver记录</h2></div></div></div><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-logging<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-logging'
}</pre><p><a class="link" href="https://cloud.google.com/logging/" target="_top">Stackdriver Logging</a>是Google Cloud Platform提供的托管日志记录服务。</p><p>该模块提供了将Web请求跟踪ID与相应的日志条目相关联的支持。它是通过检索<code class="literal">X-B3-TraceId</code> <a class="link" href="https://logback.qos.ch/manual/mdc.html" target="_top">映射诊断上下文（MDC）中的值</a> ，该值由Spring Cloud Sleuth设置。如果不使用Spring Cloud Sleuth，则已配置<code class="literal">TraceIdExtractor</code>提取所需的标头值并将其设置为日志条目的跟踪ID。这允许根据请求对日志消息进行分组，例如在<a class="link" href="https://console.cloud.google.com/logs/viewer" target="_top">Google Cloud Console日志查看器中</a> 。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>由于日志记录的设置方式，GCP项目ID和凭据在<code class="literal">application.properties</code>被忽略。相反，您应该设置<code class="literal">GOOGLE_CLOUD_PROJECT</code>和<code class="literal">GOOGLE_APPLICATION_CREDENTIALS</code>环境变量分别指向项目ID和凭证私钥位置。如果您使用的是<a class="link" href="https://cloud.google.com/sdk" target="_top">Google Cloud SDK</a> ，则可以轻松完成此操作<code class="literal">gcloud config set project [YOUR_PROJECT_ID]</code>和<code class="literal">gcloud auth application-default login</code>命令。</p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_web_mvc_interceptor" href="#_web_mvc_interceptor"></a> 159.1 Web MVC拦截器</h2></div></div></div><p>为了在基于Web MVC的应用程序中使用， <code class="literal">TraceIdLoggingWebMvcInterceptor</code>提供了使用以下命令从HTTP请求中提取请求跟踪ID的功能： <code class="literal">TraceIdExtractor</code>并将其存储在本地线程中，然后可以在日志记录附加程序中使用它以将跟踪ID元数据添加到日志消息中。</p><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>如果启用了Spring Cloud GCP跟踪，则日志记录模块会禁用自身并将日志相关性委派给Spring Cloud Sleuth。</p></td></tr></tbody></table></div><p><code class="literal">LoggingWebMvcConfigurer</code>还提供了配置类来帮助注册<code class="literal">TraceIdLoggingWebMvcInterceptor</code>在Spring MVC应用程序中。</p><p>Google Cloud Platform上托管的应用程序的“ <code class="literal">x-cloud-trace-context</code>标头，将包含在日志条目中。但是，如果使用Sleuth，则会从MDC中获取跟踪ID。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_logback_support" href="#_logback_support"></a> 159.2登录支持</h2></div></div></div><p>当前，仅支持Logback，有两种通过Logback通过此库通过Logback登录到Stackdriver的可能性：通过直接API调用和通过JSON格式的控制台日志。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_log_via_api" href="#_log_via_api"></a> 159.2.1通过API记录</h3></div></div></div><p>使用以下命令可以使用Stackdriver附加程序<code class="literal">org/springframework/cloud/gcp/autoconfigure/logging/logback-appender.xml</code> 。此附加程序从JUL或Logback日志条目构建Stackdriver Logging日志条目，向其添加跟踪ID，然后将其发送到Stackdriver Logging。</p><p><code class="literal">STACKDRIVER_LOG_NAME</code>和<code class="literal">STACKDRIVER_LOG_FLUSH_LEVEL</code>环境变量可用于自定义<code class="literal">STACKDRIVER</code>追加器。</p><p>然后，您的配置可能如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">resource</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"org/springframework/cloud/gcp/autoconfigure/logging/logback-appender.xml"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag"> /&gt;</span>

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;root</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">level</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"INFO"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender-ref</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ref</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"STACKDRIVER"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag"> /&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/root&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span></pre><p>如果要对日志输出进行更多控制，则可以进一步配置附加程序。可以使用以下属性：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">属性</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">默认值</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">log</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.log</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Stackdriver日志名称。也可以通过<code class="literal">STACKDRIVER_LOG_NAME</code>环境变量。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">flushLevel</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">WARN</code></p></td><td align="left" valign="top"><p>如果遇到具有此级别的日志条目，则触发将本地缓冲的日志刷新到Stackdriver Logging。也可以通过<code class="literal">STACKDRIVER_LOG_FLUSH_LEVEL</code>环境变量。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_log_via_console" href="#_log_via_console"></a> 159.2.2通过控制台登录</h3></div></div></div><p>对于Logback， <code class="literal">org/springframework/cloud/gcp/autoconfigure/logging/logback-json-appender.xml</code>文件可用于导入，以使配置JSON Logback附加程序更加容易。</p><p>然后，您的配置可能如下所示：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;include</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">resource</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"org/springframework/cloud/gcp/autoconfigure/logging/logback-json-appender.xml"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag"> /&gt;</span>

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;root</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">level</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"INFO"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender-ref</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">ref</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"CONSOLE_JSON"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag"> /&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/root&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span></pre><p>如果您的应用程序在Google Kubernetes Engine，Google Compute Engine或Google App Engine Flexible上运行，则您的控制台日志将自动保存到Google Stackdriver Logging。因此，您可以只包含<code class="literal">org/springframework/cloud/gcp/autoconfigure/logging/logback-json-appender.xml</code>在您的记录配置中，该记录将JSON条目记录到控制台。跟踪ID将正确设置。</p><p>如果要对日志输出进行更多控制，则可以进一步配置附加程序。可以使用以下属性：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">属性</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">默认值</th><th align="left" valign="top" style="border-bottom:1px solid">描述</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">projectId</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>如果未设置，则按以下顺序确定默认值：</p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><code class="literal">SPRING_CLOUD_GCP_LOGGING_PROJECT_ID</code>环境变量。</li><li class="listitem">的价值<code class="literal">DefaultGcpProjectIdProvider.getProjectId()</code></li></ol></div></td><td align="left" valign="top" style="border-bottom:1px solid"><p>这用于生成标准的Stackdriver Trace ID格式： <code class="literal">projects/[PROJECT-ID]/traces/[TRACE-ID]</code> 。</p>
<p>需要此格式才能在Stackdriver Trace和Stackdriver Logging之间关联跟踪。</p>
<p>如果<code class="literal">projectId</code>没有设置并且无法确定，那么它将记录<code class="literal">traceId</code>没有完全合格的格式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeTraceId</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该<code class="literal">traceId</code>被包括在内</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeSpanId</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该<code class="literal">spanId</code>被包括在内</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeLevel</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包括严重性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeThreadName</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包含线程名称</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeMDC</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包括所有MDC属性。MDC属性<code class="literal">X-B3-TraceId</code> ， <code class="literal">X-B3-SpanId</code>和<code class="literal">X-Span-Export</code>由Spring Sleuth提供的服务将被排除，因为它们将分开处理</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeLoggerName</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包括记录仪的名称</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeFormattedMessage</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包含格式化的日志消息。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeExceptionInMessage</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应将stacktrace附加到格式化的日志消息中。仅在以下情况下评估此设置： <code class="literal">includeFormattedMessage</code>是<code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeContextName</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">true</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包含日志记录上下文</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">includeMessage</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">false</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否应包含带有空白占位符的日志消息</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">includeException</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">false</code></p></td><td align="left" valign="top"><p>应将stacktrace作为自己的字段包括在内</p></td></tr></tbody></table></div><p>这是此类Logback配置的示例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;configuration &gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;property</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"projectId"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">value</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"${projectId:-${GOOGLE_CLOUD_PROJECT}}"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">/&gt;</span>

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;appender</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">name</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"CONSOLE_JSON"</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.ConsoleAppender"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;encoder</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;layout</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">class</span>=<span xmlns:d="http://docbook.org/ns/docbook" class="hl-value">"org.springframework.cloud.gcp.logging.StackdriverJsonLayout"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;projectId&gt;</span>${projectId}<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/projectId&gt;</span>

        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeTraceId&gt;true&lt;/includeTraceId&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeSpanId&gt;true&lt;/includeSpanId&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeLevel&gt;true&lt;/includeLevel&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeThreadName&gt;true&lt;/includeThreadName&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeMDC&gt;true&lt;/includeMDC&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeLoggerName&gt;true&lt;/includeLoggerName&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeFormattedMessage&gt;true&lt;/includeFormattedMessage&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeExceptionInMessage&gt;true&lt;/includeExceptionInMessage&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeContextName&gt;true&lt;/includeContextName&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeMessage&gt;false&lt;/includeMessage&gt;--&gt;</span>
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">&lt;!--&lt;includeException&gt;false&lt;/includeException&gt;--&gt;</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/layout&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/encoder&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/appender&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/configuration&gt;</span></pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_7" href="#_sample_7"></a> 159.3样本</h2></div></div></div><p>提供了一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-logging-sample" target="_top">示例Spring Boot应用程序</a> ，以显示如何使用Cloud Logging Starter。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_cloud_config_2" href="#_spring_cloud_config_2"></a> 160。Spring Cloud Config</h2></div></div></div><p>Spring Cloud GCP可以将<a class="link" href="https://cloud.google.com/deployment-manager/runtime-configurator/reference/rest/" target="_top">Google Runtime Configuration API</a>用作<a class="link" href="https://cloud.spring.io/spring-cloud-config/" target="_top">Spring Cloud Config</a>服务器来远程存储您的应用程序配置数据。</p><p>Spring Cloud GCP Config支持通过其自己的Spring Boot启动器提供。它将Google Runtime Configuration API用作Spring Boot配置属性的来源。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Google Cloud Runtime Configuration服务处于Beta状态。</p></td></tr></tbody></table></div><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-config<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-config'
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_5" href="#_configuration_5"></a> 160.1配置</h2></div></div></div><p>以下参数可在Spring Cloud GCP Config中配置：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>需要</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用配置客户端</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">false</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.name</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>您的申请名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>价值<code class="literal">spring.application.name</code>属性。如果没有<code class="literal">application</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.profile</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>活动资料</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>价值<code class="literal">spring.profiles.active</code>属性。如果不止一个配置文件，则选择最后一个</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.timeout-millis</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>连接到Google Runtime Configuration API的超时时间（以毫秒为单位）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">60000</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.project-id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>托管Google Runtime Configuration API的GCP项目ID</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>OAuth2凭据，用于通过Google Runtime Configuration API进行身份验证</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.config.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Base64编码的OAuth2凭据，用于通过Google Runtime Configuration API进行身份验证</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.config.credentials.scopes</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>Spring Cloud GCP Config凭证的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">OAuth2范围</a></p></td><td align="left" valign="top" style="border-right:1px solid"><p>没有</p></td><td align="left" valign="top"><p><a class="link" href="https://www.googleapis.com/auth/cloudruntimeconfig" target="_top">https://www.googleapis.com/auth/cloudruntimeconfig</a></p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>这些属性应在<a class="link" href="https://cloud.spring.io/spring-cloud-static/spring-cloud.html#_the_bootstrap_application_context" target="_top"><code class="literal">bootstrap.yml</code> / <code class="literal">bootstrap.properties</code></a>文件，而不是通常的文件<code class="literal">applications.yml</code> / <code class="literal">application.properties</code> 。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中</a>所述，核心属性不适用于Spring Cloud GCP Config。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_quick_start_6" href="#_quick_start_6"></a> 160.2快速入门</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">在称为Google Runtime Configuration API的配置中创建一个配置<code class="literal">${spring.application.name}_${spring.profiles.active}</code> 。换句话说，如果<code class="literal">spring.application.name</code>是<code class="literal">myapp</code>和<code class="literal">spring.profiles.active</code>是<code class="literal">prod</code> ，配置应称为<code class="literal">myapp_prod</code> 。</p><p class="simpara">为此，您应该安装<a class="link" href="https://cloud.google.com/sdk/" target="_top">Google Cloud SDK</a> ，拥有Google Cloud Project并运行以下命令：</p></li></ol></div><pre class="screen">gcloud init # if this is your first Google Cloud SDK run.
gcloud beta runtime-config configs create myapp_prod
gcloud beta runtime-config configs variables set myapp.queue-size 25 --config-name myapp_prod</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">配置您的<code class="literal">bootstrap.properties</code>文件，其中包含应用程序的配置数据：</p><pre class="screen">spring.application.name=myapp
spring.profiles.active=prod</pre></li><li class="listitem"><p class="simpara">添加<code class="literal">@ConfigurationProperties</code> Spring管理的bean的注释：</p><pre class="screen">@Component
@ConfigurationProperties("myapp")
public class SampleConfig {

  private int queueSize;

  public int getQueueSize() {
    return this.queueSize;
  }

  public void setQueueSize(int queueSize) {
    this.queueSize = queueSize;
  }
}</pre></li></ol></div><p>当您的Spring应用程序启动时， <code class="literal">queueSize</code>上面的字段值将设置为25 <code class="literal">SampleConfig</code> bean 。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_refreshing_the_configuration_at_runtime" href="#_refreshing_the_configuration_at_runtime"></a> 160.3在运行时刷新配置</h2></div></div></div><p><a class="link" href="https://cloud.spring.io/spring-cloud-static/docs/1.0.x/spring-cloud.html#_endpoints" target="_top">Spring Cloud</a>支持使用POST请求重新加载配置参数以支持<code class="literal">/actuator/refresh</code>端点。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">添加Spring Boot Actuator依赖项：</li></ol></div><p>Maven坐标：</p><pre class="screen">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.boot', name: 'spring-boot-starter-actuator'
}</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">加<code class="literal">@RefreshScope</code>到Spring配置类中，以使参数可以在运行时重新加载。</li><li class="listitem">加<code class="literal">management.endpoints.web.exposure.include=refresh</code>给你<code class="literal">application.properties</code>允许不受限制地访问<code class="literal">/actuator/refresh</code> 。</li><li class="listitem"><p class="simpara">使用更新属性<code class="literal">gcloud</code> ：</p><pre class="literallayout">$ gcloud beta runtime-config configs variables set \
  myapp.queue_size 200 \
  --config-name myapp_prod</pre></li><li class="listitem"><p class="simpara">发送POST请求到刷新端点：</p><pre class="literallayout">$ curl -XPOST https://myapp.host.com/actuator/refresh</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_8" href="#_sample_8"></a> 160.4样本</h2></div></div></div><p>提供了一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-config-sample" target="_top">示例应用程序</a>和一个代码<a class="link" href="https://codelabs.developers.google.com/codelabs/cloud-spring-runtime-config/index.html" target="_top">实验室</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_data_cloud_spanner" href="#_spring_data_cloud_spanner"></a> 161。Spring Data Cloud Spanner</h2></div></div></div><p><a class="link" href="https://projects.spring.io/spring-data/" target="_top">Spring Data</a>是用于以多种存储技术存储和检索POJO的抽象。Spring Cloud GCP增加了对<a class="link" href="https://cloud.google.com/spanner/" target="_top">Google Cloud Spanner的</a> Spring Data支持。</p><p>Maven仅使用Spring Cloud GCP BOM协调此模块：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-data-spanner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-data-spanner'
}</pre><p>我们<a class="link" href="../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-spanner" target="_top">为Spring Data Spanner</a>提供了一个<a class="link" href="../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-spanner" target="_top">Spring Boot Starter</a> ，您可以利用它来使用我们推荐的自动配置设置。要使用启动器，请参见下面的坐标。</p><p>Maven：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-data-spanner<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-data-spanner'
}</pre><p>此设置还负责引入Cloud Java Cloud Spanner库的最新兼容版本。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_6" href="#_configuration_6"></a> 161.1配置</h2></div></div></div><p>要设置Spring Data Cloud Spanner，您必须配置以下内容：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">设置与Google Cloud Spanner的连接详细信息。</li><li class="listitem">启用Spring数据存储库（可选）。</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_cloud_spanner_settings" href="#_cloud_spanner_settings"></a> 161.1.1 Cloud Spanner设置</h3></div></div></div><p>您可以使用<a class="link" href="../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-spanner" target="_top">Spring Boot Starter for Spring Data</a> Spanner在Spring应用程序中自动配置Google Cloud Spanner。它包含所有必要的设置，使您可以轻松地通过Google Cloud项目进行身份验证。以下配置选项可用：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>需要</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.instance-id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>要使用的Cloud Spanner实例</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.database</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>要使用的Cloud Spanner数据库</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.project-id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>托管Google Cloud Spanner API的GCP项目ID（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a> ID不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于与Google Cloud Spanner API进行身份验证的OAuth2凭证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a>凭证不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于与Google Cloud Spanner API进行身份验证的Base64编码的OAuth2凭证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a>凭证不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.credentials.scopes</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Spring Cloud GCP Cloud Spanner凭证的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">OAuth2范围</a></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/spanner.data" target="_top">https://www.googleapis.com/auth/spanner.data</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.createInterleavedTableDdlOnDeleteCascade</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>如果<code class="literal">true</code> ，然后生成由<code class="literal">SpannerSchemaUtils</code>对于具有交错的父子关系的表，将为“ ON DELETE CASCADE”。如果以下情况，则表的模式将为“ ON DELETE NO ACTION” <code class="literal">false</code> 。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.numRpcChannels</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于连接到Cloud Spanner的gRPC通道数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>4-由Cloud Spanner客户端库确定</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.prefetchChunks</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Cloud Spanner为读取和查询预取的块数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>4-由Cloud Spanner客户端库确定</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.minSessions</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>会话池中维护的最小会话数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0-由Cloud Spanner客户端库确定</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.maxSessions</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>会话池可以拥有的最大会话数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>400-由Cloud Spanner客户端库确定</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.maxIdleSessions</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>会话池将保持的最大空闲会话数</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0-由Cloud Spanner客户端库确定</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.writeSessionsFraction</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>要为写事务准备的会话比例</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>0.2-由Cloud Spanner客户端库确定</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.spanner.keepAliveIntervalMinutes</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>保持空闲会话多长时间</p></td><td align="left" valign="top" style="border-right:1px solid"><p>没有</p></td><td align="left" valign="top"><p>30-由Cloud Spanner客户端库确定</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_repository_settings" href="#_repository_settings"></a> 161.1.2存储库设置</h3></div></div></div><p>可以通过以下方式配置Spring Data Repository <code class="literal">@EnableSpannerRepositories</code>主标注<code class="literal">@Configuration</code>类。借助我们用于Spring Data Cloud Spanner的Spring Boot Starter， <code class="literal">@EnableSpannerRepositories</code>自动添加。不需要将其添加到其他任何类中，除非需要覆盖由<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/blob/master/spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/config/EnableSpannerRepositories.java" target="_top"><code class="literal">@EnableSpannerRepositories</code></a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_autoconfiguration" href="#_autoconfiguration"></a> 161.1.3自动配置</h3></div></div></div><p>我们的Spring Boot自动配置会在Spring应用程序上下文中创建以下可用的bean：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">的实例<code class="literal">SpannerTemplate</code></li><li class="listitem">的实例<code class="literal">SpannerDatabaseAdminTemplate</code>用于从对象层次结构生成表架构以及创建和删除表和数据库</li><li class="listitem">所有用户定义存储库扩展的实例<code class="literal">SpannerRepository</code> ， <code class="literal">CrudRepository</code> ， <code class="literal">PagingAndSortingRepository</code> ，启用存储库时</li><li class="listitem">的实例<code class="literal">DatabaseClient</code>从Google Cloud Java Client for Spanner中获得，以方便使用和较低级别的API访问</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_object_mapping" href="#_object_mapping"></a> 161.2对象映射</h2></div></div></div><p>Spring Data Cloud Spanner允许您通过注释将域POJO映射到Cloud Spanner表：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Table(name = "traders")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trader {

	<em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
	<em><span class="hl-annotation" style="color: gray">@Column(name = "trader_id")</span></em>
	String traderId;

	String firstName;

	String lastName;

	<em><span class="hl-annotation" style="color: gray">@NotMapped</span></em>
	Double temporaryNumber;
}</pre><p>Spring Data Cloud Spanner将忽略任何带有注释的属性<code class="literal">@NotMapped</code> 。这些属性不会写入或从Spanner读取。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_constructors" href="#_constructors"></a> 161.2.1构造函数</h3></div></div></div><p>POJO支持简单的构造函数。构造函数参数可以是持久属性的子集。每个构造函数参数都必须具有与实体上的持久属性相同的名称和类型，构造函数应从给定参数设置属性。不支持未直接设置为属性的参数。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Table(name = "traders")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trader {
	<em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
	<em><span class="hl-annotation" style="color: gray">@Column(name = "trader_id")</span></em>
	String traderId;

	String firstName;

	String lastName;

	<em><span class="hl-annotation" style="color: gray">@NotMapped</span></em>
	Double temporaryNumber;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Trader(String traderId, String firstName) {
	    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.traderId = traderId;
	    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.firstName = firstName;
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_table" href="#_table"></a> 161.2.2表</h3></div></div></div><p>的<code class="literal">@Table</code>注释可以提供Cloud Spanner表的名称，该表存储带注释的类的实例，每行一个。此批注是可选的，如果未给出，则从类名推断出表名，首字符不大写。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_spel_expressions_for_table_names" href="#_spel_expressions_for_table_names"></a>表名称的SpEL表达式</h4></div></div></div><p>在某些情况下，您可能希望<code class="literal">@Table</code>表名要动态确定。为此，您可以使用<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions" target="_top">Spring Expression Language</a> 。</p><p>例如：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Table(name = "trades_#{tableNameSuffix}")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trade {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ...</span>
}</pre><p>只有在以下情况下才能解析表名： <code class="literal">tableNameSuffix</code>在Spring应用程序上下文中定义了value / bean。例如，如果<code class="literal">tableNameSuffix</code>的值为“ 123”，表名将解析为<code class="literal">trades_123</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_primary_keys" href="#_primary_keys"></a> 161.2.3主键</h3></div></div></div><p>对于一个简单的表，您可能只有一个由单列组成的主键。即使在这种情况下， <code class="literal">@PrimaryKey</code>注释为必填项。
<code class="literal">@PrimaryKey</code>标识与主键相对应的一个或多个ID属性。</p><p>Spanner对多列复合主键具有一流的支持。您必须注释主键所包含的所有POJO字段<code class="literal">@PrimaryKey</code>如下：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Table(name = "trades")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trade {
	<em><span class="hl-annotation" style="color: gray">@PrimaryKey(keyOrder = 2)</span></em>
	<em><span class="hl-annotation" style="color: gray">@Column(name = "trade_id")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String tradeId;

	<em><span class="hl-annotation" style="color: gray">@PrimaryKey(keyOrder = 1)</span></em>
	<em><span class="hl-annotation" style="color: gray">@Column(name = "trader_id")</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String traderId;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String action;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Double price;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> Double shares;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> String symbol;
}</pre><p>的<code class="literal">keyOrder</code>的参数<code class="literal">@PrimaryKey</code>按顺序标识与主键列相对应的属性，从1开始并连续增加。顺序很重要，必须反映出Cloud Spanner模式中定义的顺序。在我们的示例中，用于创建表的DDL及其主键如下：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">CREATE</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">TABLE</span> trades (
    trader_id STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    trade_id STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">action</span> STRING(<span class="hl-number">15</span>),
    symbol STRING(<span class="hl-number">10</span>),
    price FLOAT64,
    shares FLOAT64
) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">PRIMARY</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">KEY</span> (trader_id, trade_id)</pre><p>扳手没有自动生成ID。对于大多数用例，应谨慎使用顺序ID，以避免在系统中创建数据热点。阅读<a class="link" href="https://cloud.google.com/spanner/docs/schema-and-data-model#primary_keys" target="_top">Spanner主键文档</a> ，以更好地了解主键和建议的做法。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_columns" href="#_columns"></a> 161.2.4列</h3></div></div></div><p>POJO上的所有可访问属性都将自动识别为Cloud Spanner列。列命名是由<code class="literal">PropertyNameFieldNamingStrategy</code>默认情况下在<code class="literal">SpannerMappingContext</code> bean 。的<code class="literal">@Column</code>注释可以选择提供与属性和其他一些设置不同的列名：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">name</code>是列的可选名称</li><li class="listitem"><code class="literal">spannerTypeMaxLength</code>指定用于<code class="literal">STRING</code>和<code class="literal">BYTES</code>列的最大长度。仅在基于域类型生成DDL架构语句时才使用此设置。</li><li class="listitem"><code class="literal">nullable</code>指定是否将列创建为<code class="literal">NOT NULL</code> 。仅在基于域类型生成DDL架构语句时才使用此设置。</li><li class="listitem"><code class="literal">spannerType</code>是您可以选择指定的Cloud Spanner列类型。如果未指定，则从Java属性类型推断兼容的列类型。</li><li class="listitem"><code class="literal">spannerCommitTimestamp</code>是一个布尔值，指定此属性是否对应于自动填充的提交时间戳记列。写入Cloud Spanner时，将忽略此属性中设置的任何值。</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_embedded_objects" href="#_embedded_objects"></a> 161.2.5嵌入式对象</h3></div></div></div><p>如果对象是类型<code class="literal">B</code>嵌入为<code class="literal">A</code> ，然后是<code class="literal">B</code>将与以下文件保存在同一Cloud Spanner表中<code class="literal">A</code> 。</p><p>如果<code class="literal">B</code>具有主键列，这些列将包含在<code class="literal">A</code> 。 <code class="literal">B</code>也可以具有嵌入式属性。嵌入允许在多个实体之间重复使用列，并且对于实现父子情况非常有用，因为Cloud Spanner要求子表包括其父项的关键列。</p><p>例如：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> X {
  <em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
  String grandParentId;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> age;
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> A {
  <em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
  <em><span class="hl-annotation" style="color: gray">@Embedded</span></em>
  X grandParent;

  <em><span class="hl-annotation" style="color: gray">@PrimaryKey(keyOrder = 2)</span></em>
  String parentId;

  String value;
}

<em><span class="hl-annotation" style="color: gray">@Table(name = "items")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> B {
  <em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
  <em><span class="hl-annotation" style="color: gray">@Embedded</span></em>
  A parent;

  <em><span class="hl-annotation" style="color: gray">@PrimaryKey(keyOrder = 2)</span></em>
  String id;

  <em><span class="hl-annotation" style="color: gray">@Column(name = "child_value")</span></em>
  String value;
}</pre><p>的实体<code class="literal">B</code>可以存储在定义为的表中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">CREATE</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">TABLE</span> items (
    grandParentId STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    parentId STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    id STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">value</span> STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    child_value STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
    age INT64
) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">PRIMARY</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">KEY</span> (grandParentId, parentId, id)</pre><p>请注意，嵌入属性的列名称必须全部唯一。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_relationships" href="#_relationships"></a> 161.2.6关系</h3></div></div></div><p>Spring Data Cloud Spanner使用Cloud Spanner <a class="link" href="https://cloud.google.com/spanner/docs/schema-and-data-model#creating-interleaved-tables" target="_top">父子交错表机制</a>支持父子关系。Cloud Spanner交错表强制一对多关系，并在单个域父实体的实体上提供有效的查询和操作。这些关系最多可以达到7个层次。Cloud Spanner还提供自动级联删除或强制删除父级之前的子实体。</p><p>尽管可以在Cloud Spanner和Spring Data Cloud Spanner中使用交错的父子表的构造实现一对一和多对多关系，但仅本地支持父子关系。Cloud Spanner不支持外键约束，尽管父子键约束在与交错表一起使用时会强制执行类似的要求。</p><p>例如，以下Java实体：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Table(name = "Singers")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Singer {
  <em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> SingerId;

  String FirstName;

  String LastName;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">byte</span>[] SingerInfo;

  <em><span class="hl-annotation" style="color: gray">@Interleaved</span></em>
  List&lt;Album&gt; albums;
}

<em><span class="hl-annotation" style="color: gray">@Table(name = "Albums")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Album {
  <em><span class="hl-annotation" style="color: gray">@PrimaryKey</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> SingerId;

  <em><span class="hl-annotation" style="color: gray">@PrimaryKey(keyOrder = 2)</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> AlbumId;

  String AlbumTitle;
}</pre><p>这些类可以对应于一对现有的交错表。的<code class="literal">@Interleaved</code>注释可以应用于<code class="literal">Collection</code>属性和内部类型解析为子实体类型。创建它们所需的架构也可以使用<code class="literal">SpannerSchemaUtils</code>并使用<code class="literal">SpannerDatabaseAdminTemplate</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
SpannerSchemaUtils schemaUtils;

<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
SpannerDatabaseAdminTemplate databaseAdmin;
...

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Get the create statmenets for all tables in the table structure rooted at Singer</span>
List&lt;String&gt; createStrings = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.schemaUtils.getCreateTableDdlStringsForInterleavedHierarchy(Singer.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Create the tables and also create the database if necessary</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.databaseAdmin.executeDdlStrings(createStrings, true);</pre><p>的<code class="literal">createStrings</code> list包含表架构语句，这些语句使用与提供的Java类型兼容的列名和类型，以及基于配置的自定义转换器而包含在其中的任何已解析子关系类型。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">CREATE</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">TABLE</span> Singers (
  SingerId   INT64 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">NOT</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">NULL</span>,
  FirstName  STRING(<span class="hl-number">1024</span>),
  LastName   STRING(<span class="hl-number">1024</span>),
  SingerInfo BYTES(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">PRIMARY</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">KEY</span> (SingerId);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">CREATE</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">TABLE</span> Albums (
  SingerId     INT64 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">NOT</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">NULL</span>,
  AlbumId      INT64 <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">NOT</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">NULL</span>,
  AlbumTitle   STRING(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">MAX</span>),
) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">PRIMARY</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">KEY</span> (SingerId, AlbumId),
  INTERLEAVE <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">IN</span> PARENT Singers <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">ON</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">DELETE</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">CASCADE</span>;</pre><p>的<code class="literal">ON DELETE CASCADE</code>子句表示如果删除歌手，Cloud Spanner将删除该歌手的所有专辑。替代方法是<code class="literal">ON DELETE NO ACTION</code> ，除非已删除所有歌手的专辑，否则无法删除该歌手。使用时<code class="literal">SpannerSchemaUtils</code>生成模式字符串， <code class="literal">spring.cloud.gcp.spanner.createInterleavedTableDdlOnDeleteCascade</code>布尔设置确定是否将这些架构生成为<code class="literal">ON DELETE CASCADE</code>对于<code class="literal">true</code>和<code class="literal">ON DELETE NO ACTION</code>对于<code class="literal">false</code> 。</p><p>Cloud Spanner将这些关系限制为7个子层。一个表可能有多个子表。</p><p>在将对象更新或插入Cloud Spanner时，其所有引用的子对象也将分别更新或插入同一请求中。在读取时，所有交错的子行也都被读取。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_supported_types" href="#_supported_types"></a> 161.2.7支持的类型</h3></div></div></div><p>Spring Data Cloud Spanner本机支持常规字段的以下类型，但也利用自定义转换器（在以下各节中详细介绍）和许多预定义的Spring Data自定义转换器来处理其他常见的Java类型。</p><p>本机支持的类型：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">com.google.cloud.ByteArray</code></li><li class="listitem"><code class="literal">com.google.cloud.Date</code></li><li class="listitem"><code class="literal">com.google.cloud.Timestamp</code></li><li class="listitem"><code class="literal">java.lang.Boolean</code> ，<code class="literal">boolean</code></li><li class="listitem"><code class="literal">java.lang.Double</code> ，<code class="literal">double</code></li><li class="listitem"><code class="literal">java.lang.Long</code> ，<code class="literal">long</code></li><li class="listitem"><code class="literal">java.lang.Integer</code> ，<code class="literal">int</code></li><li class="listitem"><code class="literal">java.lang.String</code></li><li class="listitem"><code class="literal">double[]</code></li><li class="listitem"><code class="literal">long[]</code></li><li class="listitem"><code class="literal">boolean[]</code></li><li class="listitem"><code class="literal">java.util.Date</code></li><li class="listitem"><code class="literal">java.util.Instant</code></li><li class="listitem"><code class="literal">java.sql.Date</code></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_lists" href="#_lists"></a> 161.2.8列表</h3></div></div></div><p>扳手支持<code class="literal">ARRAY</code>列的类型。
<code class="literal">ARRAY</code>列映射到<code class="literal">List</code> POJOS中的字段。</p><p>例：</p><pre class="programlisting">List&lt;Double&gt; curve;</pre><p>列表内的类型可以是任何单个属性类型。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_lists_of_structs" href="#_lists_of_structs"></a> 161.2.9结构清单</h3></div></div></div><p>Cloud Spanner查询可以<a class="link" href="https://cloud.google.com/spanner/docs/query-syntax#using-structs-with-select" target="_top">构造STRUCT值</a> ，这些<a class="link" href="https://cloud.google.com/spanner/docs/query-syntax#using-structs-with-select" target="_top">值</a>在结果中显示为列。Cloud Spanner要求STRUCT值出现在根级别的ARRAY中： <code class="literal">SELECT ARRAY(SELECT STRUCT(1 as val1, 2 as val2)) as pair FROM Users</code> 。</p><p>Spring Data Cloud Spanner会尝试将STRUCT列的值读入一个<code class="literal">Iterable</code>与列STRUCT值的架构兼容的实体类型。</p><p>对于前面的数组选择示例，可以将以下属性与<code class="literal">ARRAY<STRUCT></code>柱： <code class="literal">List<TwoInts> pair;</code>在哪里<code class="literal">TwoInts</code>类型定义：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> TwoInts {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> val1;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> val2;
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_types" href="#_custom_types"></a> 161.2.10自定义类型</h3></div></div></div><p>定制转换器可用于扩展对用户定义类型的类型支持。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">转换器需要实施<code class="literal">org.springframework.core.convert.converter.Converter</code>双向接口。</li><li class="listitem"><p class="simpara">用户定义的类型需要映射到Spanner支持的基本类型之一：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">com.google.cloud.ByteArray</code></li><li class="listitem"><code class="literal">com.google.cloud.Date</code></li><li class="listitem"><code class="literal">com.google.cloud.Timestamp</code></li><li class="listitem"><code class="literal">java.lang.Boolean</code> ，<code class="literal">boolean</code></li><li class="listitem"><code class="literal">java.lang.Double</code> ，<code class="literal">double</code></li><li class="listitem"><code class="literal">java.lang.Long</code> ，<code class="literal">long</code></li><li class="listitem"><code class="literal">java.lang.String</code></li><li class="listitem"><code class="literal">double[]</code></li><li class="listitem"><code class="literal">long[]</code></li><li class="listitem"><code class="literal">boolean[]</code></li><li class="listitem"><code class="literal">enum</code>类型</li></ul></div></li><li class="listitem">两个Converter的实例都需要传递给<code class="literal">ConverterAwareMappingSpannerEntityProcessor</code> ，然后必须将其作为<code class="literal">@Bean</code>对于<code class="literal">SpannerEntityProcessor</code> 。</li></ol></div><p>例如：</p><p>我们希望有一个类型的字段<code class="literal">Person</code>在我们的<code class="literal">Trade</code> POJO：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Table(name = "trades")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trade {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
  Person person;
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
}</pre><p>其中Person是一个简单的类：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Person {

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String firstName;
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String lastName;

}</pre><p>我们必须定义两个转换器：</p><pre class="programlisting">  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> PersonWriteConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> Converter&lt;Person, String&gt; {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String convert(Person person) {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> person.firstName + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" "</span> + person.lastName;
    }
  }

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> PersonReadConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">implements</span> Converter&lt;String, Person&gt; {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Person convert(String s) {
      Person person = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Person();
      person.firstName = s.split(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" "</span>)[<span class="hl-number">0</span>];
      person.lastName = s.split(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" "</span>)[<span class="hl-number">1</span>];
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> person;
    }
  }</pre><p>这将在我们的配置<code class="literal">@Configuration</code>文件：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ConverterConfiguration {

	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> SpannerEntityProcessor spannerEntityProcessor(SpannerMappingContext spannerMappingContext) {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> ConverterAwareMappingSpannerEntityProcessor(spannerMappingContext,
				Arrays.asList(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PersonWriteConverter()),
				Arrays.asList(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> PersonReadConverter()));
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_converter_for_struct_array_columns" href="#_custom_converter_for_struct_array_columns"></a> 161.2.11结构数组列的自定义转换器</h3></div></div></div><p>如果一个<code class="literal">Converter<Struct, A></code>被提供，然后是类型的属性<code class="literal">List<A></code>可以在您的实体类型中使用。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spanner_operations_template" href="#_spanner_operations_template"></a> 161.3扳手操作和模板</h2></div></div></div><p><code class="literal">SpannerOperations</code>及其实施， <code class="literal">SpannerTemplate</code> ，提供了Spring开发人员熟悉的Template模式。它提供：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">资源管理</li><li class="listitem">通过Spring Data POJO映射和转换功能一站式到Spanner操作</li><li class="listitem">异常转换</li></ul></div><p>使用<code class="literal">autoconfigure</code>由我们的Spanner的Spring Boot Starter提供，您的Spring应用程序上下文将包含完整配置的<code class="literal">SpannerTemplate</code>您可以轻松在应用程序中自动连线的对象：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> SpannerTemplateExample {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	SpannerTemplate spannerTemplate;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doSomething() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.delete(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, KeySet.all());
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		Trade t = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Trade();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.insert(t);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		List&lt;Trade&gt; tradesByAction = spannerTemplate.findAll(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}
}</pre><p>模板API提供了以下便捷方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara"><a class="link" href="https://cloud.google.com/spanner/docs/reads" target="_top">读取</a> ，并通过提供SpannerReadOptions和SpannerQueryOptions</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">过时的阅读</li><li class="listitem">阅读二级索引</li><li class="listitem">读取限制和偏移</li><li class="listitem">阅读排序</li></ul></div></li><li class="listitem"><a class="link" href="https://cloud.google.com/spanner/docs/reads#execute_a_query" target="_top">查询</a></li><li class="listitem">DML操作（删除，插入，更新，更新）</li><li class="listitem"><p class="simpara">部分读取</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">您可以定义一组要读入实体的列</li></ul></div></li><li class="listitem"><p class="simpara">部分写入</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">仅保留您实体的一些属性</li></ul></div></li><li class="listitem">只读交易</li><li class="listitem">锁定读写事务</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_sql_query" href="#_sql_query"></a> 161.3.1 SQL查询</h3></div></div></div><p>Cloud Spanner具有运行只读查询的SQL支持。所有与查询相关的方法都以<code class="literal">query</code>上<code class="literal">SpannerTemplate</code> 。使用<code class="literal">SpannerTemplate</code>您可以执行映射到POJO的SQL查询：</p><pre class="programlisting">List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.query(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Statement.of(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SELECT * FROM trades"</span>));</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_read" href="#_read"></a> 161.3.2读取</h3></div></div></div><p>Spanner公开了一个<a class="link" href="https://cloud.google.com/spanner/docs/reads" target="_top">Read API，</a>用于读取表或辅助索引中的单行或多行。</p><p>使用<code class="literal">SpannerTemplate</code>您可以执行读取，例如：</p><pre class="programlisting">List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.readAll(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);</pre><p>相对于查询而言，读取的主要好处是，通过使用特定功能的键，可以轻松读取多行特定模式的键<a class="link" href="https://github.com/GoogleCloudPlatform/google-cloud-java/blob/master/google-cloud-spanner/src/main/java/com/google/cloud/spanner/KeySet.java" target="_top"><code class="literal">KeySet</code></a>类。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_advanced_reads" href="#_advanced_reads"></a> 161.3.3高级读取</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stale_read" href="#_stale_read"></a>过时的阅读</h4></div></div></div><p>默认情况下，所有读取和查询均为<span class="strong"><strong>强读取</strong></span> 。<span class="strong"><strong>强读</strong></span>是在当前时间戳记下进行的读取，可以保证看到直到该读取开始之前已提交的所有数据。另一方面，过去读取的是<span class="strong"><strong>过时</strong></span>的。Cloud Spanner允许您确定读取数据时数据的最新程度。用<code class="literal">SpannerTemplate</code>您可以指定<code class="literal">Timestamp</code>通过设置<code class="literal">SpannerQueryOptions</code>要么<code class="literal">SpannerReadOptions</code>适当的读取或查询方法：</p><p>读：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// a read with options:</span>
SpannerReadOptions spannerReadOptions = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpannerReadOptions().setTimestamp(Timestamp.now());
List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.readAll(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, spannerReadOptions);</pre><p>查询：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// a query with options:</span>
SpannerQueryOptions spannerQueryOptions = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpannerQueryOptions().setTimestamp(Timestamp.now());
List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.query(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Statement.of(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SELECT * FROM trades"</span>), spannerQueryOptions);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_read_from_a_secondary_index" href="#_read_from_a_secondary_index"></a>从二级索引读取</h4></div></div></div><p>可以通过模板API使用<a class="link" href="https://cloud.google.com/spanner/docs/secondary-indexes" target="_top">辅助索引</a>进行读取，也可以通过SQL for Queries隐式使用<a class="link" href="https://cloud.google.com/spanner/docs/secondary-indexes" target="_top">辅助索引</a> 。</p><p>下面显示了如何通过使用<a class="link" href="https://cloud.google.com/spanner/docs/secondary-indexes" target="_top">二级索引</a>简单地通过设置从表中读取行<code class="literal">index</code>上<code class="literal">SpannerReadOptions</code> ：</p><pre class="programlisting">SpannerReadOptions spannerReadOptions = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpannerReadOptions().setIndex(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"TradesByTrader"</span>);
List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.readAll(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, spannerReadOptions);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_read_with_offsets_and_limits" href="#_read_with_offsets_and_limits"></a>读取偏移量和限制</h4></div></div></div><p>限制和偏移量仅受查询支持。以下将仅获取查询的前两行：</p><pre class="programlisting">SpannerQueryOptions spannerQueryOptions = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpannerQueryOptions().setLimit(<span class="hl-number">2</span>).setOffset(<span class="hl-number">3</span>);
List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.query(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Statement.of(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SELECT * FROM trades"</span>), spannerQueryOptions);</pre><p>请注意，以上等效于执行<code class="literal">SELECT * FROM trades LIMIT 2 OFFSET 3</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_sorting" href="#_sorting"></a>排序</h4></div></div></div><p>按键读取不支持排序。但是，对Template API的查询支持通过标准SQL以及Spring Data Sort API进行排序：</p><pre class="programlisting">List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.queryAll(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Sort.by(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"action"</span>));</pre><p>如果提供的排序字段名称是域类型属性的名称，则将在查询中使用与该属性对应的列名称。否则，假定给定的字段名称是Cloud Spanner表中列的名称。在忽略大小写的情况下，可以对Cloud Spanner类型STRING和BYTES的列进行排序：</p><pre class="programlisting">Sort.by(Order.desc(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"action"</span>).ignoreCase())</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_partial_read" href="#_partial_read"></a>部分阅读</h4></div></div></div><p>仅在使用查询时才可以进行部分读取。如果查询返回的行的列少于要映射到的实体的列，Spring Data将仅映射返回的列。此设置也适用于嵌套结构及其相应的嵌套POJO属性。</p><pre class="programlisting">List&lt;Trade&gt; trades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.query(Trade.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>, Statement.of(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"SELECT action, symbol FROM trades"</span>),
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> SpannerQueryOptions().setAllowMissingResultSetColumns(true));</pre><p>如果设置为<code class="literal">false</code> ，如果查询结果中缺少列，则将引发异常。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_summary_of_options_for_query_vs_read" href="#_summary_of_options_for_query_vs_read"></a>查询与读取的选项摘要</h4></div></div></div><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>特征</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>查询支持</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>阅读支持它</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>的SQL</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>没有</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>部分阅读</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>没有</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>限度</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>没有</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>偏移量</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>没有</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>次要指标</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>是</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>使用索引范围读取</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>排序</p></td><td align="left" valign="top" style="border-right:1px solid"><p>是</p></td><td align="left" valign="top"><p>没有</p></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_write_update" href="#_write_update"></a> 161.3.4写入/更新</h3></div></div></div><p>的写方法<code class="literal">SpannerOperations</code>接受POJO并将其所有属性写入Spanner。相应的Spanner表和实体元数据是从给定对象的实际类型获得的。</p><p>如果从Spanner检索了POJO，并且更改了其主键属性值，然后写入或更新了POJO，则该操作将针对具有新主键值的行进行。具有原始主键值的行将不受影响。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_insert" href="#_insert"></a>插入</h4></div></div></div><p>的<code class="literal">insert</code>的方法<code class="literal">SpannerOperations</code>接受POJO并将其所有属性写入Spanner，这意味着如果表中已经存在带有POJO主键的行，则该操作将失败。</p><pre class="programlisting">Trade t = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Trade();
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.insert(t);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_update" href="#_update"></a>更新资料</h4></div></div></div><p>的<code class="literal">update</code>的方法<code class="literal">SpannerOperations</code>接受POJO并将其所有属性写入Spanner，这意味着如果表中尚不存在POJO的主键，则该操作将失败。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// t was retrieved from a previous operation</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.update(t);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_upsert" href="#_upsert"></a>增补</h4></div></div></div><p>的<code class="literal">upsert</code>的方法<code class="literal">SpannerOperations</code>接受POJO并使用update-or-insert将其所有属性写入Spanner。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// t was retrieved from a previous operation or it's new</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.upsert(t);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_partial_update" href="#_partial_update"></a>部分更新</h4></div></div></div><p>的更新方法<code class="literal">SpannerOperations</code>默认情况下，对给定对象内的所有属性进行操作，但也接受<code class="literal">String[]</code>和<code class="literal">Optional<Set<String>></code>列名称。如果<code class="literal">Optional</code>列名称集合中的列为空，然后将所有列写入Spanner。但是，如果Optional被空集占用，则不会写入任何列。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// t was retrieved from a previous operation or it's new</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.update(t, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"symbol"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"action"</span>);</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_dml" href="#_dml"></a> 161.3.5 DML</h3></div></div></div><p>可以使用以下命令执行DML语句<code class="literal">SpannerOperations.executeDmlStatement</code> 。插入，更新和删除可以影响任意数量的行和实体。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_transactions" href="#_transactions"></a> 161.3.6交易</h3></div></div></div><p><code class="literal">SpannerOperations</code>提供运行方法<code class="literal">java.util.Function</code>单个事务中的对象，同时提供来自以下对象的读取和写入方法<code class="literal">SpannerOperations</code> 。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_readwrite_transaction" href="#_readwrite_transaction"></a>读/写事务</h4></div></div></div><p>读写事务由提供<code class="literal">SpannerOperations</code>通过<code class="literal">performReadWriteTransaction</code>方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
SpannerOperations mySpannerOperations;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doWorkInsideTransaction() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> mySpannerOperations.performReadWriteTransaction(
    transActionSpannerOperations -&gt; {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Work with transActionSpannerOperations here.</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// It is also a SpannerOperations object.</span>

      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transaction completed"</span>;
    }
  );
}</pre><p>的<code class="literal">performReadWriteTransaction</code>方法接受<code class="literal">Function</code>提供了一个实例<code class="literal">SpannerOperations</code>宾语。函数的最终返回值和类型由用户确定。您可以像平常一样使用此对象<code class="literal">SpannerOperations</code>除少数例外：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">它的读取功能无法执行陈旧的读取，因为所有读取和写入都在事务的单个时间点进行。</li><li class="listitem">它无法通过进行子交易<code class="literal">performReadWriteTransaction</code>要么<code class="literal">performReadOnlyTransaction</code> 。</li></ul></div><p>由于这些读写事务正在锁定，因此建议您使用<code class="literal">performReadOnlyTransaction</code>如果您的函数不执行任何写操作。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_read_only_transaction" href="#_read_only_transaction"></a>只读交易</h4></div></div></div><p>的<code class="literal">performReadOnlyTransaction</code>方法用于使用<code class="literal">SpannerOperations</code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
SpannerOperations mySpannerOperations;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doWorkInsideTransaction() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> mySpannerOperations.performReadOnlyTransaction(
    transActionSpannerOperations -&gt; {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Work with transActionSpannerOperations here.</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// It is also a SpannerOperations object.</span>

      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transaction completed"</span>;
    }
  );
}</pre><p>的<code class="literal">performReadOnlyTransaction</code>方法接受<code class="literal">Function</code>提供了一个实例<code class="literal">SpannerOperations</code>宾语。此方法还接受<code class="literal">ReadOptions</code>对象，但唯一使用的属性是用于及时确定快照以在事务中执行读取的时间戳。如果未在读取选项中设置时间戳，则将针对数据库的当前状态运行事务。函数的最终返回值和类型由用户确定。您可以像平常一样使用此对象<code class="literal">SpannerOperations</code>除少数例外：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">它的读取功能无法执行陈旧的读取，因为所有读取都在事务的单个时间点发生。</li><li class="listitem">它无法通过进行子交易<code class="literal">performReadWriteTransaction</code>要么<code class="literal">performReadOnlyTransaction</code></li><li class="listitem">它无法执行任何写操作。</li></ul></div><p>由于只读事务是非锁定的，并且可以在过去的某个时间点执行，因此建议将这些事务用于不执行写操作的功能。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_declarative_transactions_with_transactional_annotation" href="#_declarative_transactions_with_transactional_annotation"></a>带有@Transactional批注的声明式事务</h4></div></div></div><p>此功能需要一个<code class="literal">SpannerTransactionManager</code> ，使用时提供<code class="literal">spring-cloud-gcp-starter-data-spanner</code> 。</p><p><code class="literal">SpannerTemplate</code>和<code class="literal">SpannerRepository</code>支持运行方法<code class="literal">@Transactional</code> [注释]（ <a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative" target="_top">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative</a> ）作为事务。如果方法带有注释<code class="literal">@Transactional</code>调用另一个也带有注释的方法，则这两个方法将在同一事务中工作。
<code class="literal">performReadOnlyTransaction</code>和<code class="literal">performReadWriteTransaction</code>不能用于<code class="literal">@Transactional</code>带注释的方法，因为Cloud Spanner不支持事务内的事务。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_dml_statements" href="#_dml_statements"></a> 161.3.7 DML语句</h3></div></div></div><p><code class="literal">SpannerTemplate</code>支持[DML]（ <a class="link" href="https://cloud.google.com/spanner/docs/dml-tasks" target="_top">https://cloud.google.com/spanner/docs/dml-tasks</a> ） <code class="literal">Statements</code> 。DML语句可以通过以下方式在事务中执行<code class="literal">performReadWriteTransaction</code>或使用<code class="literal">@Transactional</code>注解。</p><p>当DML语句在事务之外执行时，它们将以[partitioned-mode]（ <a class="link" href="https://cloud.google.com/spanner/docs/dml-tasks#partitioned-dml" target="_top">https://cloud.google.com/spanner/docs/dml-tasks#partitioned-dml</a> ）执行。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_repositories" href="#_repositories"></a> 161.4资料库</h2></div></div></div><p><a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories" target="_top">Spring数据存储库</a>是一个强大的抽象，可以节省许多样板代码。</p><p>例如：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TraderRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trader, String&gt; {
}</pre><p>Spring Data生成指定接口的有效实现，可以方便地将其自动连接到应用程序中。</p><p>的<code class="literal">Trader</code>输入参数<code class="literal">SpannerRepository</code>指基础域类型。第二类参数<code class="literal">String</code>在这种情况下，指的是域类型的键的类型。</p><p>对于具有复合主键的POJO，此ID类型参数可以是<code class="literal">Object[]</code>与所有主键属性兼容， <code class="literal">Iterable</code> ， 要么<code class="literal">com.google.cloud.spanner.Key</code> 。如果域POJO类型只有一个主键列，则可以使用主键属性类型或<code class="literal">Key</code>类型。</p><p>例如，对于属于交易者的交易， <code class="literal">TradeRepository</code>看起来像这样：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trade, String[]&gt; {

}</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyApplication {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	SpannerTemplate spannerTemplate;

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	StudentRepository studentRepository;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> demo() {

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tradeRepository.deleteAll();
		String traderId = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"demo_trader"</span>;
		Trade t = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Trade();
		t.symbol = stock;
		t.action = action;
		t.traderId = traderId;
		t.price = <span class="hl-number">100.0</span>;
		t.shares = <span class="hl-number">12345.6</span>;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.spannerTemplate.insert(t);

		Iterable&lt;Trade&gt; allTrades = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tradeRepository.findAll();

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> count = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tradeRepository.countByAction(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"BUY"</span>);

	}
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_crud_repository" href="#_crud_repository"></a> 161.4.1 CRUD存储库</h3></div></div></div><p><code class="literal">CrudRepository</code>方法可以按预期工作，而且Spanner特有一件事： <code class="literal">save</code>和<code class="literal">saveAll</code>方法作为更新或插入工作。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_paging_and_sorting_repository" href="#_paging_and_sorting_repository"></a> 161.4.2分页和排序存储库</h3></div></div></div><p>您也可以使用<code class="literal">PagingAndSortingRepository</code>使用Spanner Spring Data。排序和可分页<code class="literal">findAll</code>该接口上可用的方法在Spanner数据库的当前状态上运行。结果，当在页面之间移动时，请注意数据库的状态（和结果）可能会改变。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_spanner_repository" href="#_spanner_repository"></a> 161.4.3 Spanner存储库</h3></div></div></div><p>的<code class="literal">SpannerRepository</code>扩展<code class="literal">PagingAndSortingRepository</code> ，但添加了Spanner提供的只读和读写事务功能。这些交易与<code class="literal">SpannerOperations</code> ，但特定于存储库的域类型，并提供存储库功能而不是模板功能。</p><p>例如，这是一个读写事务：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
SpannerRepository myRepo;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doWorkInsideTransaction() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> myRepo.performReadOnlyTransaction(
    transactionSpannerRepo -&gt; {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Work with the single-transaction transactionSpannerRepo here.</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// This is a SpannerRepository object.</span>

      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transaction completed"</span>;
    }
  );
}</pre><p>在为自己的域类型和查询方法创建自定义存储库时，可以扩展<code class="literal">SpannerRepository</code>访问特定于Cloud Spanner的功能以及来自的所有功能<code class="literal">PagingAndSortingRepository</code>和<code class="literal">CrudRepository</code> 。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_query_methods" href="#_query_methods"></a> 161.5查询方法</h2></div></div></div><p><code class="literal">SpannerRepository</code>支持查询方法。在以下各节中将介绍这些方法，这些方法位于您的自定义存储库接口中，这些接口的实现是根据其名称和注释生成的。查询方法可以读取，写入和删除Cloud Spanner中的实体。这些方法的参数可以是直接支持或通过自定义配置的转换器支持的任何Cloud Spanner数据类型。参数也可以是类型<code class="literal">Struct</code>或POJO。如果给定一个POJO作为参数，它将被转换为<code class="literal">Struct</code>具有与用于创建写入突变的类型转换逻辑相同的类型。使用Struct参数进行的比较仅限于<a class="link" href="https://cloud.google.com/spanner/docs/data-types#limited-comparisons-for-struct" target="_top">Cloud Spanner可用的</a>参数。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_query_methods_by_convention" href="#_query_methods_by_convention"></a> 161.5.1按约定查询方法</h3></div></div></div><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trade, String[]&gt; {
    List&lt;Trade&gt; findByAction(String action);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> countByAction(String action);

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Named methods are powerful, but can get unwieldy</span>
	List&lt;Trade&gt; findTop3DistinctByActionAndSymbolIgnoreCaseOrTraderIdOrderBySymbolDesc(
  			String action, String symbol, String traderId);
}</pre><p>在上面的示例中， <a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods" target="_top">查询方法</a> <code class="literal">TradeRepository</code>使用<a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html#repositories.query-methods.query-creation" target="_top">Spring Data Query创建命名约定</a>基于方法的名称生成。</p><p><code class="literal">List<Trade> findByAction(String action)</code>会翻译成<code class="literal">SELECT * FROM trades WHERE action = ?</code> 。</p><p>功能<code class="literal">List<Trade> findTop3DistinctByActionAndSymbolIgnoreCaseOrTraderIdOrderBySymbolDesc(String action, String symbol, String traderId);</code>将被翻译为等效于以下SQL查询：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">SELECT</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">DISTINCT</span> * <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">FROM</span> trades
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">WHERE</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">ACTION</span> = ? <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">AND</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">LOWER</span>(SYMBOL) = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">LOWER</span>(?) <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">AND</span> TRADER_ID = ?
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">ORDER</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">BY</span> SYMBOL <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">DESC</span>
LIMIT <span class="hl-number">3</span></pre><p>支持以下过滤器选项：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">平等</li><li class="listitem">大于或等于</li><li class="listitem">比...更棒</li><li class="listitem">小于或等于</li><li class="listitem">少于</li><li class="listitem">一片空白</li><li class="listitem">不为空</li><li class="listitem">是真的</li><li class="listitem">是假的</li><li class="listitem">像弦一样</li><li class="listitem">不像字符串</li><li class="listitem">包含一个字符串</li><li class="listitem">不包含字符串</li></ul></div><p>注意这句话<code class="literal">SymbolIgnoreCase</code>被翻译成<code class="literal">LOWER(SYMBOL) = LOWER(?)</code>表示不区分大小写的匹配。的<code class="literal">IgnoreCase</code>词组只能附加到与STRING或BYTES类型的列相对应的字段中。不支持在方法名称末尾附加的Spring Data“ AllIgnoreCase”短语。</p><p>的<code class="literal">Like</code>要么<code class="literal">NotLike</code>命名约定：</p><pre class="programlisting">List&lt;Trade&gt; findBySymbolLike(String symbolFragment);</pre><p>参数<code class="literal">symbolFragment</code>可以包含用于字符串匹配的<a class="link" href="https://cloud.google.com/spanner/docs/functions-and-operators#comparison-operators" target="_top">通配符</a> ，例如<code class="literal">_</code>和<code class="literal">%</code> 。</p><p>的<code class="literal">Contains</code>和<code class="literal">NotContains</code>命名约定：</p><pre class="programlisting">List&lt;Trade&gt; findBySymbolContains(String symbolFragment);</pre><p>参数<code class="literal">symbolFragment</code>是一个检查是否出现的<a class="link" href="https://cloud.google.com/spanner/docs/functions-and-operators#regexp_contains" target="_top">正则表达式</a> 。</p><p>还支持删除查询。例如，查询方法如<code class="literal">deleteByAction</code>要么<code class="literal">removeByAction</code>删除由发现的实体<code class="literal">findByAction</code> 。删除操作发生在单个事务中。</p><p>删除查询可以具有以下返回类型：*整数类型，它是删除的实体数*删除的实体的集合*<code class="literal">void</code></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_sqldml_query_methods" href="#_custom_sqldml_query_methods"></a> 161.5.2自定义SQL / DML查询方法</h3></div></div></div><p>上面的示例<code class="literal">List<Trade> fetchByActionNamedQuery(String action)</code>与<a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html#repositories.query-methods.query-creation" target="_top">Spring Data Query创建命名约定</a>不匹配，因此我们必须为其映射参数化的Spanner SQL查询。</p><p>可以通过以下两种方式之一将方法的SQL查询映射到存储库方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">namedQueries</code>属性文件</li><li class="listitem">使用<code class="literal">@Query</code>注解</li></ul></div><p>SQL标记的名称对应于<code class="literal">@Param</code>方法参数的带注释的名称。</p><p>自定义SQL查询方法可以接受单个<code class="literal">Sort</code>要么<code class="literal">Pageable</code>在SQL中的任何排序或分页之上应用的参数：</p><pre class="programlisting">	<em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM trades ORDER BY action DESC")</span></em>
	List&lt;Trade&gt; sortedTrades(Pageable pageable);

	<em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM trades ORDER BY action DESC LIMIT 1")</span></em>
 	Trade sortedTopTrade(Pageable pageable);</pre><p>可以使用：</p><pre class="programlisting">	List&lt;Trade&gt; customSortedTrades = tradeRepository.sortedTrades(PageRequest
  				.of(<span class="hl-number">2</span>, <span class="hl-number">2</span>, org.springframework.data.domain.Sort.by(Order.asc(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>))));</pre><p>结果将按“ id”以升序排序。</p><p>您的查询方法还可以返回非实体类型：</p><pre class="programlisting">  	<em><span class="hl-annotation" style="color: gray">@Query("SELECT COUNT(1) FROM trades WHERE action = @action")</span></em>
  	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> countByActionQuery(String action);

  	<em><span class="hl-annotation" style="color: gray">@Query("SELECT EXISTS(SELECT COUNT(1) FROM trades WHERE action = @action)")</span></em>
  	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> existsByActionQuery(String action);

  	<em><span class="hl-annotation" style="color: gray">@Query("SELECT action FROM trades WHERE action = @action LIMIT 1")</span></em>
  	String getFirstString(<em><span class="hl-annotation" style="color: gray">@Param("action")</span></em> String action);

  	<em><span class="hl-annotation" style="color: gray">@Query("SELECT action FROM trades WHERE action = @action")</span></em>
  	List&lt;String&gt; getFirstStringList(<em><span class="hl-annotation" style="color: gray">@Param("action")</span></em> String action);</pre><p>DML语句也可以通过查询方法执行，但是唯一可能的返回值是<code class="literal">long</code>表示受影响的行数。的<code class="literal">dmlStatement</code>布尔设置必须设置为<code class="literal">@Query</code>指示查询方法作为DML语句执行。</p><pre class="programlisting">  	<em><span class="hl-annotation" style="color: gray">@Query(value = "DELETE FROM trades WHERE action = @action", dmlStatement = true)</span></em>
  	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> deleteByActionQuery(String action);</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_query_methods_with_named_queries_properties" href="#_query_methods_with_named_queries_properties"></a>具有命名查询属性的查询方法</h4></div></div></div><p>默认情况下， <code class="literal">namedQueriesLocation</code>归因于<code class="literal">@EnableSpannerRepositories</code>指向<code class="literal">META-INF/spanner-named-queries.properties</code>文件。通过提供SQL作为“ interface.method”属性的值，可以在属性文件中指定对方法的查询：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">Trade.fetchByActionNamedQuery</span>=SELECT * FROM trades WHERE trades.action = @tag0</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trade, String[]&gt; {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// This method uses the query from the properties file instead of one generated based on name.</span>
	List&lt;Trade&gt; fetchByActionNamedQuery(<em><span class="hl-annotation" style="color: gray">@Param("tag0")</span></em> String action);
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_query_methods_with_annotation" href="#_query_methods_with_annotation"></a>带注释的查询方法</h4></div></div></div><p>使用<code class="literal">@Query</code>注解：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trade, String[]&gt; {
    <em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM trades WHERE trades.action = @tag0")</span></em>
    List&lt;Trade&gt; fetchByActionNamedQuery(<em><span class="hl-annotation" style="color: gray">@Param("tag0")</span></em> String action);
}</pre><p>表名可以直接使用。例如，以上示例中的“交易”。或者，可以通过<code class="literal">@Table</code>域类上的注释也是如此。在这种情况下，查询应引用具有完全限定的类名之间的表名<code class="literal">:</code>字符： <code class="literal">:fully.qualified.ClassName:</code> 。完整的示例如下所示：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM :com.example.Trade: WHERE trades.action = @tag0")</span></em>
List&lt;Trade&gt; fetchByActionNamedQuery(String action);</pre><p>这允许在自定义查询中使用通过SpEL评估的表名。</p><p>SpEL还可以用于提供SQL参数：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM :com.example.Trade: WHERE trades.action = @tag0
  AND price &gt; #{#priceRadius * -1} AND price &lt; #{#priceRadius * 2}")</span></em>
List&lt;Trade&gt; fetchByActionNamedQuery(String action, Double priceRadius);</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_projections" href="#_projections"></a> 161.5.3投影</h3></div></div></div><p>Spring Data Spanner支持<a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#projections" target="_top">投影</a> 。您可以根据域类型定义投影接口，并添加查询方法以在存储库中返回它们：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeProjection {

	String getAction();

	<em><span class="hl-annotation" style="color: gray">@Value("#{target.symbol + ' ' + target.action}")</span></em>
	String getSymbolAndAction();
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trade, Key&gt; {

	List&lt;Trade&gt; findByTraderId(String traderId);

	List&lt;TradeProjection&gt; findByAction(String action);

	<em><span class="hl-annotation" style="color: gray">@Query("SELECT action, symbol FROM trades WHERE action = @action")</span></em>
	List&lt;TradeProjection&gt; findByQuery(String action);
}</pre><p>可以通过基于名称约定的查询方法以及自定义SQL查询来提供投影。如果使用自定义SQL查询，则可以进一步限制从Spanner检索的列，使其仅限于投影所需的列，以提高性能。</p><p>使用SpEL定义的投影类型的属性使用固定名称<code class="literal">target</code>用于基础域对象。结果，访问基础属性采用以下形式： <code class="literal">target.<property-name></code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rest_repositories" href="#_rest_repositories"></a> 161.5.4 REST存储库</h3></div></div></div><p>使用Spring Boot运行时，只需将以下依赖项添加到pom文件中，即可将存储库作为REST服务公开：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-data-rest<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>如果您希望配置参数（例如路径），则可以使用<code class="literal">@RepositoryRestResource</code>注解：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RepositoryRestResource(collectionResourceRel = "trades", path = "trades")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerRepository&lt;Trade, String[]&gt; {
}</pre><p>例如，您可以检索所有<code class="literal">Trade</code>通过使用存储库中的对象<code class="literal">curl http://<server>:<port>/trades</code> ，或通过<code class="literal">curl http://<server>:<port>/trades/<trader_id>,<trade_id></code> 。</p><p>主键组件之间的分隔符， <code class="literal">id</code>和<code class="literal">trader_id</code>在这种情况下，默认情况下是逗号，但可以通过扩展键将其配置为在键值中找不到的任何字符串<code class="literal">SpannerKeyIdConverter</code>类：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Component</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MySpecialIdConverter <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> SpannerKeyIdConverter {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">protected</span> String getUrlIdSeparator() {
        <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">":"</span>;
    }
}</pre><p>您也可以使用<code class="literal">curl -XPOST -H"Content-Type: application/json" -<a class="link" href="mailto:d@test.json" target="_top">d@test.json</a> http://<server>:<port>/trades/</code>文件在哪里<code class="literal">test.json</code>持有的JSON表示形式<code class="literal">Trade</code>宾语。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_database_and_schema_admin" href="#_database_and_schema_admin"></a> 161.6数据库和架构管理</h2></div></div></div><p>Spanner实例中的数据库和表可以从以下位置自动创建<code class="literal">SpannerPersistentEntity</code>对象：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> SpannerSchemaUtils spannerSchemaUtils;

<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> SpannerDatabaseAdminTemplate spannerDatabaseAdminTemplate;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> createTable(SpannerPersistentEntity entity) {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span>(!spannerDatabaseAdminTemplate.tableExists(entity.tableName()){

	  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// The boolean parameter indicates that the database will be created if it does not exist.</span>
	  spannerDatabaseAdminTemplate.executeDdlStrings(Arrays.asList(
            spannerSchemaUtils.getCreateTableDDLString(entity.getType())), true);
	}
}</pre><p>可以为具有交错关系和组合键的整个对象层次结构生成模式。</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_9" href="#_sample_9"></a> 161.7样本</h2></div></div></div><p>提供了<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-data-spanner-sample" target="_top">示例应用程序</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_spring_data_cloud_datastore" href="#_spring_data_cloud_datastore"></a> 162。Spring Data Cloud数据存储</h2></div></div></div><p><a class="link" href="https://projects.spring.io/spring-data/" target="_top">Spring Data</a>是用于以多种存储技术存储和检索POJO的抽象。Spring Cloud GCP增加了对<a class="link" href="https://cloud.google.com/datastore/" target="_top">Google Cloud Datastore的</a> Spring Data支持。</p><p>Maven仅使用<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/blob/master/spring-cloud-gcp-dependencies/pom.xml" target="_top">Spring Cloud GCP BOM</a>协调此模块：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-data-datastore<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-data-datastore'
}</pre><p>我们<a class="link" href="../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-datastore" target="_top">为Spring Data Datastore</a>提供了一个<a class="link" href="../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-datastore" target="_top">Spring Boot Starter</a> ，您可以使用它使用我们推荐的自动配置设置。要使用启动器，请参见以下坐标。</p><p>Maven：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-data-datastore<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-data-datastore'
}</pre><p>此设置还负责引入Cloud Java Cloud Datastore库的最新兼容版本。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_7" href="#_configuration_7"></a> 162.1配置</h2></div></div></div><p>要设置Spring Data Cloud Datastore，您必须配置以下内容：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">设置与Google Cloud Datastore的连接详细信息。</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_cloud_datastore_settings" href="#_cloud_datastore_settings"></a> 162.1.1 Cloud Datastore设置</h3></div></div></div><p>您可以使用<a class="link" href="../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-datastore" target="_top">Spring Boot Starter for Spring Data</a> Datastore在Spring应用程序中自动配置Google Cloud Datastore。它包含所有必要的设置，使您可以轻松地通过Google Cloud项目进行身份验证。以下配置选项可用：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>描述</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>需要</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.datastore.enabled</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用Cloud Datastore客户端</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.datastore.project-id</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>托管Google Cloud Datastore API的GCP项目ID（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP Core Module中的</a> ID不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.datastore.credentials.location</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于与Google Cloud Datastore API进行身份验证的OAuth2凭证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a>凭证不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.datastore.credentials.encoded-key</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于与Google Cloud Datastore API进行身份验证的Base64编码的OAuth2凭证（如果与<a class="link" href="#spring-cloud-gcp-core" title="152。Spring Cloud GCP核心">Spring Cloud GCP核心模块中的</a>凭证不同）</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.datastore.credentials.scopes</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">适用</a>于Spring Cloud GCP Cloud Datastore凭证的<a class="link" href="https://developers.google.com/identity/protocols/googlescopes" target="_top">OAuth2范围</a></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><a class="link" href="https://www.googleapis.com/auth/datastore" target="_top">https://www.googleapis.com/auth/datastore</a></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.datastore.namespace</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>要使用的Cloud Datastore命名空间</p></td><td align="left" valign="top" style="border-right:1px solid"><p>没有</p></td><td align="left" valign="top"><p>GCP项目中Cloud Datastore的默认名称空间</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_repository_settings_2" href="#_repository_settings_2"></a> 162.1.2存储库设置</h3></div></div></div><p>可以通过以下方式配置Spring Data Repository <code class="literal">@EnableDatastoreRepositories</code>主标注<code class="literal">@Configuration</code>类。借助我们用于Spring Data Cloud Datastore的Spring Boot Starter， <code class="literal">@EnableDatastoreRepositories</code>自动添加。不需要将其添加到其他任何类中，除非需要覆盖由<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/blob/master/spring-cloud-gcp-data-datastore/src/main/java/org/springframework/cloud/gcp/data/datastore/repository/config/EnableDatastoreRepositories.java" target="_top"><code class="literal">@EnableDatastoreRepositories</code></a> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_autoconfiguration_2" href="#_autoconfiguration_2"></a> 162.1.3自动配置</h3></div></div></div><p>我们的Spring Boot自动配置会在Spring应用程序上下文中创建以下可用的bean：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">的实例<code class="literal">DatastoreTemplate</code></li><li class="listitem">所有用户定义的存储库扩展的实例<code class="literal">CrudRepository</code> ， <code class="literal">PagingAndSortingRepository</code>和<code class="literal">DatastoreRepository</code> （的扩展<code class="literal">PagingAndSortingRepository</code>启用存储库时，具有其他Cloud Datastore功能）</li><li class="listitem">的实例<code class="literal">Datastore</code>从Google Cloud Java客户端（用于数据存储）中获取，以方便使用和较低级别的API访问</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_object_mapping_2" href="#_object_mapping_2"></a> 162.2对象映射</h2></div></div></div><p>Spring Data Cloud Datastore允许您通过注释将域POJO映射到Cloud Datastore的种类和实体：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Entity(name = "traders")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trader {

	<em><span class="hl-annotation" style="color: gray">@Id</span></em>
	<em><span class="hl-annotation" style="color: gray">@Field(name = "trader_id")</span></em>
	String traderId;

	String firstName;

	String lastName;

	<em><span class="hl-annotation" style="color: gray">@Transient</span></em>
	Double temporaryNumber;
}</pre><p>Spring Data Cloud Datastore将忽略任何带有注释的属性<code class="literal">@Transient</code> 。这些属性将不会写入或从Cloud Datastore中读取。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_constructors_2" href="#_constructors_2"></a> 162.2.1构造函数</h3></div></div></div><p>POJO支持简单的构造函数。构造函数参数可以是持久属性的子集。每个构造函数参数都必须具有与实体上的持久属性相同的名称和类型，构造函数应从给定参数设置属性。不支持未直接设置为属性的参数。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Entity(name = "traders")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trader {

	<em><span class="hl-annotation" style="color: gray">@Id</span></em>
	<em><span class="hl-annotation" style="color: gray">@Field(name = "trader_id")</span></em>
	String traderId;

	String firstName;

	String lastName;

	<em><span class="hl-annotation" style="color: gray">@Transient</span></em>
	Double temporaryNumber;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Trader(String traderId, String firstName) {
	    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.traderId = traderId;
	    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.firstName = firstName;
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_kind" href="#_kind"></a> 162.2.2种类</h3></div></div></div><p>的<code class="literal">@Entity</code>注释可以提供Cloud Datastore类型的名称，该类型存储带注释的类的实例，每行一个。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_keys" href="#_keys"></a> 162.2.3键</h3></div></div></div><p><code class="literal">@Id</code>标识与ID值相对应的属性。</p><p>您必须将POJO字段之一注释为ID值，因为Cloud Datastore中的每个实体都需要一个ID值：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Entity(name = "trades")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Trade {
	<em><span class="hl-annotation" style="color: gray">@Id</span></em>
	<em><span class="hl-annotation" style="color: gray">@Field(name = "trade_id")</span></em>
	String tradeId;

	<em><span class="hl-annotation" style="color: gray">@Field(name = "trader_id")</span></em>
	String traderId;

	String action;

	Double price;

	Double shares;

	String symbol;
}</pre><p>数据存储区可以自动分配整数ID值。如果POJO实例具有<code class="literal">Long</code> ID属性通过以下方式写入Cloud Datastore： <code class="literal">null</code>作为ID值，Spring Data Cloud Datastore将从Cloud Datastore获取新分配的ID值，并将其设置在POJO中进行保存。因为原始<code class="literal">long</code> ID属性不能是<code class="literal">null</code>并默认为<code class="literal">0</code> ，则不会分配密钥。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_fields" href="#_fields"></a> 162.2.4字段</h3></div></div></div><p>POJO上的所有可访问属性都将自动识别为Cloud Datastore字段。字段命名是由<code class="literal">PropertyNameFieldNamingStrategy</code>默认情况下在<code class="literal">DatastoreMappingContext</code> bean 。的<code class="literal">@Field</code>注释可以选择提供与属性不同的字段名称。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_supported_types_2" href="#_supported_types_2"></a> 162.2.5支持的类型</h3></div></div></div><p>Spring Data Cloud Datastore支持常规字段和集合元素的以下类型：</p><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">类型</th><th align="left" valign="top" style="border-bottom:1px solid">储存为</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">com.google.cloud.Timestamp</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。时间戳值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">com.google.cloud.datastore.Blob</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。BlobValue</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">com.google.cloud.datastore.LatLng</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。LatLngValue</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">java.lang.Boolean</code> ，<code class="literal">boolean</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。布尔值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">java.lang.Double</code> ，<code class="literal">double</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。双重价值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">java.lang.Long</code> ，<code class="literal">long</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。长值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">java.lang.Integer</code> ，<code class="literal">int</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。长值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">java.lang.String</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。字符串值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">com.google.cloud.datastore.Entity</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。实体值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">com.google.cloud.datastore.Key</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。核心价值</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">byte[]</code></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>com.google.cloud.datastore。BlobValue</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>爪哇<code class="literal">enum</code>价值观</p></td><td align="left" valign="top"><p>com.google.cloud.datastore。字符串值</p></td></tr></tbody></table></div><p>此外，所有类型都可以通过以下方式转换为表中列出的类型<code class="literal">org.springframework.core.convert.support.DefaultConversionService</code>支持。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_types_2" href="#_custom_types_2"></a> 162.2.6自定义类型</h3></div></div></div><p>可以使用自定义转换器来扩展对用户定义类型的类型支持。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">转换器需要实施<code class="literal">org.springframework.core.convert.converter.Converter</code>双向接口。</li><li class="listitem">用户定义的类型需要映射到Cloud Datastore支持的基本类型之一。</li><li class="listitem">这两个Converter（读和写）的实例都需要传递给<code class="literal">DatastoreCustomConversions</code>构造函数，然后必须将其作为<code class="literal">@Bean</code>对于<code class="literal">DatastoreCustomConversions</code> 。</li></ol></div><p>例如：</p><p>我们希望有一个类型的字段<code class="literal">Album</code>在我们的<code class="literal">Singer</code> POJO并希望将其存储为字符串属性：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Singer {

	<em><span class="hl-annotation" style="color: gray">@Id</span></em>
	String singerId;

	String name;

	Album album;
}</pre><p>其中Album是一个简单的类：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Album {
	String albumName;

	LocalDate date;
}</pre><p>我们必须定义两个转换器：</p><pre class="programlisting">	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Converter to write custom Album type</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Converter&lt;Album, String&gt; ALBUM_STRING_CONVERTER =
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Converter&lt;Album, String&gt;() {
				<em><span class="hl-annotation" style="color: gray">@Override</span></em>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String convert(Album album) {
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> album.getAlbumName() + <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" "</span> + album.getDate().format(DateTimeFormatter.ISO_DATE);
				}
			};

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//Converters to read custom Album type</span>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Converter&lt;String, Album&gt; STRING_ALBUM_CONVERTER =
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Converter&lt;String, Album&gt;() {
				<em><span class="hl-annotation" style="color: gray">@Override</span></em>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> Album convert(String s) {
					String[] parts = s.split(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">" "</span>);
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Album(parts[<span class="hl-number">0</span>], LocalDate.parse(parts[parts.length - <span class="hl-number">1</span>], DateTimeFormatter.ISO_DATE));
				}
			};</pre><p>这将在我们的配置<code class="literal">@Configuration</code>文件：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ConverterConfiguration {
	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> DatastoreCustomConversions datastoreCustomConversions() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> DatastoreCustomConversions(
				Arrays.asList(
						ALBUM_STRING_CONVERTER,
						STRING_ALBUM_CONVERTER));
	}
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_collections_and_arrays" href="#_collections_and_arrays"></a> 162.2.7集合和数组</h3></div></div></div><p>数组和集合（实现的类型<code class="literal">java.util.Collection</code> ）支持的类型。它们存储为<code class="literal">com.google.cloud.datastore.ListValue</code> 。元素分别转换为Cloud Datastore支持的类型。 <code class="literal">byte[]</code>是一个例外，它将转换为<code class="literal">com.google.cloud.datastore.Blob</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_converter_for_collections" href="#_custom_converter_for_collections"></a> 162.2.8自定义转换器的集合</h3></div></div></div><p>用户可以从提供转换器<code class="literal">List<?></code>到自定义集合类型。仅需要读取转换器，在写端使用Collection API将集合转换为内部列表类型。</p><p>集合转换器需要实现<code class="literal">org.springframework.core.convert.converter.Converter</code>接口。</p><p>例：</p><p>让我们从前面的示例中改进Singer类。代替类型的字段<code class="literal">Album</code> ，我们希望有一个类型的字段<code class="literal">ImmutableSet<Album></code> ：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Singer {

	<em><span class="hl-annotation" style="color: gray">@Id</span></em>
	String singerId;

	String name;

	ImmutableSet&lt;Album&gt; albums;
}</pre><p>我们只需要定义一个读转换器：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">static</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">final</span> Converter&lt;List&lt;?&gt;, ImmutableSet&lt;?&gt;&gt; LIST_IMMUTABLE_SET_CONVERTER =
			<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Converter&lt;List&lt;?&gt;, ImmutableSet&lt;?&gt;&gt;() {
				<em><span class="hl-annotation" style="color: gray">@Override</span></em>
				<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> ImmutableSet&lt;?&gt; convert(List&lt;?&gt; source) {
					<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> ImmutableSet.copyOf(source);
				}
			};</pre><p>并将其添加到自定义转换器列表中：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Configuration</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ConverterConfiguration {
	<em><span class="hl-annotation" style="color: gray">@Bean</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> DatastoreCustomConversions datastoreCustomConversions() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> DatastoreCustomConversions(
				Arrays.asList(
						LIST_IMMUTABLE_SET_CONVERTER,

						ALBUM_STRING_CONVERTER,
						STRING_ALBUM_CONVERTER));
	}
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_relationships_2" href="#_relationships_2"></a> 162.3关系</h2></div></div></div><p>本节介绍了三种表示实体之间关系的方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">直接在包含实体的字段中存储的嵌入式实体</li><li class="listitem"><code class="literal">@Descendant</code>一对多关系的带注释的属性</li><li class="listitem"><code class="literal">@Reference</code>不带层次结构的一般关系的带注释的属性</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_embedded_entities" href="#_embedded_entities"></a> 162.3.1嵌入式实体</h3></div></div></div><p>类型也用注释的字段<code class="literal">@Entity</code>转换为<code class="literal">EntityValue</code>并存储在父实体中。</p><p>这是一个Cloud Datastore实体示例，其中包含JSON中的嵌入式实体：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">{</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Alexander"</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"age"</span> : <span class="hl-number">47</span><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">,</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"child"</span> : {<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"name"</span> : <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Philip"</span>  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">}</span></pre><p>这对应于一对简单的Java实体：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Entity;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.data.annotation.Id;

<em><span class="hl-annotation" style="color: gray">@Entity("parents")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Parent {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  String name;

  Child child;
}

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Child {
  String name;
}</pre><p><code class="literal">Child</code>实体不是以它们自己的类型存储的。它们全部存储在<code class="literal">child</code>的领域<code class="literal">parents</code>类。</p><p>支持多个级别的嵌入式实体。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>嵌入式实体不需要<code class="literal">@Id</code>字段，只有顶级实体才需要。</p></td></tr></tbody></table></div><p>例：</p><p>实体可以保存自己类型的嵌入式实体。我们可以使用此功能将树存储在Cloud Datastore中：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Embedded;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Entity;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.data.annotation.Id;

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> EmbeddableTreeNode {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> value;

  EmbeddableTreeNode left;

  EmbeddableTreeNode right;

  Map&lt;String, Long&gt; longValues;

  Map&lt;String, List&lt;Timestamp&gt;&gt; listTimestamps;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> EmbeddableTreeNode(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> value, EmbeddableTreeNode left, EmbeddableTreeNode right) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.value = value;
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.left = left;
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.right = right;
  }
}</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_maps" href="#_maps"></a>地图</h4></div></div></div><p>地图将存储为嵌入式实体，其中键值成为嵌入式实体中的字段名称。这些映射中的值类型可以是任何常规支持的属性类型，并且将使用配置的转换器将键值转换为String。</p><p>另外，可以嵌入实体的集合。它将被转换为<code class="literal">ListValue</code>在写。</p><p>例：</p><p>代替上一个示例中的二叉树，我们想在Cloud Datastore中存储一棵普通树（每个节点可以有任意数量的子代）。为此，我们需要创建一个类型为<code class="literal">List<EmbeddableTreeNode></code> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Embedded;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.data.annotation.Id;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> EmbeddableTreeNode {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> value;

  List&lt;EmbeddableTreeNode&gt; children;

  Map&lt;String, EmbeddableTreeNode&gt; siblingNodes;

  Map&lt;String, Set&lt;EmbeddableTreeNode&gt;&gt; subNodeGroups;

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> EmbeddableTreeNode(List&lt;EmbeddableTreeNode&gt; children) {
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.children = children;
  }
}</pre><p>由于地图是作为实体存储的，因此它们可以进一步包含嵌入式实体：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">值中的单个嵌入式对象可以存储在嵌入式Map的值中。</li><li class="listitem">值中嵌入对象的集合也可以存储为嵌入Map的值。</li><li class="listitem">值中的映射进一步存储为嵌入式实体，并对其值进行递归应用相同的规则。</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_ancestor_descendant_relationships" href="#_ancestor_descendant_relationships"></a> 162.3.2祖辈关系</h3></div></div></div><p>亲子关系通过<code class="literal">@Descendants</code>注解。</p><p>与嵌入式子代不同，后代是驻留在自己种类中的完整实体。父实体没有额外的字段来保存后代实体。相反，该关系是在后代的键中捕获的，该键引用了它们的父实体：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Descendants;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Entity;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.data.annotation.Id;

<em><span class="hl-annotation" style="color: gray">@Entity("orders")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ShoppingOrder {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id;

  <em><span class="hl-annotation" style="color: gray">@Descendants</span></em>
  List&lt;Item&gt; items;
}

<em><span class="hl-annotation" style="color: gray">@Entity("purchased_item")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Item {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  Key purchasedItemKey;

  String name;

  Timestamp timeAddedToOrder;
}</pre><p>例如，针对的GQL键文字表示形式的实例<code class="literal">Item</code>还将包含父项<code class="literal">ShoppingOrder</code> ID值：</p><pre class="screen">Key(orders, '12345', purchased_item, 'eggs')</pre><p>父级的GQL键字代表形式<code class="literal">ShoppingOrder</code>将会：</p><pre class="screen">Key(orders, '12345')</pre><p>Cloud Datastore实体以各自的种类单独存在。</p><p>的<code class="literal">ShoppingOrder</code> ：</p><pre class="screen">{
  "id" : 12345
}</pre><p>该订单中的两项：</p><pre class="screen">{
  "purchasedItemKey" : Key(orders, '12345', purchased_item, 'eggs'),
  "name" : "eggs",
  "timeAddedToOrder" : "2014-09-27 12:30:00.45-8:00"
}

{
  "purchasedItemKey" : Key(orders, '12345', purchased_item, 'sausage'),
  "name" : "sausage",
  "timeAddedToOrder" : "2014-09-28 11:30:00.45-9:00"
}</pre><p>使用Datastore的<a class="link" href="https://cloud.google.com/datastore/docs/concepts/entities#ancestor_paths" target="_top">祖先关系</a>将对象的父子关系结构存储在Cloud Datastore中。因为这些关系是由Ancestor机制定义的，所以父实体或子实体中都不需要额外的列来存储此关系。关系链接是后代实体键值的一部分。这些关系可能有很多层次。</p><p>拥有子实体的属性必须类似于集合，但是它们可以是常规属性（例如， <code class="literal">List</code> ，数组， <code class="literal">Set</code>等等...子项必须具有<code class="literal">Key</code>作为其ID类型，因为Cloud Datastore将祖先关系链接存储在子代键的内部。</p><p>读取或保存实体会自动导致分别读取或保存该实体下的所有后续子级。如果创建了一个新的孩子并将其添加到带注释的属性中<code class="literal">@Descendants</code>并且key属性保留为null，则将为该孩子分配一个新的钥匙。检索到的子代的顺序可能与保存的原始属性中的顺序不同。</p><p>子实体不能从一个父实体的属性移动到另一父实体的属性，除非该子实体的key属性设置为<code class="literal">null</code>或包含新父母作为祖先的值。由于Cloud Datastore实体键可以有多个父实体，因此子实体可能出现在多个父实体的属性中。由于实体密钥在Cloud Datastore中是不可变的，因此要更改子项的密钥，您必须删除现有的子项并用新密钥重新保存。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_key_reference_relationships" href="#_key_reference_relationships"></a> 162.3.3主要参考关系</h3></div></div></div><p>一般关系可以使用<code class="literal">@Reference</code>注解。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Reference;
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.data.annotation.Id;

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ShoppingOrder {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id;

  <em><span class="hl-annotation" style="color: gray">@Reference</span></em>
  List&lt;Item&gt; items;

  <em><span class="hl-annotation" style="color: gray">@Reference</span></em>
  Item specialSingleItem;
}

<em><span class="hl-annotation" style="color: gray">@Entity</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> Item {
  <em><span class="hl-annotation" style="color: gray">@Id</span></em>
  Key purchasedItemKey;

  String name;

  Timestamp timeAddedToOrder;
}</pre><p><code class="literal">@Reference</code>关系是存在于自己种类中的完整实体之间的关系。之间的关系<code class="literal">ShoppingOrder</code>和<code class="literal">Item</code>实体存储为内部的Key字段<code class="literal">ShoppingOrder</code> ，由Spring Data Cloud Datastore解析为基础Java实体类型：</p><pre class="screen">{
  "id" : 12345,
  "specialSingleItem" : Key(item, "milk"),
  "items" : [ Key(item, "eggs"), Key(item, "sausage") ]
}</pre><p>参考属性可以是单数或类似集合的。这些属性对应于实体和Cloud Datastore Kind中包含引用实体的键值的实际列。引用的实体是其他种类的成熟实体。</p><p>类似于<code class="literal">@Descendants</code>关系，读取或写入实体将在所有级别上递归读取或写入所有引用的实体。如果引用的实体有<code class="literal">null</code> ID值，然后它们将另存为新实体，并具有由Cloud Datastore分配的ID值。实体的密钥和实体作为引用持有的密钥之间没有关系的要求。从Cloud Datastore读回时，不会保留类似集合的参考属性的顺序。</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_datastore_operations_template" href="#_datastore_operations_template"></a> 162.4数据存储操作和模板</h2></div></div></div><p><code class="literal">DatastoreOperations</code>及其实施， <code class="literal">DatastoreTemplate</code> ，提供了Spring开发人员熟悉的Template模式。</p><p>使用Spring Boot Starter for Datastore提供的自动配置，您的Spring应用程序上下文将包含一个完全配置的<code class="literal">DatastoreTemplate</code>您可以在应用程序中自动连线的对象：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@SpringBootApplication</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> DatastoreTemplateExample {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	DatastoreTemplate datastoreTemplate;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> doSomething() {
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.datastoreTemplate.deleteAll(Trader.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		Trader t = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Trader();
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.datastoreTemplate.save(t);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
		List&lt;Trader&gt; traders = datastoreTemplate.findAll(Trader.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//...</span>
	}
}</pre><p>模板API提供了以下便捷方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">写操作（保存和删除）</li><li class="listitem">读写交易</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gql_query" href="#_gql_query"></a> 162.4.1 GQL查询</h3></div></div></div><p>除了通过ID检索实体之外，您还可以提交查询。</p><pre class="programlisting">  &lt;T&gt; Iterable&lt;T&gt; query(Query&lt;? <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> BaseEntity&gt; query, Class&lt;T&gt; entityClass);

  &lt;A, T&gt; Iterable&lt;T&gt; query(Query&lt;A&gt; query, Function&lt;A, T&gt; entityFunc);

  Iterable&lt;Key&gt; queryKeys(Query&lt;Key&gt; query);</pre><p>这些方法分别允许查询：*使用所有相同的映射和转换功能由给定实体类映射的实体*给定映射函数产生的任意类型*仅查询找到的实体的Cloud Datastore键</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_find_by_ids" href="#_find_by_ids"></a> 162.4.2按ID查找</h3></div></div></div><p>Datstore读取一种类型的单个实体或多个实体。</p><p>使用<code class="literal">DatastoreTemplate</code>您可以执行读取，例如：</p><pre class="programlisting">Trader trader = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.datastoreTemplate.findById(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trader1"</span>, Trader.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);

List&lt;Trader&gt; traders = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.datastoreTemplate.findAllById(ImmutableList.of(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trader1"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trader2"</span>), Trader.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);

List&lt;Trader&gt; allTraders = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.datastoreTemplate.findAll(Trader.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);</pre><p>Cloud Datastore会执行具有高度一致性的基于键的读取，但最终会具有查询一致性。在上面的示例中，前两次读取使用键，而第三次使用基于相应种类的查询执行<code class="literal">Trader</code> 。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_indexes" href="#_indexes"></a>指标</h4></div></div></div><p>默认情况下，所有字段都被索引。要禁用对特定字段的索引编制， <code class="literal">@Unindexed</code>可以使用注释。</p><p>例：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> org.springframework.cloud.gcp.data.datastore.core.mapping.Unindexed;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> ExampleItem {
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> indexedField;

	<em><span class="hl-annotation" style="color: gray">@Unindexed</span></em>
	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> unindexedField;
}</pre><p>直接使用查询或通过查询方法使用查询时，如果未使用select语句，则Cloud Datastore需要<a class="link" href="https://cloud.google.com/datastore/docs/concepts/indexes" target="_top">复合自定义索引</a> <code class="literal">SELECT *</code>或如果过滤条件中有多个<code class="literal">WHERE</code>条款。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_read_with_offsets_limits_and_sorting" href="#_read_with_offsets_limits_and_sorting"></a>读取偏移量，限制和排序</h4></div></div></div><p><code class="literal">DatastoreRepository</code>和自定义实体存储库实现Spring Data <code class="literal">PagingAndSortingRepository</code> ，它支持使用页码和页面大小的偏移量和限制。分页和排序选项也受支持<code class="literal">DatastoreTemplate</code>通过提供一个<code class="literal">DatastoreQueryOptions</code>至<code class="literal">findAll</code> 。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_partial_read_2" href="#_partial_read_2"></a>部分阅读</h4></div></div></div><p>目前尚不支持此功能。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_write_update_2" href="#_write_update_2"></a> 162.4.3写入/更新</h3></div></div></div><p>的写方法<code class="literal">DatastoreOperations</code>接受POJO并将其所有属性写入Datastore。所需的数据存储类型和实体元数据是从给定对象的实际类型获得的。</p><p>如果从数据存储区检索了POJO，并且更改了其ID值，然后写入或更新了POJO，则该操作就像针对具有新ID值的行一样进行。具有原始ID值的实体将不受影响。</p><pre class="programlisting">Trader t = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Trader();
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.datastoreTemplate.save(t);</pre><p>的<code class="literal">save</code>方法表现为更新或插入。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_partial_update_2" href="#_partial_update_2"></a>部分更新</h4></div></div></div><p>目前尚不支持此功能。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_transactions_2" href="#_transactions_2"></a> 162.4.4交易</h3></div></div></div><p>读写事务由提供<code class="literal">DatastoreOperations</code>通过<code class="literal">performTransaction</code>方法：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
DatastoreOperations myDatastoreOperations;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doWorkInsideTransaction() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> myDatastoreOperations.performTransaction(
    transactionDatastoreOperations -&gt; {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Work with transactionDatastoreOperations here.</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// It is also a DatastoreOperations object.</span>

      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transaction completed"</span>;
    }
  );
}</pre><p>的<code class="literal">performTransaction</code>方法接受<code class="literal">Function</code>提供了一个实例<code class="literal">DatastoreOperations</code>宾语。函数的最终返回值和类型由用户确定。您可以像平常一样使用此对象<code class="literal">DatastoreOperations</code>例外：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">它无法执行子交易。</li></ul></div><p>由于Cloud Datastore的一致性保证，因此在事务内部使用的实体之间的操作和关系存在<a class="link" href="https://cloud.google.com/datastore/docs/concepts/transactions#what_can_be_done_in_a_transaction" target="_top">限制</a> 。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_declarative_transactions_with_transactional_annotation_2" href="#_declarative_transactions_with_transactional_annotation_2"></a>带有@Transactional批注的声明式事务</h4></div></div></div><p>此功能需要一个<code class="literal">DatastoreTransactionManager</code> ，使用时提供<code class="literal">spring-cloud-gcp-starter-data-datastore</code> 。</p><p><code class="literal">DatastoreTemplate</code>和<code class="literal">DatastoreRepository</code>支持运行方法<code class="literal">@Transactional</code> <a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative" target="_top">注释</a>作为事务。如果方法带有注释<code class="literal">@Transactional</code>调用另一个也带有注释的方法，则这两个方法将在同一事务中工作。
<code class="literal">performTransaction</code>不能用于<code class="literal">@Transactional</code>带注释的方法，因为Cloud Datastore不支持事务内的事务。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_read_write_support_for_maps" href="#_read_write_support_for_maps"></a> 162.4.5对地图的读写支持</h3></div></div></div><p>您可以使用以下类型的地图<code class="literal">Map<String, ?></code>而不是通过直接在Cloud Datastore中读写实体对象来使用实体对象。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>这与使用包含Map属性的实体对象不同。</p></td></tr></tbody></table></div><p>映射键用作数据存储区实体的字段名称，并且映射值转换为数据存储区支持的类型。仅支持简单类型（即不支持集合）。可以添加用于自定义值类型的转换器（请参见<a class="xref" href="#_custom_types" title="161.2.10自定义类型">第161.2.10节“自定义类型”</a>部分）。</p><p>例：</p><pre class="programlisting">Map&lt;String, Long&gt; map = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> HashMap&lt;&gt;();
map.put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"field1"</span>, <span class="hl-number">1L</span>);
map.put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"field2"</span>, <span class="hl-number">2L</span>);
map.put(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"field3"</span>, <span class="hl-number">3L</span>);

keyForMap = datastoreTemplate.createKey(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"kindName"</span>, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"id"</span>);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//write a map</span>
datastoreTemplate.writeMap(keyForMap, map);

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">//read a map</span>
Map&lt;String, Long&gt; loadedMap = datastoreTemplate.findByIdAsMap(keyForMap, Long.<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span>);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_repositories_2" href="#_repositories_2"></a> 162.5资料库</h2></div></div></div><p><a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories" target="_top">Spring Data Repository</a>是可以减少样板代码的抽象。</p><p>例如：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TraderRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> DatastoreRepository&lt;Trader, String&gt; {
}</pre><p>Spring Data生成指定接口的有效实现，可以将其自动连接到应用程序中。</p><p>的<code class="literal">Trader</code>输入参数<code class="literal">DatastoreRepository</code>指基础域类型。第二类参数<code class="literal">String</code>在这种情况下，指的是域类型的键的类型。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">class</span> MyApplication {

	<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
	TraderRepository traderRepository;

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> demo() {

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.traderRepository.deleteAll();
		String traderId = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"demo_trader"</span>;
		Trader t = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> Trader();
		t.traderId = traderId;
		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.tradeRepository.save(t);

		Iterable&lt;Trader&gt; allTraders = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.traderRepository.findAll();

		<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> count = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.traderRepository.count();
	}
}</pre><p>存储库使您可以定义自定义查询方法（在以下各节中详细介绍），以基于过滤和分页参数来检索，计数和删除。过滤参数可以是您配置的自定义转换器支持的类型。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_query_methods_by_convention_2" href="#_query_methods_by_convention_2"></a> 162.5.1按约定查询方法</h3></div></div></div><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> DatastoreRepository&lt;Trade, String[]&gt; {
  List&lt;Trader&gt; findByAction(String action);

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">int</span> countByAction(String action);

  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">boolean</span> existsByAction(String action);

  List&lt;Trade&gt; findTop3ByActionAndSymbolAndPriceGreaterThanAndPriceLessThanOrEqualOrderBySymbolDesc(
  			String action, String symbol, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">double</span> priceFloor, <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">double</span> priceCeiling);

  Page&lt;TestEntity&gt; findByAction(String action, Pageable pageable);

  Slice&lt;TestEntity&gt; findBySymbol(String symbol, Pageable pageable);

  List&lt;TestEntity&gt; findBySymbol(String symbol, Sort sort);
}</pre><p>在上面的示例中， <a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods" target="_top">查询方法</a> <code class="literal">TradeRepository</code>使用https://docs.spring.io/spring-data/data-commons/docs/current/reference/html#repositories.query-methods.query-creation[Spring数据查询创建]基于方法的名称生成命名约定]。</p><p>Cloud Datastore仅支持通过AND连接的过滤器组件以及以下操作：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">equals</code></li><li class="listitem"><code class="literal">greater than or equals</code></li><li class="listitem"><code class="literal">greater than</code></li><li class="listitem"><code class="literal">less than or equals</code></li><li class="listitem"><code class="literal">less than</code></li><li class="listitem"><code class="literal">is null</code></li></ul></div><p>在编写仅指定这些方法的签名的自定义存储库接口之后，将为您生成实现，并且可以将其与存储库的自动关联实例一起使用。由于Cloud Datastore要求明确选择的字段必须全部一起出现在复合索引中， <code class="literal">find</code>基于名称的查询方法运行为<code class="literal">SELECT *</code> 。</p><p>还支持删除查询。例如，查询方法如<code class="literal">deleteByAction</code>要么<code class="literal">removeByAction</code>删除由发现的实体<code class="literal">findByAction</code> 。删除查询是作为单独的读取和删除操作执行的，而不是作为单个事务执行的，因为除非指定了查询的祖先，否则Cloud Datastore无法在事务中查询。结果是， <code class="literal">removeBy</code>和<code class="literal">deleteBy</code>名称约定查询方法不能通过任何一种在事务内部使用<code class="literal">performInTransaction</code>要么<code class="literal">@Transactional</code>注解。</p><p>删除查询可以具有以下返回类型：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">一个整数类型，它是删除的实体数</li><li class="listitem">被删除的实体的集合</li><li class="listitem">“无效”</li></ul></div><p>方法可以有<code class="literal">org.springframework.data.domain.Pageable</code>用于控制分页和排序的参数，或<code class="literal">org.springframework.data.domain.Sort</code>参数仅用于控制排序。有关详细信息，请参见<a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods" target="_top">Spring Data文档</a> 。</p><p>为了在存储库方法中返回多个项目，我们支持Java集合以及<code class="literal">org.springframework.data.domain.Page</code>和<code class="literal">org.springframework.data.domain.Slice</code> 。如果方法的返回类型为<code class="literal">org.springframework.data.domain.Page</code> ，返回的对象将包括当前页面，结果总数和页面总数。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>返回的方法<code class="literal">Page</code>执行其他查询以计算总页数。返回的方法<code class="literal">Slice</code>另一方面，不执行任何其他查询，因此效率更高。</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_custom_gql_query_methods" href="#_custom_gql_query_methods"></a> 162.5.2自定义GQL查询方法</h3></div></div></div><p>可以通过以下两种方式之一将自定义GQL查询映射到存储库方法：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">namedQueries</code>属性文件</li><li class="listitem">使用<code class="literal">@Query</code>注解</li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_query_methods_with_annotation_2" href="#_query_methods_with_annotation_2"></a>带注释的查询方法</h4></div></div></div><p>使用<code class="literal">@Query</code>注解：</p><p>GQL的标签名称与<code class="literal">@Param</code>方法参数的带注释的名称。</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TraderRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> DatastoreRepository&lt;Trader, String&gt; {

  <em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM traders WHERE name = @trader_name")</span></em>
  List&lt;Trader&gt; tradersByName(<em><span class="hl-annotation" style="color: gray">@Param("trader_name")</span></em> String traderName);

  <em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM  test_entities_ci WHERE id = @id_val")</span></em>
  TestEntity getOneTestEntity(<em><span class="hl-annotation" style="color: gray">@Param("id_val")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id);
}</pre><p>支持以下参数类型：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">com.google.cloud.Timestamp</code></li><li class="listitem"><code class="literal">com.google.cloud.datastore.Blob</code></li><li class="listitem"><code class="literal">com.google.cloud.datastore.Key</code></li><li class="listitem"><code class="literal">com.google.cloud.datastore.Cursor</code></li><li class="listitem"><code class="literal">java.lang.Boolean</code></li><li class="listitem"><code class="literal">java.lang.Double</code></li><li class="listitem"><code class="literal">java.lang.Long</code></li><li class="listitem"><code class="literal">java.lang.String</code></li><li class="listitem"><code class="literal">enum</code>价值观。这些被查询为<code class="literal">String</code>价值观。</li></ul></div><p>除了<code class="literal">Cursor</code> ，还支持每种类型的数组形式。</p><p>如果您要获取查询的项目数或查询返回的项目，请设置<code class="literal">count = true</code>要么<code class="literal">exists = true</code>的属性<code class="literal">@Query</code>注释。在这些情况下，查询方法的返回类型应为整数类型或布尔类型。</p><p>Cloud Datastore provides provides the <code class="literal">SELECT <span class="emphasis"><em>key</em></span> FROM …​</code> special column for all kinds that retrieves the <code class="literal">Key`s of each row. Selecting this special `<span class="emphasis"><em>key</em></span></code> column is especially useful and efficient for <code class="literal">count</code> and <code class="literal">exists</code> queries.</p><p>You can also query for non-entity types:</p><pre class="programlisting">	<em><span class="hl-annotation" style="color: gray">@Query(value = "SELECT __key__ from test_entities_ci")</span></em>
	List&lt;Key&gt; getKeys();

	<em><span class="hl-annotation" style="color: gray">@Query(value = "SELECT __key__ from test_entities_ci limit 1")</span></em>
	Key getKey();

	<em><span class="hl-annotation" style="color: gray">@Query("SELECT id FROM test_entities_ci WHERE id &lt;= @id_val")</span></em>
	List&lt;String&gt; getIds(<em><span class="hl-annotation" style="color: gray">@Param("id_val")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id);

	<em><span class="hl-annotation" style="color: gray">@Query("SELECT id FROM test_entities_ci WHERE id &lt;= @id_val limit 1")</span></em>
	String getOneId(<em><span class="hl-annotation" style="color: gray">@Param("id_val")</span></em> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">long</span> id);</pre><p>SpEL can be used to provide GQL parameters:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM |com.example.Trade| WHERE trades.action = @act
  AND price &gt; :#{#priceRadius * -1} AND price &lt; :#{#priceRadius * 2}")</span></em>
List&lt;Trade&gt; fetchByActionNamedQuery(<em><span class="hl-annotation" style="color: gray">@Param("act")</span></em> String action, <em><span class="hl-annotation" style="color: gray">@Param("priceRadius")</span></em> Double r);</pre><p>Kind names can be directly written in the GQL annotations.
Kind names can also be resolved from the <code class="literal">@Entity</code> annotation on domain classes.</p><p>In this case, the query should refer to table names with fully qualified class names surrounded by <code class="literal">|</code> characters: <code class="literal">|fully.qualified.ClassName|</code>.
This is useful when SpEL expressions appear in the kind name provided to the <code class="literal">@Entity</code> annotation.
For example:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Query("SELECT * FROM |com.example.Trade| WHERE trades.action = @act")</span></em>
List&lt;Trade&gt; fetchByActionNamedQuery(<em><span class="hl-annotation" style="color: gray">@Param("act")</span></em> String action);</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_query_methods_with_named_queries_properties_2" href="#_query_methods_with_named_queries_properties_2"></a>Query methods with named queries properties</h4></div></div></div><p>You can also specify queries with Cloud Datastore parameter tags and SpEL expressions in properties files.</p><p>By default, the <code class="literal">namedQueriesLocation</code> attribute on <code class="literal">@EnableDatastoreRepositories</code> points to the <code class="literal">META-INF/datastore-named-queries.properties</code> file.
You can specify the query for a method in the properties file by providing the GQL as the value for the "interface.method" property:</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-attribute">Trader.fetchByName</span>=SELECT * FROM traders WHERE name = @tag0</pre><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TraderRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> DatastoreRepository&lt;Trader, String&gt; {

	<span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// This method uses the query from the properties file instead of one generated based on name.</span>
	List&lt;Trader&gt; fetchByName(<em><span class="hl-annotation" style="color: gray">@Param("tag0")</span></em> String traderName);

}</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_transactions_3" href="#_transactions_3"></a>162.5.3 Transactions</h3></div></div></div><p>These transactions work very similarly to those of <code class="literal">DatastoreOperations</code>, but is specific to the repository’s domain type and provides repository functions instead of template functions.</p><p>For example, this is a read-write transaction:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
DatastoreRepository myRepo;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String doWorkInsideTransaction() {
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> myRepo.performTransaction(
    transactionDatastoreRepo -&gt; {
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Work with the single-transaction transactionDatastoreRepo here.</span>
      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// This is a DatastoreRepository object.</span>

      <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"transaction completed"</span>;
    }
  );
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_projections_2" href="#_projections_2"></a>162.5.4 Projections</h3></div></div></div><p>Spring Data Cloud Datastore支持<a class="link" href="https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#projections" target="_top">预测</a> 。您可以根据域类型定义投影接口，并添加查询方法以在存储库中返回它们：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeProjection {

	String getAction();

	<em><span class="hl-annotation" style="color: gray">@Value("#{target.symbol + ' ' + target.action}")</span></em>
	String getSymbolAndAction();
}

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> DatastoreRepository&lt;Trade, Key&gt; {

	List&lt;Trade&gt; findByTraderId(String traderId);

	List&lt;TradeProjection&gt; findByAction(String action);

	<em><span class="hl-annotation" style="color: gray">@Query("SELECT action, symbol FROM trades WHERE action = @action")</span></em>
	List&lt;TradeProjection&gt; findByQuery(String action);
}</pre><p>可以通过基于名称约定的查询方法以及自定义GQL查询来提供投影。如果使用自定义GQL查询，则可以进一步将从Cloud Datastore检索到的字段限制为仅投影所需的字段。但是，自定义选择语句（那些不使用<code class="literal">SELECT *</code> ）需要包含所选字段的复合索引。</p><p>使用SpEL定义的投影类型的属性使用固定名称<code class="literal">target</code>用于基础域对象。结果，访问基础属性采用以下形式： <code class="literal">target.<property-name></code> 。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rest_repositories_2" href="#_rest_repositories_2"></a> 162.5.5 REST存储库</h3></div></div></div><p>使用Spring Boot运行时，只需将以下依赖项添加到pom文件中，即可将存储库作为REST服务公开：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-data-rest<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>如果您希望配置参数（例如路径），则可以使用<code class="literal">@RepositoryRestResource</code>注解：</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RepositoryRestResource(collectionResourceRel = "trades", path = "trades")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">interface</span> TradeRepository <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">extends</span> DatastoreRepository&lt;Trade, String[]&gt; {
}</pre><p>例如，您可以检索所有<code class="literal">Trade</code>通过使用存储库中的对象<code class="literal">curl http://<server>:<port>/trades</code> ，或通过<code class="literal">curl http://<server>:<port>/trades/<trader_id></code> 。</p><p>您也可以使用<code class="literal">curl -XPOST -H"Content-Type: application/json" -<a class="link" href="mailto:d@test.json" target="_top">d@test.json</a> http://<server>:<port>/trades/</code>文件在哪里<code class="literal">test.json</code>持有的JSON表示形式<code class="literal">Trade</code>宾语。</p><p>要删除交易，您可以使用<code class="literal">curl -XDELETE http://<server>:<port>/trades/<trader_id></code></p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_10" href="#_sample_10"></a> 162.6样本</h2></div></div></div><p>提供了一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-data-datastore-basic-sample" target="_top">简单的Spring Boot应用程序</a>和更高级的<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-data-datastore-sample" target="_top">Sample Spring Boot应用程序示例</a> ，以显示如何使用Spring Data Cloud Datastore启动器和模板。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_cloud_memorystore_for_redis" href="#_cloud_memorystore_for_redis"></a> 163。Redis的Cloud Memorystore</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_spring_caching" href="#_spring_caching"></a> 163.1春季缓存</h2></div></div></div><p><a class="link" href="https://cloud.google.com/memorystore/" target="_top">Cloud Memorystore for Redis</a>提供了完全托管的内存中数据存储服务。Cloud Memorystore与Redis协议兼容，可轻松与<a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html" target="_top">Spring Caching</a>集成。</p><p>您要做的就是创建一个Cloud Memorystore实例，并在其中使用其IP地址。 <code class="literal">application.properties</code>归档为<code class="literal">spring.redis.host</code>适当的价值。其他一切与设置由Redis支持的Spring缓存完全相同。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>Memorystore实例和您的应用程序实例必须位于同一区域。</p></td></tr></tbody></table></div><p>简而言之，需要以下依赖项：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-cache<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.boot<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-boot-starter-data-redis<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>然后你可以使用<code class="literal">org.springframework.cache.annotation.Cacheable</code>您想要缓存的方法的注释。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Cacheable("cache1")</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> String hello(<em><span class="hl-annotation" style="color: gray">@PathVariable</span></em> String name) {
    ....
}</pre><p>如果您对详细的操作指南感兴趣，请<a class="link" href="https://codelabs.developers.google.com/codelabs/cloud-spring-cache-memorystore/" target="_top">使用Cloud Memorystore codelab</a>检查<a class="link" href="https://codelabs.developers.google.com/codelabs/cloud-spring-cache-memorystore/" target="_top">Spring Boot缓存</a> 。</p><p>可以在<a class="link" href="https://cloud.google.com/memorystore/docs/redis/" target="_top">此处</a>找到Cloud Memorystore文档。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_cloud_identity_aware_proxy_iap_authentication" href="#_cloud_identity_aware_proxy_iap_authentication"></a> 164。云身份识别代理（IAP）身份验证</h2></div></div></div><p><a class="link" href="https://cloud.google.com/iap/" target="_top">Cloud Identity-Aware Proxy（IAP）</a>为部署到Google Cloud的应用程序提供了安全层。</p><p>IAP入门人员使用<a class="link" href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#oauth2resourceserver" target="_top">Spring Security OAuth 2.0资源服务器</a>功能自动从注入代理的用户中提取用户身份<code class="literal">x-goog-iap-jwt-assertion</code> HTTP标头。</p><p>以下声明将自动验证：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">发行时间</li><li class="listitem">到期时间</li><li class="listitem">发行人</li><li class="listitem">听众</li></ul></div><p>观众（ <code class="literal">"aud"</code> ），当应用程序在App Engine Standard或App Engine Flexible上运行时，会自动配置验证。对于其他运行时环境，必须通过以下方式提供自定义受众<code class="literal">spring.cloud.gcp.security.iap.audience</code>属性。自定义属性（如果已指定）将覆盖自动的App Engine受众群体检测。</p><div class="important" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Important"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png"></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>Compute Engine或Kubernetes Engine没有自动的受众字符串配置。要在GCE / GKE上使用IAP启动器， <a class="link" href="https://cloud.google.com/iap/docs/signed-headers-howto#verify_the_jwt_payload" target="_top">请</a>在“ <a class="link" href="https://cloud.google.com/iap/docs/signed-headers-howto#verify_the_jwt_payload" target="_top">验证JWT有效负载”</a>指南中按照说明查找受众字符串，然后在<code class="literal">spring.cloud.gcp.security.iap.audience</code>属性。否则，应用程序将无法启动<code class="literal">No qualifying bean of type 'org.springframework.cloud.gcp.security.iap.AudienceProvider' available</code>信息。</p></td></tr></tbody></table></div><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果您创建一个自定义<a class="link" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html" target="_top"><code class="literal">WebSecurityConfigurerAdapter</code></a> ，通过添加启用提取用户身份<code class="literal">.oauth2ResourceServer().jwt()</code>配置到<a class="link" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html" target="_top"><code class="literal">HttpSecurity</code></a>宾语。如果没有习惯<a class="link" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html" target="_top"><code class="literal">WebSecurityConfigurerAdapter</code></a>如果存在，则不需要做任何事情，因为默认情况下Spring Boot将添加此自定义。</p></td></tr></tbody></table></div><p>初学者Maven坐标，使用<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/blob/master/spring-cloud-gcp-dependencies/pom.xml" target="_top">Spring Cloud GCP BOM</a> ：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
    <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-security-iap<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>Starter Gradle坐标：</p><pre class="screen">dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-security-iap'
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_configuration_8" href="#_configuration_8"></a> 164.1配置</h2></div></div></div><p>以下属性可用。</p><div class="caution" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Caution"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/caution.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>修改注册表，算法和标头属性可能对测试很有用，但不应在生产中更改默认值。</p></td></tr></tbody></table></div><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"><col class="col_4"></colgroup><thead><tr><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">名称</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">描述</th><th align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid">需要</th><th align="left" valign="top" style="border-bottom:1px solid">默认</th></tr></thead><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.security.iap.registry</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>链接到JWK公钥注册表。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal"><a class="link" href="https://www.gstatic.com/iap/verify/public_key-jwk" target="_top">https://www.gstatic.com/iap/verify/public_key-jwk</a></code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.security.iap.algorithm</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>用于签署JWK令牌的加密算法。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">ES256</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.security.iap.header</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>从中提取JWK密钥的标头。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal">x-goog-iap-jwt-assertion</code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><code class="literal">spring.cloud.gcp.security.iap.issuer</code></p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>JWK发行人进行验证。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p><code class="literal"><a class="link" href="https://cloud.google.com/iap" target="_top">https://cloud.google.com/iap</a></code></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p><code class="literal">spring.cloud.gcp.security.iap.audience</code></p></td><td align="left" valign="top" style="border-right:1px solid"><p>自定义JWK受众进行验证。</p></td><td align="left" valign="top" style="border-right:1px solid"><p>在App Engine上为false；在GCE / GKE上为true</p></td><td align="left" valign="top"> </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_11" href="#_sample_11"></a> 164.2样本</h2></div></div></div><p>提供了<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-security-iap-sample" target="_top">示例应用程序</a> 。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_google_cloud_vision" href="#_google_cloud_vision"></a> 165。Google Cloud Vision</h2></div></div></div><p><a class="link" href="https://cloud.google.com/vision/" target="_top">Google Cloud Vision API</a>允许用户利用机器学习算法来处理图像，包括：图像分类，面部检测，文本提取等。</p><p>Spring Cloud GCP提供：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem">一个方便的启动程序，它自动配置开始使用<a class="link" href="https://cloud.google.com/vision/" target="_top">Google Cloud Vision API</a>所需的身份验证设置和客户端对象。</li><li class="listitem"><p class="simpara">Cloud Vision模板可简化与Cloud Vision API的交互。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:circle"><li class="listitem">使您可以轻松地将图像作为Spring资源发送到API。</li><li class="listitem">提供常用操作的便捷方法，例如从图像中提取文本。</li></ul></div></li></ul></div><p>使用Spring Cloud GCP BOM进行Maven坐标：</p><pre class="programlisting"><span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;dependency&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;groupId&gt;</span>org.springframework.cloud<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/groupId&gt;</span>
  <span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;artifactId&gt;</span>spring-cloud-gcp-starter-vision<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/artifactId&gt;</span>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-tag">&lt;/dependency&gt;</span></pre><p>摇篮坐标：</p><pre class="screen">dependencies {
  compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-vision'
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_cloud_vision_template" href="#_cloud_vision_template"></a> 165.1云视觉模板</h2></div></div></div><p>的<code class="literal">CloudVisionTemplate</code>提供了一种将Cloud Vision API与Spring Resources结合使用的简单方法。</p><p>添加后<code class="literal">spring-cloud-gcp-starter-vision</code>依赖于您的项目，您可能<code class="literal">@Autowire</code>的实例<code class="literal">CloudVisionTemplate</code>在您的代码中使用。</p><p>的<code class="literal">CloudVisionTemplate</code>提供以下与Cloud Vision连接的方法：</p><p><code class="literal">public AnnotateImageResponse analyzeImage(Resource imageResource, Feature.Type…​ featureTypes)</code></p><p><span class="strong"><strong>参数：</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><code class="literal">Resource imageResource</code>指您要分析的图像对象的Spring资源。Google Cloud Vision文档提供了<a class="link" href="https://cloud.google.com/vision/docs/supported-files" target="_top">它们支持的图像类型</a>的<a class="link" href="https://cloud.google.com/vision/docs/supported-files" target="_top">列表</a> 。</li><li class="listitem"><code class="literal">Feature.Type…​ featureTypes</code>是指从图像中提取的Cloud Vision功能的var-arg数组。特征是指人们希望对图像执行的一种图像分析，例如标签检测，OCR识别，面部检测等。可以在一个请求中指定多个特征进行分析。 <a class="link" href="https://cloud.google.com/vision/docs/features" target="_top">Cloud Vision Feature文档中</a>提供了<a class="link" href="https://cloud.google.com/vision/docs/features" target="_top">Cloud Vision功能的</a>完整列表。</li></ul></div><p><span class="strong"><strong>返回值：</strong></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><p class="simpara"><a class="link" href="https://cloud.google.com/vision/docs/reference/rpc/google.cloud.vision.v1#google.cloud.vision.v1.AnnotateImageResponse" target="_top"><code class="literal">AnnotateImageResponse</code></a>包含请求中指定的所有特征分析的结果。对于您在请求中提供的每种功能类型， <code class="literal">AnnotateImageResponse</code>提供一种获取方法，以获取该特征分析的结果。例如，如果您使用<code class="literal">LABEL_DETECTION</code>功能，您可以使用来从响应中检索结果<code class="literal">annotateImageResponse.getLabelAnnotationsList()</code> 。</p><p class="simpara"><code class="literal">AnnotateImageResponse</code>由Google Cloud Vision库提供；请参阅<a class="link" href="https://cloud.google.com/vision/docs/reference/rpc/google.cloud.vision.v1#google.cloud.vision.v1.AnnotateImageResponse" target="_top">RPC参考</a>或<a class="link" href="https://googleapis.github.io/googleapis/java/all/latest/apidocs/com/google/cloud/vision/v1/AnnotateImageResponse.html" target="_top">Javadoc</a>以获得更多详细信息。此外，您可以查阅<a class="link" href="https://cloud.google.com/vision/docs/" target="_top">Cloud Vision文档</a>以熟悉API的概念和功能。</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_detect_image_labels_example" href="#_detect_image_labels_example"></a> 165.2检测图像标签示例</h2></div></div></div><p><a class="link" href="https://cloud.google.com/vision/docs/detecting-labels" target="_top">图像标签</a>是指产生描述图像内容的标签。以下是使用Cloud Vision Spring模板完成此操作的代码示例。</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> ResourceLoader resourceLoader;

<em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">private</span> CloudVisionTemplate cloudVisionTemplate;

<span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">public</span> <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> processImage() {
  Resource imageResource = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.resourceLoader.getResource(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"my_image.jpg"</span>);
  AnnotateImageResponse response = <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.cloudVisionTemplate.analyzeImage(
      imageResource, Type.LABEL_DETECTION);
  System.out.println(<span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Image Classification results: "</span> + response.getLabelAnnotationsList());
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_sample_12" href="#_sample_12"></a> 165.3样本</h2></div></div></div><p>提供了一个<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-samples/spring-cloud-gcp-vision-api-sample" target="_top">示例Spring Boot应用程序</a> ，以显示如何使用Cloud Vision启动器和模板。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_cloud_foundry" href="#_cloud_foundry"></a> 166。云铸造</h2></div></div></div><p>Spring Cloud GCP为Cloud Foundry的<a class="link" href="https://docs.pivotal.io/partners/gcp-sb/index.html" target="_top">GCP Service Broker</a>提供支持。我们的发布/订阅，Cloud Spanner，存储，Stackdriver Trace和Cloud SQL MySQL和PostgreSQL入门者都了解Cloud Foundry，并可以从Cloud Foundry环境中进行自动配置的项目ID，凭据等属性检索。</p><p>在诸如Pub / Sub的主题和订阅或Storage的存储桶名称的情况下，这些参数未在自动配置中使用，您可以使用Spring Boot提供的VCAP映射来获取它们。例如，要检索预配置的发布/订阅主题，可以使用<code class="literal">vcap.services.mypubsub.credentials.topic_name</code>应用程序环境中的属性。</p><div class="note" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Note"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>如果同一服务多次绑定到同一应用程序，则自动配置将无法在绑定中进行选择，并且不会为该服务激活。这包括MySQL和PostgreSQL到同一应用程序的绑定。</p></td></tr></tbody></table></div><div class="warning" style="margin-left:0.5in;margin-right:0.5in"><table border="0" summary="Warning"><tbody><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td><th align="left">警告</th></tr><tr><td align="left" valign="top"><p>为了使Cloud SQL集成在Cloud Foundry中正常工作，必须禁用自动重新配置。您可以使用<code class="literal">cf set-env <APP> JBP_CONFIG_SPRING_AUTO_RECONFIGURATION '{enabled: false}'</code>命令。否则，Cloud Foundry将产生一个<code class="literal">DataSource</code>带有无效的JDBC URL（即， <code class="literal">jdbc:mysql://null/null</code> ）。</p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_kotlin_support" href="#_kotlin_support"></a> 167。Kotlin支持</h2></div></div></div><p>Spring Framework的最新版本为Kotlin提供了一流的支持。对于Spring的Kotlin用户，Spring Cloud GCP库是开箱即用的，并且可以与Kotlin应用程序完全互操作。</p><p>有关在Kotlin中构建Spring应用程序的更多信息，请查阅<a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html#kotlin" target="_top">Spring Kotlin文档</a> 。</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear:both"><a name="_prerequisites_2" href="#_prerequisites_2"></a> 167.1先决条件</h2></div></div></div><p>确保正确设置您的Kotlin应用程序。根据您的构建系统，您需要在项目中包括正确的Kotlin构建插件：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://kotlinlang.org/docs/reference/using-maven.html" target="_top">Kotlin Maven插件</a></li><li class="listitem"><a class="link" href="https://kotlinlang.org/docs/reference/using-gradle.html" target="_top">Kotlin Gradle插件</a></li></ul></div><p>根据您的应用程序的需求，您可能需要使用编译器插件来扩展构建配置：</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type:disc"><li class="listitem"><a class="link" href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support" target="_top">Kotlin Spring插件</a> ：为方便起见，使您的Spring配置类/成员成为非最终版本。</li><li class="listitem"><a class="link" href="https://kotlinlang.org/docs/reference/compiler-plugins.html#jpa-support" target="_top">Kotlin JPA插件</a> ：允许在Kotlin应用程序中使用JPA。</li></ul></div><p>正确配置Kotlin项目后，Spring Cloud GCP库将在您的应用程序中运行，而无需进行任何其他设置。</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="_sample_13" href="#_sample_13"></a> 168。样品</h2></div></div></div><p>提供了<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-kotlin-samples/spring-cloud-gcp-kotlin-app-sample" target="_top">Kotlin示例应用程序</a> ，以演示<a class="link" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-kotlin-samples/spring-cloud-gcp-kotlin-app-sample" target="_top">Kotlin内部</a>有效的Maven设置以及各种Spring Cloud GCP集成。</p></div></div></div><div class="part"><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="_appendix_compendium_of_configuration_properties" href="#_appendix_compendium_of_configuration_properties"></a>第十九部分。附录：配置属性概述</h1></div></div></div><div class="partintro"><div></div><div class="informaltable"><table class="informaltable" style="border-collapse:collapse;border-top:1px solid;border-bottom:1px solid"><colgroup><col class="col_1"><col class="col_2"><col class="col_3"></colgroup><tbody><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>默认</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>描述</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>aws.paramstore.default-context</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>aws.paramstore.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用了AWS Parameter Store支持。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>aws.paramstore.fail-fast</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，则在配置查找期间引发异常，否则，记录警告。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>aws.paramstore.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>spring.application.name的替代品，用于在AWS Parameter Store中查找值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>aws.paramstore.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/配置</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>前缀，指示每个属性的第一级。值必须以正斜杠开头，后跟有效路径段或为空。默认为“ / config”。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>aws.paramstore.profile-分隔符</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>_</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.access-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与静态提供程序一起使用的访问密钥。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.instance-profile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置实例配置文件凭据提供程序，而无需进一步配置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.profile-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>AWS配置文件名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.profile-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>AWS配置文件路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.secret-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与静态提供程序一起使用的密钥。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.use-default-aws-credentials-chain</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>使用DefaultAWSCredentials链而不是配置自定义证书链。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.loader.core-pool-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于并行S3交互的Task Executor的核心池大小。 @see org.springframework.scheduling.concurrent。ThreadPoolTaskExecutor＃setCorePoolSize（int）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.loader.max-pool-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于并行S3交互的Task Executor的最大池大小。 @see org.springframework.scheduling.concurrent。ThreadPoolTaskExecutor＃setMaxPoolSize（int）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.loader.queue-capacity</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>备份的S3请求的最大队列容量。 @see org.springframework.scheduling.concurrent。ThreadPoolTaskExecutor＃setQueueCapacity（int）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.region.auto</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用基于EC2元数据服务的自动区域检测。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.region.static</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.stack.auto</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为应用程序启用自动堆栈名称检测。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.stack.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>myStackName</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>手动配置的堆栈名称的名称，该名称将用于检索资源。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>错误加密</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记为如果存在加密或解密错误，则进程应失败。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>加密密钥</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>对称密钥。作为更强大的选择，请考虑使用密钥库。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>crypto.key-store.alias</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>商店中密钥的别名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>crypto.key-store.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>密钥库文件的位置，例如classpath：/keystore.jks。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>加密密钥存储密码</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>锁定密钥库的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>crypto.key-store.secret</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>秘密保护密钥（默认与密码相同）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>crypto.key-store.type</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ks</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>KeyStore类型。默认为jks。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>加密算法</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>要使用的RSA算法（DEFAULT或OEAP）。设置后，请勿更改（否则现有密码将不可解密）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>crypto.rsa.salt</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>死牛</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>盐，用于加密密文的随机秘密。设置后，请勿更改（否则现有密码将不可解密）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>crypto.rsa.strong</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示在内部使用“强” AES加密的标志。如果为true，则将GCM算法应用于AES加密字节。默认值为false（在这种情况下，将使用“标准” CBC代替）。设置后，请勿更改（否则现有密码将不可解密）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>加密盐</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>死牛</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>对称密钥的盐，以十六进制编码的字节数组的形式。作为更强大的选择，请考虑使用密钥库。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>endpoints.zookeeper.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用/ zookeeper端点以检查Zookeeper的状态。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>eureka.client.healthcheck.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用Eureka健康检查处理程序。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>health.config.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示应安装配置服务器运行状况指示器的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>health.config。生存时间</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>缓存结果的生存时间（以毫秒为单位）。默认值300000（5分钟）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>hystrix.metrics.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用Hystrix指标轮询。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>hystrix.metrics.polling-interval-ms</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>后续的指标轮询之间的间隔。默认为2000毫秒。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>hystrix.shareSecurityContext</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用Hystrix并发策略插件挂钩的自动配置功能，该挂钩将转移<code class="literal">SecurityContext</code>从您的主线程到Hystrix命令使用的线程。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.bindings.cache。生存时间</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以缓存响应的最长时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.bindings.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用绑定端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.bus-env.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用bus-env端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.bus-refresh.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用总线刷新端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.channels.cache。生存时间</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以缓存响应的最长时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.channels.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用通道端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.consul.cache。生存时间</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以缓存响应的最长时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>管理端点咨询启用</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用领事端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.env.post.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用可写环境端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.features.cache。生存时间</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以缓存响应的最长时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.features.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用功能端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.gateway.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用网关端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.hystrix.config</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Hystrix设置。传统上，这些是使用servlet参数设置的。有关更多详细信息，请参考Hystrix的文档。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.hystrix.stream.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用hystrix.stream端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.pause.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用/ pause端点（发送Lifecycle.stop（））。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.refresh.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用/ refresh端点以刷新配置并重新初始化刷新作用域的bean。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.restart.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用/ restart端点以重新启动应用程序上下文。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.resume.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用/ resume端点（发送Lifecycle.start（））。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.service-registry.cache。生存时间</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以缓存响应的最长时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.endpoint.service-registry.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用服务注册端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.health.binders.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>允许启用/禁用活页夹的健康指标。如果要完全禁用运行状况指示器，则将其设置为<code class="literal">false</code> 。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>管理健康刷新</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为刷新范围启用运行状况终结点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.health.zookeeper.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为Zookeeper启用健康端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.binders.hystrix.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用OK Http Client工厂bean的创建。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.batch-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.connect-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用云监视指标。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.namespace</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>云监视名称空间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.num-threads</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.read-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>management.metrics.export.cloudwatch.step</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.checksum-policy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.connect-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.enable-repository-listener</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.local存储库</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Maven.offline</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Maven代理</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.remote存储库</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.request-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.resolve-pom</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>maven.update-policy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>proxy.auth。负载均衡</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>proxy.auth.routes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>每个路由的身份验证策略。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ribbon.eager-load.clients</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Ribbon.eager-load.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>功能区.http.client.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>不推荐使用的属性，以启用Ribbon RestClient。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ribbon.okhttp.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用将OK HTTP Client与功能区一起使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ribbon.restclient.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用不推荐使用的Ribbon RestClient的使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>功能区。安全端口</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.bus.ack.destination-service</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>想要听音乐的服务。默认情况下为null（表示所有服务）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.bus.ack.ack</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以关闭acks（默认打开）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.bus.estination</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>springCloudBus</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>消息的Spring Cloud Stream目标名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.bus.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示启用总线的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.bus.env。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以关闭环境更改事件（默认为打开）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.bus.id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>该应用程序实例的标识符。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.bus.refresh。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以关闭刷新事件（默认为打开）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.bus.trace.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以打开跟踪（默认关闭）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.discovery.default-server-port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>80</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>功能区未定义任何端口时使用的端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.discovery.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示启用发现的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.discovery。心跳频率</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>心跳的轮询频率（以毫秒为单位）。客户端将以此频率进行轮询并广播服务ID列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.discovery.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>所使用的发现客户端的顺序<code class="literal">CompositeDiscoveryClient</code>用于排序可用的客户端。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.org</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>最初定位的组织名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用户进行身份验证和获取令牌的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.skip-ssl-validation</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.space</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>最初定位的空间名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.url</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Cloud Foundry API（Cloud Controller）的URL。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.cloudfoundry.username</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>要进行身份验证的用户名（通常是电子邮件地址）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.compatibility-verifier.compatible-boot-versions</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2.1.x</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Spring Boot依赖项的默认接受版本。如果您不想指定具体的值，则可以为补丁程序版本设置{@code x}。示例：{@ code 3.4.x}</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.compatibility-verifier.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用创建Spring Cloud兼容性验证的功能。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.allow-override</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示可以使用{@link #isOverrideSystemProperties（）systemPropertiesOverride}的标志。设置为false可以防止用户意外更改默认值。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.discovery.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示已启用配置服务器发现的标志（将通过发现来查找配置服务器URL）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.discovery.service-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>配置服务器</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于找到配置服务器的服务ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>表示已启用远程配置的标志。默认为true;</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.fail-fast</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示连接服务器失败的致命标志（默认为false）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于创建客户端请求的其他标头。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.label</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于拉取远程配置属性的标签名称。默认设置是在服务器上设置的（通常是基于git的服务器的“ master”）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于获取远程属性的应用程序的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.override-none</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记，表明当{@link #setAllowOverride（boolean）allowOverride}为true时，外部属性应具有最低优先级，并且不应覆盖任何现有的属性源（包括本地配置文件）。默认为false。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.override-system-properties</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示外部属性应覆盖系统属性的标志。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与远程服务器联系时使用的密码（HTTP基本）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.profile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>默认</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获取远程配置时使用的默认配置文件（以逗号分隔）。默认为“默认”。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.request-connect-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>等待连接到配置服务器时超时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.request-read-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>等待从配置服务器读取数据时超时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.retry.initial-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>初始重试间隔（以毫秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.retry.max-尝试</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>6</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>最大尝试次数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.retry.max-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>退避的最大间隔。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.retry.multiplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1.1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>下一个间隔的乘数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.send状态</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示是否发送状态的标志。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.accept-empty</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示未找到应用程序是否需要发送HTTP 404的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.bootstrap</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示配置服务器应使用远程存储库中的属性初始化其自己的环境的标志。默认情况下处于关闭状态，因为它会延迟启动，但是在将服务器嵌入另一个应用程序时很有用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.credhub.ca-cert-files</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.credhub.connection-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.credhub.oauth2.registration-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.credhub.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.credhub.read-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.credhub.url</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.default-application-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>传入请求没有特定请求时的默认应用程序名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.default标签</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>传入请求没有特定标签时的默认存储库标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.default-profile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>默认</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>传入请求没有特定请求时的默认应用程序配置文件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.encrypt.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在发送到客户端之前，启用环境属性的解密。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.basedir</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>存储库本地工作副本的基本目录。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.clone-on-start</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示应在启动时（而不是按需）克隆存储库的标志。通常会导致启动速度较慢，但首次查询速度较快。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.default-label</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与远程存储库一起使用的默认标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.delete-untracked分支</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于指示如果删除了其原始跟踪的分支，则应在本地删除该分支的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.force-pull</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示存储库应强制拉动的标志。如果为true，则放弃任何本地更改并从远程存储库获取。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.host-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>有效的SSH主机密钥。如果还设置了hostKeyAlgorithm，则必须设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.host-key-algorithm</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>ssh-dss，ssh-rsa，ecdsa-sha2-nistp256，ecdsa-sha2-nistp384或ecdsa-sha2-nistp521中的一种。如果还设置了hostKey，则必须设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.ignore-local-ssh-settings</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，请使用基于属性的SSH而非基于文件的SSH配置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.known-hosts文件</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>自定义.known_hosts文件的位置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>环境存储库的顺序。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.passphrase</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于解锁ssh私钥的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>远程存储库认证密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.preferred-authentications</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖服务器身份验证方法顺序。如果服务器在publickey方法之前具有键盘交互身份验证，则这应该可以避免登录提示。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.private-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>有效的SSH私钥。如果ignoreLocalSshSettings为true并且Git URI为SSH格式，则必须设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.proxy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>HTTP代理配置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git。刷新率</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>刷新git存储库之间的时间（以秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.repos</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>存储库标识符到位置和其他属性的映射。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.search-paths</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>搜索要在本地工作副本中使用的路径。默认情况下，仅搜索根。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.skip-ssl-validation</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>与通过HTTPS连接提供服务的存储库进行通信时，指示应绕过SSL证书验证的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.strict-主机密钥检查</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为false，请忽略主机密钥错误。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获取HTTP或SSH连接的超时（以秒为单位）（如果适用），默认为5秒。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git.uri</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>远程存储库的URI。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.git。用户名</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>使用远程存储库进行身份验证的用户名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.health.repositories</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.jdbc.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.jdbc.sql</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>从属性中选择键，值，其中APPLICATION =？和PROFILE =？和LABEL =？</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于查询数据库的键和值的SQL。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.native.add-label-locations</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以确定是否应添加标签位置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.native.default-label</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>主</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.native。错误失败</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于确定解密期间如何处理异常的标志（默认为false）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.native.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.native.search-locations</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>搜索配置文件的位置。默认与Spring Boot应用程序相同，因此[classpath：/，classpath：/ config /，file：./，file：./ config /]。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.native.version</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将为本机存储库报告的版本字符串。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.overrides</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>属性源的额外映射将无条件发送给所有客户端。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置资源路径的前缀（默认为空）。当您不想更改上下文路径或servlet路径时，在嵌入另一个应用程序时很有用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.strip-document-from-yaml</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示应以“本机”形式返回作为文本或集合（不是地图）的YAML文档的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.basedir</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>存储库本地工作副本的基本目录。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.default-label</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与远程存储库一起使用的默认标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>环境存储库的顺序。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.passphrase</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于解锁ssh私钥的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>远程存储库认证密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.search-paths</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>搜索要在本地工作副本中使用的路径。默认情况下，仅搜索根。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.strict主机密钥检查</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>从不在已知主机列表中的远程服务器拒绝传入的SSH主机密钥。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn.uri</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>远程存储库的URI。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.svn。用户名</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>使用远程存储库进行身份验证的用户名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>秘密</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管箱后端。默认为秘密。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.default-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>所有应用程序共享的保管库密钥。默认为应用程序。设置为空禁用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>127.0.0.1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管箱主机。默认为127.0.0.1。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.kv版本</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示使用哪个版本的Vault kv后端的值。默认为1。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.namespace</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Vault X-Vault-Namespace标头的值。默认为空。这仅是Vault Enterprise功能。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>8200</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管库端口。默认为8200</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.profile分隔符</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>，</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管库配置文件分隔符。默认为逗号。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.proxy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>HTTP代理配置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.scheme</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>http</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p> Vault 方案。默认为http。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.skip-ssl-validation</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>与通过HTTPS连接提供服务的存储库进行通信时，指示应绕过SSL证书验证的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.server.vault.timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获取HTTP连接的超时时间（以秒为单位），默认为5秒。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.token</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>安全令牌通过传递到基础环境存储库。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config.uri</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[ <a class="link" href="http://localhost:8888" target="_top">http：// localhost：8888</a> ]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>远程服务器的URI（默认为<a class="link" href="http://localhost:8888" target="_top">http：// localhost：8888</a> ）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.config。用户名</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与远程服务器联系时要使用的用户名（HTTP基本）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.acl令牌</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.data-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>数据</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果format为Format。属性或格式。YAML，然后将以下字段用作查找领事以进行配置的关键字。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.default-context</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.consul.config。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.fail-fast</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，则在配置查找期间引发异常，否则，记录警告。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.format</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>spring.application.name的替代品，用于在领事KV中查找值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>配置</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.profile-分隔符</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>，</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.watch.delay</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>手表的固定延迟值，以毫秒为单位。预设为1000。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.watch.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了手表。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.config.watch.wait-time</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>55</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>等待（或阻止）观看查询的秒数，默认为55。需要小于默认的ConsulClient（默认为60）。要增加ConsulClient超时，请使用自定义ConsulRawClient和自定义HttpClient创建ConsulClient bean。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.acl令牌</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.catalog-services-watch-delay</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>观看领事目录的呼叫之间的延迟（以毫秒为单位），默认为1000。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.catalog-services-watch-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>观看领事目录时阻止的秒数，默认为2。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.datacenters</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>在服务器列表中查询的serviceId→数据中心的映射。这允许在另一个数据中心中查找服务。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.default-query-tag</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果serverListQueryTags中未列出服务列表中要查询的标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.default-zone-metadata-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>区</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务实例区域来自元数据。这允许更改元数据标签名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.deregister</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在领事中禁用自动注销服务。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用服务发现？</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.fail-fast</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，则在服务注册期间引发异常，否则，记录警告（默认为true）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-critical-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>注销超时的关键时间超过超时（例如30m）的关键时间。需要领事版本7.x或更高版本。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用于健康检查呼叫的标题。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>运行状况检查的频率（例如10s），默认为10s。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/执行器/健康</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>调用以进行健康检查的备用服务器路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>健康检查超时（例如10秒）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-tls-skip-verify</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果服务检查为true，则跳过证书验证，否则运行证书验证。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.health-check-url</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>自定义运行状况检查网址会覆盖默认值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.consul.discovery.heartbeat</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.heartbeat.interval-ratio</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.heartbeat.ttl-unit</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>s</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.heartbeat.ttl值</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>30</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.hostname</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>访问服务器时要使用的主机名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.instance-group</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务实例组。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.instance-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>唯一的服务实例ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.instance-zone</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务实例区域。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.ip地址</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>访问服务时要使用的IP地址（还必须设置preferredIpAddress才能使用）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.consul.discovery.lifecycle</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.management-port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于注册管理服务的端口（默认为管理端口）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.management-后缀</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>管理</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>注册管理服务时要使用的后缀。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.management-tags</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>注册管理服务时要使用的标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>所使用的发现客户端的顺序<code class="literal">CompositeDiscoveryClient</code>用于排序可用的客户端。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于注册服务的端口（默认为监听端口）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.prefer-agent-address</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>我们将如何确定要使用的地址的来源。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.prefer-ip-address</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>注册时使用IP地址而不是主机名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.query-passing</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>将“传递”参数添加到/ v1 / health / service / serviceName。这会将运行状况检查传递到服务器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.register</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在领事中注册为服务。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.register-health-check</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在领事中注册健康检查。在服务开发期间很有用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Spring.Cloud.Consul.Discovery.Scheme</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>http</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否注册http或https服务。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.server-list-query-tags</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>在服务器列表中查询的serviceId的→标记的映射。这允许通过单个标签过滤服务。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.service-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.discovery.tags</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>注册服务时要使用的标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.consul。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用了spring-cloud-consul。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>本地主机</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>领事代理主机名。默认为'localhost'。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>8500</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>领事代理端口。默认为'8500'。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.retry.initial-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>初始重试间隔（以毫秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.retry.max-尝试</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>6</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>最大尝试次数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.retry.max-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>退避的最大间隔。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.retry.multiplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1.1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>下一个间隔的乘数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.scheme</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>领事代理方案（HTTP / HTTPS）。如果地址中没有方案-客户端将使用HTTP。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.tls.certificate-password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>打开证书的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.tls.certificate-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>证书的文件路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.tls.key-store-instance-type</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>要使用的关键框架的类型。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.tls.key-store-password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>外部密钥库的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.tls.key-store-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>外部密钥库的路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.cloudfoundry.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.discovery.client.composite-indicator</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用发现客户端复合运行状况指示器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.discovery.client.health-indicator</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.health-indicator.include-description</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.simple.instances</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.simple.local.instance-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务实例的唯一标识符或名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.simple.local.metadata</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务实例的元数据。发现客户端可将其用于按实例修改其行为，例如在负载平衡时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.simple.local.service-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务的标识符或名称。多个实例可能共享相同的服务ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.simple.local.uri</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务实例的URI。将被解析以提取方案，主机和端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.client.simple.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.discovery.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用发现客户端运行状况指示器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.features.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用功能端点。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.compile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>功能主体的配置，将进行编译。映射中的键是函数名称，值是包含键“ lambda”（要编译的主体）和可选的“类型”（默认为“ function”）的映射。如果模棱两可，还可以包含“ inputType”和“ outputType”。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.definition</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于解析默认功能的名称（例如，“ foo”）或组合指令（例如，“ foo | bar”），尤其是在目录中只有一次可用的功能的情况下。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.imports</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>一组包含功能主体的文件的配置，这些文件将被导入和编译。映射中的键是函数名称，值是另一个映射，包含要编译的文件的“位置”和（可选）“类型”（默认为“功能”）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.scan.packages</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>功能</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>触发在指定的基本程序包中扫描可分配给java.util.function的任何类。功能。对于每个检测到的Function类，将一个Bean实例添加到上下文中。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.task.consumer</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.task.function</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.task.supplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>功能的Web资源的路径（如果不为空，则应以/开头）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.supplier.auto-startup</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.supplier.debug</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.supplier.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.supplier.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.supplier.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.function.web.supplier.template-url</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.default-filters</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用于每个路由的过滤器定义列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用DiscoveryClient网关集成的标志。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.filters</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.include-expression</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>将评估是否在网关集成中包括服务的SpEL表达式，默认为：true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.lower-case-service-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>谓词和过滤器中的小写serviceId选项，默认为false。当eureka自动将serviceId大写时，此方法很有用。因此MYSERIVCE将与/ myservice / **匹配</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.predicates</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.route-id前缀</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>routeId的前缀，默认为DiscoveryClient.getClass（）。getSimpleName（）+“ _”。服务ID将被添加以创建routeId。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.discovery.locator.url-expression</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>'lb：//'+ serviceId</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为每个路线创建uri的SpEL表达式，默认为：'lb：//'+ serviceId。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用网关功能。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.remove-hop-by-hop.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter。逐跳删除顺序</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果密钥解析器返回空密钥，则切换为拒绝请求，默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>denyEmptyKey为true时返回的HttpStatus，默认为FORBIDDEN。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.content-security-policy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>default-src'self'https :; font-src'self'https：数据：; img-src'self'https：数据：; object-src'none'; script-src https :; style-src'self'https：'unsafe-inline'</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.content-type-options</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Nosniff</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.disable</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.download-options</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>不开放</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.frame-options</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>拒绝</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.permitted-cross-domain-policies</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>没有</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.referrer-policy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>无推荐人</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.strict-transport-security</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>最大年龄= 631138519</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.filter.secure-headers.xss-protection-header</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个模式=阻止</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gateway.forwarded。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用ForwardedHeadersFilter。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.globalcors.cors-配置</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.connect-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>连接超时（以毫秒为单位），默认值为45s。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.pool.acquire-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>仅对于FIXED类型，等待等待的最长时间（以毫秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.pool.max-connections</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>仅对于FIXED类型，是在现有连接上开始挂起获取之前的最大连接数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.pool.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>代理</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>通道池映射名称，默认为代理。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.pool.type</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>供HttpClient使用的池类型，默认为ELASTIC。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.proxy.host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Netty HttpClient代理配置的主机名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.proxy.non-proxy-hosts-pattern</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置的主机列表的正则表达式（Java）。应该直接到达，绕过代理</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.proxy.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Netty HttpClient代理配置的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.proxy.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Netty HttpClient代理配置的端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.proxy.username</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Netty HttpClient代理配置的用户名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.response-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>响应超时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.close-notify-flush-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>3000毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>SSL close_notify刷新超时。默认为3000毫秒</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.close-notify-flush-timeout-millis</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.close-notify-read-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>SSL close_notify读取超时。默认为0毫秒。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.close-notify-read-timeout-millis</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.default-configuration-type</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>缺省的ssl配置类型。默认为TCP。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.handshake-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>SSL握手超时。默认为10000毫秒</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.handshake-timeout-millis</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.trusted-x509-certificates</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于验证远程端点的证书的受信任证书。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.ssl.use-insecure-trust-manager</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>安装netty InsecureTrustManagerFactory。这是不安全的，不适合生产。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpclient.wiretap</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为Netty HttpClient启用窃听调试。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.httpserver.wiretap</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为Netty HttpServer启用窃听调试。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.loadbalancer.use404</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.metrics.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用指标数据收集。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.proxy.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>固定的标头值，将添加到所有下游请求中。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.proxy.sensitive</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>一组敏感的标头名称，默认情况下不会发送到下游。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.redis-rate-limiter.burst-capacity-header</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>X-RateLimit突发容量</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>返回突发容量配置的标头名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.redis-rate-limiter.config</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.redis-rate-limiter.include-headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否包括包含速率限制器信息的标头，默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.redis-rate-limiter.remaining-header</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>X-RateLimit-剩余</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标头名称，它返回当前秒内剩余请求数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.redis-rate-limiter.replenish-rate-header</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>X-RateLimit-补充率</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>返回补充费率配置的标头名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.routes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>路线清单。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.streaming-media-types</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果XForwardedHeadersFilter已启用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.append</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了将X-Forwarded-For作为列表附加。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gateway.x-forwarded</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了X-Forwarded-For。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.host-append</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了将X-Forwarded-Host作为列表追加。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gateway.x-forwarded.host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了X-Forwarded-Host。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>XForwardedHeadersFilter的顺序。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.port-append</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了将X-Forwarded-Port作为列表追加。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gateway.x-forwarded.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了X-Forwarded-Port。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.prefix-append</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用将X-Forwarded-Prefix作为列表追加。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gateway.x-forwarded.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了X-Forwarded-Prefix。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gateway.x-forwarded.proto-append</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用将X-Forwarded-Proto作为列表附加。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gateway.x-forwarded.proto</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果启用了X-Forwarded-Proto。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用Spring Cloud GCP Config。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用程序的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.profile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用程序在其下运行的配置文件的逗号分隔字符串。从{@code spring.profiles.active}属性获取其默认值，回退到{@code spring.profiles.default}属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖Core模块中指定的GCP项目ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.config.timeout-millis</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>60000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Google Runtime Configuration API调用超时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.datastore.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.datastore.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.datastore.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.datastore.namespace</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.datastore.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.logging.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为Spring MVC自动配置Google Cloud Stackdriver日志记录。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>正在运行服务的GCP项目ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.emulator-host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>本地正在运行的仿真器的主机和端口。如果提供的话，这将设置客户端以与正在运行的发布/订阅模拟器连接。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动配置Google Cloud Pub / Sub组件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖Core模块中指定的GCP项目ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.delay-threshold-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于批处理的延迟阈值。经过这段时间后（从添加的第一个元素开始计数），这些元素将被分批包装并发送。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.element-count-threshold</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于批处理的元素计数阈值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，则启用批处理。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.flow-control.limit超出行为</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>超过指定限制时的行为。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.flow-control.max-outstanding-element-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>在执行流控制之前要保留在内存中的未完成元素的最大数量。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.flow-control.max-outstanding-request-bytes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>强制执行流控制之前要保留在内存中的最大未完成字节数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.batching.request-byte-threshold</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于批处理的请求字节阈值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.executor-threads</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>4</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>每个发布者使用的线程数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.initial-retry-delay-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>InitialRetryDelay控制第一次重试之前的延迟。随后的重试将使用根据RetryDelayMultiplier调整的该值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.initial-rpc-timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>InitialRpcTimeout控制初始RPC的超时。后续调用将使用根据RpcTimeoutMultiplier调整的该值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.jittered</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>抖动确定是否应将延迟时间随机化。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.max-尝试</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>MaxAttempts定义执行的最大尝试次数。如果此值大于0，并且尝试次数达到此限制，则即使总重试时间仍小于TotalTimeout，逻辑也会放弃重试。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.max-retry-delay-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>MaxRetryDelay设置了重试延迟的值的限制，以便RetryDelayMultiplier不能将重试延迟增加到大于此数量的值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.max-rpc-timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>MaxRpcTimeout对RPC超时值设置了限制，因此RpcTimeoutMultiplier不能将RPC超时增加到高于此值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.retry-delay-multiplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>RetryDelayMultiplier控制重试延迟的更改。将前一个呼叫的重试延迟乘以RetryDelayMultiplier，以计算下一个呼叫的重试延迟。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.rpc-timeout-multiplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>RpcTimeoutMultiplier控制RPC超时的更改。上一个呼叫的超时时间乘以RpcTimeoutMultiplier，以计算下一个呼叫的超时时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.publisher.retry.total-timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>TotalTimeout具有最终控制权，该逻辑应继续尝试远程调用直到完全放弃之前应保持多长时间。总超时时间越高，可以尝试的重试次数越多。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.executor-threads</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>4</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>每个订户使用的线程数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.flow-control.limit-exceeded-behavior</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>超过指定限制时的行为。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.flow-control.max-outstanding-element-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>在执行流控制之前要保留在内存中的未完成元素的最大数量。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.flow-control.max-outstanding-request-bytes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>强制执行流控制之前要保留在内存中的最大未完成字节数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.max-ack-extension-period</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用户工厂的可选最大ack扩展周期（以秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.max-acknowledgement-threads</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>4</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于批处理确认的线程数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.parallel-pull-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>订户工厂的可选并行拉计数设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.pull端点</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>订户工厂的可选提取端点设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.initial-retry-delay-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>InitialRetryDelay控制第一次重试之前的延迟。随后的重试将使用根据RetryDelayMultiplier调整的该值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.initial-rpc-timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>InitialRpcTimeout控制初始RPC的超时。后续调用将使用根据RpcTimeoutMultiplier调整的该值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.jittered</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>抖动确定是否应将延迟时间随机化。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.max-尝试</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>MaxAttempts定义执行的最大尝试次数。如果此值大于0，并且尝试次数达到此限制，则即使总重试时间仍小于TotalTimeout，逻辑也会放弃重试。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.max-retry-delay-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>MaxRetryDelay设置了重试延迟的值的限制，以便RetryDelayMultiplier不能将重试延迟增加到大于此数量的值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.max-rpc-timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>MaxRpcTimeout对RPC超时值设置了限制，因此RpcTimeoutMultiplier不能将RPC超时增加到高于此值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.retry-delay-multiplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>RetryDelayMultiplier控制重试延迟的更改。将前一个呼叫的重试延迟乘以RetryDelayMultiplier，以计算下一个呼叫的重试延迟。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.rpc-timeout-multiplier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>RpcTimeoutMultiplier控制RPC超时的更改。上一个呼叫的超时时间乘以RpcTimeoutMultiplier，以计算下一个呼叫的超时时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.pubsub.subscriber.retry.total-timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>TotalTimeout具有最终控制权，该逻辑应继续尝试远程调用直到完全放弃之前应保持多长时间。总超时时间越高，可以尝试的重试次数越多。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.security.iap.algorithm</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ES256</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于签署JWK令牌的加密算法。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.security.iap.audience</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>非动态受众群体字符串进行验证。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gcp.security.iap。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动配置Google Cloud IAP身份提取组件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.security.iap.header</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>x-goog-iap-jwt断言</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>从中提取JWK密钥的标头。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.security.iap.issuer</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="https://cloud.google.com/iap" target="_top">https://cloud.google.com/iap</a></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>JWK发行人进行验证。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.security.iap.registry</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="https://www.gstatic.com/iap/verify/public_key-jwk" target="_top">https://www.gstatic.com/iap/verify/public_key-jwk</a></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>链接到JWK公钥注册表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.create-interleaved-table-ddl-on-delete-cascade</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.database</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.instance-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.keep-alive-interval-minutes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.max-idle-sessions</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.max-sessions</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.min-sessions</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.num-rpc-channels</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.prefetch-chunks</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.spanner.write-sessions-fraction</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.sql.credentials</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖核心模块中指定的GCP OAuth2凭据。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.sql.database-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Cloud SQL实例中的数据库名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.sql.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动配置Google Cloud SQL支持组件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.sql.instance-connection-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Cloud SQL实例连接名称。[GCP_PROJECT_ID]：[INSTANCE_REGION]：[INSTANCE_NAME]。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.storage.auto-create-files</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.storage.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.storage.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.storage.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.storage.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动配置Google Cloud Storage组件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.authority</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>通道声称要连接的HTTP / 2权限。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.compression</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于呼叫的压缩。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.deadline-ms</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>通话截止时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动配置Google Cloud Stackdriver跟踪组件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.max入站大小</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>入站邮件的最大大小。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.max-outbound-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>出站邮件的最大大小。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.message-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将待处理的跨度批量发送到GCP Stackdriver Trace之前的超时时间（以秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.num-executor-threads</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>4</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>跟踪执行程序使用的线程数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖Core模块中指定的GCP项目ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.trace.wait-for-ready</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果出现瞬态故障，请等待通道准备就绪。在这种情况下，默认为快速失败。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.vision.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.vision.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.gcp.vision.credentials.scopes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.gcp.vision。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动配置Google Cloud Vision组件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.httpclientfactories.apache.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用创建Apache Http Client工厂bean的功能。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.httpclientfactories.ok.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用OK Http Client工厂bean的创建。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.hypermedia.refresh.fixed-delay</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5000</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.hypermedia.refresh.initial-delay</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.inetutils.default-主机名</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>本地主机</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认主机名。发生错误时使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.inetutils.default-ip-address</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>127.0.0.1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认IP地址。发生错误时使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.inetutils.ignored-interfaces</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>网络接口的Java正则表达式列表，将被忽略。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.inetutils.preferred-networks</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>首选网络地址的Java正则表达式列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.inetutils.timeout-seconds</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>超时（以秒为单位），用于计算主机名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.inetutils。仅使用站点本地接口</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否仅使用具有站点本地地址的接口。有关更多详细信息，请参见{@link InetAddress＃isSiteLocalAddress（）}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.api-version</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.apiVersion</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>v1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API版本</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.ca-cert-data</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.ca-cert-file</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.caCertData</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API CACertData</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.caCertFile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API CACertFile</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.client-cert-data</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.client-cert-file</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.client-key-algo</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.client-key-data</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.client-key-file</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.client-key-passphrase</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.clientCertData</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API ClientCertData</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.clientCertFile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API ClientCertFile</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.clientKeyAlgo</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>RSA</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API ClientKeyAlgo</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.clientKeyData</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API ClientKeyData</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.clientKeyFile</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API ClientKeyFile</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.clientKeyPassphrase</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>更改</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API ClientKeyPassphrase</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.connection-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.connectionTimeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>连接超时</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.http-proxy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.https-代理</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.logging-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.loggingInterval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>20多岁</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>记录间隔</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.master-url</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.masterUrl</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="https://kubernetes.default.svc" target="_top">https：//kubernetes.default.svc</a></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API主节点URL</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.namespace</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes命名空间</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.no-proxy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API密码</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.proxy密码</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.proxy用户名</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.request-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.requestTimeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>请求超时</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.rolling-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.rollingTimeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>900年代</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>滚动超时</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.trust-certs</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.trustCerts</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API信任证书</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.username</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes API用户名</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.watch-reconnect-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.watch-reconnect-limit</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.watchReconnectInterval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>重新连接间隔</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.client.watchReconnectLimit</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>重新连接间隔限制重试</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.config.enable-api</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.config.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用ConfigMap属性源定位器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.config.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.config.namespace</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.config.paths</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.config.sources</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在更改时启用Kubernetes配置重新加载。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.mode</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置Kubernetes配置重新加载的检测模式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.monitoring-config-maps</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用对配置映射的监视以检测更改。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.monitoring-secrets</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用对机密的监视以检测更改。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.period</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>15000毫秒</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置检测模式为“轮询”时使用的轮询周期。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.reload.strategy</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置Kubernetes更改时重新加载配置的重新加载策略。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.secrets.enable-api</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.secrets.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用Secrets属性源定位器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.secrets.labels</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.secrets.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.secrets.namespace</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.kubernetes.secrets.paths</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.loadbalancer.retry.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.refresh.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为刷新范围和相关功能启用自动配置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.refresh.extra-refreshable</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Bean的其他类名称，用于将进程发布到刷新范围中。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.service-registry.auto-registration。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用服务自动注册。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.service-registry.auto-registration.fail-fast</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果没有AutoServiceRegistration，启动是否失败。默认为false。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.service-registry.auto-registration.register-management</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否将管理注册为服务。默认为true。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.binders</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果使用了多个相同类型的绑定器（即，连接到RabbitMq的多个实例），则附加的每个绑定器属性（请参阅{@link BinderProperties}）。您可以在此处指定多个活页夹配置，每个配置具有不同的环境设置。例如; spring.cloud.stream.binders.rabbit1.environment。 。 。 ，spring.cloud.stream.binders.rabbit2.environment。 。 。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.binding-retry-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>30</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于安排绑定尝试的重试间隔（以秒为单位）。默认值：30秒。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.bindings</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>每个绑定名称（例如，“输入”）的其他绑定属性（请参见{@link BinderProperties}）。例如;这将设置Sink应用程序的“输入”绑定的内容类型：“ spring.cloud.stream.bindings.input.contentType = text / plain”</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.consul.binder.event-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.default-binder</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>在有多个可用绑定程序（例如“兔子”）的情况下，所有绑定将使用的绑定程序的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.dynamic-目的地</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以动态绑定的目的地列表。如果设置，则只能绑定列出的目的地。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.function.definition</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>绑定功能的定义。如果需要将多个功能组合为一个，请使用管道（例如'fooFunc \ | barFunc'）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.instance-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用程序已部署实例的数量。默认值：1。注意：也可以按每个单独的绑定“ spring.cloud.stream.bindings.foo.consumer.instance-count”进行管理，其中“ foo”是绑定的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.instance-index</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应用程序的实例ID：从0到instanceCount-1的数字。用于分区和Kafka。注意：也可以按每个单独的绑定“ spring.cloud.stream.bindings.foo.consumer.instance-index”进行管理，其中“ foo”是绑定的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.integration.message-handler-non-propagated标头</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>不会从入站邮件复制的邮件标题名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.auto-add-partitions</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.auto-create-topics</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.brokers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[本地主机]</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.configuration</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>适用于生产者和消费者的任意kafka属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.consumer-properties</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>任意的kafka消费者属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.fetch-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.header-mapper-bean-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>要使用的自定义标头映射器的bean名称，而不是{@link org.springframework.kafka.support。DefaultKafkaHeaderMapper}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.health-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>60</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>等待获取分区信息的时间（以秒为单位）；默认值60。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.jaas</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.max-wait</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>100</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.min-partition-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.offset-update-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.offset-update-shutdown-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2000</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.offset-update-time-window</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.producer属性</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>任意的Kafka生产者属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.queue-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>8192</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.replication-factor</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.required-acks</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.socket缓冲区大小</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2097152</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.admin</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.batch-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.buffer-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.compression-type</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.configuration</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.stream.kafka.binder.transaction.producer.error-channel</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.header-mode</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.header-patterns</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.message-key-expression</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.partition-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.partition-key-expression</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.partition-key-extractor-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.partition-selector-expression</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.partition-selector-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.required-groups</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.sync</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.topic</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.producer.use-native-encoding</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.transaction.transaction-id前缀</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.zk-连接超时</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>ZK连接超时（以毫秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.zk节点</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[本地主机]</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.binder.zk-session-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>ZK会话超时（以毫秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.bindings</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.application-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.auto-add-partitions</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.auto-create-topics</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.brokers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.configuration</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.consumer-properties</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.fetch-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.header-mapper-bean-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.health-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.jaas</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.max-wait</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.min-partition-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.offset-update-count</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.offset-update-shutdown-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.offset-update-time-window</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.producer属性</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.queue-size</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.replication-factor</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.required-acks</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.serde错误</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>{@link org.apache.kafka.streams.errors。在出现Serde错误时使用。 {@link KafkaStreamsBinderConfigurationProperties。SerdeError}值用于在使用者绑定上提供异常处理程序。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.socket缓冲区大小</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.zk-连接超时</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.zk节点</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.binder.zk-session-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.bindings</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.time-window.advance-by</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.kafka.streams.time-window.length</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.metrics.export-properties</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将附加到每条消息的属性列表。上下文刷新后，将由onApplicationEvent填充，以避免按消息进行操作的开销。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.metrics.key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>发出的度量标准的名称。应为每个应用程序的唯一值。默认为：$ {spring.application.name：$ {vcap.application.name:${spring.config.name:application}}}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.metrics.meter-filter</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>控制要捕获的“仪表”的模式。默认情况下，将捕获所有“仪表”。例如，“ spring.integration。*”将仅捕获名称以“ spring.integration”开头的仪表的度量信息。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.metrics.properties</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>应添加到度量有效负载的应用程序属性，例如： <code class="literal">spring.application**</code> 。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.metrics.schedule-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>60年代</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>时间间隔，表示为计划指标快照发布的持续时间。默认为60秒</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.override-cloud-connectors</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>仅当云配置文件处于活动状态并且该应用程序提供了Spring Cloud Connector时，此属性才适用。如果该属性为false（默认值），则绑定器检测到合适的绑定服务（例如，在Cloud Foundry中为RabbitMQ绑定器绑定的RabbitMQ服务）并将其用于创建连接（通常通过Spring Cloud Connectors）。设置为true时，此属性指示绑定程序完全忽略绑定的服务，并依赖于Spring Boot属性（例如，依赖于RabbitMQ绑定程序环境中提供的spring.rabbitmq。*属性）。连接到多个系统时，此属性的典型用法是嵌套在自定义环境中。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.rabbit.binder.admin地址</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>要求管理插件；只需要队列亲缘关系。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.rabbit.binder.admin地址</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.rabbit.binder。压缩级别</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>压缩绑定的压缩级别；参见“ java.util.zip”。平减”。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.rabbit.binder.connection-name-prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>此活页夹中连接名称的前缀。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.rabbit.binder.nodes</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>集群成员节点名称；只需要队列亲缘关系。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.rabbit.bindings</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema-registry-client.cached</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema-registry-client.endpoint</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.stream.schema.avro。动态模式生成</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema.avro.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>越南盾</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema.avro.reader-schema</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema.avro.schema-导入</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>首先应加载的文件或目录的列表，从而使它们可以由后续架构导入。请注意，导入的文件不应相互引用。 @参数</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema.avro.schema位置</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>Apache Avro模式的源目录。此转换器使用此模式。如果此架构依赖于其他架构，请考虑在{@link #schemaImports} @parameter中定义那些相关的架构</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema.server.allow-schema-deletion</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>布尔标记，用于启用/禁用模式删除。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.stream.schema.server.path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置资源路径的前缀（默认为空）。当您不想更改上下文路径或servlet路径时，在嵌入另一个应用程序时很有用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.command-line-runner-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>{@code spring.cloud.task.batch.fail-on-job-failure = true}时，用于运行批处理作业的{@code CommandLineRunner}的顺序。默认为0（与{@link org.springframework.boot.autoconfigure.batch相同。JobLauncherCommandLineRunner}）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.chunk-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>块侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.chunk.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理块事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.item-process-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>itemProcess侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.item-process.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理项目的事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.item-read-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>itemRead侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.item-read.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理项目读取事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.item-write-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>itemWrite侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.item-write.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理项目写入事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.job执行顺序</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>jobExecution侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.task.batch.events.job-execution。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理作业执行事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events。跳过顺序</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>跳过侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.task.batch.events.skip。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理跳过事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.events.step-execution-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>stepExecution侦听器顺序的属性</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.task.batch.events.step-execution。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务是否应侦听批处理步骤执行事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.fail-on-failure失败</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定如果批处理作业失败，任务应用程序是否应返回非零退出代码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.fail-on-failure-poll-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>修复了Spring Cloud Task在检查{@link org.springframework.batch.core。将spring.cloud.task.batch.failOnJobFailure设置为true时，JobExecution}已完成。默认为5000</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.job-names</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>以逗号分隔的作业名称列表，用于在启动时执行（例如， <code class="literal">job1,job2</code> ）。默认情况下，将执行在上下文中找到的所有作业。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.batch.listener.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定是否将任务链接到正在运行的批处理作业。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.task.closecontext</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>设置为true时，上下文在任务结束时关闭。否则上下文仍然是开放的。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.events.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定任务应用程序是否应发出任务事件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.executionid</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>更新任务执行时任务将使用的ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.external-execution-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以与任务相关联的ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.parent-execution-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>启动此任务执行的父任务执行ID的ID。如果任务执行没有父级，则默认为null。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.single-instance-enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>此属性用于确定如果正在运行具有相同应用程序名称的另一个任务，则该任务是否将执行。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.single-instance-lock-check-interval</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>500</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>声明任务执行将在两次检查之间等待的时间（以毫秒为单位）。默认时间是：500毫秒。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.single-instance-lock-ttl</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>声明当启用单实例的设置为true时，任务执行可以保持锁定以防止另一个任务使用特定任务名称执行的最长时间（以毫秒为单位）。默认时间是：整数。MAX_VALUE。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.task.table-prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>任务_</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>附加到由Spring Cloud Task创建的表名称的前缀。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.util.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用创建Spring Cloud实用程序bean。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-id.app-id-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用程式编号</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>AppId身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-id.network-interface</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>“ MAC_ADDRESS” UserId机制的网络接口提示。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-id.user-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>MAC地址</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>UserId机制。可以是“ MAC_ADDRESS”，“ IP_ADDRESS”，字符串或类名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-role.app-role-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>方法</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>AppRole身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-role.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>角色名称，可选，用于拉模式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-role.role-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>RoleId。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.app-role.secret-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>SecretId。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.application-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>AppId身份验证的应用程序名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.authentication</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-ec2.aws-ec2-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>AWS 2</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>AWS-EC2身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-ec2.identity-document</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="http://169.254.169.254/latest/dynamic/instance-identity/pkcs7" target="_top">http://169.254.169.254/latest/dynamic/instance-identity/pkcs7</a></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>AWS-EC2 PKCS7身份文档的URL。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-ec2.nonce</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>立即用于AWS-EC2身份验证。空随机数默认为随机数生成。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-ec2.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>角色名称，可选。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-iam.aws-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ws</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>AWS身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-iam.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>角色名称，可选。如果未设置，则默认为友好的IAM名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws-iam.server-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于在登录请求的标头中设置{@code X-Vault-AWS-IAM-Server-ID}标头的服务器的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws.access-key-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.accessKey</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的访问密钥的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>ws</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>aws后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用AWS后端使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.aws.secret-key-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>cloud.aws.credentials.secretKey</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的密钥的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.azure-msi.azure-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>天蓝色</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Azure MSI身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.azure-msi.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.cassandra.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>卡桑德拉</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Cassandra后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.cassandra.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用cassandra后端使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.cassandra.password-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.data.cassandra.password</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的密码的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.cassandra.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.cassandra.username-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.data.cassandra。用户名</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.config.lifecycle.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用生命周期管理。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.config.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于设置{@link org.springframework.core.env.PropertySource}优先级。将Vault用作其他属性源的替代时，这很有用。 @see org.springframework.core。优先顺序</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.connection-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>5000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>连接超时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.consul.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>领事</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>领事后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.vault.consul。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用领事后端使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.consul.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.consul.token-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.consul.token</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的令牌的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.database.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>数据库</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>数据库后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.database.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用数据库后端使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.database.password-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.datasource.password</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的密码的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.database.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.database.username-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.datasource.username</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.vault.discovery。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>指示已启用Vault服务器发现的标志（将通过发现查找Vault服务器URL）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.discovery.service-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>跳马</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用来找到保管箱的服务ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用保管库配置服务器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.fail-fast</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果无法从保管库获取数据，则快速失败。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-gce.gcp路径</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>gcp</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-gce.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>尝试登录的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-gce.service-account</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>可选服务帐户ID。如果未配置，则使用默认ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.credentials.encoded-key</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>OAuth2帐户私钥的base64编码内容（采用JSON格式）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.credentials.location</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>OAuth2凭证私钥的位置。</p><p>由于这是资源，因此私钥可以位于多个位置，例如本地文件系统，类路径，URL等。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.gcp-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>gcp</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.jwt-validity</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>15m</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>JWT令牌的有效性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.project-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖GCP项目ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>尝试登录的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.gcp-iam.service-account-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>覆盖GCP服务帐户ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.generic.application-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于上下文的应用程序名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.generic.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>秘密</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认后端的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.generic.default-context</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认上下文的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.generic.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用通用后端。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.generic.profile-分隔符</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置文件分隔符以组合应用程序名称和配置文件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>本地主机</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管库服务器主机。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kubernetes.kubernetes-路径</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Kubernetes</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Kubernetes身份验证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kubernetes.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>尝试登录的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kubernetes.service-account-token-file</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/var/run/secrets/kubernetes.io/serviceaccount/token</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务帐户令牌文件的路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kv。应用程序名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于上下文的应用程序名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kv。后端</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>秘密</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认后端的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kv.backend-version</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>2</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>键值后端版本。当前支持的版本是：</p><ul> <li>版本1（未转换的键值后端）。</li> <li>版本2（版本化键值后端）。</li> </ul><p></p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kv.default上下文</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>应用</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认上下文的名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.cloud.vault.kv</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用kev-value后端。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.kv.profile分隔符</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>配置文件分隔符以组合应用程序名称和配置文件。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mongodb.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>mongodb</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Cassandra后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mongodb.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用mongodb后端使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mongodb.password-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.data.mongodb.password</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的密码的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mongodb.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mongodb.username-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.data.mongodb.username</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mysql.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>MySQL的</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>mysql后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mysql.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用mysql后端用法。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mysql.password-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.datasource.password</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mysql.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.mysql.username-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.datasource.username</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>8200</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管库服务器端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.postgresql.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>PostgreSQL</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>PostgreSQL后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.postgresql.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用postgresql后端用法。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.postgresql.password-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.datasource.password</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.postgresql.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.postgresql.username-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.datasource.username</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.rabbitmq.backend</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Rabbitmq</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>rabbitmq后端路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.rabbitmq.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用rabbitmq后端使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.rabbitmq.password-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.rabbitmq.password</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的密码的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.rabbitmq.role</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>凭证的角色名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.rabbitmq.username-property</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.rabbitmq。用户名</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>获得的用户名的目标属性。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.read-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>15000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>读取超时。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.scheme</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>https</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>协议方案。可以是“ http”或“ https”。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.ssl.cert-auth-path</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>证书</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>TLS证书认证后端的安装路径。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.ssl.key-store</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>拥有证书和私钥的信任库。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.ssl.key-store-password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于访问密钥库的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.ssl.trust-store</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>拥有SSL证书的信任库。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.ssl.trust-store-password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于访问信任库的密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.token</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>静态保管库令牌。如果{@link #authentication}是{@code TOKEN}，则为必填项。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.vault.uri</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>保管箱URI。可以设置方案，主机和端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.base-sleep-time-ms</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>50</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>重试之间等待的初始时间。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.block-直到连接单元</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>与阻止与Zookeeper的连接有关的时间单位。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.block-直到连接等待</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>等待时间阻止与Zookeeper的连接。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.connect-string</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>本地主机：2181</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>Zookeeper集群的连接字符串。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.default-health-endpoint</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将检查默认健康状况端点以验证依赖项是否存在。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.dependencies</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>别名到ZookeeperDependency的映射。从Ribbon的角度来看，别名实际上是serviceID，因为Ribbon无法接受serviceID中的嵌套结构。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.dependency配置</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.dependency名称</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.initial状态</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>此实例的初始状态（默认为{@link StatusConstants＃STATUS_UP}）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.instance-host</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>服务可以在Zookeeper中注册的预定义主机。对应于URI规范中的{code address}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.instance-id</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于向Zookeeper注册的ID。默认为随机UUID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.instance-port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>用于注册服务的端口（默认为监听端口）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.instance-ssl-port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>注册服务的SSL端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.metadata</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>获取与此实例关联的元数据名称/值对。此信息将发送给Zookeeper，并可由其他实例使用。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>所使用的发现客户端的顺序<code class="literal">CompositeDiscoveryClient</code>用于排序可用的客户端。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.register</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在Zookeeper中注册为服务。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.root</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/服务</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在其中注册了所有实例的Root Zookeeper文件夹。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.discovery.uri规范</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>{scheme}：// {address}：{port}</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>在Zookeeper中注册服务时要解析的URI规范。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用了Zookeeper。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.max-retries</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>重试的最大次数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.max-sleep-ms</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>500</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>每次重试睡眠的最长时间（以毫秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.cloud.zookeeper.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将应用于所有Zookeeper依赖项路径的通用前缀。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.integration.poller.fixed-delay</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>修复了默认轮询器的延迟。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>弹簧集成轮询器每次轮询最大消息</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认轮询器每次轮询的最大邮件数。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.annotation.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.async.configurer.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用默认的AsyncConfigurer。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.async.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用检测与异步相关的组件，以便在线程之间传递跟踪信息。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.async.ignored-beans</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>{@link java.util.concurrent。的列表。应当忽略且不包含在跟踪表示中的Executor} bean名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.baggage键</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>应当在过程外传播的行李密钥名称列表。这些键将带有前缀<code class="literal">baggage</code>在实际密钥之前。设置此属性是为了与以前的Sleuth版本向后兼容。 @请参阅brave.propagation。ExtraFieldPropagation。FactoryBuilder＃addPrefixedFields（String，java.util。采集）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.feign.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>使用Feign时启用跨度信息传播。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.feign.processor.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用将Feign Context包装在其跟踪表示中的后处理器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.grpc.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>使用GRPC时启用跨度信息传播。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.http.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.http.legacy.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用旧版Sleuth设置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.sleuth.hystrix.strategy。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用将所有Callable实例包装到其Sleuth代表-TraceCallable中的自定义HystrixConcurrencyStrategy。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.integration.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用Spring Integration sleuth工具。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.integration.patterns</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[！hystrixStreamOutput *，*]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>通道名称将与之匹配的模式数组。 @see org.springframework.integration.config。GlobalChannelInterceptor＃patterns（）默认为与Hystrix流通道名称不匹配的任何通道名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.integration.websockets.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用对WebSocket的跟踪。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.keys.http.headers</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果存在其他应作为标签添加的标头。如果标头值是多值的，则标记值将是一个逗号分隔的单引号列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.keys.http.prefix</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>http。</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标头名称的前缀（如果它们作为标记添加）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.log.slf4j.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用{@link Slf4jScopeDecorator}，以在日志中打印跟踪信息。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.log.slf4j.whitelisted-mdc-keys</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>从行李到MDC的钥匙清单。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该打开消息传递。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.jms.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.jms.remote-service-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>简讯</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.kafka.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.kafka.remote-service-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>卡夫卡</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.rabbit.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.messaging.rabbit.remote-service-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>Rabbitmq</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.opentracing.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.propagation-keys</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>引用与在线过程相同的字段的列表。例如，名称“ x-vcap-request-id”将按原样设置（包括前缀）。</p><p>注意：{@code fieldName}将隐式小写。 @请参阅brave.propagation。ExtraFieldPropagation。FactoryBuilder＃addField（String）</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.propagation.tag.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用{@link TagPropagationFinishedSpanHandler}，以将额外的传播字段添加到跨度标签。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.propagation.tag.whitelisted-keys</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>从额外的传播字段到跨度标签的键列表。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>弹簧探测反应器在每个面上装饰</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>当在每个运算符上使用true装饰时，性能会下降，但是日志记录将始终包含每个运算符中的跟踪条目。如果在最后一个运算符上使用false修饰符，将会有更好的表现，但是日志记录可能并不总是包含跟踪条目。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.reactor.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，则启用对反应堆的检测。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.rxjava.schedulers.hook.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>通过RxJavaSchedulersHook启用对RxJava的支持。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.rxjava.schedulers.ignoredthreads</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[HystrixMetricPoller，^ RxComputation。* $]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>不会采样其跨度的线程名称。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.sampler。概率</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>0.1</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该采样的请求的概率。例如1.0-应该抽样100％的请求。精度仅是整数（即不支持0.1％的迹线）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.sampler.rate</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>对于低流量的端点，每秒速率可能是一个不错的选择，因为它可以提供电涌保护。例如，您可能永远不会期望端点每秒收到50个以上的请求。如果流量突然激增，达到每秒5000个请求，那么每秒仍然会有50条痕迹。相反，如果您有一个百分比（例如10％），则同一浪涌最终将导致每秒500条痕迹，这可能会使您的存储设备超负荷。为此，Amazon X-Ray包括一个限速采样器（名为Reservoir）。Brave通过{@link brave.sampler使用了相同的方法。RateLimitingSampler}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.scheduled.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为{@link org.springframework.scheduling.annotation启用跟踪。已排定}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>春季侦查计划的跳过模式</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>org.springframework.cloud.netflix.hystrix.stream。HystrixStreamTask</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>应该跳过的类的完全限定名称的模式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.supports-join</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>True表示跟踪系统支持在客户端和服务器之间共享范围ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.trace-id128</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>为true时，生成128位跟踪ID，而不是64位跟踪ID。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.additional-skip-pattern</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>跟踪中应跳过的URL的其他模式。这将附加到{@link SleuthWebProperties＃skipPattern}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.client.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用拦截器注入{@link org.springframework.web.client。RestTemplate}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.client.skip-pattern</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>在客户端跟踪中应跳过的URL的模式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果为true，则为Web应用程序启用检测。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.sleuth.web.exception-logging-filter</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以切换是否存在记录引发的异常的过滤器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.sleuth.web.exception-throwing-filter</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>标记以切换是否存在记录引发的异常的过滤器。 @不建议使用{@link #exceptionLoggingFilterEnabled}</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.filter-order</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>跟踪过滤器应注册的顺序。默认为{@link TraceHttpAutoConfiguration＃TRACING_FILTER_ORDER}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.ignore-自动配置的跳过模式</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果设置为true，将忽略自动配置的跳过模式。 @请参阅TraceWebAutoConfiguration</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.web.skip-pattern</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>/ api-docs。 <span class="strong"><strong>| /摇摇欲坠。</strong></span>|。<span class="strong"><strong>\ .png |。</strong></span>\ .css |。<span class="strong"><strong>\ .js |。</strong></span>\ .html | /favicon.ico | /hystrix.stream</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>跟踪中应跳过的URL的模式。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.sleuth.zuul.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>使用Zuul时启用跨度信息传播。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.base-url</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p><a class="link" href="http://localhost:9411/" target="_top">http：// localhost：9411 /</a></p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>zipkin查询服务器实例的URL。如果在服务发现中注册了Zipkin，则还可以提供Zipkin服务器的服务ID（例如， <a class="link" href="http://zipkinserver/" target="_top">http：// zipkinserver /</a> ）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.compression.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用spring.zipkin.discovery-client</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果设置为{@code false}，则始终将{@link ZipkinProperties＃baseUrl}视为URL。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>启用将范围发送到Zipkin。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.encoder</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>发送到Zipkin的跨度的编码类型。如果您的服务器不是最新服务器，请设置为{@link SpanBytesEncoder＃JSON_V1}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.locator.discovery.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>能够通过服务发现来定位主机名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.message-timeout</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>1个</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>将待处理的跨度批量发送到Zipkin之前的超时时间（以秒为单位）。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.sender.type</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将跨度发送到Zipkin的方法。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>spring.zipkin.service.name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>通过HTTP发送跨度的服务名称，该名称应显示在Zipkin中。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.amqp.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用对Stub Runner和AMQP的支持。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.amqp.mock连接</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用对Stub Runner和AMQP模拟连接工厂的支持。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.classifier</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>存根</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>默认情况下，在常春藤坐标中用于存根的分类器。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用stubrunner.cloud.consul。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否在领事中启用存根注册。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.cloud.delegate.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用DiscoveryClient的Stub Runner实现。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.cloud.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否为Stub Runner启用Spring Cloud支持。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.cloud.eureka.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否在尤里卡启用存根注册。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.cloud.ribbon.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用Stub Runner的Ribbon功能区集成。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>启用了stubrunner.cloud.stubbed.discovery。</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否对Stub Runner存根Service Discovery。如果设置为false，则将在实时服务发现中注册存根。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.cloud.zookeeper.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否在Zookeeper中启用存根注册。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.consumer-name</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>您可以通过为此参数设置一个值来覆盖此字段的默认{@code spring.application.name}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.delete测试后存根</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>如果设置为{@code false}，则在运行测试后不会从临时文件夹中删除存根。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.http-server-stub-configurer</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>HTTP服务器存根的配置。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.ids</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>存根的ID以“ ivy”表示法（[groupId]：artifactId：[version]：[classifier] [：port]）运行。 {@code groupId}，{@ code classifier}，{@ code version}和{@code port}是可选的。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.ids到服务ID</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将基于常春藤表示法的ID映射到应用程序内的serviceId。示例“ a：b”→“ myService”“ artifactId”→“ myOtherService”</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.integration.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用Stub Runner与Spring Integration集成。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.mappings-output-folder</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>将每个HTTP服务器的映射转储到所选文件夹。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.max端口</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>15000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动启动的WireMock服务器的端口最大值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.min端口</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>10000</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>自动启动的WireMock服务器的端口的最小值。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.password</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>储存库密码。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.properties</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>可以传递给自定义{@link org.springframework.cloud.contract.stubrunner的属性的地图。StubDownloaderBuilder}。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.proxy主机</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>存储库代理主机。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.proxy端口</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>存储库代理端口。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.stream.enabled</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>真正</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>是否启用Stub Runner与Spring Cloud Stream集成。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>存根模式</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>选择存根应该来自哪里。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>每个消费者的存根</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"><p>仅应将此特定使用者的存根在HTTP服务器存根中注册。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>stubrunner.username</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"> </td><td align="left" valign="top" style="border-bottom:1px solid"><p>储存库用户名。</p></td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>已启用wiremock.rest-template-ssl</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>wiremock.server.files</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>[]</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>wiremock.server.https端口</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>-1</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>wiremock.server.https-port-dynamic</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>wiremock.server.port</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>8080</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>wiremock.server.port-dynamic</p></td><td align="left" valign="top" style="border-right:1px solid;border-bottom:1px solid"><p>假</p></td><td align="left" valign="top" style="border-bottom:1px solid"> </td></tr><tr><td align="left" valign="top" style="border-right:1px solid"><p>wiremock.server.stubs</p></td><td align="left" valign="top" style="border-right:1px solid"><p>[]</p></td><td align="left" valign="top"> </td></tr></tbody></table></div></div></div></div></div></body></html>