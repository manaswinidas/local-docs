<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Andy Wilkinson">
<title>Spring Boot Gradle插件参考指南</title>
<link rel="stylesheet" href="css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			selectedIndex = $(this).index()
			$(".switch--item").filter(function() { return ($(this).text() === selectedText) }).each(function() {
				$(this).addClass('selected');
				$(this).siblings().removeClass('selected');
				selectedContent = $(this).parent().siblings(".content").eq(selectedIndex)
				selectedContent.removeClass('hidden');
				selectedContent.siblings().addClass('hidden');
			});
		});
	});
}

$(addBlockSwitches);
$(globalSwitch);

</script>



</head><body class="book toc2 toc-left" ><div id="header">
<h1>Spring Boot Gradle插件参考指南</h1>
<div class="details">
<span id="author" class="author">安迪·威尔金森</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#introduction">1。介绍</a></li>
<li><a href="#getting-started">2。入门</a></li>
<li><a href="#managing-dependencies">3。管理依赖</a>
<ul class="sectlevel2">
<li><a href="#managing-dependencies-customizing">3.1。自定义托管版本</a></li>
<li><a href="#managing-dependencies-using-in-isolation">3.2。孤立地使用Spring Boot的依赖项管理</a></li>
<li><a href="#managing-dependencies-learning-more">3.3。了解更多</a></li>
</ul>
</li>
<li><a href="#packaging-executable">4。打包可执行档案</a>
<ul class="sectlevel2">
<li><a href="#packaging-executable-jars">4.1。包装可执行jar</a></li>
<li><a href="#packaging-executable-wars">4.2。打包可执行文件大战</a>
<ul class="sectlevel3">
<li><a href="#packaging-executable-wars-deployable">4.2.1。打包可执行和可部署的战争</a></li>
</ul>
</li>
<li><a href="#packaging-executable-and-normal">4.3。打包可执行文件和普通档案</a></li>
<li><a href="#packaging-executable-configuring">4.4。配置可执行档案打包</a>
<ul class="sectlevel3">
<li><a href="#packaging-executable-configuring-main-class">4.4.1。配置主类</a></li>
<li><a href="#packaging-executable-configuring-excluding-devtools">4.4.2。不包括Devtools</a></li>
<li><a href="#packaging-executable-configuring-unpacking">4.4.3。配置需要解压缩的库</a></li>
<li><a href="#packaging-executable-configuring-launch-script">4.4.4。使档案完全可执行</a></li>
<li><a href="#packaging-executable-configuring-properties-launcher">4.4.5。使用<code>PropertiesLauncher</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#publishing-your-application">5，发布您的应用程序</a>
<ul class="sectlevel2">
<li><a href="#publishing-your-application-maven">5.1。与出版<code>maven</code>插入</a></li>
<li><a href="#publishing-your-application-maven-publish">5.2。与出版<code>maven-publish</code>插入</a></li>
<li><a href="#publishing-your-application-distribution">5.3。随<code>application</code>插入</a></li>
</ul>
</li>
<li><a href="#running-your-application">6。使用Gradle运行您的应用程序</a>
<ul class="sectlevel2">
<li><a href="#running-your-application-passing-arguments">6.1。将参数传递给您的应用程序</a></li>
<li><a href="#running-your-application-reloading-resources">6.2。重装资源</a></li>
</ul>
</li>
<li><a href="#integrating-with-actuator">7。与执行器集成</a>
<ul class="sectlevel2">
<li><a href="#integrating-with-actuator-build-info">7.1。生成构建信息</a></li>
</ul>
</li>
<li><a href="#reacting-to-other-plugins">8。对其他插件做出反应</a>
<ul class="sectlevel2">
<li><a href="#reacting-to-other-plugins-java">8.1。对Java插件做出反应</a></li>
<li><a href="#reacting-to-other-plugins-kotlin">8.2。对Kotlin插件的反应</a></li>
<li><a href="#reacting-to-other-plugins-war">8.3。对战争插件做出反应</a></li>
<li><a href="#reacting-to-other-plugins-dependency-management">8.4。对依赖管理插件的反应</a></li>
<li><a href="#reacting-to-other-plugins-application">8.5。对应用程序插件做出反应</a></li>
<li><a href="#reacting-to-other-plugins-maven">8.6。对Maven插件做出反应</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction">1。介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot Gradle插件在<a href="https://gradle.org">Gradle中</a>提供了Spring Boot支持。它允许您打包可执行的jar或war归档文件，运行Spring Boot应用程序，以及使用<code>spring-boot-dependencies</code> 。Spring Boot的Gradle插件需要Gradle 5.x（也支持4.10，但不支持该支持，并且在将来的版本中将删除该支持）。</p>
</div>
<div class="paragraph">
<p>除了本用户指南外，还提供<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api">API文档</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started">2。入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要开始使用该插件，需要将其应用于您的项目。</p>
</div>
<div class="paragraph">
<p>该插件已<a href="https://plugins.gradle.org/plugin/org.springframework.boot">发布到Gradle的插件门户</a> ，可以使用<code>plugins</code>块：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
	id 'org.springframework.boot' version '2.2.1.RELEASE'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">plugins {
	id("org.springframework.boot") version "2.2.1.RELEASE"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>单独应用时，插件对项目的更改很少。相反，插件会检测何时应用某些其他插件，并做出相应的反应。例如，当<code>java</code>插件被应用，用于构建可执行jar的任务将自动配置。一个典型的Spring Boot项目将应用<a href="https://docs.gradle.org/current/userguide/groovy_plugin.html"><code>groovy</code></a> ， <a href="https://docs.gradle.org/current/userguide/java_plugin.htmljava_plugin.html"><code>java</code></a> ， 要么<a href="https://kotlinlang.org/docs/reference/using-gradle.html"><code>org.jetbrains.kotlin.jvm</code></a>插件和<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"><code>io.spring.dependency-management</code></a>插件最少。例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">apply plugin: 'java'
apply plugin: 'io.spring.dependency-management'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">plugins {
	java
	id("org.springframework.boot") version "2.2.1.RELEASE"
}

apply(plugin = "io.spring.dependency-management")</code></pre>
</div>
</div>
<div class="paragraph">
<p>要了解有关Spring Boot插件在应用其他插件时的行为的更多信息，请参见有关<a href="#reacting-to-other-plugins">对其他插件的反应</a>部分。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="managing-dependencies">3。管理依赖</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当您应用<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"><code>io.spring.dependency-management</code></a>插件，Spring Boot的插件将自动<a href="#reacting-to-other-plugins-dependency-management">导入<code>spring-boot-dependencies</code></a>所使用的Spring Boot版本中的<a href="#reacting-to-other-plugins-dependency-management">bom</a> 。这提供了与Maven用户相似的依赖管理体验。例如，它允许您在声明Bom中管理的依赖项时忽略版本号。要使用此功能，只需以通常的方式声明依赖项，但省略版本号：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">dependencies {
	implementation("org.springframework.boot:spring-boot-starter-web")
	implementation("org.springframework.boot:spring-boot-starter-data-jpa")
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-customizing">3.1。自定义托管版本</h3>
<div class="paragraph">
<p>的<code>spring-boot-dependencies</code>应用依赖项管理插件时自动导入的Bom使用属性来控制它管理的依赖项的版本。请参考<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-dependencies/pom.xml">Bom</a>以获得这些属性的完整列表。</p>
</div>
<div class="paragraph">
<p>要自定义托管版本，请设置其相应的属性。例如，要自定义由SLF4J控制的版本<code>slf4j.version</code>属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">ext['slf4j.version'] = '1.7.20'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">extra["slf4j.version"] = "1.7.20"</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">每个Spring Boot版本都是针对一组特定的第三方依赖项进行设计和测试的。覆盖的版本可能会引起兼容性问题，应格外小心。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-using-in-isolation">3.2。孤立地使用Spring Boot的依赖项管理</h3>
<div class="paragraph">
<p>无需将Spring Boot的插件应用于该项目，即可在项目中使用Spring Boot的依赖项管理。的<code>SpringBootPlugin</code>类提供了一个<code>BOM_COORDINATES</code>可用于导入Bom的常数，而不必知道其组ID，工件ID或版本。</p>
</div>
<div class="paragraph">
<p>首先，将项目配置为依赖于Spring Boot插件，但不要应用它：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
	id 'org.springframework.boot' version '2.2.1.RELEASE' apply false
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">plugins {
	id("org.springframework.boot") version "2.2.1.RELEASE" apply false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot插件对依赖管理插件的依赖意味着您可以使用依赖管理插件而不必声明依赖。这也意味着您将自动使用与Spring Boot使用的版本相同的依赖项管理插件。</p>
</div>
<div class="paragraph">
<p>应用依赖管理插件，然后配置它以导入Spring Boot的BOM：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">apply plugin: 'io.spring.dependency-management'

dependencyManagement {
	imports {
		mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">apply(plugin = "io.spring.dependency-management")

the&lt;DependencyManagementExtension&gt;().apply {
	imports {
		mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的Kotlin代码有点尴尬。那是因为我们正在使用应用依赖管理插件的命令式方法。</p>
</div>
<div class="paragraph">
<p>我们可以通过应用根父项目中的插件或使用来减少代码的尴尬<code>plugins</code>就像我们为Spring Boot插件所做的那样阻塞。该方法的缺点是它迫使我们指定依赖项管理插件的版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">plugins {
	java
	id("org.springframework.boot") version "2.2.1.RELEASE" apply false
	id("io.spring.dependency-management") version "1.0.8.RELEASE"
}

dependencyManagement {
	imports {
		mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-learning-more">3.3。了解更多</h3>
<div class="paragraph">
<p>要了解有关依赖性管理插件功能的更多信息，请参阅其<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin/blob/master/README.md">文档</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packaging-executable">4。打包可执行档案</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该插件可以创建包含所有应用程序依赖项的可执行归档文件（jar文件和war文件），然后可以与<code>java -jar</code> 。</p>
</div>
<div class="sect2">
<h3 id="packaging-executable-jars">4.1。包装可执行jar</h3>
<div class="paragraph">
<p>可执行罐子可以使用<code>bootJar</code>任务。当<code>java</code>插件已应用，是的一个实例<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html"><code>BootJar</code></a> 。的<code>assemble</code>任务自动配置为取决于<code>bootJar</code>如此运行的任务<code>assemble</code> （要么<code>build</code> ）也将运行<code>bootJar</code>任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="packaging-executable-wars">4.2。打包可执行文件大战</h3>
<div class="paragraph">
<p>可以使用以下命令建立可执行的战争<code>bootWar</code>任务。当<code>war</code>插件已应用，是的一个实例<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootWar.html"><code>BootWar</code></a> 。的<code>assemble</code>任务自动配置为取决于<code>bootWar</code>如此运行的任务<code>assemble</code> （要么<code>build</code> ）也将运行<code>bootWar</code>任务。</p>
</div>
<div class="sect3">
<h4 id="packaging-executable-wars-deployable">4.2.1。打包可执行和可部署的战争</h4>
<div class="paragraph">
<p>战争文件可以打包成可以使用以下命令执行<code>java -jar</code>并部署到外部容器。为此，应将嵌入式Servlet容器依赖项添加到<code>providedRuntime</code>配置，例如：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">dependencies {
	implementation("org.springframework.boot:spring-boot-starter-web")
	providedRuntime("org.springframework.boot:spring-boot-starter-tomcat")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以确保将它们打包在war文件的<code>WEB-INF/lib-provided</code>它们不会与外部容器自己的类冲突的目录。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>providedRuntime</code>比Gradle的首选<code>compileOnly</code>除了其他限制外， <code>compileOnly</code>依赖项不在测试类路径上，因此任何基于Web的集成测试都将失败。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="packaging-executable-and-normal">4.3。打包可执行文件和普通档案</h3>
<div class="paragraph">
<p>默认情况下， <code>bootJar</code>要么<code>bootWar</code>任务已配置， <code>jar</code>要么<code>war</code>任务被禁用。通过启用以下功能，可以将项目配置为同时构建可执行存档和普通存档。 <code>jar</code>要么<code>war</code>任务：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">jar {
	enabled = true
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;Jar&gt;("jar") {
	enabled = true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免将可执行存档和普通存档写入同一位置，应将一个或另一个配置为使用其他位置。一种方法是配置分类器：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	classifier = 'boot'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	classifier = "boot"
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="packaging-executable-configuring">4.4。配置可执行档案打包</h3>
<div class="paragraph">
<p>的<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html"><code>BootJar</code></a>和<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootWar.html"><code>BootWar</code></a>任务是Gradle的子类<code>Jar</code>和<code>War</code>任务。因此，打包jar或war时可用的所有标准配置选项在打包可执行jar或war时也可用。还提供了一些特定于可执行jar和war的配置选项。</p>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-main-class">4.4.1。配置主类</h4>
<div class="paragraph">
<p>默认情况下，可执行存档的主类将通过查找带有以下内容的类来自动配置<code>public static void main(String[])</code>任务的类路径上目录中的方法。</p>
</div>
<div class="paragraph">
<p>也可以使用任务的主类显式配置主类<code>mainClassName</code>属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	mainClassName = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	mainClassName = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以使用以下命令在项目范围内配置主类名称： <code>mainClassName</code> Spring Boot DSL的属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">springBoot {
	mainClassName = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">springBoot {
	mainClassName = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code>插件</a>已被应用<code>mainClassName</code>必须配置项目属性，并且可以将其用于相同的目的：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">mainClassName = 'com.example.ExampleApplication'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">application {
	mainClassName = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后， <code>Start-Class</code>可以在任务清单上配置属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	manifest {
		attributes 'Start-Class': 'com.example.ExampleApplication'
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	manifest {
		attributes("Start-Class" to "com.example.ExampleApplication")
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-excluding-devtools">4.4.2。不包括Devtools</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot的Devtools模块<code>org.springframework.boot:spring-boot-devtools</code> ，将从可执行jar或war中排除。如果要将Devtools包含在归档文件中，请设置<code>excludeDevtools</code>财产<code>false</code> ：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootWar {
	excludeDevtools = false
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootWar&gt;("bootWar") {
	isExcludeDevtools = false
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-unpacking">4.4.3。配置需要解压缩的库</h4>
<div class="paragraph">
<p>大多数库嵌套在可执行存档中后，可以直接使用，但是某些库可能会出现问题。例如，JRuby包含自己的嵌套jar支持，该支持假定<code>jruby-complete.jar</code>在文件系统上始终直接可用。</p>
</div>
<div class="paragraph">
<p>为了处理任何有问题的库，可执行归档文件可以配置为在运行可执行归档文件时将特定的嵌套jar解压缩到临时文件夹中。可以使用与源jar文件的绝对路径匹配的Ant样式模式将库标识为需要解压缩：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	requiresUnpack '**/jruby-complete-*.jar'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	requiresUnpack("**/jruby-complete-*.jar")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了更好地控制，也可以使用封闭件。闭包通过<code>FileTreeElement</code>并应返回一个<code>boolean</code>指示是否需要打开包装。</p>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-launch-script">4.4.4。使档案完全可执行</h4>
<div class="paragraph">
<p>Spring Boot提供了对完全可执行存档的支持。通过在外壳程序脚本之前添加知道如何启动该应用程序的shell脚本，可以使存档完全可执行。在类似Unix的平台上，此启动脚本允许归档文件像任何其他可执行文件一样直接运行，或作为服务安装。</p>
</div>
<div class="paragraph">
<p>要使用此功能，必须启用启动脚本的包含：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	launchScript()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	launchScript()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将Spring Boot的默认启动脚本添加到存档中。默认启动脚本包括一些具有合理默认值的属性。可以使用<code>properties</code>属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	launchScript {
		properties 'logFilename': 'example-app.log'
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	launchScript {
		properties(mapOf("logFilename" to "example-app.log"))
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果默认启动脚本不能满足您的需求，则<code>script</code>属性可用于提供自定义启动脚本：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
	launchScript {
		script = file('src/custom.script')
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	launchScript {
		script = file("src/custom.script")
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-properties-launcher">4.4.5。使用<code>PropertiesLauncher</code></h4>
<div class="paragraph">
<p>要使用<code>PropertiesLauncher</code>要启动可执行jar或war，请配置任务的清单以设置<code>Main-Class</code>属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootWar {
	manifest {
		attributes 'Main-Class': 'org.springframework.boot.loader.PropertiesLauncher'
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootWar&gt;("bootWar") {
	manifest {
		attributes("Main-Class" to "org.springframework.boot.loader.PropertiesLauncher")
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="publishing-your-application">5，发布您的应用程序</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="publishing-your-application-maven">5.1。与出版<code>maven</code>插入</h3>
<div class="paragraph">
<p>当。。。的时候<a href="https://docs.gradle.org/current/userguide/maven_plugin.html"><code>maven</code></a>应用了<a href="https://docs.gradle.org/current/userguide/maven_plugin.html">插件</a> ， <code>Upload</code>的任务<code>bootArchives</code>配置命名<code>uploadBootArchives</code>是自动创建的。默认情况下， <code>bootArchives</code>配置包含由<code>bootJar</code>要么<code>bootWar</code>任务。的<code>uploadBootArchives</code>可以配置任务以将存档发布到Maven存储库：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">uploadBootArchives {
	repositories {
		mavenDeployer {
			repository url: 'https://repo.example.com'
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;Upload&gt;("uploadBootArchives") {
	repositories.withGroovyBuilder {
		"mavenDeployer" {
			"repository"("url" to "https://repo.example.com")
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing-your-application-maven-publish">5.2。与出版<code>maven-publish</code>插入</h3>
<div class="paragraph">
<p>要发布您的Spring Boot jar或war，请使用<code>artifact</code>方法开启<code>MavenPublication</code> 。将产生您想要发布的工件的任务传递给<code>artifact</code>方法。例如，发布默认生成的工件<code>bootJar</code>任务：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">publishing {
	publications {
		bootJava(MavenPublication) {
			artifact bootJar
		}
	}
	repositories {
		maven {
			url 'https://repo.example.com'
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">publishing {
	publications {
		create&lt;MavenPublication&gt;("bootJava") {
			artifact(tasks.getByName("bootJar"))
		}
	}
	repositories {
		maven {
			url = uri("https://repo.example.com")
		}
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing-your-application-distribution">5.3。随<code>application</code>插入</h3>
<div class="paragraph">
<p>当。。。的时候<a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code>插件</a>应用了一个名为<code>boot</code>被建造。该发行版包含由<code>bootJar</code>要么<code>bootWar</code>任务和脚本以在类似Unix的平台和Windows上启动它。Zip和tar分布可以由<code>bootDistZip</code>和<code>bootDistTar</code>任务。要使用<code>application</code>插件，其<code>mainClassName</code>必须使用应用程序的主类的名称配置project属性。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-your-application">6。使用Gradle运行您的应用程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要在不首先建立档案的情况下运行您的应用程序，请使用<code>bootRun</code>任务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew bootRun</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>bootRun</code>任务是<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/run/BootRun.html"><code>BootRun</code></a>这是一个<code>JavaExec</code>子类。这样，您就可以使用在Gradle中执行Java进程的所有<a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html">常规配置选项</a> 。该任务会自动配置为使用主源集的运行时类路径。</p>
</div>
<div class="paragraph">
<p>默认情况下，将通过查找带有以下内容的类来自动配置主类<code>public static void main(String[])</code>任务的类路径上目录中的方法。</p>
</div>
<div class="paragraph">
<p>也可以使用任务的主类显式配置主类<code>main</code>属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootRun {
	main = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
	main = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以使用以下命令在项目范围内配置主类名称： <code>mainClassName</code> Spring Boot DSL的属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">springBoot {
	mainClassName = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">springBoot {
	mainClassName = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>bootRun</code>将配置JVM以优化其启动，以在开发期间更快地启动。可以通过使用<code>optimizedLaunch</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootRun {
	optimizedLaunch = false
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
	isOptimizedLaunch = false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code>插件</a>已应用，其<code>mainClassName</code>必须配置项目属性，并且可以将其用于相同的目的：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">mainClassName = 'com.example.ExampleApplication'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">application {
	mainClassName = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="running-your-application-passing-arguments">6.1。将参数传递给您的应用程序</h3>
<div class="paragraph">
<p>像所有<code>JavaExec</code>任务，参数可以传递到<code>bootRun</code>从命令行使用<code>--args='<arguments>'</code>使用Gradle 4.9或更高版本时。例如，使用名为<code>dev</code> active可以使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew bootRun --args='--spring.profiles.active=dev'</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/JavaExec.html#setArgsString-java.lang.String-">javadoc <code>JavaExec.setArgsString</code></a>有关更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="running-your-application-reloading-resources">6.2。重装资源</h3>
<div class="paragraph">
<p>如果将devtools添加到您的项目中，它将自动监视您的应用程序的更改。或者，您可以配置<code>bootRun</code>这样您的应用程序的静态资源将从其源位置加载：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootRun {
	sourceResources sourceSets.main
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
	sourceResources(sourceSets["main"])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使得它们可以在实时应用程序中重新加载，这在开发时可能会有所帮助。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integrating-with-actuator">7。与执行器集成</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="integrating-with-actuator-build-info">7.1。生成构建信息</h3>
<div class="paragraph">
<p>spring-boot致动器<code>info</code>端点在存在以下情况时自动发布有关构建的信息<code>META-INF/build-info.properties</code>文件。一种<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/buildinfo/BuildInfo.html"><code>BuildInfo</code></a>提供了生成该文件的任务。使用任务的最简单方法是通过插件的DSL：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">springBoot {
	buildInfo()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">springBoot {
	buildInfo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将配置一个<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/buildinfo/BuildInfo.html"><code>BuildInfo</code></a>任务名为<code>bootBuildInfo</code>并且，如果存在，则将Java插件的<code>classes</code>任务取决于它。任务的目标目录将是<code>META-INF</code>在主要来源集资源的输出目录中（通常是<code>build/resources/main</code> ）。</p>
</div>
<div class="paragraph">
<p>默认情况下，生成的构建信息来自项目：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.artifact</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的基本名称<code>bootJar</code>要么<code>bootWar</code>任务，或<code>unspecified</code>如果不存在这样的任务</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.group</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目组</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目名称</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.time</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">项目建立的时间</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用DSL自定义属性：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">springBoot {
	buildInfo {
		properties {
			artifact = 'example-app'
			version = '1.2.3'
			group = 'com.example'
			name = 'Example application'
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">springBoot {
	buildInfo {
		properties {
			artifact = "example-app"
			version = "1.2.3"
			group = "com.example"
			name = "Example application"
		}
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的默认值<code>build.time</code>是构建项目的瞬间。这样做的副作用是该任务永远不会是最新的。结果，构建将花费更长的时间，因为必须执行更多的任务，包括项目的测试。另一个副作用是任务的输出将始终更改，因此构建将不会真正可重复。如果您重视构建性能或可重复性，而不是<code>build.time</code>属性，设置<code>time</code>至<code>null</code>或固定值。</p>
</div>
<div class="paragraph">
<p>还可以将其他属性添加到构建信息中：</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">springBoot {
	buildInfo {
		properties {
			additional = [
				'a': 'alpha',
				'b': 'bravo'
			]
		}
	}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">springBoot {
	buildInfo {
		properties {
			additional = mapOf(
				"a" to "alpha",
				"b" to "bravo"
			)
		}
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reacting-to-other-plugins">8。对其他插件做出反应</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当应用另一个插件时，Spring Boot插件会通过对项目的配置进行各种更改来做出反应。本节描述了这些更改。</p>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-java">8.1。对Java插件做出反应</h3>
<div class="paragraph">
<p>当摇篮的<a href="https://docs.gradle.org/current/userguide/java_plugin.html"><code>java</code>插件</a>应用于一个项目，即Spring Boot插件：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html"><code>BootJar</code></a>任务名为<code>bootJar</code>这将为项目创建一个可执行的胖子罐。该jar将包含主源集的运行时类路径上的所有内容；类打包在<code>BOOT-INF/classes</code>和罐子包装在<code>BOOT-INF/lib</code></p>
</li>
<li>
<p>配置<code>assemble</code>任务取决于<code>bootJar</code>任务。</p>
</li>
<li>
<p>禁用<code>jar</code>任务。</p>
</li>
<li>
<p>创建一个<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/run/BootRun.html"><code>BootRun</code></a>任务名为<code>bootRun</code>可以用来运行您的应用程序。</p>
</li>
<li>
<p>创建一个名为的配置<code>bootArchives</code>包含由<code>bootJar</code>任务。</p>
</li>
<li>
<p>配置任何<code>JavaCompile</code>没有配置要使用的编码的任务<code>UTF-8</code> 。</p>
</li>
<li>
<p>配置任何<code>JavaCompile</code>使用的任务<code>-parameters</code>编译器参数。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-kotlin">8.2。对Kotlin插件的反应</h3>
<div class="paragraph">
<p>当<a href="https://kotlinlang.org/docs/reference/using-gradle.html">Kotlin的Gradle插件</a>应用于项目时，Spring Boot插件将：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将Spring Boot的依赖管理中使用的Kotlin版本与插件的版本对齐。这是通过设置<code>kotlin.version</code>属性，其值与Kotlin插件的版本匹配。</p>
</li>
<li>
<p>配置任何<code>KotlinCompile</code>使用的任务<code>-java-parameters</code>编译器参数。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-war">8.3。对战争插件做出反应</h3>
<div class="paragraph">
<p>当摇篮的<a href="https://docs.gradle.org/current/userguide/war_plugin.html"><code>war</code>插件</a>应用于一个项目，即Spring Boot插件：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootWar.html"><code>BootWar</code></a>任务名为<code>bootWar</code>这将为该项目造成可执行的激烈竞争。除了标准包装之外， <code>providedRuntime</code>配置将打包在<code>WEB-INF/lib-provided</code> 。</p>
</li>
<li>
<p>配置<code>assemble</code>任务取决于<code>bootWar</code>任务。</p>
</li>
<li>
<p>禁用<code>war</code>任务。</p>
</li>
<li>
<p>配置<code>bootArchives</code>配置以包含由<code>bootWar</code>任务。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-dependency-management">8.4。对依赖管理插件的反应</h3>
<div class="paragraph">
<p>当。。。的时候<a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"><code>io.spring.dependency-management</code>插件</a>应用于项目，Spring Boot插件将自动导入<code>spring-boot-dependencies</code>宝</p>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-application">8.5。对应用程序插件做出反应</h3>
<div class="paragraph">
<p>当摇篮的<a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code>插件</a>应用于一个项目，即Spring Boot插件：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个<code>CreateStartScripts</code>任务名为<code>bootStartScripts</code>这将创建脚本来启动工件中的<code>bootArchives</code>配置使用<code>java -jar</code> 。该任务配置为使用<code>applicationDefaultJvmArgs</code>财产作为其惯例<code>defaultJvmOpts</code>属性。</p>
</li>
<li>
<p>创建一个名为<code>boot</code>并将其配置为在<code>bootArchives</code>其配置<code>lib</code>目录及其中的启动脚本<code>bin</code>目录。</p>
</li>
<li>
<p>配置<code>bootRun</code>使用的任务<code>mainClassName</code>财产作为其惯例<code>main</code>属性。</p>
</li>
<li>
<p>配置<code>bootRun</code>使用的任务<code>applicationDefaultJvmArgs</code>财产作为其惯例<code>jvmArgs</code>属性。</p>
</li>
<li>
<p>配置<code>bootJar</code>使用的任务<code>mainClassName</code>属性作为<code>Start-Class</code>清单中的条目。</p>
</li>
<li>
<p>配置<code>bootWar</code>使用的任务<code>mainClassName</code>属性作为<code>Start-Class</code>清单中的条目。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-maven">8.6。对Maven插件做出反应</h3>
<div class="paragraph">
<p>当摇篮的<a href="https://docs.gradle.org/current/userguide/maven_plugin.html"><code>maven</code>插件</a>应用于项目，Spring Boot插件将配置<code>uploadBootArchives</code><code>Upload</code>确保在生成的pom中没有声明任何依赖项的任务。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-11-06 21:38:53 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>