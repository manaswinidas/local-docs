<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>可执行Jar格式</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head><body id="executable-jar" class="book toc2 toc-left" ><div id="header">
<h1>可执行Jar格式</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#executable-jar-nested-jars">1。嵌套JAR</a>
<ul class="sectlevel2">
<li><a href="#executable-jar-jar-file-structure">1.1。可执行的Jar文件结构</a></li>
<li><a href="#executable-jar-war-file-structure">1.2。可执行战争文件结构</a></li>
</ul>
</li>
<li><a href="#executable-jar-jarfile">2。Spring Boot的“ JarFile”类</a>
<ul class="sectlevel2">
<li><a href="#executable-jar-jarfile-compatibility">2.1。与标准Java“ JarFile”的兼容性</a></li>
</ul>
</li>
<li><a href="#executable-jar-launching">3。发射可执行罐</a>
<ul class="sectlevel2">
<li><a href="#executable-jar-launcher-manifest">3.1。启动清单</a></li>
</ul>
</li>
<li><a href="#executable-jar-property-launcher-features">4。 <code>PropertiesLauncher</code> 特征</a></li>
<li><a href="#executable-jar-restrictions">5，可执行Jar限制</a></li>
<li><a href="#executable-jar-alternatives">6。替代单罐解决方案</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>的<code>spring-boot-loader</code>模块使Spring Boot支持可执行的jar和war文件。如果使用Maven插件或Gradle插件，则会自动生成可执行的jar，通常不需要了解其工作方式的详细信息。</p>
</div>
<div class="paragraph">
<p>如果您需要从其他构建系统创建可执行jar，或者您只是对基础技术感到好奇，则本附录提供了一些背景知识。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="executable-jar-nested-jars"><a class="anchor" href="#executable-jar-nested-jars"></a> 1。嵌套JAR</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java没有提供任何标准的方式来装载嵌套的jar文件（即，它们本身包含在jar中的jar文件）。如果您需要分发一个自包含的应用程序，而该应用程序可以从命令行运行而无需解压缩，则可能会出现问题。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，许多开发人员使用“阴影”罐子。阴影罐将所有罐中的所有类打包到一个“超级罐”中。带阴影的jar的问题在于，很难查看应用程序中实际包含哪些库。如果在多个jar中使用相同的文件名（但具有不同的内容），也可能会产生问题。Spring Boot采用了另一种方法，实际上允许您直接嵌套jar。</p>
</div>
<div class="sect2">
<h3 id="executable-jar-jar-file-structure"><a class="anchor" href="#executable-jar-jar-file-structure"></a> 1.1。可执行的Jar文件结构</h3>
<div class="paragraph">
<p>与Spring Boot Loader兼容的jar文件的结构应采用以下方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>example.jar
 |
 +-META-INF
 |  +-MANIFEST.MF
 +-org
 |  +-springframework
 |     +-boot
 |        +-loader
 |           +-&lt;spring boot loader classes&gt;
 +-BOOT-INF
    +-classes
    |  +-mycompany
    |     +-project
    |        +-YourClasses.class
    +-lib
       +-dependency1.jar
       +-dependency2.jar</pre>
</div>
</div>
<div class="paragraph">
<p>应用程序类应放在嵌套中<code>BOOT-INF/classes</code>目录。依赖项应放在嵌套中<code>BOOT-INF/lib</code>目录。</p>
</div>
</div>
<div class="sect2">
<h3 id="executable-jar-war-file-structure"><a class="anchor" href="#executable-jar-war-file-structure"></a> 1.2。可执行战争文件结构</h3>
<div class="paragraph">
<p>与Spring Boot Loader兼容的war文件的结构应采用以下方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>example.war
 |
 +-META-INF
 |  +-MANIFEST.MF
 +-org
 |  +-springframework
 |     +-boot
 |        +-loader
 |           +-&lt;spring boot loader classes&gt;
 +-WEB-INF
    +-classes
    |  +-com
    |     +-mycompany
    |        +-project
    |           +-YourClasses.class
    +-lib
    |  +-dependency1.jar
    |  +-dependency2.jar
    +-lib-provided
       +-servlet-api.jar
       +-dependency3.jar</pre>
</div>
</div>
<div class="paragraph">
<p>依赖项应放在嵌套中<code>WEB-INF/lib</code>目录。在运行嵌入式程序时需要但在部署到传统Web容器时不需要的任何依赖项都应放在<code>WEB-INF/lib-provided</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="executable-jar-jarfile"><a class="anchor" href="#executable-jar-jarfile"></a> 2。Spring Boot的“ JarFile”类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>用于支持加载嵌套jar的核心类是<code>org.springframework.boot.loader.jar.JarFile</code> 。它使您可以从标准jar文件或嵌套的子jar数据加载jar内容。首次加载时，每个位置<code>JarEntry</code>映射到外部jar的物理文件偏移，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>myapp.jar
+-------------------+-------------------------+
| /BOOT-INF/classes | /BOOT-INF/lib/mylib.jar |
|+-----------------+||+-----------+----------+|
||     A.class      |||  B.class  |  C.class ||
|+-----------------+||+-----------+----------+|
+-------------------+-------------------------+
 ^                    ^           ^
 0063                 3452        3980</pre>
</div>
</div>
<div class="paragraph">
<p>上例显示了<code>A.class</code>可以在<code>/BOOT-INF/classes</code>在<code>myapp.jar</code>在位置<code>0063</code> 。
<code>B.class</code>实际上可以从嵌套罐中找到<code>myapp.jar</code>在位置<code>3452</code>和<code>C.class</code>在位置上<code>3980</code> 。</p>
</div>
<div class="paragraph">
<p>有了这些信息，我们可以通过查找外部jar的适当部分来加载特定的嵌套条目。我们不需要解压缩归档文件，也不需要将所有条目数据读入内存。</p>
</div>
<div class="sect2">
<h3 id="executable-jar-jarfile-compatibility"><a class="anchor" href="#executable-jar-jarfile-compatibility"></a> 2.1。与标准Java“ JarFile”的兼容性</h3>
<div class="paragraph">
<p>Spring Boot Loader努力保持与现有代码和库的兼容性。
<code>org.springframework.boot.loader.jar.JarFile</code>从...延伸<code>java.util.jar.JarFile</code>并应作为替代产品。的<code>getURL()</code>方法返回一个<code>URL</code>打开与以下设备兼容的连接<code>java.net.JarURLConnection</code>并可以与Java一起使用<code>URLClassLoader</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="executable-jar-launching"><a class="anchor" href="#executable-jar-launching"></a> 3。发射可执行罐</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>org.springframework.boot.loader.Launcher</code> class是一个特殊的引导程序类，用作可执行jar的主要入口点。这是实际的<code>Main-Class</code>在您的jar文件中，它用于设置适当的<code>URLClassLoader</code>并最终致电给您<code>main()</code>方法。</p>
</div>
<div class="paragraph">
<p>共有三个启动器子类（ <code>JarLauncher</code> ， <code>WarLauncher</code>和<code>PropertiesLauncher</code> ）。他们的目的是加载资源（ <code>.class</code>目录中嵌套的jar文件或war文件中的文件（等等）（与在类路径中显式的文件相反）。如果是<code>JarLauncher</code>和<code>WarLauncher</code> ，嵌套路径是固定的。
<code>JarLauncher</code>看着<code>BOOT-INF/lib/</code>和<code>WarLauncher</code>看着<code>WEB-INF/lib/</code>和<code>WEB-INF/lib-provided/</code> 。如果需要，可以在这些位置添加额外的罐子。的<code>PropertiesLauncher</code>看着<code>BOOT-INF/lib/</code>默认情况下在应用程序存档中。您可以通过设置一个环境变量来添加其他位置<code>LOADER_PATH</code>要么<code>loader.path</code>在<code>loader.properties</code> （这是目录，归档文件或归档文件中目录的逗号分隔列表）。</p>
</div>
<div class="sect2">
<h3 id="executable-jar-launcher-manifest"><a class="anchor" href="#executable-jar-launcher-manifest"></a> 3.1。启动清单</h3>
<div class="paragraph">
<p>您需要指定一个适当的<code>Launcher</code>作为<code>Main-Class</code>的属性<code>META-INF/MANIFEST.MF</code> 。您要启动的实际类（即包含<code>main</code>方法）应在<code>Start-Class</code>属性。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个典型的<code>MANIFEST.MF</code>对于可执行的jar文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: com.mycompany.project.MyApplication</pre>
</div>
</div>
<div class="paragraph">
<p>对于战争文件，将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Main-Class: org.springframework.boot.loader.WarLauncher
Start-Class: com.mycompany.project.MyApplication</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您无需指定<code>Class-Path</code>清单文件中的条目。类路径是从嵌套的jar中推导出来的。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="executable-jar-property-launcher-features"><a class="anchor" href="#executable-jar-property-launcher-features"></a> 4。 <code>PropertiesLauncher</code> 特征</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>PropertiesLauncher</code>具有一些可以通过外部属性（系统属性，环境变量，清单条目或<code>loader.properties</code> ）。下表描述了这些属性：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">键</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逗号分隔的Classpath，例如<code>lib,${HOME}/app/lib</code> 。较早的条目优先，如常规<code>-classpath</code>在<code>javac</code>命令行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.home</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于解析相对路径<code>loader.path</code> 。例如，给定<code>loader.path=lib</code> ， 然后<code>${loader.home}/lib</code>是类路径位置（以及该目录中的所有jar文件）。此属性还用于查找<code>loader.properties</code>文件，如以下示例所示<code><a href="file:///opt/app" class="bare">/opt/app</a></code>默认为<code>${user.dir}</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.args</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">main方法的默认参数（以空格分隔）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.main</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要启动的主类的名称（例如， <code>com.app.Application</code> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.config.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性文件的名称（例如， <code>launcher</code> ）。默认为<code>loader</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.config.location</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性文件的路径（例如， <code>classpath:loader.properties</code> ）。默认为<code>loader.properties</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.system</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值标志，指示应将所有属性添加到系统属性。默认为<code>false</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当指定为环境变量或清单条目时，应使用以下名称：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">键</th>
<th class="tableblock halign-left valign-top">清单输入</th>
<th class="tableblock halign-left valign-top">环境变量</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Loader-Path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOADER_PATH</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.home</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Loader-Home</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOADER_HOME</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.args</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Loader-Args</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOADER_ARGS</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.main</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Start-Class</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOADER_MAIN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.config.location</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Loader-Config-Location</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOADER_CONFIG_LOCATION</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loader.system</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Loader-System</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOADER_SYSTEM</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">构建插件会自动移动<code>Main-Class</code>归因于<code>Start-Class</code>当胖子罐建成时。如果使用该名称，请使用来指定要启动的类的名称。 <code>Main-Class</code>属性和遗漏<code>Start-Class</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下规则适用于<code>PropertiesLauncher</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>loader.properties</code>在中搜索<code>loader.home</code> ，然后在类路径的根目录中，然后在<code>classpath:/BOOT-INF/classes</code> 。使用具有该名称的文件的第一个位置。</p>
</li>
<li>
<p><code>loader.home</code>是仅在以下情况下其他属性文件的目录位置（覆盖默认值） <code>loader.config.location</code>未指定。</p>
</li>
<li>
<p><code>loader.path</code>可以包含目录（以递归方式扫描jar和zip文件），归档路径，归档中的目录以扫描jar文件（例如， <code>dependencies.jar!/lib</code> ）或通配符模式（用于默认的JVM行为）。存档路径可以相对于<code>loader.home</code>或文件系统中任何带有<code>jar:file:</code>字首。</p>
</li>
<li>
<p><code>loader.path</code> （如果为空）默认为<code>BOOT-INF/lib</code> （表示本地目录或嵌套目录（如果从存档运行）。因为这， <code>PropertiesLauncher</code>表现与<code>JarLauncher</code>当没有提供其他配置时。</p>
</li>
<li>
<p><code>loader.path</code>不能用于配置位置<code>loader.properties</code> （用于搜索后者的类路径是JVM类路径，当<code>PropertiesLauncher</code>启动）。</p>
</li>
<li>
<p>占位符的替换是使用系统变量和环境变量以及属性文件本身的所有值完成的，然后再使用。</p>
</li>
<li>
<p>属性的搜索顺序（可以在多个位置查找是有意义的）是环境变量，系统属性， <code>loader.properties</code> ，爆炸的档案清单和档案清单。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="executable-jar-restrictions"><a class="anchor" href="#executable-jar-restrictions"></a> 5，可执行Jar限制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用Spring Boot Loader打包的应用程序时，需要考虑以下限制：</p>
</div>
<div id="executable-jar-zip-entry-compression" class="ulist">
<ul>
<li>
<p>邮编压缩： <code>ZipEntry</code>因为必须使用<code>ZipEntry.STORED</code>方法。这是必需的，以便我们可以直接在嵌套jar中查找单个内容。嵌套jar文件本身的内容仍然可以压缩，外部jar中的任何其他条目也可以压缩。</p>
</li>
</ul>
</div>
<div id="executable-jar-system-classloader" class="ulist">
<ul>
<li>
<p>系统类加载器：启动的应用程序应使用<code>Thread.getContextClassLoader()</code>加载类时（大多数库和框架默认情况下都这样做）。尝试使用以下方式加载嵌套jar类<code>ClassLoader.getSystemClassLoader()</code>失败。
<code>java.util.Logging</code>始终使用系统类加载器。因此，您应该考虑使用其他日志记录实现。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="executable-jar-alternatives"><a class="anchor" href="#executable-jar-alternatives"></a> 6。替代单罐解决方案</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果上述限制意味着您不能使用Spring Boot Loader，请考虑以下替代方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://maven.apache.org/plugins/maven-shade-plugin/">Maven Shade插件</a></p>
</li>
<li>
<p><a href="http://www.jdotsoft.com/JarClassLoader.php">JarClassLoader</a></p>
</li>
<li>
<p><a href="https://sourceforge.net/projects/one-jar/">一罐</a></p>
</li>
<li>
<p><a href="https://imperceptiblethoughts.com/shadow/">Gradle Shadow插件</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-11-06 21:59:20 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>