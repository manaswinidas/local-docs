<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Spring Boot功能</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head><body id="boot-features" class="book toc2 toc-left" ><div id="header">
<h1>Spring Boot功能</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#boot-features-spring-application">1。Spring应用</a>
<ul class="sectlevel2">
<li><a href="#boot-features-startup-failure">1.1。启动失败</a></li>
<li><a href="#boot-features-lazy-initialization">1.2。延迟初始化</a></li>
<li><a href="#boot-features-banner">1.3。自定义横幅</a></li>
<li><a href="#boot-features-customizing-spring-application">1.4。自定义SpringApplication</a></li>
<li><a href="#boot-features-fluent-builder-api">1.5。Fluent Builder API</a></li>
<li><a href="#boot-features-application-events-and-listeners">1.6。应用程序事件和监听器</a></li>
<li><a href="#boot-features-web-environment">1.7。网络环境</a></li>
<li><a href="#boot-features-application-arguments">1.8。访问应用程序参数</a></li>
<li><a href="#boot-features-command-line-runner">1.9。使用ApplicationRunner或CommandLineRunner</a></li>
<li><a href="#boot-features-application-exit">1.10。申请退出</a></li>
<li><a href="#boot-features-application-admin">1.11。管理员功能</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config">2。外部化配置</a>
<ul class="sectlevel2">
<li><a href="#boot-features-external-config-random-values">2.1。配置随机值</a></li>
<li><a href="#boot-features-external-config-command-line-args">2.2。访问命令行属性</a></li>
<li><a href="#boot-features-external-config-application-property-files">2.3。应用程序属性文件</a></li>
<li><a href="#boot-features-external-config-profile-specific-properties">2.4。特定于配置文件的属性</a></li>
<li><a href="#boot-features-external-config-placeholders-in-properties">2.5。属性中的占位符</a></li>
<li><a href="#boot-features-encrypting-properties">2.6。加密属性</a></li>
<li><a href="#boot-features-external-config-yaml">2.7。使用YAML代替属性</a>
<ul class="sectlevel3">
<li><a href="#boot-features-external-config-loading-yaml">2.7.1。加载YAML</a></li>
<li><a href="#boot-features-external-config-exposing-yaml-to-spring">2.7.2。在Spring环境中将YAML公开为属性</a></li>
<li><a href="#boot-features-external-config-multi-profile-yaml">2.7.3。多配置文件的YAML文档</a></li>
<li><a href="#boot-features-external-config-yaml-shortcomings">2.7.4。YAML的缺点</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config-typesafe-configuration-properties">2.8。类型安全的配置属性</a>
<ul class="sectlevel3">
<li><a href="#boot-features-external-config-java-bean-binding">2.8.1。JavaBean属性绑定</a></li>
<li><a href="#boot-features-external-config-constructor-binding">2.8.2。构造函数绑定</a></li>
<li><a href="#boot-features-external-config-enabling">2.8.3。启用<code>@ConfigurationProperties</code>注释的类型</a></li>
<li><a href="#boot-features-external-config-using">2.8.4。使用<code>@ConfigurationProperties</code>注释的类型</a></li>
<li><a href="#boot-features-external-config-3rd-party-configuration">2.8.5。第三方配置</a></li>
<li><a href="#boot-features-external-config-relaxed-binding">2.8.6。轻松绑定</a></li>
<li><a href="#boot-features-external-config-complex-type-merge">2.8.7。合并复杂类型</a></li>
<li><a href="#boot-features-external-config-conversion">2.8.8。属性转换</a>
<ul class="sectlevel4">
<li><a href="#boot-features-external-config-conversion-duration">转换时间</a></li>
<li><a href="#boot-features-external-config-conversion-datasize">转换数据大小</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config-validation">2.8.9。@ConfigurationProperties验证</a></li>
<li><a href="#boot-features-external-config-vs-value">2.8.10。@ConfigurationProperties与@Value</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-profiles">3。个人资料</a>
<ul class="sectlevel2">
<li><a href="#boot-features-adding-active-profiles">3.1。添加活动配置文件</a></li>
<li><a href="#boot-features-programmatically-setting-profiles">3.2。以编程方式设置配置文件</a></li>
<li><a href="#boot-features-profile-specific-configuration">3.3。特定于配置文件的配置文件</a></li>
</ul>
</li>
<li><a href="#boot-features-logging">4。记录中</a>
<ul class="sectlevel2">
<li><a href="#boot-features-logging-format">4.1。日志格式</a></li>
<li><a href="#boot-features-logging-console-output">4.2。控制台输出</a>
<ul class="sectlevel3">
<li><a href="#boot-features-logging-color-coded-output">4.2.1。颜色编码输出</a></li>
</ul>
</li>
<li><a href="#boot-features-logging-file-output">4.3。文件输出</a></li>
<li><a href="#boot-features-custom-log-levels">4.4。日志级别</a></li>
<li><a href="#boot-features-custom-log-groups">4.5。日志组</a></li>
<li><a href="#boot-features-custom-log-configuration">4.6。自定义日志配置</a></li>
<li><a href="#boot-features-logback-extensions">4.7。登录扩展</a>
<ul class="sectlevel3">
<li><a href="#profile-specific-configuration">4.7.1。特定于配置文件的配置</a></li>
<li><a href="#environment-properties">4.7.2。环境特性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-internationalization">5，国际化</a></li>
<li><a href="#boot-features-json">6。JSON格式</a>
<ul class="sectlevel2">
<li><a href="#boot-features-json-jackson">6.1。杰克逊</a></li>
<li><a href="#boot-features-json-gson">6.2。格森</a></li>
<li><a href="#boot-features-json-json-b">6.3。JSON-B</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-web-applications">7。开发Web应用程序</a>
<ul class="sectlevel2">
<li><a href="#boot-features-spring-mvc">7.1。“ Spring Web MVC框架”</a>
<ul class="sectlevel3">
<li><a href="#boot-features-spring-mvc-auto-configuration">7.1.1。Spring MVC自动配置</a></li>
<li><a href="#boot-features-spring-mvc-message-converters">7.1.2。HttpMessageConverters</a></li>
<li><a href="#boot-features-json-components">7.1.3。自定义JSON序列化器和反序列化器</a></li>
<li><a href="#boot-features-spring-message-codes">7.1.4。MessageCodesResolver</a></li>
<li><a href="#boot-features-spring-mvc-static-content">7.1.5。静态内容</a></li>
<li><a href="#boot-features-spring-mvc-welcome-page">7.1.6。欢迎页面</a></li>
<li><a href="#boot-features-spring-mvc-favicon">7.1.7。自定义图标</a></li>
<li><a href="#boot-features-spring-mvc-pathmatch">7.1.8。路径匹配和内容协商</a></li>
<li><a href="#boot-features-spring-mvc-web-binding-initializer">7.1.9。ConfigurableWebBindingInitializer</a></li>
<li><a href="#boot-features-spring-mvc-template-engines">7.1.10。模板引擎</a></li>
<li><a href="#boot-features-error-handling">7.1.11。错误处理</a>
<ul class="sectlevel4">
<li><a href="#boot-features-error-handling-custom-error-pages">自定义错误页面</a></li>
<li><a href="#boot-features-error-handling-mapping-error-pages-without-mvc">在Spring MVC之外映射错误页面</a></li>
</ul>
</li>
<li><a href="#boot-features-spring-hateoas">7.1.12。Spring HATEOAS </a></li>
<li><a href="#boot-features-cors">7.1.13。CORS支持</a></li>
</ul>
</li>
<li><a href="#boot-features-webflux">7.2。“ Spring WebFlux框架”</a>
<ul class="sectlevel3">
<li><a href="#boot-features-webflux-auto-configuration">7.2.1。Spring WebFlux自动配置</a></li>
<li><a href="#boot-features-webflux-httpcodecs">7.2.2。带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</a></li>
<li><a href="#boot-features-webflux-static-content">7.2.3。静态内容</a></li>
<li><a href="#boot-features-webflux-template-engines">7.2.4。模板引擎</a></li>
<li><a href="#boot-features-webflux-error-handling">7.2.5。错误处理</a>
<ul class="sectlevel4">
<li><a href="#boot-features-webflux-error-handling-custom-error-pages">自定义错误页面</a></li>
</ul>
</li>
<li><a href="#boot-features-webflux-web-filters">7.2.6。网页过滤器</a></li>
</ul>
</li>
<li><a href="#boot-features-jersey">7.3。JAX-RS和泽西岛</a></li>
<li><a href="#boot-features-embedded-container">7.4。嵌入式Servlet容器支持</a>
<ul class="sectlevel3">
<li><a href="#boot-features-embedded-container-servlets-filters-listeners">7.4.1。Servlet，过滤器和侦听器</a>
<ul class="sectlevel4">
<li><a href="#boot-features-embedded-container-servlets-filters-listeners-beans">将Servlet，过滤器和侦听器注册为Spring Bean</a></li>
</ul>
</li>
<li><a href="#boot-features-embedded-container-context-initializer">7.4.2。Servlet上下文初始化</a>
<ul class="sectlevel4">
<li><a href="#boot-features-embedded-container-servlets-filters-listeners-scanning">扫描Servlet，过滤器和侦听器</a></li>
</ul>
</li>
<li><a href="#boot-features-embedded-container-application-context">7.4.3。ServletWebServerApplicationContext</a></li>
<li><a href="#boot-features-customizing-embedded-containers">7.4.4。自定义嵌入式Servlet容器</a>
<ul class="sectlevel4">
<li><a href="#boot-features-programmatic-embedded-container-customization">程序定制</a></li>
<li><a href="#boot-features-customizing-configurableservletwebserverfactory-directly">直接自定义ConfigurableServletWebServerFactory</a></li>
</ul>
</li>
<li><a href="#boot-features-jsp-limitations">7.4.5。JSP局限性</a></li>
</ul>
</li>
<li><a href="#boot-features-reactive-server">7.5。嵌入式反应式服务器支持</a></li>
<li><a href="#boot-features-reactive-server-resources">7.6。反应性服务器资源配置</a></li>
</ul>
</li>
<li><a href="#boot-features-rsocket">8。插座</a>
<ul class="sectlevel2">
<li><a href="#boot-features-rsocket-strategies-auto-configuration">8.1。RSocket策略自动配置</a></li>
<li><a href="#boot-features-rsocket-server-auto-configuration">8.2。RSocket服务器自动配置</a></li>
<li><a href="#boot-features-rsocket-messaging">8.3。Spring Messaging RSocket支持</a></li>
<li><a href="#boot-features-rsocket-requester">8.4。使用以下命令调用RSocket服务<code>RSocketRequester</code></a></li>
</ul>
</li>
<li><a href="#boot-features-security">9。安全</a>
<ul class="sectlevel2">
<li><a href="#boot-features-security-mvc">9.1。MVC安全</a></li>
<li><a href="#boot-features-security-webflux">9.2。WebFlux安全</a></li>
<li><a href="#boot-features-security-oauth2">9.3。OAuth2</a>
<ul class="sectlevel3">
<li><a href="#boot-features-security-oauth2-client">9.3.1。客户</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-oauth2-common-providers">普通提供商的OAuth2客户端注册</a></li>
</ul>
</li>
<li><a href="#boot-features-security-oauth2-server">9.3.2。资源服务器</a></li>
<li><a href="#authorization-server">9.3.3。授权服务器</a></li>
</ul>
</li>
<li><a href="#boot-features-security-saml">9.4。SAML 2.0</a>
<ul class="sectlevel3">
<li><a href="#boot-features-security-saml2-relying-party">9.4.1。依赖党</a></li>
</ul>
</li>
<li><a href="#boot-features-security-actuator">9.5。执行器安全</a>
<ul class="sectlevel3">
<li><a href="#boot-features-security-csrf">9.5.1。跨站点请求伪造保护</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-sql">10。使用SQL数据库</a>
<ul class="sectlevel2">
<li><a href="#boot-features-configure-datasource">10.1。配置数据源</a>
<ul class="sectlevel3">
<li><a href="#boot-features-embedded-database-support">10.1.1。嵌入式数据库支持</a></li>
<li><a href="#boot-features-connect-to-production-database">10.1.2。连接到生产数据库</a></li>
<li><a href="#boot-features-connecting-to-a-jndi-datasource">10.1.3。连接到JNDI数据源</a></li>
</ul>
</li>
<li><a href="#boot-features-using-jdbc-template">10.2。使用JdbcTemplate</a></li>
<li><a href="#boot-features-jpa-and-spring-data">10.3。JPA和Spring Data JPA</a>
<ul class="sectlevel3">
<li><a href="#boot-features-entity-classes">10.3.1。实体类别</a></li>
<li><a href="#boot-features-spring-data-jpa-repositories">10.3.2。Spring Data JPA存储库</a></li>
<li><a href="#boot-features-creating-and-dropping-jpa-databases">10.3.3。创建和删除JPA数据库</a></li>
<li><a href="#boot-features-jpa-in-web-environment">10.3.4。在视图中打开EntityManager</a></li>
</ul>
</li>
<li><a href="#boot-features-data-jdbc">10.4。Spring Data JDBC</a></li>
<li><a href="#boot-features-sql-h2-console">10.5。使用H2的Web控制台</a>
<ul class="sectlevel3">
<li><a href="#boot-features-sql-h2-console-custom-path">10.5.1。更改H2控制台的路径</a></li>
</ul>
</li>
<li><a href="#boot-features-jooq">10.6。使用jOOQ</a>
<ul class="sectlevel3">
<li><a href="#code-generation">10.6.1。代码生成</a></li>
<li><a href="#using-dslcontext">10.6.2。使用DSLContext</a></li>
<li><a href="#jooq-sql-dialect">10.6.3。 jOOQ SQL方言</a></li>
<li><a href="#customizing-jooq">10.6.4。定制jOOQ</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-nosql">11。使用NoSQL技术</a>
<ul class="sectlevel2">
<li><a href="#boot-features-redis">11.1。雷迪斯</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-redis">11.1.1。连接到Redis</a></li>
</ul>
</li>
<li><a href="#boot-features-mongodb">11.2。MongoDB</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-mongodb">11.2.1。连接到MongoDB数据库</a></li>
<li><a href="#boot-features-mongo-template">11.2.2。MongoTemplate</a></li>
<li><a href="#boot-features-spring-data-mongodb-repositories">11.2.3。Spring Data MongoDB存储库</a></li>
<li><a href="#boot-features-mongo-embedded">11.2.4。嵌入式Mongo</a></li>
</ul>
</li>
<li><a href="#boot-features-neo4j">11.3。Neo4j</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-neo4j">11.3.1。连接到Neo4j数据库</a></li>
<li><a href="#boot-features-connecting-to-neo4j-embedded">11.3.2。使用嵌入式模式</a></li>
<li><a href="#boot-features-neo4j-ogm-native-types">11.3.3。使用本机类型</a></li>
<li><a href="#boot-features-neo4j-ogm-session">11.3.4。Neo4jSession</a></li>
<li><a href="#boot-features-spring-data-neo4j-repositories">11.3.5。Spring Data Neo4j存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-solr">11.4。索尔</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-solr">11.4.1。连接到Solr</a></li>
<li><a href="#boot-features-spring-data-solr-repositories">11.4.2。Spring Data Solr存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-elasticsearch">11.5。弹性搜索</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-elasticsearch-rest">11.5.1。使用REST客户端连接到Elasticsearch</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-reactive-rest">11.5.2。使用反应式REST客户端连接到Elasticsearch</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-jest">11.5.3。使用Jest连接到Elasticsearch</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-spring-data">11.5.4。使用Spring数据连接到Elasticsearch</a></li>
<li><a href="#boot-features-spring-data-elasticsearch-repositories">11.5.5。Spring Data Elasticsearch存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-cassandra">11.6。卡桑德拉</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-cassandra">11.6.1。连接到Cassandra</a></li>
<li><a href="#boot-features-spring-data-cassandra-repositories">11.6.2。Spring Data Cassandra存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-couchbase">11.7。Couchbase</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-couchbase">11.7.1。连接到Couchbase</a></li>
<li><a href="#boot-features-spring-data-couchbase-repositories">11.7.2。Spring Data Couchbase存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-ldap">11.8。LDAP</a>
<ul class="sectlevel3">
<li><a href="#boot-features-ldap-connecting">11.8.1。连接到LDAP服务器</a></li>
<li><a href="#boot-features-ldap-spring-data-repositories">11.8.2。Spring Data LDAP存储库</a></li>
<li><a href="#boot-features-ldap-embedded">11.8.3。嵌入式内存LDAP服务器</a></li>
</ul>
</li>
<li><a href="#boot-features-influxdb">11.9。InfluxDB</a>
<ul class="sectlevel3">
<li><a href="#boot-features-connecting-to-influxdb">11.9.1。连接到InfluxDB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-caching">12快取</a>
<ul class="sectlevel2">
<li><a href="#boot-features-caching-provider">12.1。支持的缓存提供程序</a>
<ul class="sectlevel3">
<li><a href="#boot-features-caching-provider-generic">12.1.1。泛型</a></li>
<li><a href="#boot-features-caching-provider-jcache">12.1.2。JCache（JSR-107）</a></li>
<li><a href="#boot-features-caching-provider-ehcache2">12.1.3。EhCache 2.x</a></li>
<li><a href="#boot-features-caching-provider-hazelcast">12.1.4。淡褐色</a></li>
<li><a href="#boot-features-caching-provider-infinispan">12.1.5。Infinispan</a></li>
<li><a href="#boot-features-caching-provider-couchbase">12.1.6。Couchbase</a></li>
<li><a href="#boot-features-caching-provider-redis">12.1.7。雷迪斯</a></li>
<li><a href="#boot-features-caching-provider-caffeine">12.1.8。咖啡因</a></li>
<li><a href="#boot-features-caching-provider-simple">12.1.9。简单</a></li>
<li><a href="#boot-features-caching-provider-none">12.1.10。没有</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-messaging">13讯息传递</a>
<ul class="sectlevel2">
<li><a href="#boot-features-jms">13.1。JMS</a>
<ul class="sectlevel3">
<li><a href="#boot-features-activemq">13.1.1。ActiveMQ支持</a></li>
<li><a href="#boot-features-artemis">13.1.2。Artemis支持</a></li>
<li><a href="#boot-features-jms-jndi">13.1.3。使用JNDI ConnectionFactory</a></li>
<li><a href="#boot-features-using-jms-sending">13.1.4。发送信息</a></li>
<li><a href="#boot-features-using-jms-receiving">13.1.5。接收讯息</a></li>
</ul>
</li>
<li><a href="#boot-features-amqp">13.2。AMQP</a>
<ul class="sectlevel3">
<li><a href="#boot-features-rabbitmq">13.2.1。RabbitMQ支持</a></li>
<li><a href="#boot-features-using-amqp-sending">13.2.2。发送信息</a></li>
<li><a href="#boot-features-using-amqp-receiving">13.2.3。接收讯息</a></li>
</ul>
</li>
<li><a href="#boot-features-kafka">13.3。Apache Kafka支持</a>
<ul class="sectlevel3">
<li><a href="#boot-features-kafka-sending-a-message">13.3.1。发送信息</a></li>
<li><a href="#boot-features-kafka-receiving-a-message">13.3.2。接收讯息</a></li>
<li><a href="#boot-features-kafka-streams">13.3.3。卡夫卡流</a></li>
<li><a href="#boot-features-kafka-extra-props">13.3.4。卡夫卡的其他属性</a></li>
<li><a href="#boot-features-embedded-kafka">13.3.5。使用嵌入式Kafka进行测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-resttemplate">14。使用调用REST服务<code>RestTemplate</code></a>
<ul class="sectlevel2">
<li><a href="#boot-features-resttemplate-customization">14.1。RestTemplate自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-webclient">15使用调用REST服务<code>WebClient</code></a>
<ul class="sectlevel2">
<li><a href="#boot-features-webclient-runtime">15.1。WebClient运行时</a></li>
<li><a href="#boot-features-webclient-customization">15.2。WebClient定制</a></li>
</ul>
</li>
<li><a href="#boot-features-validation">16。验证方式</a></li>
<li><a href="#boot-features-email">17。发送邮件</a></li>
<li><a href="#boot-features-jta">18岁JTA的分布式事务</a>
<ul class="sectlevel2">
<li><a href="#boot-features-jta-atomikos">18.1。使用Atomikos交易管理器</a></li>
<li><a href="#boot-features-jta-bitronix">18.2。使用Bitronix交易管理器</a></li>
<li><a href="#boot-features-jta-javaee">18.3。使用Java EE托管事务管理器</a></li>
<li><a href="#boot-features-jta-mixed-jms">18.4。混合XA和非XA JMS连接</a></li>
<li><a href="#boot-features-jta-supporting-alternative-embedded">18.5。支持替代嵌入式事务管理器</a></li>
</ul>
</li>
<li><a href="#boot-features-hazelcast">19淡褐色</a></li>
<li><a href="#boot-features-quartz">20石英调度器</a></li>
<li><a href="#boot-features-task-execution-scheduling">21任务执行和计划</a></li>
<li><a href="#boot-features-integration">22 Spring Integration </a></li>
<li><a href="#boot-features-session">23。 Spring 会议</a></li>
<li><a href="#boot-features-jmx">24通过JMX进行监视和管理</a></li>
<li><a href="#boot-features-testing">25岁测试中</a>
<ul class="sectlevel2">
<li><a href="#boot-features-test-scope-dependencies">25.1。测试范围依赖性</a></li>
<li><a href="#boot-features-testing-spring-applications">25.2。测试Spring应用程序</a></li>
<li><a href="#boot-features-testing-spring-boot-applications">25.3。测试Spring Boot应用程序</a>
<ul class="sectlevel3">
<li><a href="#boot-features-testing-spring-boot-applications-detecting-web-app-type">25.3.1。检测Web应用程序类型</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-detecting-config">25.3.2。检测测试配置</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-excluding-config">25.3.3。排除测试配置</a></li>
<li><a href="#boot-features-testing-spring-boot-application-arguments">25.3.4。使用应用程序参数</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-with-mock-environment">25.3.5。在模拟环境中进行测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-with-running-server">25.3.6。使用正在运行的服务器进行测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-customizing-web-test-client">25.3.7。自定义WebTestClient</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-jmx">25.3.8。使用JMX</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-mocking-beans">25.3.9。模拟 bean 和间谍 bean </a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">25.3.10。自动配置的测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests">25.3.11。自动配置的JSON测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests">25.3.12。自动配置的Spring MVC测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests">25.3.13。自动配置的Spring WebFlux测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test">25.3.14。自动配置的数据JPA测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test">25.3.15。自动配置的JDBC测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-data-jdbc-test">25.3.16。自动配置的数据JDBC测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jooq-test">25.3.17。自动配置的jOOQ测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-mongo-test">25.3.18。自动配置的数据MongoDB测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test">25.3.19。自动配置的数据Neo4j测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-redis-test">25.3.20。自动配置的数据Redis测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-ldap-test">25.3.21。自动配置的数据LDAP测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-client">25.3.22。自动配置的REST客户端</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs">25.3.23。自动配置的Spring REST Docs测试</a>
<ul class="sectlevel4">
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-mock-mvc">使用Mock MVC自动配置的Spring REST Docs测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-web-test-client">使用WebTestClient自动配置的Spring REST Docs测试</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-rest-assured">具有REST保证的自动配置的Spring REST文档测试</a></li>
</ul>
</li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-auto-configured-additional-auto-config">25.3.24。额外的自动配置和切片</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-testing-user-configuration">25.3.25。用户配置和切片</a></li>
<li><a href="#boot-features-testing-spring-boot-applications-with-spock">25.3.26。使用Spock测试Spring Boot应用程序</a></li>
</ul>
</li>
<li><a href="#boot-features-test-utilities">25.4。测试工具</a>
<ul class="sectlevel3">
<li><a href="#boot-features-configfileapplicationcontextinitializer-test-utility">25.4.1。ConfigFileApplicationContextInitializer</a></li>
<li><a href="#boot-features-test-property-values">25.4.2。TestPropertyValues</a></li>
<li><a href="#boot-features-output-capture-test-utility">25.4.3。OutputCapture</a></li>
<li><a href="#boot-features-rest-templates-test-utility">25.4.4。TestRestTemplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-websockets">26Web套接字</a></li>
<li><a href="#boot-features-webservices">27。网页服务</a>
<ul class="sectlevel2">
<li><a href="#boot-features-webservices-template">27.1。使用调用Web服务<code>WebServiceTemplate</code></a></li>
</ul>
</li>
<li><a href="#boot-features-developing-auto-configuration">28岁创建自己的自动配置</a>
<ul class="sectlevel2">
<li><a href="#boot-features-understanding-auto-configured-beans">28.1。了解自动配置的Bean</a></li>
<li><a href="#boot-features-locating-auto-configuration-candidates">28.2。查找自动配置候选人</a></li>
<li><a href="#boot-features-condition-annotations">28.3。条件注释</a>
<ul class="sectlevel3">
<li><a href="#boot-features-class-conditions">28.3.1。上课条件</a></li>
<li><a href="#boot-features-bean-conditions">28.3.2。 bean 条件</a></li>
<li><a href="#boot-features-property-conditions">28.3.3。物业条件</a></li>
<li><a href="#boot-features-resource-conditions">28.3.4。资源条件</a></li>
<li><a href="#boot-features-web-application-conditions">28.3.5。Web应用条件</a></li>
<li><a href="#boot-features-spel-conditions">28.3.6。SpEL表达条件</a></li>
</ul>
</li>
<li><a href="#boot-features-test-autoconfig">28.4。测试您的自动配置</a>
<ul class="sectlevel3">
<li><a href="#simulating-a-web-context">28.4.1。模拟Web上下文</a></li>
<li><a href="#overriding-the-classpath">28.4.2。覆盖类路径</a></li>
</ul>
</li>
<li><a href="#boot-features-custom-starter">28.5。创建自己的入门</a>
<ul class="sectlevel3">
<li><a href="#boot-features-custom-starter-naming">28.5.1。命名</a></li>
<li><a href="#boot-features-custom-starter-configuration-keys">28.5.2。配置键</a></li>
<li><a href="#boot-features-custom-starter-module-autoconfigure">28.5.3。 <code>autoconfigure</code> 模组</a></li>
<li><a href="#boot-features-custom-starter-module-starter">28.5.4。启动模块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-kotlin">29。Kotlin支持</a>
<ul class="sectlevel2">
<li><a href="#boot-features-kotlin-requirements">29.1。要求</a></li>
<li><a href="#boot-features-kotlin-null-safety">29.2。Null-safety</a></li>
<li><a href="#boot-features-kotlin-api">29.3。Kotlin API</a>
<ul class="sectlevel3">
<li><a href="#boot-features-kotlin-api-runapplication">29.3.1。 runApplication</a></li>
<li><a href="#boot-features-kotlin-api-extensions">29.3.2。扩展名</a></li>
</ul>
</li>
<li><a href="#boot-features-kotlin-dependency-management">29.4。依赖管理</a></li>
<li><a href="#boot-features-kotlin-configuration-properties">29.5。<code>@ConfigurationProperties</code></a></li>
<li><a href="#boot-features-kotlin-testing">29.6。测试中</a></li>
<li><a href="#boot-features-kotlin-resources">29.7。资源资源</a>
<ul class="sectlevel3">
<li><a href="#boot-features-kotlin-resources-further-reading">29.7.1。进一步阅读</a></li>
<li><a href="#boot-features-kotlin-resources-examples">29.7.2。例子</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-whats-next">30岁接下来要读什么</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本节将深入介绍Spring Boot。在这里，您可以了解可能要使用和自定义的关键功能。如果您尚未这样做，则可能需要阅读“ <a href="using-spring-boot.html#using-boot">Getting</a> <a href="getting-started.html#getting-started">-started.html</a> ”和“ <a href="using-spring-boot.html#using-boot">using-spring-boot.html</a> ”部分，以便您有足够的基础知识。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-spring-application"><a class="anchor" href="#boot-features-spring-application"></a> 1。Spring应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>SpringApplication</code>类提供了一种便捷的方式来引导从Windows启动的Spring应用程序<code>main()</code>方法。在许多情况下，您可以委派给静态<code>SpringApplication.run</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    SpringApplication.run(MySpringConfiguration.class, args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您的应用程序启动时，您应该看到类似于以下输出的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v2.2.1.RELEASE

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>INFO</code>显示日志消息，包括一些相关的启动详细信息，例如启动应用程序的用户。如果您需要的日志级别不是<code>INFO</code> ，您可以按照“ <a href="#boot-features-custom-log-levels">日志级别”中的说明进行设置</a> 。</p>
</div>
<div class="sect2">
<h3 id="boot-features-startup-failure"><a class="anchor" href="#boot-features-startup-failure"></a> 1.1。启动失败</h3>
<div class="paragraph">
<p>如果您的应用程序无法启动，请注册<code>FailureAnalyzers</code>有机会提供专门的错误消息和解决该问题的具体措施。例如，如果您在端口上启动Web应用程序<code>8080</code>并且该端口已被使用，您应该看到类似以下消息的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>***************************
APPLICATION FAILED TO START
***************************

Description:

Embedded servlet container failed to start. Port 8080 was already in use.

Action:

Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot提供了众多<code>FailureAnalyzer</code>实现，您可以<a href="howto.html#howto-failure-analyzer">添加自己的</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果没有故障分析器能够处理异常，您仍然可以显示完整情况报告，以更好地了解出了什么问题。为此，您需要<a href="#boot-features-external-config">启用<code>debug</code>属性</a>或<a href="#boot-features-custom-log-levels">启用<code>DEBUG</code>记录</a> <code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code> 。</p>
</div>
<div class="paragraph">
<p>例如，如果您正在使用来运行应用程序<code>java -jar</code> ，您可以启用<code>debug</code>属性如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-lazy-initialization"><a class="anchor" href="#boot-features-lazy-initialization"></a> 1.2。延迟初始化</h3>
<div class="paragraph">
<p><code>SpringApplication</code>允许延迟初始化应用程序。启用惰性初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。因此，启用延迟初始化可以减少启动应用程序所需的时间。在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。</p>
</div>
<div class="paragraph">
<p>延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。如果错误配置的Bean延迟初始化，则启动期间将不再发生故障，并且只有在初始化Bean时问题才会变得明显。还必须注意确保JVM具有足够的内存来容纳所有应用程序的bean，而不仅仅是启动期间初始化的bean。由于这些原因，默认情况下不会启用延迟初始化，因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。</p>
</div>
<div class="paragraph">
<p>可以使用<code>lazyInitialization</code>方法开启<code>SpringApplicationBuilder</code>或者<code>setLazyInitialization</code>方法开启<code>SpringApplication</code> 。另外，也可以使用<code>spring.main.lazy-initialization</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.main.lazy-initialization=true</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要在对其余应用程序使用延迟初始化时禁用某些Bean的延迟初始化，则可以使用以下命令将它们的延迟属性显式设置为false。 <code>@Lazy(false)</code>注解。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-banner"><a class="anchor" href="#boot-features-banner"></a> 1.3。自定义横幅</h3>
<div class="paragraph">
<p>启动时打印的横幅可以通过添加一个<code>banner.txt</code>文件到您的类路径或通过设置<code>spring.banner.location</code>属性到此类文件的位置。如果文件的编码不是UTF-8，则可以设置<code>spring.banner.charset</code> 。除了文本文件，您还可以添加<code>banner.gif</code> ， <code>banner.jpg</code> ， 要么<code>banner.png</code>图片文件到您的类路径或设置<code>spring.banner.image.location</code>属性。图像将转换为ASCII艺术作品并打印在任何文字横幅上方。</p>
</div>
<div class="paragraph">
<p>在你里面<code>banner.txt</code>文件，则可以使用以下任意占位符：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表格1。标语变量</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">变量</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您的应用程序的版本号，在中声明<code>MANIFEST.MF</code> 。例如， <code>Implementation-Version: 1.0</code>打印为<code>1.0</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您的应用程序的版本号，在中声明<code>MANIFEST.MF</code>并格式化以显示（用括号括起来并以<code>v</code> ）。例如<code>(v1.0)</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您正在使用的Spring Boot版本。例如<code>2.2.1.RELEASE</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您正在使用的Spring Boot版本，其格式用于显示（用括号括起来，并用前缀<code>v</code> ）。例如<code>(v2.2.1.RELEASE)</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${Ansi.NAME}</code> （要么<code>${AnsiColor.NAME}</code> ， <code>${AnsiBackground.NAME}</code> ， <code>${AnsiStyle.NAME}</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">哪里<code>NAME</code>是ANSI转义代码的名称。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a>有关详细信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.title}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您的应用程序的标题，如<code>MANIFEST.MF</code> 。例如<code>Implementation-Title: MyApp</code>打印为<code>MyApp</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">的<code>SpringApplication.setBanner(…​)</code>如果要以编程方式生成横幅，则可以使用此方法。使用<code>org.springframework.boot.Banner</code>界面并实现自己的<code>printBanner()</code>方法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您也可以使用<code>spring.main.banner-mode</code>属性，以确定是否必须在其上打印横幅<code>System.out</code> （ <code>console</code> ），发送给已配置的记录器（ <code>log</code> ），或根本不产生（ <code>off</code> ）。</p>
</div>
<div class="paragraph">
<p>打印的横幅以以下名称注册为单例bean： <code>springBootBanner</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-customizing-spring-application"><a class="anchor" href="#boot-features-customizing-spring-application"></a> 1.4。自定义SpringApplication</h3>
<div class="paragraph">
<p>如果<code>SpringApplication</code>默认值不符合您的喜好，您可以创建一个本地实例并对其进行自定义。例如，要关闭横幅，您可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">构造函数参数传递给<code>SpringApplication</code>是Spring Bean的配置源。在大多数情况下，这些都是对<code>@Configuration</code>类，但它们也可以是对XML配置或应扫描的程序包的引用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>也可以配置<code>SpringApplication</code>通过使用<code>application.properties</code>文件。有关详细信息，请参见<em><a href="#boot-features-external-config">外部化配置</a></em> 。</p>
</div>
<div class="paragraph">
<p>有关配置选项的完整列表，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/SpringApplication.html"><code>SpringApplication</code> Javadoc</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-fluent-builder-api"><a class="anchor" href="#boot-features-fluent-builder-api"></a> 1.5。Fluent Builder API</h3>
<div class="paragraph">
<p>如果您需要构建一个<code>ApplicationContext</code>层次结构（具有父/子关系的多个上下文），或者如果您更喜欢使用“流利的”构建器API，则可以使用<code>SpringApplicationBuilder</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>SpringApplicationBuilder</code>让您将多个方法调用链接在一起，并包括<code>parent</code>和<code>child</code>使您可以创建层次结构的方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">创建广告素材时有一些限制<code>ApplicationContext</code>层次结构。例如，Web组件<strong>必须</strong>包含在子上下文中，并且相同<code>Environment</code>用于父级和子级上下文。见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a>的完整详细信息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-events-and-listeners"><a class="anchor" href="#boot-features-application-events-and-listeners"></a> 1.6。应用程序事件和监听器</h3>
<div class="paragraph">
<p>除了通常的Spring Framework事件外，例如<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a> ， 一种<code>SpringApplication</code>发送一些其他应用程序事件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实际上，某些事件是在<code>ApplicationContext</code>已创建，因此您无法将监听器注册为<code>@Bean</code> 。您可以在<code>SpringApplication.addListeners(…​)</code>方法或<code>SpringApplicationBuilder.listeners(…​)</code>方法。</p>
</div>
<div class="paragraph">
<p>如果您希望这些监听器自动注册，无论创建应用程序的方式如何，都可以添加一个<code>META-INF/spring.factories</code>文件到您的项目，并通过使用<code>org.springframework.context.ApplicationListener</code>键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.context.ApplicationListener=com.example.project.MyListener</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>应用程序事件在您的应用程序运行时按以下顺序发送：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一个<code>ApplicationStartingEvent</code>在运行开始时但在进行任何处理之前（侦听器和初始化器的注册除外）发送。</p>
</li>
<li>
<p>一个<code>ApplicationEnvironmentPreparedEvent</code>当<code>Environment</code>要在上下文中使用的对象是已知的，但是在创建上下文之前。</p>
</li>
<li>
<p>一个<code>ApplicationContextInitializedEvent</code>当<code>ApplicationContext</code>已准备好，并且已调用ApplicationContextInitializers，但是在加载任何bean定义之前。</p>
</li>
<li>
<p>一个<code>ApplicationPreparedEvent</code>在刷新开始之前但在加载bean定义之后发送。</p>
</li>
<li>
<p>一个<code>ApplicationStartedEvent</code>在刷新上下文之后但在调用任何应用程序和命令行运行程序之前发送。</p>
</li>
<li>
<p>一个<code>ApplicationReadyEvent</code>在调用任何应用程序和命令行运行程序之后发送。它指示该应用程序已准备就绪，可以处理请求。</p>
</li>
<li>
<p>一个<code>ApplicationFailedEvent</code>如果启动时出现异常，则发送该消息。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面的清单仅包括<code>SpringApplicationEvent</code>绑定到<code>SpringApplication</code> 。除了这些，以下事件也将在之后发布。 <code>ApplicationPreparedEvent</code>和之前<code>ApplicationStartedEvent</code> ：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一种<code>ContextRefreshedEvent</code>当一个<code>ApplicationContext</code>刷新。</p>
</li>
<li>
<p>一种<code>WebServerInitializedEvent</code>是在<code>WebServer</code>准备好了。
<code>ServletWebServerInitializedEvent</code>和<code>ReactiveWebServerInitializedEvent</code>分别是servlet和反应式变量。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您通常不需要使用应用程序事件，但是很容易知道它们的存在。在内部，Spring Boot使用事件来处理各种任务。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>应用程序事件是通过使用Spring Framework的事件发布机制发送的。此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。因此，如果您的应用程序使用<code>SpringApplication</code>在实例中，侦听器可能会收到同一类型的应用程序事件的多个实例。</p>
</div>
<div class="paragraph">
<p>为了使您的侦听器能够区分其上下文的事件和后代上下文的事件，它应请求注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现来注入上下文<code>ApplicationContextAware</code>或者，如果侦听器是bean，则使用<code>@Autowired</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-web-environment"><a class="anchor" href="#boot-features-web-environment"></a> 1.7。网络环境</h3>
<div class="paragraph">
<p>一种<code>SpringApplication</code>尝试创建正确的类型<code>ApplicationContext</code>代表你。用于确定<code>WebApplicationType</code>很简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果存在Spring MVC，则<code>AnnotationConfigServletWebServerApplicationContext</code>用来</p>
</li>
<li>
<p>如果不存在Spring MVC且存在Spring WebFlux，则<code>AnnotationConfigReactiveWebServerApplicationContext</code>用来</p>
</li>
<li>
<p>除此以外， <code>AnnotationConfigApplicationContext</code>用来</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着如果您正在使用Spring MVC和新的<code>WebClient</code>如果在同一应用程序中使用Spring WebFlux，则默认使用Spring MVC。您可以通过调用轻松地覆盖它<code>setWebApplicationType(WebApplicationType)</code> 。</p>
</div>
<div class="paragraph">
<p>也可以完全控制<code>ApplicationContext</code>调用使用的类型<code>setApplicationContextClass(…​)</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">通常最好打电话<code>setWebApplicationType(WebApplicationType.NONE)</code>使用时<code>SpringApplication</code>在JUnit测试中。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-arguments"><a class="anchor" href="#boot-features-application-arguments"></a> 1.8。访问应用程序参数</h3>
<div class="paragraph">
<p>如果您需要访问传递给的应用程序参数<code>SpringApplication.run(…​)</code> ，您可以注入<code>org.springframework.boot.ApplicationArguments</code> bean 。的<code>ApplicationArguments</code>介面可存取原始资料<code>String[]</code>参数以及解析<code>option</code>和<code>non-option</code>参数，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;

@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List&lt;String&gt; files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Boot还注册了一个<code>CommandLinePropertySource</code>与 Spring <code>Environment</code> 。这样，您还可以通过使用<code>@Value</code>注解。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-command-line-runner"><a class="anchor" href="#boot-features-command-line-runner"></a> 1.9。使用ApplicationRunner或CommandLineRunner</h3>
<div class="paragraph">
<p>如果您需要运行一些特定的代码， <code>SpringApplication</code>已经开始，您可以实施<code>ApplicationRunner</code>要么<code>CommandLineRunner</code>接口。两个接口以相同的方式工作，并提供一个<code>run</code>方法，在之前被称为<code>SpringApplication.run(…​)</code>完成。</p>
</div>
<div class="paragraph">
<p>的<code>CommandLineRunner</code>接口提供了作为简单字符串数组访问应用程序参数的权限，而<code>ApplicationRunner</code>使用<code>ApplicationArguments</code>界面已在前面讨论过。以下示例显示了<code>CommandLineRunner</code>与一个<code>run</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner {

    public void run(String... args) {
        // Do something...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果几个<code>CommandLineRunner</code>要么<code>ApplicationRunner</code>定义了必须按特定顺序调用的bean，此外，您还可以实现<code>org.springframework.core.Ordered</code>界面或使用<code>org.springframework.core.annotation.Order</code>注解。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-exit"><a class="anchor" href="#boot-features-application-exit"></a> 1.10。申请退出</h3>
<div class="paragraph">
<p>每<code>SpringApplication</code>向JVM注册一个关闭钩子，以确保<code>ApplicationContext</code>退出时正常关闭。所有标准的Spring生命周期回调（例如<code>DisposableBean</code>接口或<code>@PreDestroy</code>注释）可以使用。</p>
</div>
<div class="paragraph">
<p>此外，bean可能会实施<code>org.springframework.boot.ExitCodeGenerator</code>接口，如果他们希望在返回时返回特定的退出代码<code>SpringApplication.exit()</code>叫做。然后可以将此退出代码传递给<code>System.exit()</code>将其作为状态码返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class ExitCodeApplication {

    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -&gt; 42;
    }

    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外， <code>ExitCodeGenerator</code>接口可以通过异常实现。当遇到这样的异常时，Spring Boot返回已实现的退出代码。 <code>getExitCode()</code>方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-admin"><a class="anchor" href="#boot-features-application-admin"></a> 1.11。管理员功能</h3>
<div class="paragraph">
<p>通过指定以下选项，可以为应用程序启用与管理员相关的功能<code>spring.application.admin.enabled</code>属性。这暴露了<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a>在平台上<code>MBeanServer</code> 。您可以使用此功能来远程管理Spring Boot应用程序。此功能对于任何服务包装器实现也可能很有用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您想知道应用程序在哪个HTTP端口上运行，请通过以下键获取属性： <code>local.server.port</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-external-config"><a class="anchor" href="#boot-features-external-config"></a> 2。外部化配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot使您可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。您可以使用属性文件，YAML文件，环境变量和命令行参数来外部化配置。可以使用以下属性将属性值直接注入到您的bean中： <code>@Value</code>注释，通过Spring的<code>Environment</code>抽象，或通过<a href="#boot-features-external-config-typesafe-configuration-properties">绑定到结构化对象</a> <code>@ConfigurationProperties</code> 。</p>
</div>
<div class="paragraph">
<p>Spring Boot使用非常特殊的<code>PropertySource</code>旨在合理地覆盖价值的秩序。按以下顺序考虑属性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="using-spring-boot.html#using-boot-devtools-globalsettings">Devtools中的全局设置属性</a> <code>$HOME/.config/spring-boot</code> devtools处于活动状态时的文件夹。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a>测试中的注释。</p>
</li>
<li>
<p><code>properties</code>测试中的属性。适用于<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a>以及<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">用于测试应用程序特定部分</a>的<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试注释</a> 。</p>
</li>
<li>
<p>命令行参数。</p>
</li>
<li>
<p>来自的属性<code>SPRING_APPLICATION_JSON</code> （嵌入在环境变量或系统属性中的内联JSON）。</p>
</li>
<li>
<p><code>ServletConfig</code>初始化参数。</p>
</li>
<li>
<p><code>ServletContext</code>初始化参数。</p>
</li>
<li>
<p>来自的JNDI属性<code>java:comp/env</code> 。</p>
</li>
<li>
<p>Java系统属性（ <code>System.getProperties()</code> ）。</p>
</li>
<li>
<p>操作系统环境变量。</p>
</li>
<li>
<p>一种<code>RandomValuePropertySource</code>仅在<code>random.*</code> 。</p>
</li>
<li>
<p>打包的jar之外的<a href="#boot-features-external-config-profile-specific-properties">特定于配置文件的应用程序属性</a> （ <code>application-{profile}.properties</code>和YAML变体）。</p>
</li>
<li>
<p>打包在jar中<a href="#boot-features-external-config-profile-specific-properties">的特定于配置文件的应用程序属性</a> （ <code>application-{profile}.properties</code>和YAML变体）。</p>
</li>
<li>
<p>包装好的jar之外的应用程序属性（ <code>application.properties</code>和YAML变体）。</p>
</li>
<li>
<p>打包在jar中的应用程序属性（ <code>application.properties</code>和YAML变体）。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>您的注释<code>@Configuration</code>类。</p>
</li>
<li>
<p>默认属性（通过设置指定<code>SpringApplication.setDefaultProperties</code> ）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了提供具体的示例，假设您开发了一个<code>@Component</code>使用一个<code>name</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean {

    @Value("${name}")
    private String name;

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在您的应用程序类路径上（例如，在jar中），您可以<code>application.properties</code>提供合理的默认属性值的文件<code>name</code> 。在新环境中运行时， <code>application.properties</code>可以在jar外部提供文件，以覆盖<code>name</code> 。对于一次性测试，您可以使用特定的命令行开关启动（例如， <code>java -jar app.jar --name="Spring"</code> ）。</p>
</div>
<div id="boot-features-external-config-application-json" class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>的<code>SPRING_APPLICATION_JSON</code>属性可以在命令行中提供环境变量。例如，您可以在UN * X shell中使用以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您最终得到<code>acme.name=test</code>在 Spring <code>Environment</code> 。您还可以提供JSON作为<code>spring.application.json</code>在系统属性中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用命令行参数来提供JSON，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --spring.application.json='{"name":"test"}'</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以将JSON作为JNDI变量提供，如下所示： <code>java:comp/env/spring.application.json</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-random-values"><a class="anchor" href="#boot-features-external-config-random-values"></a> 2.1。配置随机值</h3>
<div class="paragraph">
<p>的<code>RandomValuePropertySource</code>对于将随机值（例如，输入到机密或测试用例中）有用。它可以产生整数，longs，uuid或字符串，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>random.int*</code>语法是<code>OPEN value (,max) CLOSE</code>在哪里<code>OPEN,CLOSE</code>是任何字符和<code>value,max</code>是整数。如果<code>max</code>提供，然后<code>value</code>是最小值， <code>max</code>是最大值（不包括）。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-command-line-args"><a class="anchor" href="#boot-features-external-config-command-line-args"></a> 2.2。访问命令行属性</h3>
<div class="paragraph">
<p>默认， <code>SpringApplication</code>转换任何命令行选项参数（即，以开头的参数<code>--</code> ， 如<code>--server.port=9000</code> ）到<code>property</code>并将它们添加到 Spring <code>Environment</code> 。如前所述，命令行属性始终优先于其他属性源。</p>
</div>
<div class="paragraph">
<p>如果您不想将命令行属性添加到<code>Environment</code> ，您可以使用禁用它们<code>SpringApplication.setAddCommandLineProperties(false)</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-application-property-files"><a class="anchor" href="#boot-features-external-config-application-property-files"></a> 2.3。应用程序属性文件</h3>
<div class="paragraph">
<p><code>SpringApplication</code>从加载属性<code>application.properties</code>文件在以下位置并将其添加到Spring <code>Environment</code> ：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一种<code>/config</code>当前目录的子目录</p>
</li>
<li>
<p>当前目录</p>
</li>
<li>
<p>类路径<code>/config</code>包</p>
</li>
<li>
<p>类路径根</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该列表按优先级排序（在列表较高位置定义的属性会覆盖在较低位置定义的属性）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以<a href="#boot-features-external-config-yaml">使用YAML（'.yml'）文件</a>来替代'.properties'。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果你不喜欢<code>application.properties</code>作为配置文件名，您可以通过指定一个<code>spring.config.name</code>环境属性。您还可以通过使用<code>spring.config.location</code>环境属性（这是目录位置或文件路径的逗号分隔列表）。下面的示例演示如何指定其他文件名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.name=myproject</pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何指定两个位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<code>spring.config.name</code>和<code>spring.config.location</code>用于非常早地确定必须加载哪些文件。必须将它们定义为环境属性（通常是OS环境变量，系统属性或命令行参数）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果<code>spring.config.location</code>包含目录（而不是文件），它们应该以<code>/</code> （并在运行时附加从生成的名称<code>spring.config.name</code>加载之前，包括特定于配置文件的文件名）。在中指定的文件<code>spring.config.location</code>按原样使用，不支持特定于配置文件的变体，并且被任何特定于配置文件的属性覆盖。</p>
</div>
<div class="paragraph">
<p>配置位置以相反的顺序搜索。默认情况下，配置的位置是<code>classpath:/,classpath:/config/,file:./,file:./config/</code> 。结果搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用来配置自定义配置位置时<code>spring.config.location</code> ，它们将替换默认位置。例如，如果<code>spring.config.location</code>配置了值<code>classpath:/custom-config/,file:./custom-config/</code> ，搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>或者，当使用以下命令配置自定义配置位置时<code>spring.config.additional-location</code> ，除了默认位置外，还使用它们。在默认位置之前搜索其他位置。例如，如果<code>classpath:/custom-config/,file:./custom-config/</code>配置后，搜索顺序变为：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>通过此搜索顺序，您可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。您可以在以下位置为应用程序提供默认值<code>application.properties</code> （或您选择的其他任何基本名称<code>spring.config.name</code> ）的默认位置之一。然后，可以在运行时使用位于自定义位置之一的其他文件覆盖这些默认值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用环境变量而不是系统属性，则大多数操作系统都不允许使用句点分隔的键名，但是您可以使用下划线代替（例如， <code>SPRING_CONFIG_NAME</code>代替<code>spring.config.name</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的应用程序在容器中运行，则JNDI属性（在<code>java:comp/env</code> ）或Servlet上下文初始化参数可以代替环境变量或系统属性使用，也可以使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-profile-specific-properties"><a class="anchor" href="#boot-features-external-config-profile-specific-properties"></a> 2.4。特定于配置文件的属性</h3>
<div class="paragraph">
<p>此外<code>application.properties</code>文件，还可以使用以下命名约定来定义特定于配置文件的属性： <code>application-{profile}.properties</code> 。的<code>Environment</code>具有一组默认配置文件（默认情况下， <code>[default]</code> ）（如果未设置有效的配置文件）。换句话说，如果未明确激活任何配置文件，则来自<code>application-default.properties</code>已加载。</p>
</div>
<div class="paragraph">
<p>特定于配置文件的属性从与标准位置相同的位置加载<code>application.properties</code> ，无论配置文件专用文件是在打包jar的内部还是外部，配置文件专用文件始终会覆盖非特定文件。</p>
</div>
<div class="paragraph">
<p>如果指定了多个配置文件，则采用后赢策略。例如，由<code>spring.profiles.active</code>属性添加到通过<code>SpringApplication</code>因此，API优先。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您在中指定了任何文件<code>spring.config.location</code> ，则不考虑这些文件的特定于配置文件的变体。使用目录<code>spring.config.location</code>如果您还想使用特定于配置文件的属性。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-placeholders-in-properties"><a class="anchor" href="#boot-features-external-config-placeholders-in-properties"></a> 2.5。属性中的占位符</h3>
<div class="paragraph">
<p>中的值<code>application.properties</code>通过现有过滤<code>Environment</code>使用它们时，因此您可以参考以前定义的值（例如，从“系统”属性中）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.name=MyApp
app.description=${app.name} is a Spring Boot application</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您还可以使用这种技术来创建现有Spring Boot属性的“简短”变体。有关详细信息，请参见<em><a href="howto.html#howto-use-short-command-line-arguments">howto.html操作</a></em>方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-encrypting-properties"><a class="anchor" href="#boot-features-encrypting-properties"></a> 2.6。加密属性</h3>
<div class="paragraph">
<p>Spring Boot不提供对加密属性值的任何内置支持，但是，它提供了修改Spring中包含的值所必需的挂钩点<code>Environment</code> 。的<code>EnvironmentPostProcessor</code>介面可让您操控<code>Environment</code>在应用程序启动之前。有关详细信息，请参见<a href="howto.html#howto-customize-the-environment-or-application-context">howto.html</a> 。</p>
</div>
<div class="paragraph">
<p>如果您正在寻找一种安全的方式来存储凭据和密码， <a href="https://cloud.spring.io/spring-cloud-vault/">Spring Cloud Vault</a>项目提供了对在<a href="https://www.vaultproject.io/">HashiCorp Vault中</a>存储外部化配置的支持。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-yaml"><a class="anchor" href="#boot-features-external-config-yaml"></a> 2.7。使用YAML代替属性</h3>
<div class="paragraph">
<p><a href="https://yaml.org">YAML</a>是JSON的超集，因此是一种用于指定层次结构配置数据的便捷格式。的<code>SpringApplication</code>只要在类路径上具有<a href="https://bitbucket.org/asomov/snakeyaml">SnakeYAML</a>库，该类就会自动支持YAML作为属性的替代方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用“入门”，则SnakeYAML将自动由<code>spring-boot-starter</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-loading-yaml"><a class="anchor" href="#boot-features-external-config-loading-yaml"></a> 2.7.1。加载YAML</h4>
<div class="paragraph">
<p>Spring Framework提供了两个方便的类，可用于加载YAML文档。的<code>YamlPropertiesFactoryBean</code>将YAML加载为<code>Properties</code>和<code>YamlMapFactoryBean</code>将YAML加载为<code>Map</code> 。</p>
</div>
<div class="paragraph">
<p>例如，考虑以下YAML文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">environments:
    dev:
        url: https://dev.example.com
        name: Developer Setup
    prod:
        url: https://another.example.com
        name: My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>YAML列表表示为带有<code>[index]</code>解引用。例如，考虑以下YAML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">my:
   servers:
       - dev.example.com
       - another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">my.servers[0]=dev.example.com
my.servers[1]=another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用Spring Boot绑定到类似的属性<code>Binder</code>实用程序（这是什么<code>@ConfigurationProperties</code>确实），您需要在目标Bean类型中具有一个属性<code>java.util.List</code> （要么<code>Set</code> ），则您需要提供设置器或使用可变值对其进行初始化。例如，以下示例绑定到前面显示的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties(prefix="my")
public class Config {

    private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();

    public List&lt;String&gt; getServers() {
        return this.servers;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-exposing-yaml-to-spring"><a class="anchor" href="#boot-features-external-config-exposing-yaml-to-spring"></a> 2.7.2。在Spring环境中将YAML公开为属性</h4>
<div class="paragraph">
<p>的<code>YamlPropertySourceLoader</code>类可用于将YAML公开为<code>PropertySource</code>在 Spring <code>Environment</code> 。这样做可以让您使用<code>@Value</code>使用占位符语法的注释来访问YAML属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-multi-profile-yaml"><a class="anchor" href="#boot-features-external-config-multi-profile-yaml"></a> 2.7.3。多配置文件的YAML文档</h4>
<div class="paragraph">
<p>您可以使用以下命令在一个文件中指定多个特定于配置文件的YAML文档： <code>spring.profiles</code>指示文档何时适用的键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
    address: 192.168.1.100
---
spring:
    profiles: development
server:
    address: 127.0.0.1
---
spring:
    profiles: production &amp; eu-central
server:
    address: 192.168.1.120</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果<code>development</code>个人资料处于活动状态， <code>server.address</code>财产是<code>127.0.0.1</code> 。同样，如果<code>production</code> <strong>和</strong> <code>eu-central</code>配置文件处于活动状态， <code>server.address</code>财产是<code>192.168.1.120</code> 。如果<code>development</code> ， <code>production</code>和<code>eu-central</code>配置文件<strong>未</strong>启用，则该属性的值为<code>192.168.1.100</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>spring.profiles</code>因此可以包含一个简单的配置文件名称（例如<code>production</code> ）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production & (eu-central | eu-west)</code> 。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java">参考指南</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果在启动应用程序上下文时未明确激活任何活动，则会激活默认配置文件。因此，在以下YAML中，我们为<code>spring.security.user.password</code> <strong>仅</strong>在“默认”配置文件中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: default
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>而在以下示例中，始终设置密码是因为该密码未附加到任何配置文件，并且必须根据需要在所有其他配置文件中将其显式重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
  port: 8000
spring:
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用<code>spring.profiles</code>元素可以选择使用<code>!</code>字符。如果为单个文档指定了否定配置文件和非否定配置文件，则至少一个非否定配置文件必须匹配，并且否定配置文件不能匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-yaml-shortcomings"><a class="anchor" href="#boot-features-external-config-yaml-shortcomings"></a> 2.7.4。YAML的缺点</h4>
<div class="paragraph">
<p>无法使用来加载YAML文件<code>@PropertySource</code>注解。因此，在需要以这种方式加载值的情况下，需要使用属性文件。</p>
</div>
<div class="paragraph">
<p>在特定于配置文件的YAML文件中使用多YAML文档语法可能会导致意外行为。例如，考虑文件中的以下配置：</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: "!test"
  security:
    user:
      password: "secret"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用参数运行应用程序<code>--spring.profiles.active=dev</code>你可能期望<code>security.user.password</code>设置为“秘密”，但事实并非如此。</p>
</div>
<div class="paragraph">
<p>嵌套文档将被过滤，因为主文件名为<code>application-dev.yml</code> 。它已经被认为是特定于配置文件的，并且嵌套文档将被忽略。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们建议您不要混用特定于配置文件的YAML文件和多个YAML文档。坚持只使用其中之一。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-typesafe-configuration-properties"><a class="anchor" href="#boot-features-external-config-typesafe-configuration-properties"></a> 2.8。类型安全的配置属性</h3>
<div class="paragraph">
<p>使用<code>@Value("${property}")</code>用于注入配置属性的注释有时会很麻烦，尤其是当您使用多个属性或数据本质上是分层的时。Spring Boot提供了一种使用属性的替代方法，该属性使强类型的Bean可以管理和验证应用程序的配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">又见<a href="#boot-features-external-config-vs-value">之间的差异<code>@Value</code>和类型安全的配置属性</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-java-bean-binding"><a class="anchor" href="#boot-features-external-config-java-bean-binding"></a> 2.8.1。JavaBean属性绑定</h4>
<div class="paragraph">
<p>可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("acme")
public class AcmeProperties {

    private boolean enabled;

    private InetAddress remoteAddress;

    private final Security security = new Security();

    public boolean isEnabled() { ... }

    public void setEnabled(boolean enabled) { ... }

    public InetAddress getRemoteAddress() { ... }

    public void setRemoteAddress(InetAddress remoteAddress) { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private String username;

        private String password;

        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton("USER"));

        public String getUsername() { ... }

        public void setUsername(String username) { ... }

        public String getPassword() { ... }

        public void setPassword(String password) { ... }

        public List&lt;String&gt; getRoles() { ... }

        public void setRoles(List&lt;String&gt; roles) { ... }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的POJO定义了以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acme.enabled</code> ，值为<code>false</code>默认。</p>
</li>
<li>
<p><code>acme.remote-address</code> ，其类型可以从<code>String</code> 。</p>
</li>
<li>
<p><code>acme.security.username</code> ，其嵌套的“安全”对象的名称由属性的名称确定。特别是，返回类型根本不使用，可能已经<code>SecurityProperties</code> 。</p>
</li>
<li>
<p><code>acme.security.password</code> 。</p>
</li>
<li>
<p><code>acme.security.roles</code> ，并附有<code>String</code>默认为<code>USER</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot自动配置大量使用<code>@ConfigurationProperties</code>用于轻松配置自动配置的Bean。与自动配置类类似， <code>@ConfigurationProperties</code> Spring Boot中可用的类仅供内部使用。通过属性文件，YAML文件，环境变量等配置的映射到该类的属性是公共API，但该类本身的内容并不意味着可以直接使用。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种安排依赖于默认的空构造函数，并且getter和setter通常是强制性的，因为绑定是通过标准Java Beans属性描述符进行的，就像在Spring MVC中一样。在以下情况下，可以忽略二传手：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>只要将地图初始化，它们就需要使用吸气剂，但不一定需要使用setter，因为它们可以通过活页夹进行突变。</p>
</li>
<li>
<p>可以通过索引（通常使用YAML）或使用单个逗号分隔的值（属性）来访问集合和数组。在后一种情况下，必须使用二传手。我们建议始终为此类类型添加设置器。如果初始化集合，请确保它不是不可变的（如上例所示）。</p>
</li>
<li>
<p>如果嵌套的POJO属性已初始化（例如<code>Security</code>上例中的“字段”），则不需要设置器。如果希望活页夹通过使用其默认构造函数动态创建实例，则需要一个setter。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有些人使用Lombok项目自动添加获取器和设置器。确保Lombok不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化该对象。</p>
</div>
<div class="paragraph">
<p>最后，仅考虑标准Java Bean属性，不支持对静态属性的绑定。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-constructor-binding"><a class="anchor" href="#boot-features-external-config-constructor-binding"></a> 2.8.2。构造函数绑定</h4>
<div class="paragraph">
<p>上一节中的示例可以以不变的方式重写，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.ConstructorBinding;
import org.springframework.boot.context.properties.DefaultValue;

@ConstructorBinding
@ConfigurationProperties("acme")
public class AcmeProperties {

    private final boolean enabled;

    private final InetAddress remoteAddress;

    private final Security security;

    public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    public boolean isEnabled() { ... }

    public InetAddress getRemoteAddress() { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private final String username;

        private final String password;

        private final List&lt;String&gt; roles;

        public Security(String username, String password,
                @DefaultValue("USER") List&lt;String&gt; roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        public String getUsername() { ... }

        public String getPassword() { ... }

        public List&lt;String&gt; getRoles() { ... }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此设置中， <code>@ConstructorBinding</code>批注用于指示应使用构造函数绑定。这意味着绑定器将期望找到带有您希望绑定的参数的构造函数。</p>
</div>
<div class="paragraph">
<p>的嵌套成员<code>@ConstructorBinding</code>类（例如<code>Security</code>在上面的示例中）也将通过其构造函数进行绑定。</p>
</div>
<div class="paragraph">
<p>可以使用以下方式指定默认值<code>@DefaultValue</code>并且将应用相同的转换服务来强制<code>String</code>缺少属性的目标类型的值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要使用构造函数绑定，必须使用<code>@EnableConfigurationProperties</code>或配置属性扫描。您不能对通过常规Spring机制创建的bean使用构造函数绑定（例如， <code>@Component</code> bean ，通过创建的 bean <code>@Bean</code>方法或使用<code>@Import</code> ）</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您的类有多个构造函数，则也可以使用<code>@ConstructorBinding</code>直接在应绑定的构造函数上。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-enabling"><a class="anchor" href="#boot-features-external-config-enabling"></a> 2.8.3。启用<code>@ConfigurationProperties</code>注释的类型</h4>
<div class="paragraph">
<p>Spring Boot提供了绑定基础架构<code>@ConfigurationProperties</code>类型并将其注册为bean。您可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。</p>
</div>
<div class="paragraph">
<p>有时，带注释的课程<code>@ConfigurationProperties</code>例如，如果您正在开发自己的自动配置，或者想要有条件地启用它们，则可能不适合扫描。在这些情况下，请使用<code>@EnableConfigurationProperties</code>注解。这可以在任何<code>@Configuration</code>类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(AcmeProperties.class)
public class MyConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用配置属性扫描，请添加<code>@ConfigurationPropertiesScan</code>应用程序注释。通常，它将添加到带注释的主应用程序类中<code>@SpringBootApplication</code>但可以添加到任何<code>@Configuration</code>类。默认情况下，扫描将从声明注释的类的包中进行。如果要定义要扫描的特定程序包，可以按照以下示例所示进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
public class MyApplication {
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当。。。的时候<code>@ConfigurationProperties</code>使用配置属性扫描或通过注册bean <code>@EnableConfigurationProperties</code> ，该Bean具有常规名称： <code><pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># application.yml

acme:
    remote-address: 192.168.1.1
    security:
        username: admin
        roles:
          - USER
          - ADMIN

# additional configuration as required</code></pre>
</div>
</div>
<div class="paragraph">
<p>跟...共事<code>@ConfigurationProperties</code> bean，您可以像其他任何bean一样注入它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

    private final AcmeProperties properties;

    @Autowired
    public MyService(AcmeProperties properties) {
        this.properties = properties;
    }

    //...

    @PostConstruct
    public void openConnection() {
        Server server = new Server(this.properties.getRemoteAddress());
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>@ConfigurationProperties</code>还可以让您生成元数据文件，IDE可以使用这些元数据文件为您自己的键提供自动完成功能。有关详细信息，请参见<a href="appendix-configuration-metadata.html#configuration-metadata">附录</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-3rd-party-configuration"><a class="anchor" href="#boot-features-external-config-3rd-party-configuration"></a> 2.8.5。第三方配置</h4>
<div class="paragraph">
<p>以及使用<code>@ConfigurationProperties</code>注释课程，也可以在公共场合使用<code>@Bean</code>方法。当您想将属性绑定到控件之外的第三方组件时，这样做特别有用。</p>
</div>
<div class="paragraph">
<p>要从<code>Environment</code>属性，添加<code>@ConfigurationProperties</code>为其bean注册，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties(prefix = "another")
@Bean
public AnotherComponent anotherComponent() {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用定义的任何JavaBean属性<code>another</code>前缀被映射到那个<code>AnotherComponent</code> bean 与前面的方式相似<code>AcmeProperties</code>例。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-relaxed-binding"><a class="anchor" href="#boot-features-external-config-relaxed-binding"></a> 2.8.6。轻松绑定</h4>
<div class="paragraph">
<p>Spring Boot使用一些宽松的规则进行绑定<code>Environment</code>属性<code>@ConfigurationProperties</code> bean ，因此之间不需要完全匹配<code>Environment</code>属性名称和bean属性名称。有用的常见示例包括破折号分隔的环境属性（例如， <code>context-path</code>绑定到<code>contextPath</code> ）和大写的环境属性（例如， <code>PORT</code>绑定到<code>port</code> ）。</p>
</div>
<div class="paragraph">
<p>例如，请考虑以下内容<code>@ConfigurationProperties</code>类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties(prefix="acme.my-project.person")
public class OwnerProperties {

    private String firstName;

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用前面的代码，可以全部使用以下属性名称：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表2.宽松的绑定</caption>
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">注意</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my-project.person.first-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">烤肉串盒，建议用于<code>.properties</code>和<code>.yml</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.myProject.person.firstName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准驼峰式语法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my_project.person.first_name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线表示法，是在<code>.properties</code>和<code>.yml</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写格式，使用系统环境变量时建议使用。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>prefix</code>注释的值<em>必须</em>在kebab情况下（小写并由<code>-</code> ， 如<code>acme.my-project.person</code> ）。
</td>
</tr>
</tbody></table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表3.每个属性源的宽松绑定规则</caption>
<colgroup>
<col style="width:20%">
<col style="width:40%">
<col style="width:40%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">财产来源</th>
<th class="tableblock halign-left valign-top">简单</th>
<th class="tableblock halign-left valign-top">清单</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">骆驼案，烤肉串案或下划线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准列表语法使用<code>[ ]</code>或逗号分隔的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">YAML文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">骆驼案，烤肉串案或下划线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准YAML列表语法或逗号分隔的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以下划线作为定界符的大写格式。
  <code>_</code>不应在属性名称中使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线括起来的数值，例如<code>MY_ACME_1_OTHER = my.acme[1].other</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">骆驼案，烤肉串案或下划线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准列表语法使用<code>[ ]</code>或逗号分隔的值</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们建议，如果可能的话，属性以小写的kebab格式存储，例如<code>my.property-name=acme</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当绑定到<code>Map</code>属性，如果<code>key</code>包含小写字母数字字符或<code>-</code> ，则需要使用方括号表示法，以便保留原始值。如果钥匙没有被包围<code>[]</code> ，非字母数字或<code>-</code>被删除。例如，考虑将以下属性绑定到<code>Map</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">acme:
  map:
    "[/key1]": value1
    "[/key2]": value2
    /key3: value3</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的属性将绑定到<code>Map</code>与<code>/key1</code> ， <code>/key2</code>和<code>key3</code>作为地图中的键。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于YAML文件，方括号需要用引号引起来，以便正确解析密钥。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-complex-type-merge"><a class="anchor" href="#boot-features-external-config-complex-type-merge"></a> 2.8.7。合并复杂类型</h4>
<div class="paragraph">
<p>如果在多个位置配置了列表，则通过替换整个列表来进行覆盖。</p>
</div>
<div class="paragraph">
<p>例如，假设<code>MyPojo</code>与对象<code>name</code>和<code>description</code>的属性是<code>null</code>默认。以下示例公开了<code>MyPojo</code>来自的对象<code>AcmeProperties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;();

    public List&lt;MyPojo&gt; getList() {
        return this.list;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>dev</code>个人资料无效<code>AcmeProperties.list</code>包含一个<code>MyPojo</code>条目，如先前定义。如果<code>dev</code>配置文件已启用，但是<code>list</code> <em>仍然</em>只包含一个条目（名称为<code>my another name</code>以及对<code>null</code> ）。此配置<em>不</em>添加第二个<code>MyPojo</code>实例到列表中，并且不合并项目。</p>
</div>
<div class="paragraph">
<p>当一个<code>List</code>在多个配置文件中指定时，将使用优先级最高的配置文件（并且仅使用该优先级）。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
    - name: another name
      description: another description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果<code>dev</code>个人资料已激活， <code>AcmeProperties.list</code>包含<em>一个</em> <code>MyPojo</code>条目（名称为<code>my another name</code>以及对<code>null</code> ）。对于YAML，可以使用逗号分隔的列表和YAML列表来完全覆盖列表的内容。</p>
</div>
<div class="paragraph">
<p>对于<code>Map</code>属性，您可以绑定从多个来源获取的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。以下示例展示了一个<code>Map<String, MyPojo></code>从<code>AcmeProperties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final Map&lt;String, MyPojo&gt; map = new HashMap&lt;&gt;();

    public Map&lt;String, MyPojo&gt; getMap() {
        return this.map;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">acme:
  map:
    key1:
      name: my name 1
      description: my description 1
---
spring:
  profiles: dev
acme:
  map:
    key1:
      name: dev name 1
    key2:
      name: dev name 2
      description: dev description 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>dev</code>个人资料无效<code>AcmeProperties.map</code>包含一个带键的条目<code>key1</code> （名称为<code>my name 1</code>以及对<code>my description 1</code> ）。如果<code>dev</code>配置文件已启用，但是， <code>map</code>包含两个带键的条目<code>key1</code> （名称为<code>dev name 1</code>以及对<code>my description 1</code> ）和<code>key2</code> （名称为<code>dev name 2</code>以及对<code>dev description 2</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前述合并规则不仅适用于YAML文件，而且适用于所有属性源中的属性。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-conversion"><a class="anchor" href="#boot-features-external-config-conversion"></a> 2.8.8。属性转换</h4>
<div class="paragraph">
<p>当Spring Boot绑定到外部应用时，它会尝试将外部应用程序属性强制为正确的类型。 <code>@ConfigurationProperties</code>beans。如果您需要自定义类型转换，则可以提供<code>ConversionService</code> bean （带有一个名为的 bean <code>conversionService</code> ）或自定义属性编辑器（通过<code>CustomEditorConfigurer</code> bean ）或自定义<code>Converters</code> （带有注释的Bean定义为<code>@ConfigurationPropertiesBinding</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于在应用程序生命周期中非常早就请求了这个bean，因此请确保限制您<code>ConversionService</code>正在使用。通常，您需要的任何依赖项可能在创建时未完全初始化。您可能想重命名您的自定义<code>ConversionService</code>如果配置键强制不需要，并且仅依赖于具有以下要求的定制转换器<code>@ConfigurationPropertiesBinding</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-conversion-duration"><a class="anchor" href="#boot-features-external-config-conversion-duration"></a>转换时间</h5>
<div class="paragraph">
<p>Spring Boot为表达持续时间提供了专门的支持。如果暴露<code>java.time.Duration</code>属性，应用程序属性中可以使用以下格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个普通的<code>long</code>表示形式（以毫秒为默认单位，除非<code>@DurationUnit</code>已指定）</p>
</li>
<li>
<p>标准的ISO-8601格式<a href="https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-">使用<code>java.time.Duration</code></a></p>
</li>
<li>
<p>值和单位耦合的更易读的格式（例如<code>10s</code>表示10秒）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties("app.system")
public class AppSystemProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    public Duration getSessionTimeout() {
        return this.sessionTimeout;
    }

    public void setSessionTimeout(Duration sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }

    public Duration getReadTimeout() {
        return this.readTimeout;
    }

    public void setReadTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定30秒的会话超时， <code>30</code> ， <code>PT30S</code>和<code>30s</code>都是等效的。可以采用以下任何一种形式指定500ms的读取超时： <code>500</code> ， <code>PT0.5S</code>和<code>500ms</code> 。</p>
</div>
<div class="paragraph">
<p>您也可以使用任何受支持的单位。这些是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns</code>十亿分之一秒</p>
</li>
<li>
<p><code>us</code>微秒</p>
</li>
<li>
<p><code>ms</code>毫秒</p>
</li>
<li>
<p><code>s</code>几秒钟</p>
</li>
<li>
<p><code>m</code>几分钟</p>
</li>
<li>
<p><code>h</code>用了几个小时</p>
</li>
<li>
<p><code>d</code>持续数天</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是毫秒，可以使用以下方法覆盖<code>@DurationUnit</code>如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要从以前使用的先前版本进行升级<code>Long</code>要表示持续时间，请确保定义单位（使用<code>@DurationUnit</code> ），如果切换到毫秒还不到毫秒<code>Duration</code> 。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-conversion-datasize"><a class="anchor" href="#boot-features-external-config-conversion-datasize"></a>转换数据大小</h5>
<div class="paragraph">
<p>Spring Framework有一个<code>DataSize</code>表示字节大小的值类型。如果暴露<code>DataSize</code>属性，应用程序属性中可以使用以下格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个普通的<code>long</code>表示形式（使用字节作为默认单位，除非<code>@DataSizeUnit</code>已指定）</p>
</li>
<li>
<p>值和单位耦合的更易读的格式（例如<code>10MB</code>表示10兆字节）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties("app.io")
public class AppIoProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    public DataSize getBufferSize() {
        return this.bufferSize;
    }

    public void setBufferSize(DataSize bufferSize) {
        this.bufferSize = bufferSize;
    }

    public DataSize getSizeThreshold() {
        return this.sizeThreshold;
    }

    public void setSizeThreshold(DataSize sizeThreshold) {
        this.sizeThreshold = sizeThreshold;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定10兆字节的缓冲区大小， <code>10</code>和<code>10MB</code>是等效的。可以将256个字节的大小阈值指定为<code>256</code>要么<code>256B</code> 。</p>
</div>
<div class="paragraph">
<p>您也可以使用任何受支持的单位。这些是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>B</code>对于字节</p>
</li>
<li>
<p><code>KB</code>千字节</p>
</li>
<li>
<p><code>MB</code>兆字节</p>
</li>
<li>
<p><code>GB</code>千兆字节</p>
</li>
<li>
<p><code>TB</code>太字节</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是字节，可以使用覆盖<code>@DataSizeUnit</code>如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要从以前使用的先前版本进行升级<code>Long</code>要表示尺寸，请确保定义单位（使用<code>@DataSizeUnit</code> ）如果不是字节，请切换到<code>DataSize</code> 。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-validation"><a class="anchor" href="#boot-features-external-config-validation"></a> 2.8.9。@ConfigurationProperties验证</h4>
<div class="paragraph">
<p>Spring Boot尝试验证<code>@ConfigurationProperties</code> Spring注释的所有类<code>@Validated</code>注解。可以使用JSR-303 <code>javax.validation</code>约束注释直接在您的配置类上。为此，请确保在类路径上有兼容的JSR-303实现，然后将约束注释添加到字段中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    // ... getters and setters

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您还可以通过注释<code>@Bean</code>创建配置属性的方法<code>@Validated</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了确保始终为嵌套属性触发验证，即使未找到任何属性，也必须对关联字段进行注释<code>@Valid</code> 。以下示例基于上述内容<code>AcmeProperties</code>例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid
    private final Security security = new Security();

    // ... getters and setters

    public static class Security {

        @NotEmpty
        public String username;

        // ... getters and setters

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以添加自定义Spring <code>Validator</code>通过创建一个称为<code>configurationPropertiesValidator</code> 。的<code>@Bean</code>方法应声明<code>static</code> 。配置属性验证器是在应用程序生命周期的早期创建的，并声明<code>@Bean</code>作为静态方法，可以创建Bean，而无需实例化<code>@Configuration</code>类。这样做避免了由早期实例化引起的任何问题。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">的<code>spring-boot-actuator</code>模块包含一个暴露所有端点的端点<code>@ConfigurationProperties</code>beans。将您的网络浏览器指向<code>/actuator/configprops</code>或使用等效的JMX端点。有关详细信息，请参见“ <a href="production-ready-features.html#production-ready-endpoints">生产就绪功能</a> ”部分。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-vs-value"><a class="anchor" href="#boot-features-external-config-vs-value"></a> 2.8.10。@ConfigurationProperties与@Value</h4>
<div class="paragraph">
<p>的<code>@Value</code>批注是容器的核心功能，它没有提供与类型安全的配置属性相同的功能。下表总结了受支持的功能<code>@ConfigurationProperties</code>和<code>@Value</code> ：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">特征</th>
<th class="tableblock halign-left valign-top"><code>@ConfigurationProperties</code></th>
<th class="tableblock halign-left valign-top"><code>@Value</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#boot-features-external-config-relaxed-binding">宽松的绑定</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="appendix-configuration-metadata.html#configuration-metadata">元数据支持</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SpEL</code>评价</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果您为自己的组件定义了一组配置键，我们建议您将它们分组在带有注释的POJO中<code>@ConfigurationProperties</code> 。您还应该意识到，因为<code>@Value</code>不支持宽松的绑定，如果您需要通过使用环境变量来提供值，则不是很好的选择。</p>
</div>
<div class="paragraph">
<p>最后，虽然你可以写一个<code>SpEL</code>表达于<code>@Value</code> ，不会从<a href="#boot-features-external-config-application-property-files">应用程序属性文件</a>处理此类表达式。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-profiles"><a class="anchor" href="#boot-features-profiles"></a> 3。个人资料</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Profiles提供了一种分离应用程序配置的各个部分并使之仅在某些环境中可用的方法。任何<code>@Component</code> ， <code>@Configuration</code>要么<code>@ConfigurationProperties</code>可以用<code>@Profile</code>限制加载时间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果<code>@ConfigurationProperties</code> bean 通过注册<code>@EnableConfigurationProperties</code>而不是自动扫描， <code>@Profile</code>注释需要在<code>@Configuration</code>具有<code>@EnableConfigurationProperties</code>注解。在这种情况下<code>@ConfigurationProperties</code>被扫描， <code>@Profile</code>可以在<code>@ConfigurationProperties</code>类本身。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<code>spring.profiles.active</code><code>Environment</code>属性，用于指定哪些配置文件处于活动状态。您可以通过本章前面介绍的任何方式指定属性。例如，您可以将其包含在<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.profiles.active=dev,hsqldb</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用以下开关在命令行上指定它： <code>--spring.profiles.active=dev,hsqldb</code> 。</p>
</div>
<div class="sect2">
<h3 id="boot-features-adding-active-profiles"><a class="anchor" href="#boot-features-adding-active-profiles"></a> 3.1。添加活动配置文件</h3>
<div class="paragraph">
<p>的<code>spring.profiles.active</code>属性遵循与其他属性相同的排序规则：最高<code>PropertySource</code>胜。这意味着您可以在<code>application.properties</code>然后使用命令行开关<strong>替换</strong>它们。</p>
</div>
<div class="paragraph">
<p>有时，将特定于配置文件的属性<strong>添加</strong>到活动配置文件而不是替换它们是有用的。的<code>spring.profiles.include</code>属性可用于无条件添加活动配置文件。的<code>SpringApplication</code>入口点还具有Java API，用于设置其他配置文件（即， <code>spring.profiles.active</code>属性）。见<code>setAdditionalProfiles()</code> <a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/SpringApplication.html">SpringApplication中的</a>方法。</p>
</div>
<div class="paragraph">
<p>例如，当使用开关运行具有以下属性的应用程序时， <code>--spring.profiles.active=prod</code> ， <code>proddb</code>和<code>prodmq</code>配置文件也被激活：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">---
my.property: fromyamlfile
---
spring.profiles: prod
spring.profiles.include:
  - proddb
  - prodmq</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请记住<code>spring.profiles</code>可以在YAML文档中定义属性以确定何时将此特定文档包括在配置中。有关更多详细信息，请参见<a href="howto.html#howto-change-configuration-depending-on-the-environment">howto.html</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-programmatically-setting-profiles"><a class="anchor" href="#boot-features-programmatically-setting-profiles"></a> 3.2。以编程方式设置配置文件</h3>
<div class="paragraph">
<p>您可以通过调用以编程方式设置活动配置文件<code>SpringApplication.setAdditionalProfiles(…​)</code>在您的应用程序运行之前。也可以使用Spring的<code>ConfigurableEnvironment</code>接口。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-profile-specific-configuration"><a class="anchor" href="#boot-features-profile-specific-configuration"></a> 3.3。特定于配置文件的配置文件</h3>
<div class="paragraph">
<p>两者的特定于配置文件的变体<code>application.properties</code> （要么<code>application.yml</code> ）和通过引用的文件<code>@ConfigurationProperties</code>被视为文件并已加载。有关详细信息，请参见“ <a href="#boot-features-external-config-profile-specific-properties">特定</a>于<a href="#boot-features-external-config-profile-specific-properties">配置文件的属性</a> ”。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-logging"><a class="anchor" href="#boot-features-logging"></a> 4。记录中</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot使用<a href="https://commons.apache.org/logging">Commons Logging</a>进行所有内部日志记录，但是使底层日志实现保持打开状态。提供了<a href="https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html">Java Util Logging</a> ， <a href="https://logging.apache.org/log4j/2.x/">Log4J2</a>和<a href="https://logback.qos.ch/">Logback的</a>默认配置。在每种情况下，记录器都已预先配置为使用控制台输出，同时还提供可选文件输出。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果使用“启动器”，则使用Logback进行日志记录。还包括适当的Logback路由，以确保使用Java Util Logging，Commons Logging，Log4J或SLF4J的从属库都可以正常工作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Java有许多可用的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。通常，您不需要更改日志记录依赖项，并且Spring Boot默认值可以正常工作。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">当您将应用程序部署到servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="boot-features-logging-format"><a class="anchor" href="#boot-features-logging-format"></a> 4.1。日志格式</h3>
<div class="paragraph">
<p>Spring Boot的默认日志输出类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</pre>
</div>
</div>
<div class="paragraph">
<p>输出以下项目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日期和时间：毫秒精度，易于排序。</p>
</li>
<li>
<p>日志级别： <code>ERROR</code> ， <code>WARN</code> ， <code>INFO</code> ， <code>DEBUG</code> ， 要么<code>TRACE</code> 。</p>
</li>
<li>
<p>进程ID。</p>
</li>
<li>
<p>一种<code>---</code>分隔符以区分实际日志消息的开始。</p>
</li>
<li>
<p>线程名称：用方括号括起来（对于控制台输出可能会被截断）。</p>
</li>
<li>
<p>记录器名称：这通常是源类名称（通常缩写）。</p>
</li>
<li>
<p>日志消息。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">登录没有<code>FATAL</code>水平。它映射到<code>ERROR</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logging-console-output"><a class="anchor" href="#boot-features-logging-console-output"></a> 4.2。控制台输出</h3>
<div class="paragraph">
<p>默认日志配置在消息写入时将消息回显到控制台。默认， <code>ERROR</code> -水平， <code>WARN</code>级<code>INFO</code>级别的消息被记录。您还可以通过使用以下命令启动应用程序来启用“调试”模式<code>--debug</code>旗。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --debug</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以指定<code>debug=true</code>在你的<code>application.properties</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>启用调试模式后，将配置一些核心记录器（嵌入式容器，Hibernate和Spring Boot）以输出更多信息。启用调试模式<em>不会</em>配置您的应用程序来记录所有的消息与<code>DEBUG</code>水平。</p>
</div>
<div class="paragraph">
<p>或者，您可以通过使用以下命令启动应用程序来启用“跟踪”模式<code>--trace</code>标志（或<code>trace=true</code>在你的<code>application.properties</code> ）。这样做可以为某些核心记录器（嵌入式容器，Hibernate模式生成以及整个Spring产品组合）启用跟踪记录。</p>
</div>
<div class="sect3">
<h4 id="boot-features-logging-color-coded-output"><a class="anchor" href="#boot-features-logging-color-coded-output"></a> 4.2.1。颜色编码输出</h4>
<div class="paragraph">
<p>如果您的终端支持ANSI，则使用彩色输出来提高可读性。你可以设定<code>spring.output.ansi.enabled</code>到<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/ansi/AnsiOutput.Enabled.html">支持的值</a>以覆盖自动检测。</p>
</div>
<div class="paragraph">
<p>通过使用<code>%clr</code>转换词。转换器以最简单的形式根据对数级别为输出着色，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%5p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了日志级别到颜色的映射：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">水平</th>
<th class="tableblock halign-left valign-top">颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FATAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ERROR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WARN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">黄色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INFO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEBUG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>另外，您可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如，要使文本变黄，请使用以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持以下颜色和样式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>blue</code></p>
</li>
<li>
<p><code>cyan</code></p>
</li>
<li>
<p><code>faint</code></p>
</li>
<li>
<p><code>green</code></p>
</li>
<li>
<p><code>magenta</code></p>
</li>
<li>
<p><code>red</code></p>
</li>
<li>
<p><code>yellow</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logging-file-output"><a class="anchor" href="#boot-features-logging-file-output"></a> 4.3。文件输出</h3>
<div class="paragraph">
<p>默认情况下，Spring Boot仅记录到控制台，不写日志文件。如果除了控制台输出外还想写日志文件，则需要设置一个<code>logging.file.name</code>要么<code>logging.file.path</code>属性（例如，在您的<code>application.properties</code> ）。</p>
</div>
<div class="paragraph">
<p>下表显示了<code>logging.*</code>属性可以一起使用：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表4。记录属性</caption>
<colgroup>
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:14.2857%">
<col style="width:57.1429%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>logging.file.name</code></th>
<th class="tableblock halign-left valign-top"><code>logging.file.path</code></th>
<th class="tableblock halign-left valign-top">例</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>（没有）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>（没有）</em></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅控制台记录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定档案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>（没有）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>my.log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写入指定的日志文件。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>（没有）</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具体目录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写<code>spring.log</code>到指定目录。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>日志文件达到10 MB时会旋转，并且与控制台输出一样， <code>ERROR</code> -水平， <code>WARN</code>级<code>INFO</code>级别的消息是默认记录的。尺寸限制可以使用<code>logging.file.max-size</code>属性。以前循环的文件将无限期存档，除非<code>logging.file.max-history</code>属性已设置。日志档案的总大小可以使用<code>logging.file.total-size-cap</code> 。当日志归档的总大小超过该阈值时，将删除备份。要在应用程序启动时强制清除日志归档文件，请使用<code>logging.file.clean-history-on-start</code>属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">日志记录属性独立于实际的日志记录基础结构。因此，特定的配置密钥（例如<code>logback.configurationFile</code>用于Logback）不受Spring Boot的管理。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-custom-log-levels"><a class="anchor" href="#boot-features-custom-log-levels"></a> 4.4。日志级别</h3>
<div class="paragraph">
<p>所有受支持的日志记录系统都可以在Spring中设置记录器级别<code>Environment</code> （例如，在<code>application.properties</code> ） 通过使用<code>logging.level.<logger-name>=<level></code>哪里<code>level</code>是TRACE，DEBUG，INFO，WARN，ERROR，FATAL或OFF之一。的<code>root</code>记录器可以通过使用配置<code>logging.level.root</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了可能的日志记录设置<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.root=warn
logging.level.org.springframework.web=debug
logging.level.org.hibernate=error</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用环境变量设置日志记录级别。例如， <code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code>将设置<code>org.springframework.web</code>至<code>DEBUG</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">以上方法仅适用于程序包级别的日志记录。由于轻松绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。如果您需要配置日志记录一类，你可以使用<a href="#boot-features-external-config-application-json">的<code>SPRING_APPLICATION_JSON</code></a>变量。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-custom-log-groups"><a class="anchor" href="#boot-features-custom-log-groups"></a> 4.5。日志组</h3>
<div class="paragraph">
<p>能够将相关记录器组合在一起通常很有用，以便可以同时配置它们。例如，您可能通常会更改<em>所有</em>与Tomcat相关的记录器的记录级别，但是您不容易记住顶层软件包。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，Spring Boot允许您在Spring中定义日志记录组。 <code>Environment</code> 。例如，以下是通过将“ tomcat”组添加到<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义后，您可以使用一行更改该组中所有记录器的级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.tomcat=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot包含以下预定义的日志记录组，它们可以直接使用：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:80%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">记录仪</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网路</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.codec</code> ， <code>org.springframework.http</code> ， <code>org.springframework.web</code> ， <code>org.springframework.boot.actuate.endpoint.web</code> ，<code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sql</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.jdbc.core</code> ， <code>org.hibernate.SQL</code> ，<code>org.jooq.tools.LoggerListener</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-custom-log-configuration"><a class="anchor" href="#boot-features-custom-log-configuration"></a> 4.6。自定义日志配置</h3>
<div class="paragraph">
<p>可以通过在类路径中包含适当的库来激活各种日志记录系统，并可以通过在类路径的根目录或后续Spring指定的位置中提供适当的配置文件来进一步自定义各种日志记录系统。 <code>Environment</code>属性： <code>logging.config</code> 。</p>
</div>
<div class="paragraph">
<p>您可以通过以下方式强制Spring Boot使用特定的日志记录系统： <code>org.springframework.boot.logging.LoggingSystem</code>系统属性。该值应为a的完全限定的类名。 <code>LoggingSystem</code>实施。您还可以通过使用值完全禁用Spring Boot的日志记录配置<code>none</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于日志记录是<strong>在</strong> <code>ApplicationContext</code>创建后，就无法从中控制日志记录<code>@PropertySources</code>在 Spring <code>@Configuration</code>文件。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>根据您的日志记录系统，将加载以下文件：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">测井系统</th>
<th class="tableblock halign-left valign-top">客制化</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">退回</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logback-spring.xml</code> ， <code>logback-spring.groovy</code> ， <code>logback.xml</code> ， 要么<code>logback.groovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Log4j2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>log4j2-spring.xml</code>要么<code>log4j2.xml</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JDK（Java实用程序日志记录）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.properties</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果可能，我们建议您使用<code>-spring</code>您的日志记录配置的变体（例如， <code>logback-spring.xml</code>而不是<code>logback.xml</code> ）。如果使用标准配置位置，Spring将无法完全控制日志初始化。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">从“可执行jar”运行时，Java Util Logging存在一些已知的类加载问题，这些问题会引起问题。我们建议您尽可能从“可执行jar”运行时避免使用它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了帮助自定义，从Spring转移了一些其他属性<code>Environment</code>到系统属性，如下表所述：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"> Spring 环境</th>
<th class="tableblock halign-left valign-top">系统属性</th>
<th class="tableblock halign-left valign-top">评论</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.exception-conversion-word</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_EXCEPTION_CONVERSION_WORD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录异常时使用的转换字。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.clean-history-on-start</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_CLEAN_HISTORY_ON_START</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在启动时清除存档日志文件（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_SIZE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大日志文件大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-history</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_HISTORY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的最大归档日志文件数（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_PATH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.total-size-cap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_TOTAL_SIZE_CAP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的日志备份的总大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.console</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONSOLE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制台上使用的日志模式（stdout）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.dateformat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_DATEFORMAT_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录日期格式的附加模式。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.file</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FILE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件中使用的日志模式（如果<code>LOG_FILE</code>已启用）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.level</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_LEVEL_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现日志级别时使用的格式（默认<code>%5p</code> ）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.rolling-file-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROLLING_FILE_NAME_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过渡日志文件名的模式（默认<code>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</code> ）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前进程ID（如果可能，并且尚未将其定义为OS环境变量，则发现）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。请参阅中的默认配置<code>spring-boot.jar</code>举些例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">退回</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util日志记录</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要在日志记录属性中使用占位符，则应使用<a href="#boot-features-external-config-placeholders-in-properties">Spring Boot的语法</a>而不是基础框架的语法。值得注意的是，如果您使用Logback，则应使用<code>:</code>作为属性名称与其默认值之间的分隔符，不使用<code>:-</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以通过仅覆盖MDC和其他临时内容到日志行<code>LOG_LEVEL_PATTERN</code> （要么<code>logging.pattern.level</code>使用Logback）。例如，如果您使用<code>logging.pattern.level=user:%X{user} %5p</code> ，则默认日志格式包含“ user”的MDC条目（如果存在），如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
Handling authenticated request</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logback-extensions"><a class="anchor" href="#boot-features-logback-extensions"></a> 4.7。登录扩展</h3>
<div class="paragraph">
<p>Spring Boot包含许多Logback扩展，可以帮助进行高级配置。您可以在自己的计算机中使用这些扩展名<code>logback-spring.xml</code>配置文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">因为标准<code>logback.xml</code>配置文件加载时间过早，无法在其中使用扩展名。您需要使用<code>logback-spring.xml</code>或定义一个<code>logging.config</code>属性。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">这些扩展不能与Logback的<a href="https://logback.qos.ch/manual/configuration.html#autoScan">配置扫描一起使用</a> 。如果尝试这样做，则对配置文件进行更改将导致类似于以下记录之一的错误：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</pre>
</div>
</div>
<div class="sect3">
<h4 id="profile-specific-configuration"><a class="anchor" href="#profile-specific-configuration"></a> 4.7.1。特定于配置文件的配置</h4>
<div class="paragraph">
<p>的<code><springProfile></code>标签允许您根据活动的Spring配置文件有选择地包括或排除配置部分。个人资料部分在<code><configuration></code>元件。使用<code>name</code>属性，用于指定哪个配置文件接受配置。的<code><springProfile></code>标签可以包含一个简单的配置文件名称（例如<code>staging</code> ）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production & (eu-central | eu-west)</code> 。有关更多详细信息，请参阅<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java">参考指南</a> 。以下清单显示了三个样本概要文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;springProfile name="staging"&gt;
    &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="dev | staging"&gt;
    &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="!production"&gt;
    &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;
&lt;/springProfile&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="environment-properties"><a class="anchor" href="#environment-properties"></a> 4.7.2。环境特性</h4>
<div class="paragraph">
<p>的<code><springProperty></code>标签可让您从Spring公开属性<code>Environment</code>在Logback中使用。如果您要访问自己的值，这样做会很有用<code>application.properties</code>登录配置中的文件。该标签的工作方式类似于Logback的标准<code><property></code>标签。但是，与其指定直接<code>value</code> ，您可以指定<code>source</code>财产的（来自<code>Environment</code> ）。如果您需要将财产存放在其他地方<code>local</code>范围，您可以使用<code>scope</code>属性。如果您需要一个后备值（如果未在<code>Environment</code> ），您可以使用<code>defaultValue</code>属性。以下示例显示如何公开在Logback中使用的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
        defaultValue="localhost"/&gt;
&lt;appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender"&gt;
    &lt;remoteHost&gt;${fluentHost}&lt;/remoteHost&gt;
    ...
&lt;/appender&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>source</code>必须在烤肉串情况下指定（例如<code>my.property-name</code> ）。但是，可以将属性添加到<code>Environment</code>通过使用宽松的规则。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-internationalization"><a class="anchor" href="#boot-features-internationalization"></a> 5，国际化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot支持本地化消息，因此您的应用程序可以迎合不同语言首选项的用户。默认情况下，Spring Boot查找是否存在<code>messages</code>资源束位于类路径的根目录。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当配置的资源束的默认属性文件可用时（即，自动配置适用） <code>messages.properties</code>默认）。如果您的资源包仅包含特定于语言的属性文件，则需要添加默认文件。如果找不到与任何配置的基本名称匹配的属性文件，则不会自动配置<code>MessageSource</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用以下命令配置资源包的基本名称以及其他几个属性<code>spring.messages</code>命名空间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.messages.basename=messages,config.i18n.messages
spring.messages.fallback-to-system-locale=false</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>spring.messages.basename</code>支持以逗号分隔的位置列表，即包限定符或从类路径根目录解析的资源。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java"><code>MessageSourceProperties</code></a>了解更多受支持的选项。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-json"><a class="anchor" href="#boot-features-json"></a> 6。JSON格式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了与三个JSON映射库的集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>格森</p>
</li>
<li>
<p>杰克逊</p>
</li>
<li>
<p>JSON-B</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jackson是首选的默认库。</p>
</div>
<div class="sect2">
<h3 id="boot-features-json-jackson"><a class="anchor" href="#boot-features-json-jackson"></a> 6.1。杰克逊</h3>
<div class="paragraph">
<p>提供了Jackson的自动配置功能，并且Jackson是其中的一部分<code>spring-boot-starter-json</code> 。当杰克逊在课堂上， <code>ObjectMapper</code> bean是自动配置的。提供了几个配置属性，用于<a href="howto.html#howto-customize-the-jackson-objectmapper">自定义<code>ObjectMapper</code></a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-json-gson"><a class="anchor" href="#boot-features-json-gson"></a> 6.2。格森</h3>
<div class="paragraph">
<p>提供了Gson的自动配置。当Gson在类路径上时<code>Gson</code> bean是自动配置的。一些<code>spring.gson.*</code>提供配置属性用于自定义配置。要获得更多控制权，一个或多个<code>GsonBuilderCustomizer</code>可以使用beans。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-json-json-b"><a class="anchor" href="#boot-features-json-json-b"></a> 6.3。JSON-B</h3>
<div class="paragraph">
<p>提供了JSON-B的自动配置。当JSON-B API和实现位于类路径上时<code>Jsonb</code> bean将被自动配置。首选的JSON-B实现是提供依赖管理的Apache Johnzon。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-developing-web-applications"><a class="anchor" href="#boot-features-developing-web-applications"></a> 7。开发Web应用程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot非常适合于Web应用程序开发。您可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建独立的HTTP服务器。大多数网络应用程序使用<code>spring-boot-starter-web</code>模块以快速启动并运行。您还可以选择使用以下方式构建反应式Web应用程序： <code>spring-boot-starter-webflux</code>模块。</p>
</div>
<div class="paragraph">
<p>如果尚未开发Spring Boot Web应用程序，则可以遵循“ Hello World！“ <em><a href="getting-started.html#getting-started-first-application">入门</a></em> ”部分的示例。</p>
</div>
<div class="sect2">
<h3 id="boot-features-spring-mvc"><a class="anchor" href="#boot-features-spring-mvc"></a> 7.1。“ Spring Web MVC框架”</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc">Spring Web MVC框架</a> （通常简称为“ Spring MVC”）是一个丰富的“模型视图控制器” Web框架。Spring MVC让您创建特殊的<code>@Controller</code>要么<code>@RestController</code> bean处理传入的HTTP请求。控制器中的方法通过使用映射到HTTP <code>@RequestMapping</code>注释。</p>
</div>
<div class="paragraph">
<p>以下代码显示了典型的<code>@RestController</code>提供JSON数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@RequestMapping(value="/users")
public class MyRestController {

    @RequestMapping(value="/{user}", method=RequestMethod.GET)
    public User getUser(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
    List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}", method=RequestMethod.DELETE)
    public User deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring MVC是核心Spring Framework的一部分，有关详细信息，请参阅<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc">参考文档</a> 。在<a href="https://spring.io/guides" class="bare">spring.io/guides</a>上还有一些涵盖Spring MVC的指南。</p>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-auto-configuration"><a class="anchor" href="#boot-features-spring-mvc-auto-configuration"></a> 7.1.1。Spring MVC自动配置</h4>
<div class="paragraph">
<p>Spring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认值之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>beans。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（ <a href="#boot-features-spring-mvc-static-content">在本文档的后面部分中有介绍</a> ）。</p>
</li>
<li>
<p>自动注册<code>Converter</code> ， <code>GenericConverter</code>和<code>Formatter</code>beans。</p>
</li>
<li>
<p>支持<code>HttpMessageConverters</code> （ <a href="#boot-features-spring-mvc-message-converters">在本文档后面介绍</a> ）。</p>
</li>
<li>
<p>自动注册<code>MessageCodesResolver</code> （ <a href="#boot-features-spring-message-codes">在本文档后面介绍</a> ）。</p>
</li>
<li>
<p>静态的<code>index.html</code>支持。</p>
</li>
<li>
<p>自订<code>Favicon</code>支持（ <a href="#boot-features-spring-mvc-favicon">在本文档后面介绍</a> ）。</p>
</li>
<li>
<p>自动使用<code>ConfigurableWebBindingInitializer</code> bean（ <a href="#boot-features-spring-mvc-web-binding-initializer">在本文档后面介绍</a> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想保留Spring Boot MVC功能并想要添加其他<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc">MVC配置</a> （拦截器，格式化程序，视图控制器和其他功能），则可以添加自己的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc">MVC配置。</a> <code>@Configuration</code>类型类别<code>WebMvcConfigurer</code>但<strong>没有</strong> <code>@EnableWebMvc</code> 。如果您想提供以下的自定义实例<code>RequestMappingHandlerMapping</code> ， <code>RequestMappingHandlerAdapter</code> ， 要么<code>ExceptionHandlerExceptionResolver</code> ，您可以声明一个<code>WebMvcRegistrationsAdapter</code>提供此类组件的实例。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring MVC，可以添加自己的<code>@Configuration</code>带有注释<code>@EnableWebMvc</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-message-converters"><a class="anchor" href="#boot-features-spring-mvc-message-converters"></a> 7.1.2。HttpMessageConverters</h4>
<div class="paragraph">
<p>Spring MVC使用<code>HttpMessageConverter</code>接口以转换HTTP请求和响应。开箱即用中包含明智的默认设置。例如，可以将对象自动转换为JSON（通过使用Jackson库）或XML（通过使用Jackson XML扩展（如果有）或通过使用JAXB（如果Jackson XML扩展不可用））。默认情况下，字符串编码为<code>UTF-8</code> 。</p>
</div>
<div class="paragraph">
<p>如果您需要添加或自定义转换器，则可以使用Spring Boot的<code>HttpMessageConverters</code>类，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = ...
        HttpMessageConverter&lt;?&gt; another = ...
        return new HttpMessageConverters(additional, another);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何<code>HttpMessageConverter</code>上下文中存在的bean被添加到转换器列表中。您也可以用相同的方法覆盖默认转换器。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-json-components"><a class="anchor" href="#boot-features-json-components"></a> 7.1.3。自定义JSON序列化器和反序列化器</h4>
<div class="paragraph">
<p>如果您使用Jackson来序列化和反序列化JSON数据，则可能需要编写自己的数据<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化程序通常是<a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块注册到Jackson的</a> ，但是Spring Boot提供了另一种方法<code>@JsonComponent</code>批注，使直接注册Spring Bean更加容易。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@JsonComponent</code>注释直接在<code>JsonSerializer</code> ， <code>JsonDeserializer</code>要么<code>KeyDeserializer</code>实现。您还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

    public static class Serializer extends JsonSerializer&lt;SomeObject&gt; {
        // ...
    }

    public static class Deserializer extends JsonDeserializer&lt;SomeObject&gt; {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有<code>@JsonComponent</code> bean 在<code>ApplicationContext</code>已自动向Jackson进行注册。因为<code>@JsonComponent</code>带有元注释<code>@Component</code> ，则适用通常的组件扫描规则。</p>
</div>
<div class="paragraph">
<p>Spring Boot还提供<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java"><code>JsonObjectSerializer</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java"><code>JsonObjectDeserializer</code></a>基类，可在序列化对象时为标准Jackson版本提供有用的替代方法。看到<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/jackson/JsonObjectSerializer.html"><code>JsonObjectSerializer</code></a>和<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/jackson/JsonObjectDeserializer.html"><code>JsonObjectDeserializer</code></a>有关详细信息，请参见Javadoc。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-message-codes"><a class="anchor" href="#boot-features-spring-message-codes"></a> 7.1.4。MessageCodesResolver</h4>
<div class="paragraph">
<p>Spring MVC有一种生成错误代码的策略，该错误代码用于从绑定错误中呈现错误消息： <code>MessageCodesResolver</code> 。如果您设定<code>spring.mvc.message-codes-resolver-format</code>属性<code>PREFIX_ERROR_CODE</code>要么<code>POSTFIX_ERROR_CODE</code> ，Spring Boot会为您创建一个（请参阅中的枚举<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html"><code>DefaultMessageCodesResolver.Format</code></a> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-static-content"><a class="anchor" href="#boot-features-spring-mvc-static-content"></a> 7.1.5。静态内容</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot从目录中提供静态内容<code>/static</code> （要么<code>/public</code>要么<code>/resources</code>要么<code>/META-INF/resources</code> ）在类路径中或从<code>ServletContext</code> 。它使用<code>ResourceHttpRequestHandler</code>来自Spring MVC，因此您可以通过添加自己的行为来修改该行为<code>WebMvcConfigurer</code>并覆盖<code>addResourceHandlers</code>方法。</p>
</div>
<div class="paragraph">
<p>在独立的Web应用程序中，还会启用容器中的默认servlet，并将其用作后备，从容器的根目录提供内容<code>ServletContext</code>如果Spring决定不处理它。在大多数情况下，这种情况不会发生（除非您修改默认的MVC配置），因为Spring始终可以通过<code>DispatcherServlet</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射到<code>/**</code> ，但您可以使用<code>spring.mvc.static-path-pattern</code>属性。例如，将所有资源重新定位到<code>/resources/**</code>可以实现如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mvc.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过以下方式自定义静态资源位置： <code>spring.resources.static-locations</code>属性（用目录位置列表替换默认值）。根Servlet上下文路径， <code>"/"</code> ，也会自动添加为位置。</p>
</div>
<div class="paragraph">
<p>除了前面提到的“标准”静态资源位置， <a href="https://www.webjars.org/">Webjars内容也</a>有特殊情况。路径中的任何资源<code>/webjars/**</code>如果jar文件以Webjars格式打包，则从jar文件提供。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">请勿使用<code>src/main/webapp</code>目录，如果您的应用程序打包为jar。尽管此目录是一个通用标准，但它<strong>仅适用</strong>于war打包，并且如果生成jar，大多数构建工具都将其默默地忽略它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用案例，例如缓存清除静态资源或对Webjars使用版本无关的URL。</p>
</div>
<div class="paragraph">
<p>要为Webjar使用与版本无关的网址，请添加<code>webjars-locator-core</code>依赖性。然后声明您的Webjar。以jQuery为例，添加<code>"/webjars/jquery/jquery.min.js"</code>结果是<code>"/webjars/jquery/x.y.z/jquery.min.js"</code>哪里<code>x.y.z</code>是Webjar版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用JBoss，则需要声明<code>webjars-locator-jboss-vfs</code>依赖而不是<code>webjars-locator-core</code> 。否则，所有Webjar都会解析为<code>404</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要使用缓存清除，以下配置可为所有静态资源配置缓存清除解决方案，从而有效地添加内容哈希，例如<code><link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/></code> ，在网址中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">借助以下命令，可以在运行时将资源链接重写为模板<code>ResourceUrlEncodingFilter</code>已为Thymeleaf和FreeMarker自动配置。使用JSP时，您应该手动声明此过滤器。当前不自动支持其他模板引擎，但可以与自定义模板宏/帮助程序一起使用，并且可以使用<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html"><code>ResourceUrlProvider</code></a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，当使用JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以组合的原因。“固定”策略在URL中添加静态版本字符串，而不更改文件名，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用此配置，位于下面的JavaScript模块<code>"/js/lib/"</code>使用固定的版本控制策略（ <code>"/v12/js/lib/mymodule.js"</code> ），而其他资源仍在使用内容（ <code><link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/></code> ）。</p>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java"><code>ResourceProperties</code></a>了解更多受支持的选项。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>专门的<a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">博客文章</a>和Spring Framework的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">参考文档中</a>已经对该功能进行了全面的描述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-welcome-page"><a class="anchor" href="#boot-features-spring-mvc-welcome-page"></a> 7.1.6。欢迎页面</h4>
<div class="paragraph">
<p>Spring Boot支持静态和模板欢迎页面。它首先寻找<code>index.html</code>文件配置的静态内容位置中。如果未找到，则寻找一个<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-favicon"><a class="anchor" href="#boot-features-spring-mvc-favicon"></a> 7.1.7。自定义图标</h4>
<div class="paragraph">
<p>与其他静态资源一样，Spring Boot会寻找一个<code>favicon.ico</code>在配置的静态内容位置。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-pathmatch"><a class="anchor" href="#boot-features-spring-mvc-pathmatch"></a> 7.1.8。路径匹配和内容协商</h4>
<div class="paragraph">
<p>通过查看请求路径并将其与您的应用程序中定义的映射进行匹配，Spring MVC可以将传入的HTTP请求映射到处理程序。 <code>@GetMapping</code>控制器方法的注释）。</p>
</div>
<div class="paragraph">
<p>Spring Boot默认选择禁用后缀模式匹配，这意味着诸如<code>"GET /projects/spring-boot.json"</code>将不匹配<code>@GetMapping("/projects/spring-boot")</code>映射。这被认为是<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match">Spring MVC应用程序</a>的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match">最佳实践</a> 。过去，此功能主要用于未发送正确的“ Accept”请求标头的HTTP客户端。我们需要确保将正确的内容类型发送给客户端。如今，内容协商已变得更加可靠。</p>
</div>
<div class="paragraph">
<p>还有其他处理HTTP客户端的方法，这些客户端不能始终发送正确的“ Accept”请求标头。除了使用后缀匹配，我们还可以使用查询参数来确保类似<code>"GET /projects/spring-boot?format=json"</code>将被映射到<code>@GetMapping("/projects/spring-boot")</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您了解了注意事项，但仍希望您的应用程序使用后缀模式匹配，则需要以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-suffix-pattern=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，与其打开所有后缀模式，不如仅支持已注册的后缀模式，这会更安全：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-registered-suffix-pattern=true

# You can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-web-binding-initializer"><a class="anchor" href="#boot-features-spring-mvc-web-binding-initializer"></a> 7.1.9。ConfigurableWebBindingInitializer</h4>
<div class="paragraph">
<p>Spring MVC使用<code>WebBindingInitializer</code>初始化一个<code>WebDataBinder</code>对于特定的请求。如果您创建自己的<code>ConfigurableWebBindingInitializer</code><code>@Bean</code> ，Spring Boot会自动将Spring MVC配置为使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-template-engines"><a class="anchor" href="#boot-features-spring-mvc-template-engines"></a> 7.1.10。模板引擎</h4>
<div class="paragraph">
<p>除了REST Web服务之外，您还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持多种模板技术，包括Thymeleaf，FreeMarker和JSP。同样，许多其他模板引擎包括他们自己的Spring MVC集成。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">胸腺</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果可能，应避免使用JSP。将它们与嵌入式servlet容器一起使用时，存在几个<a href="#boot-features-jsp-limitations">已知的限制</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在默认配置下使用这些模板引擎之一时，将从以下位置自动提取模板<code>src/main/resources/templates</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">根据您运行应用程序的方式，IntelliJ IDEA对类路径的排序不同。与使用Maven或Gradle或从打包的jar运行应用程序时，从IDE的主要方法运行应用程序的顺序会有所不同。这可能导致Spring Boot无法在类路径上找到模板。如果遇到此问题，可以在IDE中重新排序类路径，以首先放置模块的类和资源。或者，您可以配置模板前缀以搜索每个<code>templates</code>类路径上的目录，如下所示： <code>classpath*:/templates/</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-error-handling"><a class="anchor" href="#boot-features-error-handling"></a> 7.1.11。错误处理</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot提供了一个<code>/error</code>以合理的方式处理所有错误的映射，并在servlet容器中注册为“全局”错误页面。对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“ whitelabel”错误视图，该视图以HTML格式呈现相同的数据（要对其进行自定义，请添加一个<code>View</code>解析为<code>error</code> ）。要完全替换默认行为，您可以实施<code>ErrorController</code>并注册该类型的bean定义或添加类型的bean <code>ErrorAttributes</code>使用现有机制但替换内容。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">的<code>BasicErrorController</code>可用作自定义的基类<code>ErrorController</code> 。如果要为新的内容类型添加处理程序（默认是处理<code>text/html</code>并为其他所有内容提供后备广告）。为此，请扩展<code>BasicErrorController</code> ，添加带有<code>@RequestMapping</code>有一个<code>produces</code>属性，并创建新类型的Bean。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以定义带有注释的类<code>@ControllerAdvice</code>定制JSON文档以返回特定的控制器和/或异常类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ControllerAdvice(basePackageClasses = AcmeController.class)
public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

    @ExceptionHandler(YourException.class)
    @ResponseBody
    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(new CustomErrorType(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        return HttpStatus.valueOf(statusCode);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果<code>YourException</code>由与同一包中定义的控制器一起抛出<code>AcmeController</code> ，是的JSON表示形式<code>CustomErrorType</code>使用POJO代替<code>ErrorAttributes</code>表示。</p>
</div>
<div class="sect4">
<h5 id="boot-features-error-handling-custom-error-pages"><a class="anchor" href="#boot-features-error-handling-custom-error-pages"></a>自定义错误页面</h5>
<div class="paragraph">
<p>如果要显示给定状态代码的自定义HTML错误页面，则可以将文件添加到<code>/error</code>夹。错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板来构建。文件名应为确切的状态代码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>映射全部<code>5xx</code>使用FreeMarker模板出现错误时，您的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftlh
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更复杂的映射，您还可以添加用于实现<code>ErrorViewResolver</code>界面，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyErrorViewResolver implements ErrorViewResolver {

    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request,
            HttpStatus status, Map&lt;String, Object&gt; model) {
        // Use the request or status to optionally return a ModelAndView
        return ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用常规的Spring MVC功能，例如<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers"><code>@ExceptionHandler</code>方法</a>和<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice"><code>@ControllerAdvice</code></a> 。的<code>ErrorController</code>然后获取所有未处理的异常。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-error-handling-mapping-error-pages-without-mvc"><a class="anchor" href="#boot-features-error-handling-mapping-error-pages-without-mvc"></a>在Spring MVC之外映射错误页面</h5>
<div class="paragraph">
<p>对于不使用Spring MVC的应用程序，可以使用<code>ErrorPageRegistrar</code>直接注册的界面<code>ErrorPages</code> 。此抽象直接与基础嵌入式servlet容器一起使用，即使您没有Spring MVC也可以使用<code>DispatcherServlet</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ErrorPageRegistrar errorPageRegistrar(){
    return new MyErrorPageRegistrar();
}

// ...

private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

    @Override
    public void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您注册一个<code>ErrorPage</code>路径最终被一个<code>Filter</code> （与某些非Spring Web框架（如Jersey和Wicket）常见），然后<code>Filter</code>必须明确注册为<code>ERROR</code>调度程序，如以下示例所示：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public FilterRegistrationBean myFilter() {
    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(new MyFilter());
    ...
    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
    return registration;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意默认<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。</p>
</div>
<div id="boot-features-error-handling-websphere" class="paragraph">
<p>注意：当Spring Boot部署到servlet容器时，将使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0及更高版本在成功完成servlet的服务方法后提交响应。您应该通过设置禁用此行为<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>至<code>false</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-hateoas"><a class="anchor" href="#boot-features-spring-hateoas"></a> 7.1.12。Spring HATEOAS </h4>
<div class="paragraph">
<p>如果您开发使用超媒体的RESTful API，Spring Boot会为Spring HATEOAS提供自动配置，该配置可与大多数应用程序很好地配合使用。自动配置取代了使用需求<code>@EnableHypermediaSupport</code>并注册了许多bean，以简化基于超媒体的应用程序的构建，包括<code>LinkDiscoverers</code> （用于客户端支持）和<code>ObjectMapper</code>配置为正确地将响应编组为所需的表示形式。的<code>ObjectMapper</code>通过设置各种来定制<code>spring.jackson.*</code>属性或（如果存在） <code>Jackson2ObjectMapperBuilder</code> bean 。</p>
</div>
<div class="paragraph">
<p>您可以使用来控制Spring HATEOAS的配置<code>@EnableHypermediaSupport</code> 。请注意，这样做会禁用<code>ObjectMapper</code>定制已在前面介绍过。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-cors"><a class="anchor" href="#boot-features-cors"></a> 7.1.13。CORS支持</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a> （CORS）是由<a href="https://caniuse.com/#feat=cors">大多数浏览器</a>实施的<a href="https://www.w3.org/TR/cors/">W3C规范</a> ，使您可以灵活地指定授权哪种类型的跨域请求，而不是使用一些安全性和功能不强的方法（例如IFRAME或JSONP） 。</p>
</div>
<div class="paragraph">
<p>从4.2版本开始，Spring MVC <a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-cors">支持CORS</a> 。使用<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-cors-controller">控制器方法CORS配置</a> <a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a> Spring Boot应用程序中的注释不需要任何特定的配置。
<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#mvc-cors-global">全局CORS配置</a>可以通过注册来定义<code>WebMvcConfigurer</code> bean 与定制<code>addCorsMappings(CorsRegistry)</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webflux"><a class="anchor" href="#boot-features-webflux"></a> 7.2。“ Spring WebFlux框架”</h3>
<div class="paragraph">
<p>Spring WebFlux是Spring Framework 5.0中引入的新的响应式Web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且无阻塞的，并通过<a href="https://projectreactor.io/">Reactor项目</a>实现<a href="https://www.reactive-streams.org/">Reactive Streams</a>规范。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux有两种形式：功能性的和基于注释的。基于注释的模型非常类似于Spring MVC模型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@RequestMapping("/users")
public class MyRestController {

    @GetMapping("/{user}")
    public Mono&lt;User&gt; getUser(@PathVariable Long user) {
        // ...
    }

    @GetMapping("/{user}/customers")
    public Flux&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @DeleteMapping("/{user}")
    public Mono&lt;User&gt; deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>功能变体“ WebFlux.fn”将路由配置与请求的实际处理分开，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class RoutingConfiguration {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler) {
        return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
                .andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
                .andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
    }

}

@Component
public class UserHandler {

    public Mono&lt;ServerResponse&gt; getUser(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; deleteUser(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux是Spring Framework的一部分，其<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn">参考文档中</a>提供了详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以定义尽可能多的<code>RouterFunction</code>您喜欢将bean模块化，以定义路由器的定义。如果需要应用优先级，可以订购Bean。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>首先，请添加<code>spring-boot-starter-webflux</code>模块到您的应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">两者都加<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>应用程序中的模块会导致Spring Boot自动配置Spring MVC，而不是WebFlux。之所以选择这种行为，是因为许多Spring开发人员添加了<code>spring-boot-starter-webflux</code>到他们的Spring MVC应用程序以使用反应式<code>WebClient</code> 。您仍然可以通过将所选应用程序类型设置为来强制执行选择<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-auto-configuration"><a class="anchor" href="#boot-features-webflux-auto-configuration"></a> 7.2.1。Spring WebFlux自动配置</h4>
<div class="paragraph">
<p>Spring Boot为Spring WebFlux提供了自动配置，可与大多数应用程序很好地配合使用。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认值之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>配置编解码器以用于<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例（ <a href="#boot-features-webflux-httpcodecs">在本文档后面部分介绍</a> ）。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（ <a href="#boot-features-spring-mvc-static-content">在本文档的后面部分中介绍</a> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想保留Spring Boot WebFlux功能并想要添加其他<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-config">WebFlux配置</a> ，则可以添加自己的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-config">配置</a> 。 <code>@Configuration</code>类型类别<code>WebFluxConfigurer</code>但<strong>没有</strong> <code>@EnableWebFlux</code> 。</p>
</div>
<div class="paragraph">
<p>如果您想完全控制Spring WebFlux，可以添加自己的<code>@Configuration</code>带有注释<code>@EnableWebFlux</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-httpcodecs"><a class="anchor" href="#boot-features-webflux-httpcodecs"></a> 7.2.2。带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h4>
<div class="paragraph">
<p>Spring WebFlux使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口以转换HTTP请求和响应。它们配置有<code>CodecConfigurer</code>通过查看类路径中可用的库来获得合理的默认值。</p>
</div>
<div class="paragraph">
<p>Spring Boot为编解码器提供了专用的配置属性， <code>spring.codec.*</code> 。它还通过使用进一步应用自定义<code>CodecCustomizer</code>实例。例如， <code>spring.jackson.*</code>配置密钥应用于杰克逊编解码器。</p>
</div>
<div class="paragraph">
<p>如果您需要添加或自定义编解码器，则可以创建自定义<code>CodecCustomizer</code>组件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.web.codec.CodecCustomizer;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return codecConfigurer -&gt; {
            // ...
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以利用<a href="#boot-features-json-components">Boot的自定义JSON序列化器和反序列化器</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-static-content"><a class="anchor" href="#boot-features-webflux-static-content"></a> 7.2.3。静态内容</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot从目录中提供静态内容<code>/static</code> （要么<code>/public</code>要么<code>/resources</code>要么<code>/META-INF/resources</code> ）在类路径中。它使用<code>ResourceWebHandler</code>来自Spring WebFlux，因此您可以通过添加自己的行为来修改该行为<code>WebFluxConfigurer</code>并覆盖<code>addResourceHandlers</code>方法。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射到<code>/**</code> ，但是您可以通过设置<code>spring.webflux.static-path-pattern</code>属性。例如，将所有资源重新定位到<code>/resources/**</code>可以实现如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.webflux.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用以下方法自定义静态资源位置<code>spring.resources.static-locations</code> 。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果有<code>index.html</code>在启动时在任何位置的应用程序的主页。</p>
</div>
<div class="paragraph">
<p>除了前面列出的“标准”静态资源位置外， <a href="https://www.webjars.org/">Webjars内容也</a>有特殊情况。路径中的任何资源<code>/webjars/**</code>如果jar文件以Webjars格式打包，则从jar文件提供。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring WebFlux应用程序不严格依赖Servlet API，因此不能将它们部署为war文件，也不能使用<code>src/main/webapp</code>目录。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-template-engines"><a class="anchor" href="#boot-features-webflux-template-engines"></a> 7.2.4。模板引擎</h4>
<div class="paragraph">
<p>除了REST Web服务之外，您还可以使用Spring WebFlux来提供动态HTML内容。Spring WebFlux支持多种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">胸腺</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在默认配置下使用这些模板引擎之一时，将从以下位置自动提取模板<code>src/main/resources/templates</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-error-handling"><a class="anchor" href="#boot-features-webflux-error-handling"></a> 7.2.5。错误处理</h4>
<div class="paragraph">
<p>Spring Boot提供了一个<code>WebExceptionHandler</code>以明智的方式处理所有错误。它在处理顺序中的位置紧靠WebFlux提供的处理程序之前，该处理程序被认为是最后一个。对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“ whitelabel”错误处理程序，以HTML格式呈现相同的数据。您还可以提供自己的HTML模板来显示错误（请参阅<a href="#boot-features-webflux-error-handling-custom-error-pages">下一节</a> ）。</p>
</div>
<div class="paragraph">
<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，您可以添加类型为ErrorAttributes的bean。</p>
</div>
<div class="paragraph">
<p>要更改错误处理行为，您可以实施<code>ErrorWebExceptionHandler</code>并注册该类型的bean定义。因为一个<code>WebExceptionHandler</code>是相当低级的，Spring Boot还提供了方便<code>AbstractErrorWebExceptionHandler</code>以便您以WebFlux功能方式处理错误，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

    // Define constructor here

    @Override
    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) {

        return RouterFunctions
                .route(aPredicate, aHandler)
                .andRoute(anotherPredicate, anotherHandler);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要获得更完整的图片，您也可以将其子类化<code>DefaultErrorWebExceptionHandler</code>直接并覆盖特定方法。</p>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-error-handling-custom-error-pages"><a class="anchor" href="#boot-features-webflux-error-handling-custom-error-pages"></a>自定义错误页面</h5>
<div class="paragraph">
<p>如果要显示给定状态代码的自定义HTML错误页面，则可以将文件添加到<code>/error</code>夹。错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板构建。文件名应为确切的状态代码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要映射<code>404</code>到静态HTML文件，您的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>映射全部<code>5xx</code>使用Mustache模板出现错误时，您的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.mustache
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-web-filters"><a class="anchor" href="#boot-features-webflux-web-filters"></a> 7.2.6。网页过滤器</h4>
<div class="paragraph">
<p>Spring WebFlux提供了一个<code>WebFilter</code>可以用来过滤HTTP请求-响应交换的接口。
<code>WebFilter</code>在应用程序上下文中找到的bean将自动用于过滤每个交换。</p>
</div>
<div class="paragraph">
<p>过滤器的顺序很重要的地方，他们可以实施<code>Ordered</code>或带有注释<code>@Order</code> 。Spring Boot自动配置可能会为您配置Web过滤器。这样做时，将使用下表中显示的顺序：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">网页过滤器</th>
<th class="tableblock halign-left valign-top">订购</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MetricsWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilterChainProxy</code> （Spring Security ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-100</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpTraceWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE - 10</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jersey"><a class="anchor" href="#boot-features-jersey"></a> 7.3。JAX-RS和泽西岛</h3>
<div class="paragraph">
<p>如果您更喜欢REST端点的JAX-RS编程模型，则可以使用可用的实现之一来代替Spring MVC。 <a href="https://jersey.github.io/">Jersey</a>和<a href="https://cxf.apache.org/">Apache CXF</a>开箱即用。CXF要求您注册其<code>Servlet</code>要么<code>Filter</code>作为一个<code>@Bean</code>在您的应用程序上下文中。Jersey提供了一些本机Spring支持，因此我们在Spring Boot中还与启动程序一起为其提供了自动配置支持。</p>
</div>
<div class="paragraph">
<p>要开始使用泽西岛，请包括<code>spring-boot-starter-jersey</code>作为依赖项，那么您需要一个<code>@Bean</code>类型的<code>ResourceConfig</code>在其中注册所有端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">泽西岛对扫描可执行归档文件的支持非常有限。例如，它无法扫描在<a href="deployment.html#deployment-install">完全可执行的jar文件中</a>或在<code>WEB-INF/classes</code>运行可执行的war文件时。为避免此限制， <code>packages</code>不应使用方法，并且应该使用<code>register</code>方法，如前面的示例所示。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于更高级的定制，您还可以注册任意数量的实现<code>ResourceConfigCustomizer</code> 。</p>
</div>
<div class="paragraph">
<p>所有注册的端点应为<code>@Components</code>带有HTTP资源注释（ <code>@GET</code>等），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Path("/hello")
public class Endpoint {

    @GET
    public String message() {
        return "Hello";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>自从<code>Endpoint</code>是 Spring <code>@Component</code> ，其生命周期由Spring管理，您可以使用<code>@Autowired</code>批注注入依赖项并使用<code>@Value</code>注解以注入外部配置。默认情况下，Jersey servlet已注册并映射到<code>/*</code> 。您可以通过添加来更改映射<code>@ApplicationPath</code>给你<code>ResourceConfig</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，Jersey被设置为<code>@Bean</code>类型的<code>ServletRegistrationBean</code>命名<code>jerseyServletRegistration</code> 。默认情况下，该Servlet延迟初始化，但是您可以通过设置<code>spring.jersey.servlet.load-on-startup</code> 。您可以通过创建自己的同名 bean 之一来禁用或覆盖该bean。您还可以通过以下方式使用过滤器而非Servlet： <code>spring.jersey.type=filter</code> （在这种情况下， <code>@Bean</code>替换或覆盖是<code>jerseyFilterRegistration</code> ）。过滤器有一个<code>@Order</code> ，您可以设置<code>spring.jersey.filter.order</code> 。可以通过使用以下命令为servlet和过滤器注册赋予init参数<code>spring.jersey.init.*</code>指定属性图。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-embedded-container"><a class="anchor" href="#boot-features-embedded-container"></a> 7.4。嵌入式Servlet容器支持</h3>
<div class="paragraph">
<p>Spring Boot包含对嵌入式<a href="https://tomcat.apache.org/">Tomcat</a> ， <a href="https://www.eclipse.org/jetty/">Jetty</a>和<a href="https://github.com/undertow-io/undertow">Undertow</a>服务器的支持。大多数开发人员使用适当的“入门”来获取完全配置的实例。默认情况下，嵌入式服务器在端口上侦听HTTP请求<code>8080</code> 。</p>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container-servlets-filters-listeners"><a class="anchor" href="#boot-features-embedded-container-servlets-filters-listeners"></a> 7.4.1。Servlet，过滤器和侦听器</h4>
<div class="paragraph">
<p>使用嵌入式Servlet容器时，您可以注册Servlet，过滤器和所有侦听器（例如<code>HttpSessionListener</code> ），请使用Servlet规范，或者使用Spring Bean或扫描Servlet组件。</p>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-servlets-filters-listeners-beans"><a class="anchor" href="#boot-features-embedded-container-servlets-filters-listeners-beans"></a>将Servlet，过滤器和侦听器注册为Spring Bean</h5>
<div class="paragraph">
<p>任何<code>Servlet</code> ， <code>Filter</code>或servlet <code>*Listener</code> Spring bean的实例已向嵌入式容器注册。如果您要引用自己的值，这可能会特别方便<code>application.properties</code>在配置过程中。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果上下文仅包含单个Servlet，则将其映射到<code>/</code> 。对于多个servlet bean，bean名称用作路径前缀。过滤器映射到<code>/*</code> 。</p>
</div>
<div class="paragraph">
<p>如果基于约定的映射不够灵活，则可以使用<code>ServletRegistrationBean</code> ， <code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>完全控制的类。</p>
</div>
<div class="paragraph">
<p>通常让无序滤 bean 处于安全状态。如果需要特定的订单，则应注释<code>Filter</code>与<code>@Order</code>或使其实现<code>Ordered</code> 。您无法配置<code>Filter</code>通过注释其bean方法<code>@Order</code> 。如果您无法更改<code>Filter</code>要添加的类<code>@Order</code>或实施<code>Ordered</code> ，您必须定义一个<code>FilterRegistrationBean</code>为了<code>Filter</code>并使用以下命令设置注册bean的顺序<code>setOrder(int)</code>方法。避免配置一个在以下位置读取请求正文的过滤器<code>Ordered.HIGHEST_PRECEDENCE</code> ，因为它可能与应用程序的字符编码配置背道而驰。如果Servlet过滤器包装了请求，则其配置顺序应小于或等于<code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">看到每个的顺序<code>Filter</code>在您的应用程序中，启用调试级别的日志记录<code>web</code> <a href="#boot-features-custom-log-groups">日志组</a> （ <code>logging.level.web=debug</code> ）。然后，将在启动时记录已注册过滤器的详细信息，包括其顺序和URL模式。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">注册时请多加注意<code>Filter</code> bean，因为它们是在应用程序生命周期中很早就初始化的。如果您需要注册一个<code>Filter</code>与其他bean交互的对象，请考虑使用<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/web/servlet/DelegatingFilterProxyRegistrationBean.html"><code>DelegatingFilterProxyRegistrationBean</code></a>代替。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container-context-initializer"><a class="anchor" href="#boot-features-embedded-container-context-initializer"></a> 7.4.2。Servlet上下文初始化</h4>
<div class="paragraph">
<p>嵌入式Servlet容器不会直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code>界面或Spring的<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意的设计决定，旨在降低设计用于战争中运行的第三方库可能破坏Spring Boot应用程序的风险。</p>
</div>
<div class="paragraph">
<p>如果您需要在Spring Boot应用程序中执行servlet上下文初始化，则应该注册一个实现了<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口。单<code>onStartup</code>方法提供对<code>ServletContext</code>并且，如有必要，可以轻松用作现有适配器<code>WebApplicationInitializer</code> 。</p>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-servlets-filters-listeners-scanning"><a class="anchor" href="#boot-features-embedded-container-servlets-filters-listeners-scanning"></a>扫描Servlet，过滤器和侦听器</h5>
<div class="paragraph">
<p>使用嵌入式容器时，自动注册带注释的类<code>@WebServlet</code> ， <code>@WebFilter</code>和<code>@WebListener</code>可以通过使用启用<code>@ServletComponentScan</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>@ServletComponentScan</code>在独立的容器中无效，而是使用容器的内置发现机制。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container-application-context"><a class="anchor" href="#boot-features-embedded-container-application-context"></a> 7.4.3。ServletWebServerApplicationContext</h4>
<div class="paragraph">
<p>在后台，Spring Boot使用了不同类型的<code>ApplicationContext</code>用于嵌入式Servlet容器支持。的<code>ServletWebServerApplicationContext</code>是一种特殊的<code>WebApplicationContext</code>通过搜索单个来引导自己<code>ServletWebServerFactory</code> bean 。通常是<code>TomcatServletWebServerFactory</code> ， <code>JettyServletWebServerFactory</code> ， 要么<code>UndertowServletWebServerFactory</code>已自动配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通常，您不需要了解这些实现类。大多数应用程序是自动配置的， <code>ApplicationContext</code>和<code>ServletWebServerFactory</code>是代表您创建的。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-customizing-embedded-containers"><a class="anchor" href="#boot-features-customizing-embedded-containers"></a> 7.4.4。自定义嵌入式Servlet容器</h4>
<div class="paragraph">
<p>可以使用Spring来配置常见的servlet容器设置<code>Environment</code>属性。通常，您将在<code>application.properties</code>文件。</p>
</div>
<div class="paragraph">
<p>常用服务器设置包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网络设置：监听传入HTTP请求的端口（ <code>server.port</code> ），要绑定的接口地址<code>server.address</code> ， 等等。</p>
</li>
<li>
<p>会话设置：会话是否持久（ <code>server.servlet.session.persistent</code> ）， 会话超时 （ <code>server.servlet.session.timeout</code> ），会话数据的位置（ <code>server.servlet.session.store-dir</code> ）和会话Cookie配置（ <code>server.servlet.session.cookie.*</code> ）。</p>
</li>
<li>
<p>错误管理：错误页面的位置（ <code>server.error.path</code> ） 等等。</p>
</li>
<li>
<p><a href="howto.html#howto-configure-ssl">SSL协议</a></p>
</li>
<li>
<p><a href="howto.html#how-to-enable-http-response-compression">HTTP压缩</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot尝试尽可能多地公开通用设置，但这并不总是可能的。在这种情况下，专用名称空间可提供服务器特定的自定义设置（请参见<code>server.tomcat</code>和<code>server.undertow</code> ）。例如，可以使用嵌入式servlet容器的特定功能配置<a href="howto.html#howto-configure-accesslogs">访问日志</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类以获取完整列表。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="boot-features-programmatic-embedded-container-customization"><a class="anchor" href="#boot-features-programmatic-embedded-container-customization"></a>程序定制</h5>
<div class="paragraph">
<p>如果您需要以编程方式配置嵌入式Servlet容器，则可以注册一个实现了<code>WebServerFactoryCustomizer</code>接口。
<code>WebServerFactoryCustomizer</code>提供对<code>ConfigurableServletWebServerFactory</code> ，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>TomcatServletWebServerFactory</code> ， <code>JettyServletWebServerFactory</code>和<code>UndertowServletWebServerFactory</code>是的专用变体<code>ConfigurableServletWebServerFactory</code>分别具有针对Tomcat，Jetty和Undertow的其他自定义设置方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-customizing-configurableservletwebserverfactory-directly"><a class="anchor" href="#boot-features-customizing-configurableservletwebserverfactory-directly"></a>直接自定义ConfigurableServletWebServerFactory</h5>
<div class="paragraph">
<p>如果上述自定义技术太有限，则可以注册<code>TomcatServletWebServerFactory</code> ， <code>JettyServletWebServerFactory</code> ， 要么<code>UndertowServletWebServerFactory</code>自己动手。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
    TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
    factory.setPort(9000);
    factory.setSessionTimeout(10, TimeUnit.MINUTES);
    factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
    return factory;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供了许多配置选项的设置器。如果您需要做一些更奇特的操作，还提供了几种受保护的方法“挂钩”。有关详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">源代码文档</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jsp-limitations"><a class="anchor" href="#boot-features-jsp-limitations"></a> 7.4.5。JSP局限性</h4>
<div class="paragraph">
<p>当运行使用嵌入式Servlet容器（并打包为可执行档案）的Spring Boot应用程序时，JSP支持存在一些限制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Jetty和Tomcat，如果使用战争包装，它应该可以工作。当与<code>java -jar</code> ，也可以部署到任何标准容器。使用可执行jar时，不支持JSP。</p>
</li>
<li>
<p>Undertow不支持JSP。</p>
</li>
<li>
<p>创建一个自定义<code>error.jsp</code>该页面不会覆盖默认视图以进行<a href="#boot-features-error-handling">错误处理</a> 。
应改用<a href="#boot-features-error-handling-custom-error-pages">自定义错误页面</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有一个<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp">JSP示例，</a>因此您可以了解如何进行设置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-reactive-server"><a class="anchor" href="#boot-features-reactive-server"></a> 7.5。嵌入式反应式服务器支持</h3>
<div class="paragraph">
<p>Spring Boot包含对以下嵌入式反应式Web服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。大多数开发人员使用适当的“入门”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-reactive-server-resources"><a class="anchor" href="#boot-features-reactive-server-resources"></a> 7.6。反应性服务器资源配置</h3>
<div class="paragraph">
<p>在自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，这些bean将向服务器实例提供HTTP资源： <code>ReactorResourceFactory</code>要么<code>JettyResourceFactory</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，在以下情况下，这些资源还将与Reactor Netty和Jetty客户端共享，以实现最佳性能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务器和客户端使用相同的技术</p>
</li>
<li>
<p>客户实例是使用<code>WebClient.Builder</code>由Spring Boot自动配置的bean</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>开发人员可以通过提供自定义来覆盖Jetty和Reactor Netty的资源配置<code>ReactorResourceFactory</code>要么<code>JettyResourceFactory</code> bean-这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="#boot-features-webclient-runtime">WebClient Runtime部分中</a>了解有关客户端资源配置的更多信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-rsocket"><a class="anchor" href="#boot-features-rsocket"></a> 8。插座</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rsocket.io">RSocket</a>是用于字节流传输的二进制协议。它通过通过单个连接传递的异步消息来启用对称交互模型。</p>
</div>
<div class="paragraph">
<p>的<code>spring-messaging</code> Spring Framework 的模块在客户端和服务器端都支持RSocket请求者和响应者。有关更多详细信息，请参见Spring Framework参考中的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#rsocket-spring">RSocket部分</a> ，其中包括RSocket协议的概述。</p>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-strategies-auto-configuration"><a class="anchor" href="#boot-features-rsocket-strategies-auto-configuration"></a> 8.1。RSocket策略自动配置</h3>
<div class="paragraph">
<p>Spring Boot自动配置<code>RSocketStrategies</code> bean提供了用于编码和解码RSocket有效负载的所有必需基础结构。默认情况下，自动配置将尝试按顺序配置以下内容：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Jackson的<a href="https://cbor.io/">CBOR</a>编解码器</p>
</li>
<li>
<p>杰克逊的JSON编解码器</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>的<code>spring-boot-starter-rsocket</code>启动程序提供了两个依赖项。查阅<a href="#boot-features-json-jackson">Jackson支持部分，</a>以了解有关定制可能性的更多信息。</p>
</div>
<div class="paragraph">
<p>开发人员可以自定义<code>RSocketStrategies</code>通过创建实现<code>RSocketStrategiesCustomizer</code>接口。注意他们<code>@Order</code>这很重要，因为它决定了编解码器的顺序。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-server-auto-configuration"><a class="anchor" href="#boot-features-rsocket-server-auto-configuration"></a> 8.2。RSocket服务器自动配置</h3>
<div class="paragraph">
<p>Spring Boot提供了RSocket服务器自动配置。所需的依赖项由<code>spring-boot-starter-rsocket</code> 。</p>
</div>
<div class="paragraph">
<p>Spring Boot允许从WebFlux服务器通过WebSocket公开RSocket，或支持独立的RSocket服务器。这取决于应用程序的类型及其配置。</p>
</div>
<div class="paragraph">
<p>对于WebFlux应用程序（即类型<code>WebApplicationType.REACTIVE</code> ），仅当以下属性匹配时，RSocket服务器才会插入Web服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
spring.rsocket.server.transport=websocket # websocket is chosen as a transport
#spring.rsocket.server.port= # no port is defined</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">由于RSocket本身是使用该库构建的，因此只有Reactor Netty支持将RSocket插入Web服务器。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另外，RSocket TCP或Websocket服务器也可以作为独立的嵌入式服务器启动。除了依赖性要求之外，唯一需要的配置是为该服务器定义端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.rsocket.server.port=9898 # the only required configuration
spring.rsocket.server.transport=tcp # you're free to configure other properties</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-messaging"><a class="anchor" href="#boot-features-rsocket-messaging"></a> 8.3。Spring Messaging RSocket支持</h3>
<div class="paragraph">
<p>Spring Boot将为RSocket自动配置Spring Messaging基础结构。</p>
</div>
<div class="paragraph">
<p>这意味着Spring Boot将创建一个<code>RSocketMessageHandler</code> bean，它将处理对应用程序的RSocket请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-requester"><a class="anchor" href="#boot-features-rsocket-requester"></a> 8.4。使用以下命令调用RSocket服务<code>RSocketRequester</code></h3>
<div class="paragraph">
<p>一旦<code>RSocket</code>服务器和客户端之间建立了通道，任何一方都可以向对方发送或接收请求。</p>
</div>
<div class="paragraph">
<p>作为服务器，您可以注入<code>RSocketRequester</code> RSocket的任何处理程序方法上的实例<code>@Controller</code> 。作为客户端，您需要首先配置和建立RSocket连接。Spring Boot自动配置<code>RSocketRequester.Builder</code>对于此类情况，需要使用预期的编解码器。</p>
</div>
<div class="paragraph">
<p>的<code>RSocketRequester.Builder</code> instance是一个原型bean，这意味着每个注入点将为您提供一个新实例。这是有意为之的，因为此构建器是有状态的，您不应使用同一实例创建具有不同设置的请求者。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

    private final RSocketRequester rsocketRequester;

    public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
        this.rsocketRequester = rsocketRequesterBuilder
                .connectTcp("example.org", 9898).block();
    }

    public Mono&lt;User&gt; someRSocketCall(String name) {
        return this.requester.route("user").data(name)
                .retrieveMono(User.class);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-security"><a class="anchor" href="#boot-features-security"></a> 9。安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果<a href="https://spring.io/projects/spring-security">Spring Security</a>在类路径上，则默认情况下Web应用程序是安全的。Spring Boot依靠Spring Security的内容协商策略来确定是否使用<code>httpBasic</code>要么<code>formLogin</code> 。要将方法级安全性添加到Web应用程序中，还可以添加<code>@EnableGlobalMethodSecurity</code>与您所需的设置。可以在《 <a href="https://docs.spring.io/spring-security/site/docs/5.2.1.RELEASE/reference/htmlsingle/#jc-method">Spring Security参考指南》中</a>找到更多信息。</p>
</div>
<div class="paragraph">
<p>默认值<code>UserDetailsService</code>有一个用户。用户名是<code>user</code> ，并且密码是随机的，并且在应用程序启动时以INFO级别显示，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您微调日志记录配置，请确保<code>org.springframework.boot.autoconfigure.security</code>类别设置为日志<code>INFO</code>级消息。否则，不会打印默认密码。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以通过提供一个<code>spring.security.user.name</code>和<code>spring.security.user.password</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，您在Web应用程序中获得的基本功能是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>UserDetailsService</code> （要么<code>ReactiveUserDetailsService</code> （对于WebFlux应用程序）具有内存存储的Bean和具有生成密码的单个用户（请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/autoconfigure/security/SecurityProperties.User.html"><code>SecurityProperties.User</code></a> （针对用户的属性）。</p>
</li>
<li>
<p>基于表单的登录或HTTP基本安全性（取决于<code>Accept</code>整个应用程序（请求中的标头）（如果执行器在类路径上，则包括执行器端点）。</p>
</li>
<li>
<p>一种<code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以提供其他<code>AuthenticationEventPublisher</code>通过添加一个beans。</p>
</div>
<div class="sect2">
<h3 id="boot-features-security-mvc"><a class="anchor" href="#boot-features-security-mvc"></a> 9.1。MVC安全</h3>
<div class="paragraph">
<p>默认的安全配置在<code>SecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code> 。
<code>SecurityAutoConfiguration</code>进口<code>SpringBootWebSecurityConfiguration</code>用于网络安全和<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这在非Web应用程序中也相关。要完全关闭默认的Web应用程序安全性配置或合并多个Spring Security组件（例如OAuth 2 Client和Resource Server），请添加一个类型为的bean <code>WebSecurityConfigurerAdapter</code> （这样做不会禁用<code>UserDetailsService</code>配置或执行器的安全性）。</p>
</div>
<div class="paragraph">
<p>也要关闭<code>UserDetailsService</code>配置，您可以添加一个类型的bean <code>UserDetailsService</code> ， <code>AuthenticationProvider</code> ， 要么<code>AuthenticationManager</code> 。</p>
</div>
<div class="paragraph">
<p>可以通过添加自定义规则来覆盖访问规则<code>WebSecurityConfigurerAdapter</code> 。Spring Boot提供了方便的方法，可用于覆盖执行器端点和静态资源的访问规则。
<code>EndpointRequest</code>可以用来创建一个<code>RequestMatcher</code>这是基于<code>management.endpoints.web.base-path</code>属性。
<code>PathRequest</code>可以用来创建一个<code>RequestMatcher</code>用于常用位置的资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-webflux"><a class="anchor" href="#boot-features-security-webflux"></a> 9.2。WebFlux安全</h3>
<div class="paragraph">
<p>与Spring MVC应用程序类似，您可以通过添加以下内容来保护WebFlux应用程序： <code>spring-boot-starter-security</code>依赖性。默认的安全配置在<code>ReactiveSecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code> 。
<code>ReactiveSecurityAutoConfiguration</code>进口<code>WebFluxSecurityConfiguration</code>用于网络安全和<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这在非Web应用程序中也相关。要完全关闭默认的Web应用程序安全性配置，可以添加Bean类型<code>WebFilterChainProxy</code> （这样做不会禁用<code>UserDetailsService</code>配置或执行器的安全性）。</p>
</div>
<div class="paragraph">
<p>也要关闭<code>UserDetailsService</code>配置，您可以添加一个类型的bean <code>ReactiveUserDetailsService</code>要么<code>ReactiveAuthenticationManager</code> 。</p>
</div>
<div class="paragraph">
<p>可以通过添加自定义配置访问规则以及使用多个Spring Security组件（例如OAuth 2 Client和Resource Server） <code>SecurityWebFilterChain</code> bean 。Spring Boot提供了方便的方法，可用于覆盖执行器端点和静态资源的访问规则。
<code>EndpointRequest</code>可以用来创建一个<code>ServerWebExchangeMatcher</code>这是基于<code>management.endpoints.web.base-path</code>属性。</p>
</div>
<div class="paragraph">
<p><code>PathRequest</code>可以用来创建一个<code>ServerWebExchangeMatcher</code>用于常用位置的资源。</p>
</div>
<div class="paragraph">
<p>例如，您可以通过添加以下内容来自定义安全配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange()
            .matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
            .pathMatchers("/foo", "/bar")
                .authenticated().and()
            .formLogin().and()
        .build();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-oauth2"><a class="anchor" href="#boot-features-security-oauth2"></a> 9.3。OAuth2</h3>
<div class="paragraph">
<p><a href="https://oauth.net/2/">OAuth2</a>是Spring支持的一种广泛使用的授权框架。</p>
</div>
<div class="sect3">
<h4 id="boot-features-security-oauth2-client"><a class="anchor" href="#boot-features-security-oauth2-client"></a> 9.3.1。客户</h4>
<div class="paragraph">
<p>如果你有<code>spring-security-oauth2-client</code>在类路径上，您可以利用一些自动配置功能来轻松设置OAuth2 / Open ID Connect客户端。此配置使用以下属性<code>OAuth2ClientProperties</code> 。相同的属性适用于servlet和反应式应用程序。</p>
</div>
<div class="paragraph">
<p>您可以在以下位置注册多个OAuth2客户端和提供程序<code>spring.security.oauth2.client</code>前缀，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.oauth2.client.registration.my-client-1.client-id=abcd
spring.security.oauth2.client.registration.my-client-1.client-secret=password
spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-1.scope=user
spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

spring.security.oauth2.client.registration.my-client-2.client-id=abcd
spring.security.oauth2.client.registration.my-client-2.client-secret=password
spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-2.scope=email
spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于支持<a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect发现的</a> OpenID Connect提供程序，可以进一步简化配置。提供商需要配置一个<code>issuer-uri</code>它是URI声明为其发布者标识符的URI。例如，如果<code>issuer-uri</code>提供的是“ https://example.com”，然后<code>OpenID Provider Configuration Request</code>将被设为“ https://example.com/.well-known/openid-configuration”。结果预期为<code>OpenID Provider Configuration Response</code> 。以下示例显示了如何使用以下命令配置OpenID Connect Provider： <code>issuer-uri</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Spring Security的<code>OAuth2LoginAuthenticationFilter</code>仅处理匹配的网址<code>/login/oauth2/code/*</code> 。如果要自定义<code>redirect-uri</code>要使用其他模式，您需要提供配置以处理该自定义模式。例如，对于servlet应用程序，您可以添加自己的<code>WebSecurityConfigurerAdapter</code>类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2Login()
                .redirectionEndpoint()
                    .baseUri("/custom-callback");
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-security-oauth2-common-providers"><a class="anchor" href="#boot-features-security-oauth2-common-providers"></a>普通提供商的OAuth2客户端注册</h5>
<div class="paragraph">
<p>对于常见的OAuth2和OpenID提供程序，包括Google，Github，Facebook和Okta，我们提供了一组提供程序默认值（ <code>google</code> ， <code>github</code> ， <code>facebook</code>和<code>okta</code> ， 分别）。</p>
</div>
<div class="paragraph">
<p>如果您不需要自定义这些提供程序，则可以设置<code>provider</code>属性，您需要为其推断默认值。另外，如果用于客户端注册的密钥与默认支持的提供程序匹配，则Spring Boot也会进行推断。</p>
</div>
<div class="paragraph">
<p>换句话说，以下示例中的两个配置都使用Google提供程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.oauth2.client.registration.my-client.client-id=abcd
spring.security.oauth2.client.registration.my-client.client-secret=password
spring.security.oauth2.client.registration.my-client.provider=google

spring.security.oauth2.client.registration.google.client-id=abcd
spring.security.oauth2.client.registration.google.client-secret=password</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-oauth2-server"><a class="anchor" href="#boot-features-security-oauth2-server"></a> 9.3.2。资源服务器</h4>
<div class="paragraph">
<p>如果你有<code>spring-security-oauth2-resource-server</code>在您的类路径上，Spring Boot可以设置一个OAuth2资源服务器。对于JWT配置，需要指定JWK设置URI或OIDC颁发者URI，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果授权服务器不支持JWK设置URI，则可以使用用于验证JWT签名的公共密钥来配置资源服务器。可以使用<code>spring.security.oauth2.resourceserver.jwt.public-key-location</code>属性，其中值需要指向包含PEM编码的x509格式的公共密钥的文件。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>相同的属性适用于servlet和反应式应用程序。</p>
</div>
<div class="paragraph">
<p>或者，您可以定义自己的<code>JwtDecoder</code>用于servlet应用程序的bean或<code>ReactiveJwtDecoder</code>用于反应性应用。</p>
</div>
<div class="paragraph">
<p>如果使用不透明令牌而不是JWT，则可以配置以下属性以通过自省来验证令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，相同的属性适用于servlet和反应式应用程序。</p>
</div>
<div class="paragraph">
<p>或者，您可以定义自己的<code>OpaqueTokenIntrospector</code>用于servlet应用程序的bean或<code>ReactiveOpaqueTokenIntrospector</code>用于反应性应用。</p>
</div>
</div>
<div class="sect3">
<h4 id="authorization-server"><a class="anchor" href="#authorization-server"></a> 9.3.3。授权服务器</h4>
<div class="paragraph">
<p>当前，Spring Security不提供对实现OAuth 2.0授权服务器的支持。但是， <a href="https://spring.io/projects/spring-security-oauth">Spring Security OAuth</a>项目提供了此功能，最终将被Spring Security完全取代。在此之前，您可以使用<code>spring-security-oauth2-autoconfigure</code>轻松设置OAuth 2.0授权服务器的模块；有关说明，请参见其<a href="https://docs.spring.io/spring-security-oauth2-boot">文档</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-saml"><a class="anchor" href="#boot-features-security-saml"></a> 9.4。SAML 2.0</h3>
<div class="sect3">
<h4 id="boot-features-security-saml2-relying-party"><a class="anchor" href="#boot-features-security-saml2-relying-party"></a> 9.4.1。依赖党</h4>
<div class="paragraph">
<p>如果你有<code>spring-security-saml2-service-provider</code>在类路径上，您可以利用一些自动配置功能来轻松设置SAML 2.0依赖方。此配置使用以下属性<code>Saml2RelyingPartyProperties</code> 。</p>
</div>
<div class="paragraph">
<p>依赖方注册代表身份提供商IDP和服务提供商SP之间的配对配置。您可以在<code>spring.security.saml2.relyingparty</code>前缀，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-actuator"><a class="anchor" href="#boot-features-security-actuator"></a> 9.5。执行器安全</h3>
<div class="paragraph">
<p>为了安全起见，除<code>/health</code>和<code>/info</code>默认情况下处于禁用状态。的<code>management.endpoints.web.exposure.include</code>属性可用于启用执行器。</p>
</div>
<div class="paragraph">
<p>如果Spring Security在类路径上，并且不存在其他WebSecurityConfigurerAdapter，则除<code>/health</code>和<code>/info</code>由Spring Boot自动配置保护。如果您定义一个自定义<code>WebSecurityConfigurerAdapter</code> ，Spring Boot自动配置将退出，您将完全控制执行器访问规则。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置之前<code>management.endpoints.web.exposure.include</code>请确保裸露的执行器不包含敏感信息和/或通过将它们放置在防火墙后面或通过诸如Spring Security之类的东西进行保护。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-security-csrf"><a class="anchor" href="#boot-features-security-csrf"></a> 9.5.1。跨站点请求伪造保护</h4>
<div class="paragraph">
<p>由于Spring Boot依赖于Spring Security的默认值，因此默认情况下CSRF保护是打开的。这意味着需要一个<code>POST</code> （关闭和记录器端点）， <code>PUT</code>要么<code>DELETE</code>使用默认的安全配置时，将收到403禁止错误。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们建议仅在创建非浏览器客户端使用的服务时完全禁用CSRF保护。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>关于CSRF保护的其他信息可以在<a href="https://docs.spring.io/spring-security/site/docs/5.2.1.RELEASE/reference/htmlsingle/#csrf">Spring Security Reference Guide中找到</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-sql"><a class="anchor" href="#boot-features-sql"></a> 10。使用SQL数据库</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-framework">Spring Framework </a>为使用SQL数据库提供了广泛的支持，从直接JDBC访问使用<code>JdbcTemplate</code>完成诸如Hibernate之类的“对象关系映射”技术。
<a href="https://spring.io/projects/spring-data">Spring Data</a>提供了附加功能：创建<code>Repository</code>直接从接口实现，并使用约定从您的方法名称生成查询。</p>
</div>
<div class="sect2">
<h3 id="boot-features-configure-datasource"><a class="anchor" href="#boot-features-configure-datasource"></a> 10.1。配置数据源</h3>
<div class="paragraph">
<p>Java的<code>javax.sql.DataSource</code>接口提供了使用数据库连接的标准方法。传统上，“数据源”使用<code>URL</code>以及一些建立数据库连接的凭据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关更多高级示例，请参见<a href="howto.html#howto-configure-a-datasource">“操作方法”部分</a> ，通常可以完全控制DataSource的配置。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-database-support"><a class="anchor" href="#boot-features-embedded-database-support"></a> 10.1.1。嵌入式数据库支持</h4>
<div class="paragraph">
<p>使用内存嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">“操作方法”部分包括<a href="howto.html#howto-database-initialization">有关如何初始化数据库的部分</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Boot可以自动配置嵌入式<a href="https://www.h2database.com">H2</a> ， <a href="http://hsqldb.org/">HSQL</a>和<a href="https://db.apache.org/derby/">Derby</a>数据库。您无需提供任何连接URL。您只需要包含要使用的嵌入式数据库的构建依赖项即可。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在测试中使用此功能，则可能会注意到整个数据库都可以重复使用同一数据库，而不管您使用的应用程序上下文有多少。如果要确保每个上下文都有一个单独的嵌入式数据库，则应设置<code>spring.datasource.generate-unique-name</code>至<code>true</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，典型的POM依赖关系如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您需要依赖<code>spring-jdbc</code>用于自动配置嵌入式数据库。在此示例中，将其通过<code>spring-boot-starter-data-jpa</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果出于某种原因确实为嵌入式数据库配置了连接URL，请务必确保禁用了数据库的自动关闭功能。如果使用H2，则应使用<code>DB_CLOSE_ON_EXIT=FALSE</code>这样做。如果使用HSQLDB，则应确保<code>shutdown=true</code>未使用。通过禁用数据库的自动关闭功能，Spring Boot可以控制何时关闭数据库，从而确保一旦不再需要访问数据库时就可以执行该操作。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connect-to-production-database"><a class="anchor" href="#boot-features-connect-to-production-database"></a> 10.1.2。连接到生产数据库</h4>
<div class="paragraph">
<p>生产数据库连接也可以通过使用池自动配置<code>DataSource</code> 。Spring Boot使用以下算法来选择特定的实现：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>我们更喜欢<a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>的性能和并发性。如果有HikariCP，我们总是选择它。</p>
</li>
<li>
<p>否则，如果Tomcat池化<code>DataSource</code>可用，我们使用它。</p>
</li>
<li>
<p>如果HikariCP和Tomcat池数据源均不可用，并且<a href="https://commons.apache.org/proper/commons-dbcp/">Commons DBCP2</a>不可用，我们将使用它。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果您使用<code>spring-boot-starter-jdbc</code>要么<code>spring-boot-starter-data-jpa</code> “入门者”，您会自动获得对<code>HikariCP</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以完全绕过该算法，并通过设置以下参数来指定要使用的连接池<code>spring.datasource.type</code>属性。如果您在Tomcat容器中运行应用程序，这尤其重要，因为<code>tomcat-jdbc</code>默认情况下提供。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">其他连接池始终可以手动配置。如果您定义自己的<code>DataSource</code> bean，不会发生自动配置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>DataSource配置由以下位置中的外部配置属性控制： <code>spring.datasource.*</code> 。例如，您可以在<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您至少应通过设置网址来指定网址<code>spring.datasource.url</code>属性。否则，Spring Boot会尝试自动配置嵌入式数据库。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您通常不需要指定<code>driver-class-name</code> ，因为Spring Boot可以从<code>url</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于池<code>DataSource</code>要创建，我们需要能够验证有效<code>Driver</code>类可用，所以我们在做任何事情之前都要检查一下。换句话说，如果您设定<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code> ，则该类必须是可加载的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a>以获得更多受支持的选项。这些是不管实际实现如何都起作用的标准选项。也可以使用它们各自的前缀来微调实现特定的设置（ <code>spring.datasource.hikari.*</code> ， <code>spring.datasource.tomcat.*</code>和<code>spring.datasource.dbcp2.*</code> ）。有关更多详细信息，请参考所用连接池实现的文档。</p>
</div>
<div class="paragraph">
<p>例如，如果使用<a href="https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes">Tomcat连接池</a> ，则可以自定义许多其他设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Number of ms to wait before throwing an exception if no connection is available.
spring.datasource.tomcat.max-wait=10000

# Maximum number of active connections that can be allocated from this pool at the same time.
spring.datasource.tomcat.max-active=50

# Validate the connection before borrowing it from the pool.
spring.datasource.tomcat.test-on-borrow=true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-a-jndi-datasource"><a class="anchor" href="#boot-features-connecting-to-a-jndi-datasource"></a> 10.1.3。连接到JNDI数据源</h4>
<div class="paragraph">
<p>如果您将Spring Boot应用程序部署到Application Server，则可能需要使用Application Server的内置功能来配置和管理DataSource，并使用JNDI对其进行访问。</p>
</div>
<div class="paragraph">
<p>的<code>spring.datasource.jndi-name</code>属性可以用作<code>spring.datasource.url</code> ， <code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性访问<code>DataSource</code>从特定的JNDI位置。例如，以下部分<code>application.properties</code>显示了如何访问定义的JBoss AS <code>DataSource</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.datasource.jndi-name=java:jboss/datasources/customers</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-using-jdbc-template"><a class="anchor" href="#boot-features-using-jdbc-template"></a> 10.2。使用JdbcTemplate</h3>
<div class="paragraph">
<p> Spring 的<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>将它们直接放入自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public MyBean(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用来自定义模板的某些属性<code>spring.jdbc.template.*</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.jdbc.template.max-rows=500</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>NamedParameterJdbcTemplate</code>重复使用<code>JdbcTemplate</code>幕后实例。如果不止一个<code>JdbcTemplate</code>被定义并且不存在主要候选者， <code>NamedParameterJdbcTemplate</code>未自动配置。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jpa-and-spring-data"><a class="anchor" href="#boot-features-jpa-and-spring-data"></a> 10.3。JPA和Spring Data JPA</h3>
<div class="paragraph">
<p>Java Persistence API是一种标准技术，可让您将对象“映射”到关系数据库。的<code>spring-boot-starter-data-jpa</code> POM提供了一种快速的入门方法。它提供以下关键依赖性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hibernate：最流行的JPA实现之一。</p>
</li>
<li>
<p>Spring Data JPA：使基于JPA的存储库的实现变得容易。</p>
</li>
<li>
<p>Spring ORM：Spring Framework提供的核心ORM支持。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在这里，我们不会过多讨论JPA或<a href="https://spring.io/projects/spring-data">Spring Data</a> 。您可以按照<a href="https://spring.io/guides/gs/accessing-data-jpa/">“访问数据与JPA”</a>从指导<a href="https://spring.io" class="bare">spring.io</a>并宣读了<a href="https://spring.io/projects/spring-data-jpa"> Spring 的数据JPA</a>和<a href="https://hibernate.org/orm/documentation/">Hibernate的</a>参考文档。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-entity-classes"><a class="anchor" href="#boot-features-entity-classes"></a> 10.3.1。实体类别</h4>
<div class="paragraph">
<p>传统上，JPA“实体”类是在<code>persistence.xml</code>文件。在Spring Boot中，此文件不是必需的，而是使用“实体扫描”。默认情况下，主配置类下的所有软件包（用注释的软件包<code>@EnableAutoConfiguration</code>要么<code>@SpringBootApplication</code> ）进行搜索。</p>
</div>
<div class="paragraph">
<p>任何带注释的类<code>@Entity</code> ， <code>@Embeddable</code> ， 要么<code>@MappedSuperclass</code>被考虑。典型的实体类类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.myapp.domain;

import java.io.Serializable;
import javax.persistence.*;

@Entity
public class City implements Serializable {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String state;

    // ... additional members, often include @OneToMany mappings

    protected City() {
        // no-args constructor required by JPA spec
        // this one is protected since it shouldn't be used directly
    }

    public City(String name, String state) {
        this.name = name;
        this.state = state;
    }

    public String getName() {
        return this.name;
    }

    public String getState() {
        return this.state;
    }

    // ... etc

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以使用来自定义实体扫描位置<code>@EntityScan</code>注解。请参阅“ <a href="howto.html#howto-separate-entity-definitions-from-spring-configuration">howto.html</a> ”方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-jpa-repositories"><a class="anchor" href="#boot-features-spring-data-jpa-repositories"></a> 10.3.2。Spring Data JPA存储库</h4>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a>存储库是可以定义以访问数据的接口。JPA查询是根据您的方法名称自动创建的。例如，一个<code>CityRepository</code>接口可能会声明一个<code>findAllByState(String state)</code>查找给定状态下所有城市的方法。</p>
</div>
<div class="paragraph">
<p>对于更复杂的查询，您可以使用Spring Data的方法注释您的方法<a href="https://docs.spring.io/spring-data/jpa/docs/2.2.1.RELEASE/api/org/springframework/data/jpa/repository/Query.html"><code>Query</code></a>注解。</p>
</div>
<div class="paragraph">
<p>Spring Data存储库通常从<a href="https://docs.spring.io/spring-data/commons/docs/2.2.1.RELEASE/api/org/springframework/data/repository/Repository.html"><code>Repository</code></a>要么<a href="https://docs.spring.io/spring-data/commons/docs/2.2.1.RELEASE/api/org/springframework/data/repository/CrudRepository.html"><code>CrudRepository</code></a>接口。如果您使用自动配置，则会从包含您的主要配置类的程序包中搜索存储库（用注释<code>@EnableAutoConfiguration</code>要么<code>@SpringBootApplication</code> ） 下。</p>
</div>
<div class="paragraph">
<p>以下示例显示了典型的Spring Data存储库接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Data JPA存储库支持三种不同的引导模式：默认，延迟和延迟。要启用延迟引导或延迟引导，请设置<code>spring.data.jpa.repositories.bootstrap-mode</code>财产<code>deferred</code>要么<code>lazy</code>分别。使用延迟启动或延迟启动时，自动配置<code>EntityManagerFactoryBuilder</code>将使用上下文的<code>AsyncTaskExecutor</code> （如果有）作为引导执行程序。如果存在一个以上，则命名为<code>applicationTaskExecutor</code>将会被使用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们几乎没有刮过Spring Data JPA的表面。有关完整的详细信息，请参见<a href="https://docs.spring.io/spring-data/jdbc/docs/1.1.1.RELEASE/reference/html/">Spring Data JPA参考文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-creating-and-dropping-jpa-databases"><a class="anchor" href="#boot-features-creating-and-dropping-jpa-databases"></a> 10.3.3。创建和删除JPA数据库</h4>
<div class="paragraph">
<p>默认情况下， <strong>仅</strong>当您使用嵌入式数据库（H2，HSQL或Derby）时， <strong>才会</strong>自动创建JPA数据库。您可以使用来显式配置JPA设置<code>spring.jpa.*</code>属性。例如，要创建和删除表格，您可以将以下行添加到<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.hibernate.ddl-auto=create-drop</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Hibernate自己的内部属性名称是（如果您碰巧记得的话）是<code>hibernate.hbm2ddl.auto</code> 。您可以通过使用以下命令来设置它以及其他Hibernate本机属性： <code>spring.jpa.properties.*</code> （先删除前缀，然后再将其添加到实体管理器中）。下面的行显示了为Hibernate设置JPA属性的示例：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.properties.hibernate.globally_quoted_identifiers=true</pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的行传递的值为<code>true</code>为了<code>hibernate.globally_quoted_identifiers</code>属性分配给Hibernate实体管理器。</p>
</div>
<div class="paragraph">
<p>默认情况下，DDL执行（或验证）推迟到<code>ApplicationContext</code>已开始。还有一个<code>spring.jpa.generate-ddl</code>标志，但是如果Hibernate自动配置处于活动状态，则不会使用该标志，因为<code>ddl-auto</code>设置更细粒度。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jpa-in-web-environment"><a class="anchor" href="#boot-features-jpa-in-web-environment"></a> 10.3.4。在视图中打开EntityManager</h4>
<div class="paragraph">
<p>如果您正在运行Web应用程序，则默认情况下会注册Spring Boot <a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html"><code>OpenEntityManagerInViewInterceptor</code></a>应用“在视图中打开EntityManager”模式，以允许在Web视图中进行延迟加载。如果您不希望出现这种情况，则应设置<code>spring.jpa.open-in-view</code>至<code>false</code>在你的<code>application.properties</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-data-jdbc"><a class="anchor" href="#boot-features-data-jdbc"></a> 10.4。Spring Data JDBC</h3>
<div class="paragraph">
<p>Spring Data包括对JDBC的存储库支持，并将为以下方法自动生成SQL： <code>CrudRepository</code> 。对于更高级的查询， <code>@Query</code>提供了注释。</p>
</div>
<div class="paragraph">
<p>当必要的依赖项位于类路径上时，Spring Boot将自动配置Spring Data的JDBC存储库。可以将它们添加到您的项目中，并且仅依赖于<code>spring-boot-starter-data-jdbc</code> 。如有必要，您可以通过添加以下内容来控制Spring Data JDBC的配置： <code>@EnableJdbcRepositories</code>注释或<code>JdbcConfiguration</code>子类到您的应用程序。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关Spring Data JDBC的完整详细信息，请参考<a href="https://docs.spring.io/spring-data/jdbc/docs/1.1.1.RELEASE/reference/html/">参考文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-sql-h2-console"><a class="anchor" href="#boot-features-sql-h2-console"></a> 10.5。使用H2的Web控制台</h3>
<div class="paragraph">
<p><a href="https://www.h2database.com">H2数据库</a>提供了一个<a href="https://www.h2database.com/html/quickstart.html#h2_console">基于浏览器的控制台</a> ，Spring Boot可以为您自动配置该<a href="https://www.h2database.com/html/quickstart.html#h2_console">控制台</a> 。满足以下条件时，将自动配置控制台：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您正在开发基于servlet的Web应用程序。</p>
</li>
<li>
<p><code>com.h2database:h2</code>在类路径上。</p>
</li>
<li>
<p>您正在使用<a href="using-spring-boot.html#using-boot-devtools">Spring Boot的开发人员工具</a> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您不使用Spring Boot的开发人员工具，但仍想使用H2的控制台，则可以配置<code>spring.h2.console.enabled</code>值为的属性<code>true</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">H2控制台仅在开发期间使用，因此您应注意确保<code>spring.h2.console.enabled</code>未设置为<code>true</code>在生产中。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-sql-h2-console-custom-path"><a class="anchor" href="#boot-features-sql-h2-console-custom-path"></a> 10.5.1。更改H2控制台的路径</h4>
<div class="paragraph">
<p>默认情况下，控制台位于<code>/h2-console</code> 。您可以使用以下命令自定义控制台的路径<code>spring.h2.console.path</code>属性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jooq"><a class="anchor" href="#boot-features-jooq"></a> 10.6。使用jOOQ</h3>
<div class="paragraph">
<p>jOOQ面向对象查询（ <a href="https://www.jooq.org/">jOOQ</a> ）是<a href="https://www.datageekery.com/">Data Geekery的</a>一种流行产品，它可以从数据库中生成Java代码，并允许您通过其流畅的API构建类型安全的SQL查询。商业版和开源版都可以与Spring Boot一起使用。</p>
</div>
<div class="sect3">
<h4 id="code-generation"><a class="anchor" href="#code-generation"></a> 10.6.1。代码生成</h4>
<div class="paragraph">
<p>为了使用jOOQ类型安全查询，您需要从数据库架构中生成Java类。您可以按照<a href="https://www.jooq.org/doc/3.12.3/manual-single-page/#jooq-in-7-steps-step3">jOOQ用户手册中</a>的说明进行<a href="https://www.jooq.org/doc/3.12.3/manual-single-page/#jooq-in-7-steps-step3">操作</a> 。如果您使用<code>jooq-codegen-maven</code>插件，您还可以使用<code>spring-boot-starter-parent</code> “父POM”，则可以安全地忽略插件的<code><version></code>标签。您还可以使用Spring Boot定义的版本变量（例如<code>h2.version</code> ）来声明插件的数据库依赖关系。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.jooq&lt;/groupId&gt;
    &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;
    &lt;executions&gt;
        ...
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;version&gt;${h2.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;configuration&gt;
        &lt;jdbc&gt;
            &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
            &lt;url&gt;jdbc:h2:~/yourdatabase&lt;/url&gt;
        &lt;/jdbc&gt;
        &lt;generator&gt;
            ...
        &lt;/generator&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-dslcontext"><a class="anchor" href="#using-dslcontext"></a> 10.6.2。使用DSLContext</h4>
<div class="paragraph">
<p>jOOQ提供的流畅API是通过以下方式启动的： <code>org.jooq.DSLContext</code>接口。Spring Boot自动配置一个<code>DSLContext</code>作为Spring Bean并将其连接到您的应用程序<code>DataSource</code> 。要使用<code>DSLContext</code> ， 您可以<code>@Autowire</code>如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class JooqExample implements CommandLineRunner {

    private final DSLContext create;

    @Autowired
    public JooqExample(DSLContext dslContext) {
        this.create = dslContext;
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">jOOQ手册倾向于使用名为<code>create</code>举行<code>DSLContext</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>DSLContext</code>构造查询，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public List&lt;GregorianCalendar&gt; authorsBornAfter1980() {
    return this.create.selectFrom(AUTHOR)
        .where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
        .fetch(AUTHOR.DATE_OF_BIRTH);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jooq-sql-dialect"><a class="anchor" href="#jooq-sql-dialect"></a> 10.6.3。 jOOQ SQL方言</h4>
<div class="paragraph">
<p>除非<code>spring.jooq.sql-dialect</code>属性已经配置，Spring Boot决定要用于您的数据源的SQL语言。如果Spring Boot无法检测到方言，它将使用<code>DEFAULT</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot只能自动配置开源版本的jOOQ支持的方言。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="customizing-jooq"><a class="anchor" href="#customizing-jooq"></a> 10.6.4。定制jOOQ</h4>
<div class="paragraph">
<p>通过定义自己的样式，可以实现更高级的自定义<code>@Bean</code>定义，在jOOQ时使用<code>Configuration</code>被建造。您可以为以下jOOQ类型定义bean：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ConnectionProvider</code></p>
</li>
<li>
<p><code>ExecutorProvider</code></p>
</li>
<li>
<p><code>TransactionProvider</code></p>
</li>
<li>
<p><code>RecordMapperProvider</code></p>
</li>
<li>
<p><code>RecordUnmapperProvider</code></p>
</li>
<li>
<p><code>Settings</code></p>
</li>
<li>
<p><code>RecordListenerProvider</code></p>
</li>
<li>
<p><code>ExecuteListenerProvider</code></p>
</li>
<li>
<p><code>VisitListenerProvider</code></p>
</li>
<li>
<p><code>TransactionListenerProvider</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您也可以创建自己的<code>org.jooq.Configuration</code><code>@Bean</code>如果要完全控制jOOQ配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-nosql"><a class="anchor" href="#boot-features-nosql"></a> 11。使用NoSQL技术</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data提供了其他项目来帮助您访问各种NoSQL技术，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/projects/spring-data-mongodb">MongoDB</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-neo4j">Neo4J</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-elasticsearch">弹性搜索</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-solr">索尔</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-redis">雷迪斯</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-gemfire">GemFire</a>或<a href="https://spring.io/projects/spring-data-geode">Geode</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-cassandra">卡桑德拉</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-ldap">LDAP</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。您可以使用其他项目，但必须自己进行配置。请参阅相应的参考文档，位于<a href="https://spring.io/projects/spring-data" class="bare">spring.io/projects/spring-data</a> 。</p>
</div>
<div class="sect2">
<h3 id="boot-features-redis"><a class="anchor" href="#boot-features-redis"></a> 11.1。雷迪斯</h3>
<div class="paragraph">
<p><a href="https://redis.io/">Redis</a>是一个缓存，消息代理和功能丰富的键值存储。Spring Boot为<a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>和<a href="https://github.com/xetorthio/jedis/">Jedis</a>客户端库以及<a href="https://github.com/spring-projects/spring-data-redis">Spring Data Redis</a>提供的在它们之上的抽象提供了基本的自动配置。</p>
</div>
<div class="paragraph">
<p>有一个<code>spring-boot-starter-data-redis</code> “启动器”，用于以方便的方式收集依赖项。默认情况下，它使用<a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a> 。该启动程序可以处理传统应用程序和响应式应用程序。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们还提供<code>spring-boot-starter-data-redis-reactive</code> “入门”可与其他具有反应性支持的商店保持一致。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-redis"><a class="anchor" href="#boot-features-connecting-to-redis"></a> 11.1.1。连接到Redis</h4>
<div class="paragraph">
<p>您可以注入自动配置的<code>RedisConnectionFactory</code> ， <code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>实例，就像其他任何Spring Bean一样。默认情况下，实例尝试在以下位置连接到Redis服务器<code>localhost:6379</code> 。下面的清单显示了这种Bean的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private StringRedisTemplate template;

    @Autowired
    public MyBean(StringRedisTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您还可以注册任意数量的实现<code>LettuceClientConfigurationBuilderCustomizer</code>进行更高级的自定义。如果您使用Jedis， <code>JedisClientConfigurationBuilderCustomizer</code>也可以。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您添加自己的<code>@Bean</code>任何一种自动配置的类型，它将替换默认值（除非是<code>RedisTemplate</code> ，如果排除基于Bean名称， <code>redisTemplate</code> ，而不是其类型）。默认情况下，如果<code>commons-pool2</code>在类路径上，您将获得一个池化连接工厂。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-mongodb"><a class="anchor" href="#boot-features-mongodb"></a> 11.2。MongoDB</h3>
<div class="paragraph">
<p><a href="https://www.mongodb.com/">MongoDB</a>是一个开源NoSQL文档数据库，它使用类似JSON的架构而不是传统的基于表的关系数据。Spring Boot为使用MongoDB提供了许多便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code> “首发”。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-mongodb"><a class="anchor" href="#boot-features-connecting-to-mongodb"></a> 11.2.1。连接到MongoDB数据库</h4>
<div class="paragraph">
<p>要访问Mongo数据库，您可以注入自动配置的数据库。 <code>org.springframework.data.mongodb.MongoDbFactory</code> 。默认情况下，该实例尝试连接到位于以下位置的MongoDB服务器： <code>mongodb://localhost/test</code> 。以下示例显示了如何连接到MongoDB数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.data.mongodb.MongoDbFactory;
import com.mongodb.DB;

@Component
public class MyBean {

    private final MongoDbFactory mongo;

    @Autowired
    public MyBean(MongoDbFactory mongo) {
        this.mongo = mongo;
    }

    // ...

    public void example() {
        DB db = mongo.getDb();
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以设置<code>spring.data.mongodb.uri</code>属性以更改URL并配置其他设置，例如<em>副本集</em> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，只要您使用Mongo 2.x，就可以指定一个<code>host</code> / <code>port</code> 。例如，您可以在自己的计算机中声明以下设置<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.mongodb.host=mongoserver
spring.data.mongodb.port=27017</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您定义了自己的<code>MongoClient</code> ，它将用于自动配置合适的<code>MongoDbFactory</code> 。都<code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code>支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用Mongo 3.0 Java驱动程序， <code>spring.data.mongodb.host</code>和<code>spring.data.mongodb.port</code>不支持。在这种情况下， <code>spring.data.mongodb.uri</code>应该用于提供所有配置。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果<code>spring.data.mongodb.port</code>未指定，默认为<code>27017</code>用来。您可以从前面显示的示例中删除此行。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您不使用Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code> bean 而不是使用<code>MongoDbFactory</code> 。如果您想完全控制建立MongoDB连接的方式，也可以声明自己的连接<code>MongoDbFactory</code>要么<code>MongoClient</code> bean 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用反应性驱动程序，则SSL需要Netty。如果Netty可用并且尚未自定义要使用的工厂，则自动配置将自动配置该工厂。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-mongo-template"><a class="anchor" href="#boot-features-mongo-template"></a> 11.2.2。MongoTemplate</h4>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-mongodb">Spring Data MongoDB</a>提供了一个<a href="https://docs.spring.io/spring-data/mongodb/docs/2.2.1.RELEASE/api/org/springframework/data/mongodb/core/MongoTemplate.html"><code>MongoTemplate</code></a>类在设计上与Spring的非常相似<code>JdbcTemplate</code> 。与<code>JdbcTemplate</code> ，Spring Boot为您自动配置一个Bean来注入模板，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final MongoTemplate mongoTemplate;

    @Autowired
    public MyBean(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>见<a href="https://docs.spring.io/spring-data/mongodb/docs/2.2.1.RELEASE/api/org/springframework/data/mongodb/core/MongoOperations.html"><code>MongoOperations</code> Javadoc</a>的完整细节。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-mongodb-repositories"><a class="anchor" href="#boot-features-spring-data-mongodb-repositories"></a> 11.2.3。Spring Data MongoDB存储库</h4>
<div class="paragraph">
<p>Spring Data包括对MongoDB的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动构造查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data MongoDB共享相同的通用基础结构。您可以以前面的JPA为例，并假设<code>City</code>现在是Mongo数据类，而不是JPA <code>@Entity</code> ，其工作方式相同，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以使用来自定义文档扫描位置<code>@EntityScan</code>注解。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关Spring Data MongoDB的完整详细信息，包括其丰富的对象映射技术，请参阅其<a href="https://spring.io/projects/spring-data-mongodb">参考文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-mongo-embedded"><a class="anchor" href="#boot-features-mongo-embedded"></a> 11.2.4。嵌入式Mongo</h4>
<div class="paragraph">
<p>Spring Boot为<a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo">Embedded Mongo</a>提供自动配置。要在您的Spring Boot应用程序中使用它，请添加对<code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code> 。</p>
</div>
<div class="paragraph">
<p>可以通过设置Mongo来配置监听Mongo的端口<code>spring.data.mongodb.port</code>属性。要使用随机分配的空闲端口，请使用值0。的<code>MongoClient</code>由...制作<code>MongoAutoConfiguration</code>自动配置为使用随机分配的端口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未配置自定义端口，则默认情况下，嵌入式支持会使用随机端口（而不是27017）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果类路径上有SLF4J，则Mongo产生的输出将自动路由到名为<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code> 。</p>
</div>
<div class="paragraph">
<p>您可以声明自己的<code>IMongodConfig</code>和<code>IRuntimeConfig</code> bean来控制Mongo实例的配置和日志记录路由。可以通过声明一个自定义下载配置<code>DownloadConfigBuilderCustomizer</code> bean 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-neo4j"><a class="anchor" href="#boot-features-neo4j"></a> 11.3。Neo4j</h3>
<div class="paragraph">
<p><a href="https://neo4j.com/">Neo4j</a>是一个开源NoSQL图形数据库，它使用通过一级关系连接的节点的丰富数据模型，与传统的RDBMS方法相比，它更适合于连接的大数据。Spring Boot为使用Neo4j提供了许多便利，包括<code>spring-boot-starter-data-neo4j</code> “起动机”。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-neo4j"><a class="anchor" href="#boot-features-connecting-to-neo4j"></a> 11.3.1。连接到Neo4j数据库</h4>
<div class="paragraph">
<p>要访问Neo4j服务器，您可以注入自动配置的<code>org.neo4j.ogm.session.Session</code> 。默认情况下，该实例尝试连接到以下位置的Neo4j服务器： <code>localhost:7687</code>使用Bolt协议。以下示例显示了如何注入Neo4j <code>Session</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private final Session session;

    @Autowired
    public MyBean(Session session) {
        this.session = session;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过设置<code>spring.data.neo4j.*</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.neo4j.uri=bolt://my-server:7687
spring.data.neo4j.username=neo4j
spring.data.neo4j.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过添加以下任意一项来完全控制会话的创建： <code>org.neo4j.ogm.config.Configuration</code> bean 还是<code>org.neo4j.ogm.session.SessionFactory</code> bean 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-neo4j-embedded"><a class="anchor" href="#boot-features-connecting-to-neo4j-embedded"></a> 11.3.2。使用嵌入式模式</h4>
<div class="paragraph">
<p>如果添加<code>org.neo4j:neo4j-ogm-embedded-driver</code>根据应用程序的依赖关系，Spring Boot自动配置Neo4j的进程内嵌入式实例，该实例在您的应用程序关闭时不会保留任何数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于嵌入式Neo4j OGM驱动程序本身不提供Neo4j内核，因此必须声明<code>org.neo4j:neo4j</code>作为自己的依赖。有关兼容版本的列表，请参阅<a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started">Neo4j OGM文档</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当类路径上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置来显式禁用嵌入式模式<code>spring.data.neo4j.embedded.enabled=false</code> 。</p>
</div>
<div class="paragraph">
<p>如果嵌入式驱动程序和Neo4j内核位于上述类路径上，则<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test">数据Neo4j测试会</a>自动使用嵌入式Neo4j实例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以通过在配置中提供数据库文件的路径来启用嵌入式模式的持久性，例如<code>spring.data.neo4j.uri=file://var/tmp/graph.db</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-neo4j-ogm-native-types"><a class="anchor" href="#boot-features-neo4j-ogm-native-types"></a> 11.3.3。使用本机类型</h4>
<div class="paragraph">
<p>Neo4j-OGM可以映射某些类型，例如<code>java.time.*</code> ， 至<code>String</code>基于属性或Neo4j提供的本机类型之一。出于向后兼容的原因，Neo4j-OGM的默认设置是使用<code>String</code>基于的表示形式。要使用本机类型，请添加对任何一个的依赖<code>org.neo4j:neo4j-ogm-bolt-native-types</code>要么<code>org.neo4j:neo4j-ogm-embedded-native-types</code> ，并配置<code>spring.data.neo4j.use-native-types</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.neo4j.use-native-types=true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-neo4j-ogm-session"><a class="anchor" href="#boot-features-neo4j-ogm-session"></a> 11.3.4。Neo4jSession</h4>
<div class="paragraph">
<p>默认情况下，如果您正在运行Web应用程序，则该会话将绑定到线程以进行请求的整个处理（即，它使用“在视图中打开会话”模式）。如果您不希望出现这种情况，请将以下行添加到您的<code>application.properties</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.neo4j.open-in-view=false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-neo4j-repositories"><a class="anchor" href="#boot-features-spring-data-neo4j-repositories"></a> 11.3.5。Spring Data Neo4j存储库</h4>
<div class="paragraph">
<p>Spring Data包括对Neo4j的存储库支持。</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j与许多其他Spring Data模块一样，与Spring Data JPA共享公共基础结构。您可以从前面的JPA示例中进行定义<code>City</code>作为Neo4j OGM <code>@NodeEntity</code>而不是JPA <code>@Entity</code>并且存储库抽象以相同的方式工作，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.myapp.domain;

import java.util.Optional;

import org.springframework.data.neo4j.repository.*;

public interface CityRepository extends Neo4jRepository&lt;City, Long&gt; {

    Optional&lt;City&gt; findOneByNameAndState(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>spring-boot-starter-data-neo4j</code> “启动器”启用存储库支持以及事务管理。您可以使用以下方法自定义位置以查找存储库和实体<code>@EnableNeo4jRepositories</code>和<code>@EntityScan</code>分别在<code>@Configuration</code> - bean 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关Spring Data Neo4j的完整详细信息，包括其对象映射技术，请参阅<a href="https://docs.spring.io/spring-data/neo4j/docs/5.2.1.RELEASE/reference/html/">参考文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-solr"><a class="anchor" href="#boot-features-solr"></a> 11.4。索尔</h3>
<div class="paragraph">
<p><a href="https://lucene.apache.org/solr/">Apache Solr</a>是一个搜索引擎。Spring Boot为Solr 5客户端库提供了基本的自动配置，并由<a href="https://github.com/spring-projects/spring-data-solr">Spring Data Solr</a>在其之上提供了抽象。有一个<code>spring-boot-starter-data-solr</code> “启动器”，用于以方便的方式收集依赖项。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-solr"><a class="anchor" href="#boot-features-connecting-to-solr"></a> 11.4.1。连接到Solr</h4>
<div class="paragraph">
<p>您可以注入自动配置的<code>SolrClient</code>实例，就像其他任何Spring Bean一样。默认情况下，该实例尝试连接到以下服务器： <code><a href="http://localhost:8983/solr" class="bare">localhost:8983/solr</a></code> 。以下示例显示如何注入Solr bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private SolrClient solr;

    @Autowired
    public MyBean(SolrClient solr) {
        this.solr = solr;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您添加自己的<code>@Bean</code>类型的<code>SolrClient</code> ，它将替换默认值。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-solr-repositories"><a class="anchor" href="#boot-features-spring-data-solr-repositories"></a> 11.4.2。Spring Data Solr存储库</h4>
<div class="paragraph">
<p>Spring Data包括对Apache Solr的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动为您构建查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data Solr共享相同的通用基础结构。您可以以前面的JPA为例，并假设<code>City</code>现在是<code>@SolrDocument</code>类而不是JPA <code>@Entity</code> ，其工作方式相同。</p>
</div>
<div class="paragraph">
<p>IP：有关Spring Data Solr的完整详细信息，请参阅<a href="https://docs.spring.io/spring-data/solr/docs/4.1.1.RELEASE/reference/html/">参考文档</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-elasticsearch"><a class="anchor" href="#boot-features-elasticsearch"></a> 11.5。弹性搜索</h3>
<div class="paragraph">
<p><a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>是一个开源，分布式，RESTful搜索和分析引擎。Spring Boot为Elasticsearch提供了基本的自动配置。</p>
</div>
<div class="paragraph">
<p>Spring Boot支持多个客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>官方Java“低级”和“高级” REST客户端</p>
</li>
<li>
<p>的<code>ReactiveElasticsearchClient</code>由Spring Data Elasticsearch提供</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>传输客户端仍然可用，但<a href="https://github.com/spring-projects/spring-data-elasticsearch">Spring Data Elasticsearch</a>和Elasticsearch本身已弃用其支持。它将在将来的版本中删除。Spring Boot提供了专用的“入门”， <code>spring-boot-starter-data-elasticsearch</code> 。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/searchbox-io/Jest">Jest</a>客户端也已被弃用，因为Elasticsearch和Spring Data Elasticsearch都为REST客户端提供了官方支持。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-rest"><a class="anchor" href="#boot-features-connecting-to-elasticsearch-rest"></a> 11.5.1。使用REST客户端连接到Elasticsearch</h4>
<div class="paragraph">
<p>Elasticsearch附带了<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">两个</a>可用于查询集群的<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">REST客户端</a> ：“低级”客户端和“高级”客户端。</p>
</div>
<div class="paragraph">
<p>如果你有<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖于类路径，Spring Boot将自动配置并注册一个<code>RestClient</code>默认情况下定位的bean <code><a href="http://localhost:9200" class="bare">localhost:9200</a></code> 。您可以进一步调整<code>RestClient</code>已配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.elasticsearch.rest.uris=https://search.example.com:9200
spring.elasticsearch.rest.read-timeout=10s
spring.elasticsearch.rest.username=user
spring.elasticsearch.rest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以注册任意数量的实现<code>RestClientBuilderCustomizer</code>进行更高级的自定义。要完全控制注册，请定义一个<code>RestClient</code> bean 。</p>
</div>
<div class="paragraph">
<p>如果你有<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>依赖于类路径，Spring Boot将自动配置一个<code>RestHighLevelClient</code> ，它包装了所有现有的<code>RestClient</code> bean，重用其HTTP配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-reactive-rest"><a class="anchor" href="#boot-features-connecting-to-elasticsearch-reactive-rest"></a> 11.5.2。使用反应式REST客户端连接到Elasticsearch</h4>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-elasticsearch">Spring Data Elasticsearch</a>发布<code>ReactiveElasticsearchClient</code>用于以反应方式查询Elasticsearch实例。它基于WebFlux的<code>WebClient</code> ，所以两者<code>spring-boot-starter-elasticsearch</code>和<code>spring-boot-starter-webflux</code>依赖项对于启用此支持很有用。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Boot将自动配置并注册一个<code>ReactiveElasticsearchClient</code>瞄准的 bean <code><a href="http://localhost:9200" class="bare">localhost:9200</a></code> 。您可以进一步调整其配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
spring.data.elasticsearch.client.reactive.use-ssl=true
spring.data.elasticsearch.client.reactive.socket-timeout=10s
spring.data.elasticsearch.client.reactive.username=user
spring.data.elasticsearch.client.reactive.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果配置属性不够，并且您想完全控制客户端配置，则可以注册自定义<code>ClientConfiguration</code> bean 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-jest"><a class="anchor" href="#boot-features-connecting-to-elasticsearch-jest"></a> 11.5.3。使用Jest连接到Elasticsearch</h4>
<div class="paragraph">
<p>现在Spring Boot支持官方<code>RestHighLevelClient</code> ，不支持Jest支持。</p>
</div>
<div class="paragraph">
<p>如果你有<code>Jest</code>在类路径上，您可以注入自动配置的<code>JestClient</code>默认情况下定位<code><a href="http://localhost:9200" class="bare">localhost:9200</a></code> 。您可以进一步调整客户端的配置方式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.elasticsearch.jest.uris=https://search.example.com:9200
spring.elasticsearch.jest.read-timeout=10000
spring.elasticsearch.jest.username=user
spring.elasticsearch.jest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以注册任意数量的实现<code>HttpClientConfigBuilderCustomizer</code>进行更高级的自定义。以下示例调整其他HTTP设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {

    @Override
    public void customize(HttpClientConfig.Builder builder) {
        builder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要完全控制注册，请定义一个<code>JestClient</code> bean 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-spring-data"><a class="anchor" href="#boot-features-connecting-to-elasticsearch-spring-data"></a> 11.5.4。使用Spring数据连接到Elasticsearch</h4>
<div class="paragraph">
<p>要连接到Elasticsearch， <code>RestHighLevelClient</code> bean必须定义，由Spring Boot自动配置或由应用程序手动提供（请参见前面的部分）。有了此配置后， <code>ElasticsearchRestTemplate</code>可以像其他任何Spring bean一样注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private final ElasticsearchRestTemplate template;

    public MyBean(ElasticsearchRestTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在......的存在下<code>spring-data-elasticsearch</code>以及使用<code>WebClient</code> （通常<code>spring-boot-starter-webflux</code> ），Spring Boot还可以自动配置<a href="#boot-features-connecting-to-elasticsearch-reactive-rest">ReactiveElasticsearchClient</a>和<code>ReactiveElasticsearchTemplate</code>作为 bean 。它们与其他REST客户端是等效的。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-elasticsearch-repositories"><a class="anchor" href="#boot-features-spring-data-elasticsearch-repositories"></a> 11.5.5。Spring Data Elasticsearch存储库</h4>
<div class="paragraph">
<p>Spring Data包括对Elasticsearch的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动为您构造查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data Elasticsearch共享相同的通用基础架构。您可以以前面的JPA为例，并假设<code>City</code>现在是一个Elasticsearch <code>@Document</code>类而不是JPA <code>@Entity</code> ，其工作方式相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关Spring Data Elasticsearch的完整详细信息，请<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">参考参考文档</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Boot使用以下命令支持经典和反应式Elasticsearch存储库<code>ElasticsearchRestTemplate</code>要么<code>ReactiveElasticsearchTemplate</code>beans。给定所需的依赖项，最有可能由Spring Boot自动配置这些bean。</p>
</div>
<div class="paragraph">
<p>如果您希望使用自己的模板来支持Elasticsearch存储库，则可以添加自己的模板<code>ElasticsearchRestTemplate</code>要么<code>ElasticsearchOperations</code><code>@Bean</code> ，只要它被命名<code>"elasticsearchTemplate"</code> 。同样适用于<code>ReactiveElasticsearchTemplate</code>和<code>ReactiveElasticsearchOperations</code> ，具有Bean名称<code>"reactiveElasticsearchTemplate"</code> 。</p>
</div>
<div class="paragraph">
<p>您可以选择使用以下属性禁用存储库支持：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.elasticsearch.repositories.enabled=false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-cassandra"><a class="anchor" href="#boot-features-cassandra"></a> 11.6。卡桑德拉</h3>
<div class="paragraph">
<p><a href="https://cassandra.apache.org/">Cassandra</a>是一个开放源代码的分布式数据库管理系统，旨在处理许多商用服务器上的大量数据。Spring Boot为Cassandra提供自动配置，并由<a href="https://github.com/spring-projects/spring-data-cassandra">Spring Data Cassandra</a>在其之上提供抽象。有一个<code>spring-boot-starter-data-cassandra</code> “启动器”，用于以方便的方式收集依赖项。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-cassandra"><a class="anchor" href="#boot-features-connecting-to-cassandra"></a> 11.6.1。连接到Cassandra</h4>
<div class="paragraph">
<p>您可以注入自动配置的<code>CassandraTemplate</code>或卡桑德拉<code>Session</code>实例，就像使用其他任何Spring Bean一样。的<code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和<code>contact-points</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.data.cassandra.keyspace-name=mykeyspace
spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以注册任意数量的实现<code>ClusterBuilderCustomizer</code>进行更高级的自定义。</p>
</div>
<div class="paragraph">
<p>以下代码清单显示了如何注入Cassandra bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private CassandraTemplate template;

    @Autowired
    public MyBean(CassandraTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您添加自己的<code>@Bean</code>类型的<code>CassandraTemplate</code> ，它将替换默认值。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-cassandra-repositories"><a class="anchor" href="#boot-features-spring-data-cassandra-repositories"></a> 11.6.2。Spring Data Cassandra存储库</h4>
<div class="paragraph">
<p>Spring Data包括对Cassandra的基本存储库支持。当前，这比前面讨论的JPA存储库受到更多限制，并且需要使用以下方法注释finder方法<code>@Query</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关Spring Data Cassandra的完整详细信息，请<a href="https://docs.spring.io/spring-data/cassandra/docs/">参考参考文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-couchbase"><a class="anchor" href="#boot-features-couchbase"></a> 11.7。Couchbase</h3>
<div class="paragraph">
<p><a href="https://www.couchbase.com/">Couchbase</a>是一个开放源代码，分布式，多模型的NoSQL面向文档的数据库，已针对交互式应用程序进行了优化。Spring Boot为Couchbase提供自动配置，并由<a href="https://github.com/spring-projects/spring-data-couchbase">Spring Data Couchbase</a>在其之上提供抽象。有<code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code> “启动器”，用于以方便的方式收集依赖项。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-couchbase"><a class="anchor" href="#boot-features-connecting-to-couchbase"></a> 11.7.1。连接到Couchbase</h4>
<div class="paragraph">
<p>你可以得到一个<code>Bucket</code>和<code>Cluster</code>通过添加Couchbase SDK和一些配置。的<code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
spring.couchbase.bucket.name=my-bucket
spring.couchbase.bucket.password=secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您<em>至少</em>需要提供引导主机，在这种情况下，存储区名称为<code>default</code>密码是一个空字符串。或者，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code><code>@Bean</code>来控制整个配置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>还可以自定义一些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改了用于打开新的超时<code>Bucket</code>并启用SSL支持：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.couchbase.env.timeouts.connect=3000
spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
spring.couchbase.env.ssl.key-store-password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查<code>spring.couchbase.env.*</code>属性以获取更多详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-couchbase-repositories"><a class="anchor" href="#boot-features-spring-data-couchbase-repositories"></a> 11.7.2。Spring Data Couchbase存储库</h4>
<div class="paragraph">
<p>Spring Data包括对Couchbase的存储库支持。有关Spring Data Couchbase的完整详细信息，请<a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/">参考参考文档</a> 。</p>
</div>
<div class="paragraph">
<p>您可以注入自动配置的<code>CouchbaseTemplate</code>与其他任何Spring Bean一样，提供了<em>默认</em>实例<code>CouchbaseConfigurer</code>可用（如前所述，启用Couchbase支持时会发生这种情况）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何注入Couchbase bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private final CouchbaseTemplate template;

    @Autowired
    public MyBean(CouchbaseTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在自己的配置中定义一些Bean，以覆盖自动配置提供的那些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>CouchbaseTemplate</code><code>@Bean</code>名称为<code>couchbaseTemplate</code> 。</p>
</li>
<li>
<p>一个<code>IndexManager</code><code>@Bean</code>名称为<code>couchbaseIndexManager</code> 。</p>
</li>
<li>
<p>一种<code>CustomConversions</code><code>@Bean</code>名称为<code>couchbaseCustomConversions</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了避免在您自己的配置中对这些名称进行硬编码，您可以重复使用<code>BeanNames</code>由Spring Data Couchbase提供。例如，您可以自定义要使用的转换器，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class SomeConfiguration {

    @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
    public CustomConversions myCustomConversions() {
        return new CustomConversions(...);
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您想完全绕过Spring Data Couchbase的自动配置，请提供您自己的<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-ldap"><a class="anchor" href="#boot-features-ldap"></a> 11.8。LDAP</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> （轻型目录访问协议）是一种开放的，与供应商无关的行业标准应用程序协议，用于通过IP网络访问和维护分布式目录信息服务。Spring Boot为任何兼容的LDAP服务器提供自动配置，并从<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>支持嵌入式内存LDAP服务器。</p>
</div>
<div class="paragraph">
<p>LDAP抽象由<a href="https://github.com/spring-projects/spring-data-ldap">Spring Data LDAP提供</a> 。有一个<code>spring-boot-starter-data-ldap</code> “启动器”，用于以方便的方式收集依赖项。</p>
</div>
<div class="sect3">
<h4 id="boot-features-ldap-connecting"><a class="anchor" href="#boot-features-ldap-connecting"></a> 11.8.1。连接到LDAP服务器</h4>
<div class="paragraph">
<p>要连接到LDAP服务器，请确保您声明了对<code>spring-boot-starter-data-ldap</code> “入门”或<code>spring-ldap-core</code>然后在application.properties中声明服务器的URL，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.ldap.urls=ldap://myserver:1235
spring.ldap.username=admin
spring.ldap.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要自定义连接设置，则可以使用<code>spring.ldap.base</code>和<code>spring.ldap.base-environment</code>属性。</p>
</div>
<div class="paragraph">
<p>一个<code>LdapContextSource</code>根据这些设置自动配置。如果您需要对其进行自定义，例如使用<code>PooledContextSource</code> ，您仍然可以注入自动配置的<code>LdapContextSource</code> 。确保标记您的自定义<code>ContextSource</code>如<code>@Primary</code>这样就可以自动配置<code>LdapTemplate</code>使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-ldap-spring-data-repositories"><a class="anchor" href="#boot-features-ldap-spring-data-repositories"></a> 11.8.2。Spring Data LDAP存储库</h4>
<div class="paragraph">
<p>Spring Data包括对LDAP的存储库支持。有关Spring Data LDAP的完整详细信息，请<a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">参考参考文档</a> 。</p>
</div>
<div class="paragraph">
<p>您还可以注入自动配置的<code>LdapTemplate</code>实例，就像使用其他任何Spring Bean一样，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private final LdapTemplate template;

    @Autowired
    public MyBean(LdapTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-ldap-embedded"><a class="anchor" href="#boot-features-ldap-embedded"></a> 11.8.3。嵌入式内存LDAP服务器</h4>
<div class="paragraph">
<p>出于测试目的，Spring Boot支持从<a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>自动配置内存中的LDAP服务器。要配置服务器，请向<code>com.unboundid:unboundid-ldapsdk</code>并声明一个<code>spring.ldap.embedded.base-dn</code>属性，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.ldap.embedded.base-dn=dc=spring,dc=io</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以定义多个base-dn值，但是，由于专有名称通常包含逗号，因此必须使用正确的符号进行定义。</p>
</div>
<div class="paragraph">
<p>在yaml文件中，您可以使用yaml列表符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.ldap.embedded.base-dn:
  - dc=spring,dc=io
  - dc=pivotal,dc=io</code></pre>
</div>
</div>
<div class="paragraph">
<p>在属性文件中，必须将索引包括在属性名称中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，服务器在随机端口上启动并触发常规LDAP支持。无需指定<code>spring.ldap.urls</code>属性。</p>
</div>
<div class="paragraph">
<p>如果有<code>schema.ldif</code>文件放在类路径上，用于初始化服务器。如果您要从其他资源加载初始化脚本，也可以使用<code>spring.ldap.embedded.ldif</code>属性。</p>
</div>
<div class="paragraph">
<p>默认情况下，使用标准架构进行验证<code>LDIF</code>文件。您可以通过设置以下选项完全关闭验证<code>spring.ldap.embedded.validation.enabled</code>属性。如果您具有自定义属性，则可以使用<code>spring.ldap.embedded.validation.schema</code>定义自定义属性类型或对象类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-influxdb"><a class="anchor" href="#boot-features-influxdb"></a> 11.9。InfluxDB</h3>
<div class="paragraph">
<p><a href="https://www.influxdata.com/">InfluxDB</a>是一个开放源代码的时间序列数据库，已优化用于在操作监视，应用程序度量，物联网传感器数据和实时分析等领域中快速，高可用性地存储和检索时间序列数据。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-influxdb"><a class="anchor" href="#boot-features-connecting-to-influxdb"></a> 11.9.1。连接到InfluxDB</h4>
<div class="paragraph">
<p>Spring Boot自动配置<code>InfluxDB</code>例如， <code>influxdb-java</code>客户端位于类路径上，并且已设置数据库的URL，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.influx.url=https://172.0.0.1:8086</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与InfluxDB的连接需要用户名和密码，则可以设置<code>spring.influx.user</code>和<code>spring.influx.password</code>属性。</p>
</div>
<div class="paragraph">
<p>InfluxDB依赖OkHttp。如果您需要调整http客户端<code>InfluxDB</code>在幕后使用，您可以注册一个<code>InfluxDbOkHttpClientBuilderProvider</code> bean 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-caching"><a class="anchor" href="#boot-features-caching"></a> 12快取</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework 提供了对向应用程序透明添加缓存的支持。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过启用了缓存支持，Spring Boot就会自动配置缓存基础架构。 <code>@EnableCaching</code>注解。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">检查Spring Framework参考的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/integration.html#cache">相关部分</a>以获取更多详细信息。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>简而言之，将缓存添加到服务的操作就像将相关注释添加到其方法一样容易，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MathService {

    @Cacheable("piDecimals")
    public int computePiDecimal(int i) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>本示例说明了在潜在的昂贵操作上使用缓存的方法。调用之前<code>computePiDecimal</code> ，则抽象会在<code>piDecimals</code>符合以下条件的缓存<code>i</code>论点。如果找到条目，则高速缓存中的内容会立即返回给调用方，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">您还可以使用标准的JSR-107（JCache）注释（例如<code>@CacheResult</code> ）。但是，我们强烈建议您不要混合使用Spring Cache和JCache批注。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您不添加任何特定的缓存库，Spring Boot会自动配置一个使用内存中并发映射的<a href="#boot-features-caching-provider-simple">简单提供程序</a> 。需要缓存时（例如<code>piDecimals</code>在前面的示例中），此提供程序将为您创建它。实际上，不建议将简单的提供程序用于生产用途，但它对于入门并确保您了解功能非常有用。确定要使用的缓存提供程序后，请确保阅读其文档，以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供自定义默认缓存的方法。 <code>spring.cache.cache-names</code>属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">还可以透明地<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/integration.html#cache-annotations-put">更新</a>或从缓存中<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/integration.html#cache-annotations-evict">逐出</a>数据。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="boot-features-caching-provider"><a class="anchor" href="#boot-features-caching-provider"></a> 12.1。支持的缓存提供程序</h3>
<div class="paragraph">
<p>缓存抽象不提供实际的存储，而是依赖于由缓存实现的抽象。 <code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口。</p>
</div>
<div class="paragraph">
<p>如果尚未定义类型的Bean <code>CacheManager</code>或一个<code>CacheResolver</code>命名<code>cacheResolver</code> （看到<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a> ），Spring Boot尝试检测以下提供程序（按指示的顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#boot-features-caching-provider-generic">泛型</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-jcache">JCache（JSR-107）</a> （EhCache 3，Hazelcast，Infinispan等）</p>
</li>
<li>
<p><a href="#boot-features-caching-provider-ehcache2">EhCache 2.x</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-hazelcast">淡褐色</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-infinispan">Infinispan</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-redis">雷迪斯</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-caffeine">咖啡因</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-simple">简单</a></p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">也可以通过设置来<em>强制</em>一个特定的缓存提供<code>spring.cache.type</code>属性。如果您需要在某些环境（例如测试）中<a href="#boot-features-caching-provider-none">完全禁用缓存，</a>请使用此属性。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>spring-boot-starter-cache</code> “入门”可快速添加基本缓存依赖项。入门者带来<code>spring-context-support</code> 。如果手动添加依赖项，则必须包括<code>spring-context-support</code>为了使用JCache，EhCache 2.x或Caffeine支持。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果<code>CacheManager</code>是由Spring Boot自动配置的，您可以通过暴露一个实现了<code>CacheManagerCustomizer</code>接口。下面的示例设置一个标志来表示<code>null</code>值应向下传递到基础地图：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; cacheManagerCustomizer() {
    return new CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() {
        @Override
        public void customize(ConcurrentMapCacheManager cacheManager) {
            cacheManager.setAllowNullValues(false);
        }
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在前面的示例中， <code>ConcurrentMapCacheManager</code>是期待。如果不是这种情况（您提供了自己的配置，或者自动配置了其他缓存提供程序），则根本不会调用定制程序。您可以根据需要拥有任意数量的定制程序，也可以使用以下命令订购它们<code>@Order</code>要么<code>Ordered</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-generic"><a class="anchor" href="#boot-features-caching-provider-generic"></a> 12.1.1。泛型</h4>
<div class="paragraph">
<p>如果上下文定义<em>了至少</em>一个，则使用通用缓存<code>org.springframework.cache.Cache</code> bean 。一种<code>CacheManager</code>包装所有该类型的bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-jcache"><a class="anchor" href="#boot-features-caching-provider-jcache"></a> 12.1.2。JCache（JSR-107）</h4>
<div class="paragraph">
<p><a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>通过以下方式启动： <code>javax.cache.spi.CachingProvider</code>在类路径上（即，在类路径上存在符合JSR-107的缓存库），并且<code>JCacheCacheManager</code>由<code>spring-boot-starter-cache</code> “起动机”。提供了各种兼容的库，Spring Boot为Ehcache 3，Hazelcast和Infinispan提供了依赖管理。也可以添加任何其他兼容的库。</p>
</div>
<div class="paragraph">
<p>可能会存在多个提供者，在这种情况下，必须明确指定提供者。即使JSR-107标准没有强制采用标准化的方式来定义配置文件的位置，Spring Boot也会尽其所能以设置带有实现细节的缓存，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Only necessary if more than one provider is present
spring.cache.jcache.provider=com.acme.MyCachingProvider
spring.cache.jcache.config=classpath:acme.xml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当缓存库同时提供本机实现和JSR-107支持时，Spring Boot会首选JSR-107支持，因此，如果您切换到其他JSR-107实现，则可以使用相同的功能。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Boot <a href="#boot-features-hazelcast">对Hazelcast</a>具有<a href="#boot-features-hazelcast">常规支持</a> 。如果单<code>HazelcastInstance</code>可用，它会自动重新用于<code>CacheManager</code>同样，除非<code>spring.cache.jcache.config</code>指定了属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有两种方法可以自定义基础<code>javax.cache.cacheManager</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以在启动时通过设置<code>spring.cache.cache-names</code>属性。如果是风俗<code>javax.cache.configuration.Configuration</code> bean已定义，用于自定义它们。</p>
</li>
<li>
<p><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean的引用是通过<code>CacheManager</code>进行完全定制。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果一个标准<code>javax.cache.CacheManager</code>定义了bean，它会自动包装在<code>org.springframework.cache.CacheManager</code>抽象期望的实现。不再对其应用定制。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-ehcache2"><a class="anchor" href="#boot-features-caching-provider-ehcache2"></a> 12.1.3。EhCache 2.x</h4>
<div class="paragraph">
<p>如果文件名为<a href="https://www.ehcache.org/">EhCache</a> 2.x <code>ehcache.xml</code>可以在类路径的根目录下找到。如果找到EhCache 2.x，则<code>EhCacheCacheManager</code>由...提供<code>spring-boot-starter-cache</code> “启动器”用于引导缓存管理器。也可以提供备用配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.ehcache.config=classpath:config/another-config.xml</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-hazelcast"><a class="anchor" href="#boot-features-caching-provider-hazelcast"></a> 12.1.4。淡褐色</h4>
<div class="paragraph">
<p>Spring Boot <a href="#boot-features-hazelcast">对Hazelcast</a>具有<a href="#boot-features-hazelcast">常规支持</a> 。如果一个<code>HazelcastInstance</code>已自动配置，并自动包装在<code>CacheManager</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-infinispan"><a class="anchor" href="#boot-features-caching-provider-infinispan"></a> 12.1.5。Infinispan</h4>
<div class="paragraph">
<p><a href="https://infinispan.org/">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，将使用默认的引导程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.infinispan.config=infinispan.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在启动时通过设置<code>spring.cache.cache-names</code>属性。如果是风俗<code>ConfigurationBuilder</code>定义了bean，它用于自定义缓存。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot对Infinispan的支持仅限于嵌入式模式，并且非常基础。如果您需要更多选择，则应该使用官方的Infinispan Spring Boot启动程序。有关更多详细信息，请参见<a href="https://github.com/infinispan/infinispan-spring-boot">Infinispan的文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-couchbase"><a class="anchor" href="#boot-features-caching-provider-couchbase"></a> 12.1.6。Couchbase</h4>
<div class="paragraph">
<p>如果<a href="https://www.couchbase.com/">Couchbase</a> Java客户端和<code>couchbase-spring-cache</code>可用的实现和<a href="#boot-features-couchbase">配置的</a> Couchbase， <code>CouchbaseCacheManager</code>已自动配置。也可以在启动时通过设置<code>spring.cache.cache-names</code>属性。这些缓存在<code>Bucket</code>已自动配置。您<em>还</em>可以创建另一个附加的高速缓存<code>Bucket</code>通过使用定制程序。假设您需要两个缓存（ <code>cache1</code>和<code>cache2</code> ）上的“主要” <code>Bucket</code>还有一个（ <code>cache3</code> ）在“另一个”上的自定义生存时间为2秒<code>Bucket</code> 。您可以通过配置创建前两个缓存，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以定义一个<code>@Configuration</code>类来配置额外的<code>Bucket</code>和<code>cache3</code>缓存，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class CouchbaseCacheConfiguration {

    private final Cluster cluster;

    public CouchbaseCacheConfiguration(Cluster cluster) {
        this.cluster = cluster;
    }

    @Bean
    public Bucket anotherBucket() {
        return this.cluster.openBucket("another", "secret");
    }

    @Bean
    public CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; cacheManagerCustomizer() {
        return c -&gt; {
            c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
                    .withExpiration(2));
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例配置重用了<code>Cluster</code>通过自动配置创建的。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-redis"><a class="anchor" href="#boot-features-caching-provider-redis"></a> 12.1.7。雷迪斯</h4>
<div class="paragraph">
<p>如果<a href="https://redis.io/">Redis</a>可用并已配置，则<code>RedisCacheManager</code>已自动配置。可以在启动时通过设置<code>spring.cache.cache-names</code>属性和缓存默认值可以通过使用<code>spring.cache.redis.*</code>属性。例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存的<em>生存时间为</em> 10分钟：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.redis.time-to-live=600000</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，会添加密钥前缀，这样，如果两个单独的缓存使用相同的密钥，则Redis不会有重叠的密钥，也不会返回无效值。如果您创建自己的设置，我们强烈建议将此设置保持启用状态<code>RedisCacheManager</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以通过添加以下命令来完全控制配置<code>RedisCacheConfiguration</code><code>@Bean</code>你自己。如果您要自定义序列化策略，这将很有用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-caffeine"><a class="anchor" href="#boot-features-caching-provider-caffeine"></a> 12.1.8。咖啡因</h4>
<div class="paragraph">
<p><a href="https://github.com/ben-manes/caffeine">Caffeine</a>是对Guava缓存的Java 8重写，取代了对Guava的支持。如果存在咖啡因， <code>CaffeineCacheManager</code> （由<code>spring-boot-starter-cache</code> “ Starter”）已自动配置。可以在启动时通过设置<code>spring.cache.cache-names</code>属性，并可以按以下顺序之一自定义（按指示的顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>缓存规范由<code>spring.cache.caffeine.spec</code></p>
</li>
<li>
<p>一种<code>com.github.benmanes.caffeine.cache.CaffeineSpec</code>定义了bean</p>
</li>
<li>
<p>一种<code>com.github.benmanes.caffeine.cache.Caffeine</code>定义了bean</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存最大大小为500， <em>生存时间为</em> 10分钟</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个<code>com.github.benmanes.caffeine.cache.CacheLoader</code>定义了bean，它会自动关联到<code>CaffeineCacheManager</code> 。自从<code>CacheLoader</code>要与缓存管理器管理的<em>所有</em>缓存相关联，必须将其定义为<code>CacheLoader<Object, Object></code> 。自动配置将忽略任何其他通用类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-simple"><a class="anchor" href="#boot-features-caching-provider-simple"></a> 12.1.9。简单</h4>
<div class="paragraph">
<p>如果找不到其他提供者，则使用<code>ConcurrentHashMap</code>因为已配置了缓存存储。如果您的应用程序中不存在任何缓存库，则这是默认设置。默认情况下，会根据需要创建缓存，但是您可以通过设置<code>cache-names</code>属性。例如，如果您只想<code>cache1</code>和<code>cache2</code>缓存，设置<code>cache-names</code>属性如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这样做，并且您的应用程序使用了未列出的缓存，那么当需要该缓存时，它将在运行时失败，但不会在启动时失败。这类似于使用未声明的缓存时“实际”缓存提供程序的行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-none"><a class="anchor" href="#boot-features-caching-provider-none"></a> 12.1.10。没有</h4>
<div class="paragraph">
<p>什么时候<code>@EnableCaching</code>在您的配置中存在时，也需要合适的缓存配置。如果您需要在某些环境中完全禁用缓存，请强制将缓存类型设置为<code>none</code>使用无操作实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cache.type=none</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-messaging"><a class="anchor" href="#boot-features-messaging"></a> 13讯息传递</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework 通过使用JMS API的简化使用，提供了与消息传递系统集成的广泛支持。 <code>JmsTemplate</code>完整的基础架构以异步接收消息。Spring AMQP为高级消息队列协议提供了类似的功能集。Spring Boot还提供了自动配置选项<code>RabbitTemplate</code>和RabbitMQ。 Spring WebSocket本身包括对STOMP消息的支持，而Spring Boot通过启动器和少量的自动配置对此提供了支持。Spring Boot还支持Apache Kafka。</p>
</div>
<div class="sect2">
<h3 id="boot-features-jms"><a class="anchor" href="#boot-features-jms"></a> 13.1。JMS</h3>
<div class="paragraph">
<p>的<code>javax.jms.ConnectionFactory</code>介面提供建立广告活动的标准方法<code>javax.jms.Connection</code>与JMS代理进行交互。虽然 Spring 需要<code>ConnectionFactory</code>要使用JMS，通常不需要自己直接使用它，而可以依靠更高级别的消息抽象。（有关详细信息，请参见Spring Framework参考文档的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/integration.html#jms">相关部分</a> 。）Spring Boot还自动配置了必要的基础结构，以发送和接收消息。</p>
</div>
<div class="sect3">
<h4 id="boot-features-activemq"><a class="anchor" href="#boot-features-activemq"></a> 13.1.1。ActiveMQ支持</h4>
<div class="paragraph">
<p>当<a href="https://activemq.apache.org/">ActiveMQ</a>在类路径中可用时，Spring Boot也可以配置一个<code>ConnectionFactory</code> 。如果存在代理，则将自动启动和配置嵌入式代理（前提是未通过配置指定代理URL）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用<code>spring-boot-starter-activemq</code> ，提供了连接或嵌入ActiveMQ实例所需的依赖关系，以及与JMS集成的Spring基础结构。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>ActiveMQ配置由以下项中的外部配置属性控制： <code>spring.activemq.*</code> 。例如，您可以在<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>CachingConnectionFactory</code>包装本地人<code>ConnectionFactory</code>可以通过外部配置属性控制的合理设置<code>spring.jms.*</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想使用本机池，可以通过向<code>org.messaginghub:pooled-jms</code>并配置<code>JmsPoolConnectionFactory</code>因此，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.activemq.pool.enabled=true
spring.activemq.pool.max-connections=50</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>以获得更多受支持的选项。您还可以注册任意数量的实现<code>ActiveMQConnectionFactoryCustomizer</code>进行更高级的自定义。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，ActiveMQ会创建目的地（如果尚不存在），以便根据其提供的名称来解析目的地。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-artemis"><a class="anchor" href="#boot-features-artemis"></a> 13.1.2。Artemis支持</h4>
<div class="paragraph">
<p>Spring Boot可以自动配置<code>ConnectionFactory</code>当它检测到<a href="https://activemq.apache.org/artemis/">Artemis</a>在类路径上可用时。如果存在代理，则将自动启动和配置嵌入式代理（除非已明确设置mode属性）。支持的模式是<code>embedded</code> （以明确要求使用嵌入式代理，并且如果代理在类路径上不可用，则会发生错误） <code>native</code> （以使用<code>netty</code>传输协议）。配置后者后，Spring Boot会配置一个<code>ConnectionFactory</code>使用默认设置连接到在本地计算机上运行的代理。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用<code>spring-boot-starter-artemis</code> ，提供了连接到现有Artemis实例所需的依赖关系，以及与JMS集成的Spring基础结构。新增中<code>org.apache.activemq:artemis-jms-server</code>应用程序允许您使用嵌入式模式。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Artemis配置由以下位置的外部配置属性控制<code>spring.artemis.*</code> 。例如，您可以在<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.artemis.mode=native
spring.artemis.host=192.168.1.210
spring.artemis.port=9876
spring.artemis.user=admin
spring.artemis.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>嵌入代理时，可以选择是否要启用持久性并列出应使其可用的目的地。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们，也可以定义类型的Bean。 <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>要么<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code> ，分别用于高级队列和主题配置。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>CachingConnectionFactory</code>包装本地人<code>ConnectionFactory</code>可以通过外部配置属性控制的合理设置<code>spring.jms.*</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想使用本机池，可以通过向<code>org.messaginghub:pooled-jms</code>并配置<code>JmsPoolConnectionFactory</code>因此，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.artemis.pool.enabled=true
spring.artemis.pool.max-connections=50</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a>了解更多受支持的选项。</p>
</div>
<div class="paragraph">
<p>不涉及JNDI查找，并且使用两个<code>name</code> Artemis配置中的属性或通过配置提供的名称。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jms-jndi"><a class="anchor" href="#boot-features-jms-jndi"></a> 13.1.3。使用JNDI ConnectionFactory</h4>
<div class="paragraph">
<p>如果您正在应用程序服务器中运行应用程序，则Spring Boot会尝试查找JMS <code>ConnectionFactory</code>通过使用JNDI。默认情况下， <code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置被检查。您可以使用<code>spring.jms.jndi-name</code>属性，如果您需要指定替代位置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.jms.jndi-name=java:/MyConnectionFactory</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-jms-sending"><a class="anchor" href="#boot-features-using-jms-sending"></a> 13.1.4。发送信息</h4>
<div class="paragraph">
<p> Spring 的<code>JmsTemplate</code>是自动配置的，您可以将其直接自动连接到您自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JmsTemplate jmsTemplate;

    @Autowired
    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html"><code>JmsMessagingTemplate</code></a>可以以类似方式注入。如果一个<code>DestinationResolver</code>或一个<code>MessageConverter</code>定义了bean，它会自动关联到自动配置的<code>JmsTemplate</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-jms-receiving"><a class="anchor" href="#boot-features-using-jms-receiving"></a> 13.1.5。接收讯息</h4>
<div class="paragraph">
<p>存在JMS基础结构时，可以使用以下命令注释任何bean <code>@JmsListener</code>创建一个侦听器端点。如果不<code>JmsListenerContainerFactory</code>已定义，将自动配置默认值。如果一个<code>DestinationResolver</code>或一个<code>MessageConverter</code>定义了bean，它会自动关联到默认工厂。</p>
</div>
<div class="paragraph">
<p>默认情况下，默认工厂是事务性的。如果您在基础架构中运行<code>JtaTransactionManager</code>存在时，默认情况下它与侦听器容器关联。如果没有， <code>sessionTransacted</code>标志已启用。在后一种情况下，您可以通过添加以下内容将本地数据存储事务与传入消息的处理相关联： <code>@Transactional</code>在您的侦听器方法（或其委托）上。这样可以确保本地事务完成后，传入消息得到确认。这还包括发送已在同一JMS会话上执行的响应消息。</p>
</div>
<div class="paragraph">
<p>以下组件会在<code>someQueue</code>目的地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">请参阅<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/jms/annotation/EnableJms.html">的Javadoc <code>@EnableJms</code></a>更多细节。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要创建更多<code>JmsListenerContainerFactory</code>实例，或者如果您想覆盖默认实例，Spring Boot提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>您可以用来初始化一个<code>DefaultJmsListenerContainerFactory</code>具有与自动配置相同的设置。</p>
</div>
<div class="paragraph">
<p>例如，以下示例公开了另一个使用特定工厂的工厂。 <code>MessageConverter</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
static class JmsConfiguration {

    @Bean
    public DefaultJmsListenerContainerFactory myFactory(
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory =
                new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory());
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以在任何地方使用工厂<code>@JmsListener</code>注释的方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-amqp"><a class="anchor" href="#boot-features-amqp"></a> 13.2。AMQP</h3>
<div class="paragraph">
<p>高级消息队列协议（AMQP）是面向消息中间件的与平台无关的有线级别协议。Spring AMQP项目将核心Spring概念应用于基于AMQP的消息传递解决方案的开发。Spring Boot为通过RabbitMQ使用AMQP提供了许多便利，包括<code>spring-boot-starter-amqp</code> “起动机”。</p>
</div>
<div class="sect3">
<h4 id="boot-features-rabbitmq"><a class="anchor" href="#boot-features-rabbitmq"></a> 13.2.1。RabbitMQ支持</h4>
<div class="paragraph">
<p><a href="https://www.rabbitmq.com/">RabbitMQ</a>是基于AMQP协议的轻型，可靠，可伸缩和便携式消息代理。 Spring 用途<code>RabbitMQ</code>通过AMQP协议进行通信。</p>
</div>
<div class="paragraph">
<p>RabbitMQ配置由以下位置的外部配置属性控制<code>spring.rabbitmq.*</code> 。例如，您可以在<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用<code>addresses</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.rabbitmq.addresses=amqp://admin:secret@localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个<code>ConnectionNameStrategy</code> bean存在于上下文中，它将自动用于命名由自动配置创建的连接<code>ConnectionFactory</code> 。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>以获得更多受支持的选项。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关更多详细信息<a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">，</a>请参见<a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">了解AMQP（RabbitMQ使用的协议）</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-amqp-sending"><a class="anchor" href="#boot-features-using-amqp-sending"></a> 13.2.2。发送信息</h4>
<div class="paragraph">
<p> Spring 的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>是自动配置的，您可以将它们直接自动连接到您自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final AmqpAdmin amqpAdmin;
    private final AmqpTemplate amqpTemplate;

    @Autowired
    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring-amqp/docs/2.2.1.RELEASE/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html"><code>RabbitMessagingTemplate</code></a>可以以类似方式注入。如果一个<code>MessageConverter</code>定义了bean，它会自动关联到自动配置的<code>AmqpTemplate</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如有必要<code>org.springframework.amqp.core.Queue</code>被定义为bean的对象自动用于在RabbitMQ实例上声明相应的队列。</p>
</div>
<div class="paragraph">
<p>要重试操作，您可以在<code>AmqpTemplate</code> （例如，在代理连接丢失的情况下）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.initial-interval=2s</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，重试是禁用的。您还可以自定义<code>RetryTemplate</code>以编程方式声明一个<code>RabbitRetryTemplateCustomizer</code> bean 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-amqp-receiving"><a class="anchor" href="#boot-features-using-amqp-receiving"></a> 13.2.3。接收讯息</h4>
<div class="paragraph">
<p>当Rabbit基础结构存在时，任何bean都可以用<code>@RabbitListener</code>创建一个侦听器端点。如果不<code>RabbitListenerContainerFactory</code>已经定义，默认<code>SimpleRabbitListenerContainerFactory</code>是自动配置的，您可以使用<code>spring.rabbitmq.listener.type</code>属性。如果一个<code>MessageConverter</code>或一个<code>MessageRecoverer</code>定义了bean，它将自动与默认工厂关联。</p>
</div>
<div class="paragraph">
<p>以下示例组件在以下示例上创建了一个侦听器终结点： <code>someQueue</code>队列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">请参阅<a href="https://docs.spring.io/spring-amqp/docs/2.2.1.RELEASE/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">的Javadoc <code>@EnableRabbit</code></a>更多细节。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要创建更多<code>RabbitListenerContainerFactory</code>实例，或者如果您想覆盖默认实例，Spring Boot提供了一个<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和一个<code>DirectRabbitListenerContainerFactoryConfigurer</code>您可以用来初始化一个<code>SimpleRabbitListenerContainerFactory</code>和一个<code>DirectRabbitListenerContainerFactory</code>具有与自动配置所使用的工厂相同的设置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">选择哪种容器都没有关系。这两个bean通过自动配置公开。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，以下配置类公开了另一个使用特定工厂的工厂。 <code>MessageConverter</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
static class RabbitConfiguration {

    @Bean
    public SimpleRabbitListenerContainerFactory myFactory(
            SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory =
                new SimpleRabbitListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以在任何地方使用工厂<code>@RabbitListener</code> -带注释的方法，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以启用重试来处理侦听器引发异常的情况。默认， <code>RejectAndDontRequeueRecoverer</code>用于，但您可以定义一个<code>MessageRecoverer</code>你自己。重试用尽后，如果代理配置为这样做，则该消息将被拒绝并被丢弃或路由到死信交换。默认情况下，重试是禁用的。您还可以自定义<code>RetryTemplate</code>以编程方式声明一个<code>RabbitRetryTemplateCustomizer</code> bean 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">默认情况下，如果禁用了重试，并且侦听器抛出异常，则会无限期地重试传递。您可以通过两种方式修改此行为：设置<code>defaultRequeueRejected</code>财产<code>false</code>因此尝试进行零次重新交付或抛出<code>AmqpRejectAndDontRequeueException</code>表示该消息应被拒绝。后者是启用重试并达到最大传递尝试次数时使用的机制。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kafka"><a class="anchor" href="#boot-features-kafka"></a> 13.3。Apache Kafka支持</h3>
<div class="paragraph">
<p>通过提供自动配置的功能来支持<a href="https://kafka.apache.org/">Apache Kafka</a> <code>spring-kafka</code>项目。</p>
</div>
<div class="paragraph">
<p>Kafka配置由以下位置的外部配置属性控制<code>spring.kafka.*</code> 。例如，您可以在<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=myGroup</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">要在启动时创建主题，请添加一个类型为的bean <code>NewTopic</code> 。如果该主题已经存在，则将忽略Bean。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>了解更多受支持的选项。</p>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-sending-a-message"><a class="anchor" href="#boot-features-kafka-sending-a-message"></a> 13.3.1。发送信息</h4>
<div class="paragraph">
<p> Spring 的<code>KafkaTemplate</code>是自动配置的，您可以直接在自己的Bean中自动对其进行布线，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    private final KafkaTemplate kafkaTemplate;

    @Autowired
    public MyBean(KafkaTemplate kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果财产<code>spring.kafka.producer.transaction-id-prefix</code>被定义，一个<code>KafkaTransactionManager</code>自动配置。另外，如果<code>RecordMessageConverter</code>定义了bean，它会自动关联到自动配置的<code>KafkaTemplate</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-receiving-a-message"><a class="anchor" href="#boot-features-kafka-receiving-a-message"></a> 13.3.2。接收讯息</h4>
<div class="paragraph">
<p>存在Apache Kafka基础结构时，可以使用以下命令注释任何bean <code>@KafkaListener</code>创建一个侦听器端点。如果不<code>KafkaListenerContainerFactory</code>已经定义，默认值将自动使用<code>spring.kafka.listener.*</code> 。</p>
</div>
<div class="paragraph">
<p>以下组件会在<code>someTopic</code>话题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    @KafkaListener(topics = "someTopic")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个<code>KafkaTransactionManager</code>定义了bean，它将自动关联到容器工厂。同样，如果<code>ErrorHandler</code> ， <code>AfterRollbackProcessor</code>要么<code>ConsumerAwareRebalanceListener</code>定义了bean，它会自动关联到默认工厂。</p>
</div>
<div class="paragraph">
<p>根据侦听器类型， <code>RecordMessageConverter</code>要么<code>BatchMessageConverter</code> bean与默认工厂关联。如果只有一个<code>RecordMessageConverter</code> bean存在于批处理侦听器中，它包装在一个<code>BatchMessageConverter</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">一个习俗<code>ChainedKafkaTransactionManager</code>必须标记<code>@Primary</code>因为它通常引用自动配置的<code>KafkaTransactionManager</code> bean 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-streams"><a class="anchor" href="#boot-features-kafka-streams"></a> 13.3.3。卡夫卡流</h4>
<div class="paragraph">
<p>Apache Kafka的Spring提供了一个工厂bean来创建一个<code>StreamsBuilder</code>反对并管理其流的生命周期。Spring Boot自动配置所需的<code>KafkaStreamsConfiguration</code> bean 只要<code>kafka-streams</code>在类路径上，并且通过启用了Kafka流<code>@EnableKafkaStreams</code>注解。</p>
</div>
<div class="paragraph">
<p>启用Kafka Streams意味着必须设置应用程序ID和引导服务器。前者可以使用<code>spring.kafka.streams.application-id</code> ，默认为<code>spring.application.name</code>如果没有设置。后者可以全局设置，也可以仅针对流进行覆盖。</p>
</div>
<div class="paragraph">
<p>使用专用属性可以使用几个附加属性。其他任意Kafka属性可以使用<code>spring.kafka.streams.properties</code>命名空间。另请参见<a href="#boot-features-kafka-extra-props">其他Kafka属性</a> 。</p>
</div>
<div class="paragraph">
<p>要使用工厂bean，只需将其电线<code>StreamsBuilder</code>进入你的<code>@Bean</code>如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public static class KafkaStreamsExampleConfiguration {

    @Bean
    public KStream&lt;Integer, String&gt; kStream(StreamsBuilder streamsBuilder) {
        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream("ks1In");
        stream.map((k, v) -&gt; new KeyValue&lt;&gt;(k, v.toUpperCase())).to("ks1Out",
                Produced.with(Serdes.Integer(), new JsonSerde&lt;&gt;()));
        return stream;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，由<code>StreamBuilder</code>它创建的对象将自动启动。您可以使用<code>spring.kafka.streams.auto-startup</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-extra-props"><a class="anchor" href="#boot-features-kafka-extra-props"></a> 13.3.4。卡夫卡的其他属性</h4>
<div class="paragraph">
<p>自动配置支持的属性显示在<a href="appendix-application-properties.html#common-application-properties">appendix-application-properties.html中</a> 。请注意，在大多数情况下，这些属性（连字符或camelCase）直接映射到Apache Kafka点缀的属性。有关详细信息，请参阅Apache Kafka文档。</p>
</div>
<div class="paragraph">
<p>这些属性的前几个属性适用于所有组件（生产者，使用者，管理员和流），但如果您希望使用不同的值，则可以在组件级别上指定。Apache Kafka将属性指定为HIGH，MEDIUM或LOW。 Spring Boot自动配置支持所有HIGH重要性属性，一些选定的MEDIUM和LOW属性以及任何没有默认值的属性。</p>
</div>
<div class="paragraph">
<p>Kafka支持的属性的子集仅可通过<code>KafkaProperties</code>类。如果希望使用不直接支持的其他属性来配置生产者或使用者，请使用以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.kafka.properties.prop.one=first
spring.kafka.admin.properties.prop.two=second
spring.kafka.consumer.properties.prop.three=third
spring.kafka.producer.properties.prop.four=fourth
spring.kafka.streams.properties.prop.five=fifth</code></pre>
</div>
</div>
<div class="paragraph">
<p>这设置了共同点<code>prop.one</code>卡夫卡物业<code>first</code> （适用于生产者，消费者和管理员）， <code>prop.two</code>管理员属性<code>second</code> ， <code>prop.three</code>消费财产<code>third</code> ， <code>prop.four</code>生产者财产<code>fourth</code>和<code>prop.five</code>流属性到<code>fifth</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以配置Spring Kafka <code>JsonDeserializer</code>如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，您可以禁用<code>JsonSerializer</code>在标头中发送类型信息的默认行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties.spring.json.add.type.headers=false</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">以这种方式设置的属性将覆盖Spring Boot显式支持的任何配置项。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-kafka"><a class="anchor" href="#boot-features-embedded-kafka"></a> 13.3.5。使用嵌入式Kafka进行测试</h4>
<div class="paragraph">
<p>Spring for Apache Kafka提供了一种使用嵌入式Apache Kafka代理测试项目的便捷方法。要使用此功能，请使用<code>@EmbeddedKafka</code>来自<code>spring-kafka-test</code>模块。有关更多信息，请参阅Spring for Apache Kafka <a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation">参考手册</a> 。</p>
</div>
<div class="paragraph">
<p>要使Spring Boot自动配置与上述嵌入式Apache Kafka代理一起使用，您需要重新映射嵌入式代理地址的系统属性（由<code>EmbeddedKafkaBroker</code> ）添加到Apache Kafka的Spring Boot配置属性中。有几种方法可以做到这一点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供系统属性以将嵌入式代理地址映射到<code>spring.kafka.bootstrap-servers</code>在测试课中：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在...上配置属性名称<code>@EmbeddedKafka</code>注解：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在配置属性中使用占位符：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-resttemplate"><a class="anchor" href="#boot-features-resttemplate"></a> 14。使用调用REST服务<code>RestTemplate</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您需要从应用程序中调用远程REST服务，则可以使用Spring Framework 的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html"><code>RestTemplate</code></a>类。以来<code>RestTemplate</code>实例在使用前通常需要自定义，Spring Boot不提供任何单个自动配置的<code>RestTemplate</code> bean 。但是，它会自动配置<code>RestTemplateBuilder</code> ，可用于创建<code>RestTemplate</code>实例在需要时。自动配置<code>RestTemplateBuilder</code>确保明智<code>HttpMessageConverters</code>适用于<code>RestTemplate</code>实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>RestTemplateBuilder</code>包括许多有用的方法，可用于快速配置<code>RestTemplate</code> 。例如，要添加BASIC身份验证支持，您可以使用<code>builder.basicAuthentication("user", "password").build()</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="boot-features-resttemplate-customization"><a class="anchor" href="#boot-features-resttemplate-customization"></a> 14.1。RestTemplate自定义</h3>
<div class="paragraph">
<p>有以下三种主要方法<code>RestTemplate</code>自定义，具体取决于您希望应用自定义的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有定制的范围尽可能狭窄，请注入自动配置的<code>RestTemplateBuilder</code>然后根据需要调用其方法。每个方法调用都返回一个新的<code>RestTemplateBuilder</code>实例，因此自定义仅影响构建器的使用。</p>
</div>
<div class="paragraph">
<p>要进行整个应用程序的附加自定义，请使用<code>RestTemplateCustomizer</code> bean 。所有此类bean都会自动注册到自动配置的<code>RestTemplateBuilder</code>并应用于与其一起构建的任何模板。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个定制程序，该定制程序配置了除以下主机以外的所有主机的代理使用<code>192.168.0.5</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class ProxyCustomizer implements RestTemplateCustomizer {

    @Override
    public void customize(RestTemplate restTemplate) {
        HttpHost proxy = new HttpHost("proxy.example.com");
        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(new DefaultProxyRoutePlanner(proxy) {

            @Override
            public HttpHost determineProxy(HttpHost target, HttpRequest request, HttpContext context)
                    throws HttpException {
                if (target.getHostName().equals("192.168.0.5")) {
                    return null;
                }
                return super.determineProxy(target, request, context);
            }

        }).build();
        restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，最极端（很少使用）的选项是创建自己的<code>RestTemplateBuilder</code> bean 。这样做会关闭自动配置<code>RestTemplateBuilder</code>并防止任何<code>RestTemplateCustomizer</code> bean 被使用。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-webclient"><a class="anchor" href="#boot-features-webclient"></a> 15使用调用REST服务<code>WebClient</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您的类路径中包含Spring WebFlux，则还可以选择使用<code>WebClient</code>调用远程REST服务。相比<code>RestTemplate</code> ，此客户具有更实用的感觉并且完全反应灵敏。您可以了解更多有关<code>WebClient</code>在<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-client">Spring Framework文档</a>的专用<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-client">部分中</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Boot创建并预配置一个<code>WebClient.Builder</code>为了你;强烈建议将其注入您的组件中并使用它来创建<code>WebClient</code>实例。Spring Boot正在配置该构建器以共享HTTP资源，以与服务器相同的方式反映编解码器的设置（请参阅<a href="#boot-features-webflux-httpcodecs">WebFlux HTTP编解码器自动配置</a> ），以及更多。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

    private final WebClient webClient;

    public MyService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://example.org").build();
    }

    public Mono&lt;Details&gt; someRestCall(String name) {
        return this.webClient.get().uri("/{name}/details", name)
                        .retrieve().bodyToMono(Details.class);
    }

}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webclient-runtime"><a class="anchor" href="#boot-features-webclient-runtime"></a> 15.1。WebClient运行时</h3>
<div class="paragraph">
<p>Spring Boot将自动检测哪个<code>ClientHttpConnector</code>用来开车<code>WebClient</code> ，具体取决于应用程序类路径上可用的库。目前，还支持Reactor Netty和Jetty RS客户端。</p>
</div>
<div class="paragraph">
<p>的<code>spring-boot-starter-webflux</code>入门取决于<code>io.projectreactor.netty:reactor-netty</code>默认情况下，它将同时实现服务器和客户端实施。如果您选择使用Jetty作为反应式服务器，则应在Jetty反应式HTTP客户端库上添加依赖项， <code>org.eclipse.jetty:jetty-reactive-httpclient</code> 。对服务器和客户端使用相同的技术具有其优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p>
</div>
<div class="paragraph">
<p>开发人员可以通过提供自定义来覆盖Jetty和Reactor Netty的资源配置<code>ReactorResourceFactory</code>要么<code>JettyResourceFactory</code> bean-这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>如果您希望为客户覆盖该选择，则可以定义自己的<code>ClientHttpConnector</code> bean并完全控制客户端配置。</p>
</div>
<div class="paragraph">
<p>您可以了解更多有关<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder"><code>WebClient</code> Spring Framework 参考文档中的配置选项</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webclient-customization"><a class="anchor" href="#boot-features-webclient-customization"></a> 15.2。WebClient定制</h3>
<div class="paragraph">
<p>有以下三种主要方法<code>WebClient</code>自定义，具体取决于您希望应用自定义的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有定制的范围尽可能狭窄，请注入自动配置的<code>WebClient.Builder</code>然后根据需要调用其方法。
<code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。如果要使用同一构建器创建多个客户端，则还可以考虑使用以下命令克隆该构建器<code>WebClient.Builder other = builder.clone();</code> 。</p>
</div>
<div class="paragraph">
<p>为了对整个应用程序进行附加定制<code>WebClient.Builder</code>实例，您可以声明<code>WebClientCustomizer</code> bean 和改变<code>WebClient.Builder</code>在注射点局部注射。</p>
</div>
<div class="paragraph">
<p>最后，您可以退回原始API并使用<code>WebClient.create()</code> 。在这种情况下，没有自动配置或<code>WebClientCustomizer</code>被申请;被应用。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-validation"><a class="anchor" href="#boot-features-validation"></a> 16。验证方式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>只要JSR-303实现（例如Hibernate验证器）位于类路径上，就会自动启用Bean验证1.1支持的方法验证功能。这可以让Bean方法带有注释<code>javax.validation</code>其参数和/或返回值的约束。具有此类注释方法的目标类需要使用<code>@Validated</code>类型级别的注解，以搜索其方法的内联约束注解。</p>
</div>
<div class="paragraph">
<p>例如，以下服务触发第一个参数的验证，确保其大小在8到10之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
@Validated
public class MyBean {

    public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
            Author author) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-email"><a class="anchor" href="#boot-features-email"></a> 17。发送邮件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework 通过使用<code>JavaMailSender</code>接口，Spring Boot为其提供了自动配置以及启动器模块。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关如何使用的详细说明，请参见<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/integration.html#mail">参考文档</a> 。 <code>JavaMailSender</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果<code>spring.mail.host</code>和相关的库（由<code>spring-boot-starter-mail</code> ）可用，默认<code>JavaMailSender</code>如果不存在则创建。发送者可以通过来自<code>spring.mail</code>命名空间。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>更多细节。</p>
</div>
<div class="paragraph">
<p>特别是，某些默认超时值是无限的，您可能需要更改该值，以避免线程被无响应的邮件服务器阻止，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=3000
spring.mail.properties.mail.smtp.writetimeout=5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以配置一个<code>JavaMailSender</code>与现有的<code>Session</code>来自JNDI：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mail.jndi-name=mail/Session</code></pre>
</div>
</div>
<div class="paragraph">
<p>当一个<code>jndi-name</code>设置，它优先于所有其他与会话相关的设置。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-jta"><a class="anchor" href="#boot-features-jta"></a> 18岁JTA的分布式事务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot通过使用<a href="https://www.atomikos.com/">Atomikos</a>或<a href="https://github.com/bitronix/btm">Bitronix</a>嵌入式事务管理器，支持跨多个XA资源的分布式JTA事务。部署到合适的Java EE应用程序服务器时，还支持JTA事务。</p>
</div>
<div class="paragraph">
<p>当检测到JTA环境时，Spring的<code>JtaTransactionManager</code>用于管理交易。自动配置的JMS，DataSource和JPA Bean已升级为支持XA事务。您可以使用标准的Spring习语，例如<code>@Transactional</code> ，参加分布式交易。如果您在JTA环境中，但仍想使用本地事务，则可以设置<code>spring.jta.enabled</code>财产<code>false</code>禁用JTA自动配置。</p>
</div>
<div class="sect2">
<h3 id="boot-features-jta-atomikos"><a class="anchor" href="#boot-features-jta-atomikos"></a> 18.1。使用Atomikos交易管理器</h3>
<div class="paragraph">
<p><a href="https://www.atomikos.com/">Atomikos</a>是一种流行的开源事务管理器，可以嵌入到您的Spring Boot应用程序中。您可以使用<code>spring-boot-starter-jta-atomikos</code>入门者可以提取适当的Atomikos库。Spring Boot自动配置Atomikos并确保适当<code>depends-on</code>设置将应用到您的Spring Bean，以正确启动和关闭顺序。</p>
</div>
<div class="paragraph">
<p>默认情况下，Atomikos事务日志写入到<code>transaction-logs</code>应用程序主目录中的目录（应用程序jar文件所在的目录）。您可以通过设置一个自定义此目录的位置<code>spring.jta.log-dir</code>您的财产<code>application.properties</code>文件。开头的属性<code>spring.jta.atomikos.properties</code>也可以用来定制Atomikos <code>UserTransactionServiceImp</code> 。见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a>的完整细节。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Atomikos实例配置一个唯一的ID。默认情况下，此ID是运行Atomikos的计算机的IP地址。为了确保生产中的唯一性，您应该配置<code>spring.jta.transaction-manager-id</code>属性，每个应用程序实例的值都不同。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-bitronix"><a class="anchor" href="#boot-features-jta-bitronix"></a> 18.2。使用Bitronix交易管理器</h3>
<div class="paragraph">
<p><a href="https://github.com/bitronix/btm">Bitronix</a>是流行的开源JTA事务管理器实现。您可以使用<code>spring-boot-starter-jta-bitronix</code>开始将适当的Bitronix依赖项添加到您的项目中。与Atomikos一样，Spring Boot自动配置Bitronix并对您的bean进行后处理，以确保启动和关闭顺序正确。</p>
</div>
<div class="paragraph">
<p>默认情况下，Bitronix事务日志文件（ <code>part1.btm</code>和<code>part2.btm</code> ）写入<code>transaction-logs</code>应用程序主目录中的目录。您可以通过设置以下内容来自定义该目录的位置<code>spring.jta.log-dir</code>属性。开头的属性<code>spring.jta.bitronix.properties</code>也绑定到<code>bitronix.tm.Configuration</code> bean，允许完全自定义。有关详细信息，请参见<a href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration">Bitronix文档</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Bitronix实例配置唯一的ID。默认情况下，此ID是运行Bitronix的计算机的IP地址。为了确保生产中的唯一性，您应该配置<code>spring.jta.transaction-manager-id</code>属性，每个应用程序实例的值都不同。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-javaee"><a class="anchor" href="#boot-features-jta-javaee"></a> 18.3。使用Java EE托管事务管理器</h3>
<div class="paragraph">
<p>如果您将Spring Boot应用程序打包为<code>war</code>要么<code>ear</code>文件并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。Spring Boot尝试通过查看常见的JNDI位置来自动配置事务管理器（ <code>java:comp/UserTransaction</code> ， <code>java:comp/TransactionManager</code> ， 等等）。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。 Spring Boot尝试通过寻找一个自动配置JMS <code>ConnectionFactory</code>在JNDI路径（ <code>java:/JmsXA</code>要么<code>java:/XAConnectionFactory</code> ），您可以使用<a href="#boot-features-connecting-to-a-jndi-datasource"><code>spring.datasource.jndi-name</code>属性</a>来配置您的<code>DataSource</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-mixed-jms"><a class="anchor" href="#boot-features-jta-mixed-jms"></a> 18.4。混合XA和非XA JMS连接</h3>
<div class="paragraph">
<p>使用JTA时，主要的JMS <code>ConnectionFactory</code> bean支持XA，并参与分布式事务。在某些情况下，您可能想通过使用非XA处理某些JMS消息<code>ConnectionFactory</code> 。例如，您的JMS处理逻辑可能需要比XA超时更长的时间。</p>
</div>
<div class="paragraph">
<p>如果您要使用非XA <code>ConnectionFactory</code> ，您可以注入<code>nonXaJmsConnectionFactory</code> bean 而不是<code>@Primary</code><code>jmsConnectionFactory</code> bean 。为了保持一致， <code>jmsConnectionFactory</code>还通过使用bean别名来提供bean <code>xaJmsConnectionFactory</code> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何注入<code>ConnectionFactory</code>实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Inject the primary (XA aware) ConnectionFactory
@Autowired
private ConnectionFactory defaultConnectionFactory;

// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
@Autowired
@Qualifier("xaJmsConnectionFactory")
private ConnectionFactory xaConnectionFactory;

// Inject the non-XA aware ConnectionFactory
@Autowired
@Qualifier("nonXaJmsConnectionFactory")
private ConnectionFactory nonXaConnectionFactory;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-supporting-alternative-embedded"><a class="anchor" href="#boot-features-jta-supporting-alternative-embedded"></a> 18.5。支持替代嵌入式事务管理器</h3>
<div class="paragraph">
<p>的<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java"><code>XAConnectionFactoryWrapper</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java"><code>XADataSourceWrapper</code></a>接口可用于支持其他嵌入式事务管理器。接口负责包装<code>XAConnectionFactory</code>和<code>XADataSource</code> bean 并定期暴露<code>ConnectionFactory</code>和<code>DataSource</code> bean，透明地注册分布式事务。数据源和JMS自动配置使用JTA变体，前提是您拥有<code>JtaTransactionManager</code> Bean和在您的内部注册的适当XA包装bean <code>ApplicationContext</code> 。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java">BitronixXAConnectionFactoryWrapper</a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java">BitronixXADataSourceWrapper</a>提供了有关如何编写XA包装器的良好示例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-hazelcast"><a class="anchor" href="#boot-features-hazelcast"></a> 19淡褐色</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果<a href="https://hazelcast.com/">Hazelcast</a>在类路径上并且找到合适的配置，则Spring Boot会自动配置一个<code>HazelcastInstance</code>您可以在您的应用程序中注入。</p>
</div>
<div class="paragraph">
<p>如果您定义<code>com.hazelcast.config.Config</code> bean，Spring Boot使用它。如果您的配置定义了一个实例名称，Spring Boot会尝试查找现有实例，而不是创建一个新实例。</p>
</div>
<div class="paragraph">
<p>如果您定义<code>com.hazelcast.config.Config</code> bean，Spring Boot使用它。如果您的配置定义了一个实例名称，Spring Boot会尝试查找现有实例，而不是创建一个新实例。</p>
</div>
<div class="paragraph">
<p>您还可以指定通过配置使用的Hazelcast配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.hazelcast.config=classpath:config/my-hazelcast.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>否则，Spring Boot会尝试从默认位置查找Hazelcast配置： <code>hazelcast.xml</code>在工作目录中或类路径的根目录中，或者<code>.yaml</code>相同位置的对应对象。我们还会检查<code>hazelcast.config</code>设置系统属性。有关更多详细信息，请参见<a href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast文档</a> 。</p>
</div>
<div class="paragraph">
<p>如果<code>hazelcast-client</code>在类路径中，Spring Boot首先尝试通过检查以下配置选项来创建客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个的存在<code>com.hazelcast.client.config.ClientConfig</code> bean 。</p>
</li>
<li>
<p>由配置文件定义的<code>spring.hazelcast.config</code>属性。</p>
</li>
<li>
<p>存在的<code>hazelcast.client.config</code>系统属性。</p>
</li>
<li>
<p>一种<code>hazelcast-client.xml</code>在工作目录或类路径的根目录下。</p>
</li>
<li>
<p>一种<code>hazelcast-client.yaml</code>在工作目录或类路径的根目录下。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot还具有<a href="#boot-features-caching-provider-hazelcast">对Hazelcast的显式缓存支持</a> 。如果启用了缓存，则<code>HazelcastInstance</code>自动包装在<code>CacheManager</code>实施。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-quartz"><a class="anchor" href="#boot-features-quartz"></a> 20石英调度器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为使用<a href="https://www.quartz-scheduler.org/">Quartz Scheduler</a>提供了许多便利，包括<code>spring-boot-starter-quartz</code> “起动机”。如果石英可用，则<code>Scheduler</code>已自动配置（通过<code>SchedulerFactoryBean</code>抽象）。</p>
</div>
<div class="paragraph">
<p>以下类型的Bean会自动被拾取并与<code>Scheduler</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JobDetail</code> ：定义特定的作业。
<code>JobDetail</code>实例可以用<code>JobBuilder</code> API。</p>
</li>
<li>
<p><code>Calendar</code> 。</p>
</li>
<li>
<p><code>Trigger</code> ：定义何时触发特定作业。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，内存中<code>JobStore</code>用来。但是，可以在以下情况下配置基于JDBC的存储： <code>DataSource</code> Bean在您的应用程序中可用，并且<code>spring.quartz.job-store-type</code>属性进行了相应配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.quartz.job-store-type=jdbc</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用JDBC存储时，可以在启动时初始化模式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.quartz.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">默认情况下，使用Quartz库随附的标准脚本检测并初始化数据库。这些脚本将删除现有表，并在每次重新启动时删除所有触发器。也可以通过设置<code>spring.quartz.jdbc.schema</code>属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要使石英使用<code>DataSource</code>除了应用程序的主程序<code>DataSource</code> ，声明一个<code>DataSource</code> bean ，注释它<code>@Bean</code>方法<code>@QuartzDataSource</code> 。这样做可以确保特定于石英的<code>DataSource</code>两者都使用<code>SchedulerFactoryBean</code>和模式初始化。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过配置创建的作业将不会覆盖从持久性作业存储中读取的已注册作业。要覆盖现有的工作定义，请设置<code>spring.quartz.overwrite-existing-jobs</code>属性。</p>
</div>
<div class="paragraph">
<p>可以使用以下命令自定义Quartz Scheduler配置<code>spring.quartz</code>属性和<code>SchedulerFactoryBeanCustomizer</code> bean ，允许程序化<code>SchedulerFactoryBean</code>定制。可以使用以下命令自定义高级Quartz配置属性<code>spring.quartz.properties.*</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">特别是<code>Executor</code> bean没有与调度程序关联，因为Quartz提供了一种通过以下方式配置调度程序的方法<code>spring.quartz.properties</code> 。如果您需要自定义任务执行器，请考虑实施<code>SchedulerFactoryBeanCustomizer</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>作业可以定义设置器以注入数据映射属性。常规 bean 也可以类似的方式注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SampleJob extends QuartzJobBean {

    private MyService myService;

    private String name;

    // Inject "MyService" bean
    public void setMyService(MyService myService) { ... }

    // Inject the "name" job data property
    public void setName(String name) { ... }

    @Override
    protected void executeInternal(JobExecutionContext context)
            throws JobExecutionException {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-task-execution-scheduling"><a class="anchor" href="#boot-features-task-execution-scheduling"></a> 21任务执行和计划</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在没有<code>Executor</code> Bean中，Spring Boot自动配置一个<code>ThreadPoolTaskExecutor</code>具有合理的默认设置，可以自动将其与异步任务执行相关联（ <code>@EnableAsync</code> ）和Spring MVC异步请求处理。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您定义了一个自定义<code>Executor</code>在上下文中，定期执行任务（即<code>@EnableAsync</code> ）将透明地使用它，但由于需要<code>AsyncTaskExecutor</code>实现（命名为<code>applicationTaskExecutor</code> ）。根据您的目标安排，您可以更改<code>Executor</code>变成一个<code>ThreadPoolTaskExecutor</code>或同时定义一个<code>ThreadPoolTaskExecutor</code>和<code>AsyncConfigurer</code>包装你的习惯<code>Executor</code> 。</p>
</div>
<div class="paragraph">
<p>自动配置<code>TaskExecutorBuilder</code>使您可以轻松创建实例，这些实例可以重现默认情况下的自动配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>线程池使用8个核心线程，这些线程可以根据负载增长和收缩。这些默认设置可以使用<code>spring.task.execution</code>命名空间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.task.execution.pool.max-size=16
spring.task.execution.pool.queue-capacity=100
spring.task.execution.pool.keep-alive=10s</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将线程池更改为使用有界队列，以便当队列已满（100个任务）时，线程池最多增加到16个线程。池的收缩更加激进，因为当线程空闲10秒（而不是默认情况下的60秒）时，它们将被回收。</p>
</div>
<div class="paragraph">
<p>一种<code>ThreadPoolTaskScheduler</code>如果需要与计划的任务执行关联，也可以自动配置（ <code>@EnableScheduling</code> ）。线程池默认使用一个线程，可以使用以下选项对这些设置进行微调： <code>spring.task.scheduling</code>命名空间。</p>
</div>
<div class="paragraph">
<p>两者都<code>TaskExecutorBuilder</code> bean 和一个<code>TaskSchedulerBuilder</code>如果需要创建自定义执行程序或调度程序，则可以在上下文中使用bean。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-integration"><a class="anchor" href="#boot-features-integration"></a> 22 Spring Integration </h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为使用<a href="https://spring.io/projects/spring-integration">Spring Integration</a>提供了许多便利，包括<code>spring-boot-starter-integration</code> “起动机”。Spring Integration通过消息传递以及其他传输（例如HTTP，TCP等）提供抽象。如果您的类路径中有Spring Integration，则可以通过<code>@EnableIntegration</code>注解。</p>
</div>
<div class="paragraph">
<p>Spring Boot还配置了一些功能，这些功能由其他Spring Integration模块的存在触发。如果<code>spring-integration-jmx</code>同样在类路径上，消息处理统计信息通过JMX发布。如果<code>spring-integration-jdbc</code>如果可用，则可以在启动时创建默认的数据库架构，如以下行所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.integration.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="paragraph">
<p>见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java"><code>IntegrationAutoConfiguration</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java"><code>IntegrationProperties</code></a>类以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果千分尺<code>meterRegistry</code> Bean存在，Spring Integration指标将由Micrometer管理。如果您希望使用旧版Spring Integration指标，请添加一个<code>DefaultMetricsFactory</code> bean到应用程序上下文。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-session"><a class="anchor" href="#boot-features-session"></a> 23。 Spring 会议</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为各种数据存储提供了<a href="https://spring.io/projects/spring-session">Spring Session</a>自动配置。在构建Servlet Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDBC</p>
</li>
<li>
<p>雷迪斯</p>
</li>
<li>
<p>淡褐色</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>构建反应式Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>雷迪斯</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果类路径上存在单个Spring Session模块，则Spring Boot会自动使用该存储实现。如果您有多个实现，则必须选择<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java"><code>StoreType</code></a>您希望用来存储会话的文件。例如，要将JDBC用作后端存储，可以按以下方式配置应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.session.store-type=jdbc</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以通过设置<code>store-type</code>至<code>none</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每个商店都有特定的附加设置。例如，可以为JDBC存储定制表的名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.session.jdbc.table-name=SESSIONS</code></pre>
</div>
</div>
<div class="paragraph">
<p>要设置会话超时，您可以使用<code>spring.session.timeout</code>属性。如果未设置该属性，则自动配置将恢复为<code>server.servlet.session.timeout</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-jmx"><a class="anchor" href="#boot-features-jmx"></a> 24通过JMX进行监视和管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java管理扩展（JMX）提供了监视和管理应用程序的标准机制。Spring Boot公开最合适<code>MBeanServer</code>作为ID为<code>mbeanServer</code> 。使用Spring JMX注释注释的任何bean（ <code>@ManagedResource</code> ， <code>@ManagedAttribute</code> ， 要么<code>@ManagedOperation</code> ）暴露于此。</p>
</div>
<div class="paragraph">
<p>如果您的平台提供了标准<code>MBeanServer</code> ，Spring Boot将使用该默认值，并且默认使用VM <code>MBeanServer</code>如有必要。如果所有步骤均失败，则重新<code>MBeanServer</code>将被创建。</p>
</div>
<div class="paragraph">
<p>见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a>类以获取更多详细信息。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-testing"><a class="anchor" href="#boot-features-testing"></a> 25岁测试中</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了许多实用程序和注释，可以在测试应用程序时提供帮助。测试支持由两个模块提供： <code>spring-boot-test</code>包含核心项目，并且<code>spring-boot-test-autoconfigure</code>支持测试的自动配置。</p>
</div>
<div class="paragraph">
<p>大多数开发人员使用<code>spring-boot-starter-test</code> “入门程序”，它导入了Spring Boot测试模块以及JUnit Jupiter，AssertJ，Hamcrest和许多其他有用的库。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>启动程序还带来了老式引擎，因此您可以运行JUnit 4和JUnit 5测试。如果已将测试迁移到JUnit 5，则应排除对JUnit 4的支持，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
            &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="boot-features-test-scope-dependencies"><a class="anchor" href="#boot-features-test-scope-dependencies"></a> 25.1。测试范围依赖性</h3>
<div class="paragraph">
<p>的<code>spring-boot-starter-test</code> “入门”（在<code>test</code><code>scope</code> ）包含以下提供的库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://junit.org/junit5">JUnit 5</a> （包括用于与JUnit 4向后兼容的老式引擎：事实上的标准，用于对Java应用程序进行单元测试。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#integration-testing">Spring测试</a>和Spring Boot测试：对Spring Boot应用程序的实用程序和集成测试支持。</p>
</li>
<li>
<p><a href="https://joel-costigliola.github.io/assertj/">AssertJ</a> ：流畅的断言库。</p>
</li>
<li>
<p><a href="https://github.com/hamcrest/JavaHamcrest">Hamcrest</a> ：匹配对象库（也称为约束或谓词）。</p>
</li>
<li>
<p><a href="https://mockito.github.io">Mockito</a> ：一个Java <a href="https://mockito.github.io">模拟</a>框架。</p>
</li>
<li>
<p><a href="https://github.com/skyscreamer/JSONassert">JSONassert</a> ：JSON的断言库。</p>
</li>
<li>
<p><a href="https://github.com/jayway/JsonPath">JsonPath</a> ：JSON的XPath。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，我们发现这些通用库在编写测试时很有用。如果这些库不满足您的需求，则可以添加自己的其他测试依赖项。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-testing-spring-applications"><a class="anchor" href="#boot-features-testing-spring-applications"></a> 25.2。测试Spring应用程序</h3>
<div class="paragraph">
<p>依赖注入的主要优点之一是，它应该使您的代码更易于进行单元测试。您可以使用实例化对象<code>new</code>运算符甚至不涉及Spring。您还可以使用<em>模拟对象</em>而不是实际的依赖项。</p>
</div>
<div class="paragraph">
<p>通常，您需要超越单元测试并开始集成测试（使用Spring <code>ApplicationContext</code> ）。能够进行集成测试而无需部署应用程序或连接到其他基础结构是很有用的。</p>
</div>
<div class="paragraph">
<p>Spring Framework 包括用于此类集成测试的专用测试模块。您可以直接声明一个依赖项<code>org.springframework:spring-test</code>或使用<code>spring-boot-starter-test</code> “启动器”以过渡方式将其拉入。</p>
</div>
<div class="paragraph">
<p>如果您尚未使用<code>spring-test</code>之前，您应该先阅读Spring Framework 参考文档的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#testing">相关部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-testing-spring-boot-applications"><a class="anchor" href="#boot-features-testing-spring-boot-applications"></a> 25.3。测试Spring Boot应用程序</h3>
<div class="paragraph">
<p>Spring Boot应用程序是Spring <code>ApplicationContext</code> ，因此除了使用普通Spring上下文通常进行的测试之外，无需执行任何非常特殊的操作即可对其进行测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，仅当您使用时，Spring Boot的外部属性，日志记录和其他功能才会安装在上下文中<code>SpringApplication</code>创建它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Boot提供了一个<code>@SpringBootTest</code>注释，可以用作标准的替代方法<code>spring-test</code><code>@ContextConfiguration</code>需要Spring Boot功能时使用注解。注释通过<a href="#boot-features-testing-spring-boot-applications-detecting-config">创建<code>ApplicationContext</code>在您的测试中通过<code>SpringApplication</code></a> 。此外<code>@SpringBootTest</code>还提供了许多其他注释，用于<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试</a>应用程序的<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">更多特定</a>部分。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您使用的是JUnit 4，请不要忘记也添加<code>@RunWith(SpringRunner.class)</code>进行测试，否则注释将被忽略。如果您使用的是JUnit 5，则无需添加等效项<code>@ExtendWith(SpringExtension.class)</code>如<code>@SpringBootTest</code>和另一个<code>@…Test</code>注释已经带有注释。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认， <code>@SpringBootTest</code>不会启动服务器。您可以使用<code>webEnvironment</code>的属性<code>@SpringBootTest</code>进一步完善测试的运行方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MOCK</code> （默认）：加载网页<code>ApplicationContext</code>并提供模拟网络环境。使用此注释时，不会启动嵌入式服务器。如果您的类路径中没有网络环境，则此模式将透明地退回到创建常规非网络环境<code>ApplicationContext</code> 。可以结合使用<a href="#boot-features-testing-spring-boot-applications-testing-with-mock-environment"><code>@AutoConfigureMockMvc</code>要么<code>@AutoConfigureWebTestClient</code></a>用于对Web应用程序进行基于模拟的测试。</p>
</li>
<li>
<p><code>RANDOM_PORT</code> ：加载一个<code>WebServerApplicationContext</code>并提供了一个真实的网络环境。嵌入式服务器将启动并在随机端口上侦听。</p>
</li>
<li>
<p><code>DEFINED_PORT</code> ：加载一个<code>WebServerApplicationContext</code>并提供了一个真实的网络环境。嵌入式服务器将启动并在已定义的端口上侦听（从您的<code>application.properties</code> ）或默认端口<code>8080</code> 。</p>
</li>
<li>
<p><code>NONE</code> ：加载<code>ApplicationContext</code>通过使用<code>SpringApplication</code>但不提供<em>任何</em>网络环境（模拟或其他方式）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的测试是<code>@Transactional</code> ，默认情况下会在每个测试方法的末尾回滚事务。但是，由于将这种安排与<code>RANDOM_PORT</code>要么<code>DEFINED_PORT</code>隐式提供了一个真正的servlet环境，HTTP客户端和服务器在单独的线程中运行，因此在单独的事务中运行。在这种情况下，服务器上启动的任何事务都不会回滚。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@SpringBootTest</code>与<code>webEnvironment = WebEnvironment.RANDOM_PORT</code>如果您的应用程序使用其他端口作为管理服务器，则还将在单独的随机端口上启动管理服务器。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-detecting-web-app-type"><a class="anchor" href="#boot-features-testing-spring-boot-applications-detecting-web-app-type"></a> 25.3.1。检测Web应用程序类型</h4>
<div class="paragraph">
<p>如果Spring MVC可用，则配置基于常规MVC的应用程序上下文。如果您只有Spring WebFlux，我们将检测到该情况并配置基于WebFlux的应用程序上下文。</p>
</div>
<div class="paragraph">
<p>如果两者都存在，则Spring MVC优先。如果要在这种情况下测试反应式Web应用程序，则必须设置<code>spring.main.web-application-type</code>属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest(properties = "spring.main.web-application-type=reactive")
class MyWebFluxTests { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-detecting-config"><a class="anchor" href="#boot-features-testing-spring-boot-applications-detecting-config"></a> 25.3.2。检测测试配置</h4>
<div class="paragraph">
<p>如果您熟悉Spring Test Framework，则可能会习惯于<code>@ContextConfiguration(classes=…​)</code>为了指定哪个Spring <code>@Configuration</code>加载。另外，您可能经常使用嵌套<code>@Configuration</code>测试中的课程。</p>
</div>
<div class="paragraph">
<p>在测试Spring Boot应用程序时，通常不需要这样做。 Spring Boot 子<code>@*Test</code>只要您未明确定义批注，注释就会自动搜索您的主配置。</p>
</div>
<div class="paragraph">
<p>搜索算法从包含测试的程序包开始工作，直到找到带有注释的类<code>@SpringBootApplication</code>要么<code>@SpringBootConfiguration</code> 。只要您以合理的方式<a href="using-spring-boot.html#using-boot-structuring-your-code">对代码</a>进行<a href="using-spring-boot.html#using-boot-structuring-your-code">结构化</a> ，通常就可以找到您的主要配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果使用<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试注释来测试应用程序的更特定的部分</a> ，则应避免在<a href="#boot-features-testing-spring-boot-applications-testing-user-configuration">main方法的应用程序类</a>上添加特定于特定区域的配置设置。</p>
</div>
<div class="paragraph">
<p>基础组件扫描配置<code>@SpringBootApplication</code>定义用于确保切片按预期工作的排除过滤器。如果您使用显式<code>@ComponentScan</code>您的指令<code>@SpringBootApplication</code> -带注释的类，请注意那些过滤器将被禁用。如果使用切片，则应再次定义它们。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要自定义主要配置，则可以使用嵌套<code>@TestConfiguration</code>类。不像嵌套<code>@Configuration</code>类（将用于代替应用程序的主要配置） <code>@TestConfiguration</code>除了应用程序的主要配置，还使用了class。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring的测试框架在测试之间缓存应用程序上下文。因此，只要您的测试共享相同的配置（无论如何发现），加载上下文的潜在耗时过程就只会发生一次。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-excluding-config"><a class="anchor" href="#boot-features-testing-spring-boot-applications-excluding-config"></a> 25.3.3。排除测试配置</h4>
<div class="paragraph">
<p>如果您的应用程序使用组件扫描（例如，如果您使用<code>@SpringBootApplication</code>要么<code>@ComponentScan</code> ），则可能会偶然发现到处都是为特定测试创建的顶级配置类。</p>
</div>
<div class="paragraph">
<p>正如我们<a href="#boot-features-testing-spring-boot-applications-detecting-config">先前所见</a> ， <code>@TestConfiguration</code>可以在测试的内部类上使用以自定义主要配置。当放在顶级班级时， <code>@TestConfiguration</code>表示中的类<code>src/test/java</code>不应通过扫描拾取。然后，可以在需要的位置显式导入该类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest
@Import(MyTestsConfiguration.class)
class MyTests {

    @Test
    void exampleTest() {
        ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果直接使用<code>@ComponentScan</code> （也就是说，不是通过<code>@SpringBootApplication</code> ），您需要注册<code>TypeExcludeFilter</code>用它。有关详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/context/TypeExcludeFilter.html">Javadoc</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-application-arguments"><a class="anchor" href="#boot-features-testing-spring-boot-application-arguments"></a> 25.3.4。使用应用程序参数</h4>
<div class="paragraph">
<p>如果您的应用程序需要<a href="#boot-features-application-arguments">参数</a> ，则可以<code>@SpringBootTest</code>使用<code>args</code>属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest(args = "--app.test=one")
class ApplicationArgumentsExampleTests {

    @Test
    void applicationArgumentsPopulated(@Autowired ApplicationArguments args) {
        assertThat(args.getOptionNames()).containsOnly("app.test");
        assertThat(args.getOptionValues("app.test")).containsOnly("one");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-with-mock-environment"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-with-mock-environment"></a> 25.3.5。在模拟环境中进行测试</h4>
<div class="paragraph">
<p>默认， <code>@SpringBootTest</code>无法启动服务器。如果您有要针对此模拟环境进行测试的Web终结点，则可以另外配置<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference//testing.html#spring-mvc-test-framework"><code>MockMvc</code></a>如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
class MockMvcExampleTests {

    @Test
    void exampleTest(@Autowired MockMvc mvc) throws Exception {
        mvc.perform(get("/")).andExpect(status().isOk()).andExpect(content().string("Hello World"));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您只想专注于Web层而不想开始完整<code>ApplicationContext</code> ，请考虑<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests">使用<code>@WebMvcTest</code>相反</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>或者，您可以配置一个<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#webtestclient-tests"><code>WebTestClient</code></a>如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;

@SpringBootTest
@AutoConfigureWebTestClient
class MockWebTestClientExampleTests {

    @Test
    void exampleTest(@Autowired WebTestClient webClient) {
        webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).isEqualTo("Hello World");
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在模拟环境中进行测试通常比在完整的Servlet容器中运行更快。但是，由于模拟发生在Spring MVC层，因此无法使用MockMvc直接测试依赖于较低级别Servlet容器行为的代码。</p>
</div>
<div class="paragraph">
<p>例如，Spring Boot的错误处理基于Servlet容器提供的“错误页面”支持。这意味着，尽管您可以按预期测试MVC层引发和处理异常，但是您无法直接测试是否呈现了特定的<a href="#boot-features-error-handling-custom-error-pages">自定义错误页面</a> 。如果您需要测试这些较低级别的问题，则可以按照下一节中的描述启动一个完全运行的服务器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-with-running-server"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-with-running-server"></a> 25.3.6。使用正在运行的服务器进行测试</h4>
<div class="paragraph">
<p>如果需要启动完全运行的服务器，建议您使用随机端口。如果您使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code> ，每次运行测试时都会随机选择一个可用端口。</p>
</div>
<div class="paragraph">
<p>的<code>@LocalServerPort</code>批注可用于<a href="howto.html#howto-discover-the-http-port-at-runtime">将实际使用的端口</a>注入测试中。为了方便起见，需要对已启动的服务器进行REST调用的测试还可以<code>@Autowire</code>一种<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#webtestclient-tests"><code>WebTestClient</code></a> ，它解析到正在运行的服务器的相对链接，并带有用于验证响应的专用API，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.test.web.reactive.server.WebTestClient;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class RandomPortWebTestClientExampleTests {

    @Test
    void exampleTest(@Autowired WebTestClient webClient) {
        webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).isEqualTo("Hello World");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此设置要求<code>spring-webflux</code>在类路径上。如果您不能或不会添加webflux，Spring Boot还提供了一个<code>TestRestTemplate</code>设施：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class RandomPortTestRestTemplateExampleTests {

    @Test
    void exampleTest(@Autowired TestRestTemplate restTemplate) {
        String body = restTemplate.getForObject("/", String.class);
        assertThat(body).isEqualTo("Hello World");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-customizing-web-test-client"><a class="anchor" href="#boot-features-testing-spring-boot-applications-customizing-web-test-client"></a> 25.3.7。自定义WebTestClient</h4>
<div class="paragraph">
<p>自定义<code>WebTestClient</code> bean，配置一个<code>WebTestClientBuilderCustomizer</code> bean 。任何这样的 bean 都被称为<code>WebTestClient.Builder</code>用于创建<code>WebTestClient</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-jmx"><a class="anchor" href="#boot-features-testing-spring-boot-applications-jmx"></a> 25.3.8。使用JMX</h4>
<div class="paragraph">
<p>由于测试上下文框架缓存上下文，因此默认情况下禁用JMX以防止相同组件在同一域上注册。如果此类测试需要访问<code>MBeanServer</code> ，也考虑将其标记为脏：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(SpringExtension.class)
@SpringBootTest(properties = "spring.jmx.enabled=true")
@DirtiesContext
class SampleJmxTests {

    @Autowired
    private MBeanServer mBeanServer;

    @Test
    void exampleTest() {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-mocking-beans"><a class="anchor" href="#boot-features-testing-spring-boot-applications-mocking-beans"></a> 25.3.9。模拟 bean 和间谍 bean </h4>
<div class="paragraph">
<p>运行测试时，有时有必要在应用程序上下文中模拟某些组件。例如，您可能在开发过程中无法使用某些远程服务的外观。当您要模拟在实际环境中可能难以触发的故障时，模拟也很有用。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含一个<code>@MockBean</code>批注，可用于为您的内部bean定义Mockito模拟<code>ApplicationContext</code> 。您可以使用批注添加新bean或替换单个现有bean定义。注释可以直接用于测试类，测试中的字段或<code>@Configuration</code>类和字段。在字段上使用时，还将注入创建的模拟的实例。每种测试方法后，模拟 bean 都会自动重置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您的测试使用Spring Boot的测试注释之一（例如<code>@SpringBootTest</code> ），此功能会自动启用。要以其他方式使用此功能，必须显式添加侦听器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestExecutionListeners(MockitoTestExecutionListener.class)</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例替换了现有的<code>RemoteService</code>一个模拟实现的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.context.*;
import org.springframework.boot.test.mock.mockito.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.BDDMockito.*;

@SpringBootTest
class MyTests {

    @MockBean
    private RemoteService remoteService;

    @Autowired
    private Reverser reverser;

    @Test
    void exampleTest() {
        // RemoteService has been injected into the reverser bean
        given(this.remoteService.someCall()).willReturn("mock");
        String reverse = reverser.reverseSomeCall();
        assertThat(reverse).isEqualTo("kcom");
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@MockBean</code>不能用于模拟应用程序上下文刷新期间执行的bean的行为。到执行测试时，应用程序上下文刷新已完成，并且配置模拟行为为时已晚。我们建议使用<code>@Bean</code>在这种情况下创建和配置模拟的方法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此外，您可以使用<code>@SpyBean</code>用Mockito包装任何现有的bean <code>spy</code> 。有关完整的详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/test/mock/mockito/SpyBean.html">Javadoc</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring的测试框架在测试之间缓存应用程序上下文，并为共享相同配置的测试重用上下文，但是使用<code>@MockBean</code>要么<code>@SpyBean</code>影响缓存键，这很可能会增加上下文的数量。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您正在使用<code>@SpyBean</code>用...监视beans<code>@Cacheable</code>通过名称引用参数的方法，您的应用程序必须使用<code>-parameters</code> 。这样可以确保一旦侦察到bean，就可以将参数名称用于缓存基础结构。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-tests"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests"></a> 25.3.10。自动配置的测试</h4>
<div class="paragraph">
<p>Spring Boot的自动配置系统对于应用程序非常有效，但有时对于测试来说可能有点过多。它通常仅有助于加载测试应用程序“切片”所需的配置部分。例如，您可能想要测试Spring MVC控制器是否正确映射了URL，并且您不想在这些测试中涉及数据库调用，或者您想要测试JPA实体，并且对那些JPA实体不感兴趣。测试运行。</p>
</div>
<div class="paragraph">
<p>的<code>spring-boot-test-autoconfigure</code>该模块包括许多注释，可用于自动配置此类“切片”。他们每个人都以类似的方式工作， <code>@…​Test</code>加载的注释<code>ApplicationContext</code>和一个或多个<code>@AutoConfigure…​</code>可以用于自定义自动配置设置的注释。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">每个切片将组件扫描限制为适当的组件，并加载一组非常受限制的自动配置类。如果您需要排除其中之一，则大多数<code>@…​Test</code>注释提供了一个<code>excludeAutoConfiguration</code>属性。或者，您可以使用<code>@ImportAutoConfiguration#exclude</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通过使用多个来包含多个“切片” <code>@…​Test</code>不支持一项测试中的注释。如果您需要多个“切片”，请选择其中一个<code>@…​Test</code>注释并包括<code>@AutoConfigure…​</code>手动注释其他“切片”。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">也可以使用<code>@AutoConfigure…​</code>带有标准的注释<code>@SpringBootTest</code>注解。如果您对“切片”应用程序不感兴趣，但需要一些自动配置的测试bean，则可以使用此组合。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-json-tests"></a> 25.3.11。自动配置的JSON测试</h4>
<div class="paragraph">
<p>要测试对象JSON序列化和反序列化是否按预期工作，可以使用<code>@JsonTest</code>注解。
<code>@JsonTest</code>自动配置可用的受支持的JSON映射器，该映射器可以是以下库之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>杰克逊<code>ObjectMapper</code> ， 任何<code>@JsonComponent</code> bean 和任何杰克逊<code>Module</code> s</p>
</li>
<li>
<p><code>Gson</code></p>
</li>
<li>
<p><code>Jsonb</code></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">启用的自动配置的列表<code>@JsonTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要配置自动配置的元素，则可以使用<code>@AutoConfigureJsonTesters</code>注解。</p>
</div>
<div class="paragraph">
<p>Spring Boot包括基于AssertJ的助手，这些助手与JSONAssert和JsonPath库一起使用，以检查JSON是否按预期方式显示。的<code>JacksonTester</code> ， <code>GsonTester</code> ， <code>JsonbTester</code>和<code>BasicJsonTester</code>这些类可以分别用于Jackson，Gson，Jsonb和Strings。测试类上的任何帮助程序字段都可以是<code>@Autowired</code>使用时<code>@JsonTest</code> 。以下示例显示了Jackson的测试类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.json.*;
import org.springframework.boot.test.context.*;
import org.springframework.boot.test.json.*;

import static org.assertj.core.api.Assertions.*;

@JsonTest
class MyJsonTests {

    @Autowired
    private JacksonTester&lt;VehicleDetails&gt; json;

    @Test
    void testSerialize() throws Exception {
        VehicleDetails details = new VehicleDetails("Honda", "Civic");
        // Assert against a `.json` file in the same package as the test
        assertThat(this.json.write(details)).isEqualToJson("expected.json");
        // Or use JSON path based assertions
        assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
        assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make")
                .isEqualTo("Honda");
    }

    @Test
    void testDeserialize() throws Exception {
        String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
        assertThat(this.json.parse(content))
                .isEqualTo(new VehicleDetails("Ford", "Focus"));
        assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">JSON帮助程序类也可以直接在标准单元测试中使用。为此，请致电<code>initFields</code>您的助手方法<code>@Before</code>如果您不使用方法<code>@JsonTest</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您正在使用基于Spring Boot的基于AssertJ的助手在给定的JSON路径上对数字值进行断言，则可能无法使用<code>isEqualTo</code>取决于类型。相反，您可以使用AssertJ的<code>satisfies</code>断言该值匹配给定条件。例如，以下示例断言实际数字是一个接近于<code>0.15</code>在...的偏移量内<code>0.01</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">assertThat(json.write(message))
    .extractingJsonPathNumberValue("@.test.numberValue")
    .satisfies((number) -&gt; assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests"></a> 25.3.12。自动配置的Spring MVC测试</h4>
<div class="paragraph">
<p>要测试Spring MVC控制器是否按预期工作，请使用<code>@WebMvcTest</code>注解。
<code>@WebMvcTest</code>自动配置Spring MVC基础架构并将扫描的Bean限制为<code>@Controller</code> ， <code>@ControllerAdvice</code> ， <code>@JsonComponent</code> ， <code>Converter</code> ， <code>GenericConverter</code> ， <code>Filter</code> ， <code>HandlerInterceptor</code> ， <code>WebMvcConfigurer</code>和<code>HandlerMethodArgumentResolver</code> 。定期<code>@Component</code>使用此注释时不扫描bean。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@WebMvcTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您需要注册其他组件，例如Jackson <code>Module</code> ，您可以使用导入其他配置类<code>@Import</code>在测试中。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>经常， <code>@WebMvcTest</code>仅限于单个控制器，并与<code>@MockBean</code>为所需的协作者提供模拟实现。</p>
</div>
<div class="paragraph">
<p><code>@WebMvcTest</code>也可以自动配置<code>MockMvc</code> 。Mock MVC提供了一种强大的方法来快速测试MVC控制器，而无需启动完整的HTTP服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您也可以自动配置<code>MockMvc</code>在非<code>@WebMvcTest</code> （如<code>@SpringBootTest</code> ）加上<code>@AutoConfigureMockMvc</code> 。以下示例使用<code>MockMvc</code> ：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.web.servlet.*;
import org.springframework.boot.test.mock.mockito.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.BDDMockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(UserVehicleController.class)
class MyControllerTests {

    @Autowired
    private MockMvc mvc;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您需要配置自动配置的元素（例如，当应用Servlet过滤器时），则可以在<code>@AutoConfigureMockMvc</code>注解。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您使用HtmlUnit或Selenium，则自动配置还会提供一个HtmlUnit <code>WebClient</code> bean 和/或硒<code>WebDriver</code> bean 。以下示例使用HtmlUnit：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.gargoylesoftware.htmlunit.*;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.web.servlet.*;
import org.springframework.boot.test.mock.mockito.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.BDDMockito.*;

@WebMvcTest(UserVehicleController.class)
class MyHtmlUnitTests {

    @Autowired
    private WebClient webClient;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
        assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，Spring Boot放置<code>WebDriver</code> Bean放在特殊的“范围”中，以确保驱动程序在每次测试后退出并注入新实例。如果您不希望出现这种情况，则可以添加<code>@Scope("singleton")</code>给你<code>WebDriver</code><code>@Bean</code>定义。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">的<code>webDriver</code> Spring Boot创建的作用域将替换任何具有相同名称的用户定义的作用域。如果您定义自己的<code>webDriver</code>范围，您可能会发现它在使用时停止工作<code>@WebMvcTest</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您在类路径上具有Spring Security， <code>@WebMvcTest</code>也会扫描<code>WebSecurityConfigurer</code>beans。您可以使用Spring Security的测试支持，而不是完全禁用此类测试的安全性。有关如何使用Spring Security的更多详细信息<code>MockMvc</code>可以在此<em><a href="howto.html#howto-use-test-with-spring-security">howto.html操作</a></em>方法部分中找到支持。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有时编写Spring MVC测试是不够的。 Spring Boot可以帮助您在<a href="#boot-features-testing-spring-boot-applications-testing-with-running-server">实际服务器上</a>运行<a href="#boot-features-testing-spring-boot-applications-testing-with-running-server">完整的端到端测试</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests"></a> 25.3.13。自动配置的Spring WebFlux测试</h4>
<div class="paragraph">
<p>要测试<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference//web-reactive.html">Spring WebFlux</a>控制器是否按预期工作，可以使用<code>@WebFluxTest</code>注解。
<code>@WebFluxTest</code>自动配置Spring WebFlux基础架构并将扫描的Bean限制为<code>@Controller</code> ， <code>@ControllerAdvice</code> ， <code>@JsonComponent</code> ， <code>Converter</code> ， <code>GenericConverter</code> ， <code>WebFilter</code>和<code>WebFluxConfigurer</code> 。定期<code>@Component</code>当<code>@WebFluxTest</code>使用注释。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">启用的自动配置的列表<code>@WebFluxTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您需要注册其他组件，例如Jackson <code>Module</code> ，您可以使用导入其他配置类<code>@Import</code>在测试中。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>经常， <code>@WebFluxTest</code>仅限于单个控制器，并与<code>@MockBean</code>注释，以为所需的协作者提供模拟实现。</p>
</div>
<div class="paragraph">
<p><code>@WebFluxTest</code>也可以自动配置<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#webtestclient"><code>WebTestClient</code></a> ，它提供了一种强大的方法来快速测试WebFlux控制器，而无需启动完整的HTTP服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您也可以自动配置<code>WebTestClient</code>在非<code>@WebFluxTest</code> （如<code>@SpringBootTest</code> ）加上<code>@AutoConfigureWebTestClient</code> 。以下示例显示了同时使用<code>@WebFluxTest</code>和一个<code>WebTestClient</code> ：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.reactive.server.WebTestClient;

@WebFluxTest(UserVehicleController.class)
class MyControllerTests {

    @Autowired
    private WebTestClient webClient;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("Honda Civic");
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">WebFlux应用程序仅支持以下设置： <code>WebTestClient</code>在模拟的Web应用程序中，当前仅可与WebFlux一起使用。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@WebFluxTest</code>无法检测通过功能Web框架注册的路由。供测试用<code>RouterFunction</code>在上下文中，请考虑导入您的<code>RouterFunction</code>通过自己<code>@Import</code>或使用<code>@SpringBootTest</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@WebFluxTest</code>无法检测到通过以下方式注册的自定义安全配置<code>@Bean</code>类型的<code>SecurityWebFilterChain</code> 。要将其包括在测试中，您将需要导入通过以下方式注册Bean的配置： <code>@Import</code>或使用<code>@SpringBootTest</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有时编写Spring WebFlux测试是不够的。 Spring Boot可以帮助您在<a href="#boot-features-testing-spring-boot-applications-testing-with-running-server">实际服务器上</a>运行<a href="#boot-features-testing-spring-boot-applications-testing-with-running-server">完整的端到端测试</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test"></a> 25.3.14。自动配置的数据JPA测试</h4>
<div class="paragraph">
<p>您可以使用<code>@DataJpaTest</code>注释以测试JPA应用程序。默认情况下，它会扫描<code>@Entity</code>对Spring Data JPA存储库进行分类和配置。如果在类路径上有嵌入式数据库，它也会配置一个。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@DataJpaTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，数据JPA测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework参考文档》中的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">相关部分</a> 。如果这不是您想要的，则可以按以下方式禁用测试或整个类的事务管理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@DataJpaTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class ExampleNonTransactionalTests {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>数据JPA测试也可能注入<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java"><code>TestEntityManager</code></a> bean，它提供了标准JPA的替代方案<code>EntityManager</code>专为测试而设计。如果要使用<code>TestEntityManager</code>在外面<code>@DataJpaTest</code>实例，您还可以使用<code>@AutoConfigureTestEntityManager</code>注解。一种<code>JdbcTemplate</code>如果需要，也可以使用。以下示例显示了<code>@DataJpaTest</code>使用中的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.orm.jpa.*;

import static org.assertj.core.api.Assertions.*;

@DataJpaTest
class ExampleRepositoryTests {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private UserRepository repository;

    @Test
    void testExample() throws Exception {
        this.entityManager.persist(new User("sboot", "1234"));
        User user = this.repository.findByUsername("sboot");
        assertThat(user.getUsername()).isEqualTo("sboot");
        assertThat(user.getVin()).isEqualTo("1234");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>内存中嵌入式数据库通常运行良好，不需要任何安装，因此通常可以很好地用于测试。但是，如果您希望针对真实数据库运行测试，则可以使用<code>@AutoConfigureTestDatabase</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DataJpaTest
@AutoConfigureTestDatabase(replace=Replace.NONE)
class ExampleRepositoryTests {

    // ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test"></a> 25.3.15。自动配置的JDBC测试</h4>
<div class="paragraph">
<p><code>@JdbcTest</code>类似于<code>@DataJpaTest</code>但适用于只需要<code>DataSource</code>并且不要使用Spring Data JDBC。默认情况下，它配置一个内存嵌入式数据库和一个<code>JdbcTemplate</code> 。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">启用的自动配置的列表<code>@JdbcTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>缺省情况下，JDBC测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework参考文档》中的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">相关部分</a> 。如果这不是您想要的，则可以为测试或整个类禁用事务管理，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@JdbcTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class ExampleNonTransactionalTests {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您希望测试针对真实数据库运行，则可以使用<code>@AutoConfigureTestDatabase</code>注释的方式与<code>DataJpaTest</code> 。（请参阅“ <a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test">自动配置的数据JPA测试</a> ”。）</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-data-jdbc-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-data-jdbc-test"></a> 25.3.16。自动配置的数据JDBC测试</h4>
<div class="paragraph">
<p><code>@DataJdbcTest</code>类似于<code>@JdbcTest</code>但适用于使用Spring Data JDBC存储库的测试。默认情况下，它配置一个内存嵌入式数据库，一个<code>JdbcTemplate</code>和Spring Data JDBC存储库。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">启用的自动配置的列表<code>@DataJdbcTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，Data JDBC测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework参考文档》中的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">相关部分</a> 。如果这不是您想要的，则可以禁用测试或整个测试类的事务管理，如<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test">JDBC示例所示</a> 。</p>
</div>
<div class="paragraph">
<p>如果您希望测试针对真实数据库运行，则可以使用<code>@AutoConfigureTestDatabase</code>注释的方式与<code>DataJpaTest</code> 。（请参阅“ <a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test">自动配置的数据JPA测试</a> ”。）</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-jooq-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jooq-test"></a> 25.3.17。自动配置的jOOQ测试</h4>
<div class="paragraph">
<p>您可以使用<code>@JooqTest</code>以类似的方式<code>@JdbcTest</code>但适用于与jOOQ相关的测试。由于jOOQ严重依赖与数据库模式相对应的基于Java的模式，因此现有的<code>DataSource</code>用来。如果要用内存数据库替换它，可以使用<code>@AutoConfigureTestDatabase</code>覆盖这些设置。（有关将jOOQ与Spring Boot结合使用的更多信息，请参阅本章前面的“ <a href="#boot-features-jooq">使用jOOQ</a> ”。）定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">启用的自动配置的列表<code>@JooqTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>@JooqTest</code>配置一个<code>DSLContext</code> 。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。以下示例显示了<code>@JooqTest</code>使用中的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.jooq.DSLContext;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.autoconfigure.jooq.JooqTest;

@JooqTest
class ExampleJooqTests {

    @Autowired
    private DSLContext dslContext;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JOOQ测试是事务性的，默认情况下会在每个测试结束时回滚。如果这不是您想要的，则可以禁用测试或整个测试类的事务管理，如<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test">JDBC示例所示</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-mongo-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-mongo-test"></a> 25.3.18。自动配置的数据MongoDB测试</h4>
<div class="paragraph">
<p>您可以使用<code>@DataMongoTest</code>测试MongoDB应用程序。默认情况下，它配置内存嵌入式MongoDB（如果可用），配置一个<code>MongoTemplate</code> ，扫描<code>@Document</code>类，并配置Spring Data MongoDB存储库。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。（有关在Spring Boot中结合使用MongoDB的更多信息，请参阅本章前面的“ <a href="#boot-features-mongodb">MongoDB</a> ”。）</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@DataMongoTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下课程显示了<code>@DataMongoTest</code>使用中的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.data.mongodb.core.MongoTemplate;

@DataMongoTest
class ExampleDataMongoTests {

    @Autowired
    private MongoTemplate mongoTemplate;

    //
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>内存嵌入式MongoDB通常运行良好，不需要安装任何开发人员，因此通常可以很好地用于测试。但是，如果您希望对真实的MongoDB服务器运行测试，则应排除嵌入式MongoDB自动配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;

@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)
class ExampleDataMongoNonEmbeddedTests {

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test"></a> 25.3.19。自动配置的数据Neo4j测试</h4>
<div class="paragraph">
<p>您可以使用<code>@DataNeo4jTest</code>测试Neo4j应用程序。默认情况下，它使用内存嵌入式Neo4j（如果有嵌入式驱动程序可用）扫描<code>@NodeEntity</code>类，并配置Spring Data Neo4j存储库。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。（有关将Neo4J与Spring Boot结合使用的更多信息，请参阅本章前面的“ <a href="#boot-features-neo4j">Neo4j</a> ”。）</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@DataNeo4jTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了在Spring Boot中使用Neo4J测试的典型设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;

@DataNeo4jTest
class ExampleDataNeo4jTests {

    @Autowired
    private YourRepository repository;

    //
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Data Neo4j测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework参考文档》中的<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">相关部分</a> 。如果这不是您想要的，则可以为测试或整个类禁用事务管理，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@DataNeo4jTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class ExampleNonTransactionalTests {

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-redis-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-redis-test"></a> 25.3.20。自动配置的数据Redis测试</h4>
<div class="paragraph">
<p>您可以使用<code>@DataRedisTest</code>测试Redis应用程序。默认情况下，它会扫描<code>@RedisHash</code>对Spring Data Redis存储库进行分类和配置。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。（有关在Spring Boot中使用Redis的更多信息，请参阅本章前面的“ <a href="#boot-features-redis">Redis</a> ”。）</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@DataRedisTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@DataRedisTest</code>使用中的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;

@DataRedisTest
class ExampleDataRedisTests {

    @Autowired
    private YourRepository repository;

    //
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-ldap-test"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-ldap-test"></a> 25.3.21。自动配置的数据LDAP测试</h4>
<div class="paragraph">
<p>您可以使用<code>@DataLdapTest</code>测试LDAP应用程序。默认情况下，它配置内存嵌入式LDAP（如果可用），配置<code>LdapTemplate</code> ，扫描<code>@Entry</code>类，并配置Spring Data LDAP存储库。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。（有关将LDAP与Spring Boot结合使用的更多信息，请参阅本章前面的“ <a href="#boot-features-ldap">LDAP</a> ”。）</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@DataLdapTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了<code>@DataLdapTest</code>使用中的注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
import org.springframework.ldap.core.LdapTemplate;

@DataLdapTest
class ExampleDataLdapTests {

    @Autowired
    private LdapTemplate ldapTemplate;

    //
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>内存嵌入式LDAP通常非常适合测试，因为它速度快且不需要安装任何开发人员。但是，如果您希望针对真实的LDAP服务器运行测试，则应排除嵌入式LDAP自动配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;

@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
class ExampleDataLdapNonEmbeddedTests {

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-client"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-client"></a> 25.3.22。自动配置的REST客户端</h4>
<div class="paragraph">
<p>您可以使用<code>@RestClientTest</code>注释以测试REST客户端。默认情况下，它会自动配置Jackson，GSON和Jsonb支持，并配置<code>RestTemplateBuilder</code> ，并增加了对<code>MockRestServiceServer</code> 。定期<code>@Component</code> bean 未装入<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由...启用的自动配置设置的列表<code>@RestClientTest</code>可以<a href="appendix-test-auto-configuration.html#test-auto-configuration">在附录中找到</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您要测试的特定bean应该通过使用<code>value</code>要么<code>components</code>的属性<code>@RestClientTest</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestClientTest(RemoteVehicleDetailsService.class)
class ExampleRestClientTest {

    @Autowired
    private RemoteVehicleDetailsService service;

    @Autowired
    private MockRestServiceServer server;

    @Test
    void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails()
            throws Exception {
        this.server.expect(requestTo("/greet/details"))
                .andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
        String greeting = this.service.callRestService();
        assertThat(greeting).isEqualTo("hello");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs"></a> 25.3.23。自动配置的Spring REST Docs测试</h4>
<div class="paragraph">
<p>您可以使用<code>@AutoConfigureRestDocs</code>批注，以在Mock MVC，REST Assured或WebTestClient的测试中使用<a href="https://spring.io/projects/spring-restdocs">Spring REST Docs</a> 。它消除了Spring REST Docs中对JUnit扩展的需求。</p>
</div>
<div class="paragraph">
<p><code>@AutoConfigureRestDocs</code>可用于覆盖默认输出目录（ <code>target/generated-snippets</code>如果您使用的是Maven或<code>build/generated-snippets</code>如果您使用的是Gradle）。它也可以用于配置出现在任何记录的URI中的主机，方案和端口。</p>
</div>
<div class="sect4">
<h5 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-mock-mvc"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-mock-mvc"></a>使用Mock MVC自动配置的Spring REST Docs测试</h5>
<div class="paragraph">
<p><code>@AutoConfigureRestDocs</code>自定义<code>MockMvc</code> bean使用Spring REST Docs。您可以使用注入<code>@Autowired</code>并像通常使用Mock MVC和Spring REST Docs一样在测试中使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(UserController.class)
@AutoConfigureRestDocs
class UserDocumentationTests {

    @Autowired
    private MockMvc mvc;

    @Test
    void listUsers() throws Exception {
        this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk())
                .andDo(document("list-users"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要对Spring REST Docs配置的更多控制权，而不是<code>@AutoConfigureRestDocs</code> ，您可以使用<code>RestDocsMockMvcConfigurationCustomizer</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestConfiguration
static class CustomizationConfiguration
        implements RestDocsMockMvcConfigurationCustomizer {

    @Override
    public void customize(MockMvcRestDocumentationConfigurer configurer) {
        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想使用Spring REST Docs对参数化输出目录的支持，则可以创建一个<code>RestDocumentationResultHandler</code> bean 。自动配置调用<code>alwaysDo</code>与此结果处理程序，从而导致每个<code>MockMvc</code>调用以自动生成默认片段。以下示例显示了<code>RestDocumentationResultHandler</code>被定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestConfiguration(proxyBeanMethods = false)
static class ResultHandlerConfiguration {

    @Bean
    public RestDocumentationResultHandler restDocumentation() {
        return MockMvcRestDocumentation.document("{method-name}");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-web-test-client"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-web-test-client"></a>使用WebTestClient自动配置的Spring REST Docs测试</h5>
<div class="paragraph">
<p><code>@AutoConfigureRestDocs</code>也可以与<code>WebTestClient</code> 。您可以使用注入<code>@Autowired</code>并像平常一样在测试中使用它<code>@WebFluxTest</code>和Spring REST Docs，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.test.web.reactive.server.WebTestClient;

import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document;

@WebFluxTest
@AutoConfigureRestDocs
class UsersDocumentationTests {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    void listUsers() {
        this.webTestClient.get().uri("/").exchange().expectStatus().isOk().expectBody()
                .consumeWith(document("list-users"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要对Spring REST Docs配置的更多控制权，而不是<code>@AutoConfigureRestDocs</code> ，您可以使用<code>RestDocsWebTestClientConfigurationCustomizer</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestConfiguration(proxyBeanMethods = false)
public static class CustomizationConfiguration implements RestDocsWebTestClientConfigurationCustomizer {

    @Override
    public void customize(WebTestClientRestDocumentationConfigurer configurer) {
        configurer.snippets().withEncoding("UTF-8");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-rest-assured"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-rest-docs-rest-assured"></a>具有REST保证的自动配置的Spring REST文档测试</h5>
<div class="paragraph">
<p><code>@AutoConfigureRestDocs</code>使<code>RequestSpecification</code> Bean，已预先配置为使用Spring REST Docs，可用于测试。您可以使用注入<code>@Autowired</code>并像在使用REST Assured和Spring REST Docs时一样，在测试中使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.restassured.specification.RequestSpecification;
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.web.server.LocalServerPort;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.is;
import static org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureRestDocs
class UserDocumentationTests {

    @Test
    void listUsers(@Autowired RequestSpecification documentationSpec, @LocalServerPort int port) {
        given(documentationSpec).filter(document("list-users")).when().port(port).get("/").then().assertThat()
                .statusCode(is(200));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要对Spring REST Docs配置的更多控制权，而不是<code>@AutoConfigureRestDocs</code> ， 一种<code>RestDocsRestAssuredConfigurationCustomizer</code>可以使用bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestConfiguration(proxyBeanMethods = false)
public static class CustomizationConfiguration implements RestDocsRestAssuredConfigurationCustomizer {

    @Override
    public void customize(RestAssuredRestDocumentationConfigurer configurer) {
        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-auto-configured-additional-auto-config"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-auto-configured-additional-auto-config"></a> 25.3.24。额外的自动配置和切片</h4>
<div class="paragraph">
<p>每个切片提供一个或多个<code>@AutoConfigure…​</code>注释，即定义应包含在切片中的自动配置。可以通过创建自定义来添加其他自动配置<code>@AutoConfigure…​</code>注释或简单地通过添加<code>@ImportAutoConfiguration</code>如下例所示进行测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@JdbcTest
@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
class ExampleJdbcTests {

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">确保不使用常规<code>@Import</code>注释以导入自动配置，因为它们由Spring Boot以特定方式处理。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-testing-user-configuration"><a class="anchor" href="#boot-features-testing-spring-boot-applications-testing-user-configuration"></a> 25.3.25。用户配置和切片</h4>
<div class="paragraph">
<p>如果您以合理的方式<a href="#using-boot-structuring-your-code">构建代码</a> ，则您的<code>@SpringBootApplication</code> <a href="#boot-features-testing-spring-boot-applications-detecting-config">默认情况下</a> ， <a href="#boot-features-testing-spring-boot-applications-detecting-config">使用</a> class作为测试的配置。</p>
</div>
<div class="paragraph">
<p>因此，重要的是不要用特定于应用程序功能特定区域的配置设置来乱扔应用程序的主类。</p>
</div>
<div class="paragraph">
<p>假设您正在使用Spring Batch，并且依赖于它的自动配置。你可以定义你的<code>@SpringBootApplication</code>如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBatchProcessing
public class SampleApplication { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为此类是测试的源配置，所以任何切片测试实际上都尝试启动Spring Batch，这绝对不是您想要执行的操作。建议的方法是将特定于区域的配置移到单独的位置<code>@Configuration</code>类与您的应用程序处于同一级别，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableBatchProcessing
public class BatchConfiguration { ... }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">根据您应用程序的复杂性，您可能只有一个<code>@Configuration</code>您的自定义类别或每个域区域一个类别。使用后一种方法，您可以根据需要在其中一项测试中启用它， <code>@Import</code>注解。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>测试片排除<code>@Configuration</code>扫描中的类。例如，对于<code>@WebMvcTest</code> ，以下配置将不包含给定的<code>WebMvcConfigurer</code>测试切片加载的应用程序上下文中的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class WebConfiguration {
    @Bean
    public WebMvcConfigurer testConfigurer() {
        return new WebMvcConfigurer() {
            ...
        };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，以下配置将导致自定义<code>WebMvcConfigurer</code>由测试切片加载。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class TestWebMvcConfigurer implements WebMvcConfigurer {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>混乱的另一个来源是类路径扫描。假定在以合理的方式组织代码的同时，您需要扫描其他程序包。您的应用程序可能类似于以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@ComponentScan({ "com.example.app", "org.acme.another" })
public class SampleApplication { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做有效地覆盖了默认的组件扫描指令，并且具有扫描这两个软件包的副作用，而与您选择的切片无关。例如，一个<code>@DataJpaTest</code>似乎突然扫描了应用程序的组件和用户配置。同样，将自定义指令移至单独的类是解决此问题的好方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果这不是您的选择，则可以创建一个<code>@SpringBootConfiguration</code>测试层次结构中的某个位置，以便代替使用。或者，您可以为测试指定一个源，从而禁用查找默认源的行为。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-testing-spring-boot-applications-with-spock"><a class="anchor" href="#boot-features-testing-spring-boot-applications-with-spock"></a> 25.3.26。使用Spock测试Spring Boot应用程序</h4>
<div class="paragraph">
<p>如果您希望使用Spock来测试Spring Boot应用程序，则应添加对Spock的依赖<code>spock-spring</code>应用程序构建的模块。
<code>spock-spring</code>将Spring的测试框架集成到Spock中。建议您使用Spock 1.2或更高版本，以受益于Spock的Spring Framework 和Spring Boot集成的许多改进。有关更多详细信息，请参见<a href="http://spockframework.org/spock/docs/1.2/modules.html#_spring_module">Spock的Spring模块的文档</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-test-utilities"><a class="anchor" href="#boot-features-test-utilities"></a> 25.4。测试工具</h3>
<div class="paragraph">
<p>一些测试实用程序类通常在测试应用程序时有用，它们被打包为<code>spring-boot</code> 。</p>
</div>
<div class="sect3">
<h4 id="boot-features-configfileapplicationcontextinitializer-test-utility"><a class="anchor" href="#boot-features-configfileapplicationcontextinitializer-test-utility"></a> 25.4.1。ConfigFileApplicationContextInitializer</h4>
<div class="paragraph">
<p><code>ConfigFileApplicationContextInitializer</code>是一个<code>ApplicationContextInitializer</code>您可以将其应用于测试以加载Spring Boot <code>application.properties</code>文件。当您不需要以下功能时，可以使用它： <code>@SpringBootTest</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ContextConfiguration(classes = Config.class,
    initializers = ConfigFileApplicationContextInitializer.class)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用<code>ConfigFileApplicationContextInitializer</code>单独不提供支持<code>@Value("${…​}")</code>注射。它唯一的工作是确保<code>application.properties</code>文件被加载到Spring的<code>Environment</code> 。对于<code>@Value</code>支持，您需要另外配置一个<code>PropertySourcesPlaceholderConfigurer</code>或使用<code>@SpringBootTest</code> ，它会自动为您配置一个。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-test-property-values"><a class="anchor" href="#boot-features-test-property-values"></a> 25.4.2。TestPropertyValues</h4>
<div class="paragraph">
<p><code>TestPropertyValues</code>让您快速将属性添加到<code>ConfigurableEnvironment</code>要么<code>ConfigurableApplicationContext</code> 。你可以用<code>key=value</code>字符串，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TestPropertyValues.of("org=Spring", "name=Boot").applyTo(env);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-output-capture-test-utility"><a class="anchor" href="#boot-features-output-capture-test-utility"></a> 25.4.3。OutputCapture</h4>
<div class="paragraph">
<p><code>OutputCapture</code>是一个JUnit <code>Extension</code>你可以用来捕捉<code>System.out</code>和<code>System.err</code>输出。使用添加<code>@ExtendWith(OutputCaptureExtension.class)</code>并注入<code>CapturedOutput</code>作为测试类构造函数或测试方法的参数，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ExtendWith(OutputCaptureExtension.class)
class OutputCaptureTests {

    @Test
    void testName(CapturedOutput output) {
        System.out.println("Hello World!");
        assertThat(output).contains("World");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rest-templates-test-utility"><a class="anchor" href="#boot-features-rest-templates-test-utility"></a> 25.4.4。TestRestTemplate</h4>
<div class="paragraph">
<p><code>TestRestTemplate</code>是Spring的便捷替代品<code>RestTemplate</code>在集成测试中很有用。您可以使用普通模板或发送基本HTTP身份验证（带有用户名和密码）的模板。在这两种情况下，模板都不会通过在服务器端错误上引发异常来以易于测试的方式运行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Framework 5.0提供了新的<code>WebTestClient</code>适用于<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests">WebFlux集成测试</a>以及<a href="#boot-features-testing-spring-boot-applications-testing-with-running-server">WebFlux和MVC端到端测试</a> 。与断言不同，它为断言提供了流畅的API <code>TestRestTemplate</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>建议（但不是强制性的）使用Apache HTTP Client（版本4.3.2或更高版本）。如果您在课程路径上有该标签， <code>TestRestTemplate</code>通过适当配置客户端进行响应。如果确实使用Apache的HTTP客户端，则会启用一些其他易于测试的功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不遵循重定向（因此您可以声明响应位置）。</p>
</li>
<li>
<p>Cookies被忽略（因此模板是无状态的）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>TestRestTemplate</code>可以在集成测试中直接实例化，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyTest {

    private TestRestTemplate template = new TestRestTemplate();

    @Test
    public void testRequest() throws Exception {
        HttpHeaders headers = this.template.getForEntity(
                "https://myhost.example.com/example", String.class).getHeaders();
        assertThat(headers.getLocation()).hasHost("other.example.com");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果您使用<code>@SpringBootTest</code>带有注释<code>WebEnvironment.RANDOM_PORT</code>要么<code>WebEnvironment.DEFINED_PORT</code> ，您可以注入完全配置的<code>TestRestTemplate</code>并开始使用它。如有必要，可以通过<code>RestTemplateBuilder</code> bean 。未指定主机和端口的所有URL都会自动连接到嵌入式服务器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebClientTests {

    @Autowired
    private TestRestTemplate template;

    @Test
    void testRequest() {
        HttpHeaders headers = this.template.getForEntity("/example", String.class).getHeaders();
        assertThat(headers.getLocation()).hasHost("other.example.com");
    }

    @TestConfiguration(proxyBeanMethods = false)
    static class Config {

        @Bean
        RestTemplateBuilder restTemplateBuilder() {
            return new RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1))
                    .setReadTimeout(Duration.ofSeconds(1));
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-websockets"><a class="anchor" href="#boot-features-websockets"></a> 26Web套接字</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为嵌入式Tomcat，Jetty和Undertow提供了WebSockets自动配置。如果将war文件部署到独立容器，Spring Boot会假定该容器负责其WebSocket支持的配置。</p>
</div>
<div class="paragraph">
<p>Spring Framework为MVC Web应用程序提供了<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web.html#websocket">丰富的WebSocket支持</a> ，可以通过以下方式轻松访问该Web应用程序： <code>spring-boot-starter-websocket</code>模块。</p>
</div>
<div class="paragraph">
<p>WebSocket支持也可用于<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/web-reactive.html#webflux-websocket">响应式Web应用程序，</a>并且需要在旁边包含WebSocket API <code>spring-boot-starter-webflux</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;
    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-webservices"><a class="anchor" href="#boot-features-webservices"></a> 27。网页服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了Web服务自动配置，因此您所要做的就是定义您的<code>Endpoints</code> 。</p>
</div>
<div class="paragraph">
<p>可以使用以下命令轻松访问<a href="https://docs.spring.io/spring-ws/docs/3.0.8.RELEASE/reference/">Spring Web Services功能</a> <code>spring-boot-starter-webservices</code>模块。</p>
</div>
<div class="paragraph">
<p><code>SimpleWsdl11Definition</code>和<code>SimpleXsdSchema</code>可以分别为您的WSDL和XSD自动创建bean。为此，请配置其位置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.webservices.wsdl-locations=classpath:/wsdl</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webservices-template"><a class="anchor" href="#boot-features-webservices-template"></a> 27.1。使用调用Web服务<code>WebServiceTemplate</code></h3>
<div class="paragraph">
<p>如果您需要从应用程序中调用远程Web服务，则可以使用<a href="https://docs.spring.io/spring-ws/docs/3.0.8.RELEASE/reference/#client-web-service-template"><code>WebServiceTemplate</code></a>类。以来<code>WebServiceTemplate</code>实例在使用前通常需要自定义，Spring Boot不提供任何单个自动配置的<code>WebServiceTemplate</code> bean 。但是，它会自动配置<code>WebServiceTemplateBuilder</code> ，可用于创建<code>WebServiceTemplate</code>实例在需要时。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

    private final WebServiceTemplate webServiceTemplate;

    public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
        this.webServiceTemplate = webServiceTemplateBuilder.build();
    }

    public DetailsResp someWsCall(DetailsReq detailsReq) {
         return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认， <code>WebServiceTemplateBuilder</code>检测合适的基于HTTP的<code>WebServiceMessageSender</code>使用类路径上的可用HTTP客户端库。您还可以如下自定义读取和连接超时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
    return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
            .setConnectTimeout(5000).setReadTimeout(2000).build()).build();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-developing-auto-configuration"><a class="anchor" href="#boot-features-developing-auto-configuration"></a> 28岁创建自己的自动配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您在开发共享库的公司中工作，或者在开源或商业库中工作，则可能要开发自己的自动配置。自动配置类可以捆绑在外部jar中，并且仍由Spring Boot拾取。</p>
</div>
<div class="paragraph">
<p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用的典型库。我们首先介绍构建自己的自动配置所需的知识，然后继续<a href="#boot-features-custom-starter">进行创建自定义启动器所需</a>的<a href="#boot-features-custom-starter">典型步骤</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">可以使用一个<a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">演示项目</a>来展示如何逐步创建入门程序。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="boot-features-understanding-auto-configured-beans"><a class="anchor" href="#boot-features-understanding-auto-configured-beans"></a> 28.1。了解自动配置的Bean</h3>
<div class="paragraph">
<p>在后台，自动配置是通过标准实现的<code>@Configuration</code>类。额外<code>@Conditional</code>批注用于约束何时应应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>注释。这样可以确保仅当找到相关的类且未声明自己的类时，才应用自动配置<code>@Configuration</code> 。</p>
</div>
<div class="paragraph">
<p>您可以浏览的源代码<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a>看到<code>@Configuration</code> Spring提供的类（请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a>文件）。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-locating-auto-configuration-candidates"><a class="anchor" href="#boot-features-locating-auto-configuration-candidates"></a> 28.2。查找自动配置候选人</h3>
<div class="paragraph">
<p>Spring Boot检查是否存在<code>META-INF/spring.factories</code>文件在您发布的jar中。该文件应在“ <code>EnableAutoConfiguration</code>键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">自动配置<em>只能</em>以这种方式加载。确保它们在特定的程序包空间中定义，并且永远不会成为组件扫描的目标。此外，自动配置类不应启用组件扫描以查找其他组件。具体<code>@Import</code>应该使用s代替。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java"><code>@AutoConfigureAfter</code></a>要么<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java"><code>@AutoConfigureBefore</code></a>注释（如果需要按特定顺序应用您的配置）。例如，如果您提供特定于Web的配置，则可能需要在<code>WebMvcAutoConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>如果要订购某些相互之间不具有直接了解的自动配置，则也可以使用<code>@AutoConfigureOrder</code> 。该注释与常规注释具有相同的语义<code>@Order</code>注释，但为自动配置类提供了专用顺序。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-condition-annotations"><a class="anchor" href="#boot-features-condition-annotations"></a> 28.3。条件注释</h3>
<div class="paragraph">
<p>您几乎总是想包含一个或多个<code>@Conditional</code>自动配置类上的注释。的<code>@ConditionalOnMissingBean</code>注解是一个常见的示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含许多<code>@Conditional</code>您可以通过注释在您自己的代码中重复使用的注释<code>@Configuration</code>班级或个人<code>@Bean</code>方法。这些注释包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#boot-features-class-conditions">上课条件</a></p>
</li>
<li>
<p><a href="#boot-features-bean-conditions"> bean 条件</a></p>
</li>
<li>
<p><a href="#boot-features-property-conditions">物业条件</a></p>
</li>
<li>
<p><a href="#boot-features-resource-conditions">资源条件</a></p>
</li>
<li>
<p><a href="#boot-features-web-application-conditions">Web应用条件</a></p>
</li>
<li>
<p><a href="#boot-features-spel-conditions">SpEL表达条件</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="boot-features-class-conditions"><a class="anchor" href="#boot-features-class-conditions"></a> 28.3.1。上课条件</h4>
<div class="paragraph">
<p>的<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注释让<code>@Configuration</code>根据是否存在特定类来包括这些类。由于注释元数据是使用<a href="https://asm.ow2.org/">ASM</a>进行解析的，因此您可以使用<code>value</code>属性来引用真实的类，即使该类实际上可能未出现在正在运行的应用程序类路径上。您也可以使用<code>name</code>属性，如果您希望通过使用<code>String</code>值。</p>
</div>
<div class="paragraph">
<p>此机制不适用于<code>@Bean</code>通常以返回类型为条件目标的方法：在方法的条件适用之前，JVM将加载该类和可能经过处理的方法引用，如果该类不存在，则该引用将失败。</p>
</div>
<div class="paragraph">
<p>要处理这种情况，请单独<code>@Configuration</code>类可以用于隔离条件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
// Some conditions
public class MyAutoConfiguration {

    // Auto-configured beans

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(EmbeddedAcmeService.class)
    static class EmbeddedConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public EmbeddedAcmeService embeddedAcmeService() { ... }

    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您使用<code>@ConditionalOnClass</code>要么<code>@ConditionalOnMissingClass</code>作为元注释的一部分，以组成您自己的组合注释，您必须使用<code>name</code>因为在这种情况下不引用类。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-bean-conditions"><a class="anchor" href="#boot-features-bean-conditions"></a> 28.3.2。 bean 条件</h4>
<div class="paragraph">
<p>的<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>批注允许根据是否存在特定bean来包含bean。您可以使用<code>value</code>属性以按类型指定bean或<code>name</code>通过名称指定bean。的<code>search</code>属性可让您限制<code>ApplicationContext</code>搜索bean时应考虑的层次结构。</p>
</div>
<div class="paragraph">
<p>当放在一个<code>@Bean</code>方法，目标类型默认为方法的返回类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public MyService myService() { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>myService</code>如果没有类型的bean将被创建<code>MyService</code>已经包含在<code>ApplicationContext</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您需要非常注意添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容来评估的。因此，我们建议仅使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>自动配置类上的注释（因为保证在添加任何用户定义的Bean定义后会加载这些注释）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>不要阻止<code>@Configuration</code>类被创建。在课堂上使用这些条件并标记每个包含的条件之间的唯一区别<code>@Bean</code>带有注释的方法是前者阻止注册<code>@Configuration</code>如果条件不匹配，则将其作为Bean类。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-property-conditions"><a class="anchor" href="#boot-features-property-conditions"></a> 28.3.3。物业条件</h4>
<div class="paragraph">
<p>的<code>@ConditionalOnProperty</code>注释允许基于Spring Environment属性包含配置。使用<code>prefix</code>和<code>name</code>属性以指定应检查的属性。默认情况下，存在且不等于的任何属性<code>false</code>被匹配。您还可以通过使用<code>havingValue</code>和<code>matchIfMissing</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-resource-conditions"><a class="anchor" href="#boot-features-resource-conditions"></a> 28.3.4。资源条件</h4>
<div class="paragraph">
<p>的<code>@ConditionalOnResource</code>注释使配置仅在存在特定资源时才包括在内。可以使用通常的Spring约定来指定资源，如以下示例所示： <code>file:/home/user/test.dat</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-web-application-conditions"><a class="anchor" href="#boot-features-web-application-conditions"></a> 28.3.5。Web应用条件</h4>
<div class="paragraph">
<p>的<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>批注允许根据应用程序是否为“ Web应用程序”来包含配置。基于Servlet的Web应用程序是使用Spring的任何应用程序<code>WebApplicationContext</code>定义一个<code>session</code>范围，或具有<code>ConfigurableWebEnvironment</code> 。响应式Web应用程序是使用以下内容的任何应用程序： <code>ReactiveWebApplicationContext</code> ，或有一个<code>ConfigurableReactiveWebEnvironment</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spel-conditions"><a class="anchor" href="#boot-features-spel-conditions"></a> 28.3.6。SpEL表达条件</h4>
<div class="paragraph">
<p>的<code>@ConditionalOnExpression</code>注释使基于<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/core.html#expressions">SpEL表达式</a>的结果可以包含配置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-test-autoconfig"><a class="anchor" href="#boot-features-test-autoconfig"></a> 28.4。测试您的自动配置</h3>
<div class="paragraph">
<p>自动配置可能受许多因素影响：用户配置（ <code>@Bean</code>定义和<code>Environment</code>定制），条件评估（特定库的存在）等。具体来说，每个测试都应创建一个定义明确的<code>ApplicationContext</code>代表这些定制的组合。
<code>ApplicationContextRunner</code>提供了实现此目标的好方法。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContextRunner</code>通常定义为测试类的一个字段，以收集基本的通用配置。以下示例确保<code>UserServiceAutoConfiguration</code>总是被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果必须定义多个自动配置，则无需按与运行应用程序时完全相同的顺序调用它们的声明。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每个测试都可以使用运行器来表示特定的用例。例如，以下示例调用了一个用户配置（ <code>UserConfiguration</code> ），并检查自动配置是否正确退出。调用中<code>run</code>提供可以与<code>Assert4J</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void defaultServiceBacksOff() {
    this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context).getBean("myUserService").isSameAs(context.getBean(UserService.class));
    });
}

@Configuration(proxyBeanMethods = false)
static class UserConfiguration {

    @Bean
    UserService myUserService() {
        return new UserService("mine");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以轻松自定义<code>Environment</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void serviceNameCanBeConfigured() {
    this.contextRunner.withPropertyValues("user.name=test123").run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context.getBean(UserService.class).getName()).isEqualTo("test123");
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>跑步者也可以用来显示<code>ConditionEvaluationReport</code> 。该报告可以打印在<code>INFO</code>要么<code>DEBUG</code>水平。以下示例显示了如何使用<code>ConditionEvaluationReportLoggingListener</code>在自动配置测试中打印报告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void autoConfigTest {
    ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
            LogLevel.INFO);
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withInitializer(initializer).run((context) -&gt; {
                    // Do something...
            });
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="simulating-a-web-context"><a class="anchor" href="#simulating-a-web-context"></a> 28.4.1。模拟Web上下文</h4>
<div class="paragraph">
<p>如果您需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请使用<code>WebApplicationContextRunner</code>要么<code>ReactiveWebApplicationContextRunner</code>分别。</p>
</div>
</div>
<div class="sect3">
<h4 id="overriding-the-classpath"><a class="anchor" href="#overriding-the-classpath"></a> 28.4.2。覆盖类路径</h4>
<div class="paragraph">
<p>也可以测试在运行时不存在特定的类和/或程序包时发生的情况。Spring Boot随附一个<code>FilteredClassLoader</code>跑步者可以轻松使用。在以下示例中，我们断言<code>UserService</code>不存在时，将自动禁用自动配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
void serviceIsIgnoredIfLibraryIsNotPresent() {
    this.contextRunner.withClassLoader(new FilteredClassLoader(UserService.class))
            .run((context) -&gt; assertThat(context).doesNotHaveBean("userService"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-custom-starter"><a class="anchor" href="#boot-features-custom-starter"></a> 28.5。创建自己的入门</h3>
<div class="paragraph">
<p>库的完整Spring Boot入门程序可能包含以下组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>autoconfigure</code>包含自动配置代码的模块。</p>
</li>
<li>
<p>的<code>starter</code>提供对<code>autoconfigure</code>模块，库以及通常有用的任何其他依赖项。简而言之，添加启动程序应提供开始使用该库所需的一切。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果不需要将这两个问题分开，则可以将自动配置代码和依赖性管理结合在一个模块中。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-naming"><a class="anchor" href="#boot-features-custom-starter-naming"></a> 28.5.1。命名</h4>
<div class="paragraph">
<p>您应该确保为启动器提供适当的名称空间。请勿以以下名称开头模块名称<code>spring-boot</code> ，即使您使用其他Maven <code>groupId</code> 。将来，我们可能会为您自动配置的内容提供官方支持。</p>
</div>
<div class="paragraph">
<p>根据经验，您应该在启动器后命名一个组合模块。例如，假设您要为“ acme”创建启动器，并命名自动配置模块<code>acme-spring-boot-autoconfigure</code>和首发<code>acme-spring-boot-starter</code> 。如果只有一个模块将两者结合在一起，则将其命名<code>acme-spring-boot-starter</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-configuration-keys"><a class="anchor" href="#boot-features-custom-starter-configuration-keys"></a> 28.5.2。配置键</h4>
<div class="paragraph">
<p>如果您的入门者提供了配置密钥，请为其使用唯一的名称空间。特别是，不要在Spring Boot使用的名称空间中包含密钥（例如<code>server</code> ， <code>management</code> ， <code>spring</code> ， 等等）。如果使用相同的名称空间，将来我们可能会以破坏模块的方式修改这些名称空间。根据经验，所有键都应以您拥有的命名空间作为前缀（例如<code>acme</code> ）。</p>
</div>
<div class="paragraph">
<p>通过为每个属性添加字段javadoc来确保记录了配置键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    /**
     * Whether to check the location of acme resources.
     */
    private boolean checkLocation = true;

    /**
     * Timeout for establishing a connection to the acme server.
     */
    private Duration loginTimeout = Duration.ofSeconds(3);

    // getters &amp; setters

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您只应使用带有<code>@ConfigurationProperties</code>字段Javadoc，因为在将它们添加到JSON之前不会对其进行处理。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这是我们内部遵循的一些规则，以确保描述一致：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请勿以“ The”或“ A”开头描述。</p>
</li>
<li>
<p>对于<code>boolean</code>类型，请从“是否”或“启用”开始描述。</p>
</li>
<li>
<p>对于基于集合的类型，请以“以逗号分隔的列表”开始描述</p>
</li>
<li>
<p>使用<code>java.time.Duration</code>而不是<code>long</code>并描述默认单位（如果不同于毫秒），例如“如果未指定持续时间后缀，将使用秒”。</p>
</li>
<li>
<p>除非必须在运行时确定默认值，否则请不要在描述中提供默认值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保<a href="appendix-configuration-metadata.html#configuration-metadata-annotation-processor">触发元数据生成，</a>以便IDE协助也可用于您的密钥。您可能需要查看生成的元数据（ <code>META-INF/spring-configuration-metadata.json</code> ），以确保正确记录了您的密钥。在兼容的IDE中使用自己的启动程序也是验证元数据质量的好主意。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-module-autoconfigure"><a class="anchor" href="#boot-features-custom-starter-module-autoconfigure"></a> 28.5.3。 <code>autoconfigure</code> 模组</h4>
<div class="paragraph">
<p>的<code>autoconfigure</code>模块包含开始使用该库所需的所有内容。它还可能包含配置键定义（例如<code>@ConfigurationProperties</code> ）以及可用于进一步自定义组件初始化方式的任何回调接口。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您应该将对库的依赖项标记为可选，以便可以包括<code>autoconfigure</code>模块更容易地在您的项目中。如果这样做，则不提供该库，并且默认情况下，Spring Boot会后退。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Boot使用注释处理器在元数据文件中收集有关自动配置的条件（ <code>META-INF/spring-autoconfigure-metadata.properties</code> ）。如果存在该文件，它将用于过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.5及更早版本，相关性应在<code>compileOnly</code>配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Gradle 4.6及更高版本中，相关性应在<code>annotationProcessor</code>配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-module-starter"><a class="anchor" href="#boot-features-custom-starter-module-starter"></a> 28.5.4。启动模块</h4>
<div class="paragraph">
<p>起动器确实是一个空罐子。其唯一目的是提供必要的依赖关系以使用库。您可以将其视为对入门所需的看法。</p>
</div>
<div class="paragraph">
<p>不要对添加了启动器的项目做任何假设。如果您要自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的<em>默认</em>依赖项可能会很困难，因为您应避免包括对于库的典型用法而言不必要的依赖项。换句话说，您不应包括可选的依赖项。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">无论哪种方式，您的入门者都必须引用核心Spring Boot入门者（ <code>spring-boot-starter</code> ）直接或间接（例如，如果您的入门者依赖于另一个入门者，则无需添加它）。如果仅使用您的自定义启动程序创建项目，则通过使用核心启动程序来兑现Spring Boot的核心功能。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-kotlin"><a class="anchor" href="#boot-features-kotlin"></a> 29。Kotlin支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a>是针对JVM（和其他平台）的静态类型的语言，它允许编写简洁明了的代码，同时提供与用Java编写的现有库的<a href="https://kotlinlang.org/docs/reference/java-interop.html">互操作性</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Boot通过利用其他Spring项目（如Spring Framework，Spring Data和Reactor）中的支持来提供Kotlin支持。有关更多信息，请参见<a href="https://docs.spring.io/spring/docs/5.2.1.RELEASE/spring-framework-reference/languages.html#kotlin">Spring Framework Kotlin支持文档</a> 。</p>
</div>
<div class="paragraph">
<p>开始使用Spring Boot和Kotlin的最简单方法是遵循<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">此综合教程</a> 。您可以通过<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>创建新的Kotlin项目。随时加入<a href="https://slack.kotlinlang.org/">Kotlin Slack</a>的#spring频道，或与<code>spring</code>和<code>kotlin</code>如果需要支持，请在<a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stack Overflow</a>上添加标签。</p>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-requirements"><a class="anchor" href="#boot-features-kotlin-requirements"></a> 29.1。要求</h3>
<div class="paragraph">
<p>Spring Boot支持Kotlin1.3.x。要使用Kotlin， <code>org.jetbrains.kotlin:kotlin-stdlib</code>和<code>org.jetbrains.kotlin:kotlin-reflect</code>必须存在于类路径中。的<code>kotlin-stdlib</code>变体<code>kotlin-stdlib-jdk7</code>和<code>kotlin-stdlib-jdk8</code>也可以使用。</p>
</div>
<div class="paragraph">
<p>由于<a href="https://discuss.kotlinlang.org/t/classes-final-by-default/166">默认情况下Kotlin类是final类</a> ，因此您可能需要配置<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support">kotlin-spring</a>插件，以便自动打开<a href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support">带有</a> Spring注释的类，以便对其进行代理。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/FasterXML/jackson-module-kotlin">在Kotlin</a>中序列化/反序列化JSON数据时，需要<a href="https://github.com/FasterXML/jackson-module-kotlin">Jackson的Kotlin模块</a> 。在类路径上找到它会自动注册。如果存在Jackson和Kotlin但不存在Jackson Kotlin模块，则会记录一条警告消息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果在<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>上引导Kotlin项目， <a href="https://start.spring.io/#!language=kotlin">则</a>默认情况下会提供这些依赖项和插件。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-null-safety"><a class="anchor" href="#boot-features-kotlin-null-safety"></a> 29.2。Null-safety</h3>
<div class="paragraph">
<p>Kotlin的主要功能之一是<a href="https://kotlinlang.org/docs/reference/null-safety.html">null安全</a> 。它处理<code>null</code>值在编译时而不是将问题推迟到运行时并遇到<code>NullPointerException</code> 。这有助于消除常见的bug来源，而无需支付包装费用，例如<code>Optional</code> 。Kotlin还允许使用具有可为空值的函数构造，如本<a href="https://www.baeldung.com/kotlin-null-safety">Kotlin中关于null安全的全面指南中所述</a> 。</p>
</div>
<div class="paragraph">
<p>尽管Java不允许人在其类型系统中表示空安全性，但Spring Framework，Spring Data和Reactor现在通过易于使用工具的批注为API提供空安全性。默认情况下，将Kotlin中使用的Java API中的<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">类型</a>识别为放松了空检查的<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">平台类型</a> 。
<a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">Kotlin对JSR 305批注的支持</a>与可空性<a href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">批注</a>相结合，为Kotlin中的相关Spring API提供了空安全性。</p>
</div>
<div class="paragraph">
<p>可以通过添加以下内容来配置JSR 305检查： <code>-Xjsr305</code>具有以下选项的编译器标志： <code>-Xjsr305={strict|warn|ignore}</code> 。默认行为与<code>-Xjsr305=warn</code> 。的<code>strict</code>从Spring API推断得出的Kotlin类型中，必须考虑到值的null-safety，但应该使用此值，但要知道Spring API nullability声明即使在次要发行版之间也会发生演变，并且将来可能会添加更多检查）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">尚不支持泛型类型参数，varargs和数组元素的可空性。有关最新信息，请参见<a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a> 。另外请注意，Spring Boot自己的API <a href="https://github.com/spring-projects/spring-boot/issues/10712">尚未被注释</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-api"><a class="anchor" href="#boot-features-kotlin-api"></a> 29.3。Kotlin API</h3>
<div class="sect3">
<h4 id="boot-features-kotlin-api-runapplication"><a class="anchor" href="#boot-features-kotlin-api-runapplication"></a> 29.3.1。 runApplication</h4>
<div class="paragraph">
<p>Spring Boot提供了一种惯用的方式来运行带有<code>runApplication<MyApplication>(*args)</code>如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class MyApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;MyApplication&gt;(*args)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是的替代品<code>SpringApplication.run(MyApplication::class.java, *args)</code> 。它还允许自定义应用程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">runApplication&lt;MyApplication&gt;(*args) {
    setBannerMode(OFF)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kotlin-api-extensions"><a class="anchor" href="#boot-features-kotlin-api-extensions"></a> 29.3.2。扩展名</h4>
<div class="paragraph">
<p>Kotlin <a href="https://kotlinlang.org/docs/reference/extensions.html">扩展</a>提供了使用其他功能扩展现有类的功能。Spring Boot Kotlin API利用这些扩展为现有的API添加了新的Kotlin特定的便利。</p>
</div>
<div class="paragraph">
<p><code>TestRestTemplate</code>扩展，类似于Spring Framework为<code>RestOperations</code>在Spring Framework中提供。除其他外，这些扩展使利用Kotlin修饰类型参数成为可能。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-dependency-management"><a class="anchor" href="#boot-features-kotlin-dependency-management"></a> 29.4。依赖管理</h3>
<div class="paragraph">
<p>为了避免在类路径中混合使用不同版本的Kotlin依赖项，Spring Boot会导入Kotlin BOM。</p>
</div>
<div class="paragraph">
<p>使用Maven，可以通过以下方式自定义Kotlin版本： <code>kotlin.version</code>提供了属性和插件管理<code>kotlin-maven-plugin</code> 。使用Gradle，Spring Boot插件会自动对齐<code>kotlin.version</code>使用Kotlin插件的版本。</p>
</div>
<div class="paragraph">
<p>Spring Boot还通过导入Kotlin Coroutines BOM管理Coroutines依赖项的版本。该版本可以通过<code>kotlin-coroutines.version</code>属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>org.jetbrains.kotlinx:kotlinx-coroutines-reactor</code>如果一个引导程序对<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>至少有一个反应依赖项的Kotlin项目，则默认提供依赖<a href="https://start.spring.io/#!language=kotlin">项</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-configuration-properties"><a class="anchor" href="#boot-features-kotlin-configuration-properties"></a> 29.5。<code>@ConfigurationProperties</code></h3>
<div class="paragraph">
<p><code>@ConfigurationProperties</code>当与<a href="#boot-features-external-config-constructor-binding"><code>@ConstructorBinding</code></a>支持不可变的类<code>val</code>属性如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ConstructorBinding
@ConfigurationProperties("example.kotlin")
data class KotlinExampleProperties(
        val name: String,
        val description: String,
        val myService: MyService) {

    data class MyService(
            val apiToken: String,
            val uri: URI
    )
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">要使用注释处理器生成<a href="appendix-configuration-metadata.html#configuration-metadata-annotation-processor">自己的元数据</a> ， <a href="https://kotlinlang.org/docs/reference/kapt.html"><code>kapt</code>应该配置</a> <code>spring-boot-configuration-processor</code>依赖性。请注意，由于kapt提供的模型的限制，某些功能（例如检测默认值或不推荐使用的项目）无法正常工作。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-testing"><a class="anchor" href="#boot-features-kotlin-testing"></a> 29.6。测试中</h3>
<div class="paragraph">
<p>虽然可以使用JUnit 4测试Kotlin代码，但默认情况下建议使用JUnit 5。JUnit 5使测试类可以实例化一次，并可以在该类的所有测试中重新使用。这样就可以使用<code>@BeforeClass</code>和<code>@AfterClass</code>非静态方法的注释，非常适合Kotlin。</p>
</div>
<div class="paragraph">
<p>JUnit 5是默认的，并且提供了vintage引擎是为了与JUnit 4向后兼容。如果您不使用它，则排除<code>org.junit.vintange:junit-vintage-engine</code> 。您还需要将<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle-changing-default">测试实例生命周期切换为“ per-class”</a> 。</p>
</div>
<div class="paragraph">
<p>要模拟Kotlin类，建议使用<a href="https://mockk.io/">MockK</a> 。如果您需要<code>Mockk</code>等同于Mockito <a href="#boot-features-testing-spring-boot-applications-mocking-beans"><code>@MockBean</code>和<code>@SpyBean</code>注解</a> ，您可以使用<a href="https://github.com/Ninja-Squad/springmockk">SpringMockK</a>提供类似<code>@MockkBean</code>和<code>@SpykBean</code>注释。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kotlin-resources"><a class="anchor" href="#boot-features-kotlin-resources"></a> 29.7。资源资源</h3>
<div class="sect3">
<h4 id="boot-features-kotlin-resources-further-reading"><a class="anchor" href="#boot-features-kotlin-resources-further-reading"></a> 29.7.1。进一步阅读</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/reference/">Kotlin语言参考</a></p>
</li>
<li>
<p><a href="https://slack.kotlinlang.org/">Kotlin Slack</a> （带有专用的#spring频道）</p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stackoverflow与<code>spring</code>和<code>kotlin</code>标签</a></p>
</li>
<li>
<p><a href="https://try.kotlinlang.org/">在浏览器中尝试Kotlin</a></p>
</li>
<li>
<p><a href="https://blog.jetbrains.com/kotlin/">Kotlin博客</a></p>
</li>
<li>
<p><a href="https://kotlin.link/">很棒的Kotlin</a></p>
</li>
<li>
<p><a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">教程：使用Spring Boot和Kotlin构建Web应用程序</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">使用Kotlin开发Spring Boot应用程序</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql">带有Kotlin，Spring Boot和PostgreSQL的地理空间Messenger</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">在Spring Framework 5.0中引入Kotlin支持</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way">Spring Framework 5 Kotlin API的功能方式</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kotlin-resources-examples"><a class="anchor" href="#boot-features-kotlin-resources-examples"></a> 29.7.2。例子</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a> ：常规Spring Boot + Spring Data JPA项目</p>
</li>
<li>
<p><a href="https://github.com/mixitconf/mixit">mixit</a> ：Spring Boot 2 + WebFlux +响应式Spring Data MongoDB</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-fullstack">spring-kotlin-fullstack</a> ：WebFlux Kotlin完整示例，其中Kotlin2js用于前端，而不是JavaScript或TypeScript</p>
</li>
<li>
<p><a href="https://github.com/spring-petclinic/spring-petclinic-kotlin">spring-petclinic-kotlin</a> ：Spring PetClinic示例应用程序的Kotlin版本</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-kotlin-deepdive">spring-kotlin-deepdive</a> ：从Boot 1.0 + Java到Boot 2.0 + Kotlin的逐步迁移</p>
</li>
<li>
<p><a href="https://github.com/sdeleuze/spring-boot-coroutines-demo">spring-boot-coroutines-demo</a> ： <a href="https://github.com/sdeleuze/spring-boot-coroutines-demo">协程</a>示例项目</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-whats-next"><a class="anchor" href="#boot-features-whats-next"></a> 30岁接下来要读什么</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您想了解有关本节中讨论的任何类的更多信息，可以查看<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api/">Spring Boot API文档</a>或<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE">直接</a>浏览<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE">源代码</a> 。如果您有特定问题，请查看<a href="howto.html#howto">操作方法</a>部分。</p>
</div>
<div class="paragraph">
<p>如果您熟悉Spring Boot的核心功能，则可以继续阅读有关<a href="production-ready-features.html#production-ready">准备就绪的功能的信息</a> 。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-11-06 21:59:20 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>