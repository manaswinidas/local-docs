<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>部署Spring Boot应用程序</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head><body id="deployment" class="book toc2 toc-left" ><div id="header">
<h1>部署Spring Boot应用程序</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#containers-deployment">1。部署到容器</a></li>
<li><a href="#cloud-deployment">2。部署到云端</a>
<ul class="sectlevel2">
<li><a href="#cloud-deployment-cloud-foundry">2.1。云铸造</a>
<ul class="sectlevel3">
<li><a href="#cloud-deployment-cloud-foundry-services">2.1.1。绑定服务</a></li>
</ul>
</li>
<li><a href="#cloud-deployment-heroku">2.2。Heroku</a></li>
<li><a href="#cloud-deployment-openshift">2.3。OpenShift</a></li>
<li><a href="#cloud-deployment-aws">2.4。亚马逊网络服务（AWS）</a>
<ul class="sectlevel3">
<li><a href="#aws-elastic-beanstalk">2.4.1。AWS Elastic Beanstalk</a>
<ul class="sectlevel4">
<li><a href="#using-the-tomcat-platform">使用Tomcat平台</a></li>
<li><a href="#using-the-java-se-platform">使用Java SE平台</a></li>
</ul>
</li>
<li><a href="#summary">2.4.2。摘要</a></li>
</ul>
</li>
<li><a href="#cloud-deployment-boxfuse">2.5。Boxfuse和Amazon Web Services</a></li>
<li><a href="#cloud-deployment-gae">2.6。谷歌云</a></li>
</ul>
</li>
<li><a href="#deployment-install">3。安装Spring Boot应用程序</a>
<ul class="sectlevel2">
<li><a href="#deployment-install-supported-operating-systems">3.1。支持的操作系统</a></li>
<li><a href="#deployment-service">3.2。Unix / Linux服务</a>
<ul class="sectlevel3">
<li><a href="#deployment-initd-service">3.2.1。作为一个安装<code>init.d</code>服务（系统V）</a>
<ul class="sectlevel4">
<li><a href="#deployment-initd-service-securing">确保<code>init.d</code>服务</a></li>
</ul>
</li>
<li><a href="#deployment-systemd-service">3.2.2。作为一个安装<code>systemd</code>服务</a></li>
<li><a href="#deployment-script-customization">3.2.3。自定义启动脚本</a>
<ul class="sectlevel4">
<li><a href="#deployment-script-customization-when-it-written">编写后自定义启动脚本</a></li>
<li><a href="#deployment-script-customization-when-it-runs">运行时自定义脚本</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#deployment-windows">3.3。Microsoft Windows服务</a></li>
</ul>
</li>
<li><a href="#deployment-whats-next">4。接下来要读什么</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>在部署应用程序时，Spring Boot的灵活打包选项提供了很多选择。您可以将Spring Boot应用程序部署到各种云平台，容器映像（例如Docker）或虚拟机/真实机上。</p>
</div>
<div class="paragraph">
<p>本节介绍一些更常见的部署方案。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="containers-deployment"><a class="anchor" href="#containers-deployment"></a> 1。部署到容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果从容器运行应用程序，则可以使用可执行jar，但是将其爆炸并以其他方式运行通常也是一个优点。某些PaaS实施也可能选择在运行存档之前将其解压缩。例如，Cloud Foundry以这种方式运行。运行解压缩存档的最简单方法是启动相应的启动器，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ jar -xf myapp.jar
$ java org.springframework.boot.loader.JarLauncher</pre>
</div>
</div>
<div class="paragraph">
<p>实际上，这在启动时（取决于jar的大小）比从未爆炸的存档中运行要快一些。在运行时，您不应期望任何差异。</p>
</div>
<div class="paragraph">
<p>解压缩jar文件后，您还可以通过使用其“自然”主方法（而不是主方法）运行应用程序来增加启动时间<code>JarLauncher</code> 。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ jar -xf myapp.jar
$ java -cp BOOT-INF/classes:BOOT-INF/lib/* com.example.MyApplication</pre>
</div>
</div>
<div class="paragraph">
<p>还可以通过将依赖项作为与应用程序类和资源（通常会更频繁地更改）分开的一层复制到映像中来创建更有效的容器映像。实现这一层分离的方法不止一种。例如，使用<code>Dockerfile</code>您可以用这种形式表示它（假设罐子已经在包装箱中打开了<code>target/dependency</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=target/dependency
COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY ${DEPENDENCY}/META-INF /app/META-INF
COPY ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","com.example.MyApplication"]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cloud-deployment"><a class="anchor" href="#cloud-deployment"></a> 2。部署到云端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot的可执行jar已为大多数流行的云PaaS（平台即服务）提供程序准备就绪。这些提供程序往往要求您“自带容器”。他们管理应用程序流程（不是专门用于Java应用程序），因此他们需要一个中间层，以使<em>您的</em>应用程序适应<em>云</em>中正在运行的流程<em>的</em>概念。</p>
</div>
<div class="paragraph">
<p>两家受欢迎的云提供商，Heroku和Cloud Foundry，采用了“ buildpack”方法。buildpack将部署的代码包装在<em>启动</em>应用程序所需的任何内容中。可能是一个JDK和一个对<code>java</code> ，嵌入式Web服务器或成熟的应用程序服务器。一个buildpack是可插入的，但是理想情况下，您应该能够通过尽可能少的自定义来获得它。这减少了您无法控制的功能的占用空间。它使开发和生产环境之间的差异最小化。</p>
</div>
<div class="paragraph">
<p>理想情况下，您的应用程序像Spring Boot可执行jar一样，具有打包运行所需的一切。</p>
</div>
<div class="paragraph">
<p>在本节中，我们研究如何启动在“入门”部分中<a href="getting-started.html#getting-started-first-application">开发</a>的<a href="getting-started.html#getting-started-first-application">简单应用程序</a>并在云中运行。</p>
</div>
<div class="sect2">
<h3 id="cloud-deployment-cloud-foundry"><a class="anchor" href="#cloud-deployment-cloud-foundry"></a> 2.1。云铸造</h3>
<div class="paragraph">
<p>如果未指定其他构建包，Cloud Foundry将提供默认的构建包。Cloud Foundry <a href="https://github.com/cloudfoundry/java-buildpack">Java buildpack</a>对Spring应用程序（包括Spring Boot）提供了出色的支持。您可以部署独立的可执行jar应用程序以及传统的<code>.war</code>打包的应用程序。</p>
</div>
<div class="paragraph">
<p>构建应用程序后（例如，通过使用<code>mvn clean package</code> ）并已<a href="https://docs.cloudfoundry.org/cf-cli/install-go-cli.html">安装<code>cf</code>命令行工具</a> ，通过使用<code>cf push</code>命令，替换您已编译的路径<code>.jar</code> 。确保已<a href="https://docs.cloudfoundry.org/cf-cli/getting-started.html#login">使用您的帐户登录<code>cf</code>命令行客户端，</a>然后再推送应用程序。以下行显示了使用<code>cf push</code>部署应用程序的命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在前面的示例中，我们用<code>acloudyspringtime</code>无论你给什么价值<code>cf</code>作为您的应用程序的名称。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>见<a href="https://docs.cloudfoundry.org/cf-cli/getting-started.html#push"><code>cf push</code></a>有关更多选项的<a href="https://docs.cloudfoundry.org/cf-cli/getting-started.html#push">文档</a> 。如果有Cloud Foundry <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html"><code>manifest.yml</code></a>文件存在于同一目录中，将被考虑。</p>
</div>
<div class="paragraph">
<p>这一点， <code>cf</code>开始上传您的应用程序，产生类似于以下示例的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Uploading acloudyspringtime... <strong>OK</strong>
Preparing to start acloudyspringtime... <strong>OK</strong>
-----&gt; Downloaded app package (<strong>8.9M</strong>)
-----&gt; Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e
-----&gt; Downloading Open Jdk JRE 1.8.0_121 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_121.tar.gz (found in cache)
       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)
-----&gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)
       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K
-----&gt; Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found in cache)
       Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s)
-----&gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)
Checking status of app 'acloudyspringtime'...
  0 of 1 instances running (1 starting)
  ...
  0 of 1 instances running (1 starting)
  ...
  0 of 1 instances running (1 starting)
  ...
  1 of 1 instances running (1 running)

App started</pre>
</div>
</div>
<div class="paragraph">
<p>恭喜你！该应用程序现已上线！</p>
</div>
<div class="paragraph">
<p>应用程序上线后，您可以使用以下命令验证已部署应用程序的状态： <code>cf apps</code>命令，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cf apps
Getting applications in ...
OK

name                 requested state   instances   memory   disk   urls
...
acloudyspringtime    started           1/1         512M     1G     acloudyspringtime.cfapps.io
...</pre>
</div>
</div>
<div class="paragraph">
<p>一旦Cloud Foundry确认已部署了您的应用程序，您就应该能够在给定的URI上找到该应用程序。在前面的示例中，您可以在以下位置找到它<code>https://acloudyspringtime.cfapps.io/</code> 。</p>
</div>
<div class="sect3">
<h4 id="cloud-deployment-cloud-foundry-services"><a class="anchor" href="#cloud-deployment-cloud-foundry-services"></a> 2.1.1。绑定服务</h4>
<div class="paragraph">
<p>默认情况下，有关正在运行的应用程序以及服务连接信息的元数据作为环境变量向应用程序公开（例如： <code>$VCAP_SERVICES</code> ）。该架构决定是由于Cloud Foundry的多语言（可以将任何语言和平台支持为buildpack）所决定的。过程范围的环境变量与语言无关。</p>
</div>
<div class="paragraph">
<p>环境变量并非总是使用最简单的API，因此Spring Boot会自动提取它们并将数据展平为可通过Spring的属性访问的属性。 <code>Environment</code>抽象，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
class MyBean implements EnvironmentAware {

    private String instanceId;

    @Override
    public void setEnvironment(Environment environment) {
        this.instanceId = environment.getProperty("vcap.application.instance_id");
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有Cloud Foundry属性均以前缀<code>vcap</code> 。您可以使用<code>vcap</code>属性来访问应用程序信息（例如应用程序的公共URL）和服务信息（例如数据库凭据）。有关完整的详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html">“ CloudFoundryVcapEnvironmentPostProcessor”</a> Javadoc。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content"><a href="https://github.com/pivotal-cf/java-cfenv/">Java CFEnv</a>项目更适合诸如配置数据源之类的任务。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cloud-deployment-heroku"><a class="anchor" href="#cloud-deployment-heroku"></a> 2.2。Heroku</h3>
<div class="paragraph">
<p>Heroku是另一个流行的PaaS平台。要自定义Heroku版本，您需要提供一个<code>Procfile</code> ，它提供了部署应用程序所需的内容。Heroku分配了一个<code>port</code>供Java应用程序使用，然后确保可以路由到外部URI。</p>
</div>
<div class="paragraph">
<p>您必须配置您的应用程序以侦听正确的端口。以下示例显示了<code>Procfile</code>对于我们的入门REST应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot使<code>-D</code>可作为可从Spring访问的属性的参数<code>Environment</code>实例。的<code>server.port</code>配置属性将馈送到嵌入式Tomcat，Jetty或Undertow实例，然后在启动时使用该端口。的<code>$PORT</code>环境变量是由Heroku PaaS分配给我们的。</p>
</div>
<div class="paragraph">
<p>这应该是您需要的一切。Heroku部署最常见的部署工作流程是<code>git push</code>生产代码，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git push heroku master

Initializing repository, <strong>done</strong>.
Counting objects: 95, <strong>done</strong>.
Delta compression using up to 8 threads.
Compressing objects: 100% (78/78), <strong>done</strong>.
Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, <strong>done</strong>.
Total 95 (delta 31), reused 0 (delta 0)

-----&gt; Java app detected
-----&gt; Installing OpenJDK 1.8... <strong>done</strong>
-----&gt; Installing Maven 3.3.1... <strong>done</strong>
-----&gt; Installing settings.xml... <strong>done</strong>
-----&gt; Executing: mvn -B -DskipTests=true clean install

       [INFO] Scanning for projects...
       Downloading: https://repo.spring.io/...
       Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)
        ....
       Downloaded: https://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)
       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...
       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...
       [INFO] ------------------------------------------------------------------------
       [INFO] <strong>BUILD SUCCESS</strong>
       [INFO] ------------------------------------------------------------------------
       [INFO] Total time: 59.358s
       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014
       [INFO] Final Memory: 20M/493M
       [INFO] ------------------------------------------------------------------------

-----&gt; Discovering process types
       Procfile declares types -&gt; <strong>web</strong>

-----&gt; Compressing... <strong>done</strong>, 70.4MB
-----&gt; Launching... <strong>done</strong>, v6
       https://agile-sierra-1405.herokuapp.com/ <strong>deployed to Heroku</strong>

To git@heroku.com:agile-sierra-1405.git
 * [new branch]      master -&gt; master</pre>
</div>
</div>
<div class="paragraph">
<p>您的应用程序现在应该已经在Heroku上启动并运行了。有关更多详细信息，请参阅将<a href="https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku">Spring Boot应用程序部署到Heroku</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="cloud-deployment-openshift"><a class="anchor" href="#cloud-deployment-openshift"></a> 2.3。OpenShift</h3>
<div class="paragraph">
<p><a href="https://www.openshift.com/">OpenShift</a>是Kubernetes容器编排平台的Red Hat公共（和企业）扩展。与Kubernetes相似，OpenShift具有许多用于安装基于Spring Boot的应用程序的选项。</p>
</div>
<div class="paragraph">
<p>OpenShift提供了许多资源来描述如何部署Spring Boot应用程序，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/">使用S2I构建器</a></p>
</li>
<li>
<p><a href="https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/">建筑指南</a></p>
</li>
<li>
<p><a href="https://blog.openshift.com/using-spring-boot-on-openshift/">在Wildfly上作为传统的Web应用程序运行</a></p>
</li>
<li>
<p><a href="https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/">OpenShift公共简报</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="cloud-deployment-aws"><a class="anchor" href="#cloud-deployment-aws"></a> 2.4。亚马逊网络服务（AWS）</h3>
<div class="paragraph">
<p>Amazon Web Services提供了多种方式来安装基于Spring Boot的应用程序，既可以作为传统的Web应用程序（war），也可以作为具有嵌入式Web服务器的可执行jar文件安装。选项包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AWS Elastic Beanstalk</p>
</li>
<li>
<p>AWS Code Deploy</p>
</li>
<li>
<p>AWS OPS作品</p>
</li>
<li>
<p>AWS云形成</p>
</li>
<li>
<p>AWS容器注册表</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个都有不同的功能和定价模型。在本文档中，我们仅描述最简单的选项：AWS Elastic Beanstalk。</p>
</div>
<div class="sect3">
<h4 id="aws-elastic-beanstalk"><a class="anchor" href="#aws-elastic-beanstalk"></a> 2.4.1。AWS Elastic Beanstalk</h4>
<div class="paragraph">
<p>如官方<a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html">Elastic Beanstalk Java指南中所述</a> ，部署Java应用程序有两个主要选项。您可以使用“ Tomcat平台”或“ Java SE平台”。</p>
</div>
<div class="sect4">
<h5 id="using-the-tomcat-platform"><a class="anchor" href="#using-the-tomcat-platform"></a>使用Tomcat平台</h5>
<div class="paragraph">
<p>该选项适用于产生war文件的Spring Boot项目。无需特殊配置。您只需要遵循官方指南即可。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-the-java-se-platform"><a class="anchor" href="#using-the-java-se-platform"></a>使用Java SE平台</h5>
<div class="paragraph">
<p>此选项适用于产生jar文件并运行嵌入式Web容器的Spring Boot项目。Elastic Beanstalk环境在端口80上运行nginx实例，以代理在端口5000上运行的实际应用程序。要对其进行配置，请将以下行添加到您的<code>application.properties</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>server.port=5000</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">上传二进制文件而不是源文件</div>
<div class="paragraph">
<p>默认情况下，Elastic Beanstalk上载源并将其编译到AWS中。但是，最好改为上传二进制文件。为此，请在您的计算机上添加类似于以下内容的行<code>.elasticbeanstalk/config.yml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">deploy:
    artifact: target/demo-0.0.1-SNAPSHOT.jar</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">通过设置环境类型来降低成本</div>
<div class="paragraph">
<p>默认情况下，Elastic Beanstalk环境是负载平衡的。负载均衡器的成本很高。为避免该费用，请<a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity">按照Amazon文档</a>中<a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity">的说明</a>将环境类型设置为“单个实例”。您还可以使用CLI和以下命令来创建单实例环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>eb create -s</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="summary"><a class="anchor" href="#summary"></a> 2.4.2。摘要</h4>
<div class="paragraph">
<p>这是使用AWS的最简单方法之一，但还有更多内容要讲，例如如何将Elastic Beanstalk集成到任何CI / CD工具中，如何使用Elastic Beanstalk Maven插件而不是CLI等等。有一篇<a href="https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/">博客文章</a>详细介绍了这些主题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cloud-deployment-boxfuse"><a class="anchor" href="#cloud-deployment-boxfuse"></a> 2.5。Boxfuse和Amazon Web Services</h3>
<div class="paragraph">
<p><a href="https://boxfuse.com/">Boxfuse的</a>工作原理是将您的Spring Boot可执行jar或war变成一个最小的VM映像，该映像可以在VirtualBox或AWS上不变地部署。 Boxfuse与Spring Boot进行了深度集成，并使用Spring Boot配置文件中的信息自动配置端口和运行状况检查URL。 Boxfuse利用此信息生成的图像以及它提供的所有资源（实例，安全组，弹性负载均衡器等）。</p>
</div>
<div class="paragraph">
<p>创建<a href="https://console.boxfuse.com">Boxfuse帐户后</a> ，将其连接到您的AWS帐户，安装最新版本的Boxfuse Client，并确保该应用程序已由Maven或Gradle构建（例如，使用<code>mvn clean package</code> ），您可以使用类似于以下命令将Spring Boot应用程序部署到AWS：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ boxfuse run myapp-1.0.jar -env=prod</pre>
</div>
</div>
<div class="paragraph">
<p>见<a href="https://boxfuse.com/docs/commandline/run.html"><code>boxfuse run</code></a>有关更多选项的<a href="https://boxfuse.com/docs/commandline/run.html">文档</a> 。如果有<a href="https://boxfuse.com/docs/commandline/#configuration"><code>boxfuse.conf</code></a>文件存在于当前目录中，将被考虑。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">默认情况下，Boxfuse激活一个名为<code>boxfuse</code>在启动时。如果您的可执行jar或war包含一个<a href="https://boxfuse.com/docs/payloads/springboot.html#configuration"><code>application-boxfuse.properties</code></a> Boxfuse文件，其配置基于其包含的属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这一点， <code>boxfuse</code>为您的应用程序创建映像，然后上载该映像，并在AWS上配置并启动必要的资源，其输出类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Fusing Image for myapp-1.0.jar ...
Image fused in 00:06.838s (53937 K) -&gt; axelfontaine/myapp:1.0
Creating axelfontaine/myapp ...
Pushing axelfontaine/myapp:1.0 ...
Verifying axelfontaine/myapp:1.0 ...
Creating Elastic IP ...
Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...
Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ...
AMI created in 00:23.557s -&gt; ami-d23f38cf
Creating security group boxfuse-sg_axelfontaine/myapp:1.0 ...
Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ...
Instance launched in 00:30.306s -&gt; i-92ef9f53
Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at https://52.28.235.61/ ...
Payload started in 00:29.266s -&gt; https://52.28.235.61/
Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...
Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...
Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at https://myapp-axelfontaine.boxfuse.io/</pre>
</div>
</div>
<div class="paragraph">
<p>您的应用程序现在应该已启动并在AWS上运行。</p>
</div>
<div class="paragraph">
<p>请参阅有关<a href="https://boxfuse.com/blog/spring-boot-ec2.html">在EC2</a>上<a href="https://boxfuse.com/blog/spring-boot-ec2.html">部署Spring Boot应用程序</a>的博客文章以及<a href="https://boxfuse.com/docs/payloads/springboot.html">Boxfuse Spring Boot集成</a>的<a href="https://boxfuse.com/docs/payloads/springboot.html">文档，</a>以开始使用Maven构建来运行该应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="cloud-deployment-gae"><a class="anchor" href="#cloud-deployment-gae"></a> 2.6。谷歌云</h3>
<div class="paragraph">
<p>Google Cloud提供了几种可用于启动Spring Boot应用程序的选项。最容易上手的可能是App Engine，但是您也可以找到在Container Engine的容器中或Compute Engine的虚拟机上运行Spring Boot的方法。</p>
</div>
<div class="paragraph">
<p>要在App Engine中运行，您可以先在用户界面中创建一个项目，该项目将为您设置一个唯一的标识符，并还设置HTTP路由。将Java应用程序添加到项目中，然后将其保留为空，然后使用<a href="https://cloud.google.com/sdk/install">Google Cloud SDK</a>从命令行或CI构建将Spring Boot应用程序推送到该插槽中。</p>
</div>
<div class="paragraph">
<p>App Engine Standard要求您使用WAR包装。请按照<a href="https://github.com/GoogleCloudPlatform/getting-started-java/blob/master/appengine-standard-java8/springboot-appengine-standard/README.md">以下步骤</a>将App Engine标准应用程序部署到Google Cloud。</p>
</div>
<div class="paragraph">
<p>另外，App Engine Flex要求您创建一个<code>app.yaml</code>文件来描述您的应用所需的资源。通常，您将此文件放入<code>src/main/appengine</code> ，它应类似于以下文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">service: default

runtime: java
env: flex

runtime_config:
  jdk: openjdk8

handlers:
- url: /.*
  script: this field is required, but ignored

manual_scaling:
  instances: 1

health_check:
  enable_health_check: False

env_variables:
  ENCRYPT_KEY: your_encryption_key_here</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过将项目ID添加到构建配置中来部署应用程序（例如，使用Maven插件），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;
    &lt;artifactId&gt;appengine-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.3.0&lt;/version&gt;
    &lt;configuration&gt;
        &lt;project&gt;myproject&lt;/project&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后部署<code>mvn appengine:deploy</code> （如果您需要先进行身份验证，则构建将失败）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deployment-install"><a class="anchor" href="#deployment-install"></a> 3。安装Spring Boot应用程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了通过使用运行Spring Boot应用程序<code>java -jar</code> ，也可以为Unix系统制作完全可执行的应用程序。完全可执行的jar可以像其他任何可执行二进制文件一样执行，也可以<a href="#deployment-service">向<code>init.d</code>要么<code>systemd</code></a> 。这使得在普通生产环境中安装和管理Spring Boot应用程序变得非常容易。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">完全可执行的jar通过将额外的脚本嵌入文件的开头来工作。当前，某些工具不接受此格式，因此您可能无法始终使用此技术。例如， <code>jar -xf</code>可能会默默地提取无法完全执行的jar或war。建议仅当您打算直接执行jar或war时才使其完全可执行，而不是使用`java -jar`来运行它或将其部署到servlet容器中。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">不能使zip64格式的jar文件完全可执行。尝试这样做将导致直接或通过以下方式报告的jar文件损坏。 <code>java -jar</code> 。包含一个或多个zip64格式嵌套jar的标准格式jar文件可以完全执行。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要使用Maven创建一个“完全可执行”的jar，请使用以下插件配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;executable&gt;true&lt;/executable&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了等效的Gradle配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">bootJar {
    launchScript()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以通过键入以下内容来运行您的应用程序： <code>./my-application.jar</code> （哪里<code>my-application</code>是您的工件的名称）。包含jar的目录用作应用程序的工作目录。</p>
</div>
<div class="sect2">
<h3 id="deployment-install-supported-operating-systems"><a class="anchor" href="#deployment-install-supported-operating-systems"></a> 3.1。支持的操作系统</h3>
<div class="paragraph">
<p>默认脚本支持大多数Linux发行版，并已在CentOS和Ubuntu上进行了测试。其他平台，例如OS X和FreeBSD，则需要使用自定义<code>embeddedLaunchScript</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="deployment-service"><a class="anchor" href="#deployment-service"></a> 3.2。Unix / Linux服务</h3>
<div class="paragraph">
<p>通过使用以下任一方法，可以轻松将Spring Boot应用程序作为Unix / Linux服务启动。 <code>init.d</code>要么<code>systemd</code> 。</p>
</div>
<div class="sect3">
<h4 id="deployment-initd-service"><a class="anchor" href="#deployment-initd-service"></a> 3.2.1。作为一个安装<code>init.d</code>服务（系统V）</h4>
<div class="paragraph">
<p>如果您将Spring Boot的Maven或Gradle插件配置为生成<a href="#deployment-install">完全可执行的jar</a> ，并且您不使用自定义<code>embeddedLaunchScript</code> ，您的应用程序可以用作<code>init.d</code>服务。为此，将罐子链接到<code>init.d</code>支持标准<code>start</code> ， <code>stop</code> ， <code>restart</code>和<code>status</code>命令。</p>
</div>
<div class="paragraph">
<p>该脚本支持以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>以拥有jar文件的用户身份启动服务</p>
</li>
<li>
<p>通过使用跟踪应用程序的PID<code>/var/run/<appname>/<appname>.pid</code></p>
</li>
<li>
<p>将控制台日志写入<code>/var/log/<appname>.log</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>假设您在其中安装了Spring Boot应用程序<code>/var/myapp</code> ，以将Spring Boot应用程序安装为<code>init.d</code>服务，创建一个符号链接，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp</pre>
</div>
</div>
<div class="paragraph">
<p>安装后，您可以按照通常的方式启动和停止服务。例如，在基于Debian的系统上，可以使用以下命令启动它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ service myapp start</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您的应用程序无法启动，请检查写入的日志文件<code>/var/log/<appname>.log</code>错误。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还可以使用标准操作系统工具将应用程序标记为自动启动。例如，在Debian上，您可以使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ update-rc.d myapp defaults &lt;priority&gt;</pre>
</div>
</div>
<div class="sect4">
<h5 id="deployment-initd-service-securing"><a class="anchor" href="#deployment-initd-service-securing"></a>确保<code>init.d</code>服务</h5>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">以下是一组有关如何保护作为init.d服务运行的Spring Boot应用程序的准则。它并不旨在详尽列出增强应用程序及其运行环境所应进行的所有工作。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当以root身份执行时（例如使用root来启动init.d服务时），默认的可执行脚本将以在Windows中指定的用户身份运行该应用程序。 <code>RUN_AS_USER</code>环境变量。如果未设置环境变量，则使用拥有jar文件的用户。您不应该以以下方式运行Spring Boot应用程序： <code>root</code> ，所以<code>RUN_AS_USER</code>永远都不应该是root，并且应用程序的jar文件也永远不应该是root。而是创建一个特定用户来运行您的应用程序并设置<code>RUN_AS_USER</code>环境变量或用途<code>chown</code>使其成为jar文件的所有者，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ chown bootapp:bootapp your-app.jar</pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，默认的可执行脚本会将应用程序作为<code>bootapp</code>用户。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">为了减少应用程序的用户帐户被盗用的机会，应考虑阻止它使用登录外壳程序。例如，您可以将帐户的外壳设置为<code>/usr/sbin/nologin</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还应该采取措施防止修改应用程序的jar文件。首先，配置其权限，使其不能被写入，只能由其所有者读取或执行，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ chmod 500 your-app.jar</pre>
</div>
</div>
<div class="paragraph">
<p>其次，如果您的应用程序或运行该应用程序的帐户受到威胁，您还应采取措施限制损害。如果攻击者确实获得了访问权限，则他们可以使jar文件可写并更改其内容。防止这种情况发生的一种方法是通过使用使其不可变<code>chattr</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ sudo chattr +i your-app.jar</pre>
</div>
</div>
<div class="paragraph">
<p>这将阻止任何用户（包括root用户）修改jar。</p>
</div>
<div class="paragraph">
<p>如果root用于控制应用程序的服务，而您<a href="#deployment-script-customization-conf-file">使用<code>.conf</code>文件</a>以自定义其启动， <code>.conf</code> root用户读取和评估文件。应该相应地对其进行保护。使用<code>chmod</code>因此文件只能由所有者读取和使用<code>chown</code>使root用户成为所有者，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ chmod 400 your-app.conf
$ sudo chown root:root your-app.conf</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deployment-systemd-service"><a class="anchor" href="#deployment-systemd-service"></a> 3.2.2。作为一个安装<code>systemd</code>服务</h4>
<div class="paragraph">
<p><code>systemd</code>是System V init系统的后继产品，现在被许多现代Linux发行版使用。虽然可以继续使用<code>init.d</code>脚本与<code>systemd</code> ，也可以通过使用来启动Spring Boot应用程序<code>systemd</code> “服务”脚本。</p>
</div>
<div class="paragraph">
<p>假设您在其中安装了Spring Boot应用程序<code>/var/myapp</code> ，以将Spring Boot应用程序安装为<code>systemd</code>服务，创建一个名为<code>myapp.service</code>放进去<code>/etc/systemd/system</code>目录。以下脚本提供了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Unit]
Description=myapp
After=syslog.target

[Service]
User=myapp
ExecStart=/var/myapp/myapp.jar
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">记住要改变<code>Description</code> ， <code>User</code>和<code>ExecStart</code>您的应用程序的字段。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>ExecStart</code>字段未声明脚本操作命令，这意味着<code>run</code>默认情况下使用命令。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请注意，与以<code>init.d</code>服务，运行应用程序的用户，PID文件和控制台日志文件由<code>systemd</code>本身，因此必须使用“服务”脚本中的适当字段进行配置。有关更多详细信息，请查阅<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">服务单元配置手册页</a> 。</p>
</div>
<div class="paragraph">
<p>要将应用程序标记为在系统启动时自动启动，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ systemctl enable myapp.service</pre>
</div>
</div>
<div class="paragraph">
<p>参考<code>man systemctl</code>更多细节。</p>
</div>
</div>
<div class="sect3">
<h4 id="deployment-script-customization"><a class="anchor" href="#deployment-script-customization"></a> 3.2.3。自定义启动脚本</h4>
<div class="paragraph">
<p>由Maven或Gradle插件编写的默认嵌入式启动脚本可以通过多种方式进行自定义。对于大多数人来说，使用默认脚本以及一些自定义设置通常就足够了。如果发现无法自定义所需的内容，请使用<code>embeddedLaunchScript</code>选择完全写入自己的文件。</p>
</div>
<div class="sect4">
<h5 id="deployment-script-customization-when-it-written"><a class="anchor" href="#deployment-script-customization-when-it-written"></a>编写后自定义启动脚本</h5>
<div class="paragraph">
<p>在将启动脚本写入jar文件时，自定义启动脚本的元素通常很有意义。例如，init.d脚本可以提供“描述”。由于您已经预先了解了描述（并且无需更改），因此在生成jar时也可以提供它。</p>
</div>
<div class="paragraph">
<p>要自定义书面元素，请使用<code>embeddedLaunchScriptProperties</code> Spring Boot Maven插件的选项或<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/reference/html//#packaging-executable-configuring-launch-script"><code>properties</code> Spring Boot Gradle插件的属性<code>launchScript</code></a> 。</p>
</div>
<div class="paragraph">
<p>默认脚本支持以下属性替换：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:10%">
<col style="width:30%">
<col style="width:30%">
<col style="width:30%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Gradle默认</th>
<th class="tableblock halign-left valign-top">Maven默认</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">脚本模式。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>auto</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>auto</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoProvides</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的<code>Provides</code> “ INIT INFO”部分</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${task.baseName}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${project.artifactId}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoRequiredStart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Required-Start</code> “ INIT INFO”部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$remote_fs $syslog $network</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$remote_fs $syslog $network</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoRequiredStop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Required-Stop</code> “ INIT INFO”部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$remote_fs $syslog $network</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$remote_fs $syslog $network</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoDefaultStart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Default-Start</code> “ INIT INFO”部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2 3 4 5</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2 3 4 5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoDefaultStop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Default-Stop</code> “ INIT INFO”部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 1 6</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 1 6</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoShortDescription</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Short-Description</code> “ INIT INFO”部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单行版<code>${project.description}</code> （回溯到<code>${task.baseName}</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${project.name}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoDescription</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Description</code> “ INIT INFO”部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${project.description}</code> （回溯到<code>${task.baseName}</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${project.description}</code> （回溯到<code>${project.name}</code> ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initInfoChkconfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>chkconfig</code> “ INIT INFO”部分</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2345 99 01</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2345 99 01</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>confFolder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的默认值<code>CONF_FOLDER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含罐子的文件夹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含罐子的文件夹</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>inlinedConfScript</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">引用应在默认启动脚本中内联的文件脚本。这可用于设置环境变量，例如<code>JAVA_OPTS</code>在加载任何外部配置文件之前</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logFolder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的默认值<code>LOG_FOLDER</code> 。仅对<code>init.d</code>服务</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logFilename</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的默认值<code>LOG_FILENAME</code> 。仅对<code>init.d</code>服务</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pidFolder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的默认值<code>PID_FOLDER</code> 。仅对<code>init.d</code>服务</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pidFilename</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PID文件名的默认值<code>PID_FOLDER</code> 。仅对<code>init.d</code>服务</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>useStartStopDaemon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否<code>start-stop-daemon</code>命令（如果可用）应用于控制过程</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>stopWaitTime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的默认值<code>STOP_WAIT_TIME</code>很快。仅对<code>init.d</code>服务</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="deployment-script-customization-when-it-runs"><a class="anchor" href="#deployment-script-customization-when-it-runs"></a>运行时自定义脚本</h5>
<div class="paragraph">
<p>对于编写jar <em>之后</em>需要自定义脚本的项目，可以使用环境变量或<a href="#deployment-script-customization-conf-file">配置文件</a> 。</p>
</div>
<div class="paragraph">
<p>默认脚本支持以下环境属性：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:14.2857%">
<col style="width:85.7143%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">变量</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MODE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作的“模式”。默认值取决于jar的构建方式，但通常<code>auto</code> （这意味着它会通过检查目录中是否为符号链接来尝试猜测它是否为初始化脚本<code>init.d</code> ）。您可以将其明确设置为<code>service</code>所以这样<code>stop|start|status|restart</code>命令起作用或<code>run</code>如果要在前台运行脚本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RUN_AS_USER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将用于运行应用程序的用户。未设置时，将使用拥有jar文件的用户。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>USE_START_STOP_DAEMON</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否<code>start-stop-daemon</code>命令（如果可用）应用于控制过程。默认为<code>true</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID_FOLDER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pid文件夹的根名称（ <code>/var/run</code>默认）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FOLDER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">放置日志文件的文件夹的名称（ <code>/var/log</code>默认）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONF_FOLDER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从中读取.conf文件的文件夹的名称（默认情况下与jar文件相同的文件夹）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILENAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">日志文件中的名称<code>LOG_FOLDER</code> （ <code><appname>.log</code>默认）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>APP_NAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序的名称。如果jar是从符号链接运行的，则脚本会猜测应用程序名称。如果它不是符号链接，或者您要显式设置应用程序名称，则这将很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RUN_ARGS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传递给程序（Spring Boot应用程序）的参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JAVA_HOME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">的位置<code>java</code>可执行文件是通过使用<code>PATH</code>默认情况下，但是如果在目录中有可执行文件，则可以显式设置<code>$JAVA_HOME/bin/java</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JAVA_OPTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启动JVM时传递给JVM的选项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JARFILE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jar文件的显式位置，以防脚本用于启动实际上未嵌入的jar。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEBUG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果不为空，则设置<code>-x</code>在shell进程中添加标记，可以轻松查看脚本中的逻辑。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STOP_WAIT_TIME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">停止应用程序之前要强制关闭的等待时间（以秒为单位）（ <code>60</code>默认）。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>PID_FOLDER</code> ， <code>LOG_FOLDER</code>和<code>LOG_FILENAME</code>变量仅对<code>init.d</code>服务。对于<code>systemd</code> ，则等效的自定义是通过使用“服务”脚本进行的。有关更多详细信息，请参见<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">服务单元配置手册页</a> 。
</td>
</tr>
</tbody></table>
</div>
<div id="deployment-script-customization-conf-file" class="paragraph">
<p>除了<code>JARFILE</code>和<code>APP_NAME</code> ，可以使用以下命令配置上一节中列出的设置<code>.conf</code>文件。该文件应位于jar文件旁边，并且具有相同的名称，但后缀为<code>.conf</code>而不是<code>.jar</code> 。例如，一个名为<code>/var/myapp/myapp.jar</code>使用名为<code>/var/myapp/myapp.conf</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">myapp.conf</div>
<div class="content">
<pre>JAVA_OPTS=-Xmx1024M
LOG_FOLDER=/custom/log/folder</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您不喜欢jar文件旁边的配置文件，可以设置一个<code>CONF_FOLDER</code>环境变量以自定义配置文件的位置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要了解有关适当保护此文件的信息，请参阅<a href="#deployment-initd-service-securing">保护init.d服务的准则</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deployment-windows"><a class="anchor" href="#deployment-windows"></a> 3.3。Microsoft Windows服务</h3>
<div class="paragraph">
<p>可以使用以下命令将Spring Boot应用程序作为Windows服务启动<a href="https://github.com/kohsuke/winsw"><code>winsw</code></a> 。</p>
</div>
<div class="paragraph">
<p>（一个<a href="https://github.com/snicoll-scratches/spring-boot-daemon">单独维护的示例</a> ）逐步描述了如何为Spring Boot应用程序创建Windows服务。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deployment-whats-next"><a class="anchor" href="#deployment-whats-next"></a> 4。接下来要读什么</h2>
<div class="sectionbody">
<div class="paragraph">
<p>请访问<a href="https://www.cloudfoundry.org/">Cloud Foundry</a> ， <a href="https://www.heroku.com/">Heroku</a> ， <a href="https://www.openshift.com">OpenShift</a>和<a href="https://boxfuse.com">Boxfuse</a>网站，以获取有关PaaS可以提供的各种功能的更多信息。这些只是最受欢迎的Java PaaS提供程序中的四个。由于Spring Boot非常适合基于云的部署，因此您也可以自由考虑其他提供商。</p>
</div>
<div class="paragraph">
<p>下一节将继续介绍<em><a href="spring-boot-cli.html#cli">Spring Boot CLI</a></em> ，或者您可以继续阅读有关<em><a href="build-tool-plugins.html#build-tool-plugins">构建工具插件的信息</a></em> 。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-11-06 21:59:19 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>