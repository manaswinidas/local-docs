<!DOCTYPE html>
<html lang="zh-Hans" ><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>“使用方法”指南</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head><body id="howto" class="book toc2 toc-left" ><div id="header">
<h1>“使用方法”指南</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#howto-spring-boot-application">1。Spring Boot应用程序</a>
<ul class="sectlevel2">
<li><a href="#howto-failure-analyzer">1.1。创建自己的FailureAnalyzer</a></li>
<li><a href="#howto-troubleshoot-auto-configuration">1.2。自动配置故障排除</a></li>
<li><a href="#howto-customize-the-environment-or-application-context">1.3。启动之前自定义环境或ApplicationContext</a></li>
<li><a href="#howto-build-an-application-context-hierarchy">1.4。建立ApplicationContext层次结构（添加父上下文或根上下文）</a></li>
<li><a href="#howto-create-a-non-web-application">1.5。创建一个非Web应用程序</a></li>
</ul>
</li>
<li><a href="#howto-properties-and-configuration">2。属性和配置</a>
<ul class="sectlevel2">
<li><a href="#howto-automatic-expansion">2.1。在构建时自动扩展属性</a>
<ul class="sectlevel3">
<li><a href="#howto-automatic-expansion-maven">2.1.1。使用Maven自动扩展属性</a></li>
<li><a href="#howto-automatic-expansion-gradle">2.1.2。使用Gradle自动扩展属性</a></li>
</ul>
</li>
<li><a href="#howto-externalize-configuration">2.2。外化配置<code>SpringApplication</code></a></li>
<li><a href="#howto-change-the-location-of-external-properties">2.3。更改应用程序外部属性的位置</a></li>
<li><a href="#howto-use-short-command-line-arguments">2.4。使用“简短”命令行参数</a></li>
<li><a href="#howto-use-yaml-for-external-properties">2.5。对外部属性使用YAML</a></li>
<li><a href="#howto-set-active-spring-profiles">2.6。设置活动Spring 轮廓</a></li>
<li><a href="#howto-change-configuration-depending-on-the-environment">2.7。根据环境更改配置</a></li>
<li><a href="#howto-discover-build-in-options-for-external-properties">2.8。发现外部属性的内置选项</a></li>
</ul>
</li>
<li><a href="#howto-embedded-web-servers">3。嵌入式Web服务器</a>
<ul class="sectlevel2">
<li><a href="#howto-use-another-web-server">3.1。使用其他Web服务器</a></li>
<li><a href="#howto-disable-web-server">3.2。禁用Web服务器</a></li>
<li><a href="#howto-change-the-http-port">3.3。更改HTTP端口</a></li>
<li><a href="#howto-user-a-random-unassigned-http-port">3.4。使用随机未分配的HTTP端口</a></li>
<li><a href="#howto-discover-the-http-port-at-runtime">3.5。在运行时发现HTTP端口</a></li>
<li><a href="#how-to-enable-http-response-compression">3.6。启用HTTP响应压缩</a></li>
<li><a href="#howto-configure-ssl">3.7。配置SSL</a></li>
<li><a href="#howto-configure-http2">3.8。配置HTTP / 2</a>
<ul class="sectlevel3">
<li><a href="#howto-configure-http2-undertow">3.8.1。带有Undertow的HTTP / 2</a></li>
<li><a href="#howto-configure-http2-jetty">3.8.2。HTTP / 2与码头</a></li>
<li><a href="#howto-configure-http2-tomcat">3.8.3。Tomcat的HTTP / 2</a></li>
<li><a href="#howto-configure-http2-netty">3.8.4。HTTP / 2和Reactor Netty</a></li>
</ul>
</li>
<li><a href="#howto-configure-webserver">3.9。配置Web服务器</a></li>
<li><a href="#howto-add-a-servlet-filter-or-listener">3.10。将Servlet，过滤器或侦听器添加到应用程序</a>
<ul class="sectlevel3">
<li><a href="#howto-add-a-servlet-filter-or-listener-as-spring-bean">3.10.1。使用Spring Bean添加Servlet，过滤器或侦听器</a>
<ul class="sectlevel4">
<li><a href="#howto-disable-registration-of-a-servlet-or-filter">禁用Servlet或过滤器的注册</a></li>
</ul>
</li>
<li><a href="#howto-add-a-servlet-filter-or-listener-using-scanning">3.10.2。使用类路径扫描添加Servlet，过滤器和侦听器</a></li>
</ul>
</li>
<li><a href="#howto-configure-accesslogs">3.11。配置访问日志</a></li>
<li><a href="#howto-use-tomcat-behind-a-proxy-server">3.12。在前端代理服务器后面运行</a>
<ul class="sectlevel3">
<li><a href="#howto-customize-tomcat-behind-a-proxy-server">3.12.1。自定义Tomcat的代理配置</a></li>
</ul>
</li>
<li><a href="#howto-enable-multiple-connectors-in-tomcat">3.13。使用Tomcat启用多个连接器</a></li>
<li><a href="#howto-use-tomcat-legacycookieprocessor">3.14。使用Tomcat的LegacyCookieProcessor</a></li>
<li><a href="#howto-enable-tomcat-mbean-registry">3.15。启用Tomcat的MBean注册表</a></li>
<li><a href="#howto-enable-multiple-listeners-in-undertow">3.16。使用Undertow启用多个侦听器</a></li>
<li><a href="#howto-create-websocket-endpoints-using-serverendpoint">3.17。使用@ServerEndpoint创建WebSocket端点</a></li>
</ul>
</li>
<li><a href="#howto-spring-mvc">4。春季MVC</a>
<ul class="sectlevel2">
<li><a href="#howto-write-a-json-rest-service">4.1。编写JSON REST服务</a></li>
<li><a href="#howto-write-an-xml-rest-service">4.2。编写XML REST服务</a></li>
<li><a href="#howto-customize-the-jackson-objectmapper">4.3。自定义Jackson ObjectMapper</a></li>
<li><a href="#howto-customize-the-responsebody-rendering">4.4。自定义@ResponseBody渲染</a></li>
<li><a href="#howto-multipart-file-upload-configuration">4.5。处理分段文件上传</a></li>
<li><a href="#howto-switch-off-the-spring-mvc-dispatcherservlet">4.6。关闭Spring MVC DispatcherServlet</a></li>
<li><a href="#howto-switch-off-default-mvc-configuration">4.7。关闭默认的MVC配置</a></li>
<li><a href="#howto-customize-view-resolvers">4.8。自定义ViewResolvers</a></li>
</ul>
</li>
<li><a href="#howto-use-test-with-spring-security">5，使用Spring Security进行测试</a></li>
<li><a href="#howto-jersey">6。泽西岛</a>
<ul class="sectlevel2">
<li><a href="#howto-jersey-spring-security">6.1。使用Spring Security保护Jersey端点</a></li>
<li><a href="#howto-jersey-alongside-another-web-framework">6.2。与另一个Web框架一起使用Jersey</a></li>
</ul>
</li>
<li><a href="#howto-http-clients">7。HTTP客户端</a>
<ul class="sectlevel2">
<li><a href="#howto-http-clients-proxy-configuration">7.1。配置RestTemplate使用代理</a></li>
<li><a href="#howto-webclient-reactor-netty-customization">7.2。配置基于Reactor Netty的WebClient使用的TcpClient</a></li>
</ul>
</li>
<li><a href="#howto-logging">8。记录中</a>
<ul class="sectlevel2">
<li><a href="#howto-configure-logback-for-logging">8.1。配置登录以进行日志记录</a>
<ul class="sectlevel3">
<li><a href="#howto-configure-logback-for-logging-fileonly">8.1.1。配置仅文件输出的Logback</a></li>
</ul>
</li>
<li><a href="#howto-configure-log4j-for-logging">8.2。配置Log4j进行日志记录</a>
<ul class="sectlevel3">
<li><a href="#howto-configure-log4j-for-logging-yaml-or-json-config">8.2.1。使用YAML或JSON配置Log4j 2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#howto-data-access">9。资料存取</a>
<ul class="sectlevel2">
<li><a href="#howto-configure-a-datasource">9.1。配置自定义数据源</a></li>
<li><a href="#howto-two-datasources">9.2。配置两个数据源</a></li>
<li><a href="#howto-use-spring-data-repositories">9.3。使用Spring数据仓库</a></li>
<li><a href="#howto-separate-entity-definitions-from-spring-configuration">9.4。将@Entity定义与Spring配置分开</a></li>
<li><a href="#howto-configure-jpa-properties">9.5。配置JPA属性</a></li>
<li><a href="#howto-configure-hibernate-naming-strategy">9.6。配置休眠命名策略</a></li>
<li><a href="#howto-configure-hibernate-second-level-caching">9.7。配置Hibernate二级缓存</a></li>
<li><a href="#howto-use-dependency-injection-hibernate-components">9.8。在休眠组件中使用依赖注入</a></li>
<li><a href="#howto-use-custom-entity-manager">9.9。使用自定义EntityManagerFactory</a></li>
<li><a href="#howto-use-two-entity-managers">9.10。使用两个EntityManager</a></li>
<li><a href="#howto-use-traditional-persistence-xml">9.11。使用传统<code>persistence.xml</code>文件</a></li>
<li><a href="#howto-use-spring-data-jpa--and-mongo-repositories">9.12。使用Spring Data JPA和Mongo存储库</a></li>
<li><a href="#howto-use-customize-spring-datas-web-support">9.13。定制Spring Data的Web支持</a></li>
<li><a href="#howto-use-exposing-spring-data-repositories-rest-endpoint">9.14。将Spring数据存储库公开为REST端点</a></li>
<li><a href="#howto-configure-a-component-that-is-used-by-JPA">9.15。配置JPA使用的组件</a></li>
<li><a href="#howto-configure-jOOQ-with-multiple-datasources">9.16。使用两个数据源配置jOOQ</a></li>
</ul>
</li>
<li><a href="#howto-database-initialization">10。数据库初始化</a>
<ul class="sectlevel2">
<li><a href="#howto-initialize-a-database-using-jpa">10.1。使用JPA初始化数据库</a></li>
<li><a href="#howto-initialize-a-database-using-hibernate">10.2。使用休眠初始化数据库</a></li>
<li><a href="#howto-initialize-a-database-using-spring-jdbc">10.3。初始化数据库</a></li>
<li><a href="#howto-initialize-a-spring-batch-database">10.4。初始化一个Spring Batch数据库</a></li>
<li><a href="#howto-use-a-higher-level-database-migration-tool">10.5。使用高级数据库迁移工具</a>
<ul class="sectlevel3">
<li><a href="#howto-execute-flyway-database-migrations-on-startup">10.5.1。在启动时执行Flyway数据库迁移</a></li>
<li><a href="#howto-execute-liquibase-database-migrations-on-startup">10.5.2。在启动时执行Liquibase数据库迁移</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#howto-messaging">11。讯息传递</a>
<ul class="sectlevel2">
<li><a href="#howto-jms-disable-transaction">11.1。禁用事务JMS会话</a></li>
</ul>
</li>
<li><a href="#howto-batch-applications">12批量申请</a>
<ul class="sectlevel2">
<li><a href="#howto-execute-spring-batch-jobs-on-startup">12.1。在启动时执行Spring Batch作业</a></li>
</ul>
</li>
<li><a href="#howto-actuator">13执行器</a>
<ul class="sectlevel2">
<li><a href="#howto-change-the-http-port-or-address-of-the-actuator-endpoints">13.1。更改执行器端点的HTTP端口或地址</a></li>
<li><a href="#howto-customize-the-whitelabel-error-page">13.2。自定义“ whitelabel”错误页面</a></li>
<li><a href="#howto-sanitize-sensible-values">13.3。清理明智的价值观</a></li>
</ul>
</li>
<li><a href="#howto-security">14。安全</a>
<ul class="sectlevel2">
<li><a href="#howto-switch-off-spring-boot-security-configuration">14.1。关闭Spring Boot安全性配置</a></li>
<li><a href="#howto-change-the-user-details-service-and-add-user-accounts">14.2。更改UserDetailsService并添加用户帐户</a></li>
<li><a href="#howto-enable-https">14.3。在代理服务器后运行时启用HTTPS</a></li>
</ul>
</li>
<li><a href="#howto-hotswapping">15热交换</a>
<ul class="sectlevel2">
<li><a href="#howto-reload-static-content">15.1。重新加载静态内容</a></li>
<li><a href="#howto-reload-thymeleaf-template-content">15.2。重新加载模板，而无需重新启动容器</a>
<ul class="sectlevel3">
<li><a href="#howto-reload-thymeleaf-content">15.2.1。胸腺模板</a></li>
<li><a href="#howto-reload-freemarker-content">15.2.2。FreeMarker模板</a></li>
<li><a href="#howto-reload-groovy-template-content">15.2.3。Groovy模板</a></li>
</ul>
</li>
<li><a href="#howto-reload-fast-restart">15.3。快速应用重启</a></li>
<li><a href="#howto-reload-java-classes-without-restarting">15.4。重新加载Java类而无需重新启动容器</a></li>
</ul>
</li>
<li><a href="#howto-build">16。建立</a>
<ul class="sectlevel2">
<li><a href="#howto-build-info">16.1。生成构建信息</a></li>
<li><a href="#howto-git-info">16.2。生成Git信息</a></li>
<li><a href="#howto-customize-dependency-versions">16.3。自定义依赖版本</a></li>
<li><a href="#howto-create-an-executable-jar-with-maven">16.4。使用Maven创建可执行JAR</a></li>
<li><a href="#howto-create-an-additional-executable-jar">16.5。使用Spring Boot应用程序作为依赖项</a></li>
<li><a href="#howto-extract-specific-libraries-when-an-executable-jar-runs">16.6。运行可执行jar时提取特定的库</a></li>
<li><a href="#howto-create-a-nonexecutable-jar">16.7。创建带有排除项的不可执行的JAR</a></li>
<li><a href="#howto-remote-debug-maven-run">16.8。远程调试以Maven开头的Spring Boot应用程序</a></li>
<li><a href="#howto-build-an-executable-archive-with-ant">16.9。在不使用Ant的情况下从Ant构建可执行存档<code>spring-boot-antlib</code></a></li>
</ul>
</li>
<li><a href="#howto-traditional-deployment">17。传统部署</a>
<ul class="sectlevel2">
<li><a href="#howto-create-a-deployable-war-file">17.1。创建可部署的战争文件</a></li>
<li><a href="#howto-convert-an-existing-application-to-spring-boot">17.2。将现有应用程序转换为Spring Boot</a></li>
<li><a href="#howto-weblogic">17.3。将WAR部署到WebLogic</a></li>
<li><a href="#howto-use-jedis-instead-of-lettuce">17.4。使用Jedis代替生菜</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本节提供了一些在使用Spring Boot时经常出现的常见``我该怎么做...''问题的答案。它的覆盖范围不是很详尽，但是确实覆盖了很多。</p>
</div>
<div class="paragraph">
<p>如果您有一个我们不在此讨论的特定问题，则可能需要查看<a href="https://stackoverflow.com/tags/spring-boot">stackoverflow.com</a>来查看是否有人已经提供了答案。这也是一个提出新问题的好地方（请使用<code>spring-boot</code>标签）。</p>
</div>
<div class="paragraph">
<p>我们也很乐意扩展此部分。如果您想添加“操作方法”，请向我们发送<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE">请求请求</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-spring-boot-application"><a class="anchor" href="#howto-spring-boot-application"></a> 1。Spring Boot应用程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本部分包括与Spring Boot应用程序直接相关的主题。</p>
</div>
<div class="sect2">
<h3 id="howto-failure-analyzer"><a class="anchor" href="#howto-failure-analyzer"></a> 1.1。创建自己的FailureAnalyzer</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/diagnostics/FailureAnalyzer.html"><code>FailureAnalyzer</code></a>这是拦截启动时将异常转化为人类可读消息的好方法，将其包装在<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/diagnostics/FailureAnalysis.html"><code>FailureAnalysis</code></a> 。Spring Boot为与应用程序上下文相关的异常，JSR-303验证等提供了此类分析器。您也可以创建自己的。</p>
</div>
<div class="paragraph">
<p><code>AbstractFailureAnalyzer</code>是的方便扩展<code>FailureAnalyzer</code>检查要处理的异常中是否存在指定的异常类型。您可以对此进行扩展，以便您的实现只有在异常出现时才有机会处理该异常。如果由于某种原因您无法处理该异常，请返回<code>null</code>使另一个实现有机会处理该异常。</p>
</div>
<div class="paragraph">
<p><code>FailureAnalyzer</code>实现必须在<code>META-INF/spring.factories</code> 。以下示例寄存器<code>ProjectConstraintViolationFailureAnalyzer</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">org.springframework.boot.diagnostics.FailureAnalyzer=\
com.example.ProjectConstraintViolationFailureAnalyzer</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您需要访问<code>BeanFactory</code>或者<code>Environment</code> ， 你的<code>FailureAnalyzer</code>可以简单地实现<code>BeanFactoryAware</code>要么<code>EnvironmentAware</code>分别。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-troubleshoot-auto-configuration"><a class="anchor" href="#howto-troubleshoot-auto-configuration"></a> 1.2。自动配置故障排除</h3>
<div class="paragraph">
<p>Spring Boot自动配置会尽力“做正确的事”，但是有时事情会失败，并且很难说出原因。</p>
</div>
<div class="paragraph">
<p>有一个非常有用的<code>ConditionEvaluationReport</code>在任何Spring Boot中都可用<code>ApplicationContext</code> 。如果启用，您可以看到它<code>DEBUG</code>记录输出。如果您使用<code>spring-boot-actuator</code> （请参阅<a href="production-ready-features.html#production-ready">执行器章节</a> ），还有一个<code>conditions</code>以JSON呈现报告的端点。使用该端点调试应用程序，并在运行时查看Spring Boot添加了哪些功能（哪些尚未添加）。</p>
</div>
<div class="paragraph">
<p>通过查看源代码和Javadoc，可以回答更多问题。阅读代码时，请记住以下经验法则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>寻找称为<code>*AutoConfiguration</code>并阅读他们的资料。要特别注意<code>@Conditional*</code>注释，以了解它们启用了哪些功能以及何时启用。加<code>--debug</code>到命令行或系统属性<code>-Ddebug</code>在控制台上获取您在应用中做出的所有自动配置决策的日志。在启用了执行器的运行应用程序中，查看<code>conditions</code>端点（ <code>/actuator/conditions</code>或等效的JMX）以获取相同的信息。</p>
</li>
<li>
<p>寻找的是<code>@ConfigurationProperties</code> （如<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a> ），然后从中读取可用的外部配置选项。的<code>@ConfigurationProperties</code>注释中有一个<code>name</code>充当外部属性前缀的属性。从而， <code>ServerProperties</code>拥有<code>prefix="server"</code>其配置属性为<code>server.port</code> ， <code>server.address</code> ， 和别的。在启用了执行器的运行应用程序中，查看<code>configprops</code>端点。</p>
</li>
<li>
<p>寻找用途<code>bind</code>上的方法<code>Binder</code>将配置值明确地从<code>Environment</code>轻松地它通常与前缀一起使用。</p>
</li>
<li>
<p>寻找<code>@Value</code>直接绑定到<code>Environment</code> 。</p>
</li>
<li>
<p>寻找<code>@ConditionalOnExpression</code>注释，用于根据SpEL表达式打开和关闭功能，通常使用从<code>Environment</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="howto-customize-the-environment-or-application-context"><a class="anchor" href="#howto-customize-the-environment-or-application-context"></a> 1.3。启动之前自定义环境或ApplicationContext</h3>
<div class="paragraph">
<p>一种<code>SpringApplication</code>拥有<code>ApplicationListeners</code>和<code>ApplicationContextInitializers</code>用于将自定义项应用于上下文或环境的文件。Spring Boot加载了许多此类自定义项，以供内部使用<code>META-INF/spring.factories</code> 。注册其他自定义项的方法有多种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>以编程方式，针对每个应用，通过调用<code>addListeners</code>和<code>addInitializers</code>方法<code>SpringApplication</code>在运行它之前。</p>
</li>
<li>
<p>以声明方式，针对每个应用，通过设置<code>context.initializer.classes</code>要么<code>context.listener.classes</code>属性。</p>
</li>
<li>
<p>声明式地，对于所有应用程序，通过添加<code>META-INF/spring.factories</code>并打包所有应用程序都用作库的jar文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的<code>SpringApplication</code>发送一些特殊的<code>ApplicationEvents</code>给侦听器（甚至在创建上下文之前），然后为侦听器注册由<code>ApplicationContext</code>也一样有关完整列表，请参见“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-application-events-and-listeners">应用程序事件和侦听器</a> ”。</p>
</div>
<div class="paragraph">
<p>也可以自定义<code>Environment</code>通过使用刷新应用程序上下文之前<code>EnvironmentPostProcessor</code> 。每个实现都应在<code>META-INF/spring.factories</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor</code></pre>
</div>
</div>
<div class="paragraph">
<p>该实现可以加载任意文件并将其添加到<code>Environment</code> 。例如，以下示例从类路径加载YAML配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EnvironmentPostProcessorExample implements EnvironmentPostProcessor {

    private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();

    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
        Resource path = new ClassPathResource("com/example/myapp/config.yml");
        PropertySource&lt;?&gt; propertySource = loadYaml(path);
        environment.getPropertySources().addLast(propertySource);
    }

    private PropertySource&lt;?&gt; loadYaml(Resource path) {
        if (!path.exists()) {
            throw new IllegalArgumentException("Resource " + path + " does not exist");
        }
        try {
            return this.loader.load("custom-resource", path).get(0);
        }
        catch (IOException ex) {
            throw new IllegalStateException("Failed to load yaml configuration from " + path, ex);
        }
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">的<code>Environment</code>已经为Spring Boot默认加载的所有常用属性源做好了准备。因此可以从环境中获取文件的位置。前面的示例添加了<code>custom-resource</code>属性源位于列表的末尾，因此在其他任何常见位置定义的键都具有优先权。定制实现可以定义另一个顺序。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">使用时<code>@PropertySource</code>在你的<code>@SpringBootApplication</code>似乎是一种便捷的方法，可以将自定义资源加载到<code>Environment</code> ，我们不建议您这样做，因为Spring Boot会准备<code>Environment</code>之前<code>ApplicationContext</code>刷新。任何定义为<code>@PropertySource</code>加载太晚，对自动配置没有任何影响。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-build-an-application-context-hierarchy"><a class="anchor" href="#howto-build-an-application-context-hierarchy"></a> 1.4。建立ApplicationContext层次结构（添加父上下文或根上下文）</h3>
<div class="paragraph">
<p>您可以使用<code>ApplicationBuilder</code>创建父/子类<code>ApplicationContext</code>层次结构。有关更多信息，请参见“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-fluent-builder-api">spring-boot-features.html</a> ”。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-create-a-non-web-application"><a class="anchor" href="#howto-create-a-non-web-application"></a> 1.5。创建一个非Web应用程序</h3>
<div class="paragraph">
<p>并非所有的Spring应用程序都必须是Web应用程序（或Web服务）。如果您想在<code>main</code>方法，还引导一个Spring应用程序以设置要使用的基础架构，您可以使用<code>SpringApplication</code> Spring Boot的功能。一种<code>SpringApplication</code>改变它<code>ApplicationContext</code>类，取决于它是否认为需要Web应用程序。您可以做的第一件事就是让服务器相关的依赖项（例如Servlet API）脱离类路径。如果您不能执行此操作（例如，从同一代码库运行两个应用程序），则可以显式调用<code>setWebApplicationType(WebApplicationType.NONE)</code>在你的<code>SpringApplication</code>实例或设置<code>applicationContextClass</code>属性（通过Java API或带有外部属性）。您可以将要作为业务逻辑运行的应用程序代码实现为<code>CommandLineRunner</code>并作为一个<code>@Bean</code>定义。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-properties-and-configuration"><a class="anchor" href="#howto-properties-and-configuration"></a> 2。属性和配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节包括有关设置和读取属性，配置设置以及它们与Spring Boot应用程序的交互的主题。</p>
</div>
<div class="sect2">
<h3 id="howto-automatic-expansion"><a class="anchor" href="#howto-automatic-expansion"></a> 2.1。在构建时自动扩展属性</h3>
<div class="paragraph">
<p>除了可以对项目的构建配置中也指定的某些属性进行硬编码之外，您可以使用现有的构建配置自动扩展它们。在Maven和Gradle中都是可能的。</p>
</div>
<div class="sect3">
<h4 id="howto-automatic-expansion-maven"><a class="anchor" href="#howto-automatic-expansion-maven"></a> 2.1.1。使用Maven自动扩展属性</h4>
<div class="paragraph">
<p>您可以使用资源过滤从Maven项目自动扩展属性。如果您使用<code>spring-boot-starter-parent</code> ，然后可以使用引用Maven的“项目属性” <code>@..@</code>占位符，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.encoding=@project.build.sourceEncoding@
app.java.version=@java.version@</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这样只会过滤生产配置（换句话说，不会对<code>src/test/resources</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果启用<code>addResources</code>标志， <code>spring-boot:run</code>目标可以添加<code>src/main/resources</code>直接到类路径（用于热重载）。这样做避免了资源过滤和此功能。相反，您可以使用<code>exec:java</code>目标或自定义插件的配置。有关更多详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/maven-plugin//usage.html">插件使用情况页面</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您不使用入门级父级，则需要在<code><build/></code>你的元素<code>pom.xml</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;filtering&gt;true&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还需要在其中包含以下元素<code><plugins/></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.7&lt;/version&gt;
    &lt;configuration&gt;
        &lt;delimiters&gt;
            &lt;delimiter&gt;@&lt;/delimiter&gt;
        &lt;/delimiters&gt;
        &lt;useDefaultDelimiters&gt;false&lt;/useDefaultDelimiters&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>useDefaultDelimiters</code>如果您使用标准的Spring占位符（例如， <code>${placeholder}</code> ）。如果该属性未设置为<code>false</code> ，这些可能会因构建而扩展。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="howto-automatic-expansion-gradle"><a class="anchor" href="#howto-automatic-expansion-gradle"></a> 2.1.2。使用Gradle自动扩展属性</h4>
<div class="paragraph">
<p>您可以通过配置Java插件的自动扩展Gradle项目中的属性<code>processResources</code>任务，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">processResources {
    expand(project.properties)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用占位符来引用Gradle项目的属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.name=${name}
app.description=${description}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">摇篮的<code>expand</code>方法使用Groovy <code>SimpleTemplateEngine</code> ，它会转变<code>${..}</code>令牌。的<code>${..}</code>样式与Spring自己的属性占位符机制冲突。要将Spring属性占位符与自动扩展一起使用，请按以下步骤对Spring属性占位符进行转义： <code>\${..}</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-externalize-configuration"><a class="anchor" href="#howto-externalize-configuration"></a> 2.2。外化配置<code>SpringApplication</code></h3>
<div class="paragraph">
<p>一种<code>SpringApplication</code>具有bean属性（主要是setter），因此在创建应用程序时可以使用其Java API修改其行为。另外，您可以通过在<code>spring.main.*</code> 。例如，在<code>application.properties</code> ，您可能具有以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.main.web-application-type=none
spring.main.banner-mode=off</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，启动时不会打印Spring Boot标语，并且应用程序也没有启动嵌入式Web服务器。</p>
</div>
<div class="paragraph">
<p>外部配置中定义的属性会覆盖用Java API指定的值，但显着的例外是用于创建Java API的源。 <code>ApplicationContext</code> 。考虑以下应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">new SpringApplicationBuilder()
    .bannerMode(Banner.Mode.OFF)
    .sources(demo.MyApp.class)
    .run(args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.main.sources=com.acme.Config,com.acme.ExtraConfig
spring.main.banner-mode=console</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>现在</em> ，实际的应用程序会显示横幅（被配置覆盖），并使用三个来源<code>ApplicationContext</code> （按以下顺序）： <code>demo.MyApp</code> ， <code>com.acme.Config</code>和<code>com.acme.ExtraConfig</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-change-the-location-of-external-properties"><a class="anchor" href="#howto-change-the-location-of-external-properties"></a> 2.3。更改应用程序外部属性的位置</h3>
<div class="paragraph">
<p>默认情况下，来自不同来源的属性会添加到Spring中<code>Environment</code>按照定义的顺序（有关确切顺序，请参见“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-external-config">spring-boot-features.html</a> ”）。</p>
</div>
<div class="paragraph">
<p>增强和修改此顺序的一种好方法是添加<code>@PropertySource</code>应用程序源的注释。类传递给<code>SpringApplication</code>静态便利方法以及使用方法添加的方法<code>setSources()</code>被检查看他们是否有<code>@PropertySources</code> 。如果它们这样做，则将这些属性添加到<code>Environment</code>足够早地用于所有阶段<code>ApplicationContext</code>生命周期。以这种方式添加的属性的优先级低于使用默认位置（例如， <code>application.properties</code> ），系统属性，环境变量或命令行。</p>
</div>
<div class="paragraph">
<p>您还可以提供以下系统属性（或环境变量）来更改行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.config.name</code> （ <code>SPRING_CONFIG_NAME</code> ）：默认为<code>application</code>作为文件名的根。</p>
</li>
<li>
<p><code>spring.config.location</code> （ <code>SPRING_CONFIG_LOCATION</code> ）：要加载的文件（例如类路径资源或URL）。独立<code>Environment</code>属性源是为此文档设置的，可以被系统属性，环境变量或命令行覆盖。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>无论您在环境中进行什么设置，Spring Boot始终会加载<code>application.properties</code>如上所述。默认情况下，如果使用YAML，则扩展名为'.yml'的文件也将添加到列表中。</p>
</div>
<div class="paragraph">
<p>Spring Boot记录了在<code>DEBUG</code>级别及其尚未找到的候选人<code>TRACE</code>水平。</p>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/config/ConfigFileApplicationListener.java"><code>ConfigFileApplicationListener</code></a>有关更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-short-command-line-arguments"><a class="anchor" href="#howto-use-short-command-line-arguments"></a> 2.4。使用“简短”命令行参数</h3>
<div class="paragraph">
<p>有些人喜欢使用（例如） <code>--port=9000</code>代替<code>--server.port=9000</code>在命令行上设置配置属性。您可以通过在其中使用占位符来启用此行为<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.port=${port:8080}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您继承自<code>spring-boot-starter-parent</code> POM，默认的过滤器令牌<code>maven-resources-plugins</code>已从更改为<code>${*}</code>至<code>@</code> （那是， <code>@maven.token@</code>代替<code>${maven.token}</code> ），以防止与Spring样式的占位符发生冲突。如果您已为<code>application.properties</code>直接，您可能还希望更改默认过滤器令牌以使用<a href="https://maven.apache.org/plugins/maven-resources-plugin/resources-mojo.html#delimiters">其他定界符</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在此特定情况下，端口绑定可在PaaS环境（例如Heroku或Cloud Foundry）中工作。在这两个平台中， <code>PORT</code>环境变量是自动设置的，Spring可以将大写的同义词绑定为<code>Environment</code>属性。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-yaml-for-external-properties"><a class="anchor" href="#howto-use-yaml-for-external-properties"></a> 2.5。对外部属性使用YAML</h3>
<div class="paragraph">
<p>YAML是JSON的超集，因此，它是一种方便的语法，用于以分层格式存储外部属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
    application:
        name: cruncher
    datasource:
        driverClassName: com.mysql.jdbc.Driver
        url: jdbc:mysql://localhost/test
server:
    port: 9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个名为<code>application.yml</code>并将其放在您的类路径的根目录中。然后加<code>snakeyaml</code>到您的依赖项（Maven坐标<code>org.yaml:snakeyaml</code> ，如果您使用<code>spring-boot-starter</code> ）。将YAML文件解析为Java <code>Map<String,Object></code> （例如JSON对象），然后Spring Boot将地图展平，使其深一层，并具有句点分隔的键，这是很多人习惯的<code>Properties</code> Java文件。</p>
</div>
<div class="paragraph">
<p>前面的示例YAML对应于以下示例<code>application.properties</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.application.name=cruncher
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost/test
server.port=9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关YAML的更多信息，请参见“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-external-config-yaml">spring-boot-features.html</a> ”。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-set-active-spring-profiles"><a class="anchor" href="#howto-set-active-spring-profiles"></a> 2.6。设置活动Spring 轮廓</h3>
<div class="paragraph">
<p> Spring <code>Environment</code>为此有一个API，但是您通常会设置一个System属性（ <code>spring.profiles.active</code> ）或OS环境变量（ <code>SPRING_PROFILES_ACTIVE</code> ）。另外，您可以使用<code>-D</code>参数（请记住将其放在主类或jar存档之前），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
<div class="paragraph">
<p>在Spring Boot中，您还可以在<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.profiles.active=production</code></pre>
</div>
</div>
<div class="paragraph">
<p>用这种方法设置的值将由“系统”属性或环境变量设置代替，而不是由<code>SpringApplicationBuilder.profiles()</code>方法。因此，后一种Java API可用于扩充配置文件，而无需更改默认值。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-profiles">spring-boot-features.html</a> ”。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-change-configuration-depending-on-the-environment"><a class="anchor" href="#howto-change-configuration-depending-on-the-environment"></a> 2.7。根据环境更改配置</h3>
<div class="paragraph">
<p>一个YAML文件实际上是一系列文档，由<code>---</code>行，然后将每个文档分别解析为展平图。</p>
</div>
<div class="paragraph">
<p>如果YAML文件包含<code>spring.profiles</code>键，然后将配置文件值（以逗号分隔的配置文件列表）输入到Spring中<code>Environment.acceptsProfiles()</code>方法。如果这些配置文件中的任何一个处于活动状态，那么该文档将包含在最终合并中（否则，则不包含在此文档中），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
    port: 9000
---

spring:
    profiles: development
server:
    port: 9001

---

spring:
    profiles: production
server:
    port: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，默认端口是9000。但是，如果称为“开发”的Spring配置文件处于活动状态，则端口为9001。如果“生产”处于活动状态，则端口为0。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">YAML文档按照它们遇到的顺序进行合并。以后的值将覆盖以前的值。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要对属性文件执行相同的操作，可以使用<code>application-${profile}.properties</code>指定特定于配置文件的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-discover-build-in-options-for-external-properties"><a class="anchor" href="#howto-discover-build-in-options-for-external-properties"></a> 2.8。发现外部属性的内置选项</h3>
<div class="paragraph">
<p>Spring Boot从以下位置绑定外部属性<code>application.properties</code> （要么<code>.yml</code>文件和其他位置）在运行时导入到应用程序中。在一个位置上没有（而且从技术上来说不是）所有受支持属性的详尽列表，因为贡献可能来自类路径上的其他jar文件。</p>
</div>
<div class="paragraph">
<p>具有执行器功能的正在运行的应用程序具有<code>configprops</code>端点，显示所有可通过以下方式获得的绑定和可绑定属性<code>@ConfigurationProperties</code> 。</p>
</div>
<div class="paragraph">
<p>附录包括<a href="appendix-application-properties.html#common-application-properties"><code>application.properties</code></a>示例，其中列出了Spring Boot支持的最常见属性。权威列表来自搜索源代码以获取<code>@ConfigurationProperties</code>和<code>@Value</code>注释以及偶尔使用<code>Binder</code> 。有关加载属性的确切顺序的更多信息，请参见“ <a href="spring-boot-features.html#boot-features-external-config">spring-boot-features.html</a> ”。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-embedded-web-servers"><a class="anchor" href="#howto-embedded-web-servers"></a> 3。嵌入式Web服务器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每个Spring Boot Web应用程序都包含一个嵌入式Web服务器。此功能导致许多方法问题，包括如何更改嵌入式服务器以及如何配置嵌入式服务器。本节回答这些问题。</p>
</div>
<div class="sect2">
<h3 id="howto-use-another-web-server"><a class="anchor" href="#howto-use-another-web-server"></a> 3.1。使用其他Web服务器</h3>
<div class="paragraph">
<p>许多Spring Boot启动器都包含默认的嵌入式容器。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Servlet堆栈应用程序， <code>spring-boot-starter-web</code>通过包含Tomcat <code>spring-boot-starter-tomcat</code> ，但您可以使用<code>spring-boot-starter-jetty</code>要么<code>spring-boot-starter-undertow</code>代替。</p>
</li>
<li>
<p>对于反应堆应用， <code>spring-boot-starter-webflux</code>通过包含来包括Reactor Netty <code>spring-boot-starter-reactor-netty</code> ，但您可以使用<code>spring-boot-starter-tomcat</code> ， <code>spring-boot-starter-jetty</code> ， 要么<code>spring-boot-starter-undertow</code>代替。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>切换到其他HTTP服务器时，除了包括所需的依赖关系之外，还需要排除默认的依赖关系。Spring Boot为HTTP服务器提供了单独的启动器，以帮助简化此过程。</p>
</div>
<div class="paragraph">
<p>以下Maven示例显示了如何排除Tomcat并包括Spring MVC的Jetty：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;properties&gt;
    &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;
&lt;/properties&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;!-- Exclude the Tomcat dependency --&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;!-- Use Jetty instead --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Servlet API的版本已被覆盖，因为与Tomcat 9和Undertow 2.0不同，Jetty 9.4不支持Servlet 4.0。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下Gradle示例显示了如何排除Netty并包括Spring WebFlux的Undertow：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">configurations {
    // exclude Reactor Netty
    compile.exclude module: 'spring-boot-starter-reactor-netty'
}

dependencies {
    compile 'org.springframework.boot:spring-boot-starter-webflux'
    // Use Undertow instead
    compile 'org.springframework.boot:spring-boot-starter-undertow'
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>spring-boot-starter-reactor-netty</code>需要使用<code>WebClient</code>类，因此即使您需要包括其他HTTP服务器，也可能需要保持对Netty的依赖。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-disable-web-server"><a class="anchor" href="#howto-disable-web-server"></a> 3.2。禁用Web服务器</h3>
<div class="paragraph">
<p>如果您的类路径包含启动Web服务器所需的位，则Spring Boot将自动启动它。要禁用此行为，请配置<code>WebApplicationType</code>在你的<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.main.web-application-type=none</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-change-the-http-port"><a class="anchor" href="#howto-change-the-http-port"></a> 3.3。更改HTTP端口</h3>
<div class="paragraph">
<p>在独立应用程序中，主HTTP端口默认为<code>8080</code>但是可以设置<code>server.port</code> （例如，在<code>application.properties</code>或作为系统属性）。多亏了轻松的绑定<code>Environment</code>值，您也可以使用<code>SERVER_PORT</code> （例如，作为OS环境变量）。</p>
</div>
<div class="paragraph">
<p>要完全关闭HTTP端点，但仍要创建一个<code>WebApplicationContext</code> ， 使用<code>server.port=-1</code> （这样做有时对测试很有用）。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-customizing-embedded-containers">spring-boot-features.html</a> ”，或<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>源代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-user-a-random-unassigned-http-port"><a class="anchor" href="#howto-user-a-random-unassigned-http-port"></a> 3.4。使用随机未分配的HTTP端口</h3>
<div class="paragraph">
<p>要扫描空闲端口（使用操作系统本机来防止冲突），请使用<code>server.port=0</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-discover-the-http-port-at-runtime"><a class="anchor" href="#howto-discover-the-http-port-at-runtime"></a> 3.5。在运行时发现HTTP端口</h3>
<div class="paragraph">
<p>您可以从日志输出或从服务器访问服务器正在运行的端口。 <code>ServletWebServerApplicationContext</code>通过其<code>WebServer</code> 。最好的方法是确保已将其初始化，然后添加一个<code>@Bean</code>类型的<code>ApplicationListener<ServletWebServerInitializedEvent></code>并在发布事件后将其从事件中拉出。</p>
</div>
<div class="paragraph">
<p>使用的测试<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>也可以使用以下命令将实际端口注入字段<code>@LocalServerPort</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)
public class MyWebIntegrationTests {

    @Autowired
    ServletWebServerApplicationContext server;

    @LocalServerPort
    int port;

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@LocalServerPort</code>是用于的元注释<code>@Value("${local.server.port}")</code> 。不要尝试在常规应用程序中注入端口。如我们所见，仅在初始化容器之后才设置该值。与测试相反，应早处理应用程序代码回调（在实际可用该值之前）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="how-to-enable-http-response-compression"><a class="anchor" href="#how-to-enable-http-response-compression"></a> 3.6。启用HTTP响应压缩</h3>
<div class="paragraph">
<p>Jetty，Tomcat和Undertow支持HTTP响应压缩。可以在<code>application.properties</code> ， 如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.compression.enabled=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，响应的长度必须至少为2048个字节才能执行压缩。您可以通过设置<code>server.compression.min-response-size</code>属性。</p>
</div>
<div class="paragraph">
<p>默认情况下，仅当响应的内容类型为以下之一时，它们才被压缩：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>text/html</code></p>
</li>
<li>
<p><code>text/xml</code></p>
</li>
<li>
<p><code>text/plain</code></p>
</li>
<li>
<p><code>text/css</code></p>
</li>
<li>
<p><code>text/javascript</code></p>
</li>
<li>
<p><code>application/javascript</code></p>
</li>
<li>
<p><code>application/json</code></p>
</li>
<li>
<p><code>application/xml</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过设置<code>server.compression.mime-types</code>属性。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-ssl"><a class="anchor" href="#howto-configure-ssl"></a> 3.7。配置SSL</h3>
<div class="paragraph">
<p>可以通过设置各种来声明性地配置SSL <code>server.ssl.*</code>属性，通常在<code>application.properties</code>要么<code>application.yml</code> 。以下示例显示了在<code>application.properties</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.port=8443
server.ssl.key-store=classpath:keystore.jks
server.ssl.key-store-password=secret
server.ssl.key-password=another-secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/server/Ssl.java"><code>Ssl</code></a>有关所有受支持属性的详细信息。</p>
</div>
<div class="paragraph">
<p>使用前面示例这样的配置意味着应用程序不再在端口8080上支持纯HTTP连接器。Spring Boot不支持通过以下方式同时配置HTTP连接器和HTTPS连接器<code>application.properties</code> 。如果要同时拥有两者，则需要以编程方式配置其中之一。我们建议使用<code>application.properties</code>配置HTTPS，因为HTTP连接器是两者中以编程方式配置的较容易方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-http2"><a class="anchor" href="#howto-configure-http2"></a> 3.8。配置HTTP / 2</h3>
<div class="paragraph">
<p>您可以使用以下命令在Spring Boot应用程序中启用HTTP / 2支持： <code>server.http2.enabled</code>配置属性。该支持取决于所选的Web服务器和应用程序环境，因为JDK8不立即支持该协议。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Boot不支持<code>h2c</code> ，是HTTP / 2协议的明文版本。因此，您必须先<a href="#howto-configure-ssl">配置SSL</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="howto-configure-http2-undertow"><a class="anchor" href="#howto-configure-http2-undertow"></a> 3.8.1。带有Undertow的HTTP / 2</h4>
<div class="paragraph">
<p>从Undertow 1.4.0+开始，在JDK8上没有任何其他要求就支持HTTP / 2。</p>
</div>
</div>
<div class="sect3">
<h4 id="howto-configure-http2-jetty"><a class="anchor" href="#howto-configure-http2-jetty"></a> 3.8.2。HTTP / 2与码头</h4>
<div class="paragraph">
<p>从Jetty 9.4.8开始， <a href="https://www.conscrypt.org/">Conscrypt库</a>还支持HTTP / 2。要启用该支持，您的应用程序需要具有两个附加依赖项： <code>org.eclipse.jetty:jetty-alpn-conscrypt-server</code>和<code>org.eclipse.jetty.http2:http2-server</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="howto-configure-http2-tomcat"><a class="anchor" href="#howto-configure-http2-tomcat"></a> 3.8.3。Tomcat的HTTP / 2</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot随Tomcat 9.0.x一起提供，当使用JDK 9或更高版本时，Tomcat 9.0.x支持HTTP / 2。另外，如果JDK 8可以使用HTTP / 2， <code>libtcnative</code>库及其依赖项安装在主机操作系统上。</p>
</div>
<div class="paragraph">
<p>如果没有，则必须使库文件夹可用于JVM库路径。您可以使用JVM参数（例如<code>-Djava.library.path=/usr/local/opt/tomcat-native/lib</code> 。有关更多信息，请参见<a href="https://tomcat.apache.org/tomcat-9.0-doc/apr.html">Tomcat官方文档</a> 。</p>
</div>
<div class="paragraph">
<p>在没有该本机支持的情况下，在JDK 8上启动Tomcat 9.0.x会记录以下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR 8787 --- [           main] o.a.coyote.http11.Http11NioProtocol      : The upgrade handler [org.apache.coyote.http2.Http2Protocol] for [h2] only supports upgrade via ALPN but has been configured for the ["https-jsse-nio-8443"] connector that does not support ALPN.</pre>
</div>
</div>
<div class="paragraph">
<p>此错误不是致命错误，并且该应用程序仍以HTTP / 1.1 SSL支持开头。</p>
</div>
</div>
<div class="sect3">
<h4 id="howto-configure-http2-netty"><a class="anchor" href="#howto-configure-http2-netty"></a> 3.8.4。HTTP / 2和Reactor Netty</h4>
<div class="paragraph">
<p>的<code>spring-boot-webflux-starter</code>默认使用Reactor Netty作为服务器。使用JDK 9或更高版本的JDK支持，可以将Reactor Netty配置为HTTP / 2。对于JDK 8环境或最佳运行时性能，此服务器还支持带有本机库的HTTP / 2。为此，您的应用程序需要具有其他依赖关系。</p>
</div>
<div class="paragraph">
<p>Spring Boot管理版本的<code>io.netty:netty-tcnative-boringssl-static</code> “超级罐”，包含所有平台的本机库。开发人员可以选择使用分类器仅导入所需的依赖项（请参阅<a href="https://netty.io/wiki/forked-tomcat-native.html">Netty官方文档</a> ）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-webserver"><a class="anchor" href="#howto-configure-webserver"></a> 3.9。配置Web服务器</h3>
<div class="paragraph">
<p>通常，您首先应该考虑使用许多可用的配置密钥之一，并通过在您的服务器中添加新条目来自定义Web服务器。 <code>application.properties</code> （要么<code>application.yml</code>或环境等。请参阅“ <a href="#howto-discover-build-in-options-for-external-properties">发现外部属性的内置选项</a> ”。的<code>server.*</code>命名空间在这里非常有用，它包括诸如<code>server.tomcat.*</code> ， <code>server.jetty.*</code>以及其他特定于服务器的功能。请参阅<a href="appendix-application-properties.html#common-application-properties">appendix-application-properties.html</a>的列表。</p>
</div>
<div class="paragraph">
<p>前面的部分已经介绍了许多常见的用例，例如压缩，SSL或HTTP / 2。但是，如果您的用例不存在配置密钥，则应查看<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/api//org/springframework/boot/web/server/WebServerFactoryCustomizer.html"><code>WebServerFactoryCustomizer</code></a> 。您可以声明一个这样的组件，并访问与您选择的服务器相关的工厂：您应该为所选服务器（Tomcat，Jetty，Reactor Netty，Undertow）和所选Web堆栈（Servlet或Reactive）选择变体。</p>
</div>
<div class="paragraph">
<p>以下示例适用于带有<code>spring-boot-starter-web</code> （Servlet堆栈）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyTomcatWebServerCustomizer
        implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; {

    @Override
    public void customize(TomcatServletWebServerFactory factory) {
        // customize the factory here
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，Spring Boot还提供：</p>
</div>
<table id="howto-configure-webserver-customizers" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:40%">
<col style="width:40%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器</th>
<th class="tableblock halign-left valign-top">Servlet堆栈</th>
<th class="tableblock halign-left valign-top">反应堆</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">雄猫</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatServletWebServerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatReactiveWebServerFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">码头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JettyServletWebServerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JettyReactiveWebServerFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">底拖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UndertowServletWebServerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UndertowReactiveWebServerFactory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">反应堆</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不适用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NettyReactiveWebServerFactory</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>获得访问权限后<code>WebServerFactory</code> ，您通常可以向其添加定制程序以配置特定的部分，例如连接器，服务器资源或服务器本身-全部使用服务器特定的API。</p>
</div>
<div class="paragraph">
<p>作为最后的选择，您也可以声明自己的<code>WebServerFactory</code>组件，它将覆盖Spring Boot提供的组件。在这种情况下，您不能依赖于<code>server</code>命名空间了。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-add-a-servlet-filter-or-listener"><a class="anchor" href="#howto-add-a-servlet-filter-or-listener"></a> 3.10。将Servlet，过滤器或侦听器添加到应用程序</h3>
<div class="paragraph">
<p>在Servlet堆栈应用程序中，即<code>spring-boot-starter-web</code> ，有两种添加方式<code>Servlet</code> ， <code>Filter</code> ， <code>ServletContextListener</code> ，以及Servlet API支持的应用程序的其他侦听器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#howto-add-a-servlet-filter-or-listener-as-spring-bean">使用Spring Bean添加Servlet，过滤器或侦听器</a></p>
</li>
<li>
<p><a href="#howto-add-a-servlet-filter-or-listener-using-scanning">使用类路径扫描添加Servlet，过滤器和侦听器</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="howto-add-a-servlet-filter-or-listener-as-spring-bean"><a class="anchor" href="#howto-add-a-servlet-filter-or-listener-as-spring-bean"></a> 3.10.1。使用Spring Bean添加Servlet，过滤器或侦听器</h4>
<div class="paragraph">
<p>要添加一个<code>Servlet</code> ， <code>Filter</code>或Servlet <code>*Listener</code>通过使用Spring bean，您必须提供一个<code>@Bean</code>它的定义。当您要注入配置或依赖项时，这样做非常有用。但是，您必须非常小心，以免引起过多其他bean的急切初始化，因为必须在应用程序生命周期的早期就将它们安装在容器中。（例如，让它们依赖于您<code>DataSource</code>或JPA配置。）您可以通过在首次使用时而不是在初始化时延迟初始化Bean来解决此类限制。</p>
</div>
<div class="paragraph">
<p>如果是<code>Filters</code>和<code>Servlets</code> ，您还可以通过添加一个<code>FilterRegistrationBean</code>或一个<code>ServletRegistrationBean</code>代替或补充基础组件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果不<code>dispatcherType</code>在过滤器注册中指定， <code>REQUEST</code>用来。这符合Servlet规范的默认调度程序类型。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>像其他任何Spring bean一样，您可以定义Servlet过滤器bean的顺序。请确保检查“ <a href="spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners-beans">spring-boot-features.html</a> ”部分。</p>
</div>
<div class="sect4">
<h5 id="howto-disable-registration-of-a-servlet-or-filter"><a class="anchor" href="#howto-disable-registration-of-a-servlet-or-filter"></a>禁用Servlet或过滤器的注册</h5>
<div class="paragraph">
<p><a href="#howto-add-a-servlet-filter-or-listener-as-spring-bean">如前所述</a> ，任何<code>Servlet</code>要么<code>Filter</code> bean会自动向servlet容器注册。禁用特定的注册<code>Filter</code>要么<code>Servlet</code> bean，为其创建一个注册bean并将其标记为禁用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public FilterRegistrationBean registration(MyFilter filter) {
    FilterRegistrationBean registration = new FilterRegistrationBean(filter);
    registration.setEnabled(false);
    return registration;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="howto-add-a-servlet-filter-or-listener-using-scanning"><a class="anchor" href="#howto-add-a-servlet-filter-or-listener-using-scanning"></a> 3.10.2。使用类路径扫描添加Servlet，过滤器和侦听器</h4>
<div class="paragraph">
<p><code>@WebServlet</code> ， <code>@WebFilter</code>和<code>@WebListener</code>注释的类可以通过注释一个<code>@Configuration</code>上课<code>@ServletComponentScan</code>并指定包含要注册的组件的软件包。默认， <code>@ServletComponentScan</code>从带注释的类的包中扫描。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-accesslogs"><a class="anchor" href="#howto-configure-accesslogs"></a> 3.11。配置访问日志</h3>
<div class="paragraph">
<p>可以通过它们各自的名称空间为Tomcat，Undertow和Jetty配置访问日志。</p>
</div>
<div class="paragraph">
<p>例如，以下设置使用<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging">自定义模式</a>记录对Tomcat的访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.tomcat.basedir=my-tomcat
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.pattern=%t %a "%r" %s (%D ms)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">日志的默认位置是<code>logs</code>相对于Tomcat基本目录的目录。默认情况下， <code>logs</code> directory是一个临时目录，因此您可能需要修复Tomcat的基本目录或为日志使用绝对路径。在前面的示例中，日志位于<code>my-tomcat/logs</code>相对于应用程序的工作目录。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以用类似的方式配置Undertow的访问日志，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.undertow.accesslog.enabled=true
server.undertow.accesslog.pattern=%t %a "%r" %s (%D ms)</code></pre>
</div>
</div>
<div class="paragraph">
<p>日志存储在<code>logs</code>相对于应用程序工作目录的目录。您可以通过设置<code>server.undertow.accesslog.dir</code>属性。</p>
</div>
<div class="paragraph">
<p>最后，Jetty的访问日志也可以配置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.jetty.accesslog.enabled=true
server.jetty.accesslog.filename=/var/log/jetty-access.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，日志重定向到<code>System.err</code> 。有关更多详细信息，请参见<a href="https://www.eclipse.org/jetty/documentation/9.4.22.v20191022/configuring-jetty-request-logs.html">Jetty文档</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-tomcat-behind-a-proxy-server"><a class="anchor" href="#howto-use-tomcat-behind-a-proxy-server"></a> 3.12。在前端代理服务器后面运行</h3>
<div class="paragraph">
<p>您的应用程序可能需要发送<code>302</code>使用绝对链接将内容重定向或呈现回自身。当在代理后面运行时，调用者需要链接到代理，而不要链接到托管您的应用的计算机的物理地址。通常，此类情况是通过与代理之间的合同来处理的，该代理添加了标头以告诉后端如何构造与自身的链接。</p>
</div>
<div class="paragraph">
<p>如果代理添加常规<code>X-Forwarded-For</code>和<code>X-Forwarded-Proto</code>标头（大多数代理服务器都这样做），则绝对链接应正确呈现（提供） <code>server.forward-headers-strategy</code>被设定为<code>NATIVE</code>要么<code>FRAMEWORK</code>在你的<code>application.properties</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的应用程序在Cloud Foundry或Heroku中运行，则<code>server.forward-headers-strategy</code>属性默认为<code>NATIVE</code> 。在所有其他情况下，默认为<code>NONE</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="howto-customize-tomcat-behind-a-proxy-server"><a class="anchor" href="#howto-customize-tomcat-behind-a-proxy-server"></a> 3.12.1。自定义Tomcat的代理配置</h4>
<div class="paragraph">
<p>如果使用Tomcat，则可以另外配置用于承载“转发”信息的标头名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>server.tomcat.remote-ip-header=x-your-remote-ip-header
server.tomcat.protocol-header=x-your-protocol-header</pre>
</div>
</div>
<div class="paragraph">
<p>Tomcat还配置有默认正则表达式，该正则表达式与要信任的内部代理匹配。默认情况下， <code>10/8</code> ， <code>192.168/16</code> ， <code>169.254/16</code>和<code>127/8</code>被信任。您可以通过添加以下条目来自定义阀门的配置<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>server.tomcat.internal-proxies=192\\.168\\.\\d{1,3}\\.\\d{1,3}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">仅当使用属性文件进行配置时，才需要双反斜杠。如果您使用YAML，则单个反斜杠就足够了，并且与上一个示例中显示的值相等的值为<code>192\.168\.\d{1,3}\.\d{1,3}</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以通过设置以下选项来信任所有代理<code>internal-proxies</code>清空（但在生产中请勿这样做）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以完全控制Tomcat的配置<code>RemoteIpValve</code>通过关闭自动开关（为此，请设置<code>server.forward-headers-strategy=NONE</code> ），并在<code>TomcatServletWebServerFactory</code> bean 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-enable-multiple-connectors-in-tomcat"><a class="anchor" href="#howto-enable-multiple-connectors-in-tomcat"></a> 3.13。使用Tomcat启用多个连接器</h3>
<div class="paragraph">
<p>您可以添加一个<code>org.apache.catalina.connector.Connector</code>到<code>TomcatServletWebServerFactory</code> ，它可以允许多个连接器，包括HTTP和HTTPS连接器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ServletWebServerFactory servletContainer() {
    TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
    tomcat.addAdditionalTomcatConnectors(createSslConnector());
    return tomcat;
}

private Connector createSslConnector() {
    Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
    Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();
    try {
        File keystore = new ClassPathResource("keystore").getFile();
        File truststore = new ClassPathResource("keystore").getFile();
        connector.setScheme("https");
        connector.setSecure(true);
        connector.setPort(8443);
        protocol.setSSLEnabled(true);
        protocol.setKeystoreFile(keystore.getAbsolutePath());
        protocol.setKeystorePass("changeit");
        protocol.setTruststoreFile(truststore.getAbsolutePath());
        protocol.setTruststorePass("changeit");
        protocol.setKeyAlias("apitester");
        return connector;
    }
    catch (IOException ex) {
        throw new IllegalStateException("can't access keystore: [" + "keystore"
                + "] or truststore: [" + "keystore" + "]", ex);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-tomcat-legacycookieprocessor"><a class="anchor" href="#howto-use-tomcat-legacycookieprocessor"></a> 3.14。使用Tomcat的LegacyCookieProcessor</h3>
<div class="paragraph">
<p>默认情况下，Spring Boot使用的嵌入式Tomcat不支持Cookie格式的“版本0”，因此您可能会看到以下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalArgumentException: An invalid character [32] was present in the Cookie value</pre>
</div>
</div>
<div class="paragraph">
<p>如果有可能，您应该考虑将代码更新为仅存储符合以后Cookie规范的值。但是，如果您无法更改Cookie的编写方式，则可以将Tomcat配置为使用<code>LegacyCookieProcessor</code> 。切换到<code>LegacyCookieProcessor</code> ，使用<code>WebServerFactoryCustomizer</code>添加一个<code>TomcatContextCustomizer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; cookieProcessorCustomizer() {
    return (factory) -&gt; factory
            .addContextCustomizers((context) -&gt; context.setCookieProcessor(new LegacyCookieProcessor()));
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-enable-tomcat-mbean-registry"><a class="anchor" href="#howto-enable-tomcat-mbean-registry"></a> 3.15。启用Tomcat的MBean注册表</h3>
<div class="paragraph">
<p>默认情况下，嵌入式Tomcat的MBean注册表是禁用的。这样可以最大程度地减少Tomcat的内存占用。例如，如果您想使用Tomcat的MBean，以便可以通过Micrometer公开它们，则必须使用<code>server.tomcat.mbeanregistry.enabled</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.tomcat.mbeanregistry.enabled=true</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-enable-multiple-listeners-in-undertow"><a class="anchor" href="#howto-enable-multiple-listeners-in-undertow"></a> 3.16。使用Undertow启用多个侦听器</h3>
<div class="paragraph">
<p>添加一个<code>UndertowBuilderCustomizer</code>到<code>UndertowServletWebServerFactory</code>并将侦听器添加到<code>Builder</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public UndertowServletWebServerFactory servletWebServerFactory() {
    UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();
    factory.addBuilderCustomizers(new UndertowBuilderCustomizer() {

        @Override
        public void customize(Builder builder) {
            builder.addHttpListener(8080, "0.0.0.0");
        }

    });
    return factory;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-create-websocket-endpoints-using-serverendpoint"><a class="anchor" href="#howto-create-websocket-endpoints-using-serverendpoint"></a> 3.17。使用@ServerEndpoint创建WebSocket端点</h3>
<div class="paragraph">
<p>如果要使用<code>@ServerEndpoint</code>在使用嵌入式容器的Spring Boot应用程序中，必须声明一个<code>ServerEndpointExporter</code><code>@Bean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ServerEndpointExporter serverEndpointExporter() {
    return new ServerEndpointExporter();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上例中显示的Bean注册了<code>@ServerEndpoint</code>带有基础WebSocket容器的带注释的Bean。部署到独立Servlet容器时，此角色由Servlet容器初始化程序执行，并且<code>ServerEndpointExporter</code>不需要bean。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-spring-mvc"><a class="anchor" href="#howto-spring-mvc"></a> 4。春季MVC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot有许多启动器，其中包括Spring MVC。请注意，一些入门者包括对Spring MVC的依赖，而不是直接包含它。本部分回答有关Spring MVC和Spring Boot的常见问题。</p>
</div>
<div class="sect2">
<h3 id="howto-write-a-json-rest-service"><a class="anchor" href="#howto-write-a-json-rest-service"></a> 4.1。编写JSON REST服务</h3>
<div class="paragraph">
<p>任何 Spring <code>@RestController</code>默认情况下，只要Jackson2在类路径上，Spring Boot应用程序中的XML就应该呈现JSON响应，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class MyController {

    @RequestMapping("/thing")
    public MyThing thing() {
            return new MyThing();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要<code>MyThing</code>可以由Jackson2序列化（对于普通POJO或Groovy对象为true），然后<code><a href="http://localhost:8080/thing" class="bare">localhost:8080/thing</a></code>默认情况下会为其提供JSON表示形式。请注意，在浏览器中，有时可能会看到XML响应，因为浏览器倾向于发送更喜欢XML的接受标头。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-write-an-xml-rest-service"><a class="anchor" href="#howto-write-an-xml-rest-service"></a> 4.2。编写XML REST服务</h3>
<div class="paragraph">
<p>如果您具有Jackson XML扩展名（ <code>jackson-dataformat-xml</code> ）上的类路径，您可以使用它来呈现XML响应。我们用于JSON的先前示例可以正常工作。要使用Jackson XML渲染器，请将以下依赖项添加到您的项目中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果Jackson的XML扩展名不可用，而JAXB可用，则XML的呈现需要满足以下条件： <code>MyThing</code>注释为<code>@XmlRootElement</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@XmlRootElement
public class MyThing {
    private String name;
    // .. getters and setters
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JAXB仅可与Java 8一起使用。如果您使用的是较新的Java版本，请在项目中添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要使服务器呈现XML而不是JSON，您可能必须发送一个<code>Accept: text/xml</code>标头（或使用浏览器）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-customize-the-jackson-objectmapper"><a class="anchor" href="#howto-customize-the-jackson-objectmapper"></a> 4.3。自定义Jackson ObjectMapper</h3>
<div class="paragraph">
<p>Spring MVC（客户端和服务器端）使用<code>HttpMessageConverters</code>在HTTP交换中协商内容转换。如果Jackson在类路径中，则您已经获得了以下提供的默认转换器<code>Jackson2ObjectMapperBuilder</code> ，系统会自动为您配置一个实例。</p>
</div>
<div class="paragraph">
<p>的<code>ObjectMapper</code> （要么<code>XmlMapper</code> for Jackson XML converter）实例（默认创建）具有以下自定义属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code>被禁用</p>
</li>
<li>
<p><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>被禁用</p>
</li>
<li>
<p><code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>被禁用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot还具有一些功能，可以更轻松地自定义此行为。</p>
</div>
<div class="paragraph">
<p>您可以配置<code>ObjectMapper</code>和<code>XmlMapper</code>使用环境的实例。杰克逊提供了一套广泛的简单的开/关功能，可用于配置其处理的各个方面。在六个枚举（在Jackson中）中描述了这些功能，这些枚举映射到环境中的属性：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">枚举</th>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">价值观</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.databind.DeserializationFeature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.jackson.deserialization.<feature_name></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> ，<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.core.JsonGenerator.Feature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.jackson.generator.<feature_name></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> ，<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.databind.MapperFeature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.jackson.mapper.<feature_name></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> ，<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.core.JsonParser.Feature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.jackson.parser.<feature_name></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> ，<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.databind.SerializationFeature</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.jackson.serialization.<feature_name></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> ，<code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>com.fasterxml.jackson.annotation.JsonInclude.Include</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.jackson.default-property-inclusion</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>always</code> ， <code>non_null</code> ， <code>non_absent</code> ， <code>non_default</code> ，<code>non_empty</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>例如，要启用漂亮的打印，请设置<code>spring.jackson.serialization.indent_output=true</code> 。请注意，由于使用了<a href="spring-boot-features.html#boot-features-external-config-relaxed-binding">宽松的绑定</a> ， <code>indent_output</code>不必匹配相应枚举常量的大小写，即<code>INDENT_OUTPUT</code> 。</p>
</div>
<div class="paragraph">
<p>这种基于环境的配置适用于自动配置<code>Jackson2ObjectMapperBuilder</code> Bean，并适用于使用该构建器创建的任何映射器，包括自动配置的<code>ObjectMapper</code> bean 。</p>
</div>
<div class="paragraph">
<p>上下文的<code>Jackson2ObjectMapperBuilder</code>可以由一个或多个自定义<code>Jackson2ObjectMapperBuilderCustomizer</code>beans。可以对此类定制器bean进行排序（Boot自己的定制器的顺序为0），从而可以在Boot定制之前和之后应用其他定制。</p>
</div>
<div class="paragraph">
<p>任何类型的 bean <code>com.fasterxml.jackson.databind.Module</code>已自动向自动配置注册<code>Jackson2ObjectMapperBuilder</code>并应用于任何<code>ObjectMapper</code>它创建的实例。当您向应用程序中添加新功能时，这提供了一种用于贡献自定义模块的全局机制。</p>
</div>
<div class="paragraph">
<p>如果要替换默认值<code>ObjectMapper</code>完全定义一个<code>@Bean</code>该类型并将其标记为<code>@Primary</code>或者，如果您更喜欢基于构建器的方法，请定义一个<code>Jackson2ObjectMapperBuilder</code><code>@Bean</code> 。请注意，无论哪种情况，这样做都会禁用<code>ObjectMapper</code> 。</p>
</div>
<div class="paragraph">
<p>如果您提供任何<code>@Beans</code>类型的<code>MappingJackson2HttpMessageConverter</code> ，它们替换了MVC配置中的默认值。另外，类型的便捷bean <code>HttpMessageConverters</code>提供（如果使用默认的MVC配置，则始终可用）。它提供了一些有用的方法来访问默认的和用户增强的消息转换器。</p>
</div>
<div class="paragraph">
<p>请参阅“ <a href="#howto-customize-the-responsebody-rendering">自定义@ResponseBody渲染</a> ”部分和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>源代码以获取更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-customize-the-responsebody-rendering"><a class="anchor" href="#howto-customize-the-responsebody-rendering"></a> 4.4。自定义@ResponseBody渲染</h3>
<div class="paragraph">
<p>春季用途<code>HttpMessageConverters</code>渲染<code>@ResponseBody</code> （或来自<code>@RestController</code> ）。您可以通过在Spring Boot上下文中添加适当类型的bean来贡献额外的转换器。如果您添加的Bean的类型无论如何都是默认包含的（例如<code>MappingJackson2HttpMessageConverter</code> （用于JSON转换），它将替换默认值。类型的便捷bean <code>HttpMessageConverters</code>是提供的，如果使用默认的MVC配置，则始终可用。它提供了一些有用的方法来访问默认的和用户增强的消息转换器（例如，如果您想将它们手动注入到自定义窗口中，可能会很有用。 <code>RestTemplate</code> ）。</p>
</div>
<div class="paragraph">
<p>与正常的MVC用法一样， <code>WebMvcConfigurer</code>您提供的Bean也可以通过覆盖<code>configureMessageConverters</code>方法。但是，与普通的MVC不同，您只能提供所需的其他转换器（因为Spring Boot使用相同的机制来提供其默认值）。最后，如果您通过提供自己的选项退出Spring Boot默认的MVC配置<code>@EnableWebMvc</code>配置，您可以完全控制并通过使用<code>getMessageConverters</code>从<code>WebMvcConfigurationSupport</code> 。</p>
</div>
<div class="paragraph">
<p>见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a>源代码以获取更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-multipart-file-upload-configuration"><a class="anchor" href="#howto-multipart-file-upload-configuration"></a> 4.5。处理分段文件上传</h3>
<div class="paragraph">
<p>Spring Boot包含Servlet 3 <code>javax.servlet.http.Part</code>支持上传文件的API。默认情况下，Spring Boot用单个请求将Spring MVC配置为每个文件最大大小为1MB，最大文件数据为10MB。您可以覆盖这些值，即中间数据的存储位置（例如， <code>/tmp</code>目录），以及使用以下命令公开的属性将数据刷新到磁盘的阈值<code>MultipartProperties</code>类。例如，如果要指定文件不受限制，请设置<code>spring.servlet.multipart.max-file-size</code>财产<code>-1</code> 。</p>
</div>
<div class="paragraph">
<p>当您希望将多部分编码文件数据作为文件接收时，多部分支持会很有帮助。 <code>@RequestParam</code> -带注释的参数类型<code>MultipartFile</code>在Spring MVC控制器处理程序方法中。</p>
</div>
<div class="paragraph">
<p>见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/MultipartAutoConfiguration.java"><code>MultipartAutoConfiguration</code></a>来源以获取更多详细信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">建议使用容器的内置支持进行分段上传，而不要引入其他依赖项，例如Apache Commons File Upload。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-switch-off-the-spring-mvc-dispatcherservlet"><a class="anchor" href="#howto-switch-off-the-spring-mvc-dispatcherservlet"></a> 4.6。关闭Spring MVC DispatcherServlet</h3>
<div class="paragraph">
<p>默认情况下，所有内容均从应用程序的根目录提供（ <code>/</code> ）。如果您希望映射到其他路径，则可以如下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.mvc.servlet.path=/acme</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您还有其他servlet，则可以声明一个<code>@Bean</code>类型的<code>Servlet</code>要么<code>ServletRegistrationBean</code>对于每个，Spring Boot将透明地将它们注册到容器。由于servlet是通过这种方式注册的，因此可以将它们映射到servlet的子上下文。 <code>DispatcherServlet</code>而不调用它。</p>
</div>
<div class="paragraph">
<p>配置<code>DispatcherServlet</code>自己是不寻常的，但如果您确实需要这样做， <code>@Bean</code>类型的<code>DispatcherServletPath</code>还必须提供以提供自定义路径<code>DispatcherServlet</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-switch-off-default-mvc-configuration"><a class="anchor" href="#howto-switch-off-default-mvc-configuration"></a> 4.7。关闭默认的MVC配置</h3>
<div class="paragraph">
<p>完全控制MVC配置的最简单方法是提供您自己的<code>@Configuration</code>与<code>@EnableWebMvc</code>注解。这样做会使您掌握所有MVC配置。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-customize-view-resolvers"><a class="anchor" href="#howto-customize-view-resolvers"></a> 4.8。自定义ViewResolvers</h3>
<div class="paragraph">
<p>一种<code>ViewResolver</code>是Spring MVC的核心组件，它在<code>@Controller</code>到实际<code>View</code>实现。注意<code>ViewResolvers</code>主要用于UI应用程序，而不是REST风格的服务（ <code>View</code>不用于渲染<code>@ResponseBody</code> ）。有许多实现<code>ViewResolver</code>可供选择，而Spring本身并没有决定您应该使用哪个。另一方面，Spring Boot会根据您在类路径和应用程序上下文中找到的内容为您安装一个或两个。的<code>DispatcherServlet</code>使用在应用程序上下文中找到的所有解析器，依次尝试每个解析器，直到获得结果。如果添加自己的解析器，则必须知道其顺序以及解析器的添加位置。</p>
</div>
<div class="paragraph">
<p><code>WebMvcAutoConfiguration</code>添加以下内容<code>ViewResolvers</code>根据您的情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个<code>InternalResourceViewResolver</code>名为“ defaultViewResolver”。这是通过使用<code>DefaultServlet</code> （如果使用静态资源和JSP页面，则包括这些资源）。它在视图名称上应用前缀和后缀，然后在Servlet上下文中查找具有该路径的物理资源（默认值均为空，但可通过以下方式进行外部配置访问<code>spring.mvc.view.prefix</code>和<code>spring.mvc.view.suffix</code> ）。您可以通过提供相同类型的bean覆盖它。</p>
</li>
<li>
<p>一种<code>BeanNameViewResolver</code>名为“ beanNameViewResolver”。这是视图解析器链的有用成员，可以拾取与名称相同的所有bean。 <code>View</code>正在解决。不必重写或替换它。</p>
</li>
<li>
<p>一种<code>ContentNegotiatingViewResolver</code>仅<strong>在</strong>实际上存在类型<strong>为的</strong> bean时才添加名为“ viewResolver”的<code>View</code>当下。这是一个“主”解析器，委派给所有其他解析器，并尝试查找与客户端发送的“ Accept” HTTP标头匹配的内容。有一个<a href="https://spring.io/blog/2013/06/03/content-negotiation-using-views">关于</a>的有用<a href="https://spring.io/blog/2013/06/03/content-negotiation-using-views">博客<code>ContentNegotiatingViewResolver</code></a>您可能想学习以了解更多信息，还可以查看源代码以获取详细信息。您可以关闭自动配置<code>ContentNegotiatingViewResolver</code>通过定义一个名为“ viewResolver”的bean。</p>
</li>
<li>
<p>如果您使用Thymeleaf，则还有一个<code>ThymeleafViewResolver</code>名为“ thymeleafViewResolver”。它通过在视图名称前后加上前缀和后缀来查找资源。前缀是<code>spring.thymeleaf.prefix</code> ，后缀是<code>spring.thymeleaf.suffix</code> 。前缀和后缀的值分别默认为“ classpath：/ templates /”和“ .html”。您可以覆盖<code>ThymeleafViewResolver</code>通过提供同名的bean。</p>
</li>
<li>
<p>如果您使用FreeMarker，那么您还有一个<code>FreeMarkerViewResolver</code>名为“ freeMarkerViewResolver”。它在加载程序路径（已外部化为<code>spring.freemarker.templateLoaderPath</code>并且默认值是'classpath：/ templates /'），方法是在视图名称前加上前缀和后缀。前缀被外部化为<code>spring.freemarker.prefix</code> ，后缀被外部化为<code>spring.freemarker.suffix</code> 。前缀和后缀的默认值分别为空和'.ftlh'。您可以覆盖<code>FreeMarkerViewResolver</code>通过提供同名的bean。</p>
</li>
<li>
<p>如果您使用Groovy模板（实际上，如果<code>groovy-templates</code>在您的类路径上），您也有一个<code>GroovyMarkupViewResolver</code>名为“ groovyMarkupViewResolver”。它通过在视图名称周围加上前缀和后缀（扩展为<code>spring.groovy.template.prefix</code>和<code>spring.groovy.template.suffix</code> ）。前缀和后缀分别具有默认值'classpath：/ templates /'和'.tpl'。您可以覆盖<code>GroovyMarkupViewResolver</code>通过提供同名的bean。</p>
</li>
<li>
<p>如果您使用Moustache，那么您还有一个<code>MustacheViewResolver</code>名为“ mustacheViewResolver”。它通过在视图名称前后加上前缀和后缀来查找资源。前缀是<code>spring.mustache.prefix</code> ，后缀是<code>spring.mustache.suffix</code> 。前缀和后缀的值分别默认为“ classpath：/ templates /”和“ .mustache”。您可以覆盖<code>MustacheViewResolver</code>通过提供同名的bean。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见以下部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java"><code>WebMvcAutoConfiguration</code></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java"><code>ThymeleafAutoConfiguration</code></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java"><code>FreeMarkerAutoConfiguration</code></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java"><code>GroovyTemplateAutoConfiguration</code></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-use-test-with-spring-security"><a class="anchor" href="#howto-use-test-with-spring-security"></a> 5，使用Spring Security进行测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security提供了对以特定用户身份运行测试的支持。例如，下面的代码段中的测试将针对具有<code>ADMIN</code>角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
    mvc
        .perform(get("/"))
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security提供了与Spring MVC Test的全面集成，并且在使用<code>@WebMvcTest</code>切片和<code>MockMvc</code> 。</p>
</div>
<div class="paragraph">
<p>有关Spring Security的测试支持的更多详细信息，请参阅Spring Security的<a href="https://docs.spring.io/spring-security/site/docs/5.2.1.RELEASE/reference/htmlsingle/#test">参考文档</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-jersey"><a class="anchor" href="#howto-jersey"></a> 6。泽西岛</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="howto-jersey-spring-security"><a class="anchor" href="#howto-jersey-spring-security"></a> 6.1。使用Spring Security保护Jersey端点</h3>
<div class="paragraph">
<p>可以使用Spring Security来保护基于Jersey的Web应用程序，其方式与用来保护基于Spring MVC的Web应用程序的方式几乎相同。但是，如果您想在Jersey中使用Spring Security的方法级安全性，则必须配置Jersey以使用<code>setStatus(int)</code>宁可<code>sendError(int)</code> 。这可以防止Jersey在Spring Security有机会向客户端报告身份验证或授权失败之前提交响应。</p>
</div>
<div class="paragraph">
<p>的<code>jersey.config.server.response.setStatusOverSendError</code>属性必须设置为<code>true</code>在应用程序的<code>ResourceConfig</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
        setProperties(Collections.singletonMap("jersey.config.server.response.setStatusOverSendError", true));
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-jersey-alongside-another-web-framework"><a class="anchor" href="#howto-jersey-alongside-another-web-framework"></a> 6.2。与另一个Web框架一起使用Jersey</h3>
<div class="paragraph">
<p>要将Jersey与其他Web框架（例如Spring MVC）一起使用，应对其进行配置，以便它将允许其他框架处理无法处理的请求。首先，将Jersey配置为使用过滤器而不是Servlet，方法是配置<code>spring.jersey.type</code>值为的应用程序属性<code>filter</code> 。其次，配置您的<code>ResourceConfig</code>转发可能导致404的请求，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
        property(ServletProperties.FILTER_FORWARD_ON_404, true);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-http-clients"><a class="anchor" href="#howto-http-clients"></a> 7。HTTP客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了许多可与HTTP客户端一起使用的启动器。本节回答与使用它们有关的问题。</p>
</div>
<div class="sect2">
<h3 id="howto-http-clients-proxy-configuration"><a class="anchor" href="#howto-http-clients-proxy-configuration"></a> 7.1。配置RestTemplate使用代理</h3>
<div class="paragraph">
<p>如<a href="spring-boot-features.html#boot-features-resttemplate-customization">spring-boot-features.html中所述</a> ，您可以使用<code>RestTemplateCustomizer</code>与<code>RestTemplateBuilder</code>建立一个定制的<code>RestTemplate</code> 。建议使用此方法来创建<code>RestTemplate</code>配置为使用代理。</p>
</div>
<div class="paragraph">
<p>代理配置的确切详细信息取决于所使用的基础客户端请求工厂。以下示例配置<code>HttpComponentsClientRequestFactory</code>带着<code>HttpClient</code>对所有主机使用代理的服务器<code>192.168.0.5</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static class ProxyCustomizer implements RestTemplateCustomizer {

    @Override
    public void customize(RestTemplate restTemplate) {
        HttpHost proxy = new HttpHost("proxy.example.com");
        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(new DefaultProxyRoutePlanner(proxy) {

            @Override
            public HttpHost determineProxy(HttpHost target, HttpRequest request, HttpContext context)
                    throws HttpException {
                if (target.getHostName().equals("192.168.0.5")) {
                    return null;
                }
                return super.determineProxy(target, request, context);
            }

        }).build();
        restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-webclient-reactor-netty-customization"><a class="anchor" href="#howto-webclient-reactor-netty-customization"></a> 7.2。配置基于Reactor Netty的WebClient使用的TcpClient</h3>
<div class="paragraph">
<p>当Reactor Netty在类路径上时，基于Reactor Netty <code>WebClient</code>已自动配置。要自定义客户端对网络连接的处理，请提供<code>ClientHttpConnector</code> bean 。以下示例配置了60秒的连接超时并添加了一个<code>ReadTimeoutHandler</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
ClientHttpConnector clientHttpConnector(ReactorResourceFactory resourceFactory) {
    TcpClient tcpClient = TcpClient.create(resourceFactory.getConnectionProvider())
            .runOn(resourceFactory.getLoopResources()).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 60000)
            .doOnConnected((connection) -&gt; connection.addHandlerLast(new ReadTimeoutHandler(60)));
    return new ReactorClientHttpConnector(HttpClient.from(tcpClient));
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">注意使用<code>ReactorResourceFactory</code>用于连接提供程序和事件循环资源。这确保了用于服务器接收请求和客户端发出请求的资源的有效共享。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-logging"><a class="anchor" href="#howto-logging"></a> 8。记录中</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了Commons Logging API（通常由Spring Framework的<code>spring-jcl</code>模块。要使用<a href="https://logback.qos.ch">Logback</a> ，您需要包括它和<code>spring-jcl</code>在类路径上。最简单的方法是通过启动器，这一切都取决于<code>spring-boot-starter-logging</code> 。对于Web应用程序，您只需要<code>spring-boot-starter-web</code> ，因为它暂时依赖于日志记录启动器。如果使用Maven，则以下依赖项会为您添加日志记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot有一个<code>LoggingSystem</code>尝试根据类路径的内容配置日志记录的抽象。如果可以使用Logback，则它是首选。</p>
</div>
<div class="paragraph">
<p>如果您需要对记录进行的唯一更改是设置各种记录器的级别，则可以在<code>application.properties</code>通过使用“ logging.level”前缀，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.org.springframework.web=DEBUG
logging.level.org.hibernate=ERROR</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用“ logging.file.name”来设置要写入日志的文件的位置（除了控制台）。</p>
</div>
<div class="paragraph">
<p>要配置日志记录系统的更细粒度的设置，您需要使用日志记录系统支持的本机配置格式<code>LoggingSystem</code>问题。默认情况下，Spring Boot从系统的默认位置获取本地配置（例如<code>classpath:logback.xml</code> （用于Logback），但是您可以使用以下命令设置配置文件的位置<code>logging.config</code>属性。</p>
</div>
<div class="sect2">
<h3 id="howto-configure-logback-for-logging"><a class="anchor" href="#howto-configure-logback-for-logging"></a> 8.1。配置登录以进行日志记录</h3>
<div class="paragraph">
<p>如果您需要将自定义设置应用到登录之外，可以使用<code>application.properties</code> ，则需要添加标准的logback配置文件。您可以添加一个<code>logback.xml</code>文件到您的类路径的根目录，以供登录后查找。您也可以使用<code>logback-spring.xml</code>如果您想使用<a href="spring-boot-features.html#boot-features-logback-extensions">Spring Boot Logback扩展</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Logback文档有一个<a href="https://logback.qos.ch/manual/configuration.html">专用部分，</a>其中详细<a href="https://logback.qos.ch/manual/configuration.html">介绍了配置</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Boot提供了许多登录配置<code>included</code>从您自己的配置。这些包括旨在允许重新应用某些常见的Spring Boot约定。</p>
</div>
<div class="paragraph">
<p>以下文件位于<code>org/springframework/boot/logging/logback/</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>defaults.xml</code> -提供转换规则，模式属性和通用记录器配置。</p>
</li>
<li>
<p><code>console-appender.xml</code> -添加一个<code>ConsoleAppender</code>使用<code>CONSOLE_LOG_PATTERN</code> 。</p>
</li>
<li>
<p><code>file-appender.xml</code> -添加一个<code>RollingFileAppender</code>使用<code>FILE_LOG_PATTERN</code>和<code>ROLLING_FILE_NAME_PATTERN</code>使用适当的设置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另外，遗产<code>base.xml</code>提供文件以与早期版本的Spring Boot兼容。</p>
</div>
<div class="paragraph">
<p>典型的习俗<code>logback.xml</code>文件看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;
    &lt;include resource="org/springframework/boot/logging/logback/defaults.xml"/&gt;
    &lt;include resource="org/springframework/boot/logging/logback/console-appender.xml" /&gt;
    &lt;root level="INFO"&gt;
        &lt;appender-ref ref="CONSOLE" /&gt;
    &lt;/root&gt;
    &lt;logger name="org.springframework.web" level="DEBUG"/&gt;
&lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的logback配置文件还可以利用以下系统属性： <code>LoggingSystem</code>照顾为您创建：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>${PID}</code> ：当前进程ID。</p>
</li>
<li>
<p><code>${LOG_FILE}</code> ：是否<code>logging.file.name</code>是在Boot的外部配置中设置的。</p>
</li>
<li>
<p><code>${LOG_PATH}</code> ：是否<code>logging.file.path</code> （代表存放日志文件的目录）是在Boot的外部配置中设置的。</p>
</li>
<li>
<p><code>${LOG_EXCEPTION_CONVERSION_WORD}</code> ：是否<code>logging.exception-conversion-word</code>是在Boot的外部配置中设置的。</p>
</li>
<li>
<p><code>${ROLLING_FILE_NAME_PATTERN}</code> ：是否<code>logging.pattern.rolling-file-name</code>是在Boot的外部配置中设置的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过使用自定义的Logback转换器，Spring Boot还可以在控制台上提供一些不错的ANSI颜色终端输出（但不在日志文件中）。见<code>CONSOLE_LOG_PATTERN</code>在里面<code>defaults.xml</code>配置示例。</p>
</div>
<div class="paragraph">
<p>如果Groovy在类路径中，则应该能够使用以下命令配置Logback <code>logback.groovy</code>也一样如果存在，则优先考虑此设置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Groovy配置不支持Spring扩展。任何<code>logback-spring.groovy</code>文件将不会被检测到。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="howto-configure-logback-for-logging-fileonly"><a class="anchor" href="#howto-configure-logback-for-logging-fileonly"></a> 8.1.1。配置仅文件输出的Logback</h4>
<div class="paragraph">
<p>如果要禁用控制台日志记录并将输出仅写入文件，则需要自定义<code>logback-spring.xml</code>那个进口<code>file-appender.xml</code>但不是<code>console-appender.xml</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;
    &lt;include resource="org/springframework/boot/logging/logback/defaults.xml" /&gt;
    &lt;property name="LOG_FILE" value="${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}/}spring.log}"/&gt;
    &lt;include resource="org/springframework/boot/logging/logback/file-appender.xml" /&gt;
    &lt;root level="INFO"&gt;
        &lt;appender-ref ref="FILE" /&gt;
    &lt;/root&gt;
&lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还需要添加<code>logging.file.name</code>给你<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.file.name=myapplication.log</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-log4j-for-logging"><a class="anchor" href="#howto-configure-log4j-for-logging"></a> 8.2。配置Log4j进行日志记录</h3>
<div class="paragraph">
<p>如果Spring Boot在类路径上，则它支持<a href="https://logging.apache.org/log4j/2.x/">Log4j 2</a>进行日志记录配置。如果使用入门程序来组装依赖项，则必须排除Logback，然后改为包括log4j 2。如果您不使用启动器，则需要提供（至少） <code>spring-jcl</code>除了Log4j 2。</p>
</div>
<div class="paragraph">
<p>最简单的方法可能是通过启动程序，即使它需要对排除对象进行微调。以下示例显示了如何在Maven中设置启动器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了在Gradle中设置启动器的一种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    compile 'org.springframework.boot:spring-boot-starter-web'
    compile 'org.springframework.boot:spring-boot-starter-log4j2'
}

configurations {
    all {
        exclude group: 'org.springframework.boot', module: 'spring-boot-starter-logging'
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Log4j入门人员将依赖关系汇总在一起，以满足常见的日志记录要求（例如使用Tomcat <code>java.util.logging</code>但使用Log4j 2配置输出）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">确保使用以下命令执行调试日志记录<code>java.util.logging</code>被路由到的Log4j 2，配置其<a href="https://logging.apache.org/log4j/2.0/log4j-jul/index.html">JDK日志适配器</a>通过设置<code>java.util.logging.manager</code>系统属性<code>org.apache.logging.log4j.jul.LogManager</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="howto-configure-log4j-for-logging-yaml-or-json-config"><a class="anchor" href="#howto-configure-log4j-for-logging-yaml-or-json-config"></a> 8.2.1。使用YAML或JSON配置Log4j 2</h4>
<div class="paragraph">
<p>除了默认的XML配置格式外，Log4j 2还支持YAML和JSON配置文件。要将Log4j 2配置为使用备用配置文件格式，请将适当的依赖项添加到类路径中，并命名您的配置文件以匹配您选择的文件格式，如以下示例所示：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:10%">
<col style="width:75%">
<col style="width:15%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">格式</th>
<th class="tableblock halign-left valign-top">依存关系</th>
<th class="tableblock halign-left valign-top">档案名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">YAML</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>com.fasterxml.jackson.core:jackson-databind</code> +<code>com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>log4j2.yaml</code> +<code>log4j2.yml</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON格式</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>com.fasterxml.jackson.core:jackson-databind</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>log4j2.json</code> +<code>log4j2.jsn</code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-data-access"><a class="anchor" href="#howto-data-access"></a> 9。资料存取</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot包含许多用于处理数据源的启动器。本节回答与这样做有关的问题。</p>
</div>
<div class="sect2">
<h3 id="howto-configure-a-datasource"><a class="anchor" href="#howto-configure-a-datasource"></a> 9.1。配置自定义数据源</h3>
<div class="paragraph">
<p>配置自己的<code>DataSource</code> ，定义一个<code>@Bean</code>在您的配置中。Spring Boot重用您的<code>DataSource</code>任何需要的地方，包括数据库初始化。如果您需要外部化某些设置，则可以绑定<code>DataSource</code>到环境（请参阅“ <a href="spring-boot-features.html#boot-features-external-config-3rd-party-configuration">spring-boot-features.html</a> ”）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Bean中定义数据源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ConfigurationProperties(prefix="app.datasource")
public DataSource dataSource() {
    return new FancyDataSource();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何通过设置属性来定义数据源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.datasource.url=jdbc:h2:mem:mydb
app.datasource.username=sa
app.datasource.pool-size=30</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设你<code>FancyDataSource</code>具有URL，用户名和池大小的常规JavaBean属性，这些设置在<code>DataSource</code>可用于其他组件。还会进行常规的<a href="#howto-initialize-a-database-using-spring-jdbc">数据库初始化</a> （因此， <code>spring.datasource.*</code>仍可与您的自定义配置一起使用）。</p>
</div>
<div class="paragraph">
<p>Spring Boot还提供了一个实用程序生成器类，称为<code>DataSourceBuilder</code> ，可用于创建标准数据源之一（如果它在类路径上）。构建器可以根据类路径中可用的内容来检测要使用的一个。它还基于JDBC URL自动检测驱动程序。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何通过使用<code>DataSourceBuilder</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ConfigurationProperties("app.datasource")
public DataSource dataSource() {
    return DataSourceBuilder.create().build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要运行一个应用程序<code>DataSource</code> ，您需要的只是连接信息。还可以提供特定于池的设置。有关更多详细信息，请检查将在运行时使用的实现。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何通过设置属性来定义JDBC数据源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.datasource.url=jdbc:mysql://localhost/test
app.datasource.username=dbuser
app.datasource.password=dbpass
app.datasource.pool-size=30</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，有一个陷阱。由于未公开连接池的实际类型，因此自定义元数据中不会生成任何密钥<code>DataSource</code>并且您的IDE中没有可用的完成功能（因为<code>DataSource</code>接口未显示任何属性）。另外，如果您碰巧在类路径上有Hikari，则此基本设置无效，因为Hikari没有<code>url</code>属性（但确实有一个<code>jdbcUrl</code>属性）。在这种情况下，您必须按照以下方式重写配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.datasource.jdbc-url=jdbc:mysql://localhost/test
app.datasource.username=dbuser
app.datasource.password=dbpass
app.datasource.maximum-pool-size=30</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过强制连接池使用并返回专用实现而不是专用方法来解决此问题<code>DataSource</code> 。您无法在运行时更改实现，但是选项列表将是明确的。</p>
</div>
<div class="paragraph">
<p>以下示例说明了如何创建一个<code>HikariDataSource</code>与<code>DataSourceBuilder</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ConfigurationProperties("app.datasource")
public HikariDataSource dataSource() {
    return DataSourceBuilder.create().type(HikariDataSource.class).build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以利用<code>DataSourceProperties</code>为您提供帮助-也就是说，如果没有提供URL，则通过为默认的嵌入式数据库提供一个有意义的用户名和密码。您可以轻松地初始化<code>DataSourceBuilder</code>从任何状态<code>DataSourceProperties</code>对象，因此您还可以注入Spring Boot自动创建的数据源。但是，这会将您的配置分为两个名称空间： <code>url</code> ， <code>username</code> ， <code>password</code> ， <code>type</code>和<code>driver</code>上<code>spring.datasource</code>其余的放在您的自定义命名空间上（ <code>app.datasource</code> ）。为避免这种情况，您可以重新定义自定义<code>DataSourceProperties</code>在您的自定义名称空间上，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Primary
@ConfigurationProperties("app.datasource")
public DataSourceProperties dataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@ConfigurationProperties("app.datasource.configuration")
public HikariDataSource dataSource(DataSourceProperties properties) {
    return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，该设置使您与Spring Boot为您所做的<em>同步</em> ，不同的是，选择了专用连接池（以代码形式），并且其设置在<code>app.datasource.configuration</code>子名称空间。因为<code>DataSourceProperties</code>正在照顾<code>url</code> / <code>jdbcUrl</code>为您翻译，您可以按以下方式进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.datasource.url=jdbc:mysql://localhost/test
app.datasource.username=dbuser
app.datasource.password=dbpass
app.datasource.configuration.maximum-pool-size=30</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Boot会将Hikari特定的设置公开给<code>spring.datasource.hikari</code> 。这个例子使用了更通用的<code>configuration</code>作为示例的sub名称空间不支持多个数据源实现。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于您的自定义配置选择与Hikari搭配使用， <code>app.datasource.type</code>没有效果。实际上，构建器会使用您可以在其中设置的任何值进行初始化，然后通过对的调用进行覆盖<code>.type()</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参阅“ Spring Boot功能”部分中的“ <a href="spring-boot-features.html#boot-features-configure-datasource">spring-boot-features.html</a> ”和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java"><code>DataSourceAutoConfiguration</code></a>类以获取更多详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-two-datasources"><a class="anchor" href="#howto-two-datasources"></a> 9.2。配置两个数据源</h3>
<div class="paragraph">
<p>如果需要配置多个数据源，则可以应用上一节中介绍的相同技巧。但是，您必须标记其中一个<code>DataSource</code>实例为<code>@Primary</code> ，因为将来各种自动配置都希望能够按类型进行配置。</p>
</div>
<div class="paragraph">
<p>如果您创建自己的<code>DataSource</code> ，自动配置将退出。在以下示例中，我们提供与自动配置在主数据源上提供的功能<em>完全相同的</em>功能集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Primary
@ConfigurationProperties("app.datasource.first")
public DataSourceProperties firstDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@Primary
@ConfigurationProperties("app.datasource.first.configuration")
public HikariDataSource firstDataSource() {
    return firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource.class).build();
}

@Bean
@ConfigurationProperties("app.datasource.second")
public BasicDataSource secondDataSource() {
    return DataSourceBuilder.create().type(BasicDataSource.class).build();
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>firstDataSourceProperties</code>必须标记为<code>@Primary</code>以便数据库初始化程序功能使用您的副本（如果使用初始化程序）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这两个数据源也都必须进行高级定制。例如，您可以按以下方式配置它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">app.datasource.first.url=jdbc:mysql://localhost/first
app.datasource.first.username=dbuser
app.datasource.first.password=dbpass
app.datasource.first.configuration.maximum-pool-size=30

app.datasource.second.url=jdbc:mysql://localhost/second
app.datasource.second.username=dbuser
app.datasource.second.password=dbpass
app.datasource.second.max-total=30</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以将相同的概念应用于辅助<code>DataSource</code>也如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Primary
@ConfigurationProperties("app.datasource.first")
public DataSourceProperties firstDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@Primary
@ConfigurationProperties("app.datasource.first.configuration")
public HikariDataSource firstDataSource() {
    return firstDataSourceProperties().initializeDataSourceBuilder().type(HikariDataSource.class).build();
}

@Bean
@ConfigurationProperties("app.datasource.second")
public DataSourceProperties secondDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@ConfigurationProperties("app.datasource.second.configuration")
public BasicDataSource secondDataSource() {
    return secondDataSourceProperties().initializeDataSourceBuilder().type(BasicDataSource.class).build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例在自定义名称空间上配置两个数据源，其逻辑与Spring Boot在自动配置中使用的逻辑相同。注意每个<code>configuration</code>子名称空间根据所选实现提供高级设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-spring-data-repositories"><a class="anchor" href="#howto-use-spring-data-repositories"></a> 9.3。使用Spring数据仓库</h3>
<div class="paragraph">
<p>Spring Data可以创建的实现<code>@Repository</code>各种口味的界面。Spring Boot会为您处理所有这些，只要那些<code>@Repositories</code>包含在与您相同的包装（或子包装）中<code>@EnableAutoConfiguration</code>类。</p>
</div>
<div class="paragraph">
<p>对于许多应用程序，您所需要做的就是在类路径上放置正确的Spring Data依赖项。有一个<code>spring-boot-starter-data-jpa</code>对于JPA，对于mongodb，对于spring-boot-starter-data-mongodb`，等等。首先，创建一些存储库接口来处理您的<code>@Entity</code>对象。</p>
</div>
<div class="paragraph">
<p>Spring Boot尝试猜测您的位置<code>@Repository</code>定义，基于<code>@EnableAutoConfiguration</code>它找到。要获得更多控制权，请使用<code>@EnableJpaRepositories</code>注释（来自Spring Data JPA）。</p>
</div>
<div class="paragraph">
<p>有关Spring Data的更多信息，请参见<a href="https://spring.io/projects/spring-data">Spring Data项目页面</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-separate-entity-definitions-from-spring-configuration"><a class="anchor" href="#howto-separate-entity-definitions-from-spring-configuration"></a> 9.4。将@Entity定义与Spring配置分开</h3>
<div class="paragraph">
<p>Spring Boot尝试猜测您的位置<code>@Entity</code>定义，基于<code>@EnableAutoConfiguration</code>它找到。要获得更多控制权，您可以使用<code>@EntityScan</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@EntityScan(basePackageClasses=City.class)
public class Application {

    //...

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-jpa-properties"><a class="anchor" href="#howto-configure-jpa-properties"></a> 9.5。配置JPA属性</h3>
<div class="paragraph">
<p>Spring Data JPA已经提供了一些独立于供应商的配置选项（例如用于SQL日志记录的那些），并且Spring Boot将这些选项以及Hibernate的其他一些选项作为外部配置属性公开。其中一些会根据上下文自动检测到，因此您不必进行设置。</p>
</div>
<div class="paragraph">
<p>的<code>spring.jpa.hibernate.ddl-auto</code>这是一种特殊情况，因为根据运行时条件，它具有不同的默认值。如果使用嵌入式数据库，并且没有模式管理器（例如Liquibase或Flyway）正在处理<code>DataSource</code> ，默认为<code>create-drop</code> 。在所有其他情况下，默认为<code>none</code> 。</p>
</div>
<div class="paragraph">
<p>JPA提供程序检测到要使用的方言。如果您想自己设置方言，请设置<code>spring.jpa.database-platform</code>属性。</p>
</div>
<div class="paragraph">
<p>下例显示了最常用的设置选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.hibernate.naming.physical-strategy=com.example.MyPhysicalNamingStrategy
spring.jpa.show-sql=true</pre>
</div>
</div>
<div class="paragraph">
<p>此外， <code>spring.jpa.properties.*</code>本地时，它们将作为普通的JPA属性（前缀去除）传递<code>EntityManagerFactory</code>被建造。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您需要确保在<code>spring.jpa.properties.*</code>与您的JPA提供商期望的完全匹配。Spring Boot不会尝试对这些条目进行任何形式的宽松绑定。</p>
</div>
<div class="paragraph">
<p>例如，如果要配置Hibernate的批处理大小，则必须使用<code>spring.jpa.properties.hibernate.jdbc.batch_size</code> 。如果您使用其他形式，例如<code>batchSize</code>要么<code>batch-size</code> ，休眠将不会应用该设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您需要对Hibernate属性应用高级自定义，请考虑注册一个<code>HibernatePropertiesCustomizer</code>在创建之前将被调用的bean <code>EntityManagerFactory</code> 。这优先于自动配置应用的任何内容。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-hibernate-naming-strategy"><a class="anchor" href="#howto-configure-hibernate-naming-strategy"></a> 9.6。配置休眠命名策略</h3>
<div class="paragraph">
<p>Hibernate使用<a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#naming">两种不同的命名策略</a>将名称从对象模型映射到相应的数据库名称。可以通过设置物理和隐式策略实现的完全限定的类名来配置<code>spring.jpa.hibernate.naming.physical-strategy</code>和<code>spring.jpa.hibernate.naming.implicit-strategy</code>属性。或者，如果<code>ImplicitNamingStrategy</code>要么<code>PhysicalNamingStrategy</code> bean在应用程序上下文中可用，Hibernate将自动配置为使用它们。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Boot使用以下命令配置物理命名策略： <code>SpringPhysicalNamingStrategy</code> 。此实现提供了与Hibernate 4相同的表结构：所有点都由下划线替换，骆驼套也由下划线替换。默认情况下，所有表名均以小写形式生成，但是如果您的架构需要它，则可以覆盖该标志。</p>
</div>
<div class="paragraph">
<p>例如，一个<code>TelephoneNumber</code>实体已映射到<code>telephone_number</code>表。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢使用Hibernate 5的默认设置，请设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</pre>
</div>
</div>
<div class="paragraph">
<p>另外，您可以配置以下bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PhysicalNamingStrategy physicalNamingStrategy() {
    return new PhysicalNamingStrategyStandardImpl();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.java"><code>HibernateJpaAutoConfiguration</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><code>JpaBaseConfiguration</code></a>更多细节。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-hibernate-second-level-caching"><a class="anchor" href="#howto-configure-hibernate-second-level-caching"></a> 9.7。配置Hibernate二级缓存</h3>
<div class="paragraph">
<p>可以为一系列缓存提供程序配置Hibernate <a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#caching">二级</a>缓存。与其将Hibernate配置为再次查找缓存提供程序，不如提供尽可能在上下文中可用的缓存提供程序。</p>
</div>
<div class="paragraph">
<p>如果您使用的是JCache，这非常简单。首先，请确保<code>org.hibernate:hibernate-jcache</code>在类路径上可用。然后，添加一个<code>HibernatePropertiesCustomizer</code> bean如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class HibernateSecondLevelCacheExample {

    @Bean
    public HibernatePropertiesCustomizer hibernateSecondLevelCacheCustomizer(JCacheCacheManager cacheManager) {
        return (properties) -&gt; properties.put(ConfigSettings.CACHE_MANAGER, cacheManager.getCacheManager());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该定制器将配置Hibernate以使用相同的<code>CacheManager</code>作为应用程序使用的一种。也可以单独使用<code>CacheManager</code>实例。有关详细信息，请参阅<a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#caching-provider-jcache">《 Hibernate用户指南》</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-dependency-injection-hibernate-components"><a class="anchor" href="#howto-use-dependency-injection-hibernate-components"></a> 9.8。在休眠组件中使用依赖注入</h3>
<div class="paragraph">
<p>默认情况下，Spring Boot注册一个<code>BeanContainer</code>使用的实现<code>BeanFactory</code>以便转换器和实体侦听器可以使用常规依赖项注入。</p>
</div>
<div class="paragraph">
<p>您可以通过注册一个禁用或调整此行为<code>HibernatePropertiesCustomizer</code>删除或更改<code>hibernate.resource.beans.container</code>属性。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-custom-entity-manager"><a class="anchor" href="#howto-use-custom-entity-manager"></a> 9.9。使用自定义EntityManagerFactory</h3>
<div class="paragraph">
<p>要完全控制配置<code>EntityManagerFactory</code> ，您需要添加一个<code>@Bean</code>名为“ entityManagerFactory”。如果存在这种类型的Bean，Spring Boot自动配置将关闭其实体管理器。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-two-entity-managers"><a class="anchor" href="#howto-use-two-entity-managers"></a> 9.10。使用两个EntityManager</h3>
<div class="paragraph">
<p>即使默认<code>EntityManagerFactory</code>工作正常，您需要定义一个新的。否则，该类型的第二个bean的存在将关闭默认值。为了方便，您可以使用方便<code>EntityManagerBuilder</code>由Spring Boot提供。另外，您也可以<code>LocalContainerEntityManagerFactoryBean</code>直接从Spring ORM，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// add two data sources configured as above

@Bean
public LocalContainerEntityManagerFactoryBean customerEntityManagerFactory(
        EntityManagerFactoryBuilder builder) {
    return builder
            .dataSource(customerDataSource())
            .packages(Customer.class)
            .persistenceUnit("customers")
            .build();
}

@Bean
public LocalContainerEntityManagerFactoryBean orderEntityManagerFactory(
        EntityManagerFactoryBuilder builder) {
    return builder
            .dataSource(orderDataSource())
            .packages(Order.class)
            .persistenceUnit("orders")
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的配置几乎可以独立工作。要完成图片，您需要配置<code>TransactionManagers</code>对于两个<code>EntityManagers</code>也一样如果您将其中之一标记为<code>@Primary</code> ，默认情况下可以选择<code>JpaTransactionManager</code>在Spring Boot中。另一个必须显式地注入到新实例中。另外，您也许可以使用跨两个JTA事务管理器。</p>
</div>
<div class="paragraph">
<p>如果使用Spring Data，则需要配置<code>@EnableJpaRepositories</code>因此，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableJpaRepositories(basePackageClasses = Customer.class,
        entityManagerFactoryRef = "customerEntityManagerFactory")
public class CustomerConfiguration {
    ...
}

@Configuration(proxyBeanMethods = false)
@EnableJpaRepositories(basePackageClasses = Order.class,
        entityManagerFactoryRef = "orderEntityManagerFactory")
public class OrderConfiguration {
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-traditional-persistence-xml"><a class="anchor" href="#howto-use-traditional-persistence-xml"></a> 9.11。使用传统<code>persistence.xml</code>文件</h3>
<div class="paragraph">
<p>Spring Boot将不会搜索或使用<code>META-INF/persistence.xml</code>默认。如果您喜欢使用传统<code>persistence.xml</code> ，您需要定义自己的<code>@Bean</code>类型的<code>LocalEntityManagerFactoryBean</code> （ID为“ entityManagerFactory”），并在其中设置持久性单元名称。</p>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/orm/jpa/JpaBaseConfiguration.java"><code>JpaBaseConfiguration</code></a>默认设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-spring-data-jpa--and-mongo-repositories"><a class="anchor" href="#howto-use-spring-data-jpa--and-mongo-repositories"></a> 9.12。使用Spring Data JPA和Mongo存储库</h3>
<div class="paragraph">
<p>Spring Data JPA和Spring Data Mongo都可以自动创建<code>Repository</code>为您实施。如果它们都存在于类路径中，则可能必须做一些额外的配置以告诉Spring Boot要创建哪个存储库。最明确的方法是使用标准Spring Data <code>@EnableJpaRepositories</code>和<code>@EnableMongoRepositories</code>注释并提供您的位置<code>Repository</code>接口。</p>
</div>
<div class="paragraph">
<p>也有标志（ <code>spring.data.*.repositories.enabled</code>和<code>spring.data.*.repositories.type</code> ），您可以在外部配置中打开和关闭自动配置的存储库。这样做很有用，例如，在您要关闭Mongo存储库并仍使用自动配置的情况下<code>MongoTemplate</code> 。</p>
</div>
<div class="paragraph">
<p>对于其他自动配置的Spring Data存储库类型（Elasticsearch，Solr等），存在相同的障碍和相同的功能。要使用它们，请相应地更改注释和标志的名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-customize-spring-datas-web-support"><a class="anchor" href="#howto-use-customize-spring-datas-web-support"></a> 9.13。定制Spring Data的Web支持</h3>
<div class="paragraph">
<p>Spring Data提供了Web支持，简化了Web应用程序中Spring Data存储库的使用。Spring Boot在<code>spring.data.web</code>用于自定义其配置的名称空间。请注意，如果您使用的是Spring Data REST，则必须使用<code>spring.data.rest</code>命名空间。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-exposing-spring-data-repositories-rest-endpoint"><a class="anchor" href="#howto-use-exposing-spring-data-repositories-rest-endpoint"></a> 9.14。将Spring数据存储库公开为REST端点</h3>
<div class="paragraph">
<p>Spring Data REST可以公开<code>Repository</code>实现为您作为REST端点的实现，前提是已为该应用程序启用了Spring MVC。</p>
</div>
<div class="paragraph">
<p>Spring Boot公开了一组有用的属性（从<code>spring.data.rest</code>命名空间） <a href="https://docs.spring.io/spring-data/rest/docs/3.2.1.RELEASE/api/org/springframework/data/rest/core/config/RepositoryRestConfiguration.html"><code>RepositoryRestConfiguration</code></a> 。如果您需要提供其他自定义设置，则应使用<a href="https://docs.spring.io/spring-data/rest/docs/3.2.1.RELEASE/api/org/springframework/data/rest/webmvc/config/RepositoryRestConfigurer.html"><code>RepositoryRestConfigurer</code></a> bean 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您未在自定义中指定任何顺序<code>RepositoryRestConfigurer</code> ，它在一个Spring Boot内部使用之后运行。如果您需要指定订单，请确保该订单大于0。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-a-component-that-is-used-by-JPA"><a class="anchor" href="#howto-configure-a-component-that-is-used-by-JPA"></a> 9.15。配置JPA使用的组件</h3>
<div class="paragraph">
<p>如果要配置JPA使用的组件，则需要确保在JPA之前初始化该组件。当组件被自动配置后，Spring Boot会为您处理。例如，当自动配置Flyway时，Hibernate被配置为依赖Flyway，这样Flyway就有机会在Hibernate尝试使用数据库之前初始化数据库。</p>
</div>
<div class="paragraph">
<p>如果您自己配置组件，则可以使用<code>EntityManagerFactoryDependsOnPostProcessor</code>子类是建立必要依赖关系的便捷方法。例如，如果您将Hibernate Search与Elasticsearch一起用作其索引管理器，则任何<code>EntityManagerFactory</code> Bean必须配置为取决于<code>elasticsearchClient</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * {@link EntityManagerFactoryDependsOnPostProcessor} that ensures that
 * {@link EntityManagerFactory} beans depend on the {@code elasticsearchClient} bean.
 */
@Component
static class ElasticsearchEntityManagerFactoryDependsOnPostProcessor
        extends EntityManagerFactoryDependsOnPostProcessor {

    ElasticsearchEntityManagerFactoryDependsOnPostProcessor() {
        super("elasticsearchClient");
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-jOOQ-with-multiple-datasources"><a class="anchor" href="#howto-configure-jOOQ-with-multiple-datasources"></a> 9.16。使用两个数据源配置jOOQ</h3>
<div class="paragraph">
<p>如果需要将jOOQ与多个数据源一起使用，则应创建自己的数据源<code>DSLContext</code>每一个人。有关更多详细信息，请参阅<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jooq/JooqAutoConfiguration.java">JooqAutoConfiguration</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">特别是， <code>JooqExceptionTranslator</code>和<code>SpringTransactionProvider</code>可以重复使用，以提供与自动配置功能相似的功能<code>DataSource</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-database-initialization"><a class="anchor" href="#howto-database-initialization"></a> 10。数据库初始化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以使用不同的方式初始化SQL数据库，具体取决于堆栈是什么。当然，如果数据库是一个单独的过程，您也可以手动执行。建议使用单一机制进行模式生成。</p>
</div>
<div class="sect2">
<h3 id="howto-initialize-a-database-using-jpa"><a class="anchor" href="#howto-initialize-a-database-using-jpa"></a> 10.1。使用JPA初始化数据库</h3>
<div class="paragraph">
<p>JPA具有用于DDL生成的功能，可以将其设置为在启动时针对数据库运行。这是通过两个外部属性控制的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.jpa.generate-ddl</code> （布尔值）打开和关闭该功能，并且与供应商无关。</p>
</li>
<li>
<p><code>spring.jpa.hibernate.ddl-auto</code> （枚举）是一种Hibernate功能，可以更精细地控制行为。此功能将在本指南的后面部分详细介绍。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="howto-initialize-a-database-using-hibernate"><a class="anchor" href="#howto-initialize-a-database-using-hibernate"></a> 10.2。使用休眠初始化数据库</h3>
<div class="paragraph">
<p>你可以设定<code>spring.jpa.hibernate.ddl-auto</code>显式且标准的Hibernate属性值为<code>none</code> ， <code>validate</code> ， <code>update</code> ， <code>create</code>和<code>create-drop</code> 。Spring Boot根据是否认为您的数据库已嵌入为您选择默认值。默认为<code>create-drop</code>如果未检测到任何模式管理器，或者<code>none</code>在所有其他情况下。通过查看<code>Connection</code>类型。
<code>hsqldb</code> ， <code>h2</code>和<code>derby</code>是嵌入式的，其他不是。从内存数据库转换为“真实”数据库时，请不要对新平台中表和数据的存在做出假设。你要么要设置<code>ddl-auto</code>显式地或使用其他机制之一来初始化数据库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以通过启用<code>org.hibernate.SQL</code>记录器。如果启用<a href="spring-boot-features.html#boot-features-logging-console-output">调试模式，</a>此操作将自动为您完成。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另外，一个名为<code>import.sql</code>如果Hibernate从头开始创建架构，则在启动时执行classpath根目录中的代码（即<code>ddl-auto</code>属性设置为<code>create</code>要么<code>create-drop</code> ）。如果您小心的话，这对于演示和测试很有用，但可能不是您想在生产中使用的类路径。这是一个Hibernate功能（与Spring无关）。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-initialize-a-database-using-spring-jdbc"><a class="anchor" href="#howto-initialize-a-database-using-spring-jdbc"></a> 10.3。初始化数据库</h3>
<div class="paragraph">
<p>Spring Boot可以自动创建您的架构（DDL脚本） <code>DataSource</code>并对其进行初始化（DML脚本）。它从标准根类路径位置加载SQL： <code>schema.sql</code>和<code>data.sql</code> ， 分别。此外，Spring Boot还处理<code>schema-${platform}.sql</code>和<code>data-${platform}.sql</code>文件（如果存在），在哪里<code>platform</code>是...的价值<code>spring.datasource.platform</code> 。这使您可以在必要时切换到特定于数据库的脚本。例如，您可以选择将其设置为数据库的供应商名称（ <code>hsqldb</code> ， <code>h2</code> ， <code>oracle</code> ， <code>mysql</code> ， <code>postgresql</code> ， 等等）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Boot自动创建嵌入式架构<code>DataSource</code> 。您可以使用<code>spring.datasource.initialization-mode</code>属性。例如，如果您想始终初始化<code>DataSource</code>不论其类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.datasource.initialization-mode=always</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，Spring Boot启用Spring JDBC初始化程序的快速失败功能。这意味着，如果脚本导致异常，则应用程序将无法启动。您可以通过设置来调整该行为<code>spring.datasource.continue-on-error</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在基于JPA的应用程序中，您可以选择让Hibernate创建架构或使用<code>schema.sql</code> ，但您不能两者都做。确保禁用<code>spring.jpa.hibernate.ddl-auto</code>如果您使用<code>schema.sql</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-initialize-a-spring-batch-database"><a class="anchor" href="#howto-initialize-a-spring-batch-database"></a> 10.4。初始化一个Spring Batch数据库</h3>
<div class="paragraph">
<p>如果您使用Spring Batch，则它随大多数流行的数据库平台一起预包装了SQL初始化脚本。Spring Boot可以检测数据库类型并在启动时执行这些脚本。如果您使用嵌入式数据库，则默认情况下会发生这种情况。您还可以为任何数据库类型启用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.batch.initialize-schema=always</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过设置显式关闭初始化<code>spring.batch.initialize-schema=never</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-a-higher-level-database-migration-tool"><a class="anchor" href="#howto-use-a-higher-level-database-migration-tool"></a> 10.5。使用高级数据库迁移工具</h3>
<div class="paragraph">
<p> Spring 引导支持两种更高级别的迁移工具： <a href="https://flywaydb.org/">迁飞</a>和<a href="https://www.liquibase.org/">Liquibase</a> 。</p>
</div>
<div class="sect3">
<h4 id="howto-execute-flyway-database-migrations-on-startup"><a class="anchor" href="#howto-execute-flyway-database-migrations-on-startup"></a> 10.5.1。在启动时执行Flyway数据库迁移</h4>
<div class="paragraph">
<p>要在启动时自动运行Flyway数据库迁移，请添加<code>org.flywaydb:flyway-core</code>到你的classpath。</p>
</div>
<div class="paragraph">
<p>通常，迁移是以下形式的脚本： <code>V<VERSION>__<NAME>.sql</code> （与<code><VERSION></code>下划线分隔的版本，例如“ 1”或“ 2_1”）。默认情况下，它们位于一个名为<code>classpath:db/migration</code> ，但是您可以通过设置<code>spring.flyway.locations</code> 。这是一个或多个的逗号分隔列表<code>classpath:</code>要么<code>filesystem:</code>位置。例如，以下配置将在默认类路径位置和<code>/opt/migration</code>目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.flyway.locations=classpath:db/migration,filesystem:/opt/migration</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以添加特殊<code>{vendor}</code>占位符以使用特定于供应商的脚本。假设以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.flyway.locations=classpath:db/migration/{vendor}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是使用<code>db/migration</code> ，上述配置根据数据库的类型（例如， <code>db/migration/mysql</code>对于MySQL）。支持的数据库列表位于<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/DatabaseDriver.java"><code>DatabaseDriver</code></a> 。</p>
</div>
<div class="paragraph">
<p>迁移也可以用Java编写。Flyway将使用实现的所有bean自动配置<code>JavaMigration</code> 。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayProperties.java"><code>FlywayProperties</code></a>提供Flyway的大多数设置以及少量的其他属性，这些属性可用于禁用迁移或关闭位置检查。如果您需要对配置进行更多控制，请考虑注册一个<code>FlywayConfigurationCustomizer</code> bean 。</p>
</div>
<div class="paragraph">
<p>Spring Boot电话<code>Flyway.migrate()</code>执行数据库迁移。如果您想要更多控制权，请提供<code>@Bean</code>实现<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/flyway/FlywayMigrationStrategy.java"><code>FlywayMigrationStrategy</code></a> 。</p>
</div>
<div class="paragraph">
<p>Flyway支持SQL和Java <a href="https://flywaydb.org/documentation/callbacks.html">回调</a> 。要使用基于SQL的回调，请将回调脚本放在<code>classpath:db/migration</code>夹。要使用基于Java的回调，请创建一个或多个实现<code>Callback</code> 。任何此类bean都会自动向其注册<code>Flyway</code> 。可以通过使用订购<code>@Order</code>或通过实施<code>Ordered</code> 。实现不推荐使用的Bean <code>FlywayCallback</code>也可以检测到接口，但是不能与它们一起使用<code>Callback</code>beans。</p>
</div>
<div class="paragraph">
<p>默认情况下，Flyway自动将（ <code>@Primary</code> ） <code>DataSource</code>并根据您的情况进行迁移。如果您想使用其他<code>DataSource</code> ，您可以创建一个并标记其<code>@Bean</code>如<code>@FlywayDataSource</code> 。如果这样做并想要两个数据源，请记住创建另一个数据源并将其标记为<code>@Primary</code> 。或者，您可以使用Flyway的本机<code>DataSource</code>通过设置<code>spring.flyway.[url,user,password]</code>在外部属性。设置<code>spring.flyway.url</code>要么<code>spring.flyway.user</code>足以导致Flyway使用自己的<code>DataSource</code> 。如果未设置这三个属性中的任何一个，则其等效值<code>spring.datasource</code>属性将被使用。</p>
</div>
<div class="paragraph">
<p>您还可以使用Flyway为特定情况提供数据。例如，您可以将特定于测试的迁移放在<code>src/test/resources</code>并且仅在您的应用程序开始进行测试时才运行它们。另外，您可以使用特定于配置文件的配置来自定义<code>spring.flyway.locations</code>因此某些迁移仅在特定配置文件处于活动状态时运行。例如，在<code>application-dev.properties</code> ，您可以指定以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.flyway.locations=classpath:/db/migration,classpath:/dev/db/migration</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过该设置，迁移<code>dev/db/migration</code>仅在<code>dev</code>个人资料已激活。</p>
</div>
</div>
<div class="sect3">
<h4 id="howto-execute-liquibase-database-migrations-on-startup"><a class="anchor" href="#howto-execute-liquibase-database-migrations-on-startup"></a> 10.5.2。在启动时执行Liquibase数据库迁移</h4>
<div class="paragraph">
<p>要在启动时自动运行Liquibase数据库迁移，请添加<code>org.liquibase:liquibase-core</code>到你的classpath。</p>
</div>
<div class="paragraph">
<p>默认情况下，从中读取主更改日志<code>db/changelog/db.changelog-master.yaml</code> ，但是您可以通过设置来更改位置<code>spring.liquibase.change-log</code> 。除了YAML，Liquibase还支持JSON，XML和SQL更改日志格式。</p>
</div>
<div class="paragraph">
<p>默认情况下，Liquibase自动将（ <code>@Primary</code> ） <code>DataSource</code>并根据您的情况进行迁移。如果您需要使用其他<code>DataSource</code> ，您可以创建一个并标记其<code>@Bean</code>如<code>@LiquibaseDataSource</code> 。如果这样做，并且想要两个数据源，请记住创建另一个数据源并将其标记为<code>@Primary</code> 。或者，您可以使用Liquibase的本机<code>DataSource</code>通过设置<code>spring.liquibase.[url,user,password]</code>在外部属性。设置<code>spring.liquibase.url</code>要么<code>spring.liquibase.user</code>足以导致Liquibase使用其自己的<code>DataSource</code> 。如果未设置这三个属性中的任何一个，则其等效值<code>spring.datasource</code>属性将被使用。</p>
</div>
<div class="paragraph">
<p>看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/liquibase/LiquibaseProperties.java"><code>LiquibaseProperties</code></a>有关可用设置（例如上下文，默认架构等）的详细信息。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-messaging"><a class="anchor" href="#howto-messaging"></a> 11。讯息传递</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了许多包含消息传递的启动器。本部分回答了将消息与Spring Boot一起使用所引起的问题。</p>
</div>
<div class="sect2">
<h3 id="howto-jms-disable-transaction"><a class="anchor" href="#howto-jms-disable-transaction"></a> 11.1。禁用事务JMS会话</h3>
<div class="paragraph">
<p>如果您的JMS代理不支持事务处理会话，则必须完全禁用事务支持。如果您创建自己的<code>JmsListenerContainerFactory</code> ，因此无需执行任何操作，因为默认情况下无法进行交易。如果您想使用<code>DefaultJmsListenerContainerFactoryConfigurer</code>要重用Spring Boot的默认值，您可以禁用事务会话，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
        ConnectionFactory connectionFactory,
        DefaultJmsListenerContainerFactoryConfigurer configurer) {
    DefaultJmsListenerContainerFactory listenerFactory =
            new DefaultJmsListenerContainerFactory();
    configurer.configure(listenerFactory, connectionFactory);
    listenerFactory.setTransactionManager(null);
    listenerFactory.setSessionTransacted(false);
    return listenerFactory;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将覆盖默认工厂，并且应将其应用于应用程序定义的任何其他工厂（如果有）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-batch-applications"><a class="anchor" href="#howto-batch-applications"></a> 12批量申请</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本部分回答了将Spring Batch与Spring Boot结合使用所引起的问题。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，批处理应用程序需要<code>DataSource</code>存储工作详细信息。批量自动接线<code>DataSource</code>并根据您的情况进行处理。要批量使用<code>DataSource</code>除了应用程序的主程序<code>DataSource</code> ，声明一个<code>DataSource</code> bean ，注释它<code>@Bean</code>方法<code>@BatchDataSource</code> 。如果这样做并想要两个数据源，请记住创建另一个数据源并将其标记为<code>@Primary</code> 。为了更好地控制，实施<code>BatchConfigurer</code> 。请参阅<a href="https://docs.spring.io/spring-batch/apidocs/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html">的Javadoc <code>@EnableBatchProcessing</code></a>更多细节。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关Spring Batch的更多信息，请参见<a href="https://spring.io/projects/spring-batch">Spring Batch项目页面</a> 。</p>
</div>
<div class="sect2">
<h3 id="howto-execute-spring-batch-jobs-on-startup"><a class="anchor" href="#howto-execute-spring-batch-jobs-on-startup"></a> 12.1。在启动时执行Spring Batch作业</h3>
<div class="paragraph">
<p>通过添加启用Spring Batch自动配置<code>@EnableBatchProcessing</code> （来自Spring Batch）在您所处的环境中。</p>
</div>
<div class="paragraph">
<p>默认情况下，它执行<strong>所有</strong> <code>Jobs</code>在启动时在应用程序上下文中运行（有关详细信息，请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherCommandLineRunner.java">JobLauncherCommandLineRunner</a> ）。您可以通过指定缩小到一个或多个特定作业<code>spring.batch.job.names</code> （以逗号分隔的工作名称模式列表）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="title">在命令行上指定作业参数</div>
<div class="paragraph">
<p>与在命令行中<a href="spring-boot-features.html#boot-features-external-config-command-line-args">设置属性的</a>命令行选项参数不同<a href="spring-boot-features.html#boot-features-external-config-command-line-args"><code>Environment</code></a> （即以<code>--</code> ， 如<code>--my-property=value</code> ），则必须在命令行上指定作业参数，而不能使用破折号（例如， <code>jobParam=value</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果应用程序上下文包括<code>JobRegistry</code> ，这些职位在<code>spring.batch.job.names</code>在注册表中查找，而不是从上下文自动连接。这是更复杂的系统的常见模式，其中多个作业在子上下文中定义并集中注册。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/BatchAutoConfiguration.java">BatchAutoConfiguration</a>和<a href="https://github.com/spring-projects/spring-batch/blob/master/spring-batch-core/src/main/java/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.java">@EnableBatchProcessing</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-actuator"><a class="anchor" href="#howto-actuator"></a> 13执行器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot包括Spring Boot执行器。本节回答了经常因使用而引起的问题。</p>
</div>
<div class="sect2">
<h3 id="howto-change-the-http-port-or-address-of-the-actuator-endpoints"><a class="anchor" href="#howto-change-the-http-port-or-address-of-the-actuator-endpoints"></a> 13.1。更改执行器端点的HTTP端口或地址</h3>
<div class="paragraph">
<p>在独立应用程序中，Actuator HTTP端口默认与主HTTP端口相同。要使应用程序在其他端口上进行侦听，请设置外部属性： <code>management.server.port</code> 。要侦听完全不同的网络地址（例如，当您有一个用于管理的内部网络和一个用于用户应用程序的外部网络）时，您还可以设置<code>management.server.address</code>到服务器可以绑定到的有效IP地址。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/server/ManagementServerProperties.java"><code>ManagementServerProperties</code></a>源代码和“ <a href="production-ready-features.html#production-ready-customizing-management-server-port">生产</a>就绪功能”部分中的“ production-ready-features.html”。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-customize-the-whitelabel-error-page"><a class="anchor" href="#howto-customize-the-whitelabel-error-page"></a> 13.2。自定义“ whitelabel”错误页面</h3>
<div class="paragraph">
<p>如果遇到服务器错误，Spring Boot会安装一个“ whitelabel”错误页面，您会在浏览器客户端中看到该错误页面（使用JSON和其他媒体类型的机器客户端应该看到带有正确错误代码的明智响应）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">组<code>server.error.whitelabel.enabled=false</code>关闭默认错误页面。这样做将还原您正在使用的servlet容器的默认值。请注意，Spring Boot仍然尝试解决错误视图，因此您可能应该添加自己的错误页面，而不是完全禁用它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>用自己的方法覆盖错误页面取决于您使用的模板技术。例如，如果您使用Thymeleaf，则可以添加<code>error.html</code>模板。如果您使用FreeMarker，则可以添加一个<code>error.ftlh</code>模板。通常，您需要<code>View</code>的名称解析为<code>error</code>或一个<code>@Controller</code>处理<code>/error</code>路径。除非您替换了某些默认配置，否则您应该找到一个<code>BeanNameViewResolver</code>在你的<code>ApplicationContext</code> ，所以<code>@Bean</code>命名<code>error</code>将是一个简单的方法。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/servlet/error/ErrorMvcAutoConfiguration.java"><code>ErrorMvcAutoConfiguration</code></a>有关更多选项。</p>
</div>
<div class="paragraph">
<p>有关如何在Servlet容器中注册处理程序的详细信息，另请参见“ <a href="spring-boot-features.html#boot-features-error-handling">错误处理</a> ”部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-sanitize-sensible-values"><a class="anchor" href="#howto-sanitize-sensible-values"></a> 13.3。清理明智的价值观</h3>
<div class="paragraph">
<p>由...返回的信息<code>env</code>和<code>configprops</code>端点可能有些敏感，因此默认情况下会清理匹配特定模式的键（即，将其值替换为<code>******</code> ）。</p>
</div>
<div class="paragraph">
<p>Spring Boot对此类密钥使用明智的默认设置：例如，对任何以单词“ password”，“ secret”，“ key”或“ token”结尾的密钥进行清理。也可以改用正则表达式，例如<code>*credentials.*</code>清理所有包含单词的键<code>credentials</code>作为关键的一部分。</p>
</div>
<div class="paragraph">
<p>可以使用<code>management.endpoint.env.keys-to-sanitize</code>和<code>management.endpoint.configprops.keys-to-sanitize</code>分别。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-security"><a class="anchor" href="#howto-security"></a> 14。安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本部分解决有关使用Spring Boot时的安全性的问题，包括因将Spring Security与Spring Boot一起使用而引起的问题。</p>
</div>
<div class="paragraph">
<p>有关Spring Security的更多信息，请参见<a href="https://spring.io/projects/spring-security">Spring Security项目页面</a> 。</p>
</div>
<div class="sect2">
<h3 id="howto-switch-off-spring-boot-security-configuration"><a class="anchor" href="#howto-switch-off-spring-boot-security-configuration"></a> 14.1。关闭Spring Boot安全性配置</h3>
<div class="paragraph">
<p>如果您定义<code>@Configuration</code>与一个<code>WebSecurityConfigurerAdapter</code>在您的应用程序中，它将关闭Spring Boot中的默认webapp安全设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-change-the-user-details-service-and-add-user-accounts"><a class="anchor" href="#howto-change-the-user-details-service-and-add-user-accounts"></a> 14.2。更改UserDetailsService并添加用户帐户</h3>
<div class="paragraph">
<p>如果您提供<code>@Bean</code>类型的<code>AuthenticationManager</code> ， <code>AuthenticationProvider</code> ， 要么<code>UserDetailsService</code> ，默认<code>@Bean</code>对于<code>InMemoryUserDetailsManager</code>未创建。这意味着您拥有完整的Spring Security功能集（例如<a href="https://docs.spring.io/spring-security/site/docs/5.2.1.RELEASE/reference/htmlsingle/#jc-authentication">各种身份验证选项</a> ）。</p>
</div>
<div class="paragraph">
<p>添加用户帐户的最简单方法是提供自己的帐户<code>UserDetailsService</code> bean 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-enable-https"><a class="anchor" href="#howto-enable-https"></a> 14.3。在代理服务器后运行时启用HTTPS</h3>
<div class="paragraph">
<p>对于所有应用程序而言，确保所有主要端点仅可通过HTTPS进行访问都是一项重要的工作。如果您将Tomcat用作servlet容器，则Spring Boot会添加Tomcat自己的<code>RemoteIpValve</code>如果它检测到某些环境设置，它将自动运行，并且您应该能够依靠<code>HttpServletRequest</code>报告它是否安全（甚至在处理真实SSL终止的代理服务器的下游）。标准行为取决于是否存在某些请求标头（ <code>x-forwarded-for</code>和<code>x-forwarded-proto</code> ）（其名称为常规名称），因此它应适用于大多数前端代理。您可以通过添加一些条目来打开阀门<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.tomcat.remote-ip-header=x-forwarded-for
server.tomcat.protocol-header=x-forwarded-proto</code></pre>
</div>
</div>
<div class="paragraph">
<p>（这些属性中的任何一个都会在阀门上切换。或者，您可以添加<code>RemoteIpValve</code>通过添加一个<code>TomcatServletWebServerFactory</code> bean 。）</p>
</div>
<div class="paragraph">
<p>要将Spring Security配置为要求所有（或某些）请求有安全通道，请考虑添加自己的请求<code>WebSecurityConfigurerAdapter</code>这增加了以下内容<code>HttpSecurity</code>组态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
public class SslWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Customize the application security
        http.requiresChannel().anyRequest().requiresSecure();
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-hotswapping"><a class="anchor" href="#howto-hotswapping"></a> 15热交换</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot支持热插拔。本部分回答有关其工作方式的问题。</p>
</div>
<div class="sect2">
<h3 id="howto-reload-static-content"><a class="anchor" href="#howto-reload-static-content"></a> 15.1。重新加载静态内容</h3>
<div class="paragraph">
<p>有几种热装选项。推荐的方法是使用<a href="using-spring-boot.html#using-boot-devtools"><code>spring-boot-devtools</code></a> ，因为它提供了其他开发时功能，例如对应用程序快速重启和LiveReload的支持，以及合理的开发时配置（例如模板缓存）。Devtools通过监视类路径的更改来工作。这意味着必须“构建”静态资源更改才能使更改生效。默认情况下，当您保存更改时，这在Eclipse中自动发生。在IntelliJ IDEA中，“生成项目”命令将触发必要的构建。由于<a href="using-spring-boot.html#using-boot-devtools-restart-exclude">默认的重新启动排除项</a> ，对静态资源的更改不会触发应用程序的重新启动。但是，它们确实会触发实时重新加载。</p>
</div>
<div class="paragraph">
<p>另外，在IDE中运行（尤其是在调试时运行）是进行开发的好方法（所有现代IDE都允许重新加载静态资源，并且通常还允许热交换Java类更改）。</p>
</div>
<div class="paragraph">
<p>最后，可以配置<a href="build-tool-plugins.html#build-tool-plugins">Maven和Gradle插件</a> （请参见<code>addResources</code>属性）以支持从命令行运行，并直接从源代码中重新加载静态文件。如果要使用高级工具编写该代码，则可以将其与外部css / js编译器进程一起使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-reload-thymeleaf-template-content"><a class="anchor" href="#howto-reload-thymeleaf-template-content"></a> 15.2。重新加载模板，而无需重新启动容器</h3>
<div class="paragraph">
<p>Spring Boot支持的大多数模板技术都包含一个用于禁用缓存的配置选项（在本文档的后面介绍）。如果您使用<code>spring-boot-devtools</code>模块，这些属性会在开发时<a href="using-spring-boot.html#using-boot-devtools-property-defaults">自动</a>为您<a href="using-spring-boot.html#using-boot-devtools-property-defaults">配置</a> 。</p>
</div>
<div class="sect3">
<h4 id="howto-reload-thymeleaf-content"><a class="anchor" href="#howto-reload-thymeleaf-content"></a> 15.2.1。胸腺模板</h4>
<div class="paragraph">
<p>如果您使用Thymeleaf，请设置<code>spring.thymeleaf.cache</code>至<code>false</code> 。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/thymeleaf/ThymeleafAutoConfiguration.java"><code>ThymeleafAutoConfiguration</code></a>其他Thymeleaf定制选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="howto-reload-freemarker-content"><a class="anchor" href="#howto-reload-freemarker-content"></a> 15.2.2。FreeMarker模板</h4>
<div class="paragraph">
<p>如果您使用FreeMarker，请设置<code>spring.freemarker.cache</code>至<code>false</code> 。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/freemarker/FreeMarkerAutoConfiguration.java"><code>FreeMarkerAutoConfiguration</code></a>其他FreeMarker自定义选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="howto-reload-groovy-template-content"><a class="anchor" href="#howto-reload-groovy-template-content"></a> 15.2.3。Groovy模板</h4>
<div class="paragraph">
<p>如果使用Groovy模板，请设置<code>spring.groovy.template.cache</code>至<code>false</code> 。看到<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/groovy/template/GroovyTemplateAutoConfiguration.java"><code>GroovyTemplateAutoConfiguration</code></a>用于其他Groovy定制选项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-reload-fast-restart"><a class="anchor" href="#howto-reload-fast-restart"></a> 15.3。快速应用重启</h3>
<div class="paragraph">
<p>的<code>spring-boot-devtools</code>该模块包括对应用程序自动重启的支持。尽管不如<a href="https://jrebel.com/software/jrebel/">JRebel</a>这样的技术快，但通常比“冷启动”要快得多。在研究本文档后面讨论的一些更复杂的重载选项之前，您可能应该先尝试一下。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="using-spring-boot.html#using-boot-devtools">using-spring-boot.html</a>部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-reload-java-classes-without-restarting"><a class="anchor" href="#howto-reload-java-classes-without-restarting"></a> 15.4。重新加载Java类而无需重新启动容器</h3>
<div class="paragraph">
<p>许多现代的IDE（Eclipse，IDEA等）都支持字节码的热交换。因此，如果所做的更改不影响类或方法的签名，则应干净地重新加载而没有副作用。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-build"><a class="anchor" href="#howto-build"></a> 16。建立</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot包括Maven和Gradle的构建插件。本部分回答有关这些插件的常见问题。</p>
</div>
<div class="sect2">
<h3 id="howto-build-info"><a class="anchor" href="#howto-build-info"></a> 16.1。生成构建信息</h3>
<div class="paragraph">
<p>Maven插件和Gradle插件都允许生成包含项目的坐标，名称和版本的构建信息。还可以将插件配置为通过配置添加其他属性。如果存在这样的文件，Spring Boot会自动配置一个<code>BuildProperties</code> bean 。</p>
</div>
<div class="paragraph">
<p>要使用Maven生成构建信息，请为<code>build-info</code>目标，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;build-info&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关更多详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/maven-plugin/">Spring Boot Maven插件文档</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例对Gradle执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">springBoot {
    buildInfo()
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">有关更多详细信息，请参见<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/reference/html//#integrating-with-actuator-build-info">Spring Boot Gradle插件文档</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-git-info"><a class="anchor" href="#howto-git-info"></a> 16.2。生成Git信息</h3>
<div class="paragraph">
<p>Maven和Gradle都允许生成一个<code>git.properties</code>包含有关您的状态信息的文件<code>git</code>项目建立时的源代码存储库。</p>
</div>
<div class="paragraph">
<p>对于Maven用户， <code>spring-boot-starter-parent</code> POM包含一个预先配置的插件，用于生成<code>git.properties</code>文件。要使用它，请将以下声明添加到您的POM中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;
            &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gradle用户可以通过使用<a href="https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties"><code>gradle-git-properties</code></a>插件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    id "com.gorylenko.gradle-git-properties" version "1.5.1"
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">提交时间<code>git.properties</code>预期匹配以下格式： <code>yyyy-MM-dd’T’HH:mm:ssZ</code> 。这是上面列出的两个插件的默认格式。使用此格式可以将时间解析为<code>Date</code>及其格式（当序列化为JSON时）由Jackson的日期序列化配置设置控制。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="howto-customize-dependency-versions"><a class="anchor" href="#howto-customize-dependency-versions"></a> 16.3。自定义依赖版本</h3>
<div class="paragraph">
<p>如果您使用直接或间接继承自的Maven构建<code>spring-boot-dependencies</code> （例如， <code>spring-boot-starter-parent</code> ），但您想覆盖特定的第三方依赖关系，则可以添加适当的<code><properties></code>元素。浏览<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.1.RELEASE/spring-boot-project/spring-boot-dependencies/pom.xml"><code>spring-boot-dependencies</code></a> POM提供属性的完整列表。例如，选择其他<code>slf4j</code>版本，您将添加以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;properties&gt;
    &lt;slf4j.version&gt;1.7.5&lt;slf4j.version&gt;
&lt;/properties&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">仅当您的Maven项目从（直接或间接）继承时，此方法才有效<code>spring-boot-dependencies</code> 。如果您添加了<code>spring-boot-dependencies</code>在你自己的<code>dependencyManagement</code>与节<code><scope>import</scope></code> ，您必须自己重新定义工件，而不是覆盖属性。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">每个Spring Boot版本都是针对这组特定的第三方依赖关系进行设计和测试的。覆盖版本可能会导致兼容性问题。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要覆盖Gradle中的依赖版本，请参阅Gradle插件文档的<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/gradle-plugin/reference/html//#managing-dependencies-customizing">这一部分</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-create-an-executable-jar-with-maven"><a class="anchor" href="#howto-create-an-executable-jar-with-maven"></a> 16.4。使用Maven创建可执行JAR</h3>
<div class="paragraph">
<p>的<code>spring-boot-maven-plugin</code>可用于创建可执行的“胖” JAR。如果您使用<code>spring-boot-starter-parent</code> POM，您可以声明插件，然后将jar重新包装如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不使用父POM，则仍然可以使用该插件。但是，您还必须添加一个<code><executions></code>部分，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;repackage&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关完整用法的详细信息，请参阅<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/maven-plugin//usage.html">插件文档</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-create-an-additional-executable-jar"><a class="anchor" href="#howto-create-an-additional-executable-jar"></a> 16.5。使用Spring Boot应用程序作为依赖项</h3>
<div class="paragraph">
<p>像war文件一样，Spring Boot应用程序也不打算用作依赖项。如果您的应用程序包含要与其他项目共享的类，则建议的方法是将该代码移到单独的模块中。然后，您的应用程序和其他项目可以依赖单独的模块。</p>
</div>
<div class="paragraph">
<p>如果您不能按照上面的建议重新排列代码，则必须将Spring Boot的Maven和Gradle插件配置为产生适合用作依赖项的独立工件。可执行存档不能用作依赖项，因为<a href="appendix-executable-jar-format.html#executable-jar-jar-file-structure">可执行jar格式将</a>应用程序类打包在<code>BOOT-INF/classes</code> 。这意味着当将可执行jar用作依赖项时，找不到它们。</p>
</div>
<div class="paragraph">
<p>为了产生两个工件，一个可以用作依赖项，另一个可以执行，必须指定分类器。该分类器应用于可执行归档文件的名称，保留默认归档文件以用作依赖项。</p>
</div>
<div class="paragraph">
<p>配置的分类器<code>exec</code>在Maven中，可以使用以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;classifier&gt;exec&lt;/classifier&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-extract-specific-libraries-when-an-executable-jar-runs"><a class="anchor" href="#howto-extract-specific-libraries-when-an-executable-jar-runs"></a> 16.6。运行可执行jar时提取特定的库</h3>
<div class="paragraph">
<p>可执行jar中的大多数嵌套库不需要解压即可运行。但是，某些库可能会有问题。例如，JRuby包含自己的嵌套jar支持，它假定<code>jruby-complete.jar</code>总是可以直接以文件的形式直接使用。</p>
</div>
<div class="paragraph">
<p>为了处理任何有问题的库，您可以标记在可执行jar首次运行时应自动解压缩特定的嵌套jar。这些嵌套的jar会写在由<code>java.io.tmpdir</code>系统属性。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">应注意确保已配置您的操作系统，以便在应用程序仍在运行时，它不会删除已解压缩到临时目录中的jar。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，为了指示应该使用Maven插件将JRuby标记为要解包，您可以添加以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;requiresUnpack&gt;
                    &lt;dependency&gt;
                        &lt;groupId&gt;org.jruby&lt;/groupId&gt;
                        &lt;artifactId&gt;jruby-complete&lt;/artifactId&gt;
                    &lt;/dependency&gt;
                &lt;/requiresUnpack&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-create-a-nonexecutable-jar"><a class="anchor" href="#howto-create-a-nonexecutable-jar"></a> 16.7。创建带有排除项的不可执行的JAR</h3>
<div class="paragraph">
<p>通常，如果您具有一个可执行文件和一个不可执行的jar作为两个单独的构建产品，则可执行版本具有库jar中不需要的其他配置文件。例如， <code>application.yml</code>配置文件可能被排除在不可执行的JAR中。</p>
</div>
<div class="paragraph">
<p>在Maven中，可执行jar必须是主要工件，您可以为库添加一个分类的jar，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;lib&lt;/id&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;jar&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;classifier&gt;lib&lt;/classifier&gt;
                        &lt;excludes&gt;
                            &lt;exclude&gt;application.yml&lt;/exclude&gt;
                        &lt;/excludes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-remote-debug-maven-run"><a class="anchor" href="#howto-remote-debug-maven-run"></a> 16.8。远程调试以Maven开头的Spring Boot应用程序</h3>
<div class="paragraph">
<p>要将远程调试器附加到使用Maven启动的Spring Boot应用程序，可以使用<code>jvmArguments</code> <a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/maven-plugin/">Maven插件的</a>属性。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/maven-plugin//examples/run-debug.html">见此示例</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-build-an-executable-archive-with-ant"><a class="anchor" href="#howto-build-an-executable-archive-with-ant"></a> 16.9。在不使用Ant的情况下从Ant构建可执行存档<code>spring-boot-antlib</code></h3>
<div class="paragraph">
<p>要使用Ant进行构建，您需要获取依赖项，进行编译，然后创建一个jar或war存档。要使其可执行，您可以使用<code>spring-boot-antlib</code>模块，也可以按照以下说明进行操作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果要构建jar，请将应用程序的类和资源打包到嵌套中<code>BOOT-INF/classes</code>目录。如果要发动战争，请将应用程序的类打包在嵌套中<code>WEB-INF/classes</code>目录照常。</p>
</li>
<li>
<p>在嵌套中添加运行时依赖项<code>BOOT-INF/lib</code> jar的目录或<code>WEB-INF/lib</code>一场战争。切记<strong>不要</strong>压缩存档中的条目。</p>
</li>
<li>
<p>添加<code>provided</code> （嵌入式容器）嵌套中的依赖项<code>BOOT-INF/lib</code> jar的目录或<code>WEB-INF/lib-provided</code>一场战争。切记<strong>不要</strong>压缩存档中的条目。</p>
</li>
<li>
<p>添加<code>spring-boot-loader</code>档案根目录中的类（以便<code>Main-Class</code>可用）。</p>
</li>
<li>
<p>使用适当的启动器（例如<code>JarLauncher</code>用于jar文件） <code>Main-Class</code>清单中的属性，并指定其作为清单条目所需的其他属性-主要是通过设置<code>Start-Class</code>属性。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用Ant构建可执行归档文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;target name="build" depends="compile"&gt;
    &lt;jar destfile="target/${ant.project.name}-${spring-boot.version}.jar" compress="false"&gt;
        &lt;mappedresources&gt;
            &lt;fileset dir="target/classes" /&gt;
            &lt;globmapper from="*" to="BOOT-INF/classes/*"/&gt;
        &lt;/mappedresources&gt;
        &lt;mappedresources&gt;
            &lt;fileset dir="src/main/resources" erroronmissingdir="false"/&gt;
            &lt;globmapper from="*" to="BOOT-INF/classes/*"/&gt;
        &lt;/mappedresources&gt;
        &lt;mappedresources&gt;
            &lt;fileset dir="${lib.dir}/runtime" /&gt;
            &lt;globmapper from="*" to="BOOT-INF/lib/*"/&gt;
        &lt;/mappedresources&gt;
        &lt;zipfileset src="${lib.dir}/loader/spring-boot-loader-jar-${spring-boot.version}.jar" /&gt;
        &lt;manifest&gt;
            &lt;attribute name="Main-Class" value="org.springframework.boot.loader.JarLauncher" /&gt;
            &lt;attribute name="Start-Class" value="${start-class}" /&gt;
        &lt;/manifest&gt;
    &lt;/jar&gt;
&lt;/target&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howto-traditional-deployment"><a class="anchor" href="#howto-traditional-deployment"></a> 17。传统部署</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot支持传统部署以及更现代的部署形式。本节回答有关传统部署的常见问题。</p>
</div>
<div class="sect2">
<h3 id="howto-create-a-deployable-war-file"><a class="anchor" href="#howto-create-a-deployable-war-file"></a> 17.1。创建可部署的战争文件</h3>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">由于Spring WebFlux不严格依赖Servlet API，并且默认情况下将应用程序部署在嵌入式Reactor Netty服务器上，因此WebFlux应用程序不支持War部署。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>产生可部署战争文件的第一步是提供一个<code>SpringBootServletInitializer</code>子类并覆盖其<code>configure</code>方法。这样做利用了Spring Framework的Servlet 3.0支持，并允许您在由Servlet容器启动应用程序时对其进行配置。通常，您应该更新应用程序的主类以扩展<code>SpringBootServletInitializer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是更新构建配置，以使您的项目生成war文件而不是jar文件。如果您使用Maven和<code>spring-boot-starter-parent</code> （为您配置Maven的war插件），您所需要做的就是修改<code>pom.xml</code>将包装更改为战争，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;packaging&gt;war&lt;/packaging&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用Gradle，则需要修改<code>build.gradle</code>将war插件应用于项目，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">apply plugin: 'war'</code></pre>
</div>
</div>
<div class="paragraph">
<p>该过程的最后一步是确保嵌入式servlet容器不干扰war文件所部署到的servlet容器。为此，您需要将嵌入式Servlet容器依赖性标记为已提供。</p>
</div>
<div class="paragraph">
<p>如果使用Maven，则以下示例将servlet容器（在本例中为Tomcat）标记为已提供：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;!-- … --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!-- … --&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用Gradle，则以下示例将servlet容器（在本例中为Tomcat）标记为已提供：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    // …
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
    // …
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<code>providedRuntime</code>比Gradle的首选<code>compileOnly</code>组态。除其他限制外， <code>compileOnly</code>依赖项不在测试类路径上，因此任何基于Web的集成测试都将失败。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您使用<a href="build-tool-plugins.html#build-tool-plugins">Spring Boot构建工具</a> ，则将提供的嵌入式servlet容器依赖关系标记为提供的文件，将生成可执行的war文件，并在文件中打包提供的依赖关系。 <code>lib-provided</code>目录。这意味着，除了可以部署到Servlet容器之外，您还可以通过以下方式运行应用程序： <code>java -jar</code>在命令行上。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-convert-an-existing-application-to-spring-boot"><a class="anchor" href="#howto-convert-an-existing-application-to-spring-boot"></a> 17.2。将现有应用程序转换为Spring Boot</h3>
<div class="paragraph">
<p>对于非Web应用程序，将现有的Spring应用程序转换为Spring Boot应用程序应该很容易。为此，请丢弃创建您的代码<code>ApplicationContext</code>并将其替换为<code>SpringApplication</code>要么<code>SpringApplicationBuilder</code> 。Spring MVC Web应用程序通常适合首先创建可部署的war应用程序，然后再将其迁移到可执行的war或jar。请参阅<a href="https://spring.io/guides/gs/convert-jar-to-war/">有关将罐子转换为战争的入门指南</a> 。</p>
</div>
<div class="paragraph">
<p>通过扩展制造可展开的战争<code>SpringBootServletInitializer</code> （例如，在一个名为<code>Application</code> ）并添加Spring Boot <code>@SpringBootApplication</code>注释，使用类似于以下示例中所示的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        // Customize the application or call application.sources(...) to add sources
        // Since our example is itself a @Configuration class (via @SpringBootApplication)
        // we actually don't need to override this method.
        return application;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，无论您输入<code>sources</code>只是 Spring <code>ApplicationContext</code> 。通常，任何已经起作用的东西都应该在这里工作。可能有些bean可以稍后删除，然后让Spring Boot为它们提供自己的默认值，但是应该可以使某些东西工作，然后再执行此操作。</p>
</div>
<div class="paragraph">
<p>可以将静态资源移至<code>/public</code> （要么<code>/static</code>要么<code>/resources</code>要么<code>/META-INF/resources</code> ）在classpath根目录中。同样适用于<code>messages.properties</code> （Spring Boot会在类路径的根目录中自动检测到）。</p>
</div>
<div class="paragraph">
<p> Spring 的香草用法<code>DispatcherServlet</code> Spring Security不需要进一步更改。如果您的应用程序具有其他功能（例如，使用其他servlet或过滤器），则可能需要在您的应用程序中添加一些配置<code>Application</code>上下文中，通过替换<code>web.xml</code> ， 如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>@Bean</code>类型的<code>Servlet</code>要么<code>ServletRegistrationBean</code>将该bean安装在容器中，就好像它是<code><servlet/></code>和<code><servlet-mapping/></code>在<code>web.xml</code> 。</p>
</li>
<li>
<p>一种<code>@Bean</code>类型的<code>Filter</code>要么<code>FilterRegistrationBean</code>表现类似（作为<code><filter/></code>和<code><filter-mapping/></code> ）。</p>
</li>
<li>
<p>一个<code>ApplicationContext</code>可以通过<code>@ImportResource</code>在你的<code>Application</code> 。另外，可以在几行中重新创建已经大量使用注释配置的简单情况，如下所示： <code>@Bean</code>定义。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>战争文件正常运行后，您可以通过添加一个<code>main</code>对你的方法<code>Application</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您打算以战争或可执行应用程序的形式启动应用程序，则需要以一种既可用于开发环境又可用于方法的方式共享构建器的定制。 <code>SpringBootServletInitializer</code>回调和<code>main</code>类中的方法类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        return configureApplication(builder);
    }

    public static void main(String[] args) {
        configureApplication(new SpringApplicationBuilder()).run(args);
    }

    private static SpringApplicationBuilder configureApplication(SpringApplicationBuilder builder) {
        return builder.sources(Application.class).bannerMode(Banner.Mode.OFF);
    }

}</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>应用程序可以分为多个类别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servlet 3.0+应用程序，无<code>web.xml</code> 。</p>
</li>
<li>
<p>带有<code>web.xml</code> 。</p>
</li>
<li>
<p>具有上下文层次结构的应用程序。</p>
</li>
<li>
<p>没有上下文层次结构的应用程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有这些都应该适合翻译，但是每种可能都需要稍微不同的技术。</p>
</div>
<div class="paragraph">
<p>如果Servlet 3.0+应用程序已经使用了Spring Servlet 3.0+初始化程序支持类，那么它们可能会很容易转换。通常，所有代码来自现有<code>WebApplicationInitializer</code>可以移动到<code>SpringBootServletInitializer</code> 。如果您现有的应用程序有多个<code>ApplicationContext</code> （例如，如果使用<code>AbstractDispatcherServletInitializer</code> ），那么您也许可以将所有上下文资源合并为一个<code>SpringApplication</code> 。您可能会遇到的主要并发症是，如果合并无效，则需要维护上下文层次结构。有关示例，请参见<a href="#howto-build-an-application-context-hierarchy">有关构建层次结构</a>的<a href="#howto-build-an-application-context-hierarchy">条目</a> 。通常需要分解包含特定于Web的功能的现有父上下文，以便所有<code>ServletContextAware</code>组件位于子上下文中。</p>
</div>
<div class="paragraph">
<p>还不是Spring应用程序的应用程序可以转换为Spring Boot应用程序，前面提到的指南可能会有所帮助。但是，您可能仍然遇到问题。在这种情况下，建议您<a href="https://stackoverflow.com/questions/tagged/spring-boot">使用标记“ <code>spring-boot</code></a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-weblogic"><a class="anchor" href="#howto-weblogic"></a> 17.3。将WAR部署到WebLogic</h3>
<div class="paragraph">
<p>要将Spring Boot应用程序部署到WebLogic，必须确保servlet初始化程序<strong>直接</strong>实现<code>WebApplicationInitializer</code> （即使您从已经实现它的基类扩展）。</p>
</div>
<div class="paragraph">
<p>WebLogic的典型初始化程序应类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
import org.springframework.web.WebApplicationInitializer;

@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer implements WebApplicationInitializer {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用Logback，则还需要告诉WebLogic首选打包版本，而不是服务器预先安装的版本。您可以通过添加一个<code>WEB-INF/weblogic.xml</code>包含以下内容的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;wls:weblogic-web-app
    xmlns:wls="http://xmlns.oracle.com/weblogic/weblogic-web-app"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
        https://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd
        http://xmlns.oracle.com/weblogic/weblogic-web-app
        https://xmlns.oracle.com/weblogic/weblogic-web-app/1.4/weblogic-web-app.xsd"&gt;
    &lt;wls:container-descriptor&gt;
        &lt;wls:prefer-application-packages&gt;
            &lt;wls:package-name&gt;org.slf4j&lt;/wls:package-name&gt;
        &lt;/wls:prefer-application-packages&gt;
    &lt;/wls:container-descriptor&gt;
&lt;/wls:weblogic-web-app&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-use-jedis-instead-of-lettuce"><a class="anchor" href="#howto-use-jedis-instead-of-lettuce"></a> 17.4。使用Jedis代替生菜</h3>
<div class="paragraph">
<p>默认情况下，Spring Boot启动器（ <code>spring-boot-starter-data-redis</code> ）使用<a href="https://github.com/lettuce-io/lettuce-core/">生菜</a> 。您需要排除该依赖性，而改为包含<a href="https://github.com/xetorthio/jedis/">Jedis</a> 。Spring Boot管理这些依赖关系，以帮助简化该过程。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Maven中执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何在Gradle中执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">configurations {
    compile.exclude module: "lettuce"
}

dependencies {
    compile("redis.clients:jedis")
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-11-06 21:59:19 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>