<html lang="zh-Hans" ><head></head><body class="book toc2 toc-left" >﻿
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Stéphane Nicoll, Dave Syer, Madhura Bhave">
<title>Spring Initializr参考指南</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


<div id="header">
<h1>Spring Initializr参考指南</h1>
<div class="details">
<span id="author" class="author">斯特凡·尼科尔（StéphaneNicoll）</span><br>
<span id="author2" class="author">戴夫·瑟</span><br>
<span id="author3" class="author">Madhura Bhave</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel0">
<li><a href="#initializr-documentation">Spring Initializr文档</a>
<ul class="sectlevel1">
<li><a href="#initializr-documentation-about">1。关于文档</a></li>
<li><a href="#initializr-documentation-getting-help">2。获得帮助</a></li>
</ul>
</li>
<li><a href="#user-guide">用户指南</a>
<ul class="sectlevel1">
<li><a href="#getting-started">3。入门</a>
<ul class="sectlevel2">
<li><a href="#getting-started-advanced-options">3.1。高级选项</a></li>
<li><a href="#getting-started-dependencies">3.2。依存关系</a></li>
<li><a href="#getting-started-tuning-defaults">3.3。调整默认值</a></li>
</ul>
</li>
<li><a href="#command-line">4。命令行支持</a></li>
<li><a href="#ide">5，IDE支持</a></li>
<li><a href="#spring-boot-cli">6。Spring Boot CLI支持</a></li>
</ul>
</li>
<li><a href="#configuration-guide">配置指南</a>
<ul class="sectlevel1">
<li><a href="#project-generation-overview">7。项目生成概述</a>
<ul class="sectlevel2">
<li><a href="#initializr-generator">7.1。Initializr生成器</a>
<ul class="sectlevel3">
<li><a href="#initializr-generator-project">7.1.1。项目生成器</a></li>
<li><a href="#initializr-generator-project-lifecycle">7.1.2。项目生成生命周期</a></li>
<li><a href="#initializr-generator-abstractions">7.1.3。项目抽象</a></li>
</ul>
</li>
<li><a href="#initializr-generator-spring">7.2。Spring Boot约定</a>
<ul class="sectlevel3">
<li><a href="#initializr-generator-spring-requirements">7.2.1。要求</a></li>
<li><a href="#initializr-generator-spring-facets">7.2.2。受支持的方面</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#create-instance">8。创建自己的实例</a>
<ul class="sectlevel2">
<li><a href="#create-instance-basic-settings">8.1。配置基本设置</a></li>
<li><a href="#create-instance-text-only-settings">8.2。配置纯文本设置</a></li>
<li><a href="#create-instance-boot-versions">8.3。配置可用的Spring Boot版本</a></li>
<li><a href="#create-instance-types">8.4。配置可用的项目类型</a></li>
<li><a href="#create-instance-dependencies">8.5。配置依赖</a>
<ul class="sectlevel3">
<li><a href="#dependencies-compatibility-range">8.5.1。相容范围</a></li>
<li><a href="#dependencies-repository">8.5.2。资料库</a></li>
</ul>
</li>
<li><a href="#create-instance-boms">8.6。配置物料清单</a>
<ul class="sectlevel3">
<li><a href="#dependencies-mappings">8.6.1。根据Spring Boot版本映射坐标</a></li>
<li><a href="#dependencies-alias">8.6.2。别名</a></li>
<li><a href="#dependencies-facet">8.6.3。刻面</a></li>
<li><a href="#create-instance-dependencies-link">8.6.4。链接</a></li>
<li><a href="#create-instance-dependencies-search">8.6.5。改善搜寻结果</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#configuration-howto">9。“操作方法”指南</a>
<ul class="sectlevel2">
<li><a href="#howto-add-a-new-dependency">9.1。添加一个新的依赖</a></li>
<li><a href="#howto-override-a-version">9.2。覆盖依赖项的版本</a></li>
<li><a href="#howto-link-boot-version">9.3。将引导版本链接到依赖项的版本</a></li>
<li><a href="#howto-add-snapshot-repository">9.4。配置快照存储库</a></li>
<li><a href="#howto-configure-custom-parent-pom">9.5。配置自定义父POM</a></li>
<li><a href="#howto-dependency-starter-flag">9.6。确保常规依赖项带来了基础入门</a></li>
<li><a href="#howto-group-share-settings">9.7。在组中共享常见的依赖项设置</a></li>
</ul>
</li>
<li><a href="#create-instance-advanced-config">10。进阶设定</a>
<ul class="sectlevel2">
<li><a href="#create-instance-advanced-config-caching">10.1。缓存配置</a></li>
<li><a href="#create-instance-advanced-config-custom-project-request">10.2。绑定到自定义项目请求</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#api-guide">API指南</a>
<ul class="sectlevel1">
<li><a href="#metadata-format">11。元数据格式</a>
<ul class="sectlevel2">
<li><a href="#content">11.1。内容</a>
<ul class="sectlevel3">
<li><a href="#project-dependencies">11.1.1。项目依赖</a></li>
<li><a href="#project-types">11.1.2。项目类型</a></li>
<li><a href="#packaging">11.1.3。打包</a></li>
<li><a href="#java-version">11.1.4。Java版本</a></li>
<li><a href="#languages">11.1.5。语言能力</a></li>
<li><a href="#boot-version">11.1.6。开机版本</a></li>
</ul>
</li>
<li><a href="#defaults">11.2。默认值</a></li>
</ul>
</li>
<li><a href="#using-the-stubs">12使用存根</a>
<ul class="sectlevel2">
<li><a href="#using-wiremock-with-spring-boot">12.1。在Spring Boot中使用WireMock</a>
<ul class="sectlevel3">
<li><a href="#loading-stubs-from-the-classpath">12.1.1。从类路径加载存根</a></li>
<li><a href="#using-the-stub-runner">12.1.2。使用存根运行器</a></li>
</ul>
</li>
<li><a href="#names-and-paths-of-stubs">12.2。存根的名称和路径</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<h1 id="initializr-documentation" class="sect0"><a class="anchor" href="#initializr-documentation"></a> Spring Initializr文档</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>本节简要概述了Spring Initializr参考文档：将其视为文档其余部分的映射。有些部分是针对特定受众的，因此本参考指南并不旨在以线性方式阅读。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Initializr提供了一个可扩展的API，以生成基于JVM的项目，并检查用于生成项目的元数据，例如列出可用的依赖项和版本。</p>
</div>
<div class="paragraph">
<p>该文档大致分为三个部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#user-guide">用户指南</a> ：本部分介绍如何使用默认的Spring Initializr实例，该实例可从<a href="https://start.spring.io" class="bare">start.spring.io</a>获得。</p>
</li>
<li>
<p><a href="#configuration-guide">配置指南</a> ：本节介绍使用jars作为自己应用程序中的库来创建自己的Spring Initializr实例。</p>
</li>
<li>
<p><a href="#api-guide">API指南</a> ：本节介绍用于项目生成的API。该API可以独立使用，也可以嵌入其他工具中（例如，在主要IDE中使用，例如Spring Tool Suite，IntelliJ IDEA Ultimate，Netbeans和VSCode）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过将jars用作自己应用程序中的库，您可以使用Spring Initializr轻松创建自己的实例。所涉及的代码最少，并且该服务具有非常丰富的配置结构，使您不仅可以定义各种项目属性的值，还可以定义依赖项列表以及要应用于它们的约束。如果这听起来很有趣，那么《 <a href="#configuration-guide">配置指南》将</a>提供您所需的所有详细信息。您可能只想修改Spring Initializr的现有实例，例如添加新的依赖关系类型，或更新现有实例的版本。对于那些以及其他简单和常见的用例，请查看<a href="#configuration-howto">“操作指南”</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Initializr还提供了可扩展的API，以生成基于JVM的项目，并检查用于生成项目的元数据，例如列出可用的依赖项和版本。该API可以独立使用，也可以嵌入其他工具中（例如，在主要IDE中使用，例如Spring Tool Suite，IntelliJ IDEA Ultimate，Netbeans和VSCode）。这些功能在<a href="#api-guide">API指南中介绍</a> 。</p>
</div>
<div class="sect1">
<h2 id="initializr-documentation-about"><a class="anchor" href="#initializr-documentation-about"></a> 1。关于文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Initializr参考指南可作为<a href="https://docs.spring.io/initializr/docs/0.8.0.RELEASE/reference/html">html获得</a> 。最新的副本可在<a href="https://docs.spring.io/initializr/docs/current/reference/html" class="bare">docs.spring.io/initializr/docs/current/reference/html中获得</a> 。</p>
</div>
<div class="paragraph">
<p>本文档的副本可以供您自己使用，也可以分发给他人，但前提是您不对此类副本收取任何费用，并且还应确保每份副本均包含本版权声明（无论是印刷版本还是电子版本）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initializr-documentation-getting-help"><a class="anchor" href="#initializr-documentation-getting-help"></a> 2。获得帮助</h2>
<div class="sectionbody">
<div class="paragraph">
<p>遇到Spring Initializr的麻烦，我们想为您提供帮助！</p>
</div>
<div class="ulist">
<ul>
<li>
<p>问一个关于<a href="https://gitter.im/spring-io/initializr">Gitter</a>的问题。</p>
</li>
<li>
<p>在<a href="https://github.com/spring-io/initializr/issues" class="bare">github.com/spring-io/initializr/issues中</a>报告Spring Initializr的<a href="https://github.com/spring-io/initializr/issues" class="bare">错误</a> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">所有的Spring Initializr都是开源的，包括文档！如果您发现文档有问题；或者，如果您只是想改善它们，请<a href="https://github.com/spring-io/initializr/tree/v0.8.0.RELEASE">参与</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<h1 id="user-guide" class="sect0"><a class="anchor" href="#user-guide"></a>用户指南</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>如果您想知道如何使用<a href="https://start.spring.io" class="bare">start.spring.io</a>或可以使用哪些功能，那么本部分适合您！您将找到与服务交互的各种方式，并且可以更好地了解如何使用该服务。</p>
</div>
<div class="paragraph">
<p>该服务使您可以快速生成Spring Boot项目。您可以定制要生成的项目：生成系统和打包，语言，打包，坐标，平台版本，最后是要添加到项目的依赖项。<a href="https://start.spring.io" class="bare">start.spring.io</a>上可用的大多数依赖<a href="https://start.spring.io" class="bare">项</a>都是Spring Boot启动器，这是向Spring Boot应用程序添加依赖项的推荐方法。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a> 3。入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>让我们创建一个项目，并发现可用于调整它的各种选项。转到<a href="https://start.spring.io" class="bare">start.spring.io</a> ，更改<code>Group</code>字段从“ com.example”到“ org.acme”，并将焦点放在<code>Dependencies</code>下面的字段。如果您输入“ web”，则会看到具有该简单条件的匹配选项列表。使用鼠标或箭头键，然后<code>Enter</code>选择“ Web”启动器。</p>
</div>
<div class="paragraph">
<p>您的浏览器现在应该处于这种状态：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/web-selected.png" alt="浏览器" width="1200" height="720">
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">上面的Spring Boot版本可能与您的版本不匹配。稍后我们将看到，start.spring.io在发布新的Spring Boot版本时会不断更新，并且该服务默认使用最新版本。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>点击<code>Generate Project</code> ，这将下载一个包含以下结构的Maven项目的zip文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>.gitignore
mvnw
mvnw.cmd
pom.xml
src
├── main
│   ├── java
│   │   └── org
│   │       └── acme
│   │           └── DemoApplication.java
│   └── resources
│       ├── application.properties
│       ├── static
│       └── templates
└── test
    └── java
        └── org
            └── acme
                └── DemoApplicationTests.java</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Initializr生成的典型项目包含一个Spring Boot应用程序（ <code>DemoApplication</code> ），测试和空配置。如果您运行<code>main</code>的方法<code>DemoApplication</code> ，您会看到一个从localhost：8080开始的“空” spring boot应用程序。</p>
</div>
<div class="paragraph">
<p>由于Spring Initializr已检测到它是一个Web应用程序，因此<code>static</code>和<code>templates</code>已创建目录来保存您的静态资源和UI模板。</p>
</div>
<div class="paragraph">
<p>此外，会自动包含Maven包装器，因此您无需安装Maven即可运行此项目（您可以使用<code>./mvnw install</code> ）。如果愿意，可以在屏幕顶部的第一个选项中选择Gradle。这将生成一个基于Gradle的项目，其中还包含一个包装器，如果您没有安装Gradle，则可以使用该包装器（使用<code>./gradlew build</code> ）。</p>
</div>
<div class="sect2">
<h3 id="getting-started-advanced-options"><a class="anchor" href="#getting-started-advanced-options"></a> 3.1。高级选项</h3>
<div class="paragraph">
<p>以下<code>Artifact</code>表单字段中，您会找到“选项”链接。如果单击该按钮，将看到所有可用选项。让我们快速浏览它们：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>组</strong> ：项目坐标（项目组的ID，由<code>groupId</code>属性（在Apache Maven中）。还推断出要使用的根软件包名称。</p>
</li>
<li>
<p><strong>工件</strong> ：项目坐标（ <strong>工件的</strong> ID，由<code>artifactId</code>属性（在Apache Maven中）。还可以推断项目的名称</p>
</li>
<li>
<p><strong>名称</strong> ：项目的显示名称，它也确定您的Spring Boot应用程序的名称。例如，如果您的项目名称是<code>my-app</code> ，生成的项目将有一个<code>MyAppApplication</code>类</p>
</li>
<li>
<p><strong>描述</strong> ：项目描述</p>
</li>
<li>
<p><strong>包名称</strong> ：项目的根包。如果未指定，则使用“ <strong>组”</strong>属性的值</p>
</li>
<li>
<p><strong>包装</strong> ：项目包装（在Apache Maven中由相同名称的概念引用）。 start.spring.io可以生成jar或war项目</p>
</li>
<li>
<p><strong>Java</strong> ：要使用的Java版本</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-dependencies"><a class="anchor" href="#getting-started-dependencies"></a> 3.2。依存关系</h3>
<div class="paragraph">
<p>UI允许您选择要使用的Spring Boot版本。您可能要保守一些，并保持默认值始终与最新的稳定版本相对应。或者，您可能要选择下一个主要版本的里程碑或快照。无论哪种方式，您都会注意到某些依赖项变得可用，而更改版本时不再可用。</p>
</div>
<div class="paragraph">
<p>如果您搜索一个已知可用的依赖项，并获得一个禁用的面板，则表明您不能在当前选择的Spring Boot版本中使用它；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Requires Spring Boot &gt;=2.0.0.RELEASE and &lt;2.1.0.RELEASE</code></pre>
</div>
</div>
<div class="paragraph">
<p>具体来说，这定义了一个“版本范围”，该版本说明该依赖性已被弃用，并且从Spring Boot 2.1开始不再可用。您可能需要查看相关项目的发行说明，以了解迁移路径可以是什么。或者，该消息可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Requires Spring Boot &gt;=2.2.0.RELEASE</code></pre>
</div>
</div>
<div class="paragraph">
<p>该版本范围意味着该依赖项不适用于所选的Spring Boot代。如果选择Spring Boot 2.2（或更高版本，如果可用），则可以选择该依赖项。</p>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-tuning-defaults"><a class="anchor" href="#getting-started-tuning-defaults"></a> 3.3。调整默认值</h3>
<div class="paragraph">
<p>Spring Initializr服务被配置为提供默认值，以便您可以以最小的麻烦生成一个新项目。也许您是科特林的粉丝？还是Gradle风扇？当前，start.spring.io默认为Java和Maven，但它也允许您轻松调整这些默认值。</p>
</div>
<div class="paragraph">
<p>您可以共享或添加书签，这些URL将自动自定义表单输入。您可以使用<code>share</code>根据您当前的选择生成URL的操作。该URL包含所有属性，但是您可以删除不需要的属性。例如，以下URL将默认值更改为使用Kotlin和Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>https://start.spring.io/#!language=kotlin&amp;type=gradle-project</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Boot版本：<code>platformVersion</code></p>
</li>
<li>
<p>依存关系：<code>dependencies</code></p>
</li>
<li>
<p>编程语言： <code>language</code> （ <code>java</code> ， <code>groovy</code>要么<code>kotlin</code> ）</p>
</li>
<li>
<p>Java版本： <code>javaVersion</code> （ <code>1.8</code> ， <code>11</code> ， <code>12</code> ）</p>
</li>
<li>
<p>项目类型： <code>type</code> （ <code>maven-project</code> ， <code>gradle-project</code> ）</p>
</li>
<li>
<p>打包： <code>packaging</code> （ <code>jar</code> ， <code>war</code> ）</p>
</li>
<li>
<p>组：<code>groupId</code></p>
</li>
<li>
<p>工件：<code>artifactId</code></p>
</li>
<li>
<p>名称：<code>name</code></p>
</li>
<li>
<p>描述：<code>description</code></p>
</li>
<li>
<p>包裹名字：<code>packageName</code></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果属性被覆盖，则将应用相同的默认规则。例如，如果该组是自定义的，它也会自动自定义根包。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果Spring Boot版本已过时，则UI将要求您做出选择并选择支持的版本。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="command-line"><a class="anchor" href="#command-line"></a> 4。命令行支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您还可以使用以下命令在Shell中生成项目<code>cURL</code>要么<code>HTTPie</code> 。要发现特定实例的可用选项，只需“卷曲”它，即如果您有<code>curl</code>安装的调用<code>curl <a href="https://start.spring.io" class="bare">start.spring.io</a></code>在命令行上（或替代<code>http <a href="https://start.spring.io" class="bare">start.spring.io</a></code>如果您喜欢使用<code>HTTPie</code> ）。</p>
</div>
<div class="paragraph">
<p>结果是服务功能的文本表示形式，分为三个部分：</p>
</div>
<div class="paragraph">
<p>首先，一张表描述可用的项目类型。在默认实例上，您会发现<code>maven-project</code>和<code>gradle-project</code>上面我们已经讨论过了，但是您也只能生成一个构建脚本，而不是整个项目。</p>
</div>
<div class="paragraph">
<p>然后，描述可用参数的表。在大多数情况下，这些选项与Web UI中可用的选项相同。但是，还有其他一些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>applicationName</code>可以用来定义应用程序的名称，并根据<code>name</code>参数</p>
</li>
<li>
<p><code>baseDir</code>可用于在档案中创建基本目录，以便您可以提取生成的zip而不先为其创建目录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，定义依赖项列表。每个条目都提供了您要选择依赖项时必须使用的标识符，描述和Spring Boot版本范围（如果有）。</p>
</div>
<div class="paragraph">
<p>除了该服务的功能外，您还将找到一些示例来帮助您了解如何生成项目。这些显然是针对您正在使用的客户端量身定制的。</p>
</div>
<div class="paragraph">
<p>假设您要基于Spring Boot生成一个“ my-project.zip”项目<code>2.1.9.RELEASE</code> ， 使用<code>web</code>和<code>devtools</code>依赖关系（请记住，这两个标识显示在服务的功能中）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ curl https://start.spring.io/starter.zip -d dependencies=web,devtools \
           -d bootVersion=2.1.9.RELEASE -o my-project.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您提取<code>my-project.zip</code> ，您会发现与网络用户界面相比有一些区别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该项目将被提取到当前目录中（Web UI自动添加一个与该项目名称相同的基本目录）</p>
</li>
<li>
<p>项目名称不是<code>my-project</code> （ <code>-o</code>参数对项目名称没有影响）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以使用<code>http</code>命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ http https://start.spring.io/starter.zip dependencies==web,devtools \
           bootVersion==2.1.9.RELEASE -d</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>HTTPie</code>读取与浏览器相同的提示，因此它将存储一个<code>demo.zip</code>文件在当前目录中，与上面讨论的相同。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ide"><a class="anchor" href="#ide"></a> 5，IDE支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Initializr还集成在所有主要的Java IDE中，使您可以创建和导入新项目，而不必将IDE留给命令行或Web UI。</p>
</div>
<div class="paragraph">
<p>以下IDE具有专门的支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eclipse / STS</p>
</li>
<li>
<p>IntelliJ IDEA（最终版）</p>
</li>
<li>
<p>NetBeans（使用<a href="https://plugins.netbeans.org/plugin/67888/nb-springboot">NB SpringBoot插件</a> ）</p>
</li>
<li>
<p>微软VSCode</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参考您喜欢的IDE的文档。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-boot-cli"><a class="anchor" href="#spring-boot-cli"></a> 6。Spring Boot CLI支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>spring</code>命令行工具定义了<code>init</code>命令，使您可以使用Spring Initializr创建项目。</p>
</div>
<div class="paragraph">
<p>请查阅<a href="https://docs.spring.io/spring-boot/docs/2.1.9.RELEASE/reference/htmlsingle/#cli-init">文档以获取更多详细信息</a> 。</p>
</div>
</div>
</div>
<h1 id="configuration-guide" class="sect0"><a class="anchor" href="#configuration-guide"></a>配置指南</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>您可以使用Spring Initializr创建自己的服务，该服务可以生成JVM项目。本节介绍如何创建自己的服务并根据需要对其进行调整，以及如何配置现有服务。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="project-generation-overview"><a class="anchor" href="#project-generation-overview"></a> 7。项目生成概述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在开始<a href="#create-instance">创建自己的服务之前</a> ，让我们看一下项目生成的核心概念，以及如何构建支持它们的库。</p>
</div>
<div class="paragraph">
<p>Initializr分为几个模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>initializr-actuator</code> ：可选模块，提供有关项目生成的其他信息和统计信息。</p>
</li>
<li>
<p><code>initializr-bom</code> ：提供物料清单，以简化项目中的依赖项管理。</p>
</li>
<li>
<p><code>initializr-docs</code> ：文档。</p>
</li>
<li>
<p><code>initializr-generator</code> ：核心项目生成库。</p>
</li>
<li>
<p><code>initializr-generator-spring</code> ：可选模块，为典型的Spring Boot项目定义约定。可以重用或替换为您自己的约定。</p>
</li>
<li>
<p><code>initializr-generator-test</code> ：测试基础结构以生成项目。</p>
</li>
<li>
<p><code>initializr-metadata</code> ：用于项目各个方面的元数据基础结构。</p>
</li>
<li>
<p><code>initializr-service-sample</code> ：展示基本的自定义实例。</p>
</li>
<li>
<p><code>initializr-version-resolver</code> ：可选模块，用于从任意POM中提取版本号。</p>
</li>
<li>
<p><code>initializr-web</code> ：第三方客户端的网络端点。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要了解项目生成背后的概念，让我们看一下<code>initializr-generator</code>和<code>initializr-generator-spring</code>更详细一点。</p>
</div>
<div class="sect2">
<h3 id="initializr-generator"><a class="anchor" href="#initializr-generator"></a> 7.1。Initializr生成器</h3>
<div class="paragraph">
<p>的<code>initializr-generator</code>模块包含生成基于JVM的项目所需的低级基础结构。</p>
</div>
<div class="sect3">
<h4 id="initializr-generator-project"><a class="anchor" href="#initializr-generator-project"></a> 7.1.1。项目生成器</h4>
<div class="paragraph">
<p>的<code>ProjectGenerator</code>类是项目生成的主要切入点。一种<code>ProjectGenerator</code>需要一个<code>ProjectDescription</code>定义要生成的特定项目以及其实现<code>ProjectAssetGenerator</code>负责根据可用候选人生成资产。</p>
</div>
<div class="paragraph">
<p>项目定义为<code>ProjectDescription</code>其中包含以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基本坐标，例如<code>groupId</code> ， <code>artifactId</code> ， <code>name</code> ，<code>description</code></p>
</li>
<li>
<p>的<code>BuildSystem</code>和<code>Packaging</code></p>
</li>
<li>
<p>JVM<code>Language</code></p>
</li>
<li>
<p>请求的依赖项，按ID索引</p>
</li>
<li>
<p>一个平台<code>Version</code>由项目使用。这可用于根据选定的世代调整可用的依赖关系。</p>
</li>
<li>
<p>的名称<code>application</code></p>
</li>
<li>
<p>根软件包名称</p>
</li>
<li>
<p>项目的基本目录（如果与根目录不同）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>项目生成发生在专用的应用程序上下文中（ <code>ProjectGenerationContext</code> ），这意味着对于每个生成的项目，上下文仅包含与该特定项目相关的配置和组件。候选组件<code>ProjectGenerationContext</code>在中定义<code>@ProjectGenerationConfiguration</code>注释的配置类。如果这些配置类在以下位置注册，则将自动导入它们： <code>META-INF/spring.factories</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>io.spring.initializr.generator.project.ProjectGenerationConfiguration=\
com.example.acme.build.BuildProjectGenerationConfiguration,\
com.example.acme.code.SourceCodeProjectGenerationConfiguration</pre>
</div>
</div>
<div class="paragraph">
<p>添加到<code>ProjectGenerationContext</code>通常可以使用条件获得。使用条件可以避免暴露那些必须检查是否必须执行某些操作的bean，并使声明更加惯用。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@ConditionalOnBuildSystem(GradleBuildSystem.ID)
@ConditionalOnPackaging(WarPackaging.ID)
public BuildCustomizer&lt;GradleBuild&gt; warPluginContributor() {
    return (build) -&gt; build.addPlugin("war");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将注册一个仅在要生成的项目使用“ Gradle”时才能自定义Gradle构建的组件<code>BuildSystem</code>和“战争” <code>Packaging</code> 。检查<code>io.spring.initializr.generator.condition</code>包装以获得更多条件。您可以通过从继承轻松创建自定义条件<code>ProjectGenerationCondition</code> 。</p>
</div>
<div class="paragraph">
<p>您只能在已加载到<code>ProjectGenerationConfiguration</code>因为他们需要具体<code>ProjectDescription</code>豆正常运行。</p>
</div>
<div class="paragraph">
<p>项目生成还可能依赖于特定于项目配置的基础架构，而该基础架构通常不在主项目中配置<code>ApplicationContext</code>以免每次收到新请求时都进行注册。一个常见的用例是设置主<code>ApplicationContext</code>作为<code>ProjectGenerationContext</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public ProjectGenerator createProjectGenerator(ApplicationContext appContext) {
    return new ProjectGenerator((context) -&gt; {
        context.setParent(appContext);
        context.registerBean(SampleContributor.class, SampleContributor::new);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这创建了一个新的<code>ProjectGenerator</code>可以使用该应用程序的任何bean的方法，请注册在以下位置找到的所有贡献者<code>META-INF/spring.factories</code>并另外注册<code>ProjectContributor</code>以编程方式</p>
</div>
<div class="paragraph">
<p><code>ProjectContributor</code>是可以用来为一个项目贡献资产的最高级别的界面。的<code>SampleContributor</code>在上面注册会生成一个<code>test.txt</code>文件位于项目结构的根目录，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SampleContributor implements ProjectContributor {

    @Override
    public void contribute(Path projectRoot) throws IOException {
        Path file = Files.createFile(projectRoot.resolve("hello.txt"));
        try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(file))) {
            writer.println("Test");
        }
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="initializr-generator-project-lifecycle"><a class="anchor" href="#initializr-generator-project-lifecycle"></a> 7.1.2。项目生成生命周期</h4>
<div class="paragraph">
<p>当一个<code>ProjectGenerator</code>被指示生成一个项目，指定<code>ProjectDescription</code>可以使用可用进行定制<code>ProjectDescriptionCustomizer</code>豆，可以使用Spring's订购<code>Ordered</code>接口。</p>
</div>
<div class="paragraph">
<p>根据可用的内容自定义说明后<code>ProjectDescriptionCustomizer</code> s，生成器使用<code>ProjectAssetGenerator</code>产生项目资产。的<code>initializr-generator</code>模块提供此接口的默认实现（ <code>`DefaultProjectAssetGenerator</code> ）使用可用的文件生成目录结构<code>ProjectContributor</code>豆子。</p>
</div>
<div class="paragraph">
<p>而默认<code>ProjectAssetGenerator</code>使用文件系统并调用一组特定的组件，则可以使用相同的组件<code>ProjectGenerator</code>具有自定义实现的实例，该实现完全专注于其他方面。</p>
</div>
</div>
<div class="sect3">
<h4 id="initializr-generator-abstractions"><a class="anchor" href="#initializr-generator-abstractions"></a> 7.1.3。项目抽象</h4>
<div class="paragraph">
<p>该模块还包含项目各个方面的抽象以及一些方便的实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有Maven和Gradle实现的构建系统抽象。</p>
</li>
<li>
<p>Java，Groovy和Kotlin实现的语言抽象，包括<code>SourceCodeWriter</code>对于每个实现。</p>
</li>
<li>
<p>具有实现的包装抽象<code>jar</code>和<code>war</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为此添加新的实现需要创建一个<code>BuildSystemFactory</code> ， <code>LanguageFactory</code>和<code>PackagingFactory</code>并将它们注册到<code>META-INF/spring.factories</code>下<code>io.spring.initializr.generator.buildsystem.BuildSystemFactory</code> ， <code>io.spring.initializr.generator.language.LanguageFactory</code>和<code>io.spring.initializr.generator.packaging.PackagingFactory</code>分别。</p>
</div>
<div class="paragraph">
<p>JVM项目通常包含该项目的构建配置。的<code>initializr-generator</code>模块提供了一个模型<code>Build</code>与实现<code>Maven</code>和<code>Gradle</code> 。可以根据约定来操纵此模型。该库还提供了一个<code>MavenBuildWriter</code>和<code>GradleBuildWriter</code>可以转换一个<code>Build</code>用于构建文件的模型。</p>
</div>
<div class="paragraph">
<p>下一节关于<a href="#initializr-generator-spring"><code>initializr-generator-spring</code></a>模块展示了<code>Build</code>可以在使用定制程序编写构建文件之前进行操作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="initializr-generator-spring"><a class="anchor" href="#initializr-generator-spring"></a> 7.2。Spring Boot约定</h3>
<div class="paragraph">
<p>这是一个可选模块，用于定义我们认为对任何Spring Boot项目都有用的约定。如果您的服务旨在生成Spring Boot项目，则可以在项目中包含此jar。</p>
</div>
<div class="paragraph">
<p>在“ <a href="#initializr-generator-project">项目生成器”部分</a> ，我们研究了如何<code>ProjectContributor</code>可用于为项目贡献资产。该模块包含以下内容的具体实现<code>ProjectContributor</code>随着<code>@ProjectGenerationConfiguration</code>对其进行配置。例如，有一个<code>MavenBuildProjectContributor</code>它为Maven构建贡献文件，例如<code>pom.xml</code> 。该贡献者在一个<code>ProjectGenerationConfiguration</code>这取决于构建系统是Maven。</p>
</div>
<div class="paragraph">
<p>本模块还介绍了<code>BuildCustomizer</code> s。 <code>BuildCustomizer</code>用于自定义项目的<code>Build</code>并被订购。例如，如果您的服务要求您向构建中添加某个插件，则可以提供一个<code>BuildCustomizer</code>添加插件和定制程序将根据其上指定的顺序进行调用。</p>
</div>
<div class="sect3">
<h4 id="initializr-generator-spring-requirements"><a class="anchor" href="#initializr-generator-spring-requirements"></a> 7.2.1。要求</h4>
<div class="paragraph">
<p>该模块的提供者希望以下Bean可用于<code>ProjectGenerationContext</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>InitializrMetadata</code>实例使用</p>
</li>
<li>
<p>（可选） <code>MetadataBuildItemResolver</code>可以根据元数据中的ID解析各种构建项（例如依赖项和BOM）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您使用的是父上下文，建议在此配置它们，因为您不应在每次生成新项目时都将其注册：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个<code>IndentingWriterFactory</code>表示要使用的缩进策略。</p>
</li>
<li>
<p>一种<code>MustacheTemplateRenderer</code>使用<code>classpath:/templates</code>作为根位置。考虑使用高速缓存策略注册此类bean，以避免每次都解析模板。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="initializr-generator-spring-facets"><a class="anchor" href="#initializr-generator-spring-facets"></a> 7.2.2。受支持的方面</h4>
<div class="paragraph">
<p>处理以下方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>web</code> ：用于驱动包含id的依赖项<code>web</code> （默认为<code>spring-boot-starter-web</code>如果不存在与该方面的依赖关系</p>
</li>
<li>
<p><code>jpa</code> ：用于标记该项目使用JPA。与Kotlin结合使用时，可以确保配置适当的插件</p>
</li>
<li>
<p><code>json</code> ：用于标记该项目取决于Jackson。与Kotlin结合使用时，这可以确保添加Kotlin专用的杰克逊模块，以实现更好的互操作性。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="create-instance"><a class="anchor" href="#create-instance"></a> 8。创建自己的实例</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此如何创建自己的服务的演练假定该服务将用于创建Spring Boot项目，这就是为什么<code>initializr-generator-spring</code>包括罐子。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Initializr提供了物料清单（BOM），因此您不必担心版本。您可以在<a href="https://start.spring.io" class="bare">start.spring.io</a>上为自己的实例生成一个项目。使用创建一个新项目<code>web</code>依赖项并添加以下依赖项和BOM：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.spring.initializr&lt;/groupId&gt;
        &lt;artifactId&gt;initializr-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.spring.initializr&lt;/groupId&gt;
        &lt;artifactId&gt;initializr-generator-spring&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.spring.initializr&lt;/groupId&gt;
            &lt;artifactId&gt;initializr-bom&lt;/artifactId&gt;
            &lt;version&gt;0.8.0.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果您正在使用Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">implementation("io.spring.initializr:initializr-web")
implementation("io.spring.initializr:initializr-generator-spring")

dependencyManagement {
  imports {
    mavenBom "io.spring.initializr:initializr-bom:0.8.0.RELEASE"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>启动应用程序后，您可以点击<a href="http://localhost:8080" class="bare">localhost：8080</a> 。您将获得一个描述该服务功能的json文档。所有选择功能都没有值（Spring Boot版本除外），我们稍后会<a href="#create-instance-boot-versions">再介绍</a> 。在本节的其余部分，我们将配置这些基本设置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>大多数设置通过<code>application.properties</code>使用<code>initializr</code>命名空间。由于配置是高度分层的，因此我们建议使用对这种结构更易读的yaml格式。如果您同意，请继续并重命名<code>application.properties</code>至<code>application.yml</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="create-instance-basic-settings"><a class="anchor" href="#create-instance-basic-settings"></a> 8.1。配置基本设置</h3>
<div class="paragraph">
<p>大多数选择功能都是通过基于列表的简单结构配置的，其中每个条目都有一个<code>id</code> ， 一种<code>name</code>以及该条目是否为默认条目。如果不<code>name</code>提供， <code>id</code>改为使用。</p>
</div>
<div class="paragraph">
<p>让我们配置我们要支持的语言和JVM代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  javaVersions:
    - id: 11
      default: false
    - id: 1.8
      default: true
  languages:
    - name: Java
      id: java
      default: true
    - name: Kotlin
      id: kotlin
      default: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果重新启动应用程序并刷新<a href="http://localhost:8080" class="bare">localhost：8080</a> ，则语言功能现在具有上面定义的选项和默认值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在那里定义的语言标识符必须有一个对应的<code>Language</code>实施。 <code>java</code> ， <code>kotlin</code>和<code>groovy</code>可以直接使用，因为核心库本身可以使用这些实现。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可用的包装也可以通过以下方式配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  packagings:
    - name: Jar
      id: jar
      default: true
    - name: War
      id: war
      default: false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>Jar</code>和<code>War</code>包装类型是开箱即用的。对于其他包装格式，您需要实施<code>Packaging</code>抽象并提供<code>PackagingFactory</code>对应于它。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="create-instance-text-only-settings"><a class="anchor" href="#create-instance-text-only-settings"></a> 8.2。配置纯文本设置</h3>
<div class="paragraph">
<p>纯文字功能包括<code>groupId</code> ， <code>artifactId</code> ， <code>name</code> ， <code>description</code> ， <code>version</code>和<code>packageName</code> 。如果未配置任何功能，则每个功能都有一个默认值。可以覆盖默认值，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  group-id:
    value: org.acme
  artifact-id:
    value: my-app</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="create-instance-boot-versions"><a class="anchor" href="#create-instance-boot-versions"></a> 8.3。配置可用的Spring Boot版本</h3>
<div class="paragraph">
<p>如果您查看<a href="https://projects.spring.io/spring-boot">Spring Boot的项目主页</a> ，则会显示最新版本。您可能已经注意到，它们与您使用Spring Initializr的默认实例自动获得的下拉列表匹配。这样做的原因是Spring Initializr在<a href="https://spring.io" class="bare">spring.io</a>上调用了一个API以自动检索最新版本。这样可以确保您始终获得最新的可用版本。</p>
</div>
<div class="paragraph">
<p>如果您是代理人，或者需要自定义<code>RestTemplate</code>在幕后使用，您可以定义一个<code>RestTemplateCustomizer</code> bean在您的配置中。有关更多详细信息， <a href="https://docs.spring.io/spring-boot/docs/2.1.9.RELEASE/reference/htmlsingle/#boot-features-restclient-customization">请参阅文档</a> 。</p>
</div>
<div class="paragraph">
<p>如果您不希望该版本自动升级，则需要覆盖<code>InitializrMetadataUpdateStrategy</code> bean，以便在必须刷新元数据时提供自己的策略。例如，您可以交换到始终返回静态内容的实现。 <code>application.yml</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public InitializrMetadataUpdateStrategy initializrMetadataUpdateStrategy() {
    return (metadata) -&gt; metadata;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要记住的事情是，默认情况下，当发布新的Spring Boot版本时，您不必担心升级实例。但是，您可能需要<a href="#create-instance-advanced-config-caching">配置缓存</a>以避免过多地请求该服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="create-instance-types"><a class="anchor" href="#create-instance-types"></a> 8.4。配置可用的项目类型</h3>
<div class="paragraph">
<p>可用的项目类型主要定义了所生成项目的结构及其构建系统。选择项目类型后，将调用相关操作以生成项目。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Initializr公开以下资源（全部通过HTTP GET访问）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/pom.xml</code>生成一个Maven<code>pom.xml</code></p>
</li>
<li>
<p><code>/build.gradle</code>生成Gradle构建</p>
</li>
<li>
<p><code>/starter.zip</code>生成以zip存档的完整项目结构</p>
</li>
<li>
<p><code>/starter.tgz</code>生成完整的项目结构，并存储在tgz中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>构建系统必须使用<code>build</code>标签，提供<code>BuildSystem</code>使用（例如<code>maven</code> ， <code>gradle</code> ）。</p>
</div>
<div class="paragraph">
<p>可以提供其他标签以进一步限定条目。除了强制性的<code>build</code>标签，一个<code>format</code>标签也可用于定义项目的格式（例如<code>project</code>对于一个完整的项目， <code>build</code>仅用于构建文件）。默认情况下，HTML UI会过滤所有可用的类型，以仅显示具有<code>format</code>带值标签<code>project</code> 。</p>
</div>
<div class="paragraph">
<p>您当然可以实现其他端点，这些端点可以生成所需的任何项目结构，但是现在，我们仅配置实例即可生成Gradle或Maven项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  types:
    - name: Maven Project
      id: maven-project
      description: Generate a Maven based project archive
      tags:
        build: maven
        format: project
      default: true
      action: /starter.zip
    - name: Gradle Project
      id: gradle-project
      description: Generate a Gradle based project archive
      tags:
        build: gradle
        format: project
      default: false
      action: /starter.zip</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果打算针对服务构建自定义客户端，则可以根据需要添加任意数量的标签，并以对用户有意义的方式在客户端中对其进行处理。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，spring boot CLI使用它们作为完整类型id的快捷方式。因此，不必像下面那样创建Gradle项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring init --type=gradle-project my-project.zip</pre>
</div>
</div>
<div class="paragraph">
<p>您可以简单地定义一个更方便的构建参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring init --build=gradle my-project.zip</pre>
</div>
</div>
<div class="paragraph">
<p>通过这种配置，恭喜，您应该能够生成您的第一个项目！现在添加依赖项，以便您可以开始搜索它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="create-instance-dependencies"><a class="anchor" href="#create-instance-dependencies"></a> 8.5。配置依赖</h3>
<div class="paragraph">
<p>最基本的<code>dependency</code>由...组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个<code>id</code>在客户中用来指代它</p>
</li>
<li>
<p>依赖项的完整Maven坐标（ <code>groupId</code>和<code>artifactId</code> ）</p>
</li>
<li>
<p>显示器<code>name</code> （用于用户界面和搜索结果中）</p>
</li>
<li>
<p>一种<code>description</code>可以（并且应该）添加以提供有关依赖项的更多信息</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Initializr自动认为没有maven坐标的依赖项定义了正式的Spring Boot启动器。在这种情况下， <code>id</code>用于推断<code>artifactId</code> 。</p>
</div>
<div class="paragraph">
<p>例如，以下配置<code>spring-boot-starter-web</code>起动机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Web
      content:
        - name: Web
          id: web
          description: Full-stack web development with Tomcat and Spring MVC</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个依赖项都包含在一个<em>组中</em> ，该<em>组</em>收集了共享公共表面积或任何其他形式的分组的依赖项。在上面的示例中， <code>Web</code>组拥有我们独特的依赖性。小组还可以提供各种设置的默认值，有关更多详细信息，请参见<a href="#howto-group-share-settings">专用方法</a> 。</p>
</div>
<div class="paragraph">
<p>在我们的<code>spring-boot-starter-web</code>上面的示例中，依赖项是由Spring Boot <em>管理的</em> ，因此无需提供<code>version</code>属性。您肯定需要定义Spring Boot未提供的其他依赖关系，我们强烈建议您使用<a href="#create-instance-boms">材料清单（或BOM）</a> 。</p>
</div>
<div class="paragraph">
<p>如果没有BOM，则可以直接指定版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Tech
      content:
        - name: Acme
          id: acme
          groupId: com.example.acme
          artifactId: acme
          version: 1.2.0.RELEASE
          description: A solid description for this dependency</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果添加此配置并搜索“ acme”（或“ solid”），则会找到此额外条目；用它生成一个Maven项目应该将以下内容添加到pom中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.example.acme&lt;/groupId&gt;
    &lt;artifactId&gt;acme&lt;/artifactId&gt;
    &lt;version&gt;1.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>本节的其余部分将详细介绍其他配置选项。</p>
</div>
<div class="sect3">
<h4 id="dependencies-compatibility-range"><a class="anchor" href="#dependencies-compatibility-range"></a> 8.5.1。相容范围</h4>
<div class="paragraph">
<p>默认情况下，无论您选择的是Spring Boot版本，依赖项都是可用的。如果您需要将依赖关系限制为特定的Spring Boot代，则可以添加一个<code>compatibilityRange</code>属性定义了定义版本范围的属性。版本范围是与之结合有效的一系列Spring Boot版本范围。当为生成的项目选择了不同版本的Spring Boot时，这些版本<strong>不会</strong>应用于依赖项本身，而是用于过滤或修改依赖项。</p>
</div>
<div class="paragraph">
<p>典型版本由四个部分组成：主要版本，次要版本，补丁版本和限定符。限定词的顺序如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>M</code>里程碑（例如<code>2.0.0.M1</code>是即将发布的2.0.0版本的第一个里程碑）：可以看作是“测试版”版本</p>
</li>
<li>
<p><code>RC</code>适用于候选发布者（例如<code>2.0.0.RC2</code>是即将发布的2.0.0版本的第二个候选版本）</p>
</li>
<li>
<p><code>RELEASE</code>用于一般可用性（例如， <code>2.0.0.RELEASE</code>是2.0.0合适的）</p>
</li>
<li>
<p><code>BUILD-SNAPSHOT</code>用于开发构建（ <code>2.1.0.BUILD-SNAPSHOT</code>表示即将推出的2.1.0版本的最新可用开发版本。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">快照在该方案中有点特殊，因为它们始终代表发行版的“最新状态”。 <code>M1</code>代表给定的主要，次要和补丁程序修订版本的最旧版本。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>版本范围具有上限和下限，如果包含边界在内，则表示为方括号（ <code>[</code>要么<code>]</code> ），否则是排他的，并用括号（ <code>(</code>要么<code>)</code> ）。例如<code>[1.1.6.RELEASE,1.3.0.M1)</code>意味着来自所有版本<code>1.1.6.RELEASE</code>直至但不包括<code>1.3.0.M1</code> （绝对不包括<code>1.3.x</code>行和之后）。</p>
</div>
<div class="paragraph">
<p>版本范围可以是单个值，例如<code>1.2.0.RELEASE</code> ，是“此版本或更高版本”的缩写。它是一个包含性下限，具有一个隐含的无限上限。</p>
</div>
<div class="paragraph">
<p>如果您需要在给定的行中指定“最新版本”，则可以使用<code>x</code>而不是硬编码版本。例如， <code>1.4.x.BUILD-SNAPSHOT</code>是1.4.x系列的最新快照版本。例如，如果您想限制来自<code>1.1.0.RELEASE</code>到1.3.x版本的最新稳定版本，您将使用<code>[1.1.0.RELEASE,1.3.x.RELEASE]</code> 。</p>
</div>
<div class="paragraph">
<p>快照的顺序自然要高于发行版本，因此，如果您希望将依赖项仅匹配到Spring Boot的最新快照，则可以使用以下版本范围： <code>1.5.x.BUILD-SNAPSHOT</code> （假设1.5是最新的）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">请记住在YAML配置文件中用版本范围的值引起来（用双引号“”）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关更多示例和惯用语，请参见下面的<a href="#howto-link-boot-version">链接版本</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="dependencies-repository"><a class="anchor" href="#dependencies-repository"></a> 8.5.2。资料库</h4>
<div class="paragraph">
<p>如果依赖关系在Maven Central（或您端上配置的任何默认存储库）上不可用，则还可以添加对存储库的引用。存储库在顶层（在<code>env</code> ），并通过配置中的键指定一个ID：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  env:
    repositories:
      my-api-repo-1:
        name: repo1
        url: https://example.com/repo1</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义后，即可在依赖项中引用存储库</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Other
      content:
        - name: Foo
          groupId: org.acme
          artifactId: foo
          version: 1.3.5
          repository: my-api-repo-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常最好为每个依赖项都有一个BOM，然后将存储库附加到BOM。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">快照和里程碑存储库<code>repo.spring.io</code>随<code>spring-snapshots</code>和<code>spring-milestones</code>标识符。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="create-instance-boms"><a class="anchor" href="#create-instance-boms"></a> 8.6。配置物料清单</h3>
<div class="paragraph">
<p>物料清单（BOM）是特殊的<code>pom.xml</code> ，部署到Maven存储库，并用于控制一组相关工件的依赖性管理。在Spring Boot生态系统中，我们通常使用后缀<code>-dependencies</code>在BOM表的工件ID上。在其他项目中，我们看到<code>-bom</code> 。建议将所有依赖项都包含在某种BOM中，因为它们为依赖项的用户提供了很好的高级功能。同样重要的是，一个项目中使用的2个BOM表不应包含具有相同依赖性的冲突版本，因此最佳实践是在添加新的BOM表之前先查看Spring Initializr中的现有BOM表，并确保您没有增加冲突。</p>
</div>
<div class="paragraph">
<p>在Spring Initializr中，物料清单在<code>env</code>级别，并通过配置密钥指定ID。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  env:
    boms:
      my-api-bom:
        groupId: org.acme
        artifactId: my-api-dependencies
        version: 1.0.0.RELEASE
        repositories: my-api-repo-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果BOM需要特殊的非默认存储库，则可以在此处引用它，而不必为每个依赖项再次明确列出存储库。依赖项或依赖项组可以通过引用ID声明它需要使用一个或多个BOM表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Other
      content:
        - name: My API
          id : my-api
          groupId: org.acme
          artifactId: my-api
          bom: my-api-bom</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="dependencies-mappings"><a class="anchor" href="#dependencies-mappings"></a> 8.6.1。根据Spring Boot版本映射坐标</h4>
<div class="paragraph">
<p>除了依赖项或BOM的Spring Boot版本范围之外，您还可以使用版本映射在更细粒度的级别上配置版本关系。依赖项或BOM有一个“映射”列表，每个列表都包含一个版本范围，以及一组要覆盖这些版本的Spring Boot的一个或多个依赖项属性。例如，您可以使用映射来切换依赖项的版本，或（更好）BOM，或更改其工件ID（如果项目更改了其包装）。</p>
</div>
<div class="paragraph">
<p>这是带有映射的BOM表的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  env:
    boms:
      cloud-bom:
        groupId: com.example.foo
        artifactId: acme-foo-dependencies
        mappings:
          - compatibilityRange: "[1.2.3.RELEASE,1.3.0.RELEASE)"
            groupId: com.example.bar
            artifactId: acme-foo-bom
            version: Arcturus.SR6
          - compatibilityRange: "[1.3.0.RELEASE,1.4.0.RELEASE)"
            version: Botein.SR7
          - compatibilityRange: "[1.4.0.RELEASE,1.5.x.RELEASE)"
            version: Castor.SR6
          - compatibilityRange: "[1.5.0.RELEASE,1.5.x.BUILD-SNAPSHOT)"
            version: Diadem.RC1
            repositories: spring-milestones
          - compatibilityRange: "1.5.x.BUILD-SNAPSHOT"
            version: Diadem.BUILD-SNAPSHOT
            repositories: spring-snapshots,spring-milestones</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要用例是将Spring Boot版本映射到Foo项目的首选或受支持的版本。您还可以看到，对于里程碑BOM表和快照BOM表，声明了其他存储库，因为这些工件不在默认存储库中。最初，物料清单被标识为<code>com.example.bar:acme-foo-bom</code>并改名为<code>Botein</code>至<code>com.example.foo:acme-foo-dependencies</code> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们还使用<code>x</code>版本范围中的技巧，以避免在每次有新的Spring Boot 1.5错误修复版本发布时更新范围</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关更多示例，请参见下面的<a href="#howto-link-boot-version">链接版本</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="dependencies-alias"><a class="anchor" href="#dependencies-alias"></a> 8.6.2。别名</h4>
<div class="paragraph">
<p>依赖项具有一个ID（例如“ Web服务”），但是可能有必要提供一个新的ID，并且仍然能够使用现在不建议使用的ID服务于来自客户端的请求。为此，可以为该依赖项定义一个别名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Other
      content:
        - name: Web Services
          id: web-services
          aliases:
            - ws</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用<code>dependencies=ws</code>要么<code>dependencies=web-services</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="dependencies-facet"><a class="anchor" href="#dependencies-facet"></a> 8.6.3。刻面</h4>
<div class="paragraph">
<p>“方面”是依赖项上的标签，用于在生成的项目中驱动代码修改。例如， <code>initializr-generator-spring</code>使用以下命令检查是否存在依赖项<code>web</code>如果包装类型为<code>war</code> 。没有依赖关系<code>web</code>构面驱动包含ID的依赖项<code>web</code> （默认为<code>spring-boot-starter-web</code>如果此类依赖项不可用）。</p>
</div>
<div class="paragraph">
<p>依赖项的“ facets”属性的值是一个字符串列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="create-instance-dependencies-link"><a class="anchor" href="#create-instance-dependencies-link"></a> 8.6.4。链接</h4>
<div class="paragraph">
<p>链接可用于提供描述性和超链接数据，以指导用户如何了解有关依赖项的更多信息。依赖项具有“链接”属性，该属性是<code>Link</code> 。每个链接都有一个<code>rel</code>标签来识别它<code>href</code>和一个可选的（但推荐） <code>description</code> 。</p>
</div>
<div class="paragraph">
<p>下列<code>rel</code>目前已正式支持该值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>guide</code> ：链接指向描述如何使用相关依赖项的指南。它可以是一个教程，一个如何做或一般可用的指南<a href="https://spring.io/guides" class="bare">spring.io/guides</a></p>
</li>
<li>
<p>参考：该链接通常指向开发人员指南的一部分或任何记录如何使用依赖项的页面</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果url的实际值可以根据环境而变化，则可以对其进行模板化。URL参数用大括号指定，例如<code><a href="https://example.com/doc/{bootVersion}/section" class="bare">example.com/doc/{bootVersion}/section</a></code>定义一个<code>bootVersion</code>参数。</p>
</div>
<div class="paragraph">
<p>当前支持以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bootVersion</code> ：当前处于活动状态的Spring Boot版本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是将两个链接添加到<code>acme</code>依赖关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Tech
      content:
        - name: Acme
          id: acme
          groupId: com.example.acme
          artifactId: acme
          version: 1.2.0.RELEASE
          description: A solid description for this dependency
          links:
            - rel: guide
              href: https://com.example/guides/acme/
              description: Getting started with Acme
            - rel: reference
              href: https://docs.example.com/acme/html</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="create-instance-dependencies-search"><a class="anchor" href="#create-instance-dependencies-search"></a> 8.6.5。改善搜寻结果</h4>
<div class="paragraph">
<p>每个依赖项可以有一个<code>weight</code> （数字> = 0）以及<code>keywords</code> （字符串列表），用于在网络用户界面的搜索功能中对它们进行优先级排序。如果您在用户界面的“依赖关系”框中键入关键字之一，则这些依赖关系将按照权重递减的顺序列出，如果它们具有一个（未加权的依赖关系排在最后）。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-howto"><a class="anchor" href="#configuration-howto"></a> 9。“操作方法”指南</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节提供了一些在配置Spring Initializr时常见的常见问题解答。</p>
</div>
<div class="sect2">
<h3 id="howto-add-a-new-dependency"><a class="anchor" href="#howto-add-a-new-dependency"></a> 9.1。添加一个新的依赖</h3>
<div class="paragraph">
<p>要添加新的依赖项，请首先确定要添加的依赖项的Maven坐标（ <code>groupId:artifactId:version</code> ），然后检查它可以使用的Spring Boot版本。如果有多个版本可以与不同版本的Spring Boot配合使用，那也很好。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果有一个已发布的BOM表可以管理您的依赖项的版本，则首先将其添加到<code>env</code>部分（请参阅<a href="#create-instance-boms">配置材料明细表</a> ）。</p>
</li>
<li>
<p>然后配置依赖项，如果可以的话，将其适合现有组，否则创建一个新组。</p>
</li>
<li>
<p>如果有BOM，则省略版本。</p>
</li>
<li>
<p>如果此依赖项需要一个Spring Boot版本范围（或最小或最大），请将其添加为<a href="#howto-link-boot-version">链接版本</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="howto-override-a-version"><a class="anchor" href="#howto-override-a-version"></a> 9.2。覆盖依赖项的版本</h3>
<div class="paragraph">
<p>有时，通常管理您的依赖项版本的BOM与最新版本发生冲突。也许只有部分Spring Boot版本才是这种情况。或者也许没有BOM，或者仅为一个依赖项创建一个BOM是不值得的。在这些情况下，您可以在顶层或<a href="#howto-link-boot-version">版本映射中</a>手动为依赖项指定<a href="#howto-link-boot-version">版本</a> 。在顶层看起来像这样（ <code>version</code>依赖项中的属性）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Tech
      content:
        - name: Acme
          id: acme
          groupId: com.example.acme
          artifactId: acme
          version: 1.2.0.RELEASE
          description: A solid description for this dependency</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto-link-boot-version"><a class="anchor" href="#howto-link-boot-version"></a> 9.3。将引导版本链接到依赖项的版本</h3>
<div class="paragraph">
<p>如果您的依赖项需要特定版本的Spring Boot，或者不同版本的Spring Boot都需要不同版本的依赖项，则可以使用两种机制进行配置。</p>
</div>
<div class="paragraph">
<p>最简单的方法是<code>compatibilityRange</code>在依赖项声明中。这是Spring Boot的一系列版本，而不是您的依赖项。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Stuff
      content:
        - name: Foo
          id: foo
          ...
          compatibilityRange: 1.2.0.M1
        - name: Bar
          id: bar
          ...
          compatibilityRange: "[1.5.0.RC1,2.0.0.M1)"</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中<code>Foo</code>适用于Spring Boot 1.2.0（或任何1.2.0里程碑）或更高版本，并且<code>Bar</code>适用于Spring Boot 1.5.0之前的版本，但不包括2.0.0。</p>
</div>
<div class="paragraph">
<p>如果您的依赖项的不同版本与Spring Boot的不同版本一起使用，那么您需要<code>mappings</code>属性。映射是<code>compatibilityRange</code>以及依赖项的某些或全部其他属性，将覆盖在顶级定义的值。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Stuff
      content:
        - name: Foo
          id: foo
          groupId: org.acme.foo
          artifactId: foo-spring-boot-starter
          compatibilityRange: 1.3.0.RELEASE
          bom: cloud-task-bom
          mappings:
            - compatibilityRange: "[1.3.0.RELEASE,1.3.x.RELEASE]"
              artifactId: foo-starter
            - compatibilityRange: "1.4.0.RELEASE"</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中， <code>foo</code>改为<code>foo-spring-boot-starter</code>从与Spring Boot 1.4兼容的版本开始。该映射指示，如果选择了Spring Boot 1.3.x，则应将工件ID设置为<code>foo-starter</code> 。</p>
</div>
<div class="paragraph">
<p>映射也可以应用于BOM声明。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  env:
    boms:
      my-api-bom:
        groupId: org.acme
        artifactId: my-api-bom
        additionalBoms: ['my-api-dependencies-bom']
        mappings:
          - compatibilityRange: "[1.0.0.RELEASE,1.1.6.RELEASE)"
            version: 1.0.0.RELEASE
            repositories: my-api-repo-1
          - compatibilityRange: "1.2.1.RELEASE"
            version: 2.0.0.RELEASE
            repositories: my-api-repo-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，Spring Boot的最高版本为1.1.6，选择BOM表的版本1.0.0，并设置其他存储库。Spring Boot版本1.2.1及更高版本选择2.0.0的BOM和另一个存储库。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-add-snapshot-repository"><a class="anchor" href="#howto-add-snapshot-repository"></a> 9.4。配置快照存储库</h3>
<div class="paragraph">
<p>如果默认项（通常是Maven Central）不包含工件，则依赖项或BOM可能需要使用特定的存储库。通常，在BOM表配置中声明该位置的最佳位置，但是如果没有BOM表，则可以将其放在依赖项本身中。您还可以使用Spring Boot <a href="#You can declare arepository">版本映射</a>来覆盖依赖项或BOM的默认存储库。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-configure-custom-parent-pom"><a class="anchor" href="#howto-configure-custom-parent-pom"></a> 9.5。配置自定义父POM</h3>
<div class="paragraph">
<p>对于Maven项目，可以如下配置自定义父POM：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  env:
    maven:
      parent:
        groupId: com.example
        artifactId: my-parent
        version: 1.0.0
        includeSpringBootBom : true</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>includeSpringBootBom</code>是<code>false</code>默认。设置为<code>true</code> ， <code>spring-boot-dependencies</code> Bom已添加到<code>dependencyManagement</code>部分，以及用于项目的Spring Boot版本。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-dependency-starter-flag"><a class="anchor" href="#howto-dependency-starter-flag"></a> 9.6。确保常规依赖项带来了基础入门</h3>
<div class="paragraph">
<p>如果依赖项不能独立存在（特别是如果它不依赖于现有的Spring Boot启动器），则可以将其标记为“非启动器”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Stuff
      content:
        - name: Lib
          id: lib
          groupId: com.acme
          artifactId: lib
          starter:false</code></pre>
</div>
</div>
<div class="paragraph">
<p>当生成的项目仅具有设置了此标志的依赖项时，还将添加基本的Spring Boot启动器。</p>
</div>
</div>
<div class="sect2">
<h3 id="howto-group-share-settings"><a class="anchor" href="#howto-group-share-settings"></a> 9.7。在组中共享常见的依赖项设置</h3>
<div class="paragraph">
<p>依赖项组是用户界面实现的提示，可以在用户选择依赖项时将它们分组在一起。这也是在依赖项之间共享设置的一种便捷方法，因为每个依赖项都继承所有设置。群组中最常见的设置是<code>groupId</code> ， <code>compatibilityRange</code>和<code>bom</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">initializr:
  dependencies:
    - name: Stuff
      bom: stuff-bom
      compatibilityRange: "[1.3.0.RELEASE,2.0.0.M1)"
      content:
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，这些依赖项仅适用于Spring Boot版本1.3到2.0（不包括），并将引入<code>stuff-bom</code> BOM。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="create-instance-advanced-config"><a class="anchor" href="#create-instance-advanced-config"></a> 10。进阶设定</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="create-instance-advanced-config-caching"><a class="anchor" href="#create-instance-advanced-config-caching"></a> 10.1。缓存配置</h3>
<div class="paragraph">
<p>如果您使用该服务，您会注意到日志中有很多带有消息的条目<code>Fetching boot metadata from <a href="https://spring.io/project_metadata/spring-boot" class="bare">spring.io/project_metadata/spring-boot</a></code> 。为了避免过于频繁地检查最新的Spring Boot版本，您应该在服务上启用缓存。如果您愿意使用JCache（JSR-107）实现，Spring Initializr会进行一些自动配置以应用适当的缓存。</p>
</div>
<div class="paragraph">
<p>添加<code>javax.cache:cache-api</code>和您最喜欢的JCache实现，只需添加即可启用缓存<code>@EnableCaching</code>给你<code>@SpringBootApplication</code> 。例如，您可以使用<code>ehcache</code>通过添加以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.cache&lt;/groupId&gt;
    &lt;artifactId&gt;cache-api&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果您正在使用Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">implementation("javax.cache:cache-api")
implementation("org.ehcache:ehcache")</code></pre>
</div>
</div>
<div class="paragraph">
<p>您会注意到日志条目很少见。如果您不想使用JSR-107，则应自行配置缓存。这是应用程序使用的缓存（每个缓存都需要进行一些配置才能使其运行）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表格1。缓存配置</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">缓存名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initializr.metadata</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缓存服务的完整元数据。元数据过期后，它将再次完全解析（包括在spring.io上检查是否有最新的Spring Boot版本）。相应地调整到期设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initializr.dependency-metadata</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定于缓存依赖项的元数据。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>initializr.templates</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于生成项目的缓存模板。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="create-instance-advanced-config-custom-project-request"><a class="anchor" href="#create-instance-advanced-config-custom-project-request"></a> 10.2。绑定到自定义项目请求</h3>
<div class="paragraph">
<p>只有元数据中定义的属性才能绑定到<code>ProjectRequest</code>并最终在<code>ProjectDescription</code> 。但是，可以选择自定义实例来提供其他属性。请注意，正式客户端（即IDE）将不支持这些属性。</p>
</div>
<div class="paragraph">
<p>第一步是定义一个自定义<code>ProjectRequest</code>与您的其他属性并创建一个自定义<code>ProjectGenerationController</code>绑定到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomProjectGenerationController extends ProjectGenerationController&lt;CustomProjectRequest&gt; {

    public CustomProjectGenerationController(InitializrMetadataProvider metadataProvider,
            ProjectGenerationInvoker&lt;CustomProjectRequest&gt; projectGenerationInvoker) {
        super(metadataProvider, projectGenerationInvoker);
    }

    @Override
    public CustomProjectRequest projectRequest(Map&lt;String, String&gt; headers) {
        CustomProjectRequest request = new CustomProjectRequest();
        request.getParameters().putAll(headers);
        request.initialize(getMetadata());
        return request;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您继承自<code>WebProjectRequest</code> ，则可以从元数据中自动应用默认值，如上所示，但您也可以选择忽略它。</p>
</div>
<div class="paragraph">
<p>下一步是确保这些附加属性在<code>ProjectGenerationContext</code> 。惯用的方式是创建自己的接口，该接口从<code>ProjectDescription</code>并公开您的自定义属性。为了确保您的观点<code>ProjectDescription</code>在<code>ProjectGenerationContext</code> ， 一个习俗<code>ProjectRequestToDescriptionConverter</code>应该被定义并且可以重用<code>DefaultProjectRequestToDescriptionConverter</code>对标准字段应用一般规则。</p>
</div>
<div class="paragraph">
<p>最后，您应该连接所有内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public CustomProjectGenerationController projectGenerationController(InitializrMetadataProvider metadataProvider,
        ApplicationContext applicationContext) {
    ProjectGenerationInvoker&lt;CustomProjectRequest&gt; projectGenerationInvoker = new ProjectGenerationInvoker&lt;&gt;(
            applicationContext, new CustomProjectRequestToDescriptionConverter());
    return new CustomProjectGenerationController(metadataProvider, projectGenerationInvoker);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<h1 id="api-guide" class="sect0"><a class="anchor" href="#api-guide"></a> API指南</h1>
<div class="sect1">
<h2 id="metadata-format"><a class="anchor" href="#metadata-format"></a> 11。元数据格式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了由initializr公开的元数据的hal / json结构。第三方客户端可以使用此类元数据来提供选项列表和默认设置，以用于请求创建项目。</p>
</div>
<div class="paragraph">
<p>建议第三方客户设置一个<code>User-Agent</code>发送到服务的<strong>每个</strong>请求的标头。用户代理的良好结构是<code>clientId/clientVersion</code> （即<code>foo/1.2.0</code>对于“ foo”客户端和版本<code>1.2.0</code> ）。</p>
</div>
<div class="sect2">
<h3 id="content"><a class="anchor" href="#content"></a> 11.1。内容</h3>
<div class="paragraph">
<p>任何第三方客户端都可以通过发出以下命令来检索服务的功能： <code>GET</code>在根URL上使用以下命令<code>Accept</code>标头： <code>application/vnd.initializr.v2.1+json</code> 。请注意，元数据将来可能会以非向后兼容的方式发展，因此添加此标头可确保服务返回您期望的元数据格式。</p>
</div>
<div class="paragraph">
<p>这是在以下位置运行的服务的示例输出<code><a href="https://start.spring.io" class="bare">start.spring.io</a></code> ：</p>
</div>
<div class="listingblock">
<div class="title">请求</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-http hljs" data-lang="http">GET / HTTP/1.1
Accept: application/vnd.initializr.v2.1+json
Host: start.spring.io</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">响应</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-http hljs" data-lang="http">HTTP/1.1 200 OK
ETag: "7884ff1cd4c266dedd7fb74f3c0defcf"
Content-Type: application/vnd.initializr.v2.1+json
Vary: Accept
Cache-Control: max-age=7200
Content-Length: 4874

{
  "_links" : {
    "maven-build" : {
      "href" : "http://start.spring.io/pom.xml?type=maven-build{&amp;dependencies,packaging,javaVersion,language,bootVersion,groupId,artifactId,version,name,description,packageName}",
      "templated" : true
    },
    "maven-project" : {
      "href" : "http://start.spring.io/starter.zip?type=maven-project{&amp;dependencies,packaging,javaVersion,language,bootVersion,groupId,artifactId,version,name,description,packageName}",
      "templated" : true
    },
    "gradle-build" : {
      "href" : "http://start.spring.io/build.gradle?type=gradle-build{&amp;dependencies,packaging,javaVersion,language,bootVersion,groupId,artifactId,version,name,description,packageName}",
      "templated" : true
    },
    "gradle-project" : {
      "href" : "http://start.spring.io/starter.zip?type=gradle-project{&amp;dependencies,packaging,javaVersion,language,bootVersion,groupId,artifactId,version,name,description,packageName}",
      "templated" : true
    },
    "dependencies" : {
      "href" : "http://start.spring.io/dependencies{?bootVersion}",
      "templated" : true
    }
  },
  "dependencies" : {
    "type" : "hierarchical-multi-select",
    "values" : [ {
      "name" : "Core",
      "values" : [ {
        "id" : "web",
        "name" : "Web",
        "description" : "Web dependency description",
        "_links" : {
          "guide" : {
            "href" : "https://example.com/guide",
            "title" : "Building a RESTful Web Service"
          },
          "reference" : {
            "href" : "https://example.com/doc"
          }
        }
      }, {
        "id" : "security",
        "name" : "Security"
      }, {
        "id" : "data-jpa",
        "name" : "Data JPA"
      } ]
    }, {
      "name" : "Other",
      "values" : [ {
        "id" : "org.acme:foo",
        "name" : "Foo",
        "_links" : {
          "guide" : [ {
            "href" : "https://example.com/guide1"
          }, {
            "href" : "https://example.com/guide2",
            "title" : "Some guide for foo"
          } ],
          "reference" : {
            "href" : "https://example.com/{bootVersion}/doc",
            "templated" : true
          }
        }
      }, {
        "id" : "org.acme:bar",
        "name" : "Bar"
      }, {
        "id" : "org.acme:biz",
        "name" : "Biz",
        "versionRange" : "2.2.0.BUILD-SNAPSHOT"
      }, {
        "id" : "org.acme:bur",
        "name" : "Bur",
        "versionRange" : "[2.1.4.RELEASE,2.2.0.BUILD-SNAPSHOT)"
      }, {
        "id" : "my-api",
        "name" : "My API"
      } ]
    } ]
  },
  "type" : {
    "type" : "action",
    "default" : "maven-project",
    "values" : [ {
      "id" : "maven-build",
      "name" : "Maven POM",
      "action" : "/pom.xml",
      "tags" : {
        "build" : "maven",
        "format" : "build"
      }
    }, {
      "id" : "maven-project",
      "name" : "Maven Project",
      "action" : "/starter.zip",
      "tags" : {
        "build" : "maven",
        "format" : "project"
      }
    }, {
      "id" : "gradle-build",
      "name" : "Gradle Config",
      "action" : "/build.gradle",
      "tags" : {
        "build" : "gradle",
        "format" : "build"
      }
    }, {
      "id" : "gradle-project",
      "name" : "Gradle Project",
      "action" : "/starter.zip",
      "tags" : {
        "build" : "gradle",
        "format" : "project"
      }
    } ]
  },
  "packaging" : {
    "type" : "single-select",
    "default" : "jar",
    "values" : [ {
      "id" : "jar",
      "name" : "Jar"
    }, {
      "id" : "war",
      "name" : "War"
    } ]
  },
  "javaVersion" : {
    "type" : "single-select",
    "default" : "1.8",
    "values" : [ {
      "id" : "1.6",
      "name" : "1.6"
    }, {
      "id" : "1.7",
      "name" : "1.7"
    }, {
      "id" : "1.8",
      "name" : "1.8"
    } ]
  },
  "language" : {
    "type" : "single-select",
    "default" : "java",
    "values" : [ {
      "id" : "groovy",
      "name" : "Groovy"
    }, {
      "id" : "java",
      "name" : "Java"
    }, {
      "id" : "kotlin",
      "name" : "Kotlin"
    } ]
  },
  "bootVersion" : {
    "type" : "single-select",
    "default" : "2.1.4.RELEASE",
    "values" : [ {
      "id" : "2.2.0.BUILD-SNAPSHOT",
      "name" : "Latest SNAPSHOT"
    }, {
      "id" : "2.1.4.RELEASE",
      "name" : "2.1.4"
    }, {
      "id" : "1.5.17.RELEASE",
      "name" : "1.5.17"
    } ]
  },
  "groupId" : {
    "type" : "text",
    "default" : "com.example"
  },
  "artifactId" : {
    "type" : "text",
    "default" : "demo"
  },
  "version" : {
    "type" : "text",
    "default" : "0.0.1-SNAPSHOT"
  },
  "name" : {
    "type" : "text",
    "default" : "demo"
  },
  "description" : {
    "type" : "text",
    "default" : "Demo project for Spring Boot"
  },
  "packageName" : {
    "type" : "text",
    "default" : "com.example.demo"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当前的功能如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>项目依赖：这真的是<em>初学者</em>或实际上，我们可能要添加到项目中的任何相关性。</p>
</li>
<li>
<p>项目类型：项目类型定义了可以在此服务上调用的操作，以及对它将产生的内容的描述（例如，包含一个预先配置的Maven项目的zip）。每种类型可能还具有一个进一步定义其生成内容的标签。</p>
</li>
<li>
<p>包装：生成的项目类型。这仅提示负责生成项目的组件（例如，生成可执行的<em>jar</em>项目）。</p>
</li>
<li>
<p>Java版本：受支持的Java版本</p>
</li>
<li>
<p>语言：使用的语言（例如Java）</p>
</li>
<li>
<p>引导版本：要使用的Spring Boot版本</p>
</li>
<li>
<p>其他基本信息，例如： <code>groupId</code> ， <code>artifactId</code> ， <code>version</code> ， <code>name</code> ， <code>description</code>和<code>packageName</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个顶级属性（即功能）都有一种标准格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种<code>type</code>定义属性语义的属性（请参见下文）。</p>
</li>
<li>
<p>一种<code>default</code>定义默认值或对默认值的引用的属性。</p>
</li>
<li>
<p>一种<code>values</code>定义可接受值集（如果有）的属性。这可以是分层的（带有<code>values</code>被关押<code>values</code> ）。一个中的每个项目<code>values</code>数组可以有一个<code>id</code> ， <code>name</code>和<code>description</code> ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下属性<code>type</code>支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>text</code> ：定义没有选项的简单文本值。</p>
</li>
<li>
<p><code>single-select</code> ：定义在指定选项中选择的简单值。</p>
</li>
<li>
<p><code>hierarchical-multi-select</code> ：定义一组分层的值（值中的值），并可以选择多个值。</p>
</li>
<li>
<p><code>action</code> ：一种特殊类型，用于定义用于定义要使用的操作的属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>每个动作都定义为符合HAL的URL。例如， <code>maven-project</code>类型模板化的URL定义如下：</p>
</div>
<div class="listingblock">
<div class="title">类型链接示例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "href" : "http://start.spring.io/starter.zip?type=maven-project{&amp;dependencies,packaging,javaVersion,language,bootVersion,groupId,artifactId,version,name,description,packageName}",
  "templated" : true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用Spring HATEOAS和<code>UriTemplate</code>特别是从模板变量生成URI的帮助器。请注意，变量与元数据文档中顶级属性的名称匹配。如果您无法解析此类URI， <code>action</code>每种类型的属性都为您提供了在服务器上调用的根操作。这需要您进行更多的手动处理。</p>
</div>
<div class="sect3">
<h4 id="project-dependencies"><a class="anchor" href="#project-dependencies"></a> 11.1.1。项目依赖</h4>
<div class="paragraph">
<p>依赖关系通常是<em>启动程序</em>模块的坐标，但也可以只是常规依赖关系。典型的依赖关系结构如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "name": "Display name",
  "id": "org.acme.project:project-starter-foo",
  "description": "What starter foo does"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该名称用作显示名称，以便在远程客户端使用的任何UI中显示。id可以是任何东西，实际上是通过配置定义了实际的依赖项定义。如果未定义ID，则使用<code>groupId</code>和<code>artifactId</code>的依赖。请特别注意，该版本<strong>永远不会</strong>用作自动ID的一部分。</p>
</div>
<div class="paragraph">
<p>每个依赖项都属于一个组。该小组的想法是收集相似的依赖关系并对其进行排序。这是一个包含<code>core</code>组以说明功能：</p>
</div>
<div class="listingblock">
<div class="title">依赖组示例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "name" : "Core",
  "values" : [ {
    "id" : "web",
    "name" : "Web",
    "description" : "Web dependency description",
    "_links" : {
      "guide" : {
        "href" : "https://example.com/guide",
        "title" : "Building a RESTful Web Service"
      },
      "reference" : {
        "href" : "https://example.com/doc"
      }
    }
  }, {
    "id" : "security",
    "name" : "Security"
  }, {
    "id" : "data-jpa",
    "name" : "Data JPA"
  } ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个依赖项都可以具有<em>链接</em> （采用HAL兼容格式）。链接按“关系”分组，“关系”为链接提供了语义。链接也可以具有<em>标题，</em>并且其URI可以被模板化。目前，唯一有效的参数是<code>bootVersion</code> 。</p>
</div>
<div class="paragraph">
<p>官方关系是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>guide</code> ：链接到说明或入门指南，</p>
</li>
<li>
<p><code>reference</code> ：链接到参考指南（文档）的一部分</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="project-types"><a class="anchor" href="#project-types"></a> 11.1.2。项目类型</h4>
<div class="paragraph">
<p>的<code>type</code>元素定义可以生成哪种项目以及如何生成。例如，如果该服务提供了生成Maven项目的功能，则该外观如下所示：</p>
</div>
<div class="listingblock">
<div class="title">项目类型示例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "id" : "maven-build",
  "name" : "Maven POM",
  "action" : "/pom.xml",
  "tags" : {
    "build" : "maven",
    "format" : "build"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您不应该依赖于该信息的输出格式。始终使用定义了<code>Content-Type</code>还有一个<code>Content-Disposition</code>标头。</p>
</div>
<div class="paragraph">
<p>请注意，每个id都有一个相关的HAL兼容链接，可用于根据模板变量生成适当的URI。顶层<code>type</code>与其他任何属性一样，具有<code>default</code>属性，用于选择服务认为是默认值的提示。</p>
</div>
<div class="paragraph">
<p>的<code>action</code>属性定义了客户端（如果您无法使用符合HAL的网址）应与之实际联系以生成该类型项目的端点。</p>
</div>
<div class="paragraph">
<p>的<code>tags</code>对象用于对项目类型进行分类并向第三方客户端提供<em>提示</em> 。例如， <em>build</em>标签定义了项目将要使用的构建系统，而<em>format</em>标签定义了所生成内容的格式（即，这里是一个完整的项目vs.一个构建文件。请注意<code>Content-type</code>回复的标头提供了其他元数据）。</p>
</div>
</div>
<div class="sect3">
<h4 id="packaging"><a class="anchor" href="#packaging"></a> 11.1.3。打包</h4>
<div class="paragraph">
<p>的<code>packaging</code>元素定义应生成的项目的类型。</p>
</div>
<div class="listingblock">
<div class="title">包装实例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "id" : "jar",
  "name" : "Jar"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该元素的明显值是<code>jar</code>和<code>war</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="java-version"><a class="anchor" href="#java-version"></a> 11.1.4。Java版本</h4>
<div class="paragraph">
<p>的<code>javaVersion</code>元素提供了该项目可能的Java版本的列表：</p>
</div>
<div class="listingblock">
<div class="title">Java示例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "id" : "1.6",
  "name" : "1.6"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="languages"><a class="anchor" href="#languages"></a> 11.1.5。语言能力</h4>
<div class="paragraph">
<p>的<code>language</code>元素提供了项目可能的语言列表：</p>
</div>
<div class="listingblock">
<div class="title">语言范例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "id" : "groovy",
  "name" : "Groovy"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-version"><a class="anchor" href="#boot-version"></a> 11.1.6。开机版本</h4>
<div class="paragraph">
<p>的<code>bootVersion</code>元素提供可用启动版本的列表</p>
</div>
<div class="listingblock">
<div class="title">Spring Boot版本示例</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-json hljs" data-lang="json">{
  "id" : "2.2.0.BUILD-SNAPSHOT",
  "name" : "Latest SNAPSHOT"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defaults"><a class="anchor" href="#defaults"></a> 11.2。默认值</h3>
<div class="paragraph">
<p>每个顶级元素都有一个<code>default</code>用作提示以在相关的UI组件中提供默认值的属性。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-the-stubs"><a class="anchor" href="#using-the-stubs"></a> 12使用存根</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Initializr项目为项目中测试的所有JSON响应发布<a href="https://github.com/tomakehurst/wiremock">WireMock</a>存根。如果您正在编写Spring Initializr服务的客户端，则可以使用这些存根测试您自己的代码。您可以使用原始的Wiremock API或通过<a href="https://github.com/spring-cloud/spring-cloud-contract">Spring Cloud Contract的</a>某些功能来使用它们。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">WireMock是一个嵌入式Web服务器，它分析传入的请求并根据匹配的某些规则（例如，特定的标头值）选择存根响应。因此，如果您向它发送一个匹配其存根之一的请求，它将向您发送一个响应，就好像它是真正的Initializr服务一样，您可以使用它来对客户端进行完整的堆栈集成测试。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="using-wiremock-with-spring-boot"><a class="anchor" href="#using-wiremock-with-spring-boot"></a> 12.1。在Spring Boot中使用WireMock</h3>
<div class="sect3">
<h4 id="loading-stubs-from-the-classpath"><a class="anchor" href="#loading-stubs-from-the-classpath"></a> 12.1.1。从类路径加载存根</h4>
<div class="paragraph">
<p>在项目中使用存根的一种便捷方法是添加测试依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.spring.initializr&lt;/groupId&gt;
    &lt;artifactId&gt;initializr-web&lt;/artifactId&gt;
    &lt;classifier&gt;stubs&lt;/classifier&gt;
    &lt;version&gt;{project-version}&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后从类路径中提取存根。在Spring Boot应用程序中，使用Spring Cloud Contract，可以启动WireMock服务器并向其注册所有存根，如以下基于JUnit 5的示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest
@AutoConfigureWireMock(port = 0,
    stubs="classpath:META-INF/io.spring.initializr/initializr-web/0.8.0.RELEASE")
class ClientApplicationTests {

    @Value("${wiremock.server.port}")
    private int port;

    ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wiremock功能随附于Spring Cloud Contract Wiremock：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-contract-wiremock&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这种依赖关系由<code>spring-cloud-contract-dependencies</code> BOM。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="using-the-stub-runner"><a class="anchor" href="#using-the-stub-runner"></a> 12.1.2。使用存根运行器</h4>
<div class="paragraph">
<p>另外，您可以使用不同的Spring Cloud Contract依赖项，配置存根运行器以寻找工件： <code>spring-cloud-starter-contract-stub-runner</code> 。下面的示例将在必要时自动下载Spring Initializr存根的已定义版本（因此，您不需要将存根声明为依赖项）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-contract-stubrunner&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试应使用<code>@AutoConfigureStubRunner</code>相反，如以下基于JUnit 5的示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest(webEnvironment = WebEnvironment.NONE)
@AutoConfigureStubRunner(
    ids = "io.spring.initializr:initializr-web:0.8.0.RELEASE",
    repositoryRoot = "https://repo.spring.io/snapshot")
class ClientApplicationTests {

    @Autowired
    private StubFinder stubFinder;


    ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个基于JUnit 5的测试示例，该示例检索服务的元数据。这些断言在这里无关紧要，但是它说明了如何将其集成到自定义客户端的测试套件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootTest(webEnvironment = WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = "io.spring.initializr:initializr-web:${project.version}", stubsMode = StubsMode.LOCAL)
class ClientApplicationTests {

    @Autowired
    private StubFinder stubFinder;

    @Autowired
    private RestTemplate restTemplate;

    @Test
    void testCurrentMetadata() {
        RequestEntity&lt;Void&gt; request = RequestEntity.get(createUri("/"))
                .accept(MediaType.valueOf("application/vnd.initializr.v2.1+json")).build();

        ResponseEntity&lt;String&gt; response = this.restTemplate.exchange(request, String.class);
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        // other assertions here
    }

    private URI createUri(String path) {
        String url = this.stubFinder.findStubUrl("initializr-web").toString();
        return URI.create(url + path);
    }

    @TestConfiguration
    static class Config {

        @Bean
        RestTemplate restTemplate(RestTemplateBuilder builder) {
            return builder.build();
        }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您有一台返回JSON元数据存根的服务器（ <code>metadataWithCurrentAcceptHeader.json</code> ）当您发送标题时<code>Accept:application/vnd.initializr.v2.1+json</code> （根据建议）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="names-and-paths-of-stubs"><a class="anchor" href="#names-and-paths-of-stubs"></a> 12.2。存根的名称和路径</h3>
<div class="paragraph">
<p>存根以jar格式（在“ ** / mappings”下）放置在jar文件中，只需设置WireMock的文件源即可使用它。各个存根的名称与在Spring Initializr项目中生成它们的测试用例的方法名称相同。因此，例如，存在一个测试用例“ metadataWithV2AcceptHeader” <code>MainControllerIntegrationTests</code>当accept标头为<code>application/vnd.initializr.v2.1+json</code> 。响应记录在存根中，并且如果在Spring Initializr测试用例中和客户端中使用的标头和请求参数相同，则它将在WireMock中匹配。方法名称通常会概括这些值是什么。</p>
</div>
<div class="paragraph">
<p>存根转轮和<code>@AutoConfigureWireMock</code>在上面的示例中，将所有存根都加载到WireMock中，因此您不一定需要知道存根的名称。您也可以一个一个地注册存根，在这种情况下，这将有助于扫描存根jar并将文件名与测试方法进行比较。例如，如果您在存根（stubs）jar中查看，则会看到一个名为<code>metadataWithV2AcceptHeader.json</code>在initializr-web项目中，还有一个测试方法<code>metadataWithV2AcceptHeader</code>产生了它。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">最近更新时间2019-10-07 21:23:40 UTC</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</body></html>