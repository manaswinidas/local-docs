<html lang="zh-Hans" dir="ltr"><head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Spring Cloud</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);</script>


</head><body class="book toc2 toc-left" dir="ltr">
<div id="header">
<h1>Spring Cloud</h1>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#features">1。特征</a></li>
<li><a href="#cloud-documentation-versions">2。发布火车版本</a></li>
<li><a href="#cloud-native-applications">3。云原生应用</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-context-application-context-services">3.1。Spring Cloud Context：应用程序上下文服务</a></li>
<li><a href="#spring-cloud-commons-common-abstractions">3.2。Spring Cloud Commons：通用抽象</a></li>
<li><a href="#spring-cloud-loadbalancer">3.3。Spring Cloud负载均衡器</a></li>
<li><a href="#spring-cloud-circuit-breaker">3.4。spring-cloud-circuitbreaker</a></li>
<li><a href="#configuration-properties">3.5。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-config">4。Spring Cloud Config</a>
<ul class="sectlevel2">
<li><a href="#quick-start">4.1。快速开始</a></li>
<li><a href="#spring-cloud-config-server">4.2。Spring Cloud Config服务器</a></li>
<li><a href="#serving-alternative-formats">4.3。提供替代格式</a></li>
<li><a href="#serving-plain-text">4.4。提供纯文本</a></li>
<li><a href="#embedding-the-config-server">4.5。嵌入配置服务器</a></li>
<li><a href="#push-notifications-and-spring-cloud-bus">4.6。推送通知和Spring Cloud Bus</a></li>
<li><a href="#spring-cloud-config-client">4.7。Spring Cloud Config客户端</a></li>
</ul>
</li>
<li><a href="#spring-cloud-netflix">5，Spring Cloud Netflix</a>
<ul class="sectlevel2">
<li><a href="#service-discovery-eureka-clients">5.1。服务发现：Eureka客户</a></li>
<li><a href="#spring-cloud-eureka-server">5.2。服务发现：Eureka服务器</a></li>
<li><a href="#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">5.3。断路器：带Hystrix的spring-cloud-circuitbreaker</a></li>
<li><a href="#circuit-breaker-hystrix-clients">5.4。断路器：Hystrix客户</a></li>
<li><a href="#circuit-breaker-hystrix-dashboard">5.5。断路器：Hystrix仪表板</a></li>
<li><a href="#hystrix-timeouts-and-ribbon-clients">5.6。Hystrix超时和功能区客户端</a></li>
<li><a href="#spring-cloud-ribbon">5.7。客户端负载均衡器：功能区</a></li>
<li><a href="#external-configuration-archaius">5.8。外部配置：Archaius</a></li>
<li><a href="#router-and-filter-zuul">5.9。路由器和过滤器：Zuul</a></li>
<li><a href="#polyglot-support-with-sidecar">5.10。Sidecar支持多语种</a></li>
<li><a href="#retrying-failed-requests">5.11。重试失败的请求</a></li>
<li><a href="#http-clients-2">5.12。HTTP客户端</a></li>
<li><a href="#modules-in-maintenance-mode">5.13。维护模式下的模块</a></li>
<li><a href="#configuration-properties-2">5.14。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-openfeign">6。Spring Cloud OpenFeign</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-feign">6.1。声明式REST客户端：伪装</a></li>
<li><a href="#configuration-properties-3">6.2。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-bus">7。spring-cloud-bus</a>
<ul class="sectlevel2">
<li><a href="#quick-start-2">7.1。快速开始</a></li>
<li><a href="#bus-endpoints">7.2。总线端点</a></li>
<li><a href="#addressing-an-instance">7.3。寻址实例</a></li>
<li><a href="#addressing-all-instances-of-a-service">7.4。处理服务的所有实例</a></li>
<li><a href="#service-id-must-be-unique">7.5。服务ID必须唯一</a></li>
<li><a href="#customizing-the-message-broker">7.6。自定义消息代理</a></li>
<li><a href="#tracing-bus-events">7.7。追踪巴士事件</a></li>
<li><a href="#broadcasting-your-own-events">7.8。广播自己的活动</a></li>
<li><a href="#configuration-properties-4">7.9。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-sleuth">8。Spring Cloud侦探</a>
<ul class="sectlevel2">
<li><a href="#introduction-2">8.1。介绍</a></li>
<li><a href="#additional-resources">8.2。其他资源</a></li>
<li><a href="#features-2">8.3。特征</a></li>
<li><a href="#sampling">8.4。采样</a></li>
<li><a href="#propagation">8.5。传播</a></li>
<li><a href="#current-tracing-component">8.6。当前跟踪组件</a></li>
<li><a href="#current-span">8.7。当前跨度</a></li>
<li><a href="#instrumentation">8.8。仪器仪表</a></li>
<li><a href="#span-lifecycle">8.9。跨度生命周期</a></li>
<li><a href="#naming-spans">8.10。命名范围</a></li>
<li><a href="#managing-spans-with-annotations">8.11。使用注释管理跨度</a></li>
<li><a href="#customizations">8.12。客制化</a></li>
<li><a href="#sending-spans-to-zipkin">8.13。发送跨区到Zipkin</a></li>
<li><a href="#zipkin-stream-span-consumer">8.14。Zipkin流跨度消费者</a></li>
<li><a href="#integrations">8.15。整合方式</a></li>
<li><a href="#configuration-properties-5">8.16。配置属性</a></li>
<li><a href="#running-examples">8.17。运行示例</a></li>
</ul>
</li>
<li><a href="#spring-cloud-consul">9。spring-cloud-consul</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-consul-install">9.1。安装领事</a></li>
<li><a href="#spring-cloud-consul-agent">9.2。领事代理</a></li>
<li><a href="#spring-cloud-consul-discovery">9.3。领事服务发现</a></li>
<li><a href="#spring-cloud-consul-config">9.4。使用Consul进行分布式配置</a></li>
<li><a href="#spring-cloud-consul-retry">9.5。领事重试</a></li>
<li><a href="#spring-cloud-consul-bus">9.6。带领事的Spring Cloud Bus</a></li>
<li><a href="#spring-cloud-consul-hystrix">9.7。Hystrix断路器</a></li>
<li><a href="#spring-cloud-consul-turbine">9.8。Hystrix指标通过Turbine和Consul进行聚合</a></li>
<li><a href="#configuration-properties-6">9.9。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-zookeeper">10。春季云动物园管理员</a>
<ul class="sectlevel2">
<li><a href="#spring-cloud-zookeeper-install">10.1。安装Zookeeper</a></li>
<li><a href="#spring-cloud-zookeeper-discovery">10.2。Zookeeper的服务发现</a></li>
<li><a href="#spring-cloud-zookeeper-netflix">10.3。将Spring Cloud Zookeeper与Spring Cloud Netflix组件一起使用</a></li>
<li><a href="#spring-cloud-zookeeper-service-registry">10.4。Spring Cloud Zookeeper和服务注册表</a></li>
<li><a href="#spring-cloud-zookeeper-dependencies">10.5。Zookeeper依赖关系</a></li>
<li><a href="#spring-cloud-zookeeper-dependency-watcher">10.6。Spring Cloud Zookeeper依赖性观察程序</a></li>
<li><a href="#spring-cloud-zookeeper-config">10.7。Zookeeper的分布式配置</a></li>
</ul>
</li>
<li><a href="#spring-boot-cloud-cli">11。Spring Boot Cloud CLI</a>
<ul class="sectlevel2">
<li><a href="#installation">11.1。安装</a></li>
<li><a href="#running-spring-cloud-services-in-development">11.2。在开发中运行Spring Cloud Services</a></li>
<li><a href="#writing-groovy-scripts-and-running-applications">11.3。编写Groovy脚本并运行应用程序</a></li>
<li><a href="#encryption-and-decryption-3">11.4。加密与解密</a></li>
</ul>
</li>
<li><a href="#spring-cloud-security">12Spring Cloud Security</a>
<ul class="sectlevel2">
<li><a href="#quickstart">12.1。快速开始</a></li>
<li><a href="#more-detail">12.2。更多详情</a></li>
<li><a href="#configuring-authentication-downstream-of-a-zuul-proxy">12.3。配置Zuul代理的下游身份验证</a></li>
</ul>
</li>
<li><a href="#spring-cloud-for-cloud-foundry">13Spring Cloud for Cloud Foundry</a>
<ul class="sectlevel2">
<li><a href="#discovery">13.1。发现</a></li>
<li><a href="#single-sign-on-2">13.2。单点登录</a></li>
<li><a href="#configuration-3">13.3。组态</a></li>
</ul>
</li>
<li><a href="#spring-cloud-contract-reference-documentation">14。Spring Cloud Contract参考文档</a>
<ul class="sectlevel2">
<li><a href="#legal">法律</a></li>
<li><a href="#getting-started">14.1。入门</a></li>
<li><a href="#using">14.2。使用Spring Cloud Contract</a></li>
<li><a href="#features">14.3。Spring Cloud合约功能</a></li>
<li><a href="#maven-project">14.4。Maven项目</a></li>
<li><a href="#gradle-project">14.5。摇篮项目</a></li>
<li><a href="#docker">14.6。Docker项目</a></li>
<li><a href="#contract-customization">14.7。Spring Cloud Contract定制</a></li>
<li><a href="#howto">14.8。“使用方法”指南</a></li>
</ul>
</li>
<li><a href="#spring-cloud-vault">15Spring Cloud Vault</a>
<ul class="sectlevel2">
<li><a href="#quick-start-3">15.1。快速开始</a></li>
<li><a href="#client-side-usage-2">15.2。客户端使用</a></li>
<li><a href="#vault.config.authentication">15.3。认证方式</a></li>
<li><a href="#vault.config.backends">15.4。秘密后端</a></li>
<li><a href="#vault.config.backends.database-backends">15.5。数据库后端</a></li>
<li><a href="#vault.config.backends.configurer">15.6。配置<code>PropertySourceLocator</code>行为</a></li>
<li><a href="#service-registry-configuration">15.7。服务注册表配置</a></li>
<li><a href="#vault.config.fail-fast">15.8。Vault Client快速失败</a></li>
<li><a href="#vault.config.namespaces">15.9。Vault Enterprise命名空间支持</a></li>
<li><a href="#vault.config.ssl">15.10。Vault Client SSL配置</a></li>
<li><a href="#vault-lease-renewal">15.11。租赁生命周期管理（续订和吊销）</a></li>
</ul>
</li>
<li><a href="#spring-cloud-gateway">16。Spring Cloud Gateway</a>
<ul class="sectlevel2">
<li><a href="#gateway-starter">16.1。如何包括Spring Cloud Gateway</a></li>
<li><a href="#glossary">16.2。词汇表</a></li>
<li><a href="#gateway-how-it-works">16.3。怎么运行的</a></li>
<li><a href="#gateway-request-predicates-factories">16.4。路线谓词工厂</a></li>
<li><a href="#gatewayfilter-factories">16.5。GatewayFilter工厂</a></li>
<li><a href="#global-filters">16.6。全局过滤器</a></li>
<li><a href="#tls-ssl">16.7。TLS / SSL</a></li>
<li><a href="#configuration-4">16.8。组态</a></li>
<li><a href="#route-metadata-configuration">16.9。路由元数据配置</a></li>
<li><a href="#reactor-netty-access-logs">16.10。Reactor Netty访问日志</a></li>
<li><a href="#cors-configuration">16.11。CORS配置</a></li>
<li><a href="#actuator-api">16.12。执行器API</a></li>
<li><a href="#troubleshooting">16.13。故障排除</a></li>
<li><a href="#developer-guide">16.14。开发人员指南</a></li>
<li><a href="#building-a-simple-gateway-using-spring-mvc-or-webflux">16.15。使用Spring MVC或Webflux构建简单的网关</a></li>
<li><a href="#configuration-properties-7">16.16。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-function">17。spring-cloud-function</a>
<ul class="sectlevel2">
<li><a href="#introduction-3">17.1。介绍</a></li>
<li><a href="#getting-started-2">17.2。入门</a></li>
<li><a href="#programming-model">17.3。编程模型</a></li>
<li><a href="#standalone-web-applications">17.4。独立的Web应用程序</a></li>
<li><a href="#standalone-streaming-applications">17.5。独立流媒体应用程序</a></li>
<li><a href="#deploying-a-packaged-function">17.6。部署打包功能</a></li>
<li><a href="#functional-bean-definitions">17.7。功能Bean定义</a></li>
<li><a href="#dynamic-compilation">17.8。动态编译</a></li>
<li><a href="#serverless-platform-adapters">17.9。无服务器平台适配器</a></li>
</ul>
</li>
<li><a href="#spring-cloud-kubernetes">18岁Spring Cloud Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#why-do-you-need-spring-cloud-kubernetes">18.1。为什么需要Spring Cloud Kubernetes？</a></li>
<li><a href="#starters">18.2。初学者</a></li>
<li><a href="#discoveryclient-for-kubernetes">18.3。Kubernetes的DiscoveryClient</a></li>
<li><a href="#kubernetes-native-service-discovery">18.4。Kubernetes本机服务发现</a></li>
<li><a href="#kubernetes-propertysource-implementations">18.5。Kubernetes PropertySource实现</a></li>
<li><a href="#ribbon-discovery-in-kubernetes">18.6。Kubernetes中的Ribbon发现</a></li>
<li><a href="#kubernetes-ecosystem-awareness">18.7。Kubernetes生态系统意识</a></li>
<li><a href="#pod-health-indicator">18.8。豆荚健康指标</a></li>
<li><a href="#leader-election">18.9。领导人选举</a></li>
<li><a href="#security-configurations-inside-kubernetes">18.10。Kubernetes内部的安全配置</a></li>
<li><a href="#service-registry-implementation">18.11。服务注册表实施</a></li>
<li><a href="#examples">18.12。例子</a></li>
<li><a href="#other-resources">18.13。其他资源</a></li>
<li><a href="#configuration-properties-8">18.14。配置属性</a></li>
<li><a href="#building">18.15。建造</a></li>
<li><a href="#contributing">18.16。贡献</a></li>
</ul>
</li>
<li><a href="#spring-cloud-gcp-reference">19Spring Cloud GCP</a>
<ul class="sectlevel2">
<li><a href="#introduction-4">19.1。介绍</a></li>
<li><a href="#getting-started-3">19.2。入门</a></li>
<li><a href="#spring-cloud-gcp-core">19.3。Spring Cloud GCP核心</a></li>
<li><a href="#google-cloud-pubsub">19.4。Google Cloud Pub / Sub</a></li>
<li><a href="#spring-resources">19.5。春季资源</a></li>
<li><a href="#spring-jdbc">19.6。Spring JDBC</a></li>
<li><a href="#spring-integration">19.7。春季整合</a></li>
<li><a href="#spring-cloud-stream">19.8。春季云流</a></li>
<li><a href="#spring-cloud-bus-2">19.9。spring-cloud-bus</a></li>
<li><a href="#spring-cloud-sleuth-2">19.10。Spring Cloud侦探</a></li>
<li><a href="#stackdriver-logging">19.11。Stackdriver记录</a></li>
<li><a href="#spring-cloud-config-2">19.12。Spring Cloud Config</a></li>
<li><a href="#spring-data-cloud-spanner">19.13。Spring Data Cloud Spanner</a></li>
<li><a href="#spring-data-cloud-datastore">19.14。Spring Data Cloud数据存储</a></li>
<li><a href="#spring-data-reactive-repositories-for-cloud-firestore">19.15。Cloud Firestore的Spring Data Reactive存储库</a></li>
<li><a href="#cloud-memorystore-for-redis">19.16。Redis的Cloud Memorystore</a></li>
<li><a href="#cloud-identity-aware-proxy-iap-authentication">19.17。云身份识别代理（IAP）身份验证</a></li>
<li><a href="#google-cloud-vision">19.18。Google Cloud Vision</a></li>
<li><a href="#google-cloud-bigquery">19.19。Google Cloud BigQuery</a></li>
<li><a href="#cloud-foundry">19.20。云铸造</a></li>
<li><a href="#kotlin-support">19.21。Kotlin支持</a></li>
<li><a href="#configuration-properties-9">19.22。配置属性</a></li>
</ul>
</li>
<li><a href="#spring-cloud-circuit-breaker-2">20spring-cloud-circuitbreaker</a>
<ul class="sectlevel3">
<li><a href="#configuring-resilience4j-circuit-breakers">20.1。配置Resilience4J断路器</a></li>
<li><a href="#configuring-spring-retry-circuit-breakers">20.2。配置弹簧重试断路器</a></li>
<li><a href="#building-2">20.3。建造</a></li>
<li><a href="#contributing-2">20.4。贡献</a></li>
</ul>
</li>
<li><a href="#spring-cloud-stream-2">21春季云流</a>
<ul class="sectlevel2">
<li><a href="#a-brief-history-of-springs-data-integration-journey">21.1。Spring数据集成之旅简史</a></li>
<li><a href="#quick-start-5">21.2。快速开始</a></li>
<li><a href="#whats-new-in-2-0">21.3。2.0中有什么新功能？</a></li>
<li><a href="#spring-cloud-stream-overview-introducing">21.4。介绍Spring Cloud Stream</a></li>
<li><a href="#main-concepts">21.5。主要概念</a></li>
<li><a href="#programming-model-2">21.6。程式设计模型</a></li>
<li><a href="#spring-cloud-stream-overview-binders">21.7。黏合剂</a></li>
<li><a href="#configuration-options">21.8。配置选项</a></li>
<li><a href="#content-type-management">21.9。内容类型协商</a></li>
<li><a href="#schema-evolution">21.10。模式演进支持</a></li>
<li><a href="#inter-application-communication">21.11。应用间通信</a></li>
<li><a href="#testing">21.12。测试中</a></li>
<li><a href="#health-indicator-5">21.13。健康指标</a></li>
<li><a href="#spring-cloud-stream-overview-metrics-emitter">21.14。公制发射器</a></li>
<li><a href="#samples-2">21.15。样品</a></li>
</ul>
</li>
<li><a href="#binder-implementations">22活页夹实现</a>
<ul class="sectlevel2">
<li><a href="#apache-kafka-binder">22.1Apache Kafka活页夹</a></li>
<li><a href="#apache-kafka-streams-binder">22.2。Apache Kafka Streams活页夹</a></li>
<li><a href="#rabbitmq-binder">22.3。RabbitMQ活页夹</a></li>
</ul>
</li>
<li><a href="#appendix-compendium-of-configuration-properties">附录：配置属性概述</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud为开发人员提供了工具，以快速构建分布式系统中的某些常见模式（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致样板式样，并且使用Spring Cloud开发人员可以快速站起来实现这些样板的服务和应用程序。它们将在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑，裸机数据中心以及诸如Cloud Foundry之类的托管平台。</p>
</div>
<div class="paragraph">
<p>发行列车版本： <strong>Hoxton。发布</strong></p>
</div>
<div class="paragraph">
<p>支持的引导版本： <strong>2.2.1。发布</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="features"><a class="anchor" href="#features"></a> <a class="link" href="#features">1。特征</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud致力于为典型的用例和扩展机制提供良好的开箱即用体验，以涵盖其他情况。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>分布式/版本化配置</p>
</li>
<li>
<p>服务注册和发现</p>
</li>
<li>
<p>路由</p>
</li>
<li>
<p>服务到服务的呼叫</p>
</li>
<li>
<p>负载均衡</p>
</li>
<li>
<p>断路器</p>
</li>
<li>
<p>分布式消息传递</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cloud-documentation-versions"><a class="anchor" href="#cloud-documentation-versions"></a> <a class="link" href="#cloud-documentation-versions">2。发布火车版本</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表格1。发布培训项目版本</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">项目名</th>
<th class="tableblock halign-left valign-top">项目版本</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-build</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-commons</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-function</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.0.0。发布</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Horsham.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-bus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-task</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.1。发布</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-config</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-netflix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-cloudfoundry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-kubernetes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.1.0。发布</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-openfeign</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-consul</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-gateway</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-security</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-sleuth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-zookeeper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-contract</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-gcp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.2.0。发布</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-vault</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-circuitbreaker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0.0。发布</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-cli</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.0.RELEASE</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="cloud-native-applications"><a class="anchor" href="#cloud-native-applications"></a> <a class="link" href="#cloud-native-applications">3。云原生应用</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook">Cloud Native</a>是一种应用程序开发样式，鼓励在持续交付和价值驱动型开发领域轻松采用最佳实践。一个相关的学科是构建<a href="https://12factor.net/">12要素应用程序</a> ，其中开发实践与交付和运营目标保持一致-例如，通过使用声明性编程，管理和监视。Spring Cloud通过多种特定方式促进了这些开发风格。起点是一组功能，分布式系统中的所有组件都需要轻松访问这些功能。</p>
</div>
<div class="paragraph">
<p>Spring Cloud构建于其中的Spring <a href="https://projects.spring.io/spring-boot">Boot</a>涵盖了许多这些功能。Spring Cloud作为两个库提供了更多功能：Spring Cloud上下文和Spring Cloud Commons。Spring Cloud Context为以下项目提供实用程序和特殊服务： <code>ApplicationContext</code> Spring Cloud应用程序（引导上下文，加密，刷新作用域和环境端点）。Spring Cloud Commons是在不同的Spring Cloud实现中使用的一组抽象和通用类（例如Spring Cloud Netflix和Spring Cloud Consul）。</p>
</div>
<div class="paragraph">
<p>如果由于“密钥大小非法”而导致异常，并且使用Sun的JDK，则需要安装Java密码术扩展（JCE）无限强度管辖权策略文件。有关更多信息，请参见以下链接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">Java 6 JCE</a></p>
</li>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Java 7 JCE</a></p>
</li>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java 8 JCE</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将文件解压缩到您使用的JRE / JDK x64 / x86版本的JDK / jre / lib / security文件夹中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，可以在{docslink} [github]上找到该项目的源代码和问题跟踪器。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="spring-cloud-context-application-context-services"><a class="anchor" href="#spring-cloud-context-application-context-services"></a> <a class="link" href="#spring-cloud-context-application-context-services">3.1。Spring Cloud Context：应用程序上下文服务</a></h3>
<div class="paragraph">
<p>Spring Boot对于如何使用Spring构建应用程序有一个坚定的看法。例如，它具有用于公共配置文件的常规位置，并具有用于公共管理和监视任务的端点。Spring Cloud在此基础上构建并添加了一些功能，这些功能可能是系统中所有组件可能会使用或偶尔需要的。</p>
</div>
<div class="sect3">
<h4 id="the-bootstrap-application-context"><a class="anchor" href="#the-bootstrap-application-context"></a> <a class="link" href="#the-bootstrap-application-context">3.1.1。Bootstrap应用程序上下文</a></h4>
<div class="paragraph">
<p>Spring Cloud应用程序通过创建“引导”上下文来运行，该上下文是主应用程序的父上下文。它负责从外部源加载配置属性，并负责解密本地外部配置文件中的属性。这两个上下文共享一个<code>Environment</code> ，这是任何Spring应用程序的外部属性的来源。默认情况下，引导程序属性（不<code>bootstrap.properties</code>但在引导阶段加载的属性）具有较高的优先级，因此它们不能被本地配置覆盖。</p>
</div>
<div class="paragraph">
<p>引导上下文使用不同于主应用程序上下文的约定来定位外部配置。代替<code>application.yml</code> （要么<code>.properties</code> ）， 您可以使用<code>bootstrap.yml</code> ，将引导程序的外部配置和主上下文很好地分开。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre>spring:
  application:
    name: foo
  cloud:
    config:
      uri: ${SPRING_CONFIG_URI:http://localhost:8888}</pre>
</div>
</div>
<div class="paragraph">
<p>如果您的应用程序需要来自服务器的任何特定于应用程序的配置，则最好设置<code>spring.application.name</code> （在<code>bootstrap.yml</code>要么<code>application.yml</code> ）。为了财产<code>spring.application.name</code>要用作应用程序的上下文ID，必须在<code>bootstrap.[properties | yml]</code> 。</p>
</div>
<div class="paragraph">
<p>您可以通过设置完全禁用引导过程<code>spring.cloud.bootstrap.enabled=false</code> （例如，在系统属性中）。</p>
</div>
</div>
<div class="sect3">
<h4 id="application-context-hierarchies"><a class="anchor" href="#application-context-hierarchies"></a> <a class="link" href="#application-context-hierarchies">3.1.2。应用程序上下文层次结构</a></h4>
<div class="paragraph">
<p>如果您从中构建应用程序上下文<code>SpringApplication</code>要么<code>SpringApplicationBuilder</code> ，然后将Bootstrap上下文作为父级添加到该上下文。Spring的一个功能是子上下文从其父级继承属性源和配置文件，因此，与没有Spring Cloud Config的情况下构建相同上下文相比，“主”应用程序上下文包含其他属性源。其他属性来源是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“引导程序”：如果有的话<code>PropertySourceLocators</code>在Bootstrap上下文中找到，并且如果它们具有非空属性，则为可选<code>CompositePropertySource</code>优先出现。一个示例就是Spring Cloud Config Server中的属性。有关如何自定义此属性源内容的说明，请参见“ <a href="#customizing-bootstrap-property-sources">自定义Bootstrap属性源</a> ”。</p>
</li>
<li>
<p>“ applicationConfig：[classpath：bootstrap.yml]”（以及相关文件，如果Spring配置文件处于活动状态）：如果您有一个<code>bootstrap.yml</code> （要么<code>.properties</code> ），这些属性用于配置Bootstrap上下文。然后，当它们的父级被设置时，它们被添加到子级上下文中。它们的优先级低于<code>application.yml</code> （要么<code>.properties</code> ）以及在创建Spring Boot应用程序过程中通常添加到子级的任何其他属性源。有关如何自定义这些属性源内容的说明，请参见“ <a href="#customizing-bootstrap-properties">更改Bootstrap属性的位置</a> ”。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于属性源的排序规则，“引导程序”条目具有优先权。但是，请注意，这些不包含来自<code>bootstrap.yml</code> ，其优先级非常低，但可用于设置默认值。</p>
</div>
<div class="paragraph">
<p>您可以通过设置以下内容的父上下文来扩展上下文层次结构<code>ApplicationContext</code>您创建-例如，通过使用其自己的界面或<code>SpringApplicationBuilder</code>便利方法（ <code>parent()</code> ， <code>child()</code>和<code>sibling()</code> ）。引导上下文是您创建的最高级祖先的父级。层次结构中的每个上下文都有其自己的“引导程序”（可能为空）属性源，以避免无意间将价值从父辈提升到子孙后代。如果有配置服务器，则层次结构中的每个上下文原则上也可以有不同的<code>spring.application.name</code>因此，另一个远程资源来源。常规的Spring应用程序上下文行为规则适用于属性解析：子上下文中的属性会按名称以及属性源名称覆盖父级属性。（如果子级具有与父级同名的属性源，则子级中不包含父级的值）。</p>
</div>
<div class="paragraph">
<p>请注意<code>SpringApplicationBuilder</code>让你分享一个<code>Environment</code>在整个层次结构中，但这不是默认值。因此，同级上下文尤其不需要具有相同的配置文件或属性源，即使它们可以与其父级共享相同的值。</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-bootstrap-properties"><a class="anchor" href="#customizing-bootstrap-properties"></a> <a class="link" href="#customizing-bootstrap-properties">3.1.3。更改引导程序属性的位置</a></h4>
<div class="paragraph">
<p>的<code>bootstrap.yml</code> （要么<code>.properties</code> ）位置可以通过设置来指定<code>spring.cloud.bootstrap.name</code> （默认： <code>bootstrap</code> ） 要么<code>spring.cloud.bootstrap.location</code> （默认值：空）—例如，在系统属性中。这些属性的行为类似于<code>spring.config.*</code>具有相同名称的变体。实际上，它们是用来设置引导程序的<code>ApplicationContext</code>通过设置其属性<code>Environment</code> 。如果有有效的个人资料（来自<code>spring.profiles.active</code>或通过<code>Environment</code>在您正在构建的上下文中使用API），该配置文件中的属性也会被加载，与常规Spring Boot应用程序中的加载方法相同（例如，从<code>bootstrap-development.properties</code>为一个<code>development</code>轮廓。</p>
</div>
</div>
<div class="sect3">
<h4 id="overriding-bootstrap-properties"><a class="anchor" href="#overriding-bootstrap-properties"></a> <a class="link" href="#overriding-bootstrap-properties">3.1.4。覆盖远程属性的值</a></h4>
<div class="paragraph">
<p>通过引导上下文添加到应用程序的属性源通常是“远程的”（例如，来自Spring Cloud Config Server）。默认情况下，不能在本地覆盖它们。如果要让您的应用程序使用自己的系统属性或配置文件覆盖远程属性，则远程属性源必须通过设置来授予其权限<code>spring.cloud.config.allowOverride=true</code> （在本地设置此功能无效）。设置该标志后，将使用两个更细粒度的设置来控制远程属性相对于系统属性和应用程序本地配置的位置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.config.overrideNone=true</code> ：从任何本地属性源覆盖。</p>
</li>
<li>
<p><code>spring.cloud.config.overrideSystemProperties=false</code>注意：只有系统属性，命令行参数和环境变量（而不是本地配置文件）才应覆盖远程设置。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="customizing-the-bootstrap-configuration"><a class="anchor" href="#customizing-the-bootstrap-configuration"></a> <a class="link" href="#customizing-the-bootstrap-configuration">3.1.5。自定义引导程序配置</a></h4>
<div class="paragraph">
<p>引导上下文可以设置为通过添加条目来执行您喜欢的任何操作<code>/META-INF/spring.factories</code>在名为<code>org.springframework.cloud.bootstrap.BootstrapConfiguration</code> 。它包含逗号分隔的Spring列表<code>@Configuration</code>用于创建上下文的类。您可以在此处创建要对主应用程序上下文可用以进行自动装配的任何bean。有一个特殊的合同<code>@Beans</code>类型的<code>ApplicationContextInitializer</code> 。如果要控制启动顺序，则可以用<code>@Order</code>批注（默认顺序为<code>last</code> ）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">添加自定义时<code>BootstrapConfiguration</code> ，请注意不要添加添加的类<code>@ComponentScanned</code>错误地插入到可能不需要它们的“主”应用程序上下文中。为启动配置类使用单独的程序包名称，并确保您的名称尚未涵盖该名称<code>@ComponentScan</code>要么<code>@SpringBootApplication</code>带注释的配置类。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>引导过程通过将初始化程序注入主程序而结束<code>SpringApplication</code>实例（这是正常的Spring Boot启动序列，无论它是作为独立应用程序运行还是在应用程序服务器中部署）。首先，从中找到的类创建引导上下文<code>spring.factories</code> 。然后，全部<code>@Beans</code>类型的<code>ApplicationContextInitializer</code>被添加到主要<code>SpringApplication</code>在开始之前。</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-bootstrap-property-sources"><a class="anchor" href="#customizing-bootstrap-property-sources"></a> <a class="link" href="#customizing-bootstrap-property-sources">3.1.6。自定义Bootstrap属性源</a></h4>
<div class="paragraph">
<p>引导过程添加的外部配置的默认属性源是Spring Cloud Config Server，但是您可以通过添加类型的bean添加其他源<code>PropertySourceLocator</code>到引导上下文（通过<code>spring.factories</code> ）。例如，您可以从其他服务器或数据库插入其他属性。</p>
</div>
<div class="paragraph">
<p>例如，请考虑以下定制定位器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class CustomPropertySourceLocator implements PropertySourceLocator {

    @Override
    public PropertySource<?> locate(Environment environment) {
        return new MapPropertySource("customProperty",
                Collections.<String, Object>singletonMap("property.from.sample.custom.source", "worked as intended"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Environment</code>传入的是用于<code>ApplicationContext</code>即将创建-换句话说，我们为其提供其他属性源的属性。它已经有正常的Spring Boot提供的属性源，因此您可以使用这些属性来定位特定于此的属性源<code>Environment</code> （例如，通过将其<code>spring.application.name</code> ，就像在默认的Spring Cloud Config Server属性源定位器中所做的一样。</p>
</div>
<div class="paragraph">
<p>如果您在其中创建带有此类的jar，然后添加一个<code>META-INF/spring.factories</code>包含以下内容<code>customProperty</code><code>PropertySource</code>出现在任何在其类路径中包含该jar的应用程序中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="logging-configuration"><a class="anchor" href="#logging-configuration"></a> <a class="link" href="#logging-configuration">3.1.7。记录配置</a></h4>
<div class="paragraph">
<p>如果要使用Spring Boot配置日志设置，则应将此配置放在`bootstrap。[yml |属性]，如果您希望将其应用于所有事件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为了使Spring Cloud正确初始化日志记录配置，您不能使用自定义前缀。例如，使用<code>custom.loggin.logpath</code>初始化日志记录系统时，Spring Cloud将无法识别。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="environment-changes"><a class="anchor" href="#environment-changes"></a> <a class="link" href="#environment-changes">3.1.8。环境变化</a></h4>
<div class="paragraph">
<p>该应用程序监听<code>EnvironmentChangeEvent</code>并以几种标准方式对更改做出反应（其他<code>ApplicationListeners</code>可以添加为<code>@Beans</code>由用户以正常方式）。当一个<code>EnvironmentChangeEvent</code>被观察到，它具有已更改的键值的列表，应用程序使用这些键值来：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>重新绑定任何<code>@ConfigurationProperties</code>上下文中的bean</p>
</li>
<li>
<p>在以下位置设置记录器级别的任何属性<code>logging.level.*</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，默认情况下，“配置客户端”不会轮询<code>Environment</code> 。通常，我们不建议您使用这种方法来检测更改（尽管您可以使用<code>@Scheduled</code>注解）。如果您拥有横向扩展的客户端应用程序，则最好广播<code>EnvironmentChangeEvent</code>所有实例，而不是让它们轮询更改（例如，通过使用<a href="https://github.com/spring-cloud/spring-cloud-bus">Spring Cloud Bus</a> ）。</p>
</div>
<div class="paragraph">
<p>的<code>EnvironmentChangeEvent</code>涵盖了一大类刷新用例，只要您实际上可以对<code>Environment</code>并发布活动。请注意，这些API是公共的，并且是核心Spring的一部分）。您可以验证更改是否绑定到<code>@ConfigurationProperties</code>通过访问<code>/configprops</code>端点（正常的Spring Boot Actuator功能）。例如，一个<code>DataSource</code>可以有它<code>maxPoolSize</code>在运行时更改（默认<code>DataSource</code>由Spring Boot创建的是<code>@ConfigurationProperties</code> bean）并动态地增加容量。重新绑定<code>@ConfigurationProperties</code>不涵盖另一类大类用例，在这些用例中，您需要对刷新有更多的控制，并且需要进行更改以使整体成为原子<code>ApplicationContext</code> 。为了解决这些问题，我们有<code>@RefreshScope</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="refresh-scope"><a class="anchor" href="#refresh-scope"></a> <a class="link" href="#refresh-scope">3.1.9。刷新范围</a></h4>
<div class="paragraph">
<p>当配置发生变化时，弹簧<code>@Bean</code>被标记为<code>@RefreshScope</code>得到特殊待遇。此功能解决了有状态Bean的问题，只有在初始化它们时才注入配置。例如，如果<code>DataSource</code>通过以下方式更改数据库URL时，连接已打开<code>Environment</code> ，您可能希望这些连接的持有人能够完成他们正在做的事情。然后，下次某物从池中借用连接时，它将获得具有新URL的连接。</p>
</div>
<div class="paragraph">
<p>有时，甚至可能必须应用<code>@RefreshScope</code>某些bean上的注释只能被初始化一次。如果bean是“不可变的”，则必须使用以下命令对bean进行注释<code>@RefreshScope</code>或在属性键下指定类名<code>spring.cloud.refresh.extra-refreshable</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您创建一个<code>DataSource</code> bean自己，实现是一个<code>HikariDataSource</code> ，返回最具体的类型，在这种情况下<code>HikariDataSource</code> 。否则，您需要设置<code>spring.cloud.refresh.extra-refreshable=javax.sql.DataSource</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>刷新作用域bean是惰性代理，它们在使用时（即，在调用方法时）进行初始化，并且作用域充当初始化值的缓存。要强制bean在下一个方法调用上重新初始化，必须使它的缓存条目无效。</p>
</div>
<div class="paragraph">
<p>的<code>RefreshScope</code>在上下文中是一个bean，并且有一个公共的<code>refreshAll()</code>通过清除目标缓存来刷新作用域中所有bean的方法。的<code>/refresh</code>端点公开了此功能（通过HTTP或JMX）。要通过名称刷新单个bean，还有一个<code>refresh(String)</code>方法。</p>
</div>
<div class="paragraph">
<p>揭露<code>/refresh</code>端点，您需要向应用程序添加以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">management:
  endpoints:
    web:
      exposure:
        include: refresh</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@RefreshScope</code> （技术上）在<code>@Configuration</code>类，但可能会导致令人惊讶的行为。例如，这并不意味着所有<code>@Beans</code>该类中定义的自己<code>@RefreshScope</code> 。特别是，依赖于那些bean的任何东西都不能依靠刷新开始时对其进行更新，除非它本身在其中<code>@RefreshScope</code> 。在这种情况下，将在刷新时重建它，并重新注入其依赖项。此时，它们将从刷新后重新初始化<code>@Configuration</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="encryption-and-decryption"><a class="anchor" href="#encryption-and-decryption"></a> <a class="link" href="#encryption-and-decryption">3.1.10。加密与解密</a></h4>
<div class="paragraph">
<p>Spring Cloud有一个<code>Environment</code>用于本地解密属性值的预处理器。它遵循与Config Server相同的规则，并通过以下方式具有相同的外部配置<code>encrypt.*</code> 。因此，您可以使用以下形式的加密值： <code>{cipher}*</code>并且，只要有一个有效的密钥，它们就会在主应用程序上下文获得<code>Environment</code>设置。要在应用程序中使用加密功能，您需要在类路径中包含Spring Security RSA（Maven坐标：“ org.springframework.security:spring-security-rsa”），并且还需要在其中使用完整强度的JCE扩展。您的JVM。</p>
</div>
<div class="paragraph">
<p>如果由于“密钥大小非法”而导致异常，并且使用Sun的JDK，则需要安装Java密码术扩展（JCE）无限强度管辖权策略文件。有关更多信息，请参见以下链接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html">Java 6 JCE</a></p>
</li>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html">Java 7 JCE</a></p>
</li>
<li>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java 8 JCE</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将文件解压缩到您使用的JRE / JDK x64 / x86版本的JDK / jre / lib / security文件夹中。</p>
</div>
</div>
<div class="sect3">
<h4 id="endpoints"><a class="anchor" href="#endpoints"></a> <a class="link" href="#endpoints">3.1.11。终点</a></h4>
<div class="paragraph">
<p>对于Spring Boot Actuator应用程序，可以使用一些其他管理端点。您可以使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>POST</code>至<code>/actuator/env</code>更新<code>Environment</code>并重新绑定<code>@ConfigurationProperties</code>和日志级别。</p>
</li>
<li>
<p><code>/actuator/refresh</code>重新加载引导上下文并刷新<code>@RefreshScope</code>豆子。</p>
</li>
<li>
<p><code>/actuator/restart</code>关闭<code>ApplicationContext</code>并重新启动它（默认情况下禁用）。</p>
</li>
<li>
<p><code>/actuator/pause</code>和<code>/actuator/resume</code>用于呼叫<code>Lifecycle</code>方法 （ <code>stop()</code>和<code>start()</code>在<code>ApplicationContext</code> ）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果禁用<code>/actuator/restart</code>端点然后<code>/actuator/pause</code>和<code>/actuator/resume</code>端点也将被禁用，因为它们只是<code>/actuator/restart</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-commons-common-abstractions"><a class="anchor" href="#spring-cloud-commons-common-abstractions"></a> <a class="link" href="#spring-cloud-commons-common-abstractions">3.2。Spring Cloud Commons：通用抽象</a></h3>
<div class="paragraph">
<p>服务发现，负载平衡和电路断路器等模式将它们带到一个通用的抽象层，可以由所有Spring Cloud客户端使用，而与实现无关（例如，使用Eureka或Consul进行的发现）。</p>
</div>
<div class="sect3">
<h4 id="discovery-client"><a class="anchor" href="#discovery-client"></a> <a class="link" href="#discovery-client">3.2.1。@EnableDiscoveryClient</a></h4>
<div class="paragraph">
<p>Spring Cloud Commons提供了<code>@EnableDiscoveryClient</code>注解。这寻找实现<code>DiscoveryClient</code>和<code>ReactiveDiscoveryClient</code>与<code>META-INF/spring.factories</code> 。发现客户端的实现将配置类添加到<code>spring.factories</code>在下面<code>org.springframework.cloud.client.discovery.EnableDiscoveryClient</code>键。示例<code>DiscoveryClient</code>实施包括<a href="https://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix Eureka</a> ， <a href="https://cloud.spring.io/spring-cloud-consul/">Spring Cloud Consul Discovery</a>和<a href="https://cloud.spring.io/spring-cloud-zookeeper/">Spring Cloud Zookeeper Discovery</a> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Cloud将同时提供阻止和响应服务发现客户端。您可以通过设置轻松禁用阻止和/或反应式客户端<code>spring.cloud.discovery.blocking.enabled=false</code>要么<code>spring.cloud.discovery.reactive.enabled=false</code> 。要完全禁用服务发现，您只需设置<code>spring.cloud.discovery.enabled=false</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>DiscoveryClient</code>向远程发现服务器自动注册本地Spring Boot服务器。可以通过设置禁用此行为<code>autoRegister=false</code>在<code>@EnableDiscoveryClient</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>@EnableDiscoveryClient</code>不再需要。你可以放一个<code>DiscoveryClient</code>类路径上的实现导致Spring Boot应用程序向服务发现服务器注册。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="health-indicator"><a class="anchor" href="#health-indicator"></a> <a class="link" href="#health-indicator">健康指标</a></h5>
<div class="paragraph">
<p>公用创建弹簧靴<code>HealthIndicator</code>那<code>DiscoveryClient</code>实施可以通过实施参与<code>DiscoveryHealthIndicator</code> 。禁用复合<code>HealthIndicator</code> ，设定<code>spring.cloud.discovery.client.composite-indicator.enabled=false</code> 。通用<code>HealthIndicator</code>基于<code>DiscoveryClient</code>已自动配置（ <code>DiscoveryClientHealthIndicator</code> ）。要禁用它，请设置<code>spring.cloud.discovery.client.health-indicator.enabled=false</code> 。要禁用<code>DiscoveryClientHealthIndicator</code> ，设定<code>spring.cloud.discovery.client.health-indicator.include-description=false</code> 。否则，它会随着<code>description</code>卷起的<code>HealthIndicator</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="ordering-discoveryclient-instances"><a class="anchor" href="#ordering-discoveryclient-instances"></a> <a class="link" href="#ordering-discoveryclient-instances">定购<code>DiscoveryClient</code>实例</a></h5>
<div class="paragraph">
<p><code>DiscoveryClient</code>接口扩展<code>Ordered</code> 。当使用多个发现客户端时，这很有用，因为它允许您定义返回的发现客户端的顺序，类似于如何订购Spring应用程序加载的bean。默认情况下，任何<code>DiscoveryClient</code>被设定为<code>0</code> 。如果您想为自定义设置其他订单<code>DiscoveryClient</code>实现，您只需要覆盖<code>getOrder()</code>方法，以便它返回适合您的设置的值。除此之外，您还可以使用属性设置广告订单的顺序<code>DiscoveryClient</code> Spring Cloud提供的实现，以及其他<code>ConsulDiscoveryClient</code> ， <code>EurekaDiscoveryClient</code>和<code>ZookeeperDiscoveryClient</code> 。为此，您只需要设置<code>spring.cloud.{clientIdentifier}.discovery.order</code> （要么<code>eureka.client.order</code> （对于Eureka）属性为所需值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="serviceregistry"><a class="anchor" href="#serviceregistry"></a> <a class="link" href="#serviceregistry">3.2.2。服务注册</a></h4>
<div class="paragraph">
<p>现在，Commons提供了一个<code>ServiceRegistry</code>提供诸如以下方法的接口<code>register(Registration)</code>和<code>deregister(Registration)</code> ，让您提供自定义的注册服务。
<code>Registration</code>是标记界面。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>ServiceRegistry</code>正在使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableDiscoveryClient(autoRegister=false)
public class MyConfiguration {
    private ServiceRegistry registry;

    public MyConfiguration(ServiceRegistry registry) {
        this.registry = registry;
    }

    // called through some external process, such as an event or a custom actuator endpoint
    public void register() {
        Registration registration = constructRegistration();
        this.registry.register(registration);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每<code>ServiceRegistry</code>实现有自己的<code>Registry</code>实施。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ZookeeperRegistration</code>用于<code>ZookeeperServiceRegistry</code></p>
</li>
<li>
<p><code>EurekaRegistration</code>用于<code>EurekaServiceRegistry</code></p>
</li>
<li>
<p><code>ConsulRegistration</code>用于<code>ConsulServiceRegistry</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您正在使用<code>ServiceRegistry</code>界面，您将需要传递正确的<code>Registry</code>实施<code>ServiceRegistry</code>您正在使用的实现。</p>
</div>
<div class="sect4">
<h5 id="serviceregistry-auto-registration"><a class="anchor" href="#serviceregistry-auto-registration"></a> <a class="link" href="#serviceregistry-auto-registration">ServiceRegistry自动注册</a></h5>
<div class="paragraph">
<p>默认情况下， <code>ServiceRegistry</code>实现自动注册正在运行的服务。要禁用该行为，可以设置：* <code>@EnableDiscoveryClient(autoRegister=false)</code>永久禁用自动注册。* <code>spring.cloud.service-registry.auto-registration.enabled=false</code>通过配置禁用行为。</p>
</div>
<div class="sect5">
<h6 id="serviceregistry-auto-registration-events"><a class="anchor" href="#serviceregistry-auto-registration-events"></a> <a class="link" href="#serviceregistry-auto-registration-events">ServiceRegistry自动注册事件</a></h6>
<div class="paragraph">
<p>服务自动注册时将触发两个事件。第一个事件称为<code>InstancePreRegisteredEvent</code>在注册服务之前被触发。第二个事件称为<code>InstanceRegisteredEvent</code>注册服务后触发。您可以注册一个<code>ApplicationListener</code> （s）听这些事件并做出反应。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果发生以下情况，则不会触发这些事件<code>spring.cloud.service-registry.auto-registration.enabled</code>被设定为<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="service-registry-actuator-endpoint"><a class="anchor" href="#service-registry-actuator-endpoint"></a> <a class="link" href="#service-registry-actuator-endpoint">服务注册表执行器端点</a></h5>
<div class="paragraph">
<p>Spring Cloud Commons提供了一个<code>/service-registry</code>执行器端点。该端点依赖于<code>Registration</code> Spring应用程序上下文中的bean。呼唤<code>/service-registry</code>使用GET返回的状态<code>Registration</code> 。对带有JSON正文的同一终结点使用POST可以更改当前状态<code>Registration</code>达到新的价值。JSON正文必须包含<code>status</code>具有首选值的字段。请参阅<code>ServiceRegistry</code>在更新状态和为状态返回的值时用于允许值的实现。例如，Eureka的支持状态为<code>UP</code> ， <code>DOWN</code> ， <code>OUT_OF_SERVICE</code>和<code>UNKNOWN</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rest-template-loadbalancer-client"><a class="anchor" href="#rest-template-loadbalancer-client"></a> <a class="link" href="#rest-template-loadbalancer-client">3.2.3。Spring RestTemplate作为负载均衡器客户端</a></h4>
<div class="paragraph">
<p><code>RestTemplate</code>可以自动配置为在后台使用负载均衡器客户端。创建负载平衡<code>RestTemplate</code> ， 创建一个<code>RestTemplate</code><code>@Bean</code>并使用<code>@LoadBalanced</code>限定符，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

public class MyClass {
    @Autowired
    private RestTemplate restTemplate;

    public String doOtherStuff() {
        String results = restTemplate.getForObject("http://stores/stores", String.class);
        return results;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">一种<code>RestTemplate</code>不再通过自动配置创建bean。各个应用程序必须创建它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>URI需要使用虚拟主机名（即服务名，而不是主机名）。功能区客户端用于创建完整的物理地址。有关如何进行<code>RestTemplate</code>设置好了。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">为了使用负载均衡<code>RestTemplate</code> ，您需要在类路径中有一个负载平衡器实现。推荐的实现是<code>BlockingLoadBalancerClient</code> -将<a href="#spring-cloud-loadbalancer-starter">Spring Cloud LoadBalancer启动器</a>添加到您的项目中以使用它。的<code>RibbonLoadBalancerClient</code>也可以使用，但现在正在维护中，我们不建议将其添加到新项目中。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果两者都有<code>RibbonLoadBalancerClient</code>和<code>BlockingLoadBalancerClient</code> ，为了保持向后兼容性， <code>RibbonLoadBalancerClient</code>将默认使用。为了覆盖它，您可以设置属性<code>spring.cloud.loadbalancer.ribbon.enabled</code>至<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="webclinet-loadbalancer-client"><a class="anchor" href="#webclinet-loadbalancer-client"></a> <a class="link" href="#webclinet-loadbalancer-client">3.2.4。Spring WebClient作为负载均衡器客户端</a></h4>
<div class="paragraph">
<p><code>WebClient</code>可以自动配置为使用负载平衡器客户端。创建负载平衡<code>WebClient</code> ， 创建一个<code>WebClient.Builder</code><code>@Bean</code>并使用<code>@LoadBalanced</code>限定符，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }
}

public class MyClass {
    @Autowired
    private WebClient.Builder webClientBuilder;

    public Mono<String> doOtherStuff() {
        return webClientBuilder.build().get().uri("http://stores/stores")
                        .retrieve().bodyToMono(String.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI需要使用虚拟主机名（即服务名，而不是主机名）。Ribbon客户端或Spring Cloud LoadBalancer用于创建完整的物理地址。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您想使用<code>@LoadBalanced WebClient.Builder</code> ，则需要在类路径中有一个loadbalancer实现。建议您将<a href="#spring-cloud-loadbalancer-starter">Spring Cloud LoadBalancer启动器</a>添加到项目中。然后， <code>ReactiveLoadBalancer</code>将在下面使用。或者，此功能也可以与<code>spring-cloud-starter-netflix-ribbon</code> ，但该请求将由非反应式处理<code>LoadBalancerClient</code>在引擎盖下。此外，spring-cloud-starter-netflix-ribbon已经处于维护模式，因此我们不建议您将其添加到新项目中。如果两者都有<code>spring-cloud-starter-loadbalancer</code>和<code>spring-cloud-starter-netflix-ribbon</code>在您的类路径中，默认情况下将使用功能区。为了切换到Spring Cloud LoadBalancer，设置值<code>spring.cloud.loadbalancer.ribbon.enabled</code>虚假。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="retrying-failed-requests"><a class="anchor" href="#retrying-failed-requests"></a> <a class="link" href="#retrying-failed-requests">重试失败的请求</a></h5>
<div class="paragraph">
<p>负载均衡<code>RestTemplate</code>可以配置为重试失败的请求。默认情况下，禁用此逻辑。您可以通过将<a href="https://github.com/spring-projects/spring-retry">Spring Retry</a>添加到应用程序的类路径来启用它。负载均衡<code>RestTemplate</code>支持某些与重试失败请求有关的功能区配置值。您可以使用<code>client.ribbon.MaxAutoRetries</code> ， <code>client.ribbon.MaxAutoRetriesNextServer</code>和<code>client.ribbon.OkToRetryOnAllOperations</code>属性。如果您想在类路径上使用Spring Retry禁用重试逻辑，则可以设置<code>spring.cloud.loadbalancer.retry.enabled=false</code> 。有关这些属性的说明，请参见<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties">功能区文档</a> 。</p>
</div>
<div class="paragraph">
<p>如果您想实施<code>BackOffPolicy</code>在重试中，您需要创建一个类型为的bean <code>LoadBalancedRetryFactory</code>并覆盖<code>createBackOffPolicy</code>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {
    @Bean
    LoadBalancedRetryFactory retryFactory() {
        return new LoadBalancedRetryFactory() {
            @Override
            public BackOffPolicy createBackOffPolicy(String service) {
                return new ExponentialBackOffPolicy();
            }
        };
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>client</code>在上述示例中，应将其替换为Ribbon客户的名称。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要添加一个或多个<code>RetryListener</code>重试功能的实现，您需要创建一个类型为的bean <code>LoadBalancedRetryListenerFactory</code>然后返回<code>RetryListener</code>您要用于给定服务的数组，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {
    @Bean
    LoadBalancedRetryListenerFactory retryListenerFactory() {
        return new LoadBalancedRetryListenerFactory() {
            @Override
            public RetryListener[] createRetryListeners(String service) {
                return new RetryListener[]{new RetryListener() {
                    @Override
                    public <T, E extends Throwable> boolean open(RetryContext context, RetryCallback<T, E> callback) {
                        //TODO Do you business...
                        return true;
                    }

                    @Override
                     public <T, E extends Throwable> void close(RetryContext context, RetryCallback<T, E> callback, Throwable throwable) {
                        //TODO Do you business...
                    }

                    @Override
                    public <T, E extends Throwable> void onError(RetryContext context, RetryCallback<T, E> callback, Throwable throwable) {
                        //TODO Do you business...
                    }
                }};
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multiple-resttemplate-objects"><a class="anchor" href="#multiple-resttemplate-objects"></a> <a class="link" href="#multiple-resttemplate-objects">3.2.5。多个RestTemplate对象</a></h4>
<div class="paragraph">
<p>如果你想要一个<code>RestTemplate</code>那不是负载均衡的，创建一个<code>RestTemplate</code>豆并注入。访问负载均衡<code>RestTemplate</code> ， 使用<code>@LoadBalanced</code>创建您的限定词<code>@Bean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    RestTemplate loadBalanced() {
        return new RestTemplate();
    }

    @Primary
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

public class MyClass {
@Autowired
private RestTemplate restTemplate;

    @Autowired
    @LoadBalanced
    private RestTemplate loadBalanced;

    public String doOtherStuff() {
        return loadBalanced.getForObject("http://stores/stores", String.class);
    }

    public String doStuff() {
        return restTemplate.getForObject("http://example.com", String.class);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">注意使用<code>@Primary</code>在平原上的注释<code>RestTemplate</code>在前面的示例中进行声明以消除不合格的歧义<code>@Autowired</code>注射。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您看到以下错误<code>java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89</code> ，尝试注入<code>RestOperations</code>或设置<code>spring.aop.proxyTargetClass=true</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="multiple-webclient-objects"><a class="anchor" href="#multiple-webclient-objects"></a> <a class="link" href="#multiple-webclient-objects">3.2.6。多个WebClient对象</a></h4>
<div class="paragraph">
<p>如果你想要一个<code>WebClient</code>那不是负载均衡的，创建一个<code>WebClient</code>豆并注入。访问负载均衡<code>WebClient</code> ， 使用<code>@LoadBalanced</code>创建您的限定词<code>@Bean</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {

    @LoadBalanced
    @Bean
    WebClient.Builder loadBalanced() {
        return WebClient.builder();
    }

    @Primary
    @Bean
    WebClient.Builder webClient() {
        return WebClient.builder();
    }
}

public class MyClass {
    @Autowired
    private WebClient.Builder webClientBuilder;

    @Autowired
    @LoadBalanced
    private WebClient.Builder loadBalanced;

    public Mono<String> doOtherStuff() {
        return loadBalanced.build().get().uri("http://stores/stores")
                        .retrieve().bodyToMono(String.class);
    }

    public Mono<String> doStuff() {
        return webClientBuilder.build().get().uri("http://example.com")
                        .retrieve().bodyToMono(String.class);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="loadbalanced-webclient"><a class="anchor" href="#loadbalanced-webclient"></a> <a class="link" href="#loadbalanced-webclient">3.2.7。Spring WebFlux WebClient作为负载均衡器客户端</a></h4>
<div class="sect4">
<h5 id="webflux-with-reactive-loadbalancer"><a class="anchor" href="#webflux-with-reactive-loadbalancer"></a> <a class="link" href="#webflux-with-reactive-loadbalancer">具有ReactorLoadBalancerExchangeFilterFunction的Spring WebFlux WebClient</a></h5>
<div class="paragraph">
<p><code>WebClient</code>可以配置为使用<code>ReactiveLoadBalancer</code> 。如果您将<a href="#spring-cloud-loadbalancer-starter">Spring Cloud LoadBalancer启动器</a>添加到项目中， <code>ReactorLoadBalancerExchangeFilterFunction</code>是自动配置的，如果<code>spring-webflux</code>在类路径上。以下示例显示了如何配置<code>WebClient</code>在引擎盖下使用无功负载均衡器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyClass {
    @Autowired
    private ReactorLoadBalancerExchangeFilterFunction lbFunction;

    public Mono<String> doOtherStuff() {
        return WebClient.builder().baseUrl("http://stores")
            .filter(lbFunction)
            .build()
            .get()
            .uri("/stores")
            .retrieve()
            .bodyToMono(String.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI需要使用虚拟主机名（即服务名，而不是主机名）。的<code>ReactorLoadBalancer</code>用于创建完整的物理地址。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果你有<code>spring-cloud-netflix-ribbon</code>在你的课堂上<a href="#load-balancer-exchange-filter-function"><code>LoadBalancerExchangeFilterFunction</code></a>默认情况下将使用它来保持向后兼容性。为了能够使用<code>ReactorLoadBalancerExchangeFilterFunction</code> ，设置的值<code>spring.cloud.loadbalancer.ribbon.enabled</code>财产<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="load-balancer-exchange-filter-function"><a class="anchor" href="#load-balancer-exchange-filter-function"></a> <a class="link" href="#load-balancer-exchange-filter-function">带有非反应式负载均衡器客户端的Spring WebFlux WebClient</a></h5>
<div class="paragraph">
<p>如果您的项目中没有<a href="#spring-cloud-loadbalancer-starter">Spring Cloud LoadBalancer启动器</a> ，但是您有spring-cloud-starter-netflix-ribbon，则仍然可以使用<code>WebClient</code>与<code>LoadBalancerClient</code> 。<code>LoadBalancerExchangeFilterFunction</code>将在以下情况下自动配置<code>spring-webflux</code>在类路径上。但是请注意，这是在后台使用非反应性客户端。以下示例显示了如何配置<code>WebClient</code>使用负载均衡器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyClass {
    @Autowired
    private LoadBalancerExchangeFilterFunction lbFunction;

    public Mono<String> doOtherStuff() {
        return WebClient.builder().baseUrl("http://stores")
            .filter(lbFunction)
            .build()
            .get()
            .uri("/stores")
            .retrieve()
            .bodyToMono(String.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI需要使用虚拟主机名（即服务名，而不是主机名）。的<code>LoadBalancerClient</code>用于创建完整的物理地址。</p>
</div>
<div class="paragraph">
<p>警告：现在不建议使用此方法。我们建议您将<a href="#webflux-with-reactive-loadbalancer">WebFlux与电抗性负载平衡器一起</a>使用。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ignore-network-interfaces"><a class="anchor" href="#ignore-network-interfaces"></a> <a class="link" href="#ignore-network-interfaces">3.2.8。忽略网络接口</a></h4>
<div class="paragraph">
<p>有时，忽略某些命名的网络接口很有用，以便可以将它们从服务发现注册中排除（例如，在Docker容器中运行时）。可以设置正则表达式列表以使所需的网络接口被忽略。以下配置忽略了<code>docker0</code>接口和所有以开头的接口<code>veth</code> ：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    inetutils:
      ignoredInterfaces:
        - docker0
        - veth.*</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过使用正则表达式列表来强制仅使用指定的网络地址，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre>spring:
  cloud:
    inetutils:
      preferredNetworks:
        - 192.168
        - 10.0</pre>
</div>
</div>
<div class="paragraph">
<p>您也可以只使用站点本地地址，如以下示例所示：.application.yml</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring:
  cloud:
    inetutils:
      useOnlySiteLocalInterfaces: true</pre>
</div>
</div>
<div class="paragraph">
<p>有关构成站点本地地址的详细信息，请参见<a href="https://docs.oracle.com/javase/8/docs/api/java/net/Inet4Address.html#isSiteLocalAddress--">Inet4Address.html.isSiteLocalAddress（）</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="http-clients"><a class="anchor" href="#http-clients"></a> <a class="link" href="#http-clients">3.2.9。HTTP客户端工厂</a></h4>
<div class="paragraph">
<p>Spring Cloud Commons提供了用于创建两个Apache HTTP客户端的bean（ <code>ApacheHttpClientFactory</code> ）和确定的HTTP客户端（ <code>OkHttpClientFactory</code> ）。的<code>OkHttpClientFactory</code>仅当OK HTTP jar位于类路径上时，才会创建bean。另外，Spring Cloud Commons提供了用于创建两个客户端都使用的连接管理器的bean： <code>ApacheHttpClientConnectionManagerFactory</code>用于Apache HTTP客户端和<code>OkHttpClientConnectionPoolFactory</code>确定HTTP客户端。如果要自定义在下游项目中创建HTTP客户端的方式，则可以提供自己的这些Bean实现。另外，如果您提供类型为的Bean <code>HttpClientBuilder</code>要么<code>OkHttpClient.Builder</code> ，默认工厂将这些构建器用作返回到下游项目的构建器的基础。您还可以通过设置禁用这些Bean的创建<code>spring.cloud.httpclientfactories.apache.enabled</code>要么<code>spring.cloud.httpclientfactories.ok.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="enabled-features"><a class="anchor" href="#enabled-features"></a> <a class="link" href="#enabled-features">3.2.10。启用的功能</a></h4>
<div class="paragraph">
<p>Spring Cloud Commons提供了一个<code>/features</code>执行器端点。该端点返回类路径上可用的功能以及是否已启用它们。返回的信息包括功能类型，名称，版本和供应商。</p>
</div>
<div class="sect4">
<h5 id="feature-types"><a class="anchor" href="#feature-types"></a> <a class="link" href="#feature-types">功能类型</a></h5>
<div class="paragraph">
<p>“功能”有两种类型：抽象和命名。</p>
</div>
<div class="paragraph">
<p>抽象功能是定义接口或抽象类并创建实现的功能，例如<code>DiscoveryClient</code> ， <code>LoadBalancerClient</code> ， 要么<code>LockService</code> 。抽象类或接口用于在上下文中查找该类型的Bean。显示的版本是<code>bean.getClass().getPackage().getImplementationVersion()</code> 。</p>
</div>
<div class="paragraph">
<p>命名功能是没有实现的特定类的功能，例如“ Circuit Breaker”，“ API Gateway”，“ Spring Cloud Bus”等。这些功能需要名称和Bean类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="declaring-features"><a class="anchor" href="#declaring-features"></a> <a class="link" href="#declaring-features">声明功能</a></h5>
<div class="paragraph">
<p>任何模块都可以声明任意数量的<code>HasFeature</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public HasFeatures commonsFeatures() {
  return HasFeatures.abstractFeatures(DiscoveryClient.class, LoadBalancerClient.class);
}

@Bean
public HasFeatures consulFeatures() {
  return HasFeatures.namedFeatures(
    new NamedFeature("Spring Cloud Bus", ConsulBusAutoConfiguration.class),
    new NamedFeature("Circuit Breaker", HystrixCommandAspect.class));
}

@Bean
HasFeatures localFeatures() {
  return HasFeatures.builder()
      .abstractFeature(Foo.class)
      .namedFeature(new NamedFeature("Bar Feature", Bar.class))
      .abstractFeature(Baz.class)
      .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些豆中的每一个都应放入适当保护的容器中<code>@Configuration</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-compatibility-verification"><a class="anchor" href="#spring-cloud-compatibility-verification"></a> <a class="link" href="#spring-cloud-compatibility-verification">3.2.11。Spring Cloud兼容性验证</a></h4>
<div class="paragraph">
<p>由于某些用户在设置Spring Cloud应用程序时遇到问题，我们决定添加兼容性验证机制。如果您当前的设置与Spring Cloud要求不兼容，它会中断，并附上一份报告，显示出确切的问题。</p>
</div>
<div class="paragraph">
<p>目前，我们验证将哪个版本的Spring Boot添加到您的类路径中。</p>
</div>
<div class="paragraph">
<p>报告范例</p>
</div>
<div class="listingblock">
<div class="content">
<pre>***************************
APPLICATION FAILED TO START
***************************

Description:

Your project setup is incompatible with our requirements due to following reasons:

- Spring Boot [2.1.0.RELEASE] is not compatible with this Spring Cloud release train


Action:

Consider applying the following actions:

- Change Spring Boot version to one of the following versions [1.2.x, 1.3.x] .
You can find the latest Spring Boot versions here [https://spring.io/projects/spring-boot#learn].
If you want to learn more about the Spring Cloud Release train compatibility, you can visit this page [https://spring.io/projects/spring-cloud#overview] and check the [Release Trains] section.</pre>
</div>
</div>
<div class="paragraph">
<p>为了禁用此功能，请设置<code>spring.cloud.compatibility-verifier.enabled</code>至<code>false</code> 。如果您想覆盖兼容的Spring Boot版本，只需设置<code>spring.cloud.compatibility-verifier.compatible-boot-versions</code>属性，以逗号分隔的兼容Spring Boot版本列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-loadbalancer"><a class="anchor" href="#spring-cloud-loadbalancer"></a> <a class="link" href="#spring-cloud-loadbalancer">3.3。Spring Cloud负载均衡器</a></h3>
<div class="paragraph">
<p>Spring Cloud提供了自己的客户端负载均衡器抽象和实现。对于负载平衡机制， <code>ReactiveLoadBalancer</code>接口已添加，并为其提供了基于循环的实现。为了让实例从反应式中选择<code>ServiceInstanceListSupplier</code>用来。目前，我们支持基于服务发现的<code>ServiceInstanceListSupplier</code>它使用类路径中可用的<a href="#discovery-client">发现客户端</a>从服务发现中检索可用实例。</p>
</div>
<div class="sect3">
<h4 id="spring-cloud-loadbalancer-integrations"><a class="anchor" href="#spring-cloud-loadbalancer-integrations"></a> <a class="link" href="#spring-cloud-loadbalancer-integrations">3.3.1。Spring Cloud LoadBalancer集成</a></h4>
<div class="paragraph">
<p>为了方便使用Spring Cloud LoadBalancer，我们提供了<code>ReactorLoadBalancerExchangeFilterFunction</code>可以与<code>WebClient</code>和<code>BlockingLoadBalancerClient</code>与<code>RestTemplate</code> 。您可以在以下各节中查看更多信息和用法示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#rest-template-loadbalancer-client">Spring RestTemplate作为负载均衡器客户端</a></p>
</li>
<li>
<p><a href="#webclinet-loadbalancer-client">Spring WebClient作为负载均衡器客户端</a></p>
</li>
<li>
<p><a href="#webflux-with-reactive-loadbalancer">Spring WebFlux WebClient与<code>ReactorLoadBalancerExchangeFilterFunction</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-loadbalancer-caching"><a class="anchor" href="#spring-cloud-loadbalancer-caching"></a> <a class="link" href="#spring-cloud-loadbalancer-caching">3.3.2。Spring Cloud LoadBalancer缓存</a></h4>
<div class="paragraph">
<p>除了基本<code>ServiceInstanceListSupplier</code>通过实例检索实例的实现<code>DiscoveryClient</code>每次必须选择一个实例时，我们都会提供两个缓存实现。</p>
</div>
<div class="sect4">
<h5 id="caffeine-backed-loadbalancer-cache-implementation"><a class="anchor" href="#caffeine-backed-loadbalancer-cache-implementation"></a><a class="link" href="#caffeine-backed-loadbalancer-cache-implementation"></a> <a href="https://github.com/ben-manes/caffeine">咖啡因</a>支持的LoadBalancer缓存实现</h5>
<div class="paragraph">
<p>如果你有<code>com.github.ben-manes.caffeine:caffeine</code>在类路径中，将使用基于咖啡因的实现。有关如何配置它的信息，请参见<a href="#loadbalancer-cache-configuration">LoadBalancerCacheConfiguration</a>部分。</p>
</div>
<div class="paragraph">
<p>如果您使用的是Caffeine，则还可以通过将自己的<a href="https://static.javadoc.io/com.github.ben-manes.caffeine/caffeine/2.2.2/com/github/benmanes/caffeine/cache/CaffeineSpec.html">Caffeine规范</a>传递给<code>spring.cloud.loadbalancer.cache.caffeine.spec</code>属性。</p>
</div>
<div class="paragraph">
<p>警告：通过您自己的Caffeine规范将覆盖所有其他LoadBalancerCache设置，包括<a href="#loadbalancer-cache-configuration">常规LoadBalancerCache配置</a>字段，例如<code>ttl</code>和<code>capacity</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="default-loadbalancer-cache-implementation"><a class="anchor" href="#default-loadbalancer-cache-implementation"></a> <a class="link" href="#default-loadbalancer-cache-implementation">默认的LoadBalancer缓存实现</a></h5>
<div class="paragraph">
<p>如果您在类路径中没有咖啡因， <code>DefaultLoadBalancerCache</code> ，它会自动提供<code>spring-cloud-starter-loadbalancer</code> ， 将会被使用。有关如何配置它的信息，请参见<a href="#loadbalancer-cache-configuration">LoadBalancerCacheConfiguration</a>部分。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">要使用咖啡因代替默认缓存，请添加<code>com.github.ben-manes.caffeine:caffeine</code>对类路径的依赖。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="loadbalancer-cache-configuration"><a class="anchor" href="#loadbalancer-cache-configuration"></a> <a class="link" href="#loadbalancer-cache-configuration">LoadBalancer缓存配置</a></h5>
<div class="paragraph">
<p>您可以设置自己的<code>ttl</code>值（写操作后条目应过期的时间），表示为<code>Duration</code> ，通过<code>String</code>符合<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config-conversion-duration">Spring Boot <code>String</code>至<code>Duration</code>转换器语法</a> 。作为的价值<code>spring.cloud.loadbalancer.cache.ttl</code>属性。您还可以通过设置以下参数的值来设置自己的LoadBalancer缓存初始容量<code>spring.cloud.loadbalancer.cache.capacity</code>属性。</p>
</div>
<div class="paragraph">
<p>默认设置包括<code>ttl</code>设置为30秒，默认<code>initialCapacity</code>是<code>256</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以通过设置的值来完全禁用loadBalancer缓存<code>spring.cloud.loadbalancer.cache.enabled</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">尽管基本的非缓存实现对于原型开发和测试很有用，但它的效率要比缓存版本低得多，因此我们建议始终在生产中使用缓存版本。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-loadbalancer-starter"><a class="anchor" href="#spring-cloud-loadbalancer-starter"></a> <a class="link" href="#spring-cloud-loadbalancer-starter">3.3.3。Spring Cloud LoadBalancer入门</a></h4>
<div class="paragraph">
<p>我们还提供了一个启动程序，使您可以轻松地在Spring Boot应用程序中添加Spring Cloud LoadBalancer。为了使用它，只需添加<code>org.springframework.cloud:spring-cloud-starter-loadbalancer</code>到构建文件中的Spring Cloud依赖项。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud LoadBalancer入门版包括<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html">Spring Boot Caching</a>和<a href="https://github.com/stoyanr">Evictor</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果类路径同时具有Ribbon和Spring Cloud LoadBalancer，则为了保持向后兼容性，默认情况下将使用基于Ribbon的实现。为了切换到在后台使用Spring Cloud LoadBalancer，请确保设置了属性<code>spring.cloud.loadbalancer.ribbon.enabled</code>至<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="passing-your-own-spring-cloud-loadbalancer-configuration"><a class="anchor" href="#passing-your-own-spring-cloud-loadbalancer-configuration"></a> <a class="link" href="#passing-your-own-spring-cloud-loadbalancer-configuration">3.3.4。传递自己的Spring Cloud LoadBalancer配置</a></h4>
<div class="paragraph">
<p>您也可以使用<code>@LoadBalancerClient</code>批注传递您自己的负载均衡器客户端配置，并传递负载均衡器客户端的名称和配置类，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@LoadBalancerClient(value = "stores", configuration = StoresLoadBalancerClientConfiguration.class)
public class MyConfiguration {

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以通过以下方式将多个配置（对于一个以上的负载均衡器客户端）一起传递： <code>@LoadBalancerClients</code>注释，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@LoadBalancerClients({@LoadBalancerClient(value = "stores", configuration = StoresLoadBalancerClientConfiguration.class), @LoadBalancerClient(value = "customers", configuration = CustomersLoadBalancerClientConfiguration.class)})
public class MyConfiguration {

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-circuit-breaker"><a class="anchor" href="#spring-cloud-circuit-breaker"></a> <a class="link" href="#spring-cloud-circuit-breaker">3.4。spring-cloud-circuitbreaker</a></h3>
<div class="sect3">
<h4 id="introduction"><a class="anchor" href="#introduction"></a> <a class="link" href="#introduction">3.4.1。介绍</a></h4>
<div class="paragraph">
<p>Spring Cloud断路器提供了不同断路器实现之间的抽象。它提供了可在您的应用程序中使用的一致的API，使开发人员可以选择最适合您的应用程序需求的断路器实现。</p>
</div>
<div class="sect4">
<h5 id="supported-implementations"><a class="anchor" href="#supported-implementations"></a> <a class="link" href="#supported-implementations">支持的实施</a></h5>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></p>
</li>
<li>
<p><a href="https://github.com/resilience4j/resilience4j">弹性4J</a></p>
</li>
<li>
<p><a href="https://github.com/alibaba/Sentinel">哨兵</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-retry">春季重试</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-concepts"><a class="anchor" href="#core-concepts"></a> <a class="link" href="#core-concepts">3.4.2。核心概念</a></h4>
<div class="paragraph">
<p>要在您的代码中创建断路器，您可以使用<code>CircuitBreakerFactory</code> API。当您在类路径中包含Spring Cloud Circuit Breaker入门程序时，将自动为您创建实现此API的bean。下面给出了一个使用此API的非常简单的示例</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public static class DemoControllerService {
    private RestTemplate rest;
    private CircuitBreakerFactory cbFactory;

    public DemoControllerService(RestTemplate rest, CircuitBreakerFactory cbFactory) {
        this.rest = rest;
        this.cbFactory = cbFactory;
    }

    public String slow() {
        return cbFactory.create("slow").run(() -> rest.getForObject("/slow", String.class), throwable -> "fallback");
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>CircuitBreakerFactory.create</code> API将创建一个名为的类的实例<code>CircuitBreaker</code> 。的<code>run</code>方法需要<code>Supplier</code>和一个<code>Function</code> 。的<code>Supplier</code>是要包装在断路器中的代码。的<code>Function</code>是断路器跳闸时将执行的故障预置。该函数将被传递<code>Throwable</code>导致触发后备广告。如果不想提供回退，则可以选择排除回退。</p>
</div>
<div class="sect4">
<h5 id="circuit-breakers-in-reactive-code"><a class="anchor" href="#circuit-breakers-in-reactive-code"></a> <a class="link" href="#circuit-breakers-in-reactive-code">无功代码断路器</a></h5>
<div class="paragraph">
<p>如果Project Reactor在类路径上，那么您也可以使用<code>ReactiveCircuitBreakerFactory</code>为您的反应式代码。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public static class DemoControllerService {
    private ReactiveCircuitBreakerFactory cbFactory;
    private WebClient webClient;


    public DemoControllerService(WebClient webClient, ReactiveCircuitBreakerFactory cbFactory) {
        this.webClient = webClient;
        this.cbFactory = cbFactory;
    }

    public Mono<String> slow() {
        return webClient.get().uri("/slow").retrieve().bodyToMono(String.class).transform(
        it -> cbFactory.create("slow").run(it, throwable -> return Mono.just("fallback")));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>ReactiveCircuitBreakerFactory.create</code> API将创建一个名为的类的实例<code>ReactiveCircuitBreaker</code> 。的<code>run</code>方法需要<code>Mono</code>要么<code>Flux</code>并将其包裹在断路器中。您可以选择分析后备<code>Function</code>如果断路器跳闸并且将通过断路器，则将调用该方法<code>Throwable</code>导致失败。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuration"><a class="anchor" href="#configuration"></a> <a class="link" href="#configuration">3.4.3。组态</a></h4>
<div class="paragraph">
<p>您可以通过创建以下类型的bean来配置断路器<code>Customizer</code> 。的<code>Customizer</code>接口有一个称为<code>customize</code>这需要<code>Object</code>自定义。</p>
</div>
<div class="paragraph">
<p>有关如何自定义给定实现的详细信息，请参见下面的链接</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../../../spring-cloud-netflix/reference/html/#_circuit_breaker_spring_cloud_circuit_breaker_with_hystrix">Hystrix</a></p>
</li>
<li>
<p><a href="../../../spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html#_configuring_resilience4j_circuit_breakers">弹性4J</a></p>
</li>
<li>
<p><a href="../../../spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html#_configuring_sentinel_circuit_breakers">哨兵</a></p>
</li>
<li>
<p><a href="../../../spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html#_configuring_spring_retry_circuit_breakers">春季重试</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties"><a class="anchor" href="#configuration-properties"></a> <a class="link" href="#configuration-properties">3.5。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与Spring Cloud Commons相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-config"><a class="anchor" href="#spring-cloud-config"></a> <a class="link" href="#spring-cloud-config">4。Spring Cloud Config</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="paragraph">
<p>Spring Cloud Config为分布式系统中的外部化配置提供服务器端和客户端支持。使用Config Server，您可以在中心位置管理所有环境中应用程序的外部属性。客户端和服务器上的概念与Spring完全相同<code>Environment</code>和<code>PropertySource</code>抽象，因此它们非常适合Spring应用程序，但可以与以任何语言运行的任何应用程序一起使用。在应用程序从开发人员到测试人员再到生产人员的整个部署管道中进行移动时，您可以管理这些环境之间的配置，并确保应用程序具有它们迁移时所需的一切。服务器存储后端的默认实现使用git，因此它轻松支持带标签的配置环境版本，并且可以通过各种工具来访问这些内容来管理内容。添加替代实现并将其插入Spring配置很容易。</p>
</div>
<div class="sect2">
<h3 id="quick-start"><a class="anchor" href="#quick-start"></a> <a class="link" href="#quick-start">4.1。快速开始</a></h3>
<div class="paragraph">
<p>该快速入门介绍了如何同时使用Spring Cloud Config Server的服务器和客户端。</p>
</div>
<div class="paragraph">
<p>首先，启动服务器，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd spring-cloud-config-server
$ ../mvnw spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p>该服务器是Spring Boot应用程序，因此，如果愿意，可以从IDE运行它（主类是<code>ConfigServerApplication</code> ）。</p>
</div>
<div class="paragraph">
<p>接下来尝试一个客户端，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8888/foo/development
{"name":"foo","label":"master","propertySources":[
  {"name":"https://github.com/scratches/config-repo/foo-development.properties","source":{"bar":"spam"}},
  {"name":"https://github.com/scratches/config-repo/foo.properties","source":{"foo":"bar"}}
]}</pre>
</div>
</div>
<div class="paragraph">
<p>定位属性源的默认策略是克隆git存储库（位于<code>spring.cloud.config.server.git.uri</code> ）并使用它初始化一个迷你<code>SpringApplication</code> 。迷你应用程序的<code>Environment</code>用于枚举属性源并将其发布在JSON端点上。</p>
</div>
<div class="paragraph">
<p>HTTP服务具有以下形式的资源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties</pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>application</code>作为注入<code>spring.config.name</code>在里面<code>SpringApplication</code> （通常是<code>application</code>在常规的Spring Boot应用中）， <code>profile</code>是活动配置文件（或属性的逗号分隔列表），并且<code>label</code>是可选的git标签（默认为<code>master</code> ）</p>
</div>
<div class="paragraph">
<p>Spring Cloud Config Server从各种来源为远程客户端提取配置。以下示例从git存储库（必须提供）中获取配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他来源包括任何与JDBC兼容的数据库，Subversion，Hashicorp Vault，Credhub和本地文件系统。</p>
</div>
<div class="sect3">
<h4 id="client-side-usage"><a class="anchor" href="#client-side-usage"></a> <a class="link" href="#client-side-usage">4.1.1。客户端使用</a></h4>
<div class="paragraph">
<p>要在应用程序中使用这些功能，您可以将其构建为依赖于spring-cloud-config-client的Spring Boot应用程序（例如，请参阅config-client或示例应用程序的测试用例）。添加依赖项最方便的方法是使用Spring Boot启动器<code>org.springframework.cloud:spring-cloud-starter-config</code> 。还有一个父pom和BOM（ <code>spring-cloud-starter-parent</code> ）（适用于Maven用户）和Spring IO版本管理属性文件（适用于Gradle和Spring CLI用户）。以下示例显示了典型的Maven配置：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>{spring-boot-docs-version}</version>
    <relativePath /> <!-- lookup parent from repository -->
</parent>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>{spring-cloud-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

<!-- repositories also needed for snapshots and milestones --></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以创建一个标准的Spring Boot应用程序，例如以下HTTP服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</pre>
</div>
</div>
<div class="paragraph">
<p>当此HTTP服务器运行时，它将从端口8888上的默认本地配置服务器（如果正在运行）中获取外部配置。要修改启动行为，可以使用以下命令更改配置服务器的位置<code>bootstrap.properties</code> （相似<code>application.properties</code>但适用于应用程序上下文的引导阶段），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.config.uri: http://myconfigserver.com</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，如果未设置应用程序名称， <code>application</code>将会被使用。要修改名称，可以将以下属性添加到<code>bootstrap.properties</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.application.name: myapp</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置属性时<code>${spring.application.name}</code>不要在您的应用名称前加上保留字<code>application-</code>以防止解决正确的属性源的问题。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>引导程序属性显示在<code>/env</code>端点作为高优先级属性源，如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/env
{
  "profiles":[],
  "configService:https://github.com/spring-cloud-samples/config-repo/bar.properties":{"foo":"bar"},
  "servletContextInitParams":{},
  "systemProperties":{...},
  ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>属性来源称为<code>``configService:<URL of remote repository>/<file name></code>包含<code>foo</code>值为的属性<code>bar</code>并且是最高优先级。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">属性源名称中的URL是git存储库，而不是配置服务器URL。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-config-server"><a class="anchor" href="#spring-cloud-config-server"></a> <a class="link" href="#spring-cloud-config-server">4.2。Spring Cloud Config服务器</a></h3>
<div class="paragraph">
<p>Spring Cloud Config Server为外部配置（名称-值对或等效的YAML内容）提供了一个基于HTTP资源的API。该服务器可通过使用以下命令嵌入到Spring Boot应用程序中： <code>@EnableConfigServer</code>注解。因此，以下应用程序是配置服务器：</p>
</div>
<div class="listingblock">
<div class="title">ConfigServer.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableConfigServer
public class ConfigServer {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServer.class, args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>像所有Spring Boot应用程序一样，它默认在端口8080上运行，但是您可以通过各种方式将其切换到更传统的端口8888。最简单的方法是设置启动默认配置存储库，方法是<code>spring.config.name=configserver</code> （有一个<code>configserver.yml</code>在Config Server jar中）。另一种是使用自己的<code>application.properties</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.port: 8888
spring.cloud.config.server.git.uri: file://${user.home}/config-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>${user.home}/config-repo</code>是一个包含YAML和属性文件的git存储库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在Windows上，如果文件URL带有驱动器前缀，则绝对需要一个额外的“ /”（例如， <code><a href="file:///${user.home}/config-repo" class="bare">/${user.home}/config-repo</a></code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下清单显示了在前面的示例中创建git存储库的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cd $HOME
$ mkdir config-repo
$ cd config-repo
$ git init .
$ echo info.foo: bar > application.properties
$ git add -A .
$ git commit -m "Add application.properties"</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">将本地文件系统用于git存储库仅用于测试。您应该使用服务器在生产环境中托管配置存储库。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果仅在其中存储文本文件，则配置存储库的初始克隆可以快速高效。如果存储二进制文件（尤其是大文件），则可能会在首次配置请求时遇到延迟，或者在服务器中遇到内存不足错误。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="environment-repository"><a class="anchor" href="#environment-repository"></a> <a class="link" href="#environment-repository">4.2.1。环境资料库</a></h4>
<div class="paragraph">
<p>您应该在哪里存储配置服务器的配置数据？控制这种行为的策略是<code>EnvironmentRepository</code> ，服务<code>Environment</code>对象。这个<code>Environment</code>是春季的域名的浅表副本<code>Environment</code> （包含<code>propertySources</code>作为主要功能）。的<code>Environment</code>资源由三个变量参数化：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{application}</code> ，它映射到<code>spring.application.name</code>在客户端。</p>
</li>
<li>
<p><code>{profile}</code> ，它映射到<code>spring.profiles.active</code>在客户端（以逗号分隔的列表）上。</p>
</li>
<li>
<p><code>{label}</code> ，这是服务器端功能，标记了一组“版本化”的配置文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>仓库实现通常表现为类似于Spring Boot应用程序，从<code>spring.config.name</code>等于<code>{application}</code>参数，以及<code>spring.profiles.active</code>等于<code>{profiles}</code>参数。配置文件的优先规则也与常规Spring Boot应用程序中的规则相同：活动配置文件的优先级高于默认设置，如果有多个配置文件，则最后一个优先（类似于将条目添加到默认配置）。 <code>Map</code> ）。</p>
</div>
<div class="paragraph">
<p>以下示例客户端应用程序具有此引导程序配置：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  application:
    name: foo
  profiles:
    active: dev,mysql</code></pre>
</div>
</div>
<div class="paragraph">
<p>（与Spring Boot应用程序一样，这些属性也可以由环境变量或命令行参数设置）。</p>
</div>
<div class="paragraph">
<p>如果存储库基于文件，则服务器将创建一个<code>Environment</code>从<code>application.yml</code> （在所有客户之间共享）和<code>foo.yml</code> （与<code>foo.yml</code>优先）。如果YAML文件中包含指向Spring配置文件的文档，则将以更高的优先级应用这些文件（按列出的配置文件的顺序）。如果存在特定于配置文件的YAML（或属性）文件，这些文件也将以比默认文件更高的优先级应用。较高的优先级会转化为<code>PropertySource</code>在前面列出的<code>Environment</code> 。（这些规则适用于独立的Spring Boot应用程序。）</p>
</div>
<div class="paragraph">
<p>您可以将spring.cloud.config.server.accept-empty设置为false，以便在未找到应用程序的情况下Server返回HTTP 404状态。默认情况下，此标志设置为true。</p>
</div>
<div class="sect4">
<h5 id="git-backend"><a class="anchor" href="#git-backend"></a> <a class="link" href="#git-backend">Git后端</a></h5>
<div class="paragraph">
<p>默认实现<code>EnvironmentRepository</code>使用Git后端，这对于管理升级和物理环境以及审核更改非常方便。要更改存储库的位置，您可以设置<code>spring.cloud.config.server.git.uri</code> Config Server中的配置属性（例如<code>application.yml</code> ）。如果您使用<code>file:</code>前缀，它应该在本地存储库中工作，以便无需服务器即可快速轻松地开始使用。但是，在这种情况下，服务器直接在本地存储库上运行而无需克隆它（如果它不是裸露的，这并不重要，因为Config Server从不对“远程”存储库进行更改）。要扩展Config Server并使其高度可用，您需要使服务器的所有实例都指向同一存储库，因此仅共享文件系统可以工作。即使在这种情况下，最好还是使用<code>ssh:</code>共享文件系统存储库的协议，以便服务器可以克隆它并将本地工作副本用作缓存。</p>
</div>
<div class="paragraph">
<p>此存储库实现映射了<code>{label}</code> git标签（提交ID，分支名称或标签）的HTTP资源的参数。如果git分支或标记名称包含斜杠（ <code>/</code> ），则应使用特殊字符串在HTTP URL中指定标签<code>(_)</code> （以避免与其他URL路径产生歧义）。例如，如果标签是<code>foo/bar</code> ，替换斜杠将产生以下标签： <code>foo(_)bar</code> 。包含特殊字符串<code>(_)</code>也可以应用于<code>{application}</code>参数。如果您使用命令行客户端（例如curl），请注意URL中的括号-您应使用单引号（''）将其从外壳中移出。</p>
</div>
<div class="sect5">
<h6 id="skipping-ssl-certificate-validation"><a class="anchor" href="#skipping-ssl-certificate-validation"></a> <a class="link" href="#skipping-ssl-certificate-validation">跳过SSL证书验证</a></h6>
<div class="paragraph">
<p>可以通过设置以下选项来禁用配置服务器对Git服务器的SSL证书的验证： <code>git.skipSslValidation</code>财产<code>true</code> （默认为<code>false</code> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://example.com/my/repo
          skipSslValidation: true</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="setting-http-connection-timeout"><a class="anchor" href="#setting-http-connection-timeout"></a> <a class="link" href="#setting-http-connection-timeout">设置HTTP连接超时</a></h6>
<div class="paragraph">
<p>您可以配置配置服务器将等待获取HTTP连接的时间（以秒为单位）。使用<code>git.timeout</code>属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://example.com/my/repo
          timeout: 4</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="placeholders-in-git-uri"><a class="anchor" href="#placeholders-in-git-uri"></a> <a class="link" href="#placeholders-in-git-uri">Git URI中的占位符</a></h6>
<div class="paragraph">
<p>Spring Cloud Config Server支持带有占位符的git存储库URL <code>{application}</code>和<code>{profile}</code> （和<code>{label}</code> （如果需要），但请记住，无论如何该标签都将用作git标签）。因此，您可以通过使用类似于以下内容的结构来支持“每个应用程序一个存储库”策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/{application}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用类似的模式来支持“每个配置文件一个存储库”策略， <code>{profile}</code> 。</p>
</div>
<div class="paragraph">
<p>此外，在您的代码中使用特殊字符串“（_）” <code>{application}</code>参数可以启用对多个组织的支持，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/{application}</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>{application}</code>在请求时以以下格式提供： <code>organization(_)application</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="pattern-matching-and-multiple-repositories"><a class="anchor" href="#pattern-matching-and-multiple-repositories"></a> <a class="link" href="#pattern-matching-and-multiple-repositories">模式匹配和多个存储库</a></h6>
<div class="paragraph">
<p>Spring Cloud Config还通过在应用程序和配置文件名称上进行模式匹配来支持更复杂的需求。模式格式是逗号分隔的列表<code>{application}/{profile}</code>带通配符的名称（请注意，以通配符开头的模式可能需要加引号），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            simple: https://github.com/simple/config-repo
            special:
              pattern: special*/dev*,*special*/dev*
              uri: https://github.com/special/config-repo
            local:
              pattern: local*
              uri: file:/home/configsvc/config-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>{application}/{profile}</code>与任何模式都不匹配，它使用在下定义的默认URI <code>spring.cloud.config.server.git.uri</code> 。在上面的示例中，对于“简单”存储库，模式为<code>simple/*</code> （它仅与一个名为<code>simple</code>在所有配置文件中）。“本地”存储库匹配所有以以下名称开头的应用程序名称<code>local</code>在所有配置文件中（ <code>/*</code>后缀会自动添加到没有配置文件匹配器的任何模式中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">仅当要设置的唯一属性是URI时，才能使用“简单”示例中使用的“单线”快捷方式。如果您需要设置其他任何内容（凭证，模式等），则需要使用完整表格。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>pattern</code>回购中的属性实际上是一个数组，因此您可以使用YAML数组（或<code>[0]</code> ， <code>[1]</code>等属性文件中的后缀）以绑定到多个模式。如果要运行具有多个配置文件的应用程序，则可能需要这样做，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          repos:
            development:
              pattern:
                - '*/development'
                - '*/staging'
              uri: https://github.com/development/config-repo
            staging:
              pattern:
                - '*/qa'
                - '*/production'
              uri: https://github.com/staging/config-repo</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud猜测包含未以结尾的配置文件的模式<code>*</code>表示您实际上要匹配以该模式开头的配置文件列表（因此<code>*/staging</code>是的快捷方式<code>["*/staging", "*/staging,*"]</code> ， 等等）。例如，这很常见，例如，您需要在本地的“开发”配置文件中运行应用程序，而在远程的“云”配置文件中运行。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每个存储库还可以选择将配置文件存储在子目录中，并且可以将搜索这些目录的模式指定为<code>searchPaths</code> 。以下示例在顶层显示了一个配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: foo,bar*</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，服务器在顶层和服务器中搜索配置文件。 <code>foo/</code>子目录，以及名称以“。”开头的任何子目录<code>bar</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，第一次请求配置时，服务器会克隆远程存储库。可以将服务器配置为在启动时克隆存储库，如以下顶级示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          repos:
            team-a:
                pattern: team-a-*
                cloneOnStart: true
                uri: https://git/team-a/config-repo.git
            team-b:
                pattern: team-b-*
                cloneOnStart: false
                uri: https://git/team-b/config-repo.git
            team-c:
                pattern: team-c-*
                uri: https://git/team-a/config-repo.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，服务器在接受任何请求之前会在启动时克隆team-a的config-repo。在请求从存储库进行配置之前，不会克隆所有其他存储库。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置要在Config Server启动时克隆的存储库有助于在Config Server启动时快速识别配置错误的配置源（例如无效的存储库URI）。用<code>cloneOnStart</code>如果未为配置源启用配置服务器，则配置服务器可能会以配置错误或无效的配置源成功启动，并且直到应用程序从该配置源请求配置时才检测到错误。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="authentication"><a class="anchor" href="#authentication"></a> <a class="link" href="#authentication">认证方式</a></h6>
<div class="paragraph">
<p>要在远程存储库上使用HTTP基本身份验证，请添加<code>username</code>和<code>password</code>分别显示属性（不在URL中），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          username: trolley
          password: strongpassword</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不使用HTTPS和用户凭据，则将密钥存储在默认目录中时，SSH也应立即可用（ <code>~/.ssh</code> ），并且URI指向SSH位置，例如<code>git@github.com:configuration/cloud-configuration</code> 。Git服务器的条目必须出现在<code>~/.ssh/known_hosts</code>文件，它在<code>ssh-rsa</code>格式。其他格式（例如<code>ecdsa-sha2-nistp256</code> ）不受支持。为避免意外，您应确保在<code>known_hosts</code> Git服务器的文件，并与您提供给配置服务器的URL匹配。如果您在网址中使用主机名，则希望在主机名中完全包含该主机名（而不是IP）。 <code>known_hosts</code>文件。使用JGit访问存储库，因此您找到的任何文档都应该适用。可以在以下位置设置HTTPS代理设置<code>~/.git/config</code>或（与其他任何JVM进程相同）具有系统属性（ <code>-Dhttps.proxyHost</code>和<code>-Dhttps.proxyPort</code> ）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果你不知道你在哪里<code>~/.git</code>目录是，使用<code>git config --global</code>操作设置（例如， <code>git config --global http.sslVerify false</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="authentication-with-aws-codecommit"><a class="anchor" href="#authentication-with-aws-codecommit"></a> <a class="link" href="#authentication-with-aws-codecommit">使用AWS CodeCommit进行身份验证</a></h6>
<div class="paragraph">
<p>Spring Cloud Config Server还支持<a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit</a>身份验证。从命令行使用Git时，AWS CodeCommit使用身份验证帮助程序。该帮助程序未与JGit库一起使用，因此，如果Git URI与AWS CodeCommit模式匹配，则会为AWS CodeCommit创建一个JGit CredentialProvider。AWS CodeCommit URI遵循此模式：// git-codecommit。$ {AWS_REGION} .amazonaws.com / $ {repopath}。</p>
</div>
<div class="paragraph">
<p>如果您提供带有AWS CodeCommit URI的用户名和密码，则它们必须是提供对存储库的访问权的<a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html">AWS accessKeyId和secretAccessKey</a> 。如果您未指定用户名和密码，则使用<a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html">AWS Default Credential Provider链</a>检索accessKeyId和secretAccessKey。</p>
</div>
<div class="paragraph">
<p>如果您的Git URI与CodeCommit URI模式（如前所示）匹配，则必须在用户名和密码或默认凭据提供程序链支持的位置之一中提供有效的AWS凭据。AWS EC2实例可以将<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html">IAM角色用于EC2实例</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>aws-java-sdk-core</code> jar是可选的依赖项。如果<code>aws-java-sdk-core</code> jar不在您的类路径上，无论git服务器URI如何，都不会创建AWS Code Commit凭证提供程序。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="authentication-with-google-cloud-source"><a class="anchor" href="#authentication-with-google-cloud-source"></a> <a class="link" href="#authentication-with-google-cloud-source">使用Google Cloud Source进行身份验证</a></h6>
<div class="paragraph">
<p>Spring Cloud Config Server还支持针对<a href="https://cloud.google.com/source-repositories/">Google Cloud Source</a>存储库进行身份验证。</p>
</div>
<div class="paragraph">
<p>如果您的Git URI使用<code>http</code>要么<code>https</code>协议，域名为<code>source.developers.google.com</code> ，将使用Google Cloud Source凭据提供程序。Google Cloud Source资源库URI的格式为<code><a href="https://source.developers.google.com/p/${GCP_PROJECT}/r/${REPO}" class="bare">source.developers.google.com/p/${GCP_PROJECT}/r/${REPO}</a></code> 。要获取您存储库的URI，请在Google Cloud Source UI中单击“克隆”，然后选择“手动生成的凭据”。不生成任何凭证，只需复制显示的URI。</p>
</div>
<div class="paragraph">
<p>Google Cloud Source凭据提供商将使用Google Cloud Platform应用程序默认凭据。请参阅<a href="https://cloud.google.com/sdk/gcloud/reference/auth/application-default/login">Google Cloud SDK文档</a> ，了解如何为系统创建应用程序默认凭据。这种方法适用于开发环境中的用户帐户和生产环境中的服务帐户。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>com.google.auth:google-auth-library-oauth2-http</code>是可选的依赖项。如果<code>google-auth-library-oauth2-http</code> jar不在您的类路径上，无论git服务器URI如何，都不会创建Google Cloud Source凭据提供程序。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="git-ssh-configuration-using-properties"><a class="anchor" href="#git-ssh-configuration-using-properties"></a> <a class="link" href="#git-ssh-configuration-using-properties">使用属性进行Git SSH配置</a></h6>
<div class="paragraph">
<p>默认情况下，Spring Cloud Config Server使用的JGit库使用SSH配置文件，例如<code>~/.ssh/known_hosts</code>和<code>/etc/ssh/ssh_config</code>使用SSH URI连接到Git存储库时。在Cloud Foundry之类的云环境中，本地文件系统可能是临时的，或者不容易访问。在这种情况下，可以使用Java属性设置SSH配置。为了激活基于属性的SSH配置， <code>spring.cloud.config.server.git.ignoreLocalSshSettings</code>属性必须设置为<code>true</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">  spring:
    cloud:
      config:
        server:
          git:
            uri: git@gitserver.com:team/repo1.git
            ignoreLocalSshSettings: true
            hostKey: someHostKey
            hostKeyAlgorithm: ssh-rsa
            privateKey: |
                         -----BEGIN RSA PRIVATE KEY-----
                         MIIEpgIBAAKCAQEAx4UbaDzY5xjW6hc9jwN0mX33XpTDVW9WqHp5AKaRbtAC3DqX
                         IXFMPgw3K45jxRb93f8tv9vL3rD9CUG1Gv4FM+o7ds7FRES5RTjv2RT/JVNJCoqF
                         ol8+ngLqRZCyBtQN7zYByWMRirPGoDUqdPYrj2yq+ObBBNhg5N+hOwKjjpzdj2Ud
                         1l7R+wxIqmJo1IYyy16xS8WsjyQuyC0lL456qkd5BDZ0Ag8j2X9H9D5220Ln7s9i
                         oezTipXipS7p7Jekf3Ywx6abJwOmB0rX79dV4qiNcGgzATnG1PkXxqt76VhcGa0W
                         DDVHEEYGbSQ6hIGSh0I7BQun0aLRZojfE3gqHQIDAQABAoIBAQCZmGrk8BK6tXCd
                         fY6yTiKxFzwb38IQP0ojIUWNrq0+9Xt+NsypviLHkXfXXCKKU4zUHeIGVRq5MN9b
                         BO56/RrcQHHOoJdUWuOV2qMqJvPUtC0CpGkD+valhfD75MxoXU7s3FK7yjxy3rsG
                         EmfA6tHV8/4a5umo5TqSd2YTm5B19AhRqiuUVI1wTB41DjULUGiMYrnYrhzQlVvj
                         5MjnKTlYu3V8PoYDfv1GmxPPh6vlpafXEeEYN8VB97e5x3DGHjZ5UrurAmTLTdO8
                         +AahyoKsIY612TkkQthJlt7FJAwnCGMgY6podzzvzICLFmmTXYiZ/28I4BX/mOSe
                         pZVnfRixAoGBAO6Uiwt40/PKs53mCEWngslSCsh9oGAaLTf/XdvMns5VmuyyAyKG
                         ti8Ol5wqBMi4GIUzjbgUvSUt+IowIrG3f5tN85wpjQ1UGVcpTnl5Qo9xaS1PFScQ
                         xrtWZ9eNj2TsIAMp/svJsyGG3OibxfnuAIpSXNQiJPwRlW3irzpGgVx/AoGBANYW
                         dnhshUcEHMJi3aXwR12OTDnaLoanVGLwLnkqLSYUZA7ZegpKq90UAuBdcEfgdpyi
                         PhKpeaeIiAaNnFo8m9aoTKr+7I6/uMTlwrVnfrsVTZv3orxjwQV20YIBCVRKD1uX
                         VhE0ozPZxwwKSPAFocpyWpGHGreGF1AIYBE9UBtjAoGBAI8bfPgJpyFyMiGBjO6z
                         FwlJc/xlFqDusrcHL7abW5qq0L4v3R+FrJw3ZYufzLTVcKfdj6GelwJJO+8wBm+R
                         gTKYJItEhT48duLIfTDyIpHGVm9+I1MGhh5zKuCqIhxIYr9jHloBB7kRm0rPvYY4
                         VAykcNgyDvtAVODP+4m6JvhjAoGBALbtTqErKN47V0+JJpapLnF0KxGrqeGIjIRV
                         cYA6V4WYGr7NeIfesecfOC356PyhgPfpcVyEztwlvwTKb3RzIT1TZN8fH4YBr6Ee
                         KTbTjefRFhVUjQqnucAvfGi29f+9oE3Ei9f7wA+H35ocF6JvTYUsHNMIO/3gZ38N
                         CPjyCMa9AoGBAMhsITNe3QcbsXAbdUR00dDsIFVROzyFJ2m40i4KCRM35bC/BIBs
                         q0TY3we+ERB40U8Z2BvU61QuwaunJ2+uGadHo58VSVdggqAo0BSkH58innKKt96J
                         69pcVH/4rmLbXdcmNYGm6iu+MlPQk4BUZknHSmVHIFdJ0EPupVaQ8RHT
                         -----END RSA PRIVATE KEY-----</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了SSH配置属性。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表2。SSH配置属性</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">物业名称</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>ignoreLocalSshSettings</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果<code>true</code> ，请使用基于属性而不是基于文件的SSH配置。必须设置为<code>spring.cloud.config.server.git.ignoreLocalSshSettings</code> ， <strong>而不是</strong>在存储库定义中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>私钥</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有效的SSH私钥。如果必须设置<code>ignoreLocalSshSettings</code>是true，Git URI是SSH格式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>hostKey</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有效的SSH主机密钥。如果必须设置<code>hostKeyAlgorithm</code>也设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>hostKeyAlgorithm</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之一<code>ssh-dss, ssh-rsa, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521</code> 。如果必须设置<code>hostKey</code>也设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>strictHostKeyChecking</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>要么<code>false</code> 。如果为false，请忽略主机密钥错误。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>knownHostsFile</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">海关地点<code>.known_hosts</code>文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>preferredAuthentications</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖服务器身份验证方法顺序。如果服务器在启动之前具有键盘交互身份验证，这应该可以避免登录提示。 <code>publickey</code>方法。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="placeholders-in-git-search-paths"><a class="anchor" href="#placeholders-in-git-search-paths"></a> <a class="link" href="#placeholders-in-git-search-paths">Git搜索路径中的占位符</a></h6>
<div class="paragraph">
<p>Spring Cloud Config Server还支持带有占位符的搜索路径，用于<code>{application}</code>和<code>{profile}</code> （和<code>{label}</code> （如需要），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          searchPaths: '{application}'</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的清单导致在存储库中搜索与目录（以及顶层）同名的文件。通配符在带有占位符的搜索路径中也有效（搜索中包括任何匹配的目录）。</p>
</div>
</div>
<div class="sect5">
<h6 id="force-pull-in-git-repositories"><a class="anchor" href="#force-pull-in-git-repositories"></a> <a class="link" href="#force-pull-in-git-repositories">强制拉入Git存储库</a></h6>
<div class="paragraph">
<p>如前所述，Spring Cloud Config Server会克隆远程git存储库，以防本地副本变脏（例如，操作系统进程更改了文件夹内容），从而使Spring Cloud Config Server无法从远程存储库更新本地副本。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，有一个<code>force-pull</code>如果本地副本是脏的，使得Spring Cloud Config Server强制从远程存储库中拉出属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          force-pull: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您有多个存储库配置，则可以配置<code>force-pull</code>每个存储库的属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://git/common/config-repo.git
          force-pull: true
          repos:
            team-a:
                pattern: team-a-*
                uri: https://git/team-a/config-repo.git
                force-pull: true
            team-b:
                pattern: team-b-*
                uri: https://git/team-b/config-repo.git
                force-pull: true
            team-c:
                pattern: team-c-*
                uri: https://git/team-a/config-repo.git</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的默认值<code>force-pull</code>财产是<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="deleting-untracked-branches-in-git-repositories"><a class="anchor" href="#deleting-untracked-branches-in-git-repositories"></a> <a class="link" href="#deleting-untracked-branches-in-git-repositories">删除Git存储库中未跟踪的分支</a></h6>
<div class="paragraph">
<p>由于Spring Cloud Config Server在将分支检出到本地存储库（例如，通过标签获取属性）后具有远程git存储库的克隆，因此它将永久保留该分支，直到下一个服务器重启（这将创建新的本地存储库）。因此，有可能删除远程分支，但仍可获取其本地副本。如果Spring Cloud Config Server客户端服务以<code>--spring.cloud.config.label=deletedRemoteBranch,master</code>它将从中获取属性<code>deletedRemoteBranch</code>本地分支机构，但不是来自<code>master</code> 。</p>
</div>
<div class="paragraph">
<p>为了使本地存储库分支保持整洁并保持远程状态- <code>deleteUntrackedBranches</code>可以设置属性。它将使Spring Cloud Config Server <strong>强制</strong>从本地存储库中删除未跟踪的分支。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          deleteUntrackedBranches: true</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的默认值<code>deleteUntrackedBranches</code>财产是<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="git-refresh-rate"><a class="anchor" href="#git-refresh-rate"></a> <a class="link" href="#git-refresh-rate">Git刷新率</a></h6>
<div class="paragraph">
<p>您可以使用以下方法控制配置服务器从Git后端获取更新的配置数据的频率： <code>spring.cloud.config.server.git.refreshRate</code> 。以秒为单位指定此属性的值。默认情况下，该值为0，这意味着配置服务器将在每次请求时从Git存储库中获取更新的配置。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="version-control-backend-filesystem-use"><a class="anchor" href="#version-control-backend-filesystem-use"></a> <a class="link" href="#version-control-backend-filesystem-use">版本控制后端文件系统使用</a></h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">使用基于VCS的后端（git，svn），文件被检出或克隆到本地文件系统。默认情况下，它们被放置在系统临时目录中，前缀为<code>config-repo-</code> 。例如，在Linux上，它可能是<code>/tmp/config-repo-<randomid></code> 。一些操作系统<a href="https://serverfault.com/questions/377348/when-does-tmp-get-cleared/377349#377349">通常会清除</a>临时目录。这可能导致意外的行为，例如缺少属性。为避免此问题，请通过设置更改Config Server使用的目录<code>spring.cloud.config.server.git.basedir</code>要么<code>spring.cloud.config.server.svn.basedir</code>到不在系统临时结构中的目录。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="file-system-backend"><a class="anchor" href="#file-system-backend"></a> <a class="link" href="#file-system-backend">文件系统后端</a></h5>
<div class="paragraph">
<p>Config Server中还有一个“本机”配置文件，该配置文件不使用Git，而是从本地类路径或文件系统（您要指向的任何静态URL）加载配置文件。 <code>spring.cloud.config.server.native.searchLocations</code> ）。要使用本机配置文件，请使用以下命令启动配置服务器： <code>spring.profiles.active=native</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请记住使用<code>file:</code>文件资源的前缀（不带前缀的默认值通常是类路径）。与任何Spring Boot配置一样，您可以嵌入<code>${}</code>风格的环境占位符，但请记住，Windows中的绝对路径需要额外的空间<code>/</code> （例如， <code><a href="file:///${user.home}/config-repo" class="bare">/${user.home}/config-repo</a></code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">的默认值<code>searchLocations</code>与本地Spring Boot应用程序相同（即， <code>[classpath:/, classpath:/config, file:./, file:./config]</code> ）。这不会暴露<code>application.properties</code>从服务器到所有客户端，因为服务器中存在的所有属性源在发送给客户端之前都已删除。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">文件系统后端非常适合快速入门和测试。要在生产环境中使用它，您需要确保文件系统可靠并且可以在Config Server的所有实例之间共享。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>搜索位置可以包含占位符<code>{application}</code> ， <code>{profile}</code>和<code>{label}</code> 。这样，您可以隔离路径中的目录，然后选择一种对您有意义的策略（例如，每个应用程序的子目录或每个配置文件的子目录）。</p>
</div>
<div class="paragraph">
<p>如果您不在搜索位置中使用占位符，则此存储库还会附加<code>{label}</code> HTTP资源的参数作为搜索路径上的后缀，因此从每个搜索位置<strong>和</strong>与标签名称相同的子目录加载属性文件（在Spring Environment中，带标签的属性优先）。因此，没有占位符的默认行为与添加以结尾的搜索位置相同<code>/{label}/</code> 。例如， <code>file:/tmp/config</code>是相同的<code>file:/tmp/config,file:/tmp/config/{label}</code> 。可以通过设置禁用此行为<code>spring.cloud.config.server.native.addLabelLocations=false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="vault-backend"><a class="anchor" href="#vault-backend"></a> <a class="link" href="#vault-backend">保管库后端</a></h5>
<div class="paragraph">
<p>Spring Cloud Config Server还支持将<a href="https://www.vaultproject.io">Vault</a>作为后端。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>保险柜是用于安全访问机密的工具。秘密是您要严格控制访问权限的所有内容，例如API密钥，密码，证书和其他敏感信息。保管库提供了对任何机密的统一界面，同时提供了严格的访问控制并记录了详细的审核日志。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>有关Vault的更多信息，请参阅<a href="https://learn.hashicorp.com/vault/?track=getting-started#getting-started">Vault快速入门指南</a> 。</p>
</div>
<div class="paragraph">
<p>要使配置服务器能够使用Vault后端，您可以通过以下方式运行配置服务器： <code>vault</code>轮廓。例如，在您的配置服务器的<code>application.properties</code> ， 你可以加<code>spring.profiles.active=vault</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，配置服务器假定您的Vault服务器运行在<code><a href="http://127.0.0.1:8200" class="bare">127.0.0.1:8200</a></code> 。它还假定后端的名称是<code>secret</code>关键是<code>application</code> 。所有这些默认值都可以在配置服务器的<code>application.properties</code> 。下表描述了可配置的保管库属性：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">主办</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">港口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8200</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方案</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">http</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">后端</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秘密</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">defaultKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">profileSeparator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">，</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kv版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">skipSslValidation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">超时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名空间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空值</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">上表中的所有属性都必须带有前缀<code>spring.cloud.config.server.vault</code>或放置在组合配置的正确“保险柜”部分中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以在以下位置找到所有可配置的属性<code>org.springframework.cloud.config.server.environment.VaultEnvironmentProperties</code> 。</p>
</div>
<div class="paragraph">
<p>Vault 0.10.0引入了版本化的键值后端（k / v后端版本2），该后端公开的API与早期版本不同，因此现在需要<code>data/</code>在安装路径和实际上下文路径之间，并将秘密包装在<code>data</code>宾语。设置<code>kvVersion=2</code>将考虑到这一点。</p>
</div>
<div class="paragraph">
<p>（可选）对Vault Enterprise的支持<code>X-Vault-Namespace</code>标头。要将其发送到保险柜，请设置<code>namespace</code>属性。</p>
</div>
<div class="paragraph">
<p>在配置服务器运行的情况下，您可以向服务器发出HTTP请求以从Vault后端检索值。为此，您需要Vault服务器的令牌。</p>
</div>
<div class="paragraph">
<p>首先，将一些数据放入Vault中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">$ vault kv put secret/application foo=bar baz=bam
$ vault kv put secret/myapp foo=myappsbar</code></pre>
</div>
</div>
<div class="paragraph">
<p>其次，向配置服务器发出HTTP请求以检索值，如以下示例所示：</p>
</div>
<div class="paragraph">
<p><code>$ curl -X "GET" "http://localhost:8888/myapp/default" -H "X-Config-Token: yourtoken"</code></p>
</div>
<div class="paragraph">
<p>您应该看到类似于以下内容的响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
   "name":"myapp",
   "profiles":[
      "default"
   ],
   "label":null,
   "version":null,
   "state":null,
   "propertySources":[
      {
         "name":"vault:myapp",
         "source":{
            "foo":"myappsbar"
         }
      },
      {
         "name":"vault:application",
         "source":{
            "baz":"bam",
            "foo":"bar"
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="multiple-properties-sources"><a class="anchor" href="#multiple-properties-sources"></a> <a class="link" href="#multiple-properties-sources">多个属性来源</a></h6>
<div class="paragraph">
<p>使用Vault时，可以为您的应用程序提供多个属性源。例如，假设您已将数据写入Vault中的以下路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">secret/myApp,dev
secret/myApp
secret/application,dev
secret/application</code></pre>
</div>
</div>
<div class="paragraph">
<p>写入的属性<code>secret/application</code>可用于<a href="#_vault_server">使用Config Server的所有应用程序</a> 。名称为“ <code>myApp</code> ，会将任何属性写入<code>secret/myApp</code>和<code>secret/application</code>可用。什么时候<code>myApp</code>有<code>dev</code>启用配置文件后，将可以使用写入上述所有路径的属性，列表中第一个路径中的属性优先于其他属性。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="accessing-backends-through-a-proxy"><a class="anchor" href="#accessing-backends-through-a-proxy"></a> <a class="link" href="#accessing-backends-through-a-proxy">通过代理访问后端</a></h5>
<div class="paragraph">
<p>配置服务器可以通过HTTP或HTTPS代理访问Git或Vault后端。对于Git或保险柜，此行为通过以下设置进行控制<code>proxy.http</code>和<code>proxy.https</code> 。这些设置是针对每个存储库的，因此，如果您使用<a href="#composite-environment-repositories">组合环境存储库</a> ，则必须分别为组合中的每个后端配置代理设置。如果使用的网络需要HTTP和HTTPS URL分别使用代理服务器，则可以为单个后端配置HTTP和HTTPS代理设置。</p>
</div>
<div class="paragraph">
<p>下表描述了HTTP和HTTPS代理的代理配置属性。所有这些属性必须以开头<code>proxy.http</code>要么<code>proxy.https</code> 。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表3。代理配置属性</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">物业名称</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>主办</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代理的主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>港口</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问代理的端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>nonProxyHosts</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置服务器应在代理外部访问的所有主机。如果同时提供两个值<code>proxy.http.nonProxyHosts</code>和<code>proxy.https.nonProxyHosts</code> ， <code>proxy.http</code>值将被使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>用户名</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用来验证代理的用户名。如果同时提供两个值<code>proxy.http.username</code>和<code>proxy.https.username</code> ， <code>proxy.http</code>值将被使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>密码</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用来验证代理的密码。如果同时提供两个值<code>proxy.http.password</code>和<code>proxy.https.password</code> ， <code>proxy.http</code>值将被使用。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下配置使用HTTPS代理访问Git存储库。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: git
  cloud:
    config:
      server:
        git:
          uri: https://github.com/spring-cloud-samples/config-repo
          proxy:
            https:
              host: my-proxy.host.io
              password: myproxypassword
              port: '3128'
              username: myproxyusername
              nonProxyHosts: example.com</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sharing-configuration-with-all-applications"><a class="anchor" href="#sharing-configuration-with-all-applications"></a> <a class="link" href="#sharing-configuration-with-all-applications">与所有应用程序共享配置</a></h5>
<div class="paragraph">
<p>所有应用程序之间的共享配置根据您采用的方法而异，如以下主题所述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-config-server-file-based-repositories">基于文件的存储库</a></p>
</li>
<li>
<p><a href="#spring-cloud-config-server-vault-server">保管箱服务器</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="spring-cloud-config-server-file-based-repositories"><a class="anchor" href="#spring-cloud-config-server-file-based-repositories"></a> <a class="link" href="#spring-cloud-config-server-file-based-repositories">基于文件的存储库</a></h6>
<div class="paragraph">
<p>对于基于文件（git，svn和本机）的存储库，具有文件名的资源位于<code>application*</code> （ <code>application.properties</code> ， <code>application.yml</code> ， <code>application-*.properties</code> ，等等）在所有客户端应用程序之间共享。您可以使用具有这些文件名的资源来配置全局默认值，并在必要时使它们被应用程序特定的文件覆盖。</p>
</div>
<div class="paragraph">
<p><a href="#property-overrides">属性覆盖</a>功能也可用于设置全局默认值，允许使用占位符应用程序在本地覆盖它们。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用“本机”配置文件（本地文件系统后端），您应该使用不属于服务器自身配置的显式搜索位置。否则， <code>application*</code>默认搜索位置中的资源被删除，因为它们是服务器的一部分。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-config-server-vault-server"><a class="anchor" href="#spring-cloud-config-server-vault-server"></a> <a class="link" href="#spring-cloud-config-server-vault-server">保管箱服务器</a></h6>
<div class="paragraph">
<p>使用Vault作为后端时，您可以通过将配置放在以下位置来与所有应用程序共享配置<code>secret/application</code> 。例如，如果运行以下Vault命令，则使用配置服务器的所有应用程序都将具有以下属性： <code>foo</code>和<code>baz</code>可供他们使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">$ vault write secret/application foo=bar baz=bam</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jdbc-backend"><a class="anchor" href="#jdbc-backend"></a> <a class="link" href="#jdbc-backend">JDBC后端</a></h5>
<div class="paragraph">
<p>Spring Cloud Config Server支持JDBC（关系数据库）作为配置属性的后端。您可以通过添加启用此功能<code>spring-jdbc</code>到类路径并使用<code>jdbc</code>概要文件或通过添加类型的Bean <code>JdbcEnvironmentRepository</code> 。如果在类路径上包括正确的依赖项（有关更多详细信息，请参见用户指南），Spring Boot会配置数据源。</p>
</div>
<div class="paragraph">
<p>数据库需要有一个名为<code>PROPERTIES</code>与列称为<code>APPLICATION</code> ， <code>PROFILE</code>和<code>LABEL</code> （与通常<code>Environment</code>含义），再加上<code>KEY</code>和<code>VALUE</code>对于键和值对<code>Properties</code>样式。Java中所有字段的类型均为String，因此您可以将它们设置为<code>VARCHAR</code>无论您需要什么长度。属性值的行为与如果它们来自名为Spring Boot的属性文件的行为相同<code>{application}-{profile}.properties</code> ，包括所有加密和解密，将作为后处理步骤应用（也就是说，不会直接在存储库实现中使用）。</p>
</div>
</div>
<div class="sect4">
<h5 id="redis-backend"><a class="anchor" href="#redis-backend"></a> <a class="link" href="#redis-backend">Redis后端</a></h5>
<div class="paragraph">
<p>Spring Cloud Config Server支持Redis作为配置属性的后端。您可以通过向<a href="https://spring.io/projects/spring-data-redis">Spring Data Redis</a>添加依赖项来启用此功能。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下配置使用Spring Data <code>RedisTemplate</code>访问Redis。我们可以用<code>spring.redis.*</code>属性以覆盖默认的连接设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: redis
  redis:
    host: redis
    port: 16379</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些属性应作为字段存储在哈希中。哈希名称应与<code>spring.application.name</code>财产或<code>spring.application.name</code>和<code>spring.profiles.active[n]</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">HMSET sample-app server.port "8100" sample.topic.name "test" test.property1 "property1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行上面可见的命令后，哈希应包含带有值的以下键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>HGETALL sample-app
{
  "server.port": "8100",
  "sample.topic.name": "test",
  "test.property1": "property1"
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">未指定配置文件时<code>default</code>将会被使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="aws-s3-backend"><a class="anchor" href="#aws-s3-backend"></a> <a class="link" href="#aws-s3-backend">AWS S3后端</a></h5>
<div class="paragraph">
<p>Spring Cloud Config Server支持将AWS S3作为配置属性的后端。您可以通过向<a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/examples-s3.html">Amazon S3</a>的<a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/examples-s3.html">AWS Java SDK</a>添加依赖项来启用此功能。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>com.amazonaws</groupId>
        <artifactId>aws-java-sdk-s3</artifactId>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下配置使用AWS S3客户端访问配置文件。我们可以用<code>spring.awss3.*</code>属性以选择存储配置的存储桶。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: awss3
  cloud:
    config:
      server:
        awss3:
          region: us-east-1
          bucket: bucket1</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以指定一个AWS URL以<a href="https://aws.amazon.com/blogs/developer/using-new-regions-and-endpoints/">覆盖</a>您的S3服务<a href="https://aws.amazon.com/blogs/developer/using-new-regions-and-endpoints/">的标准端点</a> <code>spring.awss3.endpoint</code> 。这允许支持S3的beta区域以及其他与S3兼容的存储API。</p>
</div>
<div class="paragraph">
<p>使用<a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html">默认AWS Credential Provider Chain</a>可以找到<a href="https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html">凭证</a> 。支持版本化和加密的存储桶，无需进一步配置。</p>
</div>
<div class="paragraph">
<p>配置文件以以下形式存储在您的存储桶中： <code>{application}-{profile}.properties</code> ， <code>{application}-{profile}.yml</code>要么<code>{application}-{profile}.json</code> 。可以提供一个可选标签来指定文件的目录路径。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">未指定配置文件时<code>default</code>将会被使用。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="credhub-backend"><a class="anchor" href="#credhub-backend"></a> <a class="link" href="#credhub-backend">CredHub后端</a></h5>
<div class="paragraph">
<p>Spring Cloud Config Server支持<a href="https://docs.cloudfoundry.org/credhub">CredHub</a>作为配置属性的后端。您可以通过向<a href="https://spring.io/projects/spring-credhub">Spring CredHub</a>添加依赖项来启用此功能。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.credhub</groupId>
        <artifactId>spring-credhub-starter</artifactId>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下配置使用双向TLS访问CredHub：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: credhub
  cloud:
    config:
      server:
        credhub:
          url: https://credhub:8844</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些属性应存储为JSON，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">credhub set --name "/demo-app/default/master/toggles" --type=json
value: {"toggle.button": "blue", "toggle.link": "red"}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">credhub set --name "/demo-app/default/master/abs" --type=json
value: {"marketing.enabled": true, "external.enabled": false}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有客户端应用程序的名称<code>spring.cloud.config.name=demo-app</code>将具有以下可用属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
    toggle.button: "blue",
    toggle.link: "red",
    marketing.enabled: true,
    external.enabled: false
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">未指定配置文件时<code>default</code>当未指定标签时将使用<code>master</code>将用作默认值。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="oauth-2-0"><a class="anchor" href="#oauth-2-0"></a> <a class="link" href="#oauth-2-0">OAuth 2.0</a></h6>
<div class="paragraph">
<p>您可以使用<a href="https://docs.cloudfoundry.org/concepts/architecture/uaa.html">UAA</a>作为提供程序通过<a href="https://oauth.net/2/">OAuth 2.0</a>进行身份验证。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-config</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-oauth2-client</artifactId>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下配置使用OAuth 2.0和UAA访问CredHub：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: credhub
  cloud:
    config:
      server:
        credhub:
          url: https://credhub:8844
          oauth2:
            registration-id: credhub-client
  security:
    oauth2:
      client:
        registration:
          credhub-client:
            provider: uaa
            client-id: credhub_config_server
            client-secret: asecret
            authorization-grant-type: client_credentials
        provider:
          uaa:
            token-uri: https://uaa:8443/oauth/token</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用的UAA客户ID应该具有<code>credhub.read</code>作为范围。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="composite-environment-repositories"><a class="anchor" href="#composite-environment-repositories"></a> <a class="link" href="#composite-environment-repositories">复合环境存储库</a></h5>
<div class="paragraph">
<p>在某些情况下，您可能希望从多个环境存储库中提取配置数据。为此，您可以启用<code>composite</code>配置服务器的应用程序属性或YAML文件中的配置文件。例如，如果要从Subversion存储库以及两个Git存储库中提取配置数据，则可以为配置服务器设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: composite
  cloud:
    config:
      server:
        composite:
        -
          type: svn
          uri: file:///path/to/svn/repo
        -
          type: git
          uri: file:///path/to/rex/git/repo
        -
          type: git
          uri: file:///path/to/walter/git/repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用此配置，优先级由存储库在“存储库”下列出的顺序确定。 <code>composite</code>键。在上面的示例中，首先列出了Subversion存储库，因此在Subversion存储库中找到的值将覆盖在其中一个Git存储库中为同一属性找到的值。在中找到的值<code>rex</code>在使用Git存储库之前，会在其中找到相同属性的值<code>walter</code> Git存储库。</p>
</div>
<div class="paragraph">
<p>如果您只想从各自不同类型的存储库中提取配置数据，则可以启用相应的配置文件，而不是启用<code>composite</code>配置文件，在配置服务器的应用程序属性或YAML文件中。例如，如果要从单个Git存储库和单个HashiCorp Vault服务器提取配置数据，则可以为配置服务器设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: git, vault
  cloud:
    config:
      server:
        git:
          uri: file:///path/to/git/repo
          order: 2
        vault:
          host: 127.0.0.1
          port: 8200
          order: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用此配置，优先级可以由<code>order</code>属性。您可以使用<code>order</code>属性，用于指定所有存储库的优先级顺序。数值越低<code>order</code>属性，它具有更高的优先级。存储库的优先级顺序有助于解决包含相同属性值的存储库之间的任何潜在冲突。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的复合环境包括上一个示例中的Vault服务器，则必须在对配置服务器的每个请求中都包含Vault令牌。请参阅<a href="#vault-backend">保管库后端</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从环境存储库中检索值时，任何类型的故障都会导致整个组合环境的故障。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用复合环境时，所有存储库都包含相同的标签很重要。如果您的环境与上述示例中的环境类似，并且您需要使用<code>master</code>标签，但Subversion存储库不包含名为<code>master</code> ，整个请求失败。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="custom-composite-environment-repositories"><a class="anchor" href="#custom-composite-environment-repositories"></a> <a class="link" href="#custom-composite-environment-repositories">定制复合环境存储库</a></h6>
<div class="paragraph">
<p>除了使用Spring Cloud中的一个环境存储库之外，您还可以提供自己的<code>EnvironmentRepository</code> bean被包含在复合环境中。为此，您的bean必须实现<code>EnvironmentRepository</code>接口。如果您想控制自定义的优先级<code>EnvironmentRepository</code>在复合环境中，您还应该实现<code>Ordered</code>接口并覆盖<code>getOrdered</code>方法。如果您不执行<code>Ordered</code>界面，您的<code>EnvironmentRepository</code>被赋予最低优先级。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="property-overrides"><a class="anchor" href="#property-overrides"></a> <a class="link" href="#property-overrides">物业替代</a></h5>
<div class="paragraph">
<p>Config Server具有“替代”功能，使操作员可以为所有应用程序提供配置属性。应用程序使用常规的Spring Boot钩子不会意外更改重写的属性。要声明覆盖，请向其中添加名称/值对映射<code>spring.cloud.config.server.overrides</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        overrides:
          foo: bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例使所有作为配置客户端的应用程序读取<code>foo=bar</code> ，独立于自己的配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">配置系统不能强制应用程序以任何特定方式使用配置数据。因此，覆盖无法执行。但是，它们确实为Spring Cloud Config客户端提供了有用的默认行为。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">通常，Spring环境占位符带有<code>${}</code>可以使用反斜杠（ <code>\</code> ）逃脱<code>$</code>或者<code>{</code> 。例如， <code>\${app.foo:bar}</code>决心<code>bar</code> ，除非应用提供自己的<code>app.foo</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在YAML中，您不需要转义反斜杠本身。但是，在属性文件中，在服务器上配置替代时，确实需要转义反斜杠。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以将客户端中所有替代的优先级更改为更像默认值，通过设置以下选项，让应用程序在环境变量或系统属性中提供自己的值： <code>spring.cloud.config.overrideNone=true</code>远程存储库中的标志（默认为false）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="health-indicator-2"><a class="anchor" href="#health-indicator-2"></a> <a class="link" href="#health-indicator-2">4.2.2。健康指标</a></h4>
<div class="paragraph">
<p>Config Server带有运行状况指示器，用于检查是否已配置<code>EnvironmentRepository</code>工作中。默认情况下，它会询问<code>EnvironmentRepository</code>对于名为<code>app</code> ， <code>default</code>配置文件，以及<code>EnvironmentRepository</code>实施。</p>
</div>
<div class="paragraph">
<p>您可以配置运行状况指示器以检查更多应用程序以及自定义配置文件和自定义标签，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      server:
        health:
          repositories:
            myservice:
              label: mylabel
            myservice-dev:
              name: myservice
              profiles: development</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过设置禁用健康状况指示器<code>spring.cloud.config.server.health.enabled=false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="security"><a class="anchor" href="#security"></a> <a class="link" href="#security">4.2.3。安全</a></h4>
<div class="paragraph">
<p>您可以使用对您有意义的任何方式来保护Config Server（从物理网络安全到OAuth2承载令牌），因为Spring Security和Spring Boot提供了对许多安全性安排的支持。</p>
</div>
<div class="paragraph">
<p>要使用默认的Spring Boot配置的HTTP Basic安全性，请在类路径中包含Spring Security（例如，通过<code>spring-boot-starter-security</code> ）。默认用户名是<code>user</code>以及随机生成的密码。随机密码实际上没有用，因此我们建议您配置密码（通过设置<code>spring.security.user.password</code> ）并对其进行加密（有关如何操作的说明，请参见下文）。</p>
</div>
</div>
<div class="sect3">
<h4 id="encryption-and-decryption-2"><a class="anchor" href="#encryption-and-decryption-2"></a> <a class="link" href="#encryption-and-decryption-2">4.2.4。加密与解密</a></h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">要使用加密和解密功能，您需要在JVM中安装完整强度的JCE（默认情况下不包括）。您可以从Oracle下载“ Java密码学扩展（JCE）无限强度管辖权策略文件”并按照安装说明进行操作（本质上，您需要用下载的JRE lib / security目录替换这两个策略文件）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果远程属性源包含加密的内容（值以<code>{cipher}</code> ），则将其解密，然后再通过HTTP发送给客户端。此设置的主要优点是，当属性值处于“静止”状态时（例如，在git存储库中），不需要使用纯文本格式。如果无法解密某个值，则将其从属性源中删除，并使用相同的密钥添加一个附加属性，但前缀为<code>invalid</code>和一个表示“不适用”的值（通常<code><n/a></code> ）。这在很大程度上是为了防止密文用作密码并意外泄漏。</p>
</div>
<div class="paragraph">
<p>如果您为配置客户端应用程序设置了远程配置存储库，则它可能包含一个<code>application.yml</code>类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  datasource:
    username: dbuser
    password: '{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'</code></pre>
</div>
</div>
<div class="paragraph">
<p>.properties文件中的加密值不能用引号引起来。否则，该值不会解密。以下示例显示了有效的值：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre>spring.datasource.username: dbuser
spring.datasource.password: {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ</pre>
</div>
</div>
<div class="paragraph">
<p>您可以安全地将此纯文本推送到共享的git存储库，并且秘密密码仍然受到保护。</p>
</div>
<div class="paragraph">
<p>服务器还公开<code>/encrypt</code>和<code>/decrypt</code>端点（假设它们是安全的，并且只能由授权代理访问）。如果您编辑远程配置文件，则可以使用Config Server通过POST到<code>/encrypt</code>端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8888/encrypt -d mysecret
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您加密的值中包含需要URL编码的字符，则应使用<code>--data-urlencode</code>选择<code>curl</code>确保它们编码正确。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">确保不要在加密值中包含任何curl命令统计信息。将值输出到文件可以帮助避免此问题。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>逆运算也可以通过<code>/decrypt</code> （前提是服务器配置了对称密钥或完整密钥对），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8888/decrypt -d 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您进行卷曲测试，请使用<code>--data-urlencode</code> （代替<code>-d</code> ）或设置一个明确的<code>Content-Type: text/plain</code>以确保curl在有特殊字符时正确编码数据（“ +”特别棘手）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>取加密值并添加<code>{cipher}</code>前缀，然后再将其放入YAML或属性文件中，然后再提交并将其推送到远程（可能不安全）存储中。</p>
</div>
<div class="paragraph">
<p>的<code>/encrypt</code>和<code>/decrypt</code>端点也都接受以下形式的路径<code>/*/{application}/{profiles}</code> ，当客户端调用主环境资源时，可用于按应用程序（名称）和配置文件控制密码。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要以这种精细的方式控制密码，您还必须提供一个<code>@Bean</code>类型的<code>TextEncryptorLocator</code>会根据名称和配置文件创建不同的加密器。默认情况下不提供（所有加密使用相同的密钥）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>spring</code>命令行客户端（安装了Spring Cloud CLI扩展）也可以用于加密和解密，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>
</div>
</div>
<div class="paragraph">
<p>要使用文件中的密钥（例如用于加密的RSA公钥），请在密钥值前添加“ @”并提供文件路径，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>--key</code>参数是强制性的（尽管有一个<code>--</code>字首）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="key-management"><a class="anchor" href="#key-management"></a> <a class="link" href="#key-management">4.2.5。密钥管理</a></h4>
<div class="paragraph">
<p>Config Server可以使用对称（共享）密钥或非对称密钥（RSA密钥对）。非对称选择在安全性方面是优越的，但是使用对称密钥通常更方便，因为它是在服务器中配置的单个属性值。 <code>bootstrap.properties</code> 。</p>
</div>
<div class="paragraph">
<p>要配置对称密钥，您需要设置<code>encrypt.key</code>到一个秘密的字符串（或使用<code>ENCRYPT_KEY</code>环境变量，以使其脱离纯文本配置文件）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您不能使用以下命令配置非对称密钥<code>encrypt.key</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要配置非对称密钥，请使用密钥库（例如，由密钥库创建的密钥库）。 <code>keytool</code> JDK附带的实用程序）。密钥库属性是<code>encrypt.keyStore.*</code>与<code>*</code>等于</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">属性</th>
<th class="tableblock halign-center valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>encrypt.keyStore.location</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含一个<code>Resource</code>地点</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>encrypt.keyStore.password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">持有用于解锁密钥库的密码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>encrypt.keyStore.alias</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标识商店中要使用的密钥</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>encrypt.keyStore.type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要创建的KeyStore的类型。默认为<code>jks</code> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>加密是使用公钥完成的，解密需要私钥。因此，原则上，如果您只想加密（并准备使用私钥在本地解密值），则只能在服务器中配置公钥。实际上，您可能不希望在本地进行解密，因为它会将密钥管理过程分布在所有客户端上，而不是将其集中在服务器上。另一方面，如果您的配置服务器相对不安全并且只有少数客户端需要加密的属性，那么它可能是一个有用的选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="creating-a-key-store-for-testing"><a class="anchor" href="#creating-a-key-store-for-testing"></a> <a class="link" href="#creating-a-key-store-for-testing">4.2.6。创建密钥库进行测试</a></h4>
<div class="paragraph">
<p>要创建用于测试的密钥库，可以使用类似于以下内容的命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ keytool -genkeypair -alias mytestkey -keyalg RSA \
  -dname "CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US" \
  -keypass changeme -keystore server.jks -storepass letmein</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用JDK 11或更高版本时，使用上述命令时可能会收到以下警告。在这种情况下，您可能要确保<code>keypass</code>和<code>storepass</code>值匹配。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre>Warning:  Different store and key passwords not supported for PKCS12 KeyStores. Ignoring user-specified -keypass value.</pre>
</div>
</div>
<div class="paragraph">
<p>放在<code>server.jks</code>文件放在类路径中（例如），然后在<code>bootstrap.yml</code> ，对于Config Server，请创建以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">encrypt:
  keyStore:
    location: classpath:/server.jks
    password: letmein
    alias: mytestkey
    secret: changeme</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-multiple-keys-and-key-rotation"><a class="anchor" href="#using-multiple-keys-and-key-rotation"></a> <a class="link" href="#using-multiple-keys-and-key-rotation">4.2.7。使用多个按键和按键旋转</a></h4>
<div class="paragraph">
<p>除了<code>{cipher}</code>加密属性值中的前缀，则Config Server查找零个或多个<code>{name:value}</code> （Base64编码）密文开始之前的前缀。密钥被传递给<code>TextEncryptorLocator</code> ，它可以执行定位一个<code>TextEncryptor</code>密码。如果已配置密钥库（ <code>encrypt.keystore.location</code> ），默认定位器会查找具有由<code>key</code>前缀，类似如下的密文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">foo:
  bar: `{cipher}{key:testkey}...`</code></pre>
</div>
</div>
<div class="paragraph">
<p>定位器查找名为“ testkey”的密钥。也可以使用<code>{secret:…​}</code>前缀中的值。但是，如果未提供，则默认为使用密钥库密码（这是在构建密钥库且未指定密钥时得到的密码）。如果您确实提供了机密，则还应该使用自定义加密机密<code>SecretLocator</code> 。</p>
</div>
<div class="paragraph">
<p>当密钥仅用于加密几个字节的配置数据时（也就是说，它们未在其他地方使用），从密码的角度讲，几乎不需要旋转密钥。但是，您有时可能需要更改密钥（例如，在发生安全漏洞时）。在这种情况下，所有客户端都需要更改其源配置文件（例如，在git中）并使用新的<code>{key:…​}</code>所有密码的前缀。请注意，客户端需要首先检查Config Server密钥库中的密钥别名是否可用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果要让Config Server处理所有加密和解密，则<code>{name:value}</code>前缀也可以以纯文本形式添加到<code>/encrypt</code>端点。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="serving-encrypted-properties"><a class="anchor" href="#serving-encrypted-properties"></a> <a class="link" href="#serving-encrypted-properties">4.2.8。提供加密的属性</a></h4>
<div class="paragraph">
<p>有时，您希望客户端在本地解密配置，而不是在服务器中进行解密。在这种情况下，如果您提供<code>encrypt.*</code>配置以找到密钥，您仍然可以<code>/encrypt</code>和<code>/decrypt</code>端点，但是您需要通过放置来显式关闭对传出属性的解密<code>spring.cloud.config.server.encrypt.enabled=false</code>在<code>bootstrap.[yml|properties]</code> 。如果您不关心端点，则在不配置键或启用标志的情况下都可以使用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="serving-alternative-formats"><a class="anchor" href="#serving-alternative-formats"></a> <a class="link" href="#serving-alternative-formats">4.3。提供替代格式</a></h3>
<div class="paragraph">
<p>来自环境端点的默认JSON格式非常适合Spring应用程序使用，因为它直接映射到<code>Environment</code>抽象。如果愿意，可以通过在资源路径中添加后缀（“ .yml”，“。yaml”或“ .properties”）来使用与YAML或Java属性相同的数据。对于不关心JSON终结点的结构或它们提供的额外元数据的应用程序来说，这可能很有用（例如，不使用Spring的应用程序可能会受益于此方法的简单性）。</p>
</div>
<div class="paragraph">
<p>YAML和属性表示形式还有一个附加标志（作为布尔查询参数提供，称为<code>resolvePlaceholders</code> ），以在源文档中发出占位符的信号（在标准Spring中<code>${…​}</code>形式）应尽可能在输出之前解析。对于不了解Spring占位符约定的使用者来说，这是一个有用的功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用YAML或属性格式存在一些限制，主要是与元数据的丢失有关。例如，JSON被构造为属性源的有序列表，其名称与该源相关。即使值的来源有多个来源，YAML和属性形式也会合并到一个映射中，并且原始来源文件的名称也会丢失。同样，YAML表示也不一定是后备存储库中YAML源的忠实表示。它由一系列平面属性来源构成，并且必须对密钥的形式进行假设。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="serving-plain-text"><a class="anchor" href="#serving-plain-text"></a> <a class="link" href="#serving-plain-text">4.4。提供纯文本</a></h3>
<div class="paragraph">
<p>而不是使用<code>Environment</code>抽象（或YAML或属性格式的另一种表示形式），您的应用程序可能需要针对其环境量身定制的通用纯文本配置文件。Config Server通过位于以下位置的附加终结点提供这些功能<code>/{application}/{profile}/{label}/{path}</code> ，在哪里<code>application</code> ， <code>profile</code>和<code>label</code>与常规环境端点具有相同的含义，但<code>path</code>是文件名的路径（例如<code>log.xml</code> ）。该端点的源文件与环境端点的定位方式相同。属性和YAML文件使用相同的搜索路径。但是，不是汇总所有匹配资源，而是仅返回要匹配的第一个资源。</p>
</div>
<div class="paragraph">
<p>找到资源后，使用常规格式的占位符（ <code>${…​}</code> ）通过使用有效解决<code>Environment</code>提供的应用程序名称，配置文件和标签。这样，资源端点与环境端点紧密集成在一起。考虑以下用于GIT或SVN存储库的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>application.yml
nginx.conf</pre>
</div>
</div>
<div class="paragraph">
<p>哪里<code>nginx.conf</code>看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>server {
    listen              80;
    server_name         ${nginx.server.name};
}</pre>
</div>
</div>
<div class="paragraph">
<p>和<code>application.yml</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">nginx:
  server:
    name: example.com
---
spring:
  profiles: development
nginx:
  server:
    name: develop.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>/foo/default/master/nginx.conf</code>资源可能如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>server {
    listen              80;
    server_name         example.com;
}</pre>
</div>
</div>
<div class="paragraph">
<p>和<code>/foo/development/master/nginx.conf</code>像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>server {
    listen              80;
    server_name         develop.com;
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">与用于环境配置的源文件一样， <code>profile</code>用于解析文件名。因此，如果您要使用特定于配置文件的文件， <code>/*/development/*/logback.xml</code>可以通过名为<code>logback-development.xml</code> （优先于<code>logback.xml</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您不想提供<code>label</code>并让服务器使用默认标签，您可以提供一个<code>useDefaultLabel</code>请求参数。因此，前面的示例<code>default</code>个人资料可能是<code>/foo/default/nginx.conf?useDefaultLabel</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="decrpyting-plain-text"><a class="anchor" href="#decrpyting-plain-text"></a> <a class="link" href="#decrpyting-plain-text">4.4.1。解密纯文本</a></h4>
<div class="paragraph">
<p>默认情况下，纯文本文件中的加密值不会被解密。为了启用对纯文本文件的解密，请设置<code>spring.cloud.config.server.encrypt.enabled=true</code>和<code>spring.cloud.config.server.encrypt.plainTextEncrypt=true</code>在<code>bootstrap.[yml|properties]</code></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">仅YAML，JSON和属性文件扩展名支持对纯文本文件进行解密。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果启用了此功能，并且请求了不受支持的文件扩展名，则文件中的任何加密值都不会被解密。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="embedding-the-config-server"><a class="anchor" href="#embedding-the-config-server"></a> <a class="link" href="#embedding-the-config-server">4.5。嵌入配置服务器</a></h3>
<div class="paragraph">
<p>Config Server最好作为独立应用程序运行。但是，如果需要，可以将其嵌入另一个应用程序。为此，请使用<code>@EnableConfigServer</code>注解。名为的可选属性<code>spring.cloud.config.server.bootstrap</code>在这种情况下很有用。它是一个标志，用于指示服务器是否应从其自己的远程存储库中进行配置。默认情况下，该标志为关闭状态，因为它会延迟启动。但是，当嵌入到另一个应用程序中时，以与其他任何应用程序相同的方式进行初始化是有意义的。设定时<code>spring.cloud.config.server.bootstrap</code>至<code>true</code>您还必须使用<a href="#composite-environment-repositories">复合环境存储库配置</a> 。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  application:
    name: configserver
  profiles:
    active: composite
  cloud:
    config:
      server:
        composite:
          - type: native
            search-locations: ${HOME}/Desktop/config
        bootstrap: true</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果使用bootstrap标志，则配置服务器需要在以下位置配置其名称和存储库URI： <code>bootstrap.yml</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要更改服务器端点的位置，可以（可选）设置<code>spring.cloud.config.server.prefix</code> （例如， <code>/config</code> ），以便在前缀下提供资源。前缀应以a开头但不能以a结尾<code>/</code> 。它适用于<code>@RequestMappings</code>在Config Server中（即Spring Boot的下面） <code>server.servletPath</code>和<code>server.contextPath</code>前缀）。</p>
</div>
<div class="paragraph">
<p>如果要直接从后端存储库（而不是从配置服务器）读取应用程序的配置，则基本上需要没有端点的嵌入式配置服务器。您可以不使用<code>@EnableConfigServer</code>注解（设置<code>spring.cloud.config.server.bootstrap=true</code> ）。</p>
</div>
</div>
<div class="sect2">
<h3 id="push-notifications-and-spring-cloud-bus"><a class="anchor" href="#push-notifications-and-spring-cloud-bus"></a> <a class="link" href="#push-notifications-and-spring-cloud-bus">4.6。推送通知和Spring Cloud Bus</a></h3>
<div class="paragraph">
<p>许多源代码存储库提供程序（例如Github，Gitlab，Gita，Gitee，Gogs或Bitbucket）都通过Webhook通知您存储库中的更改。您可以通过提供者的用户界面将Webhook配置为URL和您感兴趣的一组事件。例如， <a href="https://developer.github.com/v3/activity/events/types/#pushevent">Github</a>使用带有JSON主体（包含提交列表和标头（ <code>X-Github-Event</code> ） 调成<code>push</code> 。如果您添加对<code>spring-cloud-config-monitor</code>库并在配置服务器中激活Spring Cloud Bus，然后<code>/monitor</code>端点已启用。</p>
</div>
<div class="paragraph">
<p>Webhook激活后，配置服务器将发送<code>RefreshRemoteApplicationEvent</code>针对它认为可能已更改的应用程序。变化检测可以被策略化。但是，默认情况下，它会查找与应用程序名称匹配的文件中的更改（例如， <code>foo.properties</code>针对于<code>foo</code>申请，而<code>application.properties</code>针对所有应用程序）。要覆盖行为时要使用的策略是<code>PropertyPathNotificationExtractor</code> ，它接受请求标头和正文作为参数，并返回已更改文件路径的列表。</p>
</div>
<div class="paragraph">
<p>默认配置可以与Github，Gitlab，Gitea，Gitee，Gogs或Bitbucket一起使用。除了来自Github，Gitlab，Gitee或Bitbucket的JSON通知之外，您还可以通过以下方法触发更改通知： <code>/monitor</code>具有形式编码的主体参数<code>path={application}</code> 。这样做会广播到与<code>{application}</code>模式（可以包含通配符）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>RefreshRemoteApplicationEvent</code>仅在<code>spring-cloud-bus</code>已在Config Server和客户端应用程序中激活。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认配置还检测本地git存储库中的文件系统更改。在这种情况下，不使用Webhook。但是，一旦您编辑配置文件，就会广播刷新。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-config-client"><a class="anchor" href="#spring-cloud-config-client"></a> <a class="link" href="#spring-cloud-config-client">4.7。Spring Cloud Config客户端</a></h3>
<div class="paragraph">
<p>Spring Boot应用程序可以立即利用Spring Config Server（或应用程序开发人员提供的其他外部属性源）。它还选择了一些与<code>Environment</code>更改事件。</p>
</div>
<div class="sect3">
<h4 id="config-first-bootstrap"><a class="anchor" href="#config-first-bootstrap"></a> <a class="link" href="#config-first-bootstrap">4.7.1。配置第一个引导程序</a></h4>
<div class="paragraph">
<p>在类路径上具有Spring Cloud Config Client的任何应用程序的默认行为如下：当配置客户端启动时，它将绑定到Config Server（通过<code>spring.cloud.config.uri</code>引导程序配置属性）并初始化Spring <code>Environment</code>与远程资源来源。</p>
</div>
<div class="paragraph">
<p>此行为的最终结果是，所有要使用Config Server的客户端应用程序都需要一个<code>bootstrap.yml</code> （或环境变量），其中服务器地址设置为<code>spring.cloud.config.uri</code> （默认为“ http：// localhost：8888”）。</p>
</div>
</div>
<div class="sect3">
<h4 id="discovery-first-bootstrap"><a class="anchor" href="#discovery-first-bootstrap"></a> <a class="link" href="#discovery-first-bootstrap">4.7.2。发现第一引导</a></h4>
<div class="paragraph">
<p>如果您使用<code>DiscoveryClient</code>实施，例如Spring Cloud Netflix和Eureka Service Discovery或Spring Cloud Consul，您可以让Config Server在Discovery Service中注册。但是，在默认的“配置优先”模式下，客户端无法利用注册。</p>
</div>
<div class="paragraph">
<p>如果您喜欢使用<code>DiscoveryClient</code>要找到配置服务器，可以通过设置<code>spring.cloud.config.discovery.enabled=true</code> （默认为<code>false</code> ）。这样做的最终结果是，客户端应用程序都需要一个<code>bootstrap.yml</code> （或环境变量）以及适当的发现配置。例如，对于Spring Cloud Netflix，您需要定义Eureka服务器地址（例如， <code>eureka.client.serviceUrl.defaultZone</code> ）。使用此选项的价格是启动时需要进行额外的网络往返，以查找服务注册。好处是，只要发现服务是固定点，配置服务器就可以更改其坐标。默认服务ID是<code>configserver</code> ，但是您可以通过设置在客户端上进行更改<code>spring.cloud.config.discovery.serviceId</code> （以及在服务器上，以通常用于服务的方式，例如通过设置<code>spring.application.name</code> ）。</p>
</div>
<div class="paragraph">
<p>发现客户端实现均支持某种元数据映射（例如， <code>eureka.instance.metadataMap</code>尤里卡）。Config Server的某些其他属性可能需要在其服务注册元数据中进行配置，以便客户端可以正确连接。如果Config Server受HTTP Basic保护，则可以将凭据配置为<code>user</code>和<code>password</code> 。另外，如果Config Server具有上下文路径，则可以设置<code>configPath</code> 。例如，以下YAML文件适用于作为Eureka客户端的Config Server：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">eureka:
  instance:
    ...
    metadataMap:
      user: osufhalskjrtl
      password: lviuhlszvaorhvlo5847
      configPath: /config</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="config-client-fail-fast"><a class="anchor" href="#config-client-fail-fast"></a> <a class="link" href="#config-client-fail-fast">4.7.3。快速配置客户端失败</a></h4>
<div class="paragraph">
<p>在某些情况下，如果服务无法连接到Config Server，您可能希望启动失败。如果这是所需的行为，请设置引导程序配置属性<code>spring.cloud.config.fail-fast=true</code>使客户端因异常而暂停。</p>
</div>
</div>
<div class="sect3">
<h4 id="config-client-retry"><a class="anchor" href="#config-client-retry"></a> <a class="link" href="#config-client-retry">4.7.4。配置客户端重试</a></h4>
<div class="paragraph">
<p>如果您希望配置服务器在应用程序启动时偶尔会不可用，则可以使其在失败后继续尝试。首先，您需要设置<code>spring.cloud.config.fail-fast=true</code> 。然后，您需要添加<code>spring-retry</code>和<code>spring-boot-starter-aop</code>到你的classpath。默认行为是重试六次，初始回退间隔为1000ms，随后的回退的指数乘数为1.1。您可以通过设置以下属性来配置这些属性（和其他属性） <code>spring.cloud.config.retry.*</code>配置属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">要完全控制重试行为，请添加一个<code>@Bean</code>类型的<code>RetryOperationsInterceptor</code> ID为<code>configServerRetryInterceptor</code> 。春季重试有一个<code>RetryInterceptorBuilder</code>支持创建一个。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="locating-remote-configuration-resources"><a class="anchor" href="#locating-remote-configuration-resources"></a> <a class="link" href="#locating-remote-configuration-resources">4.7.5。查找远程配置资源</a></h4>
<div class="paragraph">
<p>Config Service从以下位置提供属性源<code>/{application}/{profile}/{label}</code> ，其中客户端应用程序中的默认绑定如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“名称” =<code>${spring.application.name}</code></p>
</li>
<li>
<p>“个人资料” = <code>${spring.profiles.active}</code> （其实<code>Environment.getActiveProfiles()</code> ）</p>
</li>
<li>
<p>“ label” =“主人”</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置属性时<code>${spring.application.name}</code>不要在您的应用名称前加上保留字<code>application-</code>以防止解决正确的属性源的问题。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以通过设置覆盖所有这些<code>spring.cloud.config.*</code> （哪里<code>*</code>是<code>name</code> ， <code>profile</code>要么<code>label</code> ）。的<code>label</code>对于回滚到以前的配置版本很有用。使用默认的Config Server实现，它可以是git标签，分支名称或提交ID。标签也可以逗号分隔的列表形式提供。在这种情况下，列表中的项目将一一尝试，直到一项成功为止。在要素分支上工作时，此行为可能很有用。例如，您可能想使配置标签与分支对齐，但使其成为可选（在这种情况下，请使用<code>spring.cloud.config.label=myfeature,develop</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="specifying-multiple-urls-for-the-config-server"><a class="anchor" href="#specifying-multiple-urls-for-the-config-server"></a> <a class="link" href="#specifying-multiple-urls-for-the-config-server">4.7.6。为配置服务器指定多个地址</a></h4>
<div class="paragraph">
<p>为确保在部署了Config Server的多个实例并且不时会出现一个或多个实例不可用时确保高可用性，可以指定多个URL（作为逗号分隔的列表，位于<code>spring.cloud.config.uri</code>属性），或让您的所有实例在Eureka之类的服务注册表中注册（如果使用Discovery-First Bootstrap模式）。请注意，只有在未运行Config Server时（即，应用程序退出时）或发生连接超时时，这样做才能确保高可用性。例如，如果Config Server返回500（内部服务器错误）响应，或者Config Client从Config Server收到401（由于凭据错误或其他原因），则Config Client不会尝试从其他URL获取属性。此类错误表示用户问题，而不是可用性问题。</p>
</div>
<div class="paragraph">
<p>如果您在Config Server上使用HTTP基本安全性，则仅当您将凭据嵌入到您在Config Server下指定的每个URL中时，当前才有可能支持per-Config Server身份验证凭据。 <code>spring.cloud.config.uri</code>属性。如果使用任何其他类型的安全性机制，则（当前）不能支持每台配置服务器的身份验证和授权。</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-timeouts"><a class="anchor" href="#configuring-timeouts"></a> <a class="link" href="#configuring-timeouts">4.7.7。配置超时</a></h4>
<div class="paragraph">
<p>如果要配置超时阈值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以使用属性配置读取超时<code>spring.cloud.config.request-read-timeout</code> 。</p>
</li>
<li>
<p>可以使用属性配置连接超时<code>spring.cloud.config.request-connect-timeout</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="security-2"><a class="anchor" href="#security-2"></a> <a class="link" href="#security-2">4.7.8。安全</a></h4>
<div class="paragraph">
<p>如果在服务器上使用HTTP基本安全性，则客户端需要知道密码（如果不是默认用户名，则需要用户名）。您可以通过配置服务器URI或通过单独的用户名和密码属性来指定用户名和密码，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
     uri: https://user:secret@myconfig.mycompany.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了传递相同信息的另一种方法：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
     uri: https://myconfig.mycompany.com
     username: user
     password: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>spring.cloud.config.password</code>和<code>spring.cloud.config.username</code>值将覆盖URI中提供的任何内容。</p>
</div>
<div class="paragraph">
<p>如果您在Cloud Foundry上部署应用程序，则提供密码的最佳方法是通过服务凭据（例如URI，因为它不需要在配置文件中）。以下示例在本地工作，并且适用于名为Cloud Foundry的用户提供的服务<code>configserver</code> ：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
     uri: ${vcap.services.configserver.credentials.uri:http://user:password@localhost:8888}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用其他形式的安全性，则可能需要<a href="#custom-rest-template">提供<code>RestTemplate</code></a>到<code>ConfigServicePropertySourceLocator</code> （例如，通过在引导上下文中获取它并注入它）。</p>
</div>
<div class="sect4">
<h5 id="health-indicator-3"><a class="anchor" href="#health-indicator-3"></a> <a class="link" href="#health-indicator-3">健康指标</a></h5>
<div class="paragraph">
<p>Config Client提供一个Spring Boot Health Indicator，该指示器尝试从Config Server加载配置。可以通过设置禁用健康指示器<code>health.config.enabled=false</code> 。由于性能原因，响应也被缓存。默认的生存时间为5分钟。要更改该值，请设置<code>health.config.time-to-live</code>属性（以毫秒为单位）。</p>
</div>
</div>
<div class="sect4">
<h5 id="custom-rest-template"><a class="anchor" href="#custom-rest-template"></a> <a class="link" href="#custom-rest-template">提供自定义的RestTemplate</a></h5>
<div class="paragraph">
<p>在某些情况下，您可能需要自定义来自客户端对配置服务器的请求。通常，这样做涉及通过特殊<code>Authorization</code>标头以验证对服务器的请求。提供自定义<code>RestTemplate</code> ：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用以下实现创建一个新的配置Bean <code>PropertySourceLocator</code> ，如以下示例所示：</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">CustomConfigServiceBootstrapConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class CustomConfigServiceBootstrapConfiguration {
    @Bean
    public ConfigServicePropertySourceLocator configServicePropertySourceLocator() {
        ConfigClientProperties clientProperties = configClientProperties();
       ConfigServicePropertySourceLocator configServicePropertySourceLocator =  new ConfigServicePropertySourceLocator(clientProperties);
        configServicePropertySourceLocator.setRestTemplate(customRestTemplate(clientProperties));
        return configServicePropertySourceLocator;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为了简化添加方法<code>Authorization</code>标头<code>spring.cloud.config.headers.*</code>属性可以代替使用。
</td>
</tr>
</tbody></table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在<code>resources/META-INF</code> ，创建一个名为<code>spring.factories</code>并指定您的自定义配置，如以下示例所示：</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">弹簧工厂</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">org.springframework.cloud.bootstrap.BootstrapConfiguration = com.my.config.client.CustomConfigServiceBootstrapConfiguration</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="vault"><a class="anchor" href="#vault"></a> <a class="link" href="#vault">金库</a></h5>
<div class="paragraph">
<p>将保管库用作配置服务器的后端时，客户端需要为服务器提供令牌以从保管库检索值。可以通过设置在客户端内部提供此令牌<code>spring.cloud.config.token</code>在<code>bootstrap.yml</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    config:
      token: YourVaultToken</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nested-keys-in-vault"><a class="anchor" href="#nested-keys-in-vault"></a> <a class="link" href="#nested-keys-in-vault">4.7.9。保险柜中的嵌套键</a></h4>
<div class="paragraph">
<p>保险柜支持将键嵌套在保险柜中存储的值中的功能，如以下示例所示：</p>
</div>
<div class="paragraph">
<p><code>echo -n '{"appA": {"secret": "appAsecret"}, "bar": "baz"}' | vault write secret/myapp -</code></p>
</div>
<div class="paragraph">
<p>此命令将JSON对象写入您的保险柜。要在Spring中访问这些值，您可以使用传统的点（ <code>.</code> ）注释，如以下示例所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Value("${appA.secret}")
String name = "World";</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码将设置<code>name</code>可变为<code>appAsecret</code> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-netflix"><a class="anchor" href="#spring-cloud-netflix"></a> <a class="link" href="#spring-cloud-netflix">5，Spring Cloud Netflix</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="paragraph">
<p>该项目通过自动配置并绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供了Netflix OSS集成。使用一些简单的注释，您可以快速启用和配置应用程序内部的通用模式，并使用经过实战检验的Netflix组件构建大型分布式系统。提供的模式包括服务发现（Eureka），断路器（Hystrix），智能路由（Zuul）和客户端负载平衡（Ribbon）。</p>
</div>
<div class="sect2">
<h3 id="service-discovery-eureka-clients"><a class="anchor" href="#service-discovery-eureka-clients"></a> <a class="link" href="#service-discovery-eureka-clients">5.1。服务发现：Eureka客户</a></h3>
<div class="paragraph">
<p>服务发现是基于微服务的体系结构的主要宗旨之一。尝试手动配置每个客户端或某种形式的约定可能很困难并且很脆弱。Eureka是Netflix Service Discovery服务器和客户端。可以将服务器配置和部署为高度可用，每个服务器将有关已注册服务的状态复制到其他服务器。</p>
</div>
<div class="sect3">
<h4 id="netflix-eureka-client-starter"><a class="anchor" href="#netflix-eureka-client-starter"></a> <a class="link" href="#netflix-eureka-client-starter">5.1.1。如何包括尤里卡客户</a></h4>
<div class="paragraph">
<p>要将Eureka Client包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID为<code>spring-cloud-starter-netflix-eureka-client</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="registering-with-eureka"><a class="anchor" href="#registering-with-eureka"></a> <a class="link" href="#registering-with-eureka">5.1.2。在尤里卡注册</a></h4>
<div class="paragraph">
<p>客户端向Eureka注册时，它会提供有关其自身的元数据，例如主机，端口，运行状况指示器URL，主页和其他详细信息。Eureka从属于服务的每个实例接收心跳消息。如果心跳在可配置的时间表上进行故障转移，则通常会将实例从注册表中删除。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个最小的Eureka客户端应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，前面的示例显示了一个普通的<a href="https://projects.spring.io/spring-boot/">Spring Boot</a>应用程序。有了<code>spring-cloud-starter-netflix-eureka-client</code>在类路径上，您的应用程序会自动向Eureka Server注册。需要配置以找到Eureka服务器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，“ defaultZone”是一个魔术字符串后备值，它为任何不表达首选项的客户端提供服务URL（换句话说，这是一个有用的默认值）。</p>
</div>
<div class="paragraph">
<p>默认应用程序名称（即服务ID），虚拟主机和非安全端口（从<code>Environment</code> ） 是<code>${spring.application.name}</code> ， <code>${spring.application.name}</code>和<code>${server.port}</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>有<code>spring-cloud-starter-netflix-eureka-client</code>在类路径上的，使该应用程序同时成为Eureka的“实例”（即，它自己注册）和“客户端”（它可以查询注册表以定位其他服务）。实例行为由<code>eureka.instance.*</code>配置键，但如果确保您的应用程序具有<code>spring.application.name</code> （这是Eureka服务ID或VIP的默认设置）。</p>
</div>
<div class="paragraph">
<p>有关<a href="https://github.com/spring-cloud/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java">可</a>配置选项的更多详细信息，请参见<a href="https://github.com/spring-cloud/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java">EurekaInstanceConfigBean</a>和<a href="https://github.com/spring-cloud/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java">EurekaClientConfigBean</a> 。</p>
</div>
<div class="paragraph">
<p>要禁用Eureka Discovery Client，您可以设置<code>eureka.client.enabled</code>至<code>false</code> 。在以下情况下，Eureka Discovery Client也将被禁用<code>spring.cloud.discovery.enabled</code>被设定为<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="authenticating-with-the-eureka-server"><a class="anchor" href="#authenticating-with-the-eureka-server"></a> <a class="link" href="#authenticating-with-the-eureka-server">5.1.3。使用Eureka服务器进行身份验证</a></h4>
<div class="paragraph">
<p>如果其中一种是HTTP基本身份验证，则会自动添加到您的eureka客户端<code>eureka.client.serviceUrl.defaultZone</code> URL中嵌入了凭据（卷曲样式，如下所示： <code><a href="https://user:password@localhost:8761/eureka" class="bare">user:password@localhost:8761/eureka</a></code> ）。对于更复杂的需求，您可以创建一个<code>@Bean</code>类型的<code>DiscoveryClientOptionalArgs</code>并注入<code>ClientFilter</code>实例，将所有实例应用于从客户端到服务器的调用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于Eureka的限制，无法支持每服务器的基本身份验证凭据，因此仅使用找到的第一组凭据。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="status-page-and-health-indicator"><a class="anchor" href="#status-page-and-health-indicator"></a> <a class="link" href="#status-page-and-health-indicator">5.1.4。状态页和健康指示器</a></h4>
<div class="paragraph">
<p>Eureka实例的状态页和运行状况指示器默认为<code>/info</code>和<code>/health</code>分别是Spring Boot Actuator应用程序中有用端点的默认位置。即使您使用非默认上下文路径或servlet路径（例如， <code>server.servletPath=/custom</code> ）。下面的示例显示两个设置的默认值：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>eureka:
  instance:
    statusPageUrlPath: ${server.servletPath}/info
    healthCheckUrlPath: ${server.servletPath}/health</pre>
</div>
</div>
<div class="paragraph">
<p>这些链接显示在客户端使用的元数据中，并在某些情况下用于确定是否将请求发送到您的应用程序，因此，如果请求准确无误，这将很有帮助。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在Dalston中，还需要在更改该管理上下文路径时设置状态和运行状况检查URL。从Edgware开始就删除了此要求。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="registering-a-secure-application"><a class="anchor" href="#registering-a-secure-application"></a> <a class="link" href="#registering-a-secure-application">5.1.5。注册安全的应用程序</a></h4>
<div class="paragraph">
<p>如果您想通过HTTPS与您的应用进行联系，则可以在<code>EurekaInstanceConfig</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>eureka.instance.[nonSecurePortEnabled]=[false]</code></p>
</li>
<li>
<p><code>eureka.instance.[securePortEnabled]=[true]</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这样做使Eureka发布实例信息，该实例信息显示出对安全通信的明确偏好。Spring Cloud<code>DiscoveryClient</code>始终返回以开头的URI <code>https</code>以这种方式配置的服务。同样，以这种方式配置服务时，Eureka（本机）实例信息具有安全的运行状况检查URL。</p>
</div>
<div class="paragraph">
<p>由于Eureka在内部工作的方式，它仍然会为状态和主页发布非安全URL，除非您也明确地覆盖了这些URL。您可以使用占位符来配置eureka实例URL，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>eureka:
  instance:
    statusPageUrl: https://${eureka.hostname}/info
    healthCheckUrl: https://${eureka.hostname}/health
    homePageUrl: https://${eureka.hostname}/</pre>
</div>
</div>
<div class="paragraph">
<p>（注意<code>${eureka.hostname}</code>是本机占位符，仅在更高版本的Eureka中可用。您也可以使用Spring占位符来实现相同的目的-例如，通过使用<code>${eureka.instance.hostName}</code> ）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的应用程序在代理之后运行，并且SSL终止在代理中（例如，如果您在Cloud Foundry或其他平台中作为服务运行），则需要确保代理被“转发”的标头被拦截和处理通过应用程序。如果嵌入在Spring Boot应用程序中的Tomcat容器具有针对'X-Forwarded-\ *`标头的显式配置，则会自动发生。应用程序提供的指向自身的链接错误（错误的主机，端口或协议）表明此配置错误。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="eurekas-health-checks"><a class="anchor" href="#eurekas-health-checks"></a> <a class="link" href="#eurekas-health-checks">5.1.6。尤里卡的健康检查</a></h4>
<div class="paragraph">
<p>默认情况下，Eureka使用客户端心跳来确定客户端是否启动。除非另有说明，否则，根据Spring Boot Actuator，发现客户端不会传播应用程序的当前运行状况检查状态。因此，在成功注册后，Eureka始终宣布该应用程序处于“启动”状态。可以通过启用Eureka运行状况检查来更改此行为，这会导致应用程序状态传播到Eureka。结果，所有其他应用程序都不会将流量发送到状态为“ UP”以外的其他应用程序。以下示例显示了如何为客户端启用运行状况检查：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>eureka:
  client:
    healthcheck:
      enabled: true</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<code>eureka.client.healthcheck.enabled=true</code>应该只设置在<code>application.yml</code> 。在中设置值<code>bootstrap.yml</code>会导致不良的副作用，例如在Eureka中注册<code>UNKNOWN</code>状态。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要对健康检查进行更多控制，请考虑实施自己的检查<code>com.netflix.appinfo.HealthCheckHandler</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="eureka-metadata-for-instances-and-clients"><a class="anchor" href="#eureka-metadata-for-instances-and-clients"></a> <a class="link" href="#eureka-metadata-for-instances-and-clients">5.1.7。实例和客户端的Eureka元数据</a></h4>
<div class="paragraph">
<p>值得花费一些时间来了解Eureka元数据的工作原理，因此您可以在平台上使用有意义的方式使用它。有用于信息的标准元数据，例如主机名，IP地址，端口号，状态页和运行状况检查。这些将发布在服务注册表中，并由客户端用于以直接方式联系服务。可以将其他元数据添加到实例注册中<code>eureka.instance.metadataMap</code> ，并且可以在远程客户端中访问此元数据。通常，除非让客户端知道元数据的含义，否则其他元数据不会更改客户端的行为。在本文档后面将介绍几种特殊情况，其中Spring Cloud已经为元数据映射分配了含义。</p>
</div>
<div class="sect4">
<h5 id="using-eureka-on-cloud-foundry"><a class="anchor" href="#using-eureka-on-cloud-foundry"></a> <a class="link" href="#using-eureka-on-cloud-foundry">在Cloud Foundry上使用Eureka</a></h5>
<div class="paragraph">
<p>Cloud Foundry具有全局路由器，因此同一应用程序的所有实例都具有相同的主机名（其他具有类似体系结构的PaaS解决方案的布置也相同）。这不一定是使用尤里卡的障碍。但是，如果您使用路由器（建议或什至是强制性的，取决于平台的设置方式），则需要显式设置主机名和端口号（安全或非安全），以便它们使用路由器。您可能还希望使用实例元数据，以便可以区分客户端上的实例（例如，在自定义负载平衡器中）。默认情况下， <code>eureka.instance.instanceId</code>是<code>vcap.application.instance_id</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80</pre>
</div>
</div>
<div class="paragraph">
<p>根据在Cloud Foundry实例中设置安全规则的方式，您可能可以注册并使用主机VM的IP地址进行直接的服务到服务的调用。Pivotal Web服务（ <a href="https://run.pivotal.io">PWS</a> ）尚不提供此功能。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-eureka-on-aws"><a class="anchor" href="#using-eureka-on-aws"></a> <a class="link" href="#using-eureka-on-aws">在AWS上使用Eureka</a></h5>
<div class="paragraph">
<p>如果计划将应用程序部署到AWS云，则必须将Eureka实例配置为可感知AWS。您可以通过如下自定义<a href="https://github.com/spring-cloud/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java">EurekaInstanceConfigBean</a>来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
@Profile("!default")
public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
  EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);
  AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
  b.setDataCenterInfo(info);
  return b;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="changing-the-eureka-instance-id"><a class="anchor" href="#changing-the-eureka-instance-id"></a> <a class="link" href="#changing-the-eureka-instance-id">更改尤里卡实例ID</a></h5>
<div class="paragraph">
<p>一个普通的Netflix Eureka实例注册的ID等于其主机名（即，每个主机仅提供一项服务）。Spring Cloud Eureka提供了明智的默认值，其定义如下：</p>
</div>
<div class="paragraph">
<p><code>${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}</code></p>
</div>
<div class="paragraph">
<p>一个例子是<code>myhost:myappname:8080</code> 。</p>
</div>
<div class="paragraph">
<p>通过使用Spring Cloud，您可以通过在<code>eureka.instance.instanceId</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>eureka:
  instance:
    instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre>
</div>
</div>
<div class="paragraph">
<p>通过前面示例中显示的元数据和在本地主机上部署的多个服务实例，在其中插入随机值以使实例唯一。在Cloud Foundry中， <code>vcap.application.instance_id</code>是在Spring Boot应用程序中自动填充的，因此不需要随机值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-the-eurekaclient"><a class="anchor" href="#using-the-eurekaclient"></a> <a class="link" href="#using-the-eurekaclient">5.1.8。使用EurekaClient</a></h4>
<div class="paragraph">
<p>一旦拥有作为发现客户端的应用程序，就可以使用它从<a href="#spring-cloud-eureka-server">Eureka Server</a>发现服务实例。一种方法是使用本机<code>com.netflix.discovery.EurekaClient</code> （与Spring Cloud相对<code>DiscoveryClient</code> ），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Autowired
private EurekaClient discoveryClient;

public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
}</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请勿使用<code>EurekaClient</code>在一个<code>@PostConstruct</code>方法或<code>@Scheduled</code>方法（或任何<code>ApplicationContext</code>可能尚未启动）。初始化为<code>SmartLifecycle</code> （与<code>phase=0</code> ），因此最早可以依靠它的是另一个<code>SmartLifecycle</code>具有更高的阶段。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="eurekaclient-without-jersey"><a class="anchor" href="#eurekaclient-without-jersey"></a> <a class="link" href="#eurekaclient-without-jersey">没有球衣的EurekaClient</a></h5>
<div class="paragraph">
<p>默认情况下，EurekaClient使用Jersey进行HTTP通信。如果希望避免来自Jersey的依赖关系，可以将其从依赖关系中排除。Spring Cloud基于Spring自动配置传输客户端<code>RestTemplate</code> 。以下示例显示排除了Jersey：</p>
</div>
<div class="listingblock">
<div class="content">
<pre><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    <exclusions>
        <exclusion>
            <groupId>com.sun.jersey</groupId>
            <artifactId>jersey-client</artifactId>
        </exclusion>
        <exclusion>
            <groupId>com.sun.jersey</groupId>
            <artifactId>jersey-core</artifactId>
        </exclusion>
        <exclusion>
            <groupId>com.sun.jersey.contribs</groupId>
            <artifactId>jersey-apache-client4</artifactId>
        </exclusion>
    </exclusions>
</dependency></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="alternatives-to-the-native-netflix-eurekaclient"><a class="anchor" href="#alternatives-to-the-native-netflix-eurekaclient"></a> <a class="link" href="#alternatives-to-the-native-netflix-eurekaclient">5.1.9。本地Netflix EurekaClient的替代产品</a></h4>
<div class="paragraph">
<p>您无需使用原始Netflix <code>EurekaClient</code> 。而且，通常在某种包装器后面使用它会更方便。Spring Cloud支持<a href="#spring-cloud-feign">Feign</a> （REST客户端构建器）和<a href="#spring-cloud-ribbon">Spring <code>RestTemplate</code></a>通过逻辑Eureka服务标识符（VIP）而不是物理URL。要使用固定的物理服务器列表配置功能区，可以设置<code><client>.ribbon.listOfServers</code>到以逗号分隔的物理地址（或主机名）列表，其中<code><client></code>是客户端的ID。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>org.springframework.cloud.client.discovery.DiscoveryClient</code> ，它为发现客户端提供了一个简单的API（非Netflix专用），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List<ServiceInstance> list = discoveryClient.getInstances("STORES");
    if (list != null && list.size() > 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="why-is-it-so-slow-to-register-a-service"><a class="anchor" href="#why-is-it-so-slow-to-register-a-service"></a> <a class="link" href="#why-is-it-so-slow-to-register-a-service">5.1.10。为什么注册服务这么慢？</a></h4>
<div class="paragraph">
<p>成为实例还涉及到注册表的定期心跳（通过客户端的<code>serviceUrl</code> ），默认时长为30秒。直到实例，服务器和客户端在其本地缓存中都具有相同的元数据后，客户端才能发现该服务（因此可能需要3个心跳）。您可以通过设置更改周期<code>eureka.instance.leaseRenewalIntervalInSeconds</code> 。将其设置为小于30的值可加快使客户端连接到其他服务的过程。在生产中，最好使用默认值，因为服务器中的内部计算对租约续订期进行了假设。</p>
</div>
</div>
<div class="sect3">
<h4 id="zones"><a class="anchor" href="#zones"></a> <a class="link" href="#zones">5.1.11。区域</a></h4>
<div class="paragraph">
<p>如果您已将Eureka客户端部署到多个区域，则您可能更希望这些客户端在同一区域内使用服务，然后再尝试其他区域中的服务。要进行设置，您需要正确配置Eureka客户端。</p>
</div>
<div class="paragraph">
<p>首先，您需要确保已将Eureka服务器部署到每个区域，并且它们彼此对等。有关更多信息，请参见<a href="#spring-cloud-eureka-server-zones-and-regions">区域和区域</a>部分。</p>
</div>
<div class="paragraph">
<p>接下来，您需要告诉Eureka您的服务位于哪个区域。您可以使用<code>metadataMap</code>属性。例如，如果<code>service 1</code>部署到两个<code>zone 1</code>和<code>zone 2</code> ，您需要在中设置以下Eureka属性<code>service 1</code> ：</p>
</div>
<div class="paragraph">
<p><strong>1区服务1</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>eureka.instance.metadataMap.zone = zone1
eureka.client.preferSameZoneEureka = true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2区服务1</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>eureka.instance.metadataMap.zone = zone2
eureka.client.preferSameZoneEureka = true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="refreshing-eureka-clients"><a class="anchor" href="#refreshing-eureka-clients"></a> <a class="link" href="#refreshing-eureka-clients">5.1.12。刷新尤里卡客户</a></h4>
<div class="paragraph">
<p>默认情况下， <code>EurekaClient</code> bean是可刷新的，这意味着可以更改和刷新Eureka客户端属性。发生刷新时，客户端将从Eureka服务器中注销，并且可能会在短暂的时间内不提供给定服务的所有实例。消除这种情况的一种方法是禁用刷新Eureka客户端的功能。为此做<code>eureka.client.refresh.enable=false</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-eureka-server"><a class="anchor" href="#spring-cloud-eureka-server"></a> <a class="link" href="#spring-cloud-eureka-server">5.2。服务发现：Eureka服务器</a></h3>
<div class="paragraph">
<p>本节介绍如何设置Eureka服务器。</p>
</div>
<div class="sect3">
<h4 id="netflix-eureka-server-starter"><a class="anchor" href="#netflix-eureka-server-starter"></a> <a class="link" href="#netflix-eureka-server-starter">5.2.1。如何包含Eureka服务器</a></h4>
<div class="paragraph">
<p>要将Eureka Server包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID为<code>spring-cloud-starter-netflix-eureka-server</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的项目已经使用Thymeleaf作为其模板引擎，则可能无法正确加载Eureka服务器的Freemarker模板。在这种情况下，必须手动配置模板加载器：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  freemarker:
    template-loader-path: classpath:/templates/
    prefer-file-system-access: false</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-running-eureka-server"><a class="anchor" href="#spring-cloud-running-eureka-server"></a> <a class="link" href="#spring-cloud-running-eureka-server">5.2.2。如何运行尤里卡服务器</a></h4>
<div class="paragraph">
<p>以下示例显示了最小的Eureka服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableEurekaServer
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该服务器有一个主页，其中包含UI和HTTP API端点，用于在下面的常规Eureka功能。 <code>/eureka/*</code> 。</p>
</div>
<div class="paragraph">
<p>以下链接具有一些Eureka背景知识： <a href="https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer">磁通电容器</a>和<a href="https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0">google小组讨论</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于Gradle的依赖性解析规则以及缺少父bom功能，具体取决于<code>spring-cloud-starter-netflix-eureka-server</code>可能会导致应用程序启动失败。要解决此问题，请添加Spring Boot Gradle插件并按如下所示导入Spring Cloud Starter父Bom：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">buildscript {
  dependencies {
    classpath("org.springframework.boot:spring-boot-gradle-plugin:{spring-boot-docs-version}")
  }
}

apply plugin: "spring-boot"

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:{spring-cloud-version}"
  }
}</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-eureka-server-zones-and-regions"><a class="anchor" href="#spring-cloud-eureka-server-zones-and-regions"></a> <a class="link" href="#spring-cloud-eureka-server-zones-and-regions">5.2.3。高可用性，区域和区域</a></h4>
<div class="paragraph">
<p>Eureka服务器没有后端存储，但是注册表中的所有服务实例都必须发送心跳信号以使其注册保持最新（因此可以在内存中完成）。客户端还具有Eureka注册的内存缓存（因此，对于每个对服务的请求，它们都不必转到注册表）。</p>
</div>
<div class="paragraph">
<p>默认情况下，每个Eureka服务器也是Eureka客户端，并且需要（至少一个）服务URL来定位对等方。如果您不提供该服务，则该服务将运行并运行，但是它将使您的日志充满关于无法向对等方注册的噪音。</p>
</div>
<div class="paragraph">
<p>另请参阅<a href="#spring-cloud-ribbon">以下</a>有关客户端对区域和区域<a href="#spring-cloud-ribbon">的功能区支持的详细信息</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-eureka-server-standalone-mode"><a class="anchor" href="#spring-cloud-eureka-server-standalone-mode"></a> <a class="link" href="#spring-cloud-eureka-server-standalone-mode">5.2.4。独立模式</a></h4>
<div class="paragraph">
<p>只要有某种监视器或弹性运行时（例如Cloud Foundry），两个缓存（客户端和服务器）和心跳的组合就可以使一台独立的Eureka服务器对故障具有相当的恢复能力。在独立模式下，您可能希望关闭客户端行为，以使其不会继续尝试并无法到达其对等对象。下面的示例演示如何关闭客户端行为：</p>
</div>
<div class="listingblock">
<div class="title">application.yml（独立式Eureka服务器）</div>
<div class="content">
<pre>server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</pre>
</div>
</div>
<div class="paragraph">
<p>请注意<code>serviceUrl</code>指向与本地实例相同的主机。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-eureka-server-peer-awareness"><a class="anchor" href="#spring-cloud-eureka-server-peer-awareness"></a> <a class="link" href="#spring-cloud-eureka-server-peer-awareness">5.2.5。同行意识</a></h4>
<div class="paragraph">
<p>通过运行多个实例并要求它们相互注册，可以使Eureka更具弹性并可以使用。实际上，这是默认行为，因此您需要做的就是添加一个有效的<code>serviceUrl</code>到对等方，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml（两个对等的Eureka服务器）</div>
<div class="content">
<pre>---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: https://peer2/eureka/

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: https://peer1/eureka/</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们有一个YAML文件，可用于在两台主机上运行同一服务器（ <code>peer1</code>和<code>peer2</code> ），方法是在不同的Spring配置文件中运行它。您可以使用此配置通过操作来测试单个主机上的对等感知（在生产环境中这样做没有太大价值） <code>/etc/hosts</code>解析主机名。实际上， <code>eureka.instance.hostname</code>如果您在知道其主机名的计算机上运行，则不需要（默认情况下，通过使用<code>java.net.InetAddress</code> ）。</p>
</div>
<div class="paragraph">
<p>您可以将多个对等方添加到系统，并且只要它们均通过至少一个边缘彼此连接，它们就可以在彼此之间同步注册。如果对等方在物理上是分开的（在一个数据中心内部或在多个数据中心之间），则该系统原则上可以承受“裂脑”型故障。您可以将多个对等方添加到系统中，并且只要它们都直接相互连接，它们就可以在彼此之间同步注册。</p>
</div>
<div class="listingblock">
<div class="title">application.yml（三个对等感知Eureka服务器）</div>
<div class="content">
<pre>eureka:
  client:
    serviceUrl:
      defaultZone: https://peer1/eureka/,http://peer2/eureka/,http://peer3/eureka/

---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2

---
spring:
  profiles: peer3
eureka:
  instance:
    hostname: peer3</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-eureka-server-prefer-ip-address"><a class="anchor" href="#spring-cloud-eureka-server-prefer-ip-address"></a> <a class="link" href="#spring-cloud-eureka-server-prefer-ip-address">5.2.6。何时首选IP地址</a></h4>
<div class="paragraph">
<p>在某些情况下，尤里卡最好公布服务的IP地址而不是主机名。组<code>eureka.instance.preferIpAddress</code>至<code>true</code>当应用程序向eureka注册时，它将使用其IP地址而不是其主机名。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果Java无法确定主机名，则IP地址将发送到Eureka。设置主机名的唯一明确方法是通过设置<code>eureka.instance.hostname</code>属性。您可以使用环境变量在运行时设置主机名，例如， <code>eureka.instance.hostname=${HOST_NAME}</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="securing-the-eureka-server"><a class="anchor" href="#securing-the-eureka-server"></a> <a class="link" href="#securing-the-eureka-server">5.2.7。保护Eureka服务器</a></h4>
<div class="paragraph">
<p>您只需通过以下方式将Spring Security添加到服务器的类路径中即可保护Eureka服务器的安全： <code>spring-boot-starter-security</code> 。默认情况下，当Spring Security位于类路径上时，它将要求在每次向应用程序发送请求时都发送有效的CSRF令牌。尤里卡客户通常不会拥有有效的跨站点请求伪造（CSRF）令牌，因此您需要为<code>/eureka/**</code>端点。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableWebSecurity
class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().ignoringAntMatchers("/eureka/**");
        super.configure(http);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关CSRF的更多信息，请参见<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf">Spring Security文档</a> 。</p>
</div>
<div class="paragraph">
<p>可以在Spring Cloud Samples存储<a href="https://github.com/spring-cloud-samples/eureka/tree/Eureka-With-Security">库中</a>找到演示版的Eureka Server。</p>
</div>
</div>
<div class="sect3">
<h4 id="disabling-ribbon-with-eureka-server-and-client-starters"><a class="anchor" href="#disabling-ribbon-with-eureka-server-and-client-starters"></a> <a class="link" href="#disabling-ribbon-with-eureka-server-and-client-starters">5.2.8。使用Eureka Server和客户端启动器禁用功能区</a></h4>
<div class="paragraph">
<p><code>spring-cloud-starter-netflix-eureka-server</code>和<code>spring-cloud-starter-netflix-eureka-client</code>一起来<code>spring-cloud-starter-netflix-ribbon</code> 。由于Ribbon负载均衡器现在处于维护模式，我们建议改用Eureka启动程序中也包括的Spring Cloud LoadBalancer。</p>
</div>
<div class="paragraph">
<p>为此，您可以设置<code>spring.cloud.loadbalancer.ribbon.enabled</code>财产<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>然后，您还可以在构建文件中从Eureka启动程序中排除功能区相关的依赖项，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-starter-ribbon</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>com.netflix.ribbon</groupId>
                    <artifactId>ribbon-eureka</artifactId>
                </exclusion>
            </exclusions>
</dependency></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jdk-11-support"><a class="anchor" href="#jdk-11-support"></a> <a class="link" href="#jdk-11-support">5.2.9。JDK 11支持</a></h4>
<div class="paragraph">
<p>在JDK 11中删除了Eureka服务器所依赖的JAXB模块。如果打算在运行Eureka服务器时使用JDK 11，则必须在POM或Gradle文件中包括这些依赖项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="circuit-breaker-spring-cloud-circuit-breaker-with-hystrix"><a class="anchor" href="#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix"></a> <a class="link" href="#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">5.3。断路器：带Hystrix的spring-cloud-circuitbreaker</a></h3>
<div class="sect3">
<h4 id="disabling-spring-cloud-circuit-breaker-hystrix"><a class="anchor" href="#disabling-spring-cloud-circuit-breaker-hystrix"></a> <a class="link" href="#disabling-spring-cloud-circuit-breaker-hystrix">5.3.1。禁用spring-cloud-circuitbreakerHystrix</a></h4>
<div class="paragraph">
<p>您可以通过设置禁用自动配置<code>spring.cloud.circuitbreaker.hystrix.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-hystrix-circuit-breakers"><a class="anchor" href="#configuring-hystrix-circuit-breakers"></a> <a class="link" href="#configuring-hystrix-circuit-breakers">5.3.2。配置Hystrix断路器</a></h4>
<div class="sect4">
<h5 id="default-configuration"><a class="anchor" href="#default-configuration"></a> <a class="link" href="#default-configuration">默认配置</a></h5>
<div class="paragraph">
<p>要为所有断路器提供默认配置，请创建一个<code>Customize</code>通过的豆<code>HystrixCircuitBreakerFactory</code>要么<code>ReactiveHystrixCircuitBreakerFactory</code> 。的<code>configureDefault</code>方法可用于提供默认配置。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<HystrixCircuitBreakerFactory> defaultConfig() {
    return factory -> factory.configureDefault(id -> HystrixCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
            .withExecutionTimeoutInMilliseconds(4000)));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="reactive-example"><a class="anchor" href="#reactive-example"></a> <a class="link" href="#reactive-example">反应性例子</a></h6>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<ReactiveHystrixCircuitBreakerFactory> defaultConfig() {
    return factory -> factory.configureDefault(id -> HystrixObservableCommand.Setter
            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))
            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                    .withExecutionTimeoutInMilliseconds(4000)));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specific-circuit-breaker-configuration"><a class="anchor" href="#specific-circuit-breaker-configuration"></a> <a class="link" href="#specific-circuit-breaker-configuration">特定断路器配置</a></h5>
<div class="paragraph">
<p>与提供默认配置类似，您可以创建一个<code>Customize</code>豆这是通过<code>HystrixCircuitBreakerFactory</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<HystrixCircuitBreakerFactory> customizer() {
    return factory -> factory.configure(builder -> builder.commandProperties(
                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(2000)), "foo", "bar");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="reactive-example-2"><a class="anchor" href="#reactive-example-2"></a> <a class="link" href="#reactive-example-2">反应性例子</a></h6>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<ReactiveHystrixCircuitBreakerFactory> customizer() {
    return factory -> factory.configure(builder -> builder.commandProperties(
                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(2000)), "foo", "bar");
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="circuit-breaker-hystrix-clients"><a class="anchor" href="#circuit-breaker-hystrix-clients"></a> <a class="link" href="#circuit-breaker-hystrix-clients">5.4。断路器：Hystrix客户</a></h3>
<div class="paragraph">
<p>Netflix创建了一个名为<a href="https://github.com/Netflix/Hystrix">Hystrix</a>的库，该库实现了<a href="https://martinfowler.com/bliki/CircuitBreaker.html">断路器模式</a> 。在微服务架构中，通常有多个服务调用层，如以下示例所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/master/docs/src/main/asciidoc/images/Hystrix.png" alt="Hystrix">
</div>
<div class="title">图1。微服务图</div>
</div>
<div class="paragraph">
<p>较低级别的服务中的服务故障可能会导致级联故障，直至用户。当对特定服务的呼叫超过<code>circuitBreaker.requestVolumeThreshold</code> （默认值：20个请求），并且失败百分比大于<code>circuitBreaker.errorThresholdPercentage</code> （默认值：> 50％）在由<code>metrics.rollingStats.timeInMilliseconds</code> （默认值：10秒），电路断开并且不进行呼叫。在错误和断路的情况下，开发人员可以提供后备功能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/master/docs/src/main/asciidoc/images/HystrixFallback.png" alt="HystrixFallback">
</div>
<div class="title">图2。Hystrix后备可防止级联故障</div>
</div>
<div class="paragraph">
<p>开路可以停止级联故障，并让不堪重负的服务故障时间得以恢复。回退可以是另一个受Hystrix保护的调用，静态数据或合理的空值。可以将回退链接在一起，以便第一个回退进行其他业务调用，然后回退到静态数据。</p>
</div>
<div class="sect3">
<h4 id="how-to-include-hystrix"><a class="anchor" href="#how-to-include-hystrix"></a> <a class="link" href="#how-to-include-hystrix">5.4.1。如何包括Hystrix</a></h4>
<div class="paragraph">
<p>要将Hystrix包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID为<code>spring-cloud-starter-netflix-hystrix</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例显示了带有Hystrix断路器的最小型Eureka服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@SpringBootApplication
@EnableCircuitBreaker
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map<String, Object> parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map<String, Object> parameters) {
        return /* something useful */;
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@HystrixCommand</code>由一个名为<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">“ javanica”</a>的Netflix contrib库提供。Spring Cloud会自动将带有该批注的Spring bean包装在连接到Hystrix断路器的代理中。断路器计算何时断开和闭合电路，以及在发生故障时应采取的措施。</p>
</div>
<div class="paragraph">
<p>配置<code>@HystrixCommand</code>您可以使用<code>commandProperties</code>具有列表的属性<code>@HystrixProperty</code>注释。有关更多详细信息，请参见<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration">此处</a> 。有关可用属性的详细信息，请参见<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix Wiki</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="netflix-hystrix-starter"><a class="anchor" href="#netflix-hystrix-starter"></a> <a class="link" href="#netflix-hystrix-starter">5.4.2。传播安全上下文或使用Spring Scope</a></h4>
<div class="paragraph">
<p>如果您希望某些线程本地上下文传播到<code>@HystrixCommand</code> ，默认声明无效，因为它在线程池中执行命令（如果超时）。您可以通过配置或要求注释使用不同的“隔离策略”，将Hystrix切换为使用与调用方相同的线程或直接在注释中使用。以下示例演示了如何在注释中设置线程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@HystrixCommand(fallbackMethod = "stubMyService",
    commandProperties = {
      @HystrixProperty(name="execution.isolation.strategy", value="SEMAPHORE")
    }
)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是同一件事<code>@SessionScope</code>要么<code>@RequestScope</code> 。如果遇到运行时异常，提示它找不到范围内的上下文，则需要使用同一线程。</p>
</div>
<div class="paragraph">
<p>您还可以选择设置<code>hystrix.shareSecurityContext</code>财产<code>true</code> 。这样做会自动配置Hystrix并发策略插件挂钩以传输<code>SecurityContext</code>从您的主线程到Hystrix命令使用的线程。Hystrix不允许注册多个Hystrix并发策略，因此可以通过声明自己的扩展机制来使用<code>HystrixConcurrencyStrategy</code>作为春豆。Spring Cloud在Spring上下文中寻找您的实现，并将其包装在自己的插件中。</p>
</div>
</div>
<div class="sect3">
<h4 id="health-indicator-4"><a class="anchor" href="#health-indicator-4"></a> <a class="link" href="#health-indicator-4">5.4.3。健康指标</a></h4>
<div class="paragraph">
<p>连接的断路器的状态也暴露在<code>/health</code>调用应用程序的端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "hystrix": {
        "openCircuitBreakers": [
            "StoreIntegration::getStoresByLocationLink"
        ],
        "status": "CIRCUIT_OPEN"
    },
    "status": "UP"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hystrix-metrics-stream"><a class="anchor" href="#hystrix-metrics-stream"></a> <a class="link" href="#hystrix-metrics-stream">5.4.4。Hystrix指标流</a></h4>
<div class="paragraph">
<p>要启用Hystrix指标流，请添加对<code>spring-boot-starter-actuator</code>并设置<code>management.endpoints.web.exposure.include: hystrix.stream</code> 。这样做会暴露<code>/actuator/hystrix.stream</code>作为管理端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="circuit-breaker-hystrix-dashboard"><a class="anchor" href="#circuit-breaker-hystrix-dashboard"></a> <a class="link" href="#circuit-breaker-hystrix-dashboard">5.5。断路器：Hystrix仪表板</a></h3>
<div class="paragraph">
<p>Hystrix的主要优点之一是它收集的有关每个HystrixCommand的一组指标。Hystrix仪表板以有效的方式显示每个断路器的运行状况。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/master/docs/src/main/asciidoc/images/Hystrix.png" alt="Hystrix">
</div>
<div class="title">图3。Hystrix仪表板</div>
</div>
</div>
<div class="sect2">
<h3 id="hystrix-timeouts-and-ribbon-clients"><a class="anchor" href="#hystrix-timeouts-and-ribbon-clients"></a> <a class="link" href="#hystrix-timeouts-and-ribbon-clients">5.6。Hystrix超时和功能区客户端</a></h3>
<div class="paragraph">
<p>使用用于包装Ribbon客户端的Hystrix命令时，您要确保将Hystrix超时配置为比配置的Ribbon超时更长，包括可能进行的任何重试。例如，如果您的功能区连接超时为一秒，并且功能区客户端可能重试该请求三次，则Hystrix超时应该稍微超过三秒钟。</p>
</div>
<div class="sect3">
<h4 id="netflix-hystrix-dashboard-starter"><a class="anchor" href="#netflix-hystrix-dashboard-starter"></a> <a class="link" href="#netflix-hystrix-dashboard-starter">5.6.1。如何包括Hystrix仪表板</a></h4>
<div class="paragraph">
<p>要将Hystrix仪表板包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID为<code>spring-cloud-starter-netflix-hystrix-dashboard</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="paragraph">
<p>要运行Hystrix仪表板，请使用以下命令注释您的Spring Boot主类<code>@EnableHystrixDashboard</code> 。然后参观<code>/hystrix</code>并将仪表板指向单个实例的<code>/hystrix.stream</code> Hystrix客户端应用程序中的端点。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">连接到<code>/hystrix.stream</code>如果端点使用HTTPS，则JVM必须信任服务器使用的证书。如果证书不受信任，则必须将证书导入JVM，以便Hystrix仪表板成功连接到流端点。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="turbine"><a class="anchor" href="#turbine"></a> <a class="link" href="#turbine">5.6.2。涡轮</a></h4>
<div class="paragraph">
<p>从系统的整体运行状况来看，查看单个实例的Hystrix数据不是很有用。<a href="https://github.com/Netflix/Turbine">涡轮</a>是一个汇总所有相关信息的应用程序<code>/hystrix.stream</code>端点合并<code>/turbine.stream</code>用于Hystrix仪表板。个别实例通过Eureka定位。要运行Turbine，需要使用<code>@EnableTurbine</code>注释（例如，通过使用spring-cloud-starter-netflix-turbine设置类路径）。<a href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)">Turbine 1 Wiki中</a>记录的所有配置属性均适用。唯一的区别是<code>turbine.instanceUrlSuffix</code>不需要前置端口，因为它将自动处理，除非<code>turbine.instanceInsertPort=false</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，涡轮查找<code>/hystrix.stream</code>通过查找其注册实例上的端点<code>hostName</code>和<code>port</code>尤里卡中的条目，然后附加<code>/hystrix.stream</code>对它。如果实例的元数据包含<code>management.port</code> ，它代替了<code>port</code>的价值<code>/hystrix.stream</code>端点。默认情况下，元数据条目称为<code>management.port</code>等于<code>management.port</code>配置属性。可以使用以下配置覆盖它：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre>eureka:
  instance:
    metadata-map:
      management.port: ${management.port:8081}</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>turbine.appConfig</code>配置密钥是Eureka serviceIds的列表，涡轮用于查找实例。然后在Hystrix仪表板中使用该涡轮流，并使用类似于以下内容的URL：</p>
</div>
<div class="paragraph">
<p><code><a href="https://my.turbine.server:8080/turbine.stream?cluster=CLUSTERNAME" class="bare">my.turbine.server:8080/turbine.stream?cluster=CLUSTERNAME</a></code></p>
</div>
<div class="paragraph">
<p>如果名称为，则可以省略cluster参数<code>default</code> 。的<code>cluster</code>参数必须与中的条目匹配<code>turbine.aggregator.clusterConfig</code> 。从Eureka返回的值是大写的。因此，如果有一个名为<code>customers</code>在尤里卡（Eureka）注册：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>turbine:
  aggregator:
    clusterConfig: CUSTOMERS
  appConfig: customers</pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要自定义Turbine应该使用哪些群集名称（因为您不想将群集名称存储在<code>turbine.aggregator.clusterConfig</code>配置），提供一个类型的bean <code>TurbineClustersProvider</code> 。</p>
</div>
<div class="paragraph">
<p>的<code>clusterName</code>可以通过SPEL表达式自定义<code>turbine.clusterNameExpression</code>以root作为实例<code>InstanceInfo</code> 。默认值为<code>appName</code> ，这意味着尤里卡<code>serviceId</code>成为群集密钥（即， <code>InstanceInfo</code>为客户有一个<code>appName</code>的<code>CUSTOMERS</code> ）。一个不同的例子是<code>turbine.clusterNameExpression=aSGName</code> ，它从AWS ASG名称获取集群名称。以下清单显示了另一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>turbine:
  aggregator:
    clusterConfig: SYSTEM,USER
  appConfig: customers,stores,ui,admin
  clusterNameExpression: metadata['cluster']</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，来自四个服务的集群名称是从它们的元数据映射中拉出的，并且期望其值包括<code>SYSTEM</code>和<code>USER</code> 。</p>
</div>
<div class="paragraph">
<p>要对所有应用程序使用“默认”群集，您需要一个字符串文字表达式（如果在YAML中，也要使用单引号和双引号进行转义）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>turbine:
  appConfig: customers,stores
  clusterNameExpression: "'default'"</pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud提供了<code>spring-cloud-starter-netflix-turbine</code>具有运行Turbine服务器所需的所有依赖项。要添加Turbine，请创建一个Spring Boot应用程序并使用<code>@EnableTurbine</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，Spring Cloud允许Turbine使用主机和端口来允许每个主机，每个集群多个进程。如果你想内置式水轮机<em>不是</em>本地Netflix的行为允许每个主机的多个进程，每簇（关键实例ID是主机名），集<code>turbine.combineHostPort=false</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="clusters-endpoint"><a class="anchor" href="#clusters-endpoint"></a> <a class="link" href="#clusters-endpoint">集群端点</a></h5>
<div class="paragraph">
<p>在某些情况下，其他应用程序了解Turbine中配置了哪些custers可能会很有用。为此，您可以使用<code>/clusters</code>端点，它将返回所有已配置集群的JSON数组。</p>
</div>
<div class="listingblock">
<div class="title">GET /集群</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
  {
    "name": "RACES",
    "link": "http://localhost:8383/turbine.stream?cluster=RACES"
  },
  {
    "name": "WEB",
    "link": "http://localhost:8383/turbine.stream?cluster=WEB"
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过设置禁用此端点<code>turbine.endpoints.clusters.enabled</code>至<code>false</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="turbine-stream"><a class="anchor" href="#turbine-stream"></a> <a class="link" href="#turbine-stream">5.6.3。涡轮流</a></h4>
<div class="paragraph">
<p>在某些环境中（例如在PaaS设置中），从所有分布式Hystrix命令中提取指标的经典Turbine模型不起作用。在这种情况下，您可能想让Hystrix命令将度量标准推送到Turbine。Spring Cloud通过消息传递实现了这一点。为此，请在客户端上添加依赖项<code>spring-cloud-netflix-hystrix-stream</code>和<code>spring-cloud-starter-stream-*</code>你的选择。请参阅<a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/">Spring Cloud Stream文档</a>以获取有关代理以及如何配置客户端凭据的详细信息。对于本地代理，它应该开箱即用。</p>
</div>
<div class="paragraph">
<p>在服务器端，创建一个Spring Boot应用程序并使用<code>@EnableTurbineStream</code> 。Turbine Stream服务器需要使用Spring Webflux，因此<code>spring-boot-starter-webflux</code>需要包含在您的项目中。默认<code>spring-boot-starter-webflux</code>添加时包含<code>spring-cloud-starter-netflix-turbine-stream</code>到您的应用程序。</p>
</div>
<div class="paragraph">
<p>然后，您可以将Hystrix仪表板指向Turbine Stream Server，而不是指向单个Hystrix流。如果Turbine Stream在myhost的端口8989上运行，则将<code><a href="https://myhost:8989" class="bare">myhost:8989</a></code>在Hystrix仪表板的流输入字段中。电路以其各自的前缀为前缀<code>serviceId</code> ，后跟一个点（ <code>.</code> ），然后是电路名称。</p>
</div>
<div class="paragraph">
<p>Spring Cloud提供了<code>spring-cloud-starter-netflix-turbine-stream</code>具有运行Turbine Stream服务器所需的所有依赖项。然后，您可以添加所选的Stream活页夹-例如<code>spring-cloud-starter-stream-rabbit</code> 。</p>
</div>
<div class="paragraph">
<p>Turbine Stream服务器还支持<code>cluster</code>参数。与Turbine服务器不同，Turbine Stream使用eureka serviceIds作为群集名称，并且这些名称不可配置。</p>
</div>
<div class="paragraph">
<p>如果Turbine Stream服务器正在端口8989上运行<code>my.turbine.server</code>并且您有两个eureka serviceIds <code>customers</code>和<code>products</code>在您的环境中，以下URL将在您的Turbine Stream服务器上可用。 <code>default</code>空集群名称将提供Turbine Stream服务器接收的所有指标。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>https://my.turbine.sever:8989/turbine.stream?cluster=customers
https://my.turbine.sever:8989/turbine.stream?cluster=products
https://my.turbine.sever:8989/turbine.stream?cluster=default
https://my.turbine.sever:8989/turbine.stream</pre>
</div>
</div>
<div class="paragraph">
<p>因此，您可以将eureka serviceIds用作Turbine仪表板（或任何兼容的仪表板）的群集名称。您不需要配置任何属性，例如<code>turbine.appConfig</code> ， <code>turbine.clusterNameExpression</code>和<code>turbine.aggregator.clusterConfig</code>用于您的Turbine Stream服务器。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Turbine Stream服务器使用Spring Cloud Stream从配置的输入通道收集所有指标。这意味着它不会从每个实例主动收集Hystrix指标。它只能提供每个实例已经收集到输入通道中的度量。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-ribbon"><a class="anchor" href="#spring-cloud-ribbon"></a> <a class="link" href="#spring-cloud-ribbon">5.7。客户端负载均衡器：功能区</a></h3>
<div class="paragraph">
<p>Ribbon是客户端负载平衡器，可让您对HTTP和TCP客户端的行为进行大量控制。Feign已在使用Ribbon，因此，如果您使用<code>@FeignClient</code> ，本节也适用。</p>
</div>
<div class="paragraph">
<p>Ribbon中的中心概念是指定客户端的概念。每个负载平衡器都是组件的一部分，这些组件可以一起工作以按需联系远程服务器，并且该组件的名称是您作为应用程序开发人员提供的（例如，通过使用<code>@FeignClient</code>注解）。随需应变，Spring Cloud会创建一个新的集成<code>ApplicationContext</code>通过使用每个命名客户端<code>RibbonClientConfiguration</code> 。其中包括（除其他事项外） <code>ILoadBalancer</code> ， 一种<code>RestClient</code>和<code>ServerListFilter</code> 。</p>
</div>
<div class="sect3">
<h4 id="netflix-ribbon-starter"><a class="anchor" href="#netflix-ribbon-starter"></a> <a class="link" href="#netflix-ribbon-starter">5.7.1。如何包括功能区</a></h4>
<div class="paragraph">
<p>要将Ribbon包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID为<code>spring-cloud-starter-netflix-ribbon</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-the-ribbon-client"><a class="anchor" href="#customizing-the-ribbon-client"></a> <a class="link" href="#customizing-the-ribbon-client">5.7.2。自定义功能区客户端</a></h4>
<div class="paragraph">
<p>您可以使用以下命令中的外部属性来配置功能区客户端的一些位<code><client>.ribbon.*</code> ，除了可以使用Spring Boot配置文件之外，与本地使用Netflix API相似。可以将本机选项作为静态字段进行检查<a href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java"><code>CommonClientConfigKey</code></a> （色带芯的一部分）。</p>
</div>
<div class="paragraph">
<p>Spring Cloud还允许您通过声明其他配置（在<code>RibbonClientConfiguration</code> ）使用<code>@RibbonClient</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@RibbonClient(name = "custom", configuration = CustomConfiguration.class)
public class TestConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，客户端由已经存在的组件组成<code>RibbonClientConfiguration</code> ，以及任何<code>CustomConfiguration</code> （后者通常会覆盖前者）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">的<code>CustomConfiguration</code> clas一定是<code>@Configuration</code>类，但要注意它不在<code>@ComponentScan</code>用于主要应用程序上下文。否则，它会被所有<code>@RibbonClients</code> 。如果您使用<code>@ComponentScan</code> （要么<code>@SpringBootApplication</code> ），则需要采取措施避免将其包含在内（例如，您可以将其放在单独的，不重叠的程序包中，或指定要在其中明确扫描的程序包） <code>@ComponentScan</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下表显示了Spring Cloud Netflix默认为Ribbon提供的bean：</p>
</div>
<table class="tableblock frame-topbot grid-all" style="width:60%">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">豆类型</th>
<th class="tableblock halign-center valign-top">豆名</th>
<th class="tableblock halign-center valign-top">班级名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IClientConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonClientConfig</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultClientConfigImpl</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IRule</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonRule</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ZoneAvoidanceRule</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IPing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonPing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DummyPing</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerList<Server></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonServerList</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConfigurationBasedServerList</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerListFilter<Server></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonServerListFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ZonePreferenceServerListFilter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ILoadBalancer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonLoadBalancer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ZoneAwareLoadBalancer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerListUpdater</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ribbonServerListUpdater</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PollingServerListUpdater</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>创建其中一种类型的Bean并将其放置在<code>@RibbonClient</code>配置（例如<code>FooConfiguration</code>如上所示），您可以覆盖所描述的每个bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration(proxyBeanMethods = false)
protected static class FooConfiguration {

    @Bean
    public ZonePreferenceServerListFilter serverListFilter() {
        ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter();
        filter.setZone("myTestZone");
        return filter;
    }

    @Bean
    public IPing ribbonPing() {
        return new PingUrl();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的include语句替换<code>NoOpPing</code>与<code>PingUrl</code>并提供自定义<code>serverListFilter</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-the-default-for-all-ribbon-clients"><a class="anchor" href="#customizing-the-default-for-all-ribbon-clients"></a> <a class="link" href="#customizing-the-default-for-all-ribbon-clients">5.7.3。为所有功能区客户端自定义默认值</a></h4>
<div class="paragraph">
<p>通过使用以下命令，可以为所有功能区客户端提供默认配置： <code>@RibbonClients</code>注释并注册默认配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)
public class RibbonClientDefaultConfigurationTestsConfig {

    public static class BazServiceList extends ConfigurationBasedServerList {

        public BazServiceList(IClientConfig config) {
            super.initWithNiwsConfig(config);
        }

    }

}

@Configuration(proxyBeanMethods = false)
class DefaultRibbonConfig {

    @Bean
    public IRule ribbonRule() {
        return new BestAvailableRule();
    }

    @Bean
    public IPing ribbonPing() {
        return new PingUrl();
    }

    @Bean
    public ServerList<Server> ribbonServerList(IClientConfig config) {
        return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config);
    }

    @Bean
    public ServerListSubsetFilter serverListFilter() {
        ServerListSubsetFilter filter = new ServerListSubsetFilter();
        return filter;
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customizing-the-ribbon-client-by-setting-properties"><a class="anchor" href="#customizing-the-ribbon-client-by-setting-properties"></a> <a class="link" href="#customizing-the-ribbon-client-by-setting-properties">5.7.4。通过设置属性来自定义功能区客户端</a></h4>
<div class="paragraph">
<p>从1.2.0版开始，Spring Cloud Netflix现在通过将属性设置为与<a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer">Ribbon文档</a>兼容来支持自定义Ribbon客户端。</p>
</div>
<div class="paragraph">
<p>这使您可以在启动时在不同环境中更改行为。</p>
</div>
<div class="paragraph">
<p>以下列表显示了受支持的属性>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><clientName>.ribbon.NFLoadBalancerClassName</code> ：应实施<code>ILoadBalancer</code></p>
</li>
<li>
<p><code><clientName>.ribbon.NFLoadBalancerRuleClassName</code> ：应实施<code>IRule</code></p>
</li>
<li>
<p><code><clientName>.ribbon.NFLoadBalancerPingClassName</code> ：应实施<code>IPing</code></p>
</li>
<li>
<p><code><clientName>.ribbon.NIWSServerListClassName</code> ：应实施<code>ServerList</code></p>
</li>
<li>
<p><code><clientName>.ribbon.NIWSServerListFilterClassName</code> ：应实施<code>ServerListFilter</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这些属性中定义的类优先于使用定义的bean <code>@RibbonClient(configuration=MyRibbonConfig.class)</code>以及Spring Cloud Netflix提供的默认设置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设置<code>IRule</code>服务名称为<code>users</code> ，您可以设置以下属性：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>users:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</pre>
</div>
</div>
<div class="paragraph">
<p>有关<a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers">功能区</a>提供的实现，请参见<a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers">功能区文档</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-ribbon-with-eureka"><a class="anchor" href="#using-ribbon-with-eureka"></a> <a class="link" href="#using-ribbon-with-eureka">5.7.5。将功能区与Eureka一起使用</a></h4>
<div class="paragraph">
<p>当Eureka与Ribbon结合使用时（也就是说，两者都在类路径上）， <code>ribbonServerList</code>被扩展为<code>DiscoveryEnabledNIWSServerList</code> ，其中填充了Eureka中的服务器列表。它还取代了<code>IPing</code>与<code>NIWSDiscoveryPing</code> ，它委托Eureka确定服务器是否已启动。的<code>ServerList</code>默认情况下安装的是<code>DomainExtractingServerList</code> 。其目的是使元数据可用于负载均衡器，而无需使用AWS AMI元数据（这是Netflix所依赖的）。默认情况下，服务器列表是使用实例元数据中提供的“区域”信息构建的（因此，在远程客户端上， <code>eureka.instance.metadataMap.zone</code> ）。如果缺少，并且<code>approximateZoneFromHostname</code>如果设置了flag，它可以使用服务器主机名中的域名作为区域的代理。区域信息可用后，可以在<code>ServerListFilter</code> 。默认情况下，它用于在与客户端相同的区域中定位服务器，因为默认值为<code>ZonePreferenceServerListFilter</code> 。默认情况下，客户端区域的确定方式与远程实例相同（即，通过<code>eureka.instance.metadataMap.zone</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">设置客户端区域的传统“ archaius”方法是通过名为“ @zone”的配置属性。如果可用，Spring Cloud会优先使用所有其他设置（请注意，密钥必须在YAML配置中用引号引起来）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果没有其他区域数据源，则根据客户端配置（而不是实例配置）进行猜测。我们采取<code>eureka.client.availabilityZones</code> ，这是从区域名称到区域列表的映射，并为实例自己的区域拉出第一个区域（即<code>eureka.client.region</code> ，默认为“ us-east-1”，以与本机Netflix兼容）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-ribbon-without-eureka"><a class="anchor" href="#spring-cloud-ribbon-without-eureka"></a> <a class="link" href="#spring-cloud-ribbon-without-eureka">5.7.6。示例：如何在没有尤里卡的情况下使用色带</a></h4>
<div class="paragraph">
<p>Eureka是一种抽象发现远程服务器的便捷方法，因此您不必在客户端中对它们的URL进行硬编码。但是，如果您不想使用Eureka，Ribbon和Feign也可以使用。假设您已经声明了<code>@RibbonClient</code>用于“商店”，并且Eureka未被使用（甚至不在类路径上）。功能区客户端默认为配置的服务器列表。您可以提供以下配置：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>stores:
  ribbon:
    listOfServers: example.com,google.com</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-disable-eureka-use-in-ribbon"><a class="anchor" href="#example-disable-eureka-use-in-ribbon"></a> <a class="link" href="#example-disable-eureka-use-in-ribbon">5.7.7。示例：禁用功能区中的尤里卡使用</a></h4>
<div class="paragraph">
<p>设置<code>ribbon.eureka.enabled</code>财产<code>false</code>明确禁用在功能区中使用Eureka，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>ribbon:
  eureka:
   enabled: false</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-the-ribbon-api-directly"><a class="anchor" href="#using-the-ribbon-api-directly"></a> <a class="link" href="#using-the-ribbon-api-directly">5.7.8。直接使用功能区API</a></h4>
<div class="paragraph">
<p>您也可以使用<code>LoadBalancerClient</code>直接，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyClass {
    @Autowired
    private LoadBalancerClient loadBalancer;

    public void doStuff() {
        ServiceInstance instance = loadBalancer.choose("stores");
        URI storesUri = URI.create(String.format("https://%s:%s", instance.getHost(), instance.getPort()));
        // ... do something with the URI
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ribbon-child-context-eager-load"><a class="anchor" href="#ribbon-child-context-eager-load"></a> <a class="link" href="#ribbon-child-context-eager-load">5.7.9。缓存功能区配置</a></h4>
<div class="paragraph">
<p>每个名为Ribbon的客户端都有一个Spring Cloud维护的相应子应用程序上下文。此应用程序上下文在对命名客户端的第一个请求上延迟加载。通过指定功能区客户端的名称，可以更改此延迟加载行为，以代替在启动时急于加载这些子应用程序上下文，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>ribbon:
  eager-load:
    enabled: true
    clients: client1, client2, client3</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-configure-hystrix-thread-pools"><a class="anchor" href="#how-to-configure-hystrix-thread-pools"></a> <a class="link" href="#how-to-configure-hystrix-thread-pools">5.7.10。如何配置Hystrix线程池</a></h4>
<div class="paragraph">
<p>如果你改变<code>zuul.ribbonIsolationStrategy</code>至<code>THREAD</code> ，Hystrix的线程隔离策略用于所有路由。在这种情况下， <code>HystrixThreadPoolKey</code>被设定为<code>RibbonCommand</code>作为默认值。这意味着所有路由的HystrixCommands在同一个Hystrix线程池中执行。可以使用以下配置更改此行为：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>zuul:
  threadPool:
    useSeparateThreadPools: true</pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例导致在Hystrix线程池中为每个路由执行HystrixCommands。</p>
</div>
<div class="paragraph">
<p>在这种情况下，默认<code>HystrixThreadPoolKey</code>与每个路由的服务ID相同。为添加前缀<code>HystrixThreadPoolKey</code> ，设定<code>zuul.threadPool.threadPoolKeyPrefix</code>到要添加的值，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>zuul:
  threadPool:
    useSeparateThreadPools: true
    threadPoolKeyPrefix: zuulgw</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-provdie-a-key-to-ribbon"><a class="anchor" href="#how-to-provdie-a-key-to-ribbon"></a> <a class="link" href="#how-to-provdie-a-key-to-ribbon">5.7.11。如何提供功能区的密钥<code>IRule</code></a></h4>
<div class="paragraph">
<p>如果您需要提供自己的<code>IRule</code>实现以处理诸如“ canary”测试之类的特殊路由要求，将一些信息传递给<code>choose</code>的方法<code>IRule</code> 。</p>
</div>
<div class="listingblock">
<div class="title">com.netflix.loadbalancer。IRule.java</div>
<div class="content">
<pre>public interface IRule{
    public Server choose(Object key);
         :</pre>
</div>
</div>
<div class="paragraph">
<p>您可以提供一些您的使用信息<code>IRule</code>实现以选择目标服务器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RequestContext.getCurrentContext()
              .set(FilterConstants.LOAD_BALANCER_KEY, "canary-test");</pre>
</div>
</div>
<div class="paragraph">
<p>如果您将任何物体放入<code>RequestContext</code>的关键<code>FilterConstants.LOAD_BALANCER_KEY</code> ，它将传递给<code>choose</code>的方法<code>IRule</code>实施。前面示例中显示的代码必须在执行之前<code>RibbonRoutingFilter</code>被执行。Zuul的前置过滤器是执行此操作的最佳位置。您可以通过以下方式访问HTTP标头和查询参数<code>RequestContext</code>在预过滤器中，因此可以用来确定<code>LOAD_BALANCER_KEY</code>传递给功能区。如果您不重视任何<code>LOAD_BALANCER_KEY</code>在<code>RequestContext</code> ，则将null作为参数传递给<code>choose</code>方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="external-configuration-archaius"><a class="anchor" href="#external-configuration-archaius"></a> <a class="link" href="#external-configuration-archaius">5.8。外部配置：Archaius</a></h3>
<div class="paragraph">
<p><a href="https://github.com/Netflix/archaius">Archaius</a>是Netflix客户端配置库。它是所有Netflix OSS组件用于配置的库。Archaius是<a href="https://commons.apache.org/proper/commons-configuration">Apache Commons Configuration</a>项目的扩展。它可以通过轮询源以进行更改或通过将源将更改推送到客户端来更新配置。Archaius使用动态<type>属性类作为属性的句柄，如以下示例所示：</type></p>
</div>
<div class="listingblock">
<div class="title">Archaius示例</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ArchaiusTest {
    DynamicStringProperty myprop = DynamicPropertyFactory
            .getInstance()
            .getStringProperty("my.prop");

    void doSomething() {
        OtherClass.someMethod(myprop.get());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Archaius具有自己的一组配置文件和加载优先级。Spring应用程序通常不应该直接使用Archaius，但是仍然需要本地配置Netflix工具。Spring Cloud具有一个Spring Environment Bridge，以便Archaius可以从Spring Environment中读取属性。该桥允许Spring Boot项目使用常规配置工具链，同时允许它们按记录的方式配置Netflix工具（大部分情况下）。</p>
</div>
</div>
<div class="sect2">
<h3 id="router-and-filter-zuul"><a class="anchor" href="#router-and-filter-zuul"></a> <a class="link" href="#router-and-filter-zuul">5.9。路由器和过滤器：Zuul</a></h3>
<div class="paragraph">
<p>路由是微服务架构不可或缺的一部分。例如， <code>/</code>可能会映射到您的Web应用程序， <code>/api/users</code>映射到用户服务，并且<code>/api/shop</code>映射到商店服务。
<a href="https://github.com/Netflix/zuul">Zuul</a>是Netflix的基于JVM的路由器和服务器端负载平衡器。</p>
</div>
<div class="paragraph">
<p><a href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27">Netflix将Zuul</a>用于以下<a href="https://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27">用途</a> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>认证方式</p>
</li>
<li>
<p>见解</p>
</li>
<li>
<p>压力测试</p>
</li>
<li>
<p>金丝雀测试</p>
</li>
<li>
<p>动态路由</p>
</li>
<li>
<p>服务迁移</p>
</li>
<li>
<p>减载</p>
</li>
<li>
<p>安全</p>
</li>
<li>
<p>静态响应处理</p>
</li>
<li>
<p>主动/主动流量管理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Zuul的规则引擎使规则和过滤器基本上可以用任何JVM语言编写，并具有对Java和Groovy的内置支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">配置属性<code>zuul.max.host.connections</code>已被两个新属性取代， <code>zuul.host.maxTotalConnections</code>和<code>zuul.host.maxPerRouteConnections</code> ，分别默认为200和20。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认的Hystrix隔离模式（ <code>ExecutionIsolationStrategy</code> ）的所有路线是<code>SEMAPHORE</code> 。
<code>zuul.ribbonIsolationStrategy</code>可以更改为<code>THREAD</code>如果首选该隔离模式。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="netflix-zuul-starter"><a class="anchor" href="#netflix-zuul-starter"></a> <a class="link" href="#netflix-zuul-starter">5.9.1。如何包含Zuul</a></h4>
<div class="paragraph">
<p>要将Zuul包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID为<code>spring-cloud-starter-netflix-zuul</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="netflix-zuul-reverse-proxy"><a class="anchor" href="#netflix-zuul-reverse-proxy"></a> <a class="link" href="#netflix-zuul-reverse-proxy">5.9.2。嵌入式Zuul反向代理</a></h4>
<div class="paragraph">
<p>Spring Cloud创建了嵌入式Zuul代理，以简化UI应用程序要对一个或多个后端服务进行代理调用的常见用例的开发。此功能对于用户界面代理所需的后端服务很有用，从而避免了为所有后端独立管理CORS和身份验证问题的需求。</p>
</div>
<div class="paragraph">
<p>要启用它，用<code>@EnableZuulProxy</code> 。这样做会导致将本地呼叫转发到适当的服务。按照惯例，ID为<code>users</code>从位于以下位置的代理接收请求<code>/users</code> （去除前缀）。代理使用功能区来定位要通过发现转发到的实例。所有请求均在<a href="#hystrix-fallbacks-for-routes">hystrix命令</a>中执行，因此失败会显示在Hystrix指标中。一旦电路断开，代理就不会尝试与服务联系。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Zuul启动程序不包括发现客户端，因此，对于基于服务ID的路由，您还需要在类路径上提供其中之一（Eureka是一种选择）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要跳过自动添加服务的过程，请设置<code>zuul.ignored-services</code>服务ID模式列表。如果服务与被忽略但已包含在显式配置的路由映射中的模式匹配，则将其忽略，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  ignoredServices: '*'
  routes:
    users: /myusers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，所有服务均被忽略， <strong>除了</strong> <code>users</code> 。</p>
</div>
<div class="paragraph">
<p>要增加或更改代理路由，可以添加外部配置，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users: /myusers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例意味着HTTP调用<code>/myusers</code>前进到<code>users</code>服务（例如<code>/myusers/101</code>转发给<code>/101</code> ）。</p>
</div>
<div class="paragraph">
<p>要对路由进行更细粒度的控制，可以分别指定路径和serviceId，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      serviceId: users_service</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例意味着HTTP调用<code>/myusers</code>前进到<code>users_service</code>服务。该路线必须有一个<code>path</code>可以指定为蚂蚁风格的图案<code>/myusers/*</code>只匹配一个级别，但是<code>/myusers/**</code>分层匹配。</p>
</div>
<div class="paragraph">
<p>后端的位置可以指定为<code>serviceId</code> （用于发现服务）或<code>url</code> （针对实际位置），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      url: https://example.com/users_service</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些简单的网址路由不会作为<code>HystrixCommand</code> ，也不会使用功能区对多个URL进行负载均衡。要实现这些目标，您可以指定一个<code>serviceId</code>具有静态服务器列表，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">zuul:
  routes:
    echo:
      path: /myusers/**
      serviceId: myusers-service
      stripPrefix: true

hystrix:
  command:
    myusers-service:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: ...

myusers-service:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList
    listOfServers: https://example1.com,http://example2.com
    ConnectTimeout: 1000
    ReadTimeout: 3000
    MaxTotalHttpConnections: 500
    MaxConnectionsPerHost: 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是指定服务路由并为<code>serviceId</code> （这样做需要在Ribbon中禁用Eureka支持- <a href="#spring-cloud-ribbon-without-eureka">有关更多信息</a> ，请参见<a href="#spring-cloud-ribbon-without-eureka">上文</a> ），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">zuul:
  routes:
    users:
      path: /myusers/**
      serviceId: users

ribbon:
  eureka:
    enabled: false

users:
  ribbon:
    listOfServers: example.com,google.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在<code>serviceId</code>和路线使用<code>regexmapper</code> 。它使用正则表达式命名组从中提取变量<code>serviceId</code>并将它们注入到路由模式中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">ApplicationConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public PatternServiceRouteMapper serviceRouteMapper() {
    return new PatternServiceRouteMapper(
        "(?<name>^.+)-(?<version>v.+$)",
        "${version}/${name}");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例表示<code>serviceId</code>的<code>myusers-v1</code>映射到路线<code>/v1/myusers/**</code> 。可以接受任何正则表达式，但是所有命名组都必须同时存在<code>servicePattern</code>和<code>routePattern</code> 。如果<code>servicePattern</code>与不符<code>serviceId</code> ，则使用默认行为。在前面的示例中， <code>serviceId</code>的<code>myusers</code>映射到“ / myusers / **”路由（未检测到版本）。默认情况下，此功能是禁用的，仅适用于发现的服务。</p>
</div>
<div class="paragraph">
<p>要为所有映射添加前缀，请设置<code>zuul.prefix</code>到一个值，例如<code>/api</code> 。默认情况下，代理前缀会从请求中剥离，然后再转发请求（您可以通过以下方式关闭此行为： <code>zuul.stripPrefix=false</code> ）。您还可以关闭从单个路由中剥离特定于服务的前缀，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      stripPrefix: false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>zuul.stripPrefix</code>仅适用于中设置的前缀<code>zuul.prefix</code> 。它对给定路由的内部定义的前缀没有任何影响<code>path</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>/myusers/101</code>转发给<code>/myusers/101</code>在<code>users</code>服务。</p>
</div>
<div class="paragraph">
<p>的<code>zuul.routes</code>条目实际上绑定到类型的对象<code>ZuulProperties</code> 。如果您查看该对象的属性，则可以看到它还有一个<code>retryable</code>旗。将该标志设置为<code>true</code>使功能区客户端自动重试失败的请求。您也可以将该标志设置为<code>true</code>当您需要修改使用功能区客户端配置的重试操作的参数时。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>X-Forwarded-Host</code>标头已添加到转发的请求中。要关闭它，设置<code>zuul.addProxyHeaders = false</code> 。默认情况下，前缀路径被剥离，并且对后端的请求接收到一个<code>X-Forwarded-Prefix</code>标头（ <code>/myusers</code>在前面显示的示例中）。</p>
</div>
<div class="paragraph">
<p>如果您设置默认路线（ <code>/</code> ），具有<code>@EnableZuulProxy</code>可以充当独立服务器。例如， <code>zuul.route.home: /</code>会将所有流量（“ / **”）路由到“家庭”服务。</p>
</div>
<div class="paragraph">
<p>如果需要更细粒度的忽略，则可以指定要忽略的特定模式。这些模式在路线定位过程开始时进行评估，这意味着模式中应包含前缀以保证匹配。被忽略的模式跨越所有服务，并取代任何其他路由规范。以下示例显示了如何创建忽略的模式：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  ignoredPatterns: /**/admin/**
  routes:
    users: /myusers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例表示所有调用（例如<code>/myusers/101</code> ）转发给<code>/101</code>在<code>users</code>服务。但是，通话包括<code>/admin/</code>不解决。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果您需要保留路线的顺序，则需要使用YAML文件，因为使用属性文件时顺序会丢失。以下示例显示了这样的YAML文件：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
    legacy:
      path: /**</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要使用属性文件，则<code>legacy</code>路径可能会终止于<code>users</code>路径，呈现<code>users</code>路径无法到达。</p>
</div>
</div>
<div class="sect3">
<h4 id="zuul-http-client"><a class="anchor" href="#zuul-http-client"></a> <a class="link" href="#zuul-http-client">5.9.3。Zuul Http客户端</a></h4>
<div class="paragraph">
<p>Zuul使用的默认HTTP客户端现在由Apache HTTP客户端（而不是已弃用的功能区）支持<code>RestClient</code> 。使用<code>RestClient</code>要么<code>okhttp3.OkHttpClient</code> ，设定<code>ribbon.restclient.enabled=true</code>要么<code>ribbon.okhttp.enabled=true</code> ， 分别。如果要自定义Apache HTTP客户端或OK HTTP客户端，请提供以下类型的Bean： <code>ClosableHttpClient</code>要么<code>OkHttpClient</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="cookies-and-sensitive-headers"><a class="anchor" href="#cookies-and-sensitive-headers"></a> <a class="link" href="#cookies-and-sensitive-headers">5.9.4。Cookie和敏感标题</a></h4>
<div class="paragraph">
<p>您可以在同一系统中的服务之间共享标头，但是您可能不希望敏感标头泄漏到下游到外部服务器中。您可以在路由配置中指定忽略的标头列表。Cookies发挥着特殊的作用，因为它们在浏览器中具有定义明确的语义，并且始终将它们视为敏感内容。如果代理的使用者是浏览器，那么下游服务的cookie也会给用户带来问题，因为它们都混杂在一起（所有下游服务看起来都来自同一位置）。</p>
</div>
<div class="paragraph">
<p>如果您对服务的设计很谨慎（例如，如果只有一个下游服务设置cookie），则可以让它们从后端一直流到调用者。另外，如果您的代理设置cookie，并且所有后端服务都在同一系统中，则很自然地简单地共享它们（例如，使用Spring Session将它们链接到某些共享状态）。除此之外，由下游服务设置的任何cookie可能对调用者都无用，因此建议您（至少）进行<code>Set-Cookie</code>和<code>Cookie</code>放入不属于您域的路由的敏感标头中。即使对于属于您域的路由，也要在让Cookie与代理之间流动之前，仔细考虑其含义。</p>
</div>
<div class="paragraph">
<p>可以将敏感头配置为每个路由的逗号分隔列表，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      sensitiveHeaders: Cookie,Set-Cookie,Authorization
      url: https://downstream</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这是默认值<code>sensitiveHeaders</code> ，因此除非您希望它与众不同，否则无需进行设置。这是Spring Cloud Netflix 1.1中的新功能（在1.0中，用户无法控制标题，并且所有cookie都双向流动）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>sensitiveHeaders</code>是黑名单，默认值不为空。因此，要让Zuul发送所有标头（ <code>ignored</code> ），则必须将其明确设置为空列表。如果要将Cookie或授权标头传递到后端，则必须这样做。以下示例显示了如何使用<code>sensitiveHeaders</code> ：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    users:
      path: /myusers/**
      sensitiveHeaders:
      url: https://downstream</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以通过设置<code>zuul.sensitiveHeaders</code> 。如果<code>sensitiveHeaders</code>在路线上设置，它将覆盖全局<code>sensitiveHeaders</code>设置。</p>
</div>
</div>
<div class="sect3">
<h4 id="ignored-headers"><a class="anchor" href="#ignored-headers"></a> <a class="link" href="#ignored-headers">5.9.5。忽略标题</a></h4>
<div class="paragraph">
<p>除了路由敏感标头之外，您还可以设置一个名为<code>zuul.ignoredHeaders</code>与下游服务交互期间应丢弃的值（请求和响应）。默认情况下，如果Spring Security不在类路径中，则它们为空。否则，它们将初始化为一组由Spring Security指定的众所周知的“安全”标头（例如，涉及缓存）。在这种情况下，假设下游服务也可以添加这些标头，但是我们需要来自代理的值。要在Spring Security位于类路径上时不丢弃这些众所周知的安全标头，可以设置<code>zuul.ignoreSecurityHeaders</code>至<code>false</code> 。如果您在Spring Security中禁用了HTTP Security响应标头并需要下游服务提供的值，则这样做很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="management-endpoints"><a class="anchor" href="#management-endpoints"></a> <a class="link" href="#management-endpoints">5.9.6。管理端点</a></h4>
<div class="paragraph">
<p>默认情况下，如果您使用<code>@EnableZuulProxy</code>使用Spring Boot Actuator，可以启用两个附加端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>路线</p>
</li>
<li>
<p>筛选器</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="routes-endpoint"><a class="anchor" href="#routes-endpoint"></a> <a class="link" href="#routes-endpoint">路线终点</a></h5>
<div class="paragraph">
<p>GET到路由端点<code>/routes</code>返回已映射路由的列表：</p>
</div>
<div class="listingblock">
<div class="title">GET /路线</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  /stores/**: "http://localhost:8081"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过添加其他路线详细信息来请求<code>?format=details</code>查询字符串<code>/routes</code> 。这样做会产生以下输出：</p>
</div>
<div class="listingblock">
<div class="title">GET /路线/细节</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "/stores/**": {
    "id": "stores",
    "fullPath": "/stores/**",
    "location": "http://localhost:8081",
    "path": "/**",
    "prefix": "/stores",
    "retryable": false,
    "customSensitiveHeaders": false,
    "prefixStripped": true
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种<code>POST</code>至<code>/routes</code>强制刷新现有路由（例如，服务目录中发生更改时）。您可以通过设置禁用此端点<code>endpoints.routes.enabled</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">路由应自动响应服务目录中的更改，但是<code>POST</code>至<code>/routes</code>是一种迫使更改立即发生的方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="filters-endpoint"><a class="anchor" href="#filters-endpoint"></a> <a class="link" href="#filters-endpoint">过滤端点</a></h5>
<div class="paragraph">
<p>一种<code>GET</code>到位于的过滤器端点<code>/filters</code>按类型返回Zuul过滤器的地图。对于地图中的每种过滤器类型，您将获得该类型的所有过滤器的列表以及它们的详细信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="strangulation-patterns-and-local-forwards"><a class="anchor" href="#strangulation-patterns-and-local-forwards"></a> <a class="link" href="#strangulation-patterns-and-local-forwards">5.9.7。勒索模式和本地前锋</a></h4>
<div class="paragraph">
<p>迁移现有应用程序或API时，常见的模式是“勒死”旧的端点，并用不同的实现方式慢慢替换它们。Zuul代理是一个有用的工具，因为您可以使用它来处理来自旧端点客户端的所有流量，但可以将某些请求重定向到新请求。</p>
</div>
<div class="paragraph">
<p>以下示例显示“扼杀”方案的配置详细信息：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    first:
      path: /first/**
      url: https://first.example.com
    second:
      path: /second/**
      url: forward:/second
    third:
      path: /third/**
      url: forward:/3rd
    legacy:
      path: /**
      url: https://legacy.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们扼杀了“旧版”应用程序，该应用程序映射到与其他模式之一不匹配的所有请求。中的路径<code>/first/**</code>已使用外部URL提取到新服务中。中的路径<code>/second/**</code>被转发，以便可以在本地处理（例如，使用正常的Spring <code>@RequestMapping</code> ）。中的路径<code>/third/**</code>也被转发，但前缀不同（ <code>/third/foo</code>转发给<code>/3rd/foo</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">被忽略的模式不会被完全忽略，它们不会由代理处理（因此它们也可以在本地有效转发）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="uploading-files-through-zuul"><a class="anchor" href="#uploading-files-through-zuul"></a> <a class="link" href="#uploading-files-through-zuul">5.9.8。通过Zuul上传文件</a></h4>
<div class="paragraph">
<p>如果您使用<code>@EnableZuulProxy</code> ，您可以使用代理路径上传文件，只要文件很小，它就可以正常工作。对于大文件，有一个替代路径可以绕过Spring <code>DispatcherServlet</code> （以避免多部分处理）在“ / zuul / *”中。换句话说，如果您有<code>zuul.routes.customers=/customers/**</code> ， 那么你也能<code>POST</code>大文件<code>/zuul/customers/*</code> 。servlet路径通过以下方式外部化<code>zuul.servletPath</code> 。如果代理路由带您通过功能区负载平衡器，则极大的文件也需要提高的超时设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000
ribbon:
  ConnectTimeout: 3000
  ReadTimeout: 60000</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，要使流技术处理大型文件，您需要在请求中使用分块编码（某些浏览器默认不这样做），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ curl -v -H "Transfer-Encoding: chunked" \
    -F "file=@mylarge.iso" localhost:9999/zuul/simple/file</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="query-string-encoding"><a class="anchor" href="#query-string-encoding"></a> <a class="link" href="#query-string-encoding">5.9.9。查询字符串编码</a></h4>
<div class="paragraph">
<p>在处理传入请求时，对查询参数进行解码，以便可以在Zuul过滤器中进行修改。然后将它们重新编码，在路由过滤器中重建后端请求。如果（例如）使用Javascript的编码，则结果可能不同于原始输入<code>encodeURIComponent()</code>方法。尽管这在大多数情况下不会引起问题，但某些Web服务器可能对复杂查询字符串的编码很挑剔。</p>
</div>
<div class="paragraph">
<p>要强制使用查询字符串的原始编码，可以将特殊标志传递给<code>ZuulProperties</code>以便查询字符串与<code>HttpServletRequest::getQueryString</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  forceOriginalQueryStringEncoding: true</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此特殊标志仅适用于<code>SimpleHostRoutingFilter</code> 。此外，您失去了使用以下命令轻松覆盖查询参数的功能<code>RequestContext.getCurrentContext().setRequestQueryParams(someOverriddenParameters)</code> ，因为现在直接在原始字符串中获取查询字符串<code>HttpServletRequest</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="request-uri-encoding"><a class="anchor" href="#request-uri-encoding"></a> <a class="link" href="#request-uri-encoding">5.9.10。请求URI编码</a></h4>
<div class="paragraph">
<p>处理传入请求时，在将请求URI与路由匹配之前，先对其进行解码。然后在路由过滤器中重建后端请求时，将对请求URI进行重新编码。如果您的URI包含编码的“ /”字符，则可能导致某些意外行为。</p>
</div>
<div class="paragraph">
<p>要使用原始请求URI，可以向'ZuulProperties'传递一个特殊标志，以便URI可以与<code>HttpServletRequest::getRequestURI</code>方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  decodeUrl: false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用覆盖请求URI <code>requestURI</code> RequestContext属性，并且此标志设置为false，则不会对在请求上下文中设置的URL进行编码。确保URL已被编码是您的责任。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="plain-embedded-zuul"><a class="anchor" href="#plain-embedded-zuul"></a> <a class="link" href="#plain-embedded-zuul">5.9.11。纯色嵌入式Zuul</a></h4>
<div class="paragraph">
<p>如果您使用<code>@EnableZuulServer</code> （代替<code>@EnableZuulProxy</code> ），您也可以运行Zuul服务器而无需代理或有选择地打开代理平台的某些部分。您添加到类型为的应用程序中的所有bean <code>ZuulFilter</code>会自动安装（与<code>@EnableZuulProxy</code> ），但不会自动添加任何代理过滤器。</p>
</div>
<div class="paragraph">
<p>在这种情况下，仍然可以通过配置“ zuul.routes。*”来指定进入Zuul服务器的路由，但是没有服务发现也没有代理。因此，“ serviceId”和“ url”设置将被忽略。以下示例将“ / api / **”中的所有路径映射到Zuul过滤器链：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"> zuul:
  routes:
    api: /api/**</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="disable-zuul-filters"><a class="anchor" href="#disable-zuul-filters"></a> <a class="link" href="#disable-zuul-filters">5.9.12。禁用Zuul过滤器</a></h4>
<div class="paragraph">
<p>Zuul for Spring Cloud附带了许多<code>ZuulFilter</code>在代理和服务器模式下默认启用的bean。有关可启用的过滤器列表，请参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-zuul/src/main/java/org/springframework/cloud/netflix/zuul/filters">Zuul过滤器包</a> 。如果要禁用一个，请设置<code>zuul.<SimpleClassName>.<filterType>.disable=true</code> 。按照惯例，包装后<code>filters</code>是Zuul过滤器类型。例如禁用<code>org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code> ，设定<code>zuul.SendResponseFilter.post.disable=true</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="hystrix-fallbacks-for-routes"><a class="anchor" href="#hystrix-fallbacks-for-routes"></a> <a class="link" href="#hystrix-fallbacks-for-routes">5.9.13。提供路线的Hystrix后备</a></h4>
<div class="paragraph">
<p>当Zuul中给定路线的电路发生跳闸时，您可以通过创建一个类型为bean的bean提供回退响应<code>FallbackProvider</code> 。在此Bean中，您需要指定备用的路由ID，并提供一个<code>ClientHttpResponse</code>返回作为后备。下面的例子展示了一个相对简单的<code>FallbackProvider</code>实施：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyFallbackProvider implements FallbackProvider {

    @Override
    public String getRoute() {
        return "customers";
    }

    @Override
    public ClientHttpResponse fallbackResponse(String route, final Throwable cause) {
        if (cause instanceof HystrixTimeoutException) {
            return response(HttpStatus.GATEWAY_TIMEOUT);
        } else {
            return response(HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    private ClientHttpResponse response(final HttpStatus status) {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return status;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return status.value();
            }

            @Override
            public String getStatusText() throws IOException {
                return status.getReasonPhrase();
            }

            @Override
            public void close() {
            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了上一个示例的路由配置可能如何显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">zuul:
  routes:
    customers: /customers/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想为所有路由提供默认回退，则可以创建一个类型为的bean <code>FallbackProvider</code>并拥有<code>getRoute</code>方法返回<code>*</code>要么<code>null</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyFallbackProvider implements FallbackProvider {
    @Override
    public String getRoute() {
        return "*";
    }

    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable throwable) {
        return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.OK;
            }

            @Override
            public int getRawStatusCode() throws IOException {
                return 200;
            }

            @Override
            public String getStatusText() throws IOException {
                return "OK";
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream("fallback".getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zuul-timeouts"><a class="anchor" href="#zuul-timeouts"></a> <a class="link" href="#zuul-timeouts">5.9.14。Zuul超时</a></h4>
<div class="paragraph">
<p>如果要为通过Zuul代理的请求配置套接字超时和读取超时，则根据您的配置，有两个选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果Zuul使用服务发现，则需要使用以下命令配置这些超时<code>ribbon.ReadTimeout</code>和<code>ribbon.SocketTimeout</code>功能区属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果通过指定URL配置了Zuul路由，则需要使用<code>zuul.host.connect-timeout-millis</code>和<code>zuul.host.socket-timeout-millis</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="zuul-redirect-location-rewrite"><a class="anchor" href="#zuul-redirect-location-rewrite"></a> <a class="link" href="#zuul-redirect-location-rewrite">5.9.15。改写<code>Location</code>标头</a></h4>
<div class="paragraph">
<p>如果Zuul正在使用Web应用程序，则可能需要重新编写<code>Location</code> Web应用程序通过HTTP状态代码重定向时的标头<code>3XX</code> 。否则，浏览器将重定向到Web应用程序的URL，而不是Zuul URL。您可以配置<code>LocationRewriteFilter</code> Zuul过滤器重新编写<code>Location</code> Zuul网址的标头。它还添加回去的全局前缀和特定于路由的前缀。以下示例通过使用Spring Configuration文件添加过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.springframework.cloud.netflix.zuul.filters.post.LocationRewriteFilter;
...

@Configuration
@EnableZuulProxy
public class ZuulConfig {
    @Bean
    public LocationRewriteFilter locationRewriteFilter() {
        return new LocationRewriteFilter();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">小心使用此过滤器。过滤器作用于<code>Location</code> ALL的标题<code>3XX</code>响应代码，可能不适用于所有情况，例如在将用户重定向到外部URL时。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="enabling-cross-origin-requests"><a class="anchor" href="#enabling-cross-origin-requests"></a> <a class="link" href="#enabling-cross-origin-requests">5.9.16。启用跨源请求</a></h4>
<div class="paragraph">
<p>默认情况下，Zuul将所有跨源请求（CORS）路由到服务。如果您想让Zuul处理这些请求，可以通过提供自定义来完成<code>WebMvcConfigurer</code>豆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public WebMvcConfigurer corsConfigurer() {
    return new WebMvcConfigurer() {
        public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping("/path-1/**")
                    .allowedOrigins("https://allowed-origin.com")
                    .allowedMethods("GET", "POST");
        }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，我们允许<code>GET</code>和<code>POST</code>来自的方法<code><a href="https://allowed-origin.com" class="bare">allowed-origin.com</a></code>将跨域请求发送到以<code>path-1</code> 。您可以使用以下方式将CORS配置应用于特定的路径模式或整个应用程序的全局路径<code>/**</code>映射。您可以自定义属性： <code>allowedOrigins</code> ， <code>allowedMethods</code> ， <code>allowedHeaders</code> ， <code>exposedHeaders</code> ， <code>allowCredentials</code>和<code>maxAge</code>通过此配置。</p>
</div>
</div>
<div class="sect3">
<h4 id="metrics"><a class="anchor" href="#metrics"></a> <a class="link" href="#metrics">5.9.17。指标</a></h4>
<div class="paragraph">
<p>Zuul将在执行器指标端点下提供指标，以解决路由请求时可能发生的任何故障。这些指标可以通过点击<code>/actuator/metrics</code> 。指标的名称格式如下<code>ZUUL::EXCEPTION:errorCause:statusCode</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="zuul-developer-guide"><a class="anchor" href="#zuul-developer-guide"></a> <a class="link" href="#zuul-developer-guide">5.9.18。Zuul开发人员指南</a></h4>
<div class="paragraph">
<p>有关Zuul的工作原理的一般概述，请参见<a href="https://github.com/Netflix/zuul/wiki/How-it-Works">Zuul Wiki</a> 。</p>
</div>
<div class="sect4">
<h5 id="the-zuul-servlet"><a class="anchor" href="#the-zuul-servlet"></a> <a class="link" href="#the-zuul-servlet">Zuul Servlet</a></h5>
<div class="paragraph">
<p>Zuul被实现为Servlet。对于一般情况，Zuul已嵌入到Spring Dispatch机制中。这使Spring MVC可以控制路由。在这种情况下，Zuul缓冲请求。如果需要不缓存请求就通过Zuul（例如，用于大文件上传），则Servlet也会安装在Spring Dispatcher的外部。缺省情况下，该servlet的地址为<code>/zuul</code> 。您可以使用<code>zuul.servlet-path</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="zuul-requestcontext"><a class="anchor" href="#zuul-requestcontext"></a> <a class="link" href="#zuul-requestcontext">Zuul RequestContext</a></h5>
<div class="paragraph">
<p>为了在过滤器之间传递信息，Zuul使用了<a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/context/RequestContext.java"><code>RequestContext</code></a> 。其数据保存在<code>ThreadLocal</code>特定于每个请求。有关在何处路由请求，错误和实际信息的信息<code>HttpServletRequest</code>和<code>HttpServletResponse</code>被存储在那里。的<code>RequestContext</code>延伸<code>ConcurrentHashMap</code> ，因此任何内容都可以存储在上下文中。 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-zuul/src/main/java/org/springframework/cloud/netflix/zuul/filters/support/FilterConstants.java"><code>FilterConstants</code></a>包含由Spring Cloud Netflix安装的过滤器使用的密钥（ <a href="#zuul-developer-guide-enable-filters">稍后会</a>详细介绍）。</p>
</div>
</div>
<div class="sect4">
<h5 id="enablezuulproxy-vs-enablezuulserver"><a class="anchor" href="#enablezuulproxy-vs-enablezuulserver"></a> <a class="link" href="#enablezuulproxy-vs-enablezuulserver"><code>@EnableZuulProxy</code>与<code>@EnableZuulServer</code></a></h5>
<div class="paragraph">
<p>Spring Cloud Netflix安装了许多过滤器，具体取决于用于启用Zuul的注释。 <code>@EnableZuulProxy</code>是...的超集<code>@EnableZuulServer</code> 。换一种说法， <code>@EnableZuulProxy</code>包含所有安装的过滤器<code>@EnableZuulServer</code> 。“代理”中的其他过滤器启用路由功能。如果您想要“空白” Zuul，则应使用<code>@EnableZuulServer</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="zuul-developer-guide-enable-filters"><a class="anchor" href="#zuul-developer-guide-enable-filters"></a> <a class="link" href="#zuul-developer-guide-enable-filters"><code>@EnableZuulServer</code>筛选器</a></h5>
<div class="paragraph">
<p><code>@EnableZuulServer</code>创建一个<code>SimpleRouteLocator</code>从Spring Boot配置文件加载路由定义。</p>
</div>
<div class="paragraph">
<p>安装了以下过滤器（作为普通的Spring Bean）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>前置过滤器：</p>
<div class="ulist">
<ul>
<li>
<p><code>ServletDetectionFilter</code> ：检测请求是否通过Spring Dispatcher。设置键为的布尔值<code>FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</code> 。</p>
</li>
<li>
<p><code>FormBodyWrapperFilter</code> ：解析表单数据并为下游请求重新编码。</p>
</li>
<li>
<p><code>DebugFilter</code> ：如果<code>debug</code>设置请求参数，设置<code>RequestContext.setDebugRouting()</code>和<code>RequestContext.setDebugRequest()</code>至<code>true</code> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>路线过滤器：</p>
<div class="ulist">
<ul>
<li>
<p><code>SendForwardFilter</code> ：通过使用Servlet转发请求<code>RequestDispatcher</code> 。转发位置存储在<code>RequestContext</code>属性， <code>FilterConstants.FORWARD_TO_KEY</code> 。这对于转发到当前应用程序中的端点很有用。</p>
</li>
</ul>
</div>
</li>
<li>
<p>帖子过滤器：</p>
<div class="ulist">
<ul>
<li>
<p><code>SendResponseFilter</code> ：将代理请求的响应写入当前响应。</p>
</li>
</ul>
</div>
</li>
<li>
<p>错误过滤器：</p>
<div class="ulist">
<ul>
<li>
<p><code>SendErrorFilter</code> ：转发至<code>/error</code> （默认情况下）如果<code>RequestContext.getThrowable()</code>不为空。您可以更改默认转发路径（ <code>/error</code> ）设置<code>error.path</code>属性。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="enablezuulproxy-filters"><a class="anchor" href="#enablezuulproxy-filters"></a> <a class="link" href="#enablezuulproxy-filters"><code>@EnableZuulProxy</code>筛选器</a></h5>
<div class="paragraph">
<p>创建一个<code>DiscoveryClientRouteLocator</code>从一个加载路线定义<code>DiscoveryClient</code> （例如Eureka）以及属性。为每个创建一条路线<code>serviceId</code>来自<code>DiscoveryClient</code> 。添加新服务后，将刷新路由。</p>
</div>
<div class="paragraph">
<p>除了前面描述的过滤器之外，还安装了以下过滤器（作为普通的Spring Bean）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>前置过滤器：</p>
<div class="ulist">
<ul>
<li>
<p><code>PreDecorationFilter</code> ：根据提供的内容确定路线和路线<code>RouteLocator</code> 。它还为下游请求设置了各种与代理相关的标头。</p>
</li>
</ul>
</div>
</li>
<li>
<p>路线过滤器：</p>
<div class="ulist">
<ul>
<li>
<p><code>RibbonRoutingFilter</code> ：使用Ribbon，Hystrix和可插拔HTTP客户端发送请求。服务ID位于<code>RequestContext</code>属性， <code>FilterConstants.SERVICE_ID_KEY</code> 。此过滤器可以使用不同的HTTP客户端：</p>
<div class="ulist">
<ul>
<li>
<p>阿帕奇<code>HttpClient</code> ：默认客户端。</p>
</li>
<li>
<p>方形<code>OkHttpClient</code> v3：通过启用<code>com.squareup.okhttp3:okhttp</code>类路径和设置上的库<code>ribbon.okhttp.enabled=true</code> 。</p>
</li>
<li>
<p>Netflix Ribbon HTTP客户端：通过设置启用<code>ribbon.restclient.enabled=true</code> 。该客户端具有局限性，包括不支持PATCH方法，但还具有内置的重试功能。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>SimpleHostRoutingFilter</code> ：通过Apache HttpClient将请求发送到预定的URL。网址位于<code>RequestContext.getRouteHost()</code> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="custom-zuul-filter-examples"><a class="anchor" href="#custom-zuul-filter-examples"></a> <a class="link" href="#custom-zuul-filter-examples">自定义Zuul过滤器示例</a></h5>
<div class="paragraph">
<p>下面的大多数“如何编写”示例都包含在<a href="https://github.com/spring-cloud-samples/sample-zuul-filters">示例Zuul过滤器</a>项目中。在该存储库中也有一些处理请求或响应正文的示例。</p>
</div>
<div class="paragraph">
<p>本节包括以下示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#zuul-developer-guide-sample-pre-filter">如何编写预过滤器</a></p>
</li>
<li>
<p><a href="#zuul-developer-guide-sample-route-filter">如何编写路由过滤器</a></p>
</li>
<li>
<p><a href="#zuul-developer-guide-sample-post-filter">如何编写帖子过滤器</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="zuul-developer-guide-sample-pre-filter"><a class="anchor" href="#zuul-developer-guide-sample-pre-filter"></a> <a class="link" href="#zuul-developer-guide-sample-pre-filter">如何编写预过滤器</a></h6>
<div class="paragraph">
<p>前置过滤器可在<code>RequestContext</code>用于下游过滤器。主要用例是设置路由过滤器所需的信息。以下示例显示了Zuul预过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class QueryParamPreFilter extends ZuulFilter {
    @Override
    public int filterOrder() {
        return PRE_DECORATION_FILTER_ORDER - 1; // run before PreDecoration
    }

    @Override
    public String filterType() {
        return PRE_TYPE;
    }

    @Override
    public boolean shouldFilter() {
        RequestContext ctx = RequestContext.getCurrentContext();
        return !ctx.containsKey(FORWARD_TO_KEY) // a filter has already forwarded
                && !ctx.containsKey(SERVICE_ID_KEY); // a filter has already determined serviceId
    }
    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        if (request.getParameter("sample") != null) {
            // put the serviceId in `RequestContext`
            ctx.put(SERVICE_ID_KEY, request.getParameter("foo"));
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的过滤器填充<code>SERVICE_ID_KEY</code>来自<code>sample</code>请求参数。实际上，您不应该执行这种直接映射。而是应从以下值查询服务ID <code>sample</code>代替。</p>
</div>
<div class="paragraph">
<p>现在<code>SERVICE_ID_KEY</code>被填充<code>PreDecorationFilter</code>不运行，并且<code>RibbonRoutingFilter</code>运行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">如果您要路由到完整网址，请致电<code>ctx.setRouteHost(url)</code>代替。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要修改路由过滤器转发到的路径，请设置<code>REQUEST_URI_KEY</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="zuul-developer-guide-sample-route-filter"><a class="anchor" href="#zuul-developer-guide-sample-route-filter"></a> <a class="link" href="#zuul-developer-guide-sample-route-filter">如何编写路由过滤器</a></h6>
<div class="paragraph">
<p>路由过滤器在预过滤器之后运行，并向其他服务发出请求。此处的许多工作是在客户端所需的模型之间来回转换请求和响应数据。以下示例显示了Zuul路由过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OkHttpRoutingFilter extends ZuulFilter {
    @Autowired
    private ProxyRequestHelper helper;

    @Override
    public String filterType() {
        return ROUTE_TYPE;
    }

    @Override
    public int filterOrder() {
        return SIMPLE_HOST_ROUTING_FILTER_ORDER - 1;
    }

    @Override
    public boolean shouldFilter() {
        return RequestContext.getCurrentContext().getRouteHost() != null
                && RequestContext.getCurrentContext().sendZuulResponse();
    }

    @Override
    public Object run() {
        OkHttpClient httpClient = new OkHttpClient.Builder()
                // customize
                .build();

        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();

        String method = request.getMethod();

        String uri = this.helper.buildZuulRequestURI(request);

        Headers.Builder headers = new Headers.Builder();
        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String name = headerNames.nextElement();
            Enumeration<String> values = request.getHeaders(name);

            while (values.hasMoreElements()) {
                String value = values.nextElement();
                headers.add(name, value);
            }
        }

        InputStream inputStream = request.getInputStream();

        RequestBody requestBody = null;
        if (inputStream != null && HttpMethod.permitsRequestBody(method)) {
            MediaType mediaType = null;
            if (headers.get("Content-Type") != null) {
                mediaType = MediaType.parse(headers.get("Content-Type"));
            }
            requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream));
        }

        Request.Builder builder = new Request.Builder()
                .headers(headers.build())
                .url(uri)
                .method(method, requestBody);

        Response response = httpClient.newCall(builder.build()).execute();

        LinkedMultiValueMap<String, String> responseHeaders = new LinkedMultiValueMap<>();

        for (Map.Entry<String, List<String>> entry : response.headers().toMultimap().entrySet()) {
            responseHeaders.put(entry.getKey(), entry.getValue());
        }

        this.helper.setResponse(response.code(), response.body().byteStream(),
                responseHeaders);
        context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的过滤器将Servlet请求信息转换为OkHttp3请求信息，执行HTTP请求，并将OkHttp3响应信息转换为Servlet响应。</p>
</div>
</div>
<div class="sect5">
<h6 id="zuul-developer-guide-sample-post-filter"><a class="anchor" href="#zuul-developer-guide-sample-post-filter"></a> <a class="link" href="#zuul-developer-guide-sample-post-filter">如何编写帖子过滤器</a></h6>
<div class="paragraph">
<p>后置过滤器通常操纵响应。以下过滤器添加了随机<code>UUID</code>作为<code>X-Sample</code>标头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AddResponseHeaderFilter extends ZuulFilter {
    @Override
    public String filterType() {
        return POST_TYPE;
    }

    @Override
    public int filterOrder() {
        return SEND_RESPONSE_FILTER_ORDER - 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletResponse servletResponse = context.getResponse();
        servletResponse.addHeader("X-Sample", UUID.randomUUID().toString());
        return null;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">其他操作，例如转换响应主体，则更加复杂且计算量大。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-zuul-errors-work"><a class="anchor" href="#how-zuul-errors-work"></a> <a class="link" href="#how-zuul-errors-work">Zuul错误如何工作</a></h5>
<div class="paragraph">
<p>如果在Zuul过滤器生命周期的任何部分引发异常，则将执行错误过滤器。的<code>SendErrorFilter</code>仅在以下情况下运行<code>RequestContext.getThrowable()</code>不是<code>null</code> 。然后设置特定<code>javax.servlet.error.*</code>属性在请求中并将请求转发到Spring Boot错误页面。</p>
</div>
</div>
<div class="sect4">
<h5 id="zuul-eager-application-context-loading"><a class="anchor" href="#zuul-eager-application-context-loading"></a> <a class="link" href="#zuul-eager-application-context-loading">Zuul急切的应用程序上下文加载</a></h5>
<div class="paragraph">
<p>Zuul在内部使用Ribbon来调用远程URL。默认情况下，Ribbon客户端在第一次调用时由Spring Cloud延迟加载。通过使用以下配置，可以为Zuul更改此行为，这将导致在应用程序启动时急于加载与子Ribbon相关的应用程序上下文。以下示例显示了如何启用即时加载：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>zuul:
  ribbon:
    eager-load:
      enabled: true</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="polyglot-support-with-sidecar"><a class="anchor" href="#polyglot-support-with-sidecar"></a> <a class="link" href="#polyglot-support-with-sidecar">5.10。Sidecar支持多语种</a></h3>
<div class="paragraph">
<p>您是否要使用非JVM语言来利用Eureka，Ribbon和Config Server？Spring Cloud Netflix Sidecar的灵感来自<a href="https://github.com/Netflix/Prana">Netflix Prana</a> 。它包括一个HTTP API，用于获取给定服务的所有实例（按主机和端口）。您也可以通过嵌入式Zuul代理来代理服务呼叫，该代理从Eureka获取其路由条目。可以通过主机查找或通过Zuul代理直接访问Spring Cloud Config Server。非JVM应用程序应实施运行状况检查，以便Sidecar可以向Eureka报告应用程序是启动还是关闭。</p>
</div>
<div class="paragraph">
<p>要将Sidecar包含在您的项目中，请使用组ID为<code>org.springframework.cloud</code>和工件ID或<code>spring-cloud-netflix-sidecar</code> 。</p>
</div>
<div class="paragraph">
<p>要启用Sidecar，请使用以下命令创建一个Spring Boot应用程序： <code>@EnableSidecar</code> 。该注释包括<code>@EnableCircuitBreaker</code> ， <code>@EnableDiscoveryClient</code>和<code>@EnableZuulProxy</code> 。在与非JVM应用程序相同的主机上运行结果应用程序。</p>
</div>
<div class="paragraph">
<p>要配置侧车，请添加<code>sidecar.port</code>和<code>sidecar.health-uri</code>至<code>application.yml</code> 。的<code>sidecar.port</code> property是非JVM应用程序侦听的端口。这样，Sidecar可以在Eureka中正确注册该应用程序。的<code>sidecar.secure-port-enabled</code>选项提供了一种启用流量安全端口的方法。的<code>sidecar.health-uri</code>是在非JVM应用程序上可访问的URI，它模仿Spring Boot运行状况指示器。它应该返回类似于以下内容的JSON文档：</p>
</div>
<div class="listingblock">
<div class="title">health-uri-document</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "status":"UP"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下application.yml示例显示了Sidecar应用程序的示例配置：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
  port: 5678
spring:
  application:
    name: sidecar

sidecar:
  port: 8000
  health-uri: http://localhost:8000/health.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>的API <code>DiscoveryClient.getInstances()</code>方法是<code>/hosts/{serviceId}</code> 。以下示例响应<code>/hosts/customers</code>返回不同主机上的两个实例：</p>
</div>
<div class="listingblock">
<div class="title">/主机/客户</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
    {
        "host": "myhost",
        "port": 9000,
        "uri": "https://myhost:9000",
        "serviceId": "CUSTOMERS",
        "secure": false
    },
    {
        "host": "myhost2",
        "port": 9000,
        "uri": "https://myhost2:9000",
        "serviceId": "CUSTOMERS",
        "secure": false
    }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>非JVM应用程序可以访问该API（如果sidecar位于端口5678上），位于<code><a href="http://localhost:5678/hosts/{serviceId}" class="bare">localhost:5678/hosts/{serviceId}</a></code> 。</p>
</div>
<div class="paragraph">
<p>Zuul代理会自动为Eureka中已知的每个服务添加路由到<code>/<serviceId></code> ，因此可以在以下位置获得客户服务<code>/customers</code> 。非JVM应用程序可以在以下位置访问客户服务<code><a href="http://localhost:5678/customers" class="bare">localhost:5678/customers</a></code> （假设边车正在监听端口5678）。</p>
</div>
<div class="paragraph">
<p>如果Config Server已向Eureka注册，则非JVM应用程序可以通过Zuul代理对其进行访问。如果<code>serviceId</code> ConfigServer的是<code>configserver</code>并且Sidecar在端口5678上，则可以在<a href="http://localhost:5678/configserver" class="bare">localhost：5678 / configserver上</a>对其进行访问。</p>
</div>
<div class="paragraph">
<p>非JVM应用程序可以利用Config Server返回YAML文档的功能。例如，对<a href="https://sidecar.local.spring.io:5678/configserver/default-master.yml" class="bare">sidecar.local.spring.io:5678/configserver/default-master.yml</a>的调用可能会导致YAML文档类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  password: password
info:
  description: Spring Cloud Samples
  url: https://github.com/spring-cloud-samples</code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用HTTP时启用健康检查请求以接受所有证书<code>sidecar.accept-all-ssl-certificates</code>为`true。</p>
</div>
</div>
<div class="sect2">
<h3 id="retrying-failed-requests"><a class="anchor" href="#retrying-failed-requests"></a> <a class="link" href="#retrying-failed-requests">5.11。重试失败的请求</a></h3>
<div class="paragraph">
<p>Spring Cloud Netflix提供了多种发出HTTP请求的方式。您可以使用负载平衡<code>RestTemplate</code> ，功能区或伪装。无论您选择如何创建HTTP请求，始终都有可能导致请求失败。当请求失败时，您可能希望自动重试该请求。为此，在使用Sping Cloud Netflix时，需要在应用程序的类路径中包括<a href="https://github.com/spring-projects/spring-retry">Spring Retry</a> 。存在Spring Retry时，负载均衡<code>RestTemplates</code> ，Feign和Zuul会自动重试任何失败的请求（假设您的配置允许这样做）。</p>
</div>
<div class="sect3">
<h4 id="backoff-policies"><a class="anchor" href="#backoff-policies"></a> <a class="link" href="#backoff-policies">5.11.1。退避政策</a></h4>
<div class="paragraph">
<p>默认情况下，重试请求时不使用任何退避策略。如果要配置退避策略，则需要创建一个类型为的bean <code>LoadBalancedRetryFactory</code>并覆盖<code>createBackOffPolicy</code>给定服务的方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class MyConfiguration {
    @Bean
    LoadBalancedRetryFactory retryFactory() {
        return new LoadBalancedRetryFactory() {
            @Override
            public BackOffPolicy createBackOffPolicy(String service) {
                return new ExponentialBackOffPolicy();
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuration-2"><a class="anchor" href="#configuration-2"></a> <a class="link" href="#configuration-2">5.11.2。组态</a></h4>
<div class="paragraph">
<p>当将Ribbon与Spring Retry一起使用时，可以通过配置某些Ribbon属性来控制重试功能。为此，请设置<code>client.ribbon.MaxAutoRetries</code> ， <code>client.ribbon.MaxAutoRetriesNextServer</code>和<code>client.ribbon.OkToRetryOnAllOperations</code>属性。有关这些属性的说明，请参见<a href="https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties">功能区文档</a> 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">启用<code>client.ribbon.OkToRetryOnAllOperations</code>包括重试POST请求，由于请求正文的缓冲，这可能会对服务器资源产生影响。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">这些属性名称区分大小写，并且由于其中某些属性是在Netflix Ribbon项目中定义的，因此它们在Pascal Case中使用，而Spring Cloud中的属性在Camel Case中使用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此外，您可能想在响应中返回某些状态代码时重试请求。您可以通过设置功能列表来列出希望功能区客户端重试的响应代码。 <code>clientName.ribbon.retryableStatusCodes</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">clientName:
  ribbon:
    retryableStatusCodes: 404,502</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以创建一个类型的bean <code>LoadBalancedRetryPolicy</code>并实施<code>retryableStatusCode</code>给定状态码的方法重试请求。</p>
</div>
<div class="sect4">
<h5 id="zuul"><a class="anchor" href="#zuul"></a> <a class="link" href="#zuul">祖尔</a></h5>
<div class="paragraph">
<p>您可以通过设置关闭Zuul的重试功能<code>zuul.retryable</code>至<code>false</code> 。您还可以通过设置来禁用逐个路由的重试功能<code>zuul.routes.routename.retryable</code>至<code>false</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="http-clients-2"><a class="anchor" href="#http-clients-2"></a> <a class="link" href="#http-clients-2">5.12。HTTP客户端</a></h3>
<div class="paragraph">
<p>Spring Cloud Netflix会自动为您创建Ribbon，Feign和Zuul使用的HTTP客户端。但是，您也可以根据需要提供自定义的HTTP客户端。为此，您可以创建一个类型为的bean <code>ClosableHttpClient</code>如果您使用的是Apache Http Cient或<code>OkHttpClient</code>如果使用的是OK HTTP。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">创建自己的HTTP客户端时，您还负责为这些客户端实施正确的连接管理策略。这样做不当会导致资源管理问题。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="modules-in-maintenance-mode"><a class="anchor" href="#modules-in-maintenance-mode"></a> <a class="link" href="#modules-in-maintenance-mode">5.13。维护模式下的模块</a></h3>
<div class="paragraph">
<p>将模块置于维护模式意味着Spring Cloud团队将不再向该模块添加新功能。我们将修复阻止程序错误和安全性问题，还将考虑并审查社区提出的小请求。</p>
</div>
<div class="paragraph">
<p>自格林威治发布列车全面上市以来，我们打算继续为这些模块提供至少一年的支持。</p>
</div>
<div class="paragraph">
<p>以下Spring Cloud Netflix模块和相应的启动程序将进入维护模式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>spring-cloud-netflix-archaius</p>
</li>
<li>
<p>Spring-Cloud-NetFlix-Hystrix合同</p>
</li>
<li>
<p>Spring-Cloud-NetFlix-Hystrix-仪表板</p>
</li>
<li>
<p>Spring-Cloud-NetFlix-Hystrix-流</p>
</li>
<li>
<p>spring-cloud-netflix-hystrix</p>
</li>
<li>
<p>春天云netflix丝带</p>
</li>
<li>
<p>spring-cloud-netflix涡轮流</p>
</li>
<li>
<p>弹簧云netflix涡轮</p>
</li>
<li>
<p>春天云netflix zuul</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">这不包括Eureka或并发限制模块。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-2"><a class="anchor" href="#configuration-properties-2"></a> <a class="link" href="#configuration-properties-2">5.14。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与Spring Cloud Netflix相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-openfeign"><a class="anchor" href="#spring-cloud-openfeign"></a> <a class="link" href="#spring-cloud-openfeign">6。Spring Cloud OpenFeign</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="paragraph">
<p>该项目通过自动配置并绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供OpenFeign集成。</p>
</div>
<div class="sect2">
<h3 id="spring-cloud-feign"><a class="anchor" href="#spring-cloud-feign"></a> <a class="link" href="#spring-cloud-feign">6.1。声明式REST客户端：伪装</a></h3>
<div class="paragraph">
<p><a href="https://github.com/OpenFeign/feign">Feign</a>是声明性Web服务客户端。它使编写Web服务客户端更加容易。要使用Feign，请创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC批注以及使用它们的支持<code>HttpMessageConverters</code>在Spring Web中默认使用。Spring Cloud集成了Ribbon和Eureka以及Spring Cloud LoadBalancer，以在使用Feign时提供负载平衡的http客户端。</p>
</div>
<div class="sect3">
<h4 id="netflix-feign-starter"><a class="anchor" href="#netflix-feign-starter"></a> <a class="link" href="#netflix-feign-starter">6.1.1。如何包含假装</a></h4>
<div class="paragraph">
<p>要将Feign包含在您的项目中，请使用带有starter的组<code>org.springframework.cloud</code>和工件ID <code>spring-cloud-starter-openfeign</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="paragraph">
<p>春季启动应用程序示例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableFeignClients
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">StoreClient.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient("stores")
public interface StoreClient {
    @RequestMapping(method = RequestMethod.GET, value = "/stores")
    List<Store> getStores();

    @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
    Store update(@PathVariable("storeId") Long storeId, Store store);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在里面<code>@FeignClient</code>注释String值（上面的“ stores”）是一个任意的客户端名称，用于创建<a href="https://github.com/Netflix/ribbon">Ribbon</a>负载平衡器（请参见<a href="#spring-cloud-ribbon">下面的Ribbon支持的详细信息</a> ）或<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/reactive/ReactiveLoadBalancer.java">Spring Cloud LoadBalancer</a> 。您也可以使用<code>url</code>属性（绝对值或只是主机名）。应用程序上下文中的Bean名称是接口的标准名称。要指定自己的别名值，您可以使用<code>qualifier</code>的价值<code>@FeignClient</code>注解。</p>
</div>
<div class="paragraph">
<p>上面的负载平衡器客户端将希望发现“商店”服务的物理地址。如果您的应用程序是Eureka客户端，则它将在Eureka服务注册表中解析该服务。如果您不想使用Eureka，则可以在外部配置中简单地配置服务器列表（ <a href="#spring-cloud-ribbon-without-eureka">例如，</a>参见<a href="#spring-cloud-ribbon-without-eureka">上文</a> ）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">为了保持向后兼容性，用作默认的负载均衡器实现。但是，Spring Cloud Netflix Ribbon现在处于维护模式，因此我们建议改为使用Spring Cloud LoadBalancer。为此，请设置<code>spring.cloud.loadbalancer.ribbon.enabled</code>至<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-feign-overriding-defaults"><a class="anchor" href="#spring-cloud-feign-overriding-defaults"></a> <a class="link" href="#spring-cloud-feign-overriding-defaults">6.1.2。覆盖伪默认</a></h4>
<div class="paragraph">
<p>Spring Cloud的Feign支持中的中心概念是指定客户端的概念。每个虚拟客户端都是组件集合的一部分，这些组件可以一起工作以按需联系远程服务器，并且该集合的名称是您使用<code>@FeignClient</code>注解。Spring Cloud创建了一个新的合奏<code>ApplicationContext</code>按需使用每个命名客户<code>FeignClientsConfiguration</code> 。其中包括（除其他事项外） <code>feign.Decoder</code> ， 一种<code>feign.Encoder</code>和<code>feign.Contract</code> 。可以通过使用<code>contextId</code>的属性<code>@FeignClient</code>注解。</p>
</div>
<div class="paragraph">
<p>通过Spring Cloud，您可以通过声明其他配置（在<code>FeignClientsConfiguration</code> ）使用<code>@FeignClient</code> 。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(name = "stores", configuration = FooConfiguration.class)
public interface StoreClient {
    //..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，客户端由已经存在的组件组成<code>FeignClientsConfiguration</code>与任何<code>FooConfiguration</code> （后者将覆盖前者）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>FooConfiguration</code>不需要注释<code>@Configuration</code> 。但是，如果是这样，请小心将其从任何<code>@ComponentScan</code>否则将包括此配置，因为它将成为该配置的默认来源<code>feign.Decoder</code> ， <code>feign.Encoder</code> ， <code>feign.Contract</code> ，等等。通过将其与任何其他产品放在单独的，不重叠的包装中可以避免这种情况<code>@ComponentScan</code>要么<code>@SpringBootApplication</code> ，也可以明确排除在<code>@ComponentScan</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>serviceId</code>现在不推荐使用属性，而推荐使用<code>name</code>属性。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用<code>contextId</code>的属性<code>@FeignClient</code>注释，除了更改名称<code>ApplicationContext</code>集成，它将覆盖客户端名称的别名，并将其用作为该客户端创建的配置Bean名称的一部分。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">以前，使用<code>url</code>属性，不需要<code>name</code>属性。使用<code>name</code>现在是必需的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>占位符在<code>name</code>和<code>url</code>属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(name = "${feign.name}", url = "${feign.url}")
public interface StoreClient {
    //..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Netflix默认为假装提供以下bean（ <code>BeanType</code> beanName： <code>ClassName</code> ）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Decoder</code> feignDecoder： <code>ResponseEntityDecoder</code> （其中包含一个<code>SpringDecoder</code> ）</p>
</li>
<li>
<p><code>Encoder</code> feignEncoder：<code>SpringEncoder</code></p>
</li>
<li>
<p><code>Logger</code> feignLogger：<code>Slf4jLogger</code></p>
</li>
<li>
<p><code>Contract</code> feignContract：<code>SpringMvcContract</code></p>
</li>
<li>
<p><code>Feign.Builder</code> feignBuilder：<code>HystrixFeign.Builder</code></p>
</li>
<li>
<p><code>Client</code> feignClient：如果Ribbon在类路径中且已启用，则为<code>LoadBalancerFeignClient</code> ，否则，如果Spring Cloud LoadBalancer在类路径中， <code>FeignBlockingLoadBalancerClient</code>用来。如果它们都不在类路径中，则使用默认的伪装客户端。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>spring-cloud-starter-openfeign</code>同时包含<code>spring-cloud-starter-netflix-ribbon</code>和<code>spring-cloud-starter-loadbalancer</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>OkHttpClient和ApacheHttpClient伪装客户端可以通过设置使用<code>feign.okhttp.enabled</code>要么<code>feign.httpclient.enabled</code>至<code>true</code> ，并将它们放在类路径中。您可以通过提供以下任一类型的bean来定制所使用的HTTP客户端<code>org.apache.http.impl.client.CloseableHttpClient</code>使用Apache或<code>okhttp3.OkHttpClient</code>使用OK HTTP时。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Cloud Netflix <em>不会</em>为伪装提供以下bean，但仍会从应用程序上下文中查找这些类型的bean以创建伪装客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Logger.Level</code></p>
</li>
<li>
<p><code>Retryer</code></p>
</li>
<li>
<p><code>ErrorDecoder</code></p>
</li>
<li>
<p><code>Request.Options</code></p>
</li>
<li>
<p><code>Collection<RequestInterceptor></code></p>
</li>
<li>
<p><code>SetterFactory</code></p>
</li>
<li>
<p><code>QueryMapEncoder</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>创建其中一种类型的Bean并将其放置在<code>@FeignClient</code>配置（例如<code>FooConfiguration</code>以上）允许您覆盖所描述的每个bean。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class FooConfiguration {
    @Bean
    public Contract feignContract() {
        return new feign.Contract.Default();
    }

    @Bean
    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        return new BasicAuthRequestInterceptor("user", "password");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这取代了<code>SpringMvcContract</code>与<code>feign.Contract.Default</code>并添加一个<code>RequestInterceptor</code>到的集合<code>RequestInterceptor</code> 。</p>
</div>
<div class="paragraph">
<p><code>@FeignClient</code>也可以使用配置属性进行配置。</p>
</div>
<div class="paragraph">
<p>application.yml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">feign:
  client:
    config:
      feignName:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: full
        errorDecoder: com.example.SimpleErrorDecoder
        retryer: com.example.SimpleRetryer
        requestInterceptors:
          - com.example.FooRequestInterceptor
          - com.example.BarRequestInterceptor
        decode404: false
        encoder: com.example.SimpleEncoder
        decoder: com.example.SimpleDecoder
        contract: com.example.SimpleContract</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在<code>@EnableFeignClients</code>属性<code>defaultConfiguration</code>以与上述类似的方式。不同之处在于此配置将适用于<em>所有</em>伪客户端。</p>
</div>
<div class="paragraph">
<p>如果您更喜欢使用配置属性来配置所有<code>@FeignClient</code> ，您可以使用<code>default</code>假名。</p>
</div>
<div class="paragraph">
<p>application.yml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 5000
        loggerLevel: basic</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们都创建<code>@Configuration</code> bean和配置属性，配置属性将获胜。它将覆盖<code>@Configuration</code>价值观。但是，如果您想将优先级更改为<code>@Configuration</code> ， 你可以改变<code>feign.client.default-to-properties</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您需要使用<code>ThreadLocal</code>您的绑定变量<code>RequestInterceptor`s you will need to either set the thread isolation strategy for Hystrix to `SEMAPHORE</code>或在Feign中禁用Hystrix。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>application.yml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># To disable Hystrix in Feign
feign:
  hystrix:
    enabled: false

# To set thread isolation to SEMAPHORE
hystrix:
  command:
    default:
      execution:
        isolation:
          strategy: SEMAPHORE</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们要创建多个具有相同名称或网址的伪装客户端，以便它们指向同一台服务器，但每个客户端使用不同的自定义配置，则必须使用<code>contextId</code>的属性<code>@FeignClient</code>为了避免这些配置bean的名称冲突。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(contextId = "fooClient", name = "stores", configuration = FooConfiguration.class)
public interface FooClient {
    //..
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(contextId = "barClient", name = "stores", configuration = BarConfiguration.class)
public interface BarClient {
    //..
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating-feign-clients-manually"><a class="anchor" href="#creating-feign-clients-manually"></a> <a class="link" href="#creating-feign-clients-manually">6.1.3。手动创建假客户</a></h4>
<div class="paragraph">
<p>在某些情况下，可能有必要使用上述方法无法实现的方式自定义Feign客户。在这种情况下，您可以使用<a href="https://github.com/OpenFeign/feign/#basics">Feign Builder API</a>创建客户端。下面是一个示例，该示例创建具有相同接口的两个Feign Client，但为每个Feign Client配置一个单独的请求拦截器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Import(FeignClientsConfiguration.class)
class FooController {

    private FooClient fooClient;

    private FooClient adminClient;

        @Autowired
    public FooController(Decoder decoder, Encoder encoder, Client client, Contract contract) {
        this.fooClient = Feign.builder().client(client)
                .encoder(encoder)
                .decoder(decoder)
                .contract(contract)
                .requestInterceptor(new BasicAuthRequestInterceptor("user", "user"))
                .target(FooClient.class, "https://PROD-SVC");

        this.adminClient = Feign.builder().client(client)
                .encoder(encoder)
                .decoder(decoder)
                .contract(contract)
                .requestInterceptor(new BasicAuthRequestInterceptor("admin", "admin"))
                .target(FooClient.class, "https://PROD-SVC");
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在上面的例子中<code>FeignClientsConfiguration.class</code>是Spring Cloud Netflix提供的默认配置。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>PROD-SVC</code>是客户将向其请求的服务的名称。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">假装<code>Contract</code>对象定义接口上有效的注释和值。自动接线<code>Contract</code> bean提供了对SpringMVC注释的支持，而不是默认的Feign本机注释。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-feign-hystrix"><a class="anchor" href="#spring-cloud-feign-hystrix"></a> <a class="link" href="#spring-cloud-feign-hystrix">6.1.4。Feign Hystrix支持</a></h4>
<div class="paragraph">
<p>如果Hystrix在类路径上并且<code>feign.hystrix.enabled=true</code> ，Feign将使用断路器包装所有方法。返回一个<code>com.netflix.hystrix.HystrixCommand</code>也可以。这使您可以使用反应模式（通过调用<code>.toObservable()</code>要么<code>.observe()</code>或异步使用（通过调用<code>.queue()</code> ）。</p>
</div>
<div class="paragraph">
<p>要基于每个客户端禁用Hystrix支持，请创建香草<code>Feign.Builder</code>具有“原型”范围，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class FooConfiguration {
        @Bean
    @Scope("prototype")
    public Feign.Builder feignBuilder() {
        return Feign.builder();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">在Spring Cloud Dalston发行之前，如果Hystrix在类路径中，Feign默认会将所有方法包装在断路器中。Spring Cloud Dalston中更改了此默认行为，以支持选择加入方法。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-feign-hystrix-fallback"><a class="anchor" href="#spring-cloud-feign-hystrix-fallback"></a> <a class="link" href="#spring-cloud-feign-hystrix-fallback">6.1.5。假装Hystrix后备</a></h4>
<div class="paragraph">
<p>Hystrix支持回退的概念：当它们的电路断开或出现错误时，将执行默认代码路径。为给定启用后备<code>@FeignClient</code>设置<code>fallback</code>属性为实现后备的类名称。您还需要将实现声明为Spring bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(name = "hello", fallback = HystrixClientFallback.class)
protected interface HystrixClient {
    @RequestMapping(method = RequestMethod.GET, value = "/hello")
    Hello iFailSometimes();
}

static class HystrixClientFallback implements HystrixClient {
    @Override
    public Hello iFailSometimes() {
        return new Hello("fallback");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要访问引起后备触发器的原因，则可以使用<code>fallbackFactory</code>内部属性<code>@FeignClient</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(name = "hello", fallbackFactory = HystrixClientFallbackFactory.class)
protected interface HystrixClient {
    @RequestMapping(method = RequestMethod.GET, value = "/hello")
    Hello iFailSometimes();
}

@Component
static class HystrixClientFallbackFactory implements FallbackFactory<HystrixClient> {
    @Override
    public HystrixClient create(Throwable cause) {
        return new HystrixClient() {
            @Override
            public Hello iFailSometimes() {
                return new Hello("fallback; reason was: " + cause.getMessage());
            }
        };
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">Feign中的后备实现以及Hystrix后备如何工作存在局限性。当前不支持回退方法<code>com.netflix.hystrix.HystrixCommand</code>和<code>rx.Observable</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="feign-and-primary"><a class="anchor" href="#feign-and-primary"></a> <a class="link" href="#feign-and-primary">6.1.6。假装和<code>@Primary</code></a></h4>
<div class="paragraph">
<p>当将Feign与Hystrix备用广告素材一起使用时， <code>ApplicationContext</code>相同类型的。这将导致<code>@Autowired</code>之所以无法工作，是因为没有一个bean，也没有一个被标记为primary。为解决此问题，Spring Cloud Netflix将所有Feign实例标记为<code>@Primary</code> ，因此Spring Framework将知道要注入哪个bean。在某些情况下，这可能不是理想的。要关闭此行为，请设置<code>primary</code>的属性<code>@FeignClient</code>虚假。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient(name = "hello", primary = false)
public interface HelloClient {
    // methods here
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-feign-inheritance"><a class="anchor" href="#spring-cloud-feign-inheritance"></a> <a class="link" href="#spring-cloud-feign-inheritance">6.1.7。假继承支持</a></h4>
<div class="paragraph">
<p>Feign通过单继承接口支持样板API。这允许将常用操作分组为方便的基本接口。</p>
</div>
<div class="listingblock">
<div class="title">UserService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface UserService {

    @RequestMapping(method = RequestMethod.GET, value ="/users/{id}")
    User getUser(@PathVariable("id") long id);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">UserResource.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
public class UserResource implements UserService {

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">UserClient.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package project.user;

@FeignClient("users")
public interface UserClient extends UserService {

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">通常不建议在服务器和客户端之间共享接口。它引入了紧密耦合，并且实际上也无法以当前形式与Spring MVC一起使用（方法参数映射不被继承）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="feign-requestresponse-compression"><a class="anchor" href="#feign-requestresponse-compression"></a> <a class="link" href="#feign-requestresponse-compression">6.1.8。伪装请求/响应压缩</a></h4>
<div class="paragraph">
<p>您可以考虑为您的Feign请求启用请求或响应GZIP压缩。您可以通过启用以下属性之一来做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">feign.compression.request.enabled=true
feign.compression.response.enabled=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>伪装请求压缩为您提供的设置类似于您为Web服务器设置的设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">feign.compression.request.enabled=true
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=2048</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些属性使您可以选择压缩媒体类型和最小请求阈值长度。</p>
</div>
<div class="paragraph">
<p>对于OkHttpClient以外的http客户端，可以启用默认的gzip解码器以ISO-8859-1编码对gzip响应进行解码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">---
feign.compression.response.enabled=true
feign.compression.response.useGzipDecoder=true
---</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="feign-logging"><a class="anchor" href="#feign-logging"></a> <a class="link" href="#feign-logging">6.1.9。伪装伐木</a></h4>
<div class="paragraph">
<p>为每个创建的Feign客户端创建一个记录器。默认情况下，记录器的名称是用于创建Feign客户端的接口的全类名称。伪装日志仅响应<code>DEBUG</code>水平。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">logging.level.project.user.UserClient: DEBUG</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Logger.Level</code>您可以为每个客户端配置的对象，告诉Feign要记录多少。选择是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code> ，不记录（ <strong>DEFAULT</strong> ）。</p>
</li>
<li>
<p><code>BASIC</code> ，仅记录请求方法和URL以及响应状态代码和执行时间。</p>
</li>
<li>
<p><code>HEADERS</code> ，记录基本信息以及请求和响应标头。</p>
</li>
<li>
<p><code>FULL</code> ，记录请求和响应的标题，正文和元数据。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，以下将设置<code>Logger.Level</code>至<code>FULL</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
public class FooConfiguration {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="feign-querymap-support"><a class="anchor" href="#feign-querymap-support"></a> <a class="link" href="#feign-querymap-support">6.1.10。假装@QueryMap支持</a></h4>
<div class="paragraph">
<p>OpenFeign <code>@QueryMap</code>批注支持将POJO用作GET参数映射。不幸的是，默认的OpenFeign QueryMap注释与Spring不兼容，因为它缺少一个<code>value</code>属性。</p>
</div>
<div class="paragraph">
<p>Spring Cloud OpenFeign提供了等效的功能<code>@SpringQueryMap</code>批注，用于批注POJO或Map参数作为查询参数映射。</p>
</div>
<div class="paragraph">
<p>例如， <code>Params</code>类定义参数<code>param1</code>和<code>param2</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Params.java
public class Params {
    private String param1;
    private String param2;

    // [Getters and setters omitted for brevity]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下伪装客户使用<code>Params</code>通过使用<code>@SpringQueryMap</code>注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient("demo")
public interface DemoTemplate {

    @GetMapping(path = "/demo")
    String demoEndpoint(@SpringQueryMap Params params);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要对生成的查询参数图进行更多控制，则可以实施自定义<code>QueryMapEncoder</code>豆。</p>
</div>
</div>
<div class="sect3">
<h4 id="hateoas-support"><a class="anchor" href="#hateoas-support"></a> <a class="link" href="#hateoas-support">6.1.11。HATEOAS支持</a></h4>
<div class="paragraph">
<p>Spring提供了一些API来创建遵循<a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a>原理的REST表示形式， <a href="https://spring.io/projects/spring-hateoas">Spring Hateoas</a>和<a href="https://spring.io/projects/spring-data-rest">Spring Data REST</a> 。</p>
</div>
<div class="paragraph">
<p>如果您的专案使用<code>org.springframework.boot:spring-boot-starter-hateoas</code>入门或<code>org.springframework.boot:spring-boot-starter-data-rest</code>首先，Feign HATEOAS支持默认为启用。</p>
</div>
<div class="paragraph">
<p>启用HATEOAS支持后，允许Feign客户端序列化和反序列化HATEOAS表示模型： <a href="https://docs.spring.io/spring-hateoas/docs/1.0.0.M1/apidocs/org/springframework/hateoas/EntityModel.html">EntityModel</a> ， <a href="https://docs.spring.io/spring-hateoas/docs/1.0.0.M1/apidocs/org/springframework/hateoas/CollectionModel.html">CollectionModel</a>和<a href="https://docs.spring.io/spring-hateoas/docs/1.0.0.M1/apidocs/org/springframework/hateoas/PagedModel.html">PagedModel</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient("demo")
public interface DemoTemplate {

    @GetMapping(path = "/stores")
    CollectionModel<Store> getStores();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-3"><a class="anchor" href="#configuration-properties-3"></a> <a class="link" href="#configuration-properties-3">6.2。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与Sleuth相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-bus"><a class="anchor" href="#spring-cloud-bus"></a> <a class="link" href="#spring-cloud-bus">7。spring-cloud-bus</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Bus将轻量级消息代理程序链接到分布式系统的节点。然后可以使用此代理来广播状态更改（例如配置更改）或其他管理指令。一个关键的想法是，总线就像是横向扩展的Spring Boot应用程序的分布式执行器。但是，它也可以用作应用之间的通信渠道。该项目为AMQP经纪人或Kafka提供了入门服务。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a href="https://github.com/spring-cloud/spring-cloud-config/tree/master/docs/src/main/asciidoc">github</a>的项目中找到源代码和问题跟踪程序。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="quick-start-2"><a class="anchor" href="#quick-start-2"></a> <a class="link" href="#quick-start-2">7.1。快速开始</a></h3>
<div class="paragraph">
<p>如果Spring Cloud Bus在类路径中检测到自身，则通过添加Spring Boot autconfiguration来工作。要启用总线，请添加<code>spring-cloud-starter-bus-amqp</code>要么<code>spring-cloud-starter-bus-kafka</code>到您的依赖管理。Spring Cloud负责其余的工作。确保代理（RabbitMQ或Kafka）可用并且已配置。在本地主机上运行时，您无需执行任何操作。如果您是远程运行，请使用Spring Cloud Connectors或Spring Boot约定定义代理凭据，如Rabbit的以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  rabbitmq:
    host: mybroker.com
    port: 5672
    username: user
    password: secret</pre>
</div>
</div>
<div class="paragraph">
<p>总线当前支持向所有侦听节点或特定服务的所有节点发送消息（由Eureka定义）。的<code>/bus/*</code>执行器名称空间具有一些HTTP端点。当前，有两个已实现。首先， <code>/bus/env</code> ，发送键/值对以更新每个节点的Spring Environment。第二， <code>/bus/refresh</code> ，重新加载每个应用程序的配置，就好像它们都被ping通了<code>/refresh</code>端点。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud Bus入门文章涵盖Rabbit和Kafka，因为它们是两个最常见的实现。但是，Spring Cloud Stream非常灵活，并且绑定程序可以与<code>spring-cloud-bus</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="bus-endpoints"><a class="anchor" href="#bus-endpoints"></a> <a class="link" href="#bus-endpoints">7.2。总线端点</a></h3>
<div class="paragraph">
<p>Spring Cloud Bus提供了两个端点， <code>/actuator/bus-refresh</code>和<code>/actuator/bus-env</code>对应于Spring Cloud Commons中的各个执行器端点， <code>/actuator/refresh</code>和<code>/actuator/env</code>分别。</p>
</div>
<div class="sect3">
<h4 id="bus-refresh-endpoint"><a class="anchor" href="#bus-refresh-endpoint"></a> <a class="link" href="#bus-refresh-endpoint">7.2.1。总线刷新端点</a></h4>
<div class="paragraph">
<p>的<code>/actuator/bus-refresh</code>端点清除<code>RefreshScope</code>缓存并重新绑定<code>@ConfigurationProperties</code> 。有关更多信息，请参见<a href="#refresh-scope">刷新作用域</a>文档。</p>
</div>
<div class="paragraph">
<p>揭露<code>/actuator/bus-refresh</code>端点，您需要向应用程序添加以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">management.endpoints.web.exposure.include=bus-refresh</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bus-env-endpoint"><a class="anchor" href="#bus-env-endpoint"></a> <a class="link" href="#bus-env-endpoint">7.2.2。总线环境端点</a></h4>
<div class="paragraph">
<p>的<code>/actuator/bus-env</code>端点使用跨多个实例的指定键/值对更新每个实例环境。</p>
</div>
<div class="paragraph">
<p>揭露<code>/actuator/bus-env</code>端点，您需要向应用程序添加以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">management.endpoints.web.exposure.include=bus-env</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>/actuator/bus-env</code>端点接受<code>POST</code>具有以下形状的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "name": "key1",
    "value": "value1"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="addressing-an-instance"><a class="anchor" href="#addressing-an-instance"></a> <a class="link" href="#addressing-an-instance">7.3。寻址实例</a></h3>
<div class="paragraph">
<p>该应用程序的每个实例都有一个服务ID，其值可以通过<code>spring.cloud.bus.id</code>并且其值应按标识符的冒号分隔列表（从最低到最高）排列。默认值是从环境构造为<code>spring.application.name</code>和<code>server.port</code> （要么<code>spring.application.index</code> （如果已设置）。ID的默认值以以下形式构造： <code>app:index:id</code> ，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>app</code>是个<code>vcap.application.name</code> ，如果存在，或者<code>spring.application.name</code></p>
</li>
<li>
<p><code>index</code>是个<code>vcap.application.instance_index</code> ，如果存在， <code>spring.application.index</code> ， <code>local.server.port</code> ， <code>server.port</code> ， 要么<code>0</code> （以该顺序）。</p>
</li>
<li>
<p><code>id</code>是个<code>vcap.application.instance_id</code> ，如果存在，则为一个随机值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>HTTP端点接受“目标”路径参数，例如<code>/bus-refresh/customers:9000</code> ，在哪里<code>destination</code>是服务ID。如果该ID由总线上的一个实例拥有，它将处理该消息，而所有其他实例将忽略它。</p>
</div>
</div>
<div class="sect2">
<h3 id="addressing-all-instances-of-a-service"><a class="anchor" href="#addressing-all-instances-of-a-service"></a> <a class="link" href="#addressing-all-instances-of-a-service">7.4。处理服务的所有实例</a></h3>
<div class="paragraph">
<p>在弹簧中使用“目标”参数<code>PathMatcher</code> （以路径分隔符作为冒号- <code>:</code> ），以确定实例是否处理该消息。使用前面的示例， <code>/bus-env/customers:**</code>定位“客户”服务的所有实例，而与其余服务ID无关。</p>
</div>
</div>
<div class="sect2">
<h3 id="service-id-must-be-unique"><a class="anchor" href="#service-id-must-be-unique"></a> <a class="link" href="#service-id-must-be-unique">7.5。服务ID必须唯一</a></h3>
<div class="paragraph">
<p>总线尝试两次以消除对事件的处理-一次来自原始事件<code>ApplicationEvent</code>然后一次从队列中为此，它将对照当前服务ID检查发送服务ID。如果服务的多个实例具有相同的ID，则不会处理事件。在本地计算机上运行时，每个服务都在不同的端口上，并且该端口是ID的一部分。 Cloud Foundry提供了一个区分索引。为确保ID在Cloud Foundry之外是唯一的，请设置<code>spring.application.index</code>对于每个服务实例都是唯一的。</p>
</div>
</div>
<div class="sect2">
<h3 id="customizing-the-message-broker"><a class="anchor" href="#customizing-the-message-broker"></a> <a class="link" href="#customizing-the-message-broker">7.6。自定义消息代理</a></h3>
<div class="paragraph">
<p>Spring Cloud Bus使用<a href="https://cloud.spring.io/spring-cloud-stream">Spring Cloud Stream</a>广播消息。因此，要使消息流动，您只需要在类路径中包括您选择的活页夹实现即可。带有AMQP（RabbitMQ）和Kafka（ <code>spring-cloud-starter-bus-[amqp|kafka]</code> ）。一般来说，Spring Cloud Stream依赖于Spring Boot自动配置约定来配置中间件。例如，可以使用以下方式更改AMQP经纪人地址<code>spring.rabbitmq.*</code>配置属性。Spring Cloud Bus在以下方面具有少数本机配置属性<code>spring.cloud.bus.*</code> （例如， <code>spring.cloud.bus.destination</code>是用作外部中间件的主题的名称）。通常，默认值就足够了。</p>
</div>
<div class="paragraph">
<p>要了解有关如何自定义消息代理设置的更多信息，请参阅Spring Cloud Stream文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="tracing-bus-events"><a class="anchor" href="#tracing-bus-events"></a> <a class="link" href="#tracing-bus-events">7.7。追踪巴士事件</a></h3>
<div class="paragraph">
<p>公交事件（的子类<code>RemoteApplicationEvent</code>可以通过设置来跟踪<code>spring.cloud.bus.trace.enabled=true</code> 。如果您这样做的话，Spring Boot <code>TraceRepository</code> （如果存在）显示每个发送的事件以及每个服务实例的所有通知。以下示例来自<code>/trace</code>端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "timestamp": "2015-11-26T10:24:44.411+0000",
  "info": {
    "signal": "spring.cloud.bus.ack",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "stores:8081",
    "destination": "*:**"
  }
  },
  {
  "timestamp": "2015-11-26T10:24:41.864+0000",
  "info": {
    "signal": "spring.cloud.bus.sent",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "customers:9000",
    "destination": "*:**"
  }
  },
  {
  "timestamp": "2015-11-26T10:24:41.862+0000",
  "info": {
    "signal": "spring.cloud.bus.ack",
    "type": "RefreshRemoteApplicationEvent",
    "id": "c4d374b7-58ea-4928-a312-31984def293b",
    "origin": "customers:9000",
    "destination": "*:**"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的迹线表明<code>RefreshRemoteApplicationEvent</code>来自<code>customers:9000</code> ，广播给所有服务，并被接收（确认） <code>customers:9000</code>和<code>stores:8081</code> 。</p>
</div>
<div class="paragraph">
<p>要自己处理确认信号，您可以添加一个<code>@EventListener</code>为了<code>AckRemoteApplicationEvent</code>和<code>SentApplicationEvent</code>键入您的应用（并启用跟踪）。或者，您可以点击<code>TraceRepository</code>并从那里挖掘数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">任何总线应用程序都可以跟踪ack。但是，有时，在中央服务中执行此操作很有用，该服务可以对数据进行更复杂的查询或将其转发给专门的跟踪服务。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="broadcasting-your-own-events"><a class="anchor" href="#broadcasting-your-own-events"></a> <a class="link" href="#broadcasting-your-own-events">7.8。广播自己的活动</a></h3>
<div class="paragraph">
<p>巴士可以携带任何类型的事件<code>RemoteApplicationEvent</code> 。默认传输是JSON，解串器需要提前知道将要使用哪些类型。要注册新类型，必须将其放在以下子包中<code>org.springframework.cloud.bus.event</code> 。</p>
</div>
<div class="paragraph">
<p>要自定义事件名称，可以使用<code>@JsonTypeName</code>在您的自定义类上还是依靠默认策略，即使用该类的简单名称。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">生产者和消费者都需要访问类定义。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="registering-events-in-custom-packages"><a class="anchor" href="#registering-events-in-custom-packages"></a> <a class="link" href="#registering-events-in-custom-packages">7.8.1。在自定义包中注册事件</a></h4>
<div class="paragraph">
<p>如果您不能或不想使用以下子包<code>org.springframework.cloud.bus.event</code>对于您的自定义事件，必须指定要扫描哪些程序包以查找类型的事件<code>RemoteApplicationEvent</code>通过使用<code>@RemoteApplicationEventScan</code>注解。指定的套件<code>@RemoteApplicationEventScan</code>包括子包。</p>
</div>
<div class="paragraph">
<p>例如，考虑以下自定义事件，即<code>MyEvent</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme;

public class MyEvent extends RemoteApplicationEvent {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过以下方式在解串器中注册该事件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme;

@Configuration
@RemoteApplicationEventScan
public class BusConfiguration {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在不指定值的情况下，该类的包<code>@RemoteApplicationEventScan</code>用于注册。在这个例子中<code>com.acme</code>通过使用以下软件包注册<code>BusConfiguration</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以使用来明确指定要扫描的软件包<code>value</code> ， <code>basePackages</code>要么<code>basePackageClasses</code>的属性<code>@RemoteApplicationEventScan</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme;

@Configuration
//@RemoteApplicationEventScan({"com.acme", "foo.bar"})
//@RemoteApplicationEventScan(basePackages = {"com.acme", "foo.bar", "fizz.buzz"})
@RemoteApplicationEventScan(basePackageClasses = BusConfiguration.class)
public class BusConfiguration {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上所有示例<code>@RemoteApplicationEventScan</code>是等效的，因为<code>com.acme</code>通过显式指定软件包来注册软件包<code>@RemoteApplicationEventScan</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以指定多个要扫描的基本软件包。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-4"><a class="anchor" href="#configuration-properties-4"></a> <a class="link" href="#configuration-properties-4">7.9。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与总线相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-sleuth"><a class="anchor" href="#spring-cloud-sleuth"></a> <a class="link" href="#spring-cloud-sleuth">8。Spring Cloud侦探</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>阿德里安·科尔（Adrian Cole），斯宾塞·吉布（Spencer Gibb），玛琳·格热兹兹克（Marcin Grzejszczak），戴夫·瑟（Dave Syer），杰伊·布莱恩特（Jay Bryant）</p>
</div>
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="sect2">
<h3 id="introduction-2"><a class="anchor" href="#introduction-2"></a> <a class="link" href="#introduction-2">8.1。介绍</a></h3>
<div class="paragraph">
<p>Spring Cloud Sleuth为<a href="https://cloud.spring.io">Spring Cloud</a>实现了分布式跟踪解决方案。</p>
</div>
<div class="sect3">
<h4 id="terminology"><a class="anchor" href="#terminology"></a> <a class="link" href="#terminology">8.1.1。术语</a></h4>
<div class="paragraph">
<p>Spring Cloud Sleuth借用了<a href="https://research.google.com/pubs/pub36356.html">Dapper的</a>术语。</p>
</div>
<div class="paragraph">
<p><strong>跨度</strong> ：基本工作单位。例如，发送RPC是一个新的跨度，就像发送响应到RPC一样。跨度由跨度的唯一64位ID和跨度所属的跟踪的另一个64位ID标识。跨区还具有其他数据，例如描述，带有时间戳的事件，键值批注（标签），引起跨度的跨区ID和进程ID（通常为IP地址）。</p>
</div>
<div class="paragraph">
<p>跨度可以启动和停止，并且可以跟踪其时序信息。创建跨度后，您必须在将来的某个时间点将其停止。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">开始跟踪的初始跨度称为<code>root span</code> 。该跨度的ID的值等于跟踪ID。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><strong>迹线：</strong>一组形成树状结构的跨度。例如，如果您运行分布式大数据存储，则跟踪可能由<code>PUT</code>请求。</p>
</div>
<div class="paragraph">
<p><strong>注释：</strong>用于及时记录事件的存在。使用<a href="https://github.com/openzipkin/brave">Brave</a>工具，我们不再需要为<a href="https://zipkin.io/">Zipkin</a>设置特殊事件来了解客户端和服务器是谁，请求在哪里开始以及在哪里结束。但是，出于学习目的，我们标记这些事件以突出显示发生了哪种操作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>cs</strong> ：客户端已发送。客户提出了要求。此注释指示跨度的开始。</p>
</li>
<li>
<p><strong>sr</strong> ：接收到服务器：服务器端收到了请求并开始处理它。减去<code>cs</code>此时间戳中的时间戳显示了网络延迟。</p>
</li>
<li>
<p><strong>ss</strong> ：服务器已发送。在请求处理完成时进行注释（当响应被发送回客户端时）。减去<code>sr</code>此时间戳中的时间戳显示了服务器端处理请求所需的时间。</p>
</li>
<li>
<p><strong>cr</strong> ：收到客户。表示跨度结束。客户端已成功收到服务器端的响应。减去<code>cs</code>此时间戳中的时间戳显示了客户端从服务器接收响应所需的整个时间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下图显示了<strong>Span</strong>和<strong>Trace</strong>以及Zipkin批注在系统中的外观：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/trace-id.png" alt="跟踪信息传播">
</div>
</div>
<div class="paragraph">
<p>音符的每种颜色表示一个跨度（有七个跨度-从<strong>A</strong>到<strong>G</strong> ）。请考虑以下注意事项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Trace Id = X
Span Id = D
Client Sent</code></pre>
</div>
</div>
<div class="paragraph">
<p>此注释表示当前跨度已将“ <strong>跟踪ID”</strong>设置为<strong>X</strong>并将“ <strong>跨度ID”</strong>设置为<strong>D。</strong>另外， <code>Client Sent</code>事件发生了。</p>
</div>
<div class="paragraph">
<p>下图显示了跨度的父子关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/parents.png" alt="亲子关系">
</div>
</div>
</div>
<div class="sect3">
<h4 id="purpose"><a class="anchor" href="#purpose"></a> <a class="link" href="#purpose">8.1.2。目的</a></h4>
<div class="paragraph">
<p>以下各节引用上图中显示的示例。</p>
</div>
<div class="sect4">
<h5 id="distributed-tracing-with-zipkin"><a class="anchor" href="#distributed-tracing-with-zipkin"></a> <a class="link" href="#distributed-tracing-with-zipkin">使用Zipkin进行分布式跟踪</a></h5>
<div class="paragraph">
<p>本示例有七个跨度。如果转到Zipkin中的跟踪，则可以在第二个跟踪中看到此数字，如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-traces.png" alt="痕迹">
</div>
</div>
<div class="paragraph">
<p>但是，如果选择一条特定的迹线，则会看到四个跨度，如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-ui.png" alt="跟踪信息传播">
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">选择特定轨迹时，会看到合并的跨度。这意味着，如果有两个跨度发送到Zipkin，且带有“服务器已接收和服务器已发送”或“客户端已接收和客户端已发送”注释，则它们将显示为单个跨度。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这种情况下，为什么七个跨度和四个跨度有区别？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个跨度来自<code>http:/start</code>跨度。它已收到服务器（ <code>sr</code> ）和已发送的服务器（ <code>ss</code> ）注释。</p>
</li>
<li>
<p>来自两个RPC调用的两个范围<code>service1</code>至<code>service2</code>到<code>http:/foo</code>端点。客户已发送（ <code>cs</code> ），并收到客户（ <code>cr</code> ）事件发生在<code>service1</code>侧。服务器已收到（ <code>sr</code> ）和已发送的服务器（ <code>ss</code> ）事件发生在<code>service2</code>侧。这两个范围形成一个与RPC调用相关的逻辑范围。</p>
</li>
<li>
<p>来自两个RPC调用的两个范围<code>service2</code>至<code>service3</code>到<code>http:/bar</code>端点。客户已发送（ <code>cs</code> ），并收到客户（ <code>cr</code> ）事件发生在<code>service2</code>侧。服务器收到（ <code>sr</code> ）和已发送的服务器（ <code>ss</code> ）事件发生在<code>service3</code>侧。这两个范围形成一个与RPC调用相关的逻辑范围。</p>
</li>
<li>
<p>来自两个RPC调用的两个范围<code>service2</code>至<code>service4</code>到<code>http:/baz</code>端点。客户已发送（ <code>cs</code> ），并收到客户（ <code>cr</code> ）事件发生在<code>service2</code>侧。服务器已收到（ <code>sr</code> ）和已发送的服务器（ <code>ss</code> ）事件发生在<code>service4</code>侧。这两个范围形成一个与RPC调用相关的逻辑范围。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，如果我们计算物理跨度，则有一个<code>http:/start</code> ，两个来自<code>service1</code>呼唤<code>service2</code> ，两个来自<code>service2</code>呼唤<code>service3</code>和两个来自<code>service2</code>呼唤<code>service4</code> 。总而言之，我们共有七个跨度。</p>
</div>
<div class="paragraph">
<p>从逻辑上讲，我们看到四个跨度的信息，因为我们有一个跨度与传入请求有关<code>service1</code>和与RPC调用相关的三个范围。</p>
</div>
</div>
<div class="sect4">
<h5 id="visualizing-errors"><a class="anchor" href="#visualizing-errors"></a> <a class="link" href="#visualizing-errors">可视化错误</a></h5>
<div class="paragraph">
<p>Zipkin使您可以可视化跟踪中的错误。当引发异常但未捕获到异常时，我们在跨度上设置了适当的标签，然后Zipkin可以正确着色。您可以在迹线列表中看到一条红色的迹线。之所以出现，是因为引发了异常。</p>
</div>
<div class="paragraph">
<p>如果单击该跟踪，将看到类似的图片，如下所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-error-traces.png" alt="错误痕迹">
</div>
</div>
<div class="paragraph">
<p>如果您再单击其中一个跨度，则会看到以下内容</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/zipkin-error-trace-screenshot.png" alt="错误跟踪信息传播">
</div>
</div>
<div class="paragraph">
<p>跨度显示错误的原因以及与之相关的整个堆栈跟踪。</p>
</div>
</div>
<div class="sect4">
<h5 id="distributed-tracing-with-brave"><a class="anchor" href="#distributed-tracing-with-brave"></a> <a class="link" href="#distributed-tracing-with-brave">勇敢的分布式跟踪</a></h5>
<div class="paragraph">
<p>从版本开始<code>2.0.0</code> ，Spring Cloud Sleuth使用<a href="https://github.com/openzipkin/brave">Brave</a>作为跟踪库。因此，Sleuth不再负责存储上下文，而是将工作委托给Brave。</p>
</div>
<div class="paragraph">
<p>由于Sleuth与Brave具有不同的命名和标记约定，因此我们决定从现在开始遵循Brave的约定。但是，如果您想使用传统的Sleuth方法，则可以设置<code>spring.sleuth.http.legacy.enabled</code>财产<code>true</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="live-examples"><a class="anchor" href="#live-examples"></a> <a class="link" href="#live-examples">现场例子</a></h5>
<div class="imageblock">
<div class="content">
<a class="image" href="https://docssleuth-zipkin-server.cfapps.io/"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/pws.png" alt="Zipkin部署在Pivotal Web Services上" width="150" height="74"></a>
</div>
<div class="title">单击“ Pivotal Web服务”图标可实时观看！单击“ Pivotal Web服务”图标可实时观看！</div>
</div>
<div class="paragraph">
<p><a href="https://docssleuth-zipkin-server.cfapps.io/">点击此处观看直播！</a></p>
</div>
<div class="paragraph">
<p>Zipkin中的依赖关系图应类似于下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/dependencies.png" alt="依存关系">
</div>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://docssleuth-zipkin-server.cfapps.io/dependency"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/pws.png" alt="Zipkin部署在Pivotal Web Services上" width="150" height="74"></a>
</div>
<div class="title">单击“ Pivotal Web服务”图标可实时观看！单击“ Pivotal Web服务”图标可实时观看！</div>
</div>
<div class="paragraph">
<p><a href="https://docssleuth-zipkin-server.cfapps.io/dependency">点击此处观看直播！</a></p>
</div>
</div>
<div class="sect4">
<h5 id="log-correlation"><a class="anchor" href="#log-correlation"></a> <a class="link" href="#log-correlation">日志关联</a></h5>
<div class="paragraph">
<p>使用grep通过扫描等于（例如）的跟踪ID读取这四个应用程序的日志时<code>2485ec27856c56f4</code> ，您将获得类似于以下内容的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>service1.log:2016-02-26 11:15:47.561  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Hello from service1. Calling service2
service2.log:2016-02-26 11:15:47.710  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Hello from service2. Calling service3 and then service4
service3.log:2016-02-26 11:15:47.895  INFO [service3,2485ec27856c56f4,1210be13194bfe5,true] 68060 --- [nio-8083-exec-1] i.s.c.sleuth.docs.service3.Application   : Hello from service3
service2.log:2016-02-26 11:15:47.924  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service3 [Hello from service3]
service4.log:2016-02-26 11:15:48.134  INFO [service4,2485ec27856c56f4,1b1845262ffba49d,true] 68061 --- [nio-8084-exec-1] i.s.c.sleuth.docs.service4.Application   : Hello from service4
service2.log:2016-02-26 11:15:48.156  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service4 [Hello from service4]
service1.log:2016-02-26 11:15:48.182  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Got response from service2 [Hello from service2, response from service3 [Hello from service3] and from service4 [Hello from service4]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用日志汇总工具（例如<a href="https://www.elastic.co/products/kibana">Kibana</a> ， <a href="https://www.splunk.com/">Splunk</a>和其他工具），则可以对发生的事件进行排序。来自Kibana的示例类似于下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-sleuth/master/docs/src/main/asciidoc/images/kibana.png" alt="与Kibana的对数关联">
</div>
</div>
<div class="paragraph">
<p>如果要使用<a href="https://www.elastic.co/guide/en/logstash/current/index.html">Logstash</a> ，以下清单显示了Logstash的Grok模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>filter {
       # pattern matching logback pattern
       grok {
              match => { "message" => "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果要将Grok与Cloud Foundry的日志一起使用，则必须使用以下模式：</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>filter {
       # pattern matching logback pattern
       grok {
              match => { "message" => "(?m)OUT\s+%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}\s+---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
       }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="json-logback-with-logstash"><a class="anchor" href="#json-logback-with-logstash"></a> <a class="link" href="#json-logback-with-logstash">使用Logstash进行JSON Logback</a></h6>
<div class="paragraph">
<p>通常，您不想将日志存储在文本文件中，而是存储在Logstash可以立即选择的JSON文件中。为此，您必须执行以下操作（出于可读性考虑，我们在<code>groupId:artifactId:version</code>符号）。</p>
</div>
<div class="paragraph">
<p><strong>依赖关系设置</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>确保Logback位于类路径（ <code>ch.qos.logback:logback-core</code> ）。</p>
</li>
<li>
<p>添加Logstash Logback编码。例如，使用版本<code>4.6</code> ，添加<code>net.logstash.logback:logstash-logback-encoder:4.6</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>登录设置</strong></p>
</div>
<div class="paragraph">
<p>考虑以下Logback配置文件示例（名为<a href="https://github.com/spring-cloud-samples/sleuth-documentation-apps/blob/master/service1/src/main/resources/logback-spring.xml">logback-spring.xml</a> ）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    ​
    <springProperty scope="context" name="springAppName" source="spring.application.name"/>
    <!-- Example for logging into the build folder of your project -->
    <property name="LOG_FILE" value="${BUILD_FOLDER:-build}/${springAppName}"/>​

    <!-- You can override this to have a custom pattern -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"/>

    <!-- Appender to log to console -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <!-- Minimum logging level to be presented in the console logs-->
            <level>DEBUG</level>
        </filter>
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- Appender to log to file -->​
    <appender name="flatfile" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.gz</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>
    ​
    <!-- Appender to log to file in a JSON format -->
    <appender name="logstash" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}.json</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.json.%d{yyyy-MM-dd}.gz</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp>
                    <timeZone>UTC</timeZone>
                </timestamp>
                <pattern>
                    <pattern>
                        {
                        "severity": "%level",
                        "service": "${springAppName:-}",
                        "trace": "%X{X-B3-TraceId:-}",
                        "span": "%X{X-B3-SpanId:-}",
                        "parent": "%X{X-B3-ParentSpanId:-}",
                        "exportable": "%X{X-Span-Export:-}",
                        "pid": "${PID:-}",
                        "thread": "%thread",
                        "class": "%logger{40}",
                        "rest": "%message"
                        }
                    </pattern>
                </pattern>
            </providers>
        </encoder>
    </appender>
    ​
    <root level="INFO">
        <appender-ref ref="console"/>
        <!-- uncomment this to have also JSON logs -->
        <!--<appender-ref ref="logstash"/>-->
        <!--<appender-ref ref="flatfile"/>-->
    </root>
</configuration></code></pre>
</div>
</div>
<div class="paragraph">
<p>该Logback配置文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将应用程序中的信息以JSON格式记录到<code>build/${spring.application.name}.json</code>文件。</p>
</li>
<li>
<p>注释了两个附加的附加程序：控制台和标准日志文件。</p>
</li>
<li>
<p>具有与上一部分相同的日志记录模式。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您使用自定义<code>logback-spring.xml</code> ，您必须通过<code>spring.application.name</code>在里面<code>bootstrap</code>而不是<code>application</code>属性文件。否则，您的自定义登录文件将无法正确读取该属性。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="propagating-span-context"><a class="anchor" href="#propagating-span-context"></a> <a class="link" href="#propagating-span-context">传播跨度上下文</a></h5>
<div class="paragraph">
<p>跨度上下文是必须跨进程边界传播到任何子跨度的状态。跨度上下文的一部分是行李。跟踪和跨度ID是跨度上下文的必需部分。行李是可选部件。</p>
</div>
<div class="paragraph">
<p>行李是存储在span上下文中的一组key：value对。行李与踪迹一起旅行，并附着在每个跨度上。Spring Cloud Sleuth理解，如果HTTP标头带有前缀，则标头与行李相关<code>baggage-</code>对于消息传递，它从<code>baggage_</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">当前对行李物品的数量或大小没有限制。但是，请记住，太多会降低系统吞吐量或增加RPC延迟。在极端情况下，由于超出传输级别的消息或报头容量，过多的行李可能会使应用程序崩溃。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示跨度设置行李：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Span initialSpan = this.tracer.nextSpan().name("span").start();
ExtraFieldPropagation.set(initialSpan.context(), "foo", "bar");
ExtraFieldPropagation.set(initialSpan.context(), "UPPER_CASE", "someValue");</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="baggage-versus-span-tags"><a class="anchor" href="#baggage-versus-span-tags"></a> <a class="link" href="#baggage-versus-span-tags">行李与跨度标签</a></h6>
<div class="paragraph">
<p>行李随身携带（每个孩子跨度都包含其父母的行李）。Zipkin不了解行李，也不会收到该信息。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">从Sleuth 2.0.0开始，您必须在项目配置中显式传递行李密钥名称。<a href="#prefixed-fields">在此处</a>阅读有关该设置的更多信息
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>标签被附加到特定范围。换句话说，它们仅针对该特定跨度显示。但是，您可以按标签搜索以找到轨迹，前提是存在一个具有所搜索标签值的跨度。</p>
</div>
<div class="paragraph">
<p>如果您希望能够基于行李查找跨度，则应在根跨度中添加相应的条目作为标签。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">范围必须在范围内。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下清单显示了使用行李的集成测试：</p>
</div>
<div class="listingblock">
<div class="title">设置</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring.sleuth:
  baggage-keys:
    - baz
    - bizarrecase
  propagation-keys:
    - foo
    - upper_case</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">代码</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">initialSpan.tag("foo",
        ExtraFieldPropagation.get(initialSpan.context(), "foo"));
initialSpan.tag("UPPER_CASE",
        ExtraFieldPropagation.get(initialSpan.context(), "UPPER_CASE"));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sleuth-adding-project"><a class="anchor" href="#sleuth-adding-project"></a> <a class="link" href="#sleuth-adding-project">8.1.3。将侦探添加到项目中</a></h4>
<div class="paragraph">
<p>本节介绍如何使用Maven或Gradle将Sleuth添加到项目中。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">为确保您的应用名称正确显示在Zipkin中，请设置<code>spring.application.name</code>财产<code>bootstrap.yml</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="only-sleuth-log-correlation"><a class="anchor" href="#only-sleuth-log-correlation"></a> <a class="link" href="#only-sleuth-log-correlation">仅侦探（对数相关）</a></h5>
<div class="paragraph">
<p>如果您只想使用Spring Cloud Sleuth而没有Zipkin集成，请添加<code>spring-cloud-starter-sleuth</code>模块到您的项目。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用Maven添加Sleuth：</p>
</div>
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement> <i class="conum" data-value="1"></i><b>(1)</b>
      <dependencies>
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-dependencies</artifactId>
              <version>${release.train.version}</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
      </dependencies>
</dependencyManagement>

<dependency> <i class="conum" data-value="2"></i><b>(2)</b>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将依赖项添加到<code>spring-cloud-starter-sleuth</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用Gradle添加Sleuth：</p>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencyManagement { <i class="conum" data-value="1"></i><b>(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"
    }
}

dependencies { <i class="conum" data-value="2"></i><b>(2)</b>
    compile "org.springframework.cloud:spring-cloud-starter-sleuth"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将依赖项添加到<code>spring-cloud-starter-sleuth</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sleuth-with-zipkin-via-http"><a class="anchor" href="#sleuth-with-zipkin-via-http"></a> <a class="link" href="#sleuth-with-zipkin-via-http">通过HTTP与Zipkin一起侦探</a></h5>
<div class="paragraph">
<p>如果您同时需要Sleuth和Zipkin，请添加<code>spring-cloud-starter-zipkin</code>依赖性。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何对Maven执行此操作：</p>
</div>
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement> <i class="conum" data-value="1"></i><b>(1)</b>
      <dependencies>
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-dependencies</artifactId>
              <version>${release.train.version}</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
      </dependencies>
</dependencyManagement>

<dependency> <i class="conum" data-value="2"></i><b>(2)</b>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将依赖项添加到<code>spring-cloud-starter-zipkin</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何对Gradle进行操作：</p>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencyManagement { <i class="conum" data-value="1"></i><b>(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"
    }
}

dependencies { <i class="conum" data-value="2"></i><b>(2)</b>
    compile "org.springframework.cloud:spring-cloud-starter-zipkin"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将依赖项添加到<code>spring-cloud-starter-zipkin</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="sleuth-with-zipkin-over-rabbitmq-or-kafka"><a class="anchor" href="#sleuth-with-zipkin-over-rabbitmq-or-kafka"></a> <a class="link" href="#sleuth-with-zipkin-over-rabbitmq-or-kafka">通过RabbitMQ或Kafka与Zipkin一起侦探</a></h5>
<div class="paragraph">
<p>如果您要使用RabbitMQ或Kafka而不是HTTP，请添加<code>spring-rabbit</code>要么<code>spring-kafka</code>依赖性。默认目的地名称是<code>zipkin</code> 。</p>
</div>
<div class="paragraph">
<p>如果使用Kafka，则必须设置属性<code>spring.zipkin.sender.type</code>相应的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.zipkin.sender.type: kafka</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<code>spring-cloud-sleuth-stream</code>已不推荐使用，并且与这些目的地不兼容。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要让Sleuth优于RabbitMQ，请添加<code>spring-cloud-starter-zipkin</code>和<code>spring-rabbit</code>依赖性。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何对Gradle进行操作：</p>
</div>
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement> <i class="conum" data-value="1"></i><b>(1)</b>
      <dependencies>
          <dependency>
              <groupId>org.springframework.cloud</groupId>
              <artifactId>spring-cloud-dependencies</artifactId>
              <version>${release.train.version}</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
      </dependencies>
</dependencyManagement>

<dependency> <i class="conum" data-value="2"></i><b>(2)</b>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
<dependency> <i class="conum" data-value="3"></i><b>(3)</b>
    <groupId>org.springframework.amqp</groupId>
    <artifactId>spring-rabbit</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将依赖项添加到<code>spring-cloud-starter-zipkin</code> 。这样，所有嵌套的依赖项都将被下载。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>要自动配置RabbitMQ，请添加<code>spring-rabbit</code>依赖性。</td>
</tr>
</tbody></table>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencyManagement { <i class="conum" data-value="1"></i><b>(1)</b>
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${releaseTrainVersion}"
    }
}

dependencies {
    compile "org.springframework.cloud:spring-cloud-starter-zipkin" <i class="conum" data-value="2"></i><b>(2)</b>
    compile "org.springframework.amqp:spring-rabbit" <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们建议您通过Spring BOM添加依赖项管理，这样就不必自己管理版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>将依赖项添加到<code>spring-cloud-starter-zipkin</code> 。这样，所有嵌套的依赖项都将被下载。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>要自动配置RabbitMQ，请添加<code>spring-rabbit</code>依赖性。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="overriding-the-auto-configuration-of-zipkin"><a class="anchor" href="#overriding-the-auto-configuration-of-zipkin"></a> <a class="link" href="#overriding-the-auto-configuration-of-zipkin">8.1.4。覆盖Zipkin的自动配置</a></h4>
<div class="paragraph">
<p>从2.1.0版开始，Spring Cloud Sleuth支持将跟踪发送到多个跟踪系统。为了使它起作用，每个跟踪系统都需要有一个<code>Reporter<Span></code>和<code>Sender</code> 。如果要覆盖提供的bean，则需要给它们指定一个特定的名称。为此，您可以分别使用<code>ZipkinAutoConfiguration.REPORTER_BEAN_NAME</code>和<code>ZipkinAutoConfiguration.SENDER_BEAN_NAME</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
protected static class MyConfig {

    @Bean(ZipkinAutoConfiguration.REPORTER_BEAN_NAME)
    Reporter<zipkin2.Span> myReporter() {
        return AsyncReporter.create(mySender());
    }

    @Bean(ZipkinAutoConfiguration.SENDER_BEAN_NAME)
    MySender mySender() {
        return new MySender();
    }

    static class MySender extends Sender {

        private boolean spanSent = false;

        boolean isSpanSent() {
            return this.spanSent;
        }

        @Override
        public Encoding encoding() {
            return Encoding.JSON;
        }

        @Override
        public int messageMaxBytes() {
            return Integer.MAX_VALUE;
        }

        @Override
        public int messageSizeInBytes(List<byte[]> encodedSpans) {
            return encoding().listSizeInBytes(encodedSpans);
        }

        @Override
        public Call<Void> sendSpans(List<byte[]> encodedSpans) {
            this.spanSent = true;
            return Call.create(null);
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="additional-resources"><a class="anchor" href="#additional-resources"></a> <a class="link" href="#additional-resources">8.2。其他资源</a></h3>
<div class="paragraph">
<p><a href="https://content.pivotal.io/springone-platform-2017/distributed-tracing-latency-analysis-for-your-microservices-grzejszczak-krishna">单击此处，</a>您可以观看<a href="https://twitter.com/reshmi9k">Reshmi Krishna</a>和<a href="https://twitter.com/mgrzejszczak">Marcin Grzejszczak</a>谈论有关Spring Cloud Sleuth和Zipkin <a href="https://content.pivotal.io/springone-platform-2017/distributed-tracing-latency-analysis-for-your-microservices-grzejszczak-krishna">的视频</a> 。</p>
</div>
<div class="paragraph">
<p>您可以<a href="https://github.com/openzipkin/sleuth-webmvc-example">在openzipkin / sleuth-webmvc-example系统信息库中</a>检查Sleuth和Brave的不同设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="features-2"><a class="anchor" href="#features-2"></a> <a class="link" href="#features-2">8.3。特征</a></h3>
<div class="ulist">
<ul>
<li>
<p>将跟踪和跨度ID添加到Slf4J MDC，因此您可以在日志聚合器中从给定的跟踪或跨度提取所有日志，如以下示例日志所示：</p>
<div class="listingblock">
<div class="content">
<pre>2016-02-02 15:30:57.902  INFO [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:30:58.372 ERROR [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
2016-02-02 15:31:01.936  INFO [bar,46ab0d418373cbc9,46ab0d418373cbc9,false] 23030 --- [nio-8081-exec-4] ...</pre>
</div>
</div>
<div class="paragraph">
<p>注意<code>[appname,traceId,spanId,exportable]</code>来自MDC的条目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>spanId</code></strong> ：发生的特定操作的ID。</p>
</li>
<li>
<p><strong><code>appname</code></strong> ：记录跨度的应用程序的名称。</p>
</li>
<li>
<p><strong><code>traceId</code></strong> ：包含跨度的延迟图的ID。</p>
</li>
<li>
<p><strong><code>exportable</code></strong> ：是否应将日志导出到Zipkin。您何时希望跨度不可导出？当您要将某些操作包装在Span中并将其仅写入日志时。</p>
</li>
</ul>
</div>
</li>
<li>
<p>提供对常见的分布式跟踪数据模型的抽象：跟踪，跨度（形成DAG），注释和键值注释。Spring Cloud Sleuth宽松地基于HTrace，但与Zipkin（Dapper）兼容。</p>
</li>
<li>
<p>Sleuth记录计时信息以帮助进行延迟分析。通过使用侦探，您可以查明应用程序中延迟的原因。</p>
</li>
<li>
<p>编写Sleuth时不要过多记录日志，也不会导致生产应用程序崩溃。为此，Sleuth：</p>
<div class="ulist">
<ul>
<li>
<p>在带内传播有关调用图的结构数据，并在带外传播其余数据。</p>
</li>
<li>
<p>包括对诸如HTTP之类的层的自觉检测。</p>
</li>
<li>
<p>包括用于管理数量的采样策略。</p>
</li>
<li>
<p>可以报告给Zipkin系统进行查询和可视化。</p>
</li>
</ul>
</div>
</li>
<li>
<p>从Spring应用程序（Servlet过滤器，异步端点，Rest模板，计划的动作，消息通道，Zuul过滤器和Feign客户端）检测常见的入口和出口点。</p>
</li>
<li>
<p>Sleuth包含默认逻辑以跨HTTP或消息传递边界加入跟踪。例如，HTTP传播在与Zipkin兼容的请求标头上工作。</p>
</li>
<li>
<p>侦查可以在进程之间传播上下文（也称为行李）。因此，如果您在Span上设置了行李元素，则会通过HTTP或消息传递将其下游发送到其他进程。</p>
</li>
<li>
<p>提供一种创建或继续跨度以及通过注释添加标签和日志的方法。</p>
</li>
<li>
<p>如果<code>spring-cloud-sleuth-zipkin</code>在类路径上，该应用程序会生成并收集与Zipkin兼容的跟踪。默认情况下，它通过HTTP将它们发送到本地主机（端口9411）上的Zipkin服务器。您可以通过设置配置服务的位置<code>spring.zipkin.baseUrl</code> 。</p>
<div class="ulist">
<ul>
<li>
<p>如果你依靠<code>spring-rabbit</code> ，您的应用会将跟踪发送到RabbitMQ代理，而不是HTTP。</p>
</li>
<li>
<p>如果你依靠<code>spring-kafka</code> ，并设置<code>spring.zipkin.sender.type: kafka</code> ，您的应用会将跟踪发送到Kafka代理，而不是HTTP。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">
<code>spring-cloud-sleuth-stream</code>已弃用，不应再使用。
</td>
</tr>
</tbody></table>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Cloud Sleuth与<a href="https://opentracing.io/">OpenTracing</a>兼容。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">始终设置SLF4J MDC，并且按先前显示的示例，登录用户可以立即在日志中看到跟踪和跨度ID。其他日志记录系统必须配置自己的格式化程序才能获得相同的结果。默认值如下： <code>logging.pattern.level</code>调成<code>%5p [${spring.zipkin.service.name:${spring.application.name:-}},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}]</code> （这是Logback用户的Spring Boot功能）。如果您不使用SLF4J，则不会自动应用此模式。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="introduction-to-brave"><a class="anchor" href="#introduction-to-brave"></a> <a class="link" href="#introduction-to-brave">8.3.1。勇敢简介</a></h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">从版本开始<code>2.0.0</code> ，Spring Cloud Sleuth使用<a href="https://github.com/openzipkin/brave">Brave</a>作为跟踪库。为了您的方便，我们在此处嵌入了Brave文档的一部分。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">在大多数情况下，您只需要使用<code>Tracer</code>要么<code>SpanCustomizer</code> Sleuth提供的Brave中的咖啡豆。以下文档高度概述了Brave是什么以及它如何工作。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>勇敢是一个库，用于捕获有关分布式操作的延迟信息并将其报告给Zipkin。大多数用户不直接使用Brave。他们使用库或框架，而不是代表他们使用Brave。</p>
</div>
<div class="paragraph">
<p>该模块包括一个跟踪器，该跟踪器创建并连接跨度，以对潜在的分布式工作的延迟进行建模。它还包括用于在网络边界上传播跟踪上下文的库（例如，使用HTTP标头）。</p>
</div>
<div class="sect4">
<h5 id="tracing"><a class="anchor" href="#tracing"></a> <a class="link" href="#tracing">追踪</a></h5>
<div class="paragraph">
<p>最重要的是，您需要<code>brave.Tracer</code> ，配置为<a href="https://github.com/openzipkin/zipkin-reporter-java">向Zipkin报告</a> 。</p>
</div>
<div class="paragraph">
<p>以下示例安装程序通过HTTP（与Kafka相对）将跟踪数据（跨度）发送到Zipkin：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyClass {

    private final Tracer tracer;

    // Tracer will be autowired
    MyClass(Tracer tracer) {
        this.tracer = tracer;
    }

    void doSth() {
        Span span = tracer.newTrace().name("encode").start();
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您的跨度包含的名称长于50个字符，则该名称将被截断为50个字符。您的姓名必须明确明确。知名人士会导致延迟问题，有时甚至会引发异常。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>跟踪器创建并连接跨度，以对潜在的分布式工作的延迟进行建模。它可以采用采样来减少处理过程中的开销，减少发送到Zipkin的数据量或两者。</p>
</div>
<div class="paragraph">
<p>跟踪器返回的跨距在完成后将数据报告给Zipkin，如果未采样则不执行任何操作。开始跨度后，您可以注释感兴趣的事件或添加包含详细信息或查找键的标签。</p>
</div>
<div class="paragraph">
<p>跨度具有包括跟踪标识符的上下文，该标识符将跨度放置在代表分布式操作的树中的正确位置。</p>
</div>
</div>
<div class="sect4">
<h5 id="local-tracing"><a class="anchor" href="#local-tracing"></a> <a class="link" href="#local-tracing">本地追踪</a></h5>
<div class="paragraph">
<p>跟踪永远不会离开进程的代码时，请在范围范围内运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracer tracer;

// Start a new trace or a span within an existing trace representing an operation
ScopedSpan span = tracer.startScopedSpan("encode");
try {
  // The span is in "scope" meaning downstream code such as loggers can see trace IDs
  return encoder.encode();
} catch (RuntimeException | Error e) {
  span.error(e); // Unless you handle exceptions, you might not know the operation failed!
  throw e;
} finally {
  span.finish(); // always finish the span
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您需要更多功能或更好的控制时，请使用<code>Span</code>类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracer tracer;

// Start a new trace or a span within an existing trace representing an operation
Span span = tracer.nextSpan().name("encode").start();
// Put the span in "scope" so that downstream code such as loggers can see trace IDs
try (SpanInScope ws = tracer.withSpanInScope(span)) {
  return encoder.encode();
} catch (RuntimeException | Error e) {
  span.error(e); // Unless you handle exceptions, you might not know the operation failed!
  throw e;
} finally {
  span.finish(); // note the scope is independent of the span. Always finish a span.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的两个示例都报告了完全相同的跨度！</p>
</div>
<div class="paragraph">
<p>在上面的示例中，范围将是新的根范围或现有跟踪中的下一个子级。</p>
</div>
</div>
<div class="sect4">
<h5 id="customizing-spans"><a class="anchor" href="#customizing-spans"></a> <a class="link" href="#customizing-spans">自定义跨度</a></h5>
<div class="paragraph">
<p>一旦具有跨度，就可以向其添加标签。标记可用作查找键或详细信息。例如，您可以在运行时版本中添加标签，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">span.tag("clnt/finagle.version", "6.36.0");</code></pre>
</div>
</div>
<div class="paragraph">
<p>向第三方公开自定义跨度的功能时，请优先使用<code>brave.SpanCustomizer</code>相对于<code>brave.Span</code> 。前者更易于理解和测试，不会用跨度生命周期挂钩吸引用户。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface MyTraceCallback {
  void request(Request request, SpanCustomizer customizer);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以来<code>brave.Span</code>贯彻<code>brave.SpanCustomizer</code> ，您可以将其传递给用户，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">for (MyTraceCallback callback : userCallbacks) {
  callback.request(request, span);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="implicitly-looking-up-the-current-span"><a class="anchor" href="#implicitly-looking-up-the-current-span"></a> <a class="link" href="#implicitly-looking-up-the-current-span">隐式查找当前跨度</a></h5>
<div class="paragraph">
<p>有时，您不知道跟踪是否正在进行，并且您不希望用户执行空检查。
<code>brave.CurrentSpanCustomizer</code>通过将数据添加到正在进行或删除的任何跨度中来解决此问题，如以下示例所示：</p>
</div>
<div class="paragraph">
<p>例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// The user code can then inject this without a chance of it being null.
@Autowired SpanCustomizer span;

void userCode() {
  span.annotate("tx.started");
  ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rpc-tracing"><a class="anchor" href="#rpc-tracing"></a> <a class="link" href="#rpc-tracing">RPC追踪</a></h5>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在滚动自己的RPC工具之前，请检查<a href="https://github.com/openzipkin/brave/tree/master/instrumentation">此处编写</a>的<a href="https://github.com/openzipkin/brave/tree/master/instrumentation">工具</a>以及<a href="https://zipkin.io/pages/existing_instrumentations.html">Zipkin的列表</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>RPC跟踪通常由拦截器自动完成。它们在幕后添加了与其在RPC操作中的角色相关的标签和事件。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何添加客户端范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracing tracing;
@Autowired Tracer tracer;

// before you send a request, add metadata that describes the operation
span = tracer.nextSpan().name(service + "/" + method).kind(CLIENT);
span.tag("myrpc.version", "1.0.0");
span.remoteServiceName("backend");
span.remoteIpAndPort("172.3.4.1", 8108);

// Add the trace context to the request, so it can be propagated in-band
tracing.propagation().injector(Request::addHeader)
                     .inject(span.context(), request);

// when the request is scheduled, start the span
span.start();

// if there is an error, tag the span
span.tag("error", error.getCode());
// or if there is an exception
span.error(exception);

// when the response is complete, finish the span
span.finish();</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="one-way-tracing"><a class="anchor" href="#one-way-tracing"></a> <a class="link" href="#one-way-tracing">单向跟踪</a></h6>
<div class="paragraph">
<p>有时，您需要对有请求但无响应的异步操作进行建模。在普通的RPC跟踪中，您使用<code>span.finish()</code>表示已收到回复。在单向跟踪中，您使用<code>span.flush()</code>相反，因为您不希望得到响应。</p>
</div>
<div class="paragraph">
<p>下面的示例显示客户端如何建模单向操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracing tracing;
@Autowired Tracer tracer;

// start a new span representing a client request
oneWaySend = tracer.nextSpan().name(service + "/" + method).kind(CLIENT);

// Add the trace context to the request, so it can be propagated in-band
tracing.propagation().injector(Request::addHeader)
                     .inject(oneWaySend.context(), request);

// fire off the request asynchronously, totally dropping any response
request.execute();

// start the client side and flush instead of finish
oneWaySend.start().flush();</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示服务器如何处理单向操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracing tracing;
@Autowired Tracer tracer;

// pull the context out of the incoming request
extractor = tracing.propagation().extractor(Request::getHeader);

// convert that context to a span which you can name and add tags to
oneWayReceive = nextSpan(tracer, extractor.extract(request))
    .name("process-request")
    .kind(SERVER)
    ... add tags etc.

// start the server side and flush instead of finish
oneWayReceive.start().flush();

// you should not modify this span anymore as it is complete. However,
// you can create children to represent follow-up work.
next = tracer.newSpan(oneWayReceive.context()).name("step2").start();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sampling"><a class="anchor" href="#sampling"></a> <a class="link" href="#sampling">8.4。采样</a></h3>
<div class="paragraph">
<p>可以采用采样来减少收集和报告的过程外数据。如果未对跨度进行采样，则不会增加开销（无操作）。</p>
</div>
<div class="paragraph">
<p>采样是一项前期决策，这意味着报告数据的决策是在跟踪的第一个操作中做出的，并且该决策会向下游传播。</p>
</div>
<div class="paragraph">
<p>默认情况下，全局采样器将单个速率应用于所有跟踪的操作。
<code>Tracer.Builder.sampler</code>控制此设置，它默认为跟踪每个请求。</p>
</div>
<div class="sect3">
<h4 id="declarative-sampling"><a class="anchor" href="#declarative-sampling"></a> <a class="link" href="#declarative-sampling">8.4.1。声明式抽样</a></h4>
<div class="paragraph">
<p>一些应用程序需要根据java方法的类型或注释进行采样。</p>
</div>
<div class="paragraph">
<p>大多数用户使用框架拦截器来自动化这种策略。以下示例显示了它如何在内部工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracer tracer;

// derives a sample rate from an annotation on a java method
DeclarativeSampler<Traced> sampler = DeclarativeSampler.create(Traced::sampleRate);

@Around("@annotation(traced)")
public Object traceThing(ProceedingJoinPoint pjp, Traced traced) throws Throwable {
  // When there is no trace in progress, this decides using an annotation
  Sampler decideUsingAnnotation = declarativeSampler.toSampler(traced);
  Tracer tracer = tracer.withSampler(decideUsingAnnotation);

  // This code looks the same as if there was no declarative override
  ScopedSpan span = tracer.startScopedSpan(spanName(pjp));
  try {
    return pjp.proceed();
  } catch (RuntimeException | Error e) {
    span.error(e);
    throw e;
  } finally {
    span.finish();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="custom-sampling"><a class="anchor" href="#custom-sampling"></a> <a class="link" href="#custom-sampling">8.4.2。定制采样</a></h4>
<div class="paragraph">
<p>根据操作的不同，您可能需要应用不同的策略。例如，您可能不想跟踪对静态资源（例如图像）的请求，或者您想跟踪所有对新API的请求。</p>
</div>
<div class="paragraph">
<p>大多数用户使用框架拦截器来自动化这种策略。以下示例显示了它如何在内部工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracer tracer;
@Autowired Sampler fallback;

Span nextSpan(final Request input) {
  Sampler requestBased = Sampler() {
    @Override public boolean isSampled(long traceId) {
      if (input.url().startsWith("/experimental")) {
        return true;
      } else if (input.url().startsWith("/static")) {
        return false;
      }
      return fallback.isSampled(traceId);
    }
  };
  return tracer.withSampler(requestBased).nextSpan();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sampling-in-spring-cloud-sleuth"><a class="anchor" href="#sampling-in-spring-cloud-sleuth"></a> <a class="link" href="#sampling-in-spring-cloud-sleuth">8.4.3。在Spring Cloud Sleuth中采样</a></h4>
<div class="paragraph">
<p>默认情况下，Spring Cloud Sleuth将所有范围设置为不可导出。这意味着跟踪将出现在日志中，但不会出现在任何远程存储中。测试默认值通常就足够了，如果仅使用日志（例如，使用ELK聚合器），则可能只需要它即可。如果您将跨度数据导出到Zipkin，则还有一个<code>Sampler.ALWAYS_SAMPLE</code>设置导出所有内容， <code>RateLimitingSampler</code>设置每秒采样X个事务（默认为<code>1000</code> ） 要么<code>ProbabilityBasedSampler</code>设置对固定范围的一部分采样。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>RateLimitingSampler</code>是默认值，如果您使用<code>spring-cloud-sleuth-zipkin</code> 。您可以通过设置来配置速率限制<code>spring.sleuth.sampler.rate</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以通过创建bean定义来安装采样器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Sampler defaultSampler() {
    return Sampler.ALWAYS_SAMPLE;
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以设置HTTP标头<code>X-B3-Flags</code>至<code>1</code> ，或者，在进行消息传递时，您可以设置<code>spanFlags</code>标头<code>1</code> 。这样做将强制电流跨度可导出，而不管采样决定如何。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了使用限速采样器，请设置<code>spring.sleuth.sampler.rate</code>属性，以选择每秒钟间隔要接受的跟踪量。最小数字为0，最大数字为2,147,483,647（最大整数）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="propagation"><a class="anchor" href="#propagation"></a> <a class="link" href="#propagation">8.5。传播</a></h3>
<div class="paragraph">
<p>需要进行传播以确保源自同一根的活动被收集到同一条迹线中。最常见的传播方法是通过将RPC请求发送到接收它的服务器来从客户端复制跟踪上下文。</p>
</div>
<div class="paragraph">
<p>例如，进行下游HTTP调用时，其跟踪上下文被编码为请求标头，并与请求标头一起发送，如下图所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>   Client Span                                                Server Span
┌──────────────────┐                                       ┌──────────────────┐
│                  │                                       │                  │
│   TraceContext   │           Http Request Headers        │   TraceContext   │
│ ┌──────────────┐ │          ┌───────────────────┐        │ ┌──────────────┐ │
│ │ TraceId      │ │          │ X─B3─TraceId      │        │ │ TraceId      │ │
│ │              │ │          │                   │        │ │              │ │
│ │ ParentSpanId │ │ Extract  │ X─B3─ParentSpanId │ Inject │ │ ParentSpanId │ │
│ │              ├─┼─────────>│                   ├────────┼>│              │ │
│ │ SpanId       │ │          │ X─B3─SpanId       │        │ │ SpanId       │ │
│ │              │ │          │                   │        │ │              │ │
│ │ Sampled      │ │          │ X─B3─Sampled      │        │ │ Sampled      │ │
│ └──────────────┘ │          └───────────────────┘        │ └──────────────┘ │
│                  │                                       │                  │
└──────────────────┘                                       └──────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的名称来自<a href="https://github.com/openzipkin/b3-propagation">B3 Propagation</a> ，它内置于Brave，并具有许多语言和框架的实现。</p>
</div>
<div class="paragraph">
<p>大多数用户使用框架拦截器来自动化传播。接下来的两个示例显示了这对于客户端和服务器的工作方式。</p>
</div>
<div class="paragraph">
<p>以下示例显示了客户端传播如何工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracing tracing;

// configure a function that injects a trace context into a request
injector = tracing.propagation().injector(Request.Builder::addHeader);

// before a request is sent, add the current span's context to it
injector.inject(span.context(), request);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了服务器端传播的工作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracing tracing;
@Autowired Tracer tracer;

// configure a function that extracts the trace context from a request
extractor = tracing.propagation().extractor(Request::getHeader);

// when a server receives a request, it joins or starts a new trace
span = tracer.nextSpan(extractor.extract(request));</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="propagating-extra-fields"><a class="anchor" href="#propagating-extra-fields"></a> <a class="link" href="#propagating-extra-fields">8.5.1。传播额外的字段</a></h4>
<div class="paragraph">
<p>有时您需要传播额外的字段，例如请求ID或备用跟踪上下文。例如，如果您处于Cloud Foundry环境中，则可能要传递请求ID，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// when you initialize the builder, define the extra field you want to propagate
Tracing.newBuilder().propagationFactory(
  ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, "x-vcap-request-id")
);

// later, you can tag that request ID or use it in log correlation
requestId = ExtraFieldPropagation.get("x-vcap-request-id");</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能还需要传播未使用的跟踪上下文。例如，您可能处于Amazon Web Services环境中，但没有向X-Ray报告数据。为了确保X射线可以正确共存，请传递其跟踪标头，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">tracingBuilder.propagationFactory(
  ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, "x-amzn-trace-id")
);</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在Spring Cloud Sleuth中，跟踪构建器的所有元素<code>Tracing.newBuilder()</code>被定义为bean。因此，如果您想通过自定义<code>PropagationFactory</code> ，对于您而言，创建该类型的bean就足够了，我们将在<code>Tracing</code>豆。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="prefixed-fields"><a class="anchor" href="#prefixed-fields"></a> <a class="link" href="#prefixed-fields">前缀字段</a></h5>
<div class="paragraph">
<p>如果它们遵循通用模式，则还可以在字段前面加上前缀。以下示例说明了如何传播<code>x-vcap-request-id</code>原样发送该字段，但发送<code>country-code</code>和<code>user-id</code>电线上的字段为<code>x-baggage-country-code</code>和<code>x-baggage-user-id</code> ， 分别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Tracing.newBuilder().propagationFactory(
  ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)
                       .addField("x-vcap-request-id")
                       .addPrefixedFields("x-baggage-", Arrays.asList("country-code", "user-id"))
                       .build()
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以后，您可以调用以下代码来影响当前跟踪上下文的国家/地区代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ExtraFieldPropagation.set("x-country-code", "FO");
String countryCode = ExtraFieldPropagation.get("x-country-code");</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果您有对跟踪上下文的引用，则可以显式使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ExtraFieldPropagation.set(span.context(), "x-country-code", "FO");
String countryCode = ExtraFieldPropagation.get(span.context(), "x-country-code");</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">与以前版本的Sleuth的不同之处在于，使用Brave，您必须传递行李钥匙列表。有以下属性可实现此目的。随着<code>spring.sleuth.baggage-keys</code> ，您可以设置以开头的键<code>baggage-</code>用于HTTP调用和<code>baggage_</code>用于消息传递。您也可以使用<code>spring.sleuth.propagation-keys</code>属性以传递前缀密钥列表，这些前缀密钥传播到没有任何前缀的远程服务。您也可以使用<code>spring.sleuth.local-keys</code>属性以传递将在本地传播但不会通过网络传播的列表键。请注意，没有<code>x-</code>在标题键前面。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了自动将行李值设置为Slf4j的MDC，您必须设置<code>spring.sleuth.log.slf4j.whitelisted-mdc-keys</code>属性，其中包含列入白名单的行李和传播密钥的列表。例如<code>spring.sleuth.log.slf4j.whitelisted-mdc-keys=foo</code>将设置<code>foo</code>放进MDC。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请记住，将条目添加到MDC可能会大大降低应用程序的性能！
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要将行李条目添加为标签，则可以通过行李条目搜索跨度，可以将值设置为<code>spring.sleuth.propagation.tag.whitelisted-keys</code>以及列入白名单的行李钥匙清单。要禁用该功能，您必须通过<code>spring.sleuth.propagation.tag.enabled=false</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="extracting-a-propagated-context"><a class="anchor" href="#extracting-a-propagated-context"></a> <a class="link" href="#extracting-a-propagated-context">提取传播的上下文</a></h5>
<div class="paragraph">
<p>的<code>TraceContext.Extractor<C></code>从传入的请求或消息中读取跟踪标识符和采样状态。载体通常是一个请求对象或标头。</p>
</div>
<div class="paragraph">
<p>此实用程序用于标准仪器（例如<code>HttpServerHandler</code> ），但也可用于自定义RPC或消息传递代码。</p>
</div>
<div class="paragraph">
<p><code>TraceContextOrSamplingFlags</code>通常仅与<code>Tracer.nextSpan(extracted)</code> ，除非您要在客户端和服务器之间共享范围ID。</p>
</div>
</div>
<div class="sect4">
<h5 id="sharing-span-ids-between-client-and-server"><a class="anchor" href="#sharing-span-ids-between-client-and-server"></a> <a class="link" href="#sharing-span-ids-between-client-and-server">在客户端和服务器之间共享范围ID</a></h5>
<div class="paragraph">
<p>正常的检测模式是创建一个跨度，该跨度代表RPC的服务器端。 <code>Extractor.extract</code>当应用于传入的客户端请求时，可能会返回完整的跟踪上下文。 <code>Tracer.joinSpan</code>尝试继续此跟踪，如果支持，则使用相同的跨度ID，否则，创建一个子跨度。当跨度ID被共享时，报告的数据包括这样的标记。</p>
</div>
<div class="paragraph">
<p>下图显示了B3传播的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>                              ┌───────────────────┐      ┌───────────────────┐
 Incoming Headers             │   TraceContext    │      │   TraceContext    │
┌───────────────────┐(extract)│ ┌───────────────┐ │(join)│ ┌───────────────┐ │
│ X─B3-TraceId      │─────────┼─┼> TraceId      │ │──────┼─┼> TraceId      │ │
│                   │         │ │               │ │      │ │               │ │
│ X─B3-ParentSpanId │─────────┼─┼> ParentSpanId │ │──────┼─┼> ParentSpanId │ │
│                   │         │ │               │ │      │ │               │ │
│ X─B3-SpanId       │─────────┼─┼> SpanId       │ │──────┼─┼> SpanId       │ │
└───────────────────┘         │ │               │ │      │ │               │ │
                              │ │               │ │      │ │  Shared: true │ │
                              │ └───────────────┘ │      │ └───────────────┘ │
                              └───────────────────┘      └───────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>某些传播系统仅转发父范围ID，在<code>Propagation.Factory.supportsJoin() == false</code> 。在这种情况下，始终提供新的跨度ID，而传入上下文确定父ID。</p>
</div>
<div class="paragraph">
<p>下图显示了AWS传播的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>                              ┌───────────────────┐      ┌───────────────────┐
 x-amzn-trace-id              │   TraceContext    │      │   TraceContext    │
┌───────────────────┐(extract)│ ┌───────────────┐ │(join)│ ┌───────────────┐ │
│ Root              │─────────┼─┼> TraceId      │ │──────┼─┼> TraceId      │ │
│                   │         │ │               │ │      │ │               │ │
│ Parent            │─────────┼─┼> SpanId       │ │──────┼─┼> ParentSpanId │ │
└───────────────────┘         │ └───────────────┘ │      │ │               │ │
                              └───────────────────┘      │ │  SpanId: New  │ │
                                                         │ └───────────────┘ │
                                                         └───────────────────┘</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：某些跨度报告程序不支持共享跨度ID。例如，如果您设置<code>Tracing.Builder.spanReporter(amazonXrayOrGoogleStackdrive)</code> ，您应该通过设置禁用加入<code>Tracing.Builder.supportsJoin(false)</code> 。这样做会迫使一个新孩子跨过<code>Tracer.joinSpan()</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="implementing-propagation"><a class="anchor" href="#implementing-propagation"></a> <a class="link" href="#implementing-propagation">实施传播</a></h5>
<div class="paragraph">
<p><code>TraceContext.Extractor<C></code>由一个<code>Propagation.Factory</code>插入。在内部，此代码创建联合类型， <code>TraceContextOrSamplingFlags</code> ，其中之一：* <code>TraceContext</code>如果存在跟踪和跨度ID。* <code>TraceIdContext</code>如果存在跟踪ID，但不存在跨度ID。* <code>SamplingFlags</code>如果不存在标识符。</p>
</div>
<div class="paragraph">
<p>一些<code>Propagation</code>实现从提取（例如，读取传入的标头）到注入（例如，写入传出的标头）的角度携带额外的数据。例如，它可能带有一个请求ID。当实现中有多余的数据时，它们将按以下方式处理：*如果<code>TraceContext</code>被提取，添加额外的数据为<code>TraceContext.extra()</code> 。*否则，将其添加为<code>TraceContextOrSamplingFlags.extra()</code> ， 哪一个<code>Tracer.nextSpan</code>处理。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="current-tracing-component"><a class="anchor" href="#current-tracing-component"></a> <a class="link" href="#current-tracing-component">8.6。当前跟踪组件</a></h3>
<div class="paragraph">
<p>Brave支持“当前跟踪组件”概念，该概念仅在您没有其他获取参考的方法时才应使用。这样做是针对JDBC连接的，因为它们通常在跟踪组件之前进行初始化。</p>
</div>
<div class="paragraph">
<p>可以通过以下方式获得实例化的最新跟踪组件： <code>Tracing.current()</code> 。您也可以使用<code>Tracing.currentTracer()</code>仅获取示踪剂。如果使用这两种方法之一，请不要缓存结果。而是在每次需要它们时查找它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="current-span"><a class="anchor" href="#current-span"></a> <a class="link" href="#current-span">8.7。当前跨度</a></h3>
<div class="paragraph">
<p>勇敢者支持代表飞行中操作的“电流跨度”概念。您可以使用<code>Tracer.currentSpan()</code>将自定义标签添加到跨度和<code>Tracer.nextSpan()</code>在飞行中创造一个孩子</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">在Sleuth中，您可以自动连接<code>Tracer</code> Bean通过检索当前范围<code>tracer.currentSpan()</code>方法。要检索当前上下文，只需调用<code>tracer.currentSpan().context()</code> 。要以字符串形式获取当前跟踪ID，可以使用<code>traceIdString()</code>像这样的方法： <code>tracer.currentSpan().context().traceIdString()</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="setting-a-span-in-scope-manually"><a class="anchor" href="#setting-a-span-in-scope-manually"></a> <a class="link" href="#setting-a-span-in-scope-manually">8.7.1。手动设置范围</a></h4>
<div class="paragraph">
<p>在编写新的检测时，将您创建的跨度作为当前跨度放置在示波器中很重要。这样做不仅使用户可以使用<code>Tracer.currentSpan()</code> ，但它也允许自定义设置（例如SLF4J MDC）查看当前的跟踪ID。</p>
</div>
<div class="paragraph">
<p><code>Tracer.withSpanInScope(Span)</code>通过使用try-with-resources惯用语可以简化此过程，并且使用起来最方便。每当可能调用外部代码（例如进行拦截器或其他操作）时，请将范围放在范围内，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracer tracer;

try (SpanInScope ws = tracer.withSpanInScope(span)) {
  return inboundRequest.invoke();
} finally { // note the scope is independent of the span
  span.finish();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在极端情况下，您可能需要暂时清除当前范围（例如，启动不应该与当前请求关联的任务）。为此，请将null传递给<code>withSpanInScope</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired Tracer tracer;

try (SpanInScope cleared = tracer.withSpanInScope(null)) {
  startBackgroundThread();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="instrumentation"><a class="anchor" href="#instrumentation"></a> <a class="link" href="#instrumentation">8.8。仪器仪表</a></h3>
<div class="paragraph">
<p>Spring Cloud Sleuth会自动检测所有Spring应用程序，因此您无需执行任何操作即可激活它。通过根据可用的堆栈使用多种技术来添加检测。例如，对于Servlet Web应用程序，我们使用<code>Filter</code> ，对于Spring Integration，我们使用<code>ChannelInterceptors</code> 。</p>
</div>
<div class="paragraph">
<p>您可以自定义跨度标签中使用的键。为了限制范围数据的数量，默认情况下，HTTP请求仅使用少量元数据（例如状态码，主机和URL）进行标记。您可以通过配置添加请求标头<code>spring.sleuth.keys.http.headers</code> （标题名称列表）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">仅在存在以下情况时才收集和导出标签<code>Sampler</code>允许它。默认情况下，没有这样的<code>Sampler</code> ，以确保在不进行任何配置的情况下不存在意外收集过多数据的危险）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="span-lifecycle"><a class="anchor" href="#span-lifecycle"></a> <a class="link" href="#span-lifecycle">8.9。跨度生命周期</a></h3>
<div class="paragraph">
<p>您可以通过以下方式在Span上执行以下操作： <code>brave.Tracer</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#creating-and-finishing-spans">start</a> ：开始跨度时，将分配其名称并记录开始时间戳。</p>
</li>
<li>
<p><a href="#creating-and-finishing-spans">close</a> ：跨度已完成（记录了跨度的结束时间），并且，如果对跨度进行了采样，则可以进行收集（例如，收集到Zipkin）。</p>
</li>
<li>
<p><a href="#continuing-spans">继续</a> ：创建一个新的span实例。它是继续的副本。</p>
</li>
<li>
<p><a href="#continuing-spans">detach</a> ：跨度不会停止或关闭。它只会从当前线程中删除。</p>
</li>
<li>
<p><a href="#creating-spans-with-explicit-parent">使用显式父项创建</a> ：您可以创建一个新的跨度并为其设置一个显式父项。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Cloud Sleuth创建一个实例<code>Tracer</code>为了你。为了使用它，您可以对其进行自动接线。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="creating-and-finishing-spans"><a class="anchor" href="#creating-and-finishing-spans"></a> <a class="link" href="#creating-and-finishing-spans">8.9.1。创建和整理跨度</a></h4>
<div class="paragraph">
<p>您可以使用<code>Tracer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Start a span. If there was a span present in this thread it will become
// the `newSpan`'s parent.
Span newSpan = this.tracer.nextSpan().name("calculateTax");
try (Tracer.SpanInScope ws = this.tracer.withSpanInScope(newSpan.start())) {
    // ...
    // You can tag a span
    newSpan.tag("taxValue", taxValue);
    // ...
    // You can log an event on a span
    newSpan.annotate("taxCalculated");
}
finally {
    // Once done remember to finish the span. This will allow collecting
    // the span to send it to Zipkin
    newSpan.finish();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们可以看到如何创建跨度的新实例。如果此线程中已经有一个跨度，它将成为新跨度的父级。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">创建跨度后，请始终保持清洁。另外，请始终完成要发送给Zipkin的所有跨度。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您的跨度包含一个大于50个字符的名称，该名称将被截断为50个字符。您的姓名必须明确明确。知名人士会导致延迟问题，有时甚至会引发例外情况。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="continuing-spans"><a class="anchor" href="#continuing-spans"></a> <a class="link" href="#continuing-spans">8.9.2。连续跨度</a></h4>
<div class="paragraph">
<p>有时，您不想创建一个新跨度，但想继续一个跨度。这种情况的示例如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>AOP</strong> ：如果在到达方面之前已经创建了一个跨度，则您可能不想创建新的跨度。</p>
</li>
<li>
<p><strong>Hystrix</strong> ：执行Hystrix命令很可能是当前处理的逻辑部分。实际上，它仅仅是技术实现细节，您不一定要在跟踪中将其反映为一个单独的实体。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要继续跨度，您可以使用<code>brave.Tracer</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// let's assume that we're in a thread Y and we've received
// the `initialSpan` from thread X
Span continuedSpan = this.tracer.toSpan(newSpan.context());
try {
    // ...
    // You can tag a span
    continuedSpan.tag("taxValue", taxValue);
    // ...
    // You can log an event on a span
    continuedSpan.annotate("taxCalculated");
}
finally {
    // Once done remember to flush the span. That means that
    // it will get reported but the span itself is not yet finished
    continuedSpan.flush();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating-spans-with-explicit-parent"><a class="anchor" href="#creating-spans-with-explicit-parent"></a> <a class="link" href="#creating-spans-with-explicit-parent">8.9.3。使用显式父级创建跨度</a></h4>
<div class="paragraph">
<p>您可能要开始一个新的跨度并提供该跨度的显式父项。假定范围的父级在一个线程中，而您想在另一个线程中开始一个新的范围。在《勇敢传说》中，每当您致电<code>nextSpan()</code> ，它会参考当前范围的跨度创建一个跨度。您可以将范围放在范围中，然后调用<code>nextSpan()</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// let's assume that we're in a thread Y and we've received
// the `initialSpan` from thread X. `initialSpan` will be the parent
// of the `newSpan`
Span newSpan = null;
try (Tracer.SpanInScope ws = this.tracer.withSpanInScope(initialSpan)) {
    newSpan = this.tracer.nextSpan().name("calculateCommission");
    // ...
    // You can tag a span
    newSpan.tag("commissionValue", commissionValue);
    // ...
    // You can log an event on a span
    newSpan.annotate("commissionCalculated");
}
finally {
    // Once done remember to finish the span. This will allow collecting
    // the span to send it to Zipkin. The tags and events set on the
    // newSpan will not be present on the parent
    if (newSpan != null) {
        newSpan.finish();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">创建这样的跨度后，必须完成它。否则，不会报告（例如，向Zipkin报告）。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="naming-spans"><a class="anchor" href="#naming-spans"></a> <a class="link" href="#naming-spans">8.10。命名范围</a></h3>
<div class="paragraph">
<p>选择一个跨度名称不是一件容易的事。跨度名称应描述一个操作名称。该名称应为低基数，因此不应包含标识符。</p>
</div>
<div class="paragraph">
<p>由于正在进行很多检测，因此一些跨度名称是人为的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>controller-method-name</code>由控制器接收的方法名称为<code>controllerMethodName</code></p>
</li>
<li>
<p><code>async</code>使用包装完成的异步操作<code>Callable</code>和<code>Runnable</code>接口。</p>
</li>
<li>
<p>用注释的方法<code>@Scheduled</code>返回类的简单名称。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>幸运的是，对于异步处理，您可以提供显式命名。</p>
</div>
<div class="sect3">
<h4 id="spanname-annotation"><a class="anchor" href="#spanname-annotation"></a> <a class="link" href="#spanname-annotation">8.10.1。 <code>@SpanName</code>注解</a></h4>
<div class="paragraph">
<p>您可以使用<code>@SpanName</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpanName("calculateTax")
class TaxCountingRunnable implements Runnable {

    @Override
    public void run() {
        // perform logic
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，按以下方式处理时，将跨度命名为<code>calculateTax</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Runnable runnable = new TraceRunnable(this.tracing, spanNamer,
        new TaxCountingRunnable());
Future<?> future = executorService.submit(runnable);
// ... some additional logic ...
future.get();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tostring-method"><a class="anchor" href="#tostring-method"></a> <a class="link" href="#tostring-method">8.10.2。 <code>toString()</code>方法</a></h4>
<div class="paragraph">
<p>为以下情况创建单独的类非常罕见<code>Runnable</code>要么<code>Callable</code> 。通常，创建一个匿名类的实例。您不能注释此类。为了克服该限制，如果没有<code>@SpanName</code>注释存在，我们检查该类是否具有自定义实现<code>toString()</code>方法。</p>
</div>
<div class="paragraph">
<p>运行这样的代码将导致创建一个名为<code>calculateTax</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Runnable runnable = new TraceRunnable(this.tracing, spanNamer, new Runnable() {
    @Override
    public void run() {
        // perform logic
    }

    @Override
    public String toString() {
        return "calculateTax";
    }
});
Future<?> future = executorService.submit(runnable);
// ... some additional logic ...
future.get();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="managing-spans-with-annotations"><a class="anchor" href="#managing-spans-with-annotations"></a> <a class="link" href="#managing-spans-with-annotations">8.11。使用注释管理跨度</a></h3>
<div class="paragraph">
<p>您可以使用各种注释来管理跨度。</p>
</div>
<div class="sect3">
<h4 id="rationale"><a class="anchor" href="#rationale"></a> <a class="link" href="#rationale">8.11.1。基本原理</a></h4>
<div class="paragraph">
<p>使用注释管理跨区有很多充分的理由，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与API无关的方法可以与跨度进行协作。使用注释使用户可以添加到跨度，而跨度api不依赖库。这样，Sleuth可以更改其核心API，以减少对用户代码的影响。</p>
</li>
<li>
<p>基本跨度操作减少了表面积。如果没有此功能，则必须使用span api，该api的生命周期命令可能无法正确使用。通过仅公开作用域，标记和日志功能，您可以进行协作而不会意外中断跨度生命周期。</p>
</li>
<li>
<p>与运行时生成的代码协作。使用诸如Spring Data和Feign之类的库，可以在运行时生成接口的实现。因此，对象的跨度包裹是乏味的。现在，您可以在接口和这些接口的参数上提供注释。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="creating-new-spans"><a class="anchor" href="#creating-new-spans"></a> <a class="link" href="#creating-new-spans">8.11.2。创建新的跨度</a></h4>
<div class="paragraph">
<p>如果您不想手动创建本地范围，则可以使用<code>@NewSpan</code>注解。另外，我们提供<code>@SpanTag</code>注释以自动方式添加标签。</p>
</div>
<div class="paragraph">
<p>现在我们可以考虑一些用法示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@NewSpan
void testMethod();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在不带任何参数的情况下对方法进行注释会导致创建一个新的跨度，该跨度的名称等于带注释的方法名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@NewSpan("customNameOnTestMethod4")
void testMethod4();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您在注释中提供值（直接或通过设置<code>name</code>参数），创建的跨度将提供的值作为名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// method declaration
@NewSpan(name = "customNameOnTestMethod5")
void testMethod5(@SpanTag("testTag") String param);

// and method execution
this.testBean.testMethod5("test");</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以同时使用名称和标签。让我们专注于后者。在这种情况下，带注释的方法的参数运行时值的值将成为标记的值。在我们的示例中，标记键为<code>testTag</code> ，而标记值为<code>test</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@NewSpan(name = "customNameOnTestMethod3")
@Override
public void testMethod3() {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以将<code>@NewSpan</code>在类和接口上的注释。如果您覆盖接口的方法并为<code>@NewSpan</code>注释，最具体的一个获胜（在这种情况下<code>customNameOnTestMethod3</code>设置）。</p>
</div>
</div>
<div class="sect3">
<h4 id="continuing-spans-2"><a class="anchor" href="#continuing-spans-2"></a> <a class="link" href="#continuing-spans-2">8.11.3。连续跨度</a></h4>
<div class="paragraph">
<p>如果要将标签和注释添加到现有范围，则可以使用<code>@ContinueSpan</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// method declaration
@ContinueSpan(log = "testMethod11")
void testMethod11(@SpanTag("testTag11") String param);

// method execution
this.testBean.testMethod11("test");
this.testBean.testMethod13();</code></pre>
</div>
</div>
<div class="paragraph">
<p>（请注意，与<code>@NewSpan</code>注释，您也可以使用<code>log</code>参数。）</p>
</div>
<div class="paragraph">
<p>这样，跨度将继续，并且：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日志条目名为<code>testMethod11.before</code>和<code>testMethod11.after</code>被创建。</p>
</li>
<li>
<p>如果引发异常，则名为<code>testMethod11.afterFailure</code>也被创建。</p>
</li>
<li>
<p>标记为<code>testTag11</code>和值为<code>test</code>被建造。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="advanced-tag-setting"><a class="anchor" href="#advanced-tag-setting"></a> <a class="link" href="#advanced-tag-setting">8.11.4。高级标签设置</a></h4>
<div class="paragraph">
<p>有3种不同的方法可以将标签添加到跨度。所有这些都由<code>SpanTag</code>注解。优先级如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>尝试一下<code>TagValueResolver</code>类型和提供的名称。</p>
</li>
<li>
<p>如果未提供Bean名称，请尝试评估表达式。我们搜索一个<code>TagValueExpressionResolver</code>豆。默认实现使用SPEL表达式解析。
<strong>重要事项</strong>您只能从SPEL表达式中引用属性。由于安全限制，不允许执行方法。</p>
</li>
<li>
<p>如果我们找不到任何要求值的表达式，则返回<code>toString()</code>参数的值。</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="custom-extractor"><a class="anchor" href="#custom-extractor"></a> <a class="link" href="#custom-extractor">定制提取器</a></h5>
<div class="paragraph">
<p>以下方法的标记值是通过实现<code>TagValueResolver</code>接口。它的类名必须作为<code>resolver</code>属性。</p>
</div>
<div class="paragraph">
<p>考虑以下带注释的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@NewSpan
public void getAnnotationForTagValueResolver(
        @SpanTag(key = "test", resolver = TagValueResolver.class) String test) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在进一步考虑以下<code>TagValueResolver</code> bean实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean(name = "myCustomTagValueResolver")
public TagValueResolver tagValueResolver() {
    return parameter -> "Value from myCustomTagValueResolver";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的两个示例导致将标签值设置为等于<code>Value from myCustomTagValueResolver</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="resolving-expressions-for-a-value"><a class="anchor" href="#resolving-expressions-for-a-value"></a> <a class="link" href="#resolving-expressions-for-a-value">为值解析表达式</a></h5>
<div class="paragraph">
<p>考虑以下带注释的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@NewSpan
public void getAnnotationForTagValueExpression(@SpanTag(key = "test",
        expression = "'hello' + ' characters'") String test) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有自定义实现<code>TagValueExpressionResolver</code>导致对SPEL表达式进行评估，并获得一个值为的标签<code>4 characters</code>在跨度上设置。如果要使用其他表达式解析机制，则可以创建自己的bean实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-the-tostring-method"><a class="anchor" href="#using-the-tostring-method"></a> <a class="link" href="#using-the-tostring-method">使用<code>toString()</code>方法</a></h5>
<div class="paragraph">
<p>考虑以下带注释的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@NewSpan
public void getAnnotationForArgumentToString(@SpanTag("test") Long param) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以值运行前面的方法<code>15</code>导致设置一个字符串值为<code>"15"</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="customizations"><a class="anchor" href="#customizations"></a> <a class="link" href="#customizations">8.12。客制化</a></h3>
<div class="sect3">
<h4 id="customizers"><a class="anchor" href="#customizers"></a> <a class="link" href="#customizers">8.12.1。客制化</a></h4>
<div class="paragraph">
<p>使用Brave 5.7，您可以使用多种选项为项目提供定制程序。勇敢与</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TracingCustomizer</code> -允许配置插件协作构建实例<code>Tracing</code> 。</p>
</li>
<li>
<p><code>CurrentTraceContextCustomizer</code> -允许配置插件协作构建实例<code>CurrentTraceContext</code> 。</p>
</li>
<li>
<p><code>ExtraFieldCustomizer</code> -允许配置插件协作构建实例<code>ExtraFieldPropagation.Factory</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sleuth将搜索那些类型的bean并自动应用定制。</p>
</div>
</div>
<div class="sect3">
<h4 id="http"><a class="anchor" href="#http"></a> <a class="link" href="#http">8.12.2。HTTP</a></h4>
<div class="paragraph">
<p>如果需要定制与HTTP相关范围的客户端/服务器解析，只需注册一个类型为bean的bean <code>brave.http.HttpClientParser</code>要么<code>brave.http.HttpServerParser</code> 。如果需要客户机/服务器采样，只需注册一个类型为的bean <code>brave.sampler.SamplerFunction<HttpRequest></code>并命名豆<code>sleuthHttpClientSampler</code>用于客户采样器和<code>sleuthHttpServerSampler</code>用于服务器采样器。</p>
</div>
<div class="paragraph">
<p>为了您的方便<code>@HttpClientSampler</code>和<code>@HttpServerSampler</code>批注可用于注入适当的bean或通过其静态String引用bean名称<code>NAME</code>领域。</p>
</div>
<div class="paragraph">
<p>查看Brave的代码，查看如何制作基于路径的采样器的<a href="https://github.com/openzipkin/brave/tree/master/instrumentation/http#sampling-policy" class="bare">示例github.com/openzipkin/brave/tree/master/instrumentation/http#sampling-policy</a></p>
</div>
<div class="paragraph">
<p>如果您要完全重写<code>HttpTracing</code>豆你可以用<code>SkipPatternProvider</code>检索URL的界面<code>Pattern</code>对于不应采样的跨度。您可以在下面看到使用示例<code>SkipPatternProvider</code>在服务器端， <code>Sampler<HttpRequest></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class Config {
  @Bean(name = HttpServerSampler.NAME)
  SamplerFunction<HttpRequest> myHttpSampler(SkipPatternProvider provider) {
      Pattern pattern = provider.skipPattern();
      return request -> {
          String url = request.path();
          boolean shouldSkip = pattern.matcher(url).matches();
          if (shouldSkip) {
              return false;
          }
          return null;
      };
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tracingfilter"><a class="anchor" href="#tracingfilter"></a> <a class="link" href="#tracingfilter">8.12.3。<code>TracingFilter</code></a></h4>
<div class="paragraph">
<p>您还可以修改<code>TracingFilter</code> ，它是负责处理输入的HTTP请求并基于HTTP响应添加标签的组件。您可以通过注册自己的实例来自定义标签或修改响应标题。 <code>TracingFilter</code>豆。</p>
</div>
<div class="paragraph">
<p>在以下示例中，我们注册了<code>TracingFilter</code>豆，添加<code>ZIPKIN-TRACE-ID</code>响应标头，其中包含当前Span的跟踪ID，并添加带有标签的标签<code>custom</code>和一个值<code>tag</code>到跨度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
@Order(TraceWebServletAutoConfiguration.TRACING_FILTER_ORDER + 1)
class MyFilter extends GenericFilterBean {

    private final Tracer tracer;

    MyFilter(Tracer tracer) {
        this.tracer = tracer;
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
            FilterChain chain) throws IOException, ServletException {
        Span currentSpan = this.tracer.currentSpan();
        if (currentSpan == null) {
            chain.doFilter(request, response);
            return;
        }
        // for readability we're returning trace id in a hex form
        ((HttpServletResponse) response).addHeader("ZIPKIN-TRACE-ID",
                currentSpan.context().traceIdString());
        // we can also add some custom tags
        currentSpan.tag("custom", "tag");
        chain.doFilter(request, response);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="messaging"><a class="anchor" href="#messaging"></a> <a class="link" href="#messaging">8.12.4。讯息传递</a></h4>
<div class="paragraph">
<p>Sleuth自动配置<code>MessagingTracing</code> Bean，作为Kafka或JMS等消息传递工具的基础。</p>
</div>
<div class="paragraph">
<p>如果需要定制生产者/消费者消息传递跟踪的样本，只需注册一个类型为的bean <code>brave.sampler.SamplerFunction<MessagingRequest></code>并命名豆<code>sleuthProducerSampler</code>用于生产者采样器和<code>sleuthConsumerSampler</code>用于消费者采样器。</p>
</div>
<div class="paragraph">
<p>为了您的方便<code>@ProducerSampler</code>和<code>@ConsumerSampler</code>批注可用于注入适当的bean或通过其静态String引用bean名称<code>NAME</code>领域。</p>
</div>
<div class="paragraph">
<p>例如这是一个采样器，每秒可以跟踪100个消费者请求，“警报”通道除外。其他请求将使用由<code>Tracing</code>零件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class Config {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://github.com/openzipkin/brave/tree/master/instrumentation/messaging#sampling-policy" class="bare">github.com/openzipkin/brave/tree/master/instrumentation/messaging#sampling-policy</a></p>
</div>
</div>
<div class="sect3">
<h4 id="rpc"><a class="anchor" href="#rpc"></a> <a class="link" href="#rpc">8.12.5。RPC</a></h4>
<div class="paragraph">
<p>Sleuth自动配置<code>RpcTracing</code>用作gRPC或Dubbo等RPC工具的基础的bean。</p>
</div>
<div class="paragraph">
<p>如果需要自定义RPC跟踪的客户端/服务器采样，只需注册一个类型为bean的bean <code>brave.sampler.SamplerFunction<RpcRequest></code>并命名豆<code>sleuthRpcClientSampler</code>用于客户采样器和<code>sleuthRpcServerSampler</code>用于服务器采样器。</p>
</div>
<div class="paragraph">
<p>为了您的方便<code>@RpcClientSampler</code>和<code>@RpcServerSampler</code>批注可用于注入适当的bean或通过其静态String引用bean名称<code>NAME</code>领域。</p>
</div>
<div class="paragraph">
<p>例如这是一个每秒跟踪100个“ GetUserToken”服务器请求的采样器。这不会启动对运行状况检查服务的请求的新跟踪。其他请求将使用全局采样配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class Config {
  @Bean(name = RpcServerSampler.NAME)
  SamplerFunction<RpcRequest> myRpcSampler() {
      Matcher<RpcRequest> userAuth = and(serviceEquals("users.UserService"),
              methodEquals("GetUserToken"));
      return RpcRuleSampler.newBuilder()
              .putRule(serviceEquals("grpc.health.v1.Health"), Sampler.NEVER_SAMPLE)
              .putRule(userAuth, RateLimitingSampler.create(100)).build();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参见<a href="https://github.com/openzipkin/brave/tree/master/instrumentation/rpc#sampling-policy" class="bare">github.com/openzipkin/brave/tree/master/instrumentation/rpc#sampling-policy</a></p>
</div>
</div>
<div class="sect3">
<h4 id="custom-service-name"><a class="anchor" href="#custom-service-name"></a> <a class="link" href="#custom-service-name">8.12.6。定制服务名称</a></h4>
<div class="paragraph">
<p>默认情况下，Sleuth假定，当您向Zipkin发送跨度时，您希望跨度的服务名称等于<code>spring.application.name</code>属性。但是，并非总是如此。在某些情况下，您想为来自应用程序的所有范围显式提供不同的服务名称。为此，您可以将以下属性传递给应用程序以覆盖该值（该示例适用于名为<code>myService</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.zipkin.service.name: myService</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customization-of-reported-spans"><a class="anchor" href="#customization-of-reported-spans"></a> <a class="link" href="#customization-of-reported-spans">8.12.7。自定义报告的跨度</a></h4>
<div class="paragraph">
<p>在报告跨度之前（例如，向Zipkin报告），您可能需要以某种方式修改该跨度。您可以使用<code>FinishedSpanHandler</code>接口。</p>
</div>
<div class="paragraph">
<p>在Sleuth中，我们生成具有固定名称的跨度。一些用户希望根据标签的值来修改名称。您可以实施<code>FinishedSpanHandler</code>更改名称的界面。</p>
</div>
<div class="paragraph">
<p>以下示例说明如何注册两个实现的bean <code>FinishedSpanHandler</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
FinishedSpanHandler handlerOne() {
    return new FinishedSpanHandler() {
        @Override
        public boolean handle(TraceContext traceContext, MutableSpan span) {
            span.name("foo");
            return true; // keep this span
        }
    };
}

@Bean
FinishedSpanHandler handlerTwo() {
    return new FinishedSpanHandler() {
        @Override
        public boolean handle(TraceContext traceContext, MutableSpan span) {
            span.name(span.name() + " bar");
            return true; // keep this span
        }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例导致将报告的跨度的名称更改为<code>foo bar</code> ，直到它被报告（例如，Zipkin）。</p>
</div>
</div>
<div class="sect3">
<h4 id="host-locator"><a class="anchor" href="#host-locator"></a> <a class="link" href="#host-locator">8.12.8。主机定位器</a></h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本节是关于通过服务发现定义<strong>主机</strong> 。这是<strong>不是</strong>通过服务发现找到基普金。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要定义与特定跨度相对应的主机，我们需要解析主机名和端口。默认方法是从服务器属性中获取这些值。如果未设置，则尝试从网络接口检索主机名。</p>
</div>
<div class="paragraph">
<p>如果启用了发现客户端，并且希望从服务注册表中的已注册实例中检索主机地址，则必须设置<code>spring.zipkin.locator.discovery.enabled</code>属性（适用于基于HTTP和基于流的跨度报告），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.zipkin.locator.discovery.enabled: true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sending-spans-to-zipkin"><a class="anchor" href="#sending-spans-to-zipkin"></a> <a class="link" href="#sending-spans-to-zipkin">8.13。发送跨区到Zipkin</a></h3>
<div class="paragraph">
<p>默认情况下，如果您添加<code>spring-cloud-starter-zipkin</code>作为对项目的依赖项，当跨度关闭时，它将通过HTTP发送到Zipkin。通信是异步的。您可以通过设置网址来配置网址<code>spring.zipkin.baseUrl</code>属性，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.zipkin.baseUrl: https://192.168.99.100:9411/</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要通过服务发现来找到Zipkin，可以在URL中传递Zipkin的服务ID，如以下示例所示： <code>zipkinserver</code>服务编号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.zipkin.baseUrl: https://zipkinserver/</code></pre>
</div>
</div>
<div class="paragraph">
<p>要禁用此功能，只需设置<code>spring.zipkin.discoveryClientEnabled</code>为`false。</p>
</div>
<div class="paragraph">
<p>启用发现客户端功能后，Sleuth会使用<code>LoadBalancerClient</code>查找Zipkin服务器的URL。这意味着您可以例如通过功能区来设置负载平衡配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">zipkinserver:
  ribbon:
    ListOfServers: host1,host2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您在类路径中同时使用了web，rabbit或kafka，则可能需要选择将跨度发送到zipkin的方法。为此，请设置<code>web</code> ， <code>rabbit</code> ， 要么<code>kafka</code>到<code>spring.zipkin.sender.type</code>属性。以下示例显示了如何设置发件人类型<code>web</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.zipkin.sender.type: web</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义<code>RestTemplate</code>通过HTTP发送跨度到Zipkin，您可以注册<code>ZipkinRestTemplateCustomizer</code>豆。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
class MyConfig {
    @Bean ZipkinRestTemplateCustomizer myCustomizer() {
        return new ZipkinRestTemplateCustomizer() {
            @Override
            void customize(RestTemplate restTemplate) {
                // customize the RestTemplate
            }
        };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果您想控制创建<code>RestTemplate</code>对象，则必须创建一个<code>zipkin2.reporter.Sender</code>类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Bean Sender myRestTemplateSender(ZipkinProperties zipkin,
            ZipkinRestTemplateCustomizer zipkinRestTemplateCustomizer) {
        RestTemplate restTemplate = mySuperCustomRestTemplate();
        zipkinRestTemplateCustomizer.customize(restTemplate);
        return myCustomSender(zipkin, restTemplate);
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zipkin-stream-span-consumer"><a class="anchor" href="#zipkin-stream-span-consumer"></a> <a class="link" href="#zipkin-stream-span-consumer">8.14。Zipkin流跨度消费者</a></h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">我们建议使用Zipkin的本机支持进行基于消息的跨度发送。从Edgware版本开始，不建议使用Zipkin Stream服务器。在Finchley版本中，将其删除。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果出于某种原因需要创建不赞成使用的Stream Zipkin服务器，请参阅<a href="https://cloud.spring.io/spring-cloud-static/Dalston.SR4/multi/multi__span_data_as_messages.html#_zipkin_consumer">Dalston文档</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="integrations"><a class="anchor" href="#integrations"></a> <a class="link" href="#integrations">8.15。整合方式</a></h3>
<div class="sect3">
<h4 id="opentracing"><a class="anchor" href="#opentracing"></a> <a class="link" href="#opentracing">8.15.1。开放追踪</a></h4>
<div class="paragraph">
<p>Spring Cloud Sleuth与<a href="https://opentracing.io/">OpenTracing</a>兼容。如果您在类路径上有OpenTracing，我们将自动注册OpenTracing <code>Tracer</code>豆。如果您要禁用此功能，请设置<code>spring.sleuth.opentracing.enabled</code>至<code>false</code></p>
</div>
</div>
<div class="sect3">
<h4 id="runnable-and-callable"><a class="anchor" href="#runnable-and-callable"></a> <a class="link" href="#runnable-and-callable">8.15.2。可运行和可调用</a></h4>
<div class="paragraph">
<p>如果你把逻辑包装进去<code>Runnable</code>要么<code>Callable</code> ，您可以将这些类包装在其Sleuth代表中，如以下示例所示<code>Runnable</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Runnable runnable = new Runnable() {
    @Override
    public void run() {
        // do some work
    }

    @Override
    public String toString() {
        return "spanNameFromToStringMethod";
    }
};
// Manual `TraceRunnable` creation with explicit "calculateTax" Span name
Runnable traceRunnable = new TraceRunnable(this.tracing, spanNamer, runnable,
        "calculateTax");
// Wrapping `Runnable` with `Tracing`. That way the current span will be available
// in the thread of `Runnable`
Runnable traceRunnableFromTracer = this.tracing.currentTraceContext()
        .wrap(runnable);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何针对<code>Callable</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Callable<String> callable = new Callable<String>() {
    @Override
    public String call() throws Exception {
        return someLogic();
    }

    @Override
    public String toString() {
        return "spanNameFromToStringMethod";
    }
};
// Manual `TraceCallable` creation with explicit "calculateTax" Span name
Callable<String> traceCallable = new TraceCallable<>(this.tracing, spanNamer,
        callable, "calculateTax");
// Wrapping `Callable` with `Tracing`. That way the current span will be available
// in the thread of `Callable`
Callable<String> traceCallableFromTracer = this.tracing.currentTraceContext()
        .wrap(callable);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，您可以确保为每个执行创建并关闭新的跨度。</p>
</div>
</div>
<div class="sect3">
<h4 id="hystrix"><a class="anchor" href="#hystrix"></a> <a class="link" href="#hystrix">8.15.3。Hystrix</a></h4>
<div class="sect4">
<h5 id="custom-concurrency-strategy"><a class="anchor" href="#custom-concurrency-strategy"></a> <a class="link" href="#custom-concurrency-strategy">自定义并发策略</a></h5>
<div class="paragraph">
<p>我们注册一个习俗<a href="https://github.com/Netflix/Hystrix/wiki/Plugins#concurrencystrategy"><code>HystrixConcurrencyStrategy</code></a>叫<code>TraceCallable</code>包裹所有<code>Callable</code> Sleuth代表的实例。该策略将开始或继续跨度，具体取决于在调用Hystrix命令之前是否已经在进行跟踪。您可以选择设置<code>spring.sleuth.hystrix.strategy.passthrough</code>至<code>true</code>如果您不希望开始新的跨度，则仅将跟踪上下文传播到Hystrix执行线程。要禁用自定义Hystrix并发策略，请设置<code>spring.sleuth.hystrix.strategy.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="manual-command-setting"><a class="anchor" href="#manual-command-setting"></a> <a class="link" href="#manual-command-setting">手动指令设定</a></h5>
<div class="paragraph">
<p>假设您具有以下<code>HystrixCommand</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HystrixCommand<String> hystrixCommand = new HystrixCommand<String>(setter) {
    @Override
    protected String run() throws Exception {
        return someLogic();
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>要传递跟踪信息，您必须在Sleuth版本的Sleuth中包装相同的逻辑<code>HystrixCommand</code> ， 这就是所谓的<code>TraceCommand</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TraceCommand<String> traceCommand = new TraceCommand<String>(tracer, setter) {
    @Override
    public String doRun() throws Exception {
        return someLogic();
    }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rxjava"><a class="anchor" href="#rxjava"></a> <a class="link" href="#rxjava">8.15.4。RxJava的</a></h4>
<div class="paragraph">
<p>我们注册一个自定义<a href="https://github.com/ReactiveX/RxJava/wiki/Plugins#rxjavaschedulershook"><code>RxJavaSchedulersHook</code></a>包裹所有<code>Action0</code> Sleuth代表中的实例，称为<code>TraceAction</code> 。挂钩将开始或继续跨度，具体取决于在计划操作之前是否已经进行了跟踪。禁用自定义<code>RxJavaSchedulersHook</code> ，将<code>spring.sleuth.rxjava.schedulers.hook.enabled</code>至<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>您可以为不想创建跨度的线程名称定义一个正则表达式列表。为此，请在列表中提供逗号分隔的正则表达式列表。 <code>spring.sleuth.rxjava.schedulers.ignoredthreads</code>属性。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">建议的反应式编程和Sleuth方法是使用Reactor支持。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="http-integration"><a class="anchor" href="#http-integration"></a> <a class="link" href="#http-integration">8.15.5。HTTP整合</a></h4>
<div class="paragraph">
<p>可以通过设置<code>spring.sleuth.web.enabled</code>属性值等于<code>false</code> 。</p>
</div>
<div class="sect4">
<h5 id="http-filter"><a class="anchor" href="#http-filter"></a> <a class="link" href="#http-filter">HTTP过滤器</a></h5>
<div class="paragraph">
<p>通过<code>TracingFilter</code> ，所有采样的传入请求均会创建跨度。那个Span的名字是<code>http:</code> +请求发送到的路径。例如，如果请求已发送至<code>/this/that</code>那么名称将是<code>http:/this/that</code> 。您可以通过设置以下网址来配置要跳过的URI： <code>spring.sleuth.web.skipPattern</code>属性。如果你有<code>ManagementServerProperties</code>在类路径上，其值<code>contextPath</code>被附加到提供的跳过模式中。如果您想重用Sleuth的默认跳过模式并追加自己的模式，请使用<code>spring.sleuth.web.additionalSkipPattern</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，所有弹簧启动执行器端点都会自动添加到跳过模式中。如果要禁用此行为集<code>spring.sleuth.web.ignore-auto-configured-skip-patterns</code>至<code>true</code> 。</p>
</div>
<div class="paragraph">
<p>要更改跟踪过滤器注册的顺序，请设置<code>spring.sleuth.web.filter-order</code>属性。</p>
</div>
<div class="paragraph">
<p>要禁用记录未捕获异常的过滤器，您可以禁用<code>spring.sleuth.web.exception-throwing-filter-enabled</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="handlerinterceptor"><a class="anchor" href="#handlerinterceptor"></a> <a class="link" href="#handlerinterceptor">处理程序拦截器</a></h5>
<div class="paragraph">
<p>由于我们希望范围名称精确，因此我们使用<code>TraceHandlerInterceptor</code>要么包装一个现有的<code>HandlerInterceptor</code>或直接添加到现有列表中<code>HandlerInterceptors</code> 。的<code>TraceHandlerInterceptor</code>向给定添加一个特殊的请求属性<code>HttpServletRequest</code> 。如果<code>TracingFilter</code>没有看到此属性，它将创建一个“后备”跨度，这是在服务器端创建的一个附加跨度，以便在UI中正确显示跟踪。如果发生这种情况，可能是缺少仪器。在这种情况下，请在Spring Cloud Sleuth中提出问题。</p>
</div>
</div>
<div class="sect4">
<h5 id="async-servlet-support"><a class="anchor" href="#async-servlet-support"></a> <a class="link" href="#async-servlet-support">异步Servlet支持</a></h5>
<div class="paragraph">
<p>如果您的控制器返回一个<code>Callable</code>或一个<code>WebAsyncTask</code> ，Spring Cloud Sleuth会继续现有范围，而不是创建一个新范围。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-support"><a class="anchor" href="#webflux-support"></a> <a class="link" href="#webflux-support">WebFlux支持</a></h5>
<div class="paragraph">
<p>通过<code>TraceWebFilter</code> ，所有采样的传入请求均会创建跨度。那个Span的名字是<code>http:</code> +请求发送到的路径。例如，如果请求已发送至<code>/this/that</code> ， 名字是<code>http:/this/that</code> 。您可以使用来配置要跳过的URI。 <code>spring.sleuth.web.skipPattern</code>属性。如果你有<code>ManagementServerProperties</code>在类路径上，其值<code>contextPath</code>被附加到提供的跳过模式中。如果您想重用Sleuth的默认跳过模式并添加自己的跳过模式，请使用<code>spring.sleuth.web.additionalSkipPattern</code> 。</p>
</div>
<div class="paragraph">
<p>要更改跟踪过滤器注册的顺序，请设置<code>spring.sleuth.web.filter-order</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="dubbo-rpc-support"><a class="anchor" href="#dubbo-rpc-support"></a> <a class="link" href="#dubbo-rpc-support">Dubbo RPC支持</a></h5>
<div class="paragraph">
<p>通过与Brave的集成，Spring Cloud Sleuth支持<a href="https://dubbo.apache.org/">Dubbo</a> 。只需添加<code>brave-instrumentation-dubbo</code>依赖关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>io.zipkin.brave</groupId>
    <artifactId>brave-instrumentation-dubbo</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>您还需要设置一个<code>dubbo.properties</code>包含以下内容的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">dubbo.provider.filter=tracing
dubbo.consumer.filter=tracing</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以<a href="https://github.com/openzipkin/brave/tree/master/instrumentation/dubbo-rpc">在此处</a>阅读有关Brave-Dubbo集成的更多信息。可以在<a href="https://github.com/openzipkin/sleuth-webmvc-example/compare/add-dubbo-tracing">此处</a>找到Spring Cloud Sleuth和Dubbo的示例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http-client-integration"><a class="anchor" href="#http-client-integration"></a> <a class="link" href="#http-client-integration">8.15.6。HTTP客户端集成</a></h4>
<div class="sect4">
<h5 id="synchronous-rest-template"><a class="anchor" href="#synchronous-rest-template"></a> <a class="link" href="#synchronous-rest-template">同步休息模板</a></h5>
<div class="paragraph">
<p>我们注入一个<code>RestTemplate</code>拦截器，以确保将所有跟踪信息传递给请求。每次拨打电话时，都会创建一个新的跨度。收到响应后关闭。阻止同步<code>RestTemplate</code>功能集<code>spring.sleuth.web.client.enabled</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您必须注册<code>RestTemplate</code>作为一个bean，以便拦截器被注入。如果您创建一个<code>RestTemplate</code>具有一个的实例<code>new</code>关键字，则检测无效。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="asynchronous-rest-template"><a class="anchor" href="#asynchronous-rest-template"></a> <a class="link" href="#asynchronous-rest-template">异步休息模板</a></h5>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">从侦探开始<code>2.0.0</code> ，我们不再注册的Bean <code>AsyncRestTemplate</code>类型。创建此类Bean由您自己决定。然后我们对其进行检测。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>阻止<code>AsyncRestTemplate</code>功能集<code>spring.sleuth.web.async.client.enabled</code>至<code>false</code> 。禁用默认设置<code>TraceAsyncClientHttpRequestFactoryWrapper</code> ，设定<code>spring.sleuth.web.async.client.factory.enabled</code>至<code>false</code> 。如果您不想创建<code>AsyncRestClient</code>设置好了<code>spring.sleuth.web.async.client.template.enabled</code>至<code>false</code> 。</p>
</div>
<div class="sect5">
<h6 id="multiple-asynchronous-rest-templates"><a class="anchor" href="#multiple-asynchronous-rest-templates"></a> <a class="link" href="#multiple-asynchronous-rest-templates">多个异步休息模板</a></h6>
<div class="paragraph">
<p>有时您需要使用异步实现模板的多个实现。在以下代码段中，您可以看到有关如何设置此类自定义代码的示例<code>AsyncRestTemplate</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableAutoConfiguration
static class Config {

    @Bean(name = "customAsyncRestTemplate")
    public AsyncRestTemplate traceAsyncRestTemplate() {
        return new AsyncRestTemplate(asyncClientFactory(),
                clientHttpRequestFactory());
    }

    private ClientHttpRequestFactory clientHttpRequestFactory() {
        ClientHttpRequestFactory clientHttpRequestFactory = new CustomClientHttpRequestFactory();
        // CUSTOMIZE HERE
        return clientHttpRequestFactory;
    }

    private AsyncClientHttpRequestFactory asyncClientFactory() {
        AsyncClientHttpRequestFactory factory = new CustomAsyncClientHttpRequestFactory();
        // CUSTOMIZE HERE
        return factory;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webclient"><a class="anchor" href="#webclient"></a><a class="link" href="#webclient"><code>WebClient</code></a></h5>
<div class="paragraph">
<p>我们注入一个<code>ExchangeFilterFunction</code>创建跨度并通过成功和错误时回调的实现，负责关闭客户端跨度。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.web.client.enabled</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您必须注册<code>WebClient</code>作为bean，以便应用跟踪工具。如果您创建一个<code>WebClient</code>具有一个的实例<code>new</code>关键字，则检测无效。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="traverson"><a class="anchor" href="#traverson"></a> <a class="link" href="#traverson">特拉弗森</a></h5>
<div class="paragraph">
<p>如果您使用<a href="https://docs.spring.io/spring-hateoas/docs/current/reference/html/#client.traverson">Traverson</a>库，则可以注入一个<code>RestTemplate</code>作为到Traverson对象中的bean。以来<code>RestTemplate</code>已被拦截，您将完全支持在客户端中进行跟踪。以下伪代码显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired RestTemplate restTemplate;

Traverson traverson = new Traverson(URI.create("https://some/address"),
    MediaType.APPLICATION_JSON, MediaType.APPLICATION_JSON_UTF8).setRestOperations(restTemplate);
// use Traverson</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache-httpclientbuilder-and-httpasyncclientbuilder"><a class="anchor" href="#apache-httpclientbuilder-and-httpasyncclientbuilder"></a> <a class="link" href="#apache-httpclientbuilder-and-httpasyncclientbuilder">阿帕奇<code>HttpClientBuilder</code>和<code>HttpAsyncClientBuilder</code></a></h5>
<div class="paragraph">
<p>我们对<code>HttpClientBuilder</code>和<code>HttpAsyncClientBuilder</code>以便将跟踪上下文注入到已发送的请求中。</p>
</div>
<div class="paragraph">
<p>要阻止这些功能，请设置<code>spring.sleuth.web.client.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="netty-httpclient"><a class="anchor" href="#netty-httpclient"></a> <a class="link" href="#netty-httpclient">净额<code>HttpClient</code></a></h5>
<div class="paragraph">
<p>我们对Netty的<code>HttpClient</code> 。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.web.client.enabled</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您必须注册<code>HttpClient</code>作为bean，以便进行检测。如果您创建一个<code>HttpClient</code>具有一个的实例<code>new</code>关键字，则检测无效。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="userinforesttemplatecustomizer"><a class="anchor" href="#userinforesttemplatecustomizer"></a><a class="link" href="#userinforesttemplatecustomizer"><code>UserInfoRestTemplateCustomizer</code></a></h5>
<div class="paragraph">
<p>我们对Spring Security的<code>UserInfoRestTemplateCustomizer</code> 。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.web.client.enabled</code>至<code>false</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="feign"><a class="anchor" href="#feign"></a> <a class="link" href="#feign">8.15.7。假装</a></h4>
<div class="paragraph">
<p>默认情况下，Spring Cloud Sleuth通过以下方式与Feign集成<code>TraceFeignClientAutoConfiguration</code> 。您可以通过设置完全禁用它<code>spring.sleuth.feign.enabled</code>至<code>false</code> 。如果这样做，则不会进行任何与Feign相关的检测。</p>
</div>
<div class="paragraph">
<p>Feign仪器的一部分通过<code>FeignBeanPostProcessor</code> 。您可以通过设置禁用它<code>spring.sleuth.feign.processor.enabled</code>至<code>false</code> 。如果设置为<code>false</code> ，Spring Cloud Sleuth不会检测您的任何定制Feign组件。但是，所有默认工具仍然存在。</p>
</div>
</div>
<div class="sect3">
<h4 id="grpc"><a class="anchor" href="#grpc"></a> <a class="link" href="#grpc">8.15.8。 gRPC</a></h4>
<div class="paragraph">
<p>Spring Cloud Sleuth通过以下方式为<a href="https://grpc.io/">gRPC</a>提供工具<code>TraceGrpcAutoConfiguration</code> 。您可以通过设置完全禁用它<code>spring.sleuth.grpc.enabled</code>至<code>false</code> 。</p>
</div>
<div class="sect4">
<h5 id="variant-1"><a class="anchor" href="#variant-1"></a> <a class="link" href="#variant-1">变体1</a></h5>
<div class="sect5">
<h6 id="dependencies"><a class="anchor" href="#dependencies"></a> <a class="link" href="#dependencies">依存关系</a></h6>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">gRPC集成依赖于两个外部库来检测客户端和服务器，并且这两个库都必须在类路径上才能启用检测。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Maven：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>        <dependency>
            <groupId>io.github.lognet</groupId>
            <artifactId>grpc-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>io.zipkin.brave</groupId>
            <artifactId>brave-instrumentation-grpc</artifactId>
        </dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>摇篮：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>    compile("io.github.lognet:grpc-spring-boot-starter")
    compile("io.zipkin.brave:brave-instrumentation-grpc")</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="server-instrumentation"><a class="anchor" href="#server-instrumentation"></a> <a class="link" href="#server-instrumentation">服务器检测</a></h6>
<div class="paragraph">
<p>Spring Cloud Sleuth利用grpc-spring-boot-starter向带有注释的所有服务注册Brave的gRPC服务器拦截器<code>@GRpcService</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="client-instrumentation"><a class="anchor" href="#client-instrumentation"></a> <a class="link" href="#client-instrumentation">客户端工具</a></h6>
<div class="paragraph">
<p>gRPC客户端利用<code>ManagedChannelBuilder</code>构造一个<code>ManagedChannel</code>用于与gRPC服务器通信。本地人<code>ManagedChannelBuilder</code>提供静态方法作为构建的入口点<code>ManagedChannel</code>但是，这种实例在Spring应用程序上下文的影响范围之外。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">Spring Cloud Sleuth提供了<code>SpringAwareManagedChannelBuilder</code>可以通过Spring应用程序上下文进行自定义，并由gRPC客户端注入。<strong>创建时必须使用此构建器<code>ManagedChannel</code>实例。</strong>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>侦探创造一个<code>TracingManagedChannelBuilderCustomizer</code>将Brave的客户端拦截器注入到<code>SpringAwareManagedChannelBuilder</code> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="variant-2"><a class="anchor" href="#variant-2"></a> <a class="link" href="#variant-2">变体2</a></h5>
<div class="paragraph">
<p><a href="https://github.com/yidongnan/grpc-spring-boot-starter">Grpc Spring Boot Starter</a>自动检测Spring Cloud Sleuth和brave的gRPC工具的存在，并注册必要的客户端和/或服务器工具。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="asynchronous-communication"><a class="anchor" href="#asynchronous-communication"></a> <a class="link" href="#asynchronous-communication">8.15.9。异步通讯</a></h4>
<div class="sect4">
<h5 id="async-annotated-methods"><a class="anchor" href="#async-annotated-methods"></a> <a class="link" href="#async-annotated-methods"><code>@Async</code>带注释的方法</a></h5>
<div class="paragraph">
<p>在Spring Cloud Sleuth中，我们检测与异步相关的组件，以便在线程之间传递跟踪信息。您可以通过设置以下值来禁用此行为： <code>spring.sleuth.async.enabled</code>至<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>如果您用<code>@Async</code> ，我们将自动创建具有以下特征的新跨度：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果该方法带有注释<code>@SpanName</code> ，注释的值是Span的名称。</p>
</li>
<li>
<p>如果该方法未使用注释<code>@SpanName</code> ，Span名称是带注释的方法名称。</p>
</li>
<li>
<p>该范围用方法的类名和方法名标记。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="scheduled-annotated-methods"><a class="anchor" href="#scheduled-annotated-methods"></a> <a class="link" href="#scheduled-annotated-methods"><code>@Scheduled</code>带注释的方法</a></h5>
<div class="paragraph">
<p>在Spring Cloud Sleuth中，我们对调度的方法执行进行检测，以便在线程之间传递跟踪信息。您可以通过设置以下值来禁用此行为： <code>spring.sleuth.scheduled.enabled</code>至<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>如果您用<code>@Scheduled</code> ，我们将自动创建具有以下特征的新跨度：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>跨度名称是带注释的方法名称。</p>
</li>
<li>
<p>该范围用方法的类名和方法名标记。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您要跳过跨度创建一些<code>@Scheduled</code>带注释的类，您可以设置<code>spring.sleuth.scheduled.skipPattern</code>使用与表达式的完全限定名称匹配的正则表达式<code>@Scheduled</code>带注释的类。如果您使用<code>spring-cloud-sleuth-stream</code>和<code>spring-cloud-netflix-hystrix-stream</code>在一起，将为每个Hystrix指标创建一个范围并将其发送给Zipkin。此行为可能很烦人。这就是为什么默认情况下<code>spring.sleuth.scheduled.skipPattern=org.springframework.cloud.netflix.hystrix.stream.HystrixStreamTask</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="executor-executorservice-and-scheduledexecutorservice"><a class="anchor" href="#executor-executorservice-and-scheduledexecutorservice"></a> <a class="link" href="#executor-executorservice-and-scheduledexecutorservice">Executor，ExecutorService和ScheduledExecutorService</a></h5>
<div class="paragraph">
<p>我们提供<code>LazyTraceExecutor</code> ， <code>TraceableExecutorService</code>和<code>TraceableScheduledExecutorService</code> 。每次提交，调用或计划新任务时，这些实现都会创建跨度。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何通过以下方式传递跟踪信息： <code>TraceableExecutorService</code>当与<code>CompletableFuture</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletableFuture<Long> completableFuture = CompletableFuture.supplyAsync(() -> {
    // perform some logic
    return 1_000_000L;
}, new TraceableExecutorService(beanFactory, executorService,
        // 'calculateTax' explicitly names the span - this param is optional
        "calculateTax"));</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">侦探不适用于<code>parallelStream()</code>盒子外面。如果要使跟踪信息通过流传播，则必须将方法与<code>supplyAsync(…​)</code> ，如先前所示。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果有实现<code>Executor</code>您要从跨度创建中排除的界面，可以使用<code>spring.sleuth.async.ignored-beans</code>属性，您可以在其中提供Bean名称列表。</p>
</div>
<div class="sect5">
<h6 id="customization-of-executors"><a class="anchor" href="#customization-of-executors"></a> <a class="link" href="#customization-of-executors">定制执行者</a></h6>
<div class="paragraph">
<p>有时，您需要设置一个自定义实例<code>AsyncExecutor</code> 。以下示例显示了如何设置这样的自定义<code>Executor</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Configuration
@EnableAutoConfiguration
@EnableAsync
// add the infrastructure role to ensure that the bean gets auto-proxied
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
static class CustomExecutorConfig extends AsyncConfigurerSupport {

    @Autowired
    BeanFactory beanFactory;

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // CUSTOMIZE HERE
        executor.setCorePoolSize(7);
        executor.setMaxPoolSize(42);
        executor.setQueueCapacity(11);
        executor.setThreadNamePrefix("MyExecutor-");
        // DON'T FORGET TO INITIALIZE
        executor.initialize();
        return new LazyTraceExecutor(this.beanFactory, executor);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">为确保您的配置得到后期处理，请记住添加<code>@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</code>在你的<code>@Configuration</code>类</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="messaging-2"><a class="anchor" href="#messaging-2"></a> <a class="link" href="#messaging-2">8.15.10。讯息传递</a></h4>
<div class="paragraph">
<p>可以通过设置<code>spring.sleuth.messaging.enabled</code>属性值等于<code>false</code> 。</p>
</div>
<div class="sect4">
<h5 id="spring-integration-and-spring-cloud-stream"><a class="anchor" href="#spring-integration-and-spring-cloud-stream"></a> <a class="link" href="#spring-integration-and-spring-cloud-stream">Spring集成和Spring Cloud Stream</a></h5>
<div class="paragraph">
<p>Spring Cloud Sleuth与<a href="https://projects.spring.io/spring-integration/">Spring Integration集成</a> 。它为发布和订阅事件创建跨度。要禁用Spring Integration工具，请设置<code>spring.sleuth.integration.enabled</code>至<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>您可以提供<code>spring.sleuth.integration.patterns</code>模式以显式提供要包括在跟踪中的通道的名称。默认情况下，除<code>hystrixStreamOutput</code>包括频道。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">使用时<code>Executor</code>建立一个Spring Integration <code>IntegrationFlow</code> ，您必须使用未跟踪的<code>Executor</code> 。使用以下方法装饰Spring Integration Executor通道<code>TraceableExecutorService</code>导致跨度未正确关闭。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要定制从消息头读取和写入跟踪上下文的方式，就足以注册类型的bean：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Propagation.Setter<MessageHeaderAccessor, String></code> -用于将标头写入消息</p>
</li>
<li>
<p><code>Propagation.Getter<MessageHeaderAccessor, String></code> -从邮件中读取标题</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spring-rabbitmq"><a class="anchor" href="#spring-rabbitmq"></a> <a class="link" href="#spring-rabbitmq">春天兔子</a></h5>
<div class="paragraph">
<p>我们对<code>RabbitTemplate</code>以便将跟踪标头注入到消息中。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.messaging.rabbit.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-kafka"><a class="anchor" href="#spring-kafka"></a> <a class="link" href="#spring-kafka">春天卡夫卡</a></h5>
<div class="paragraph">
<p>我们对春季卡夫卡的<code>ProducerFactory</code>和<code>ConsumerFactory</code>以便将跟踪标头注入到创建的Spring Kafka的<code>Producer</code>和<code>Consumer</code> 。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.messaging.kafka.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-kafka-streams"><a class="anchor" href="#spring-kafka-streams"></a> <a class="link" href="#spring-kafka-streams">春天卡夫卡溪流</a></h5>
<div class="paragraph">
<p>我们对<code>KafkaStreams</code><code>KafkaClientSupplier</code>以便将跟踪标头注入到<code>Producer</code>和<code>Consumer`s. A `KafkaStreamsTracing</code> bean允许通过其他方式进行进一步的检测<code>TransformerSupplier</code>和<code>ProcessorSupplier</code>方法。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.messaging.kafka.streams.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-jms"><a class="anchor" href="#spring-jms"></a> <a class="link" href="#spring-jms">春季JMS</a></h5>
<div class="paragraph">
<p>我们对<code>JmsTemplate</code>以便将跟踪标头注入到消息中。我们也支持<code>@JmsListener</code>消费者方的注释方法。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.messaging.jms.enabled</code>至<code>false</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">我们不支持JMS的行李运送</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-aws-messaging-sqs"><a class="anchor" href="#spring-cloud-aws-messaging-sqs"></a> <a class="link" href="#spring-cloud-aws-messaging-sqs">Spring Cloud AWS Messaging SQS</a></h5>
<div class="paragraph">
<p>我们仪器<code>@SqsListener</code>由...提供<code>org.springframework.cloud:spring-cloud-aws-messaging</code>这样就可以从消息中提取跟踪头，并在上下文中添加跟踪。</p>
</div>
<div class="paragraph">
<p>要阻止此功能，请设置<code>spring.sleuth.messaging.sqs.enabled</code>至<code>false</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zuul-2"><a class="anchor" href="#zuul-2"></a> <a class="link" href="#zuul-2">8.15.11。祖尔</a></h4>
<div class="paragraph">
<p>我们通过使用跟踪信息丰富功能区请求来检测Zuul功能区集成。要禁用Zuul支持，请设置<code>spring.sleuth.zuul.enabled</code>财产<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="redis"><a class="anchor" href="#redis"></a> <a class="link" href="#redis">8.15.12。雷迪斯</a></h4>
<div class="paragraph">
<p>我们设置<code>tracing</code> Lettcue的财产<code>ClientResources</code>实例以启用Lettuce中内置的Brave跟踪。要禁用Redis支持，请设置<code>spring.sleuth.redis.enabled</code>财产<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="quartz"><a class="anchor" href="#quartz"></a> <a class="link" href="#quartz">8.15.13。石英</a></h4>
<div class="paragraph">
<p>我们通过在Quartz Scheduler中添加Job / Trigger侦听器来检测石英作业。</p>
</div>
<div class="paragraph">
<p>要关闭此功能，请设置<code>spring.sleuth.quartz.enabled</code>财产<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="project-reactor"><a class="anchor" href="#project-reactor"></a> <a class="link" href="#project-reactor">8.15.14。项目反应堆</a></h4>
<div class="paragraph">
<p>对于依赖Project Reactor的项目，例如Spring Cloud Gateway，我们建议将<code>spring.sleuth.reactor.decorate-on-each</code>选择<code>false</code> 。这样，与标准仪器机制相比，应观察到性能提高。该选项的作用是包装装饰<code>onLast</code>运算符代替<code>onEach</code>这将导致创建更少的对象。缺点是，当Project Reactor更改线程时，跟踪传播将继续而不会出现问题，但是任何依赖于<code>ThreadLocal</code>例如MDC条目可能有问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-5"><a class="anchor" href="#configuration-properties-5"></a> <a class="link" href="#configuration-properties-5">8.16。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与Sleuth相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="running-examples"><a class="anchor" href="#running-examples"></a> <a class="link" href="#running-examples">8.17。运行示例</a></h3>
<div class="paragraph">
<p>您可以看到在<a href="https://run.pivotal.io/">Pivotal Web Services中</a>部署的正在运行的示例。在以下链接中查看它们：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docssleuth-zipkin-server.cfapps.io/">Zipkin的应用程序在示例中呈现到顶部</a> 。首先向<a href="https://docssleuth-service1.cfapps.io/start">服务1</a>发出请求，然后在Zipkin中签出跟踪。</p>
</li>
<li>
<p><a href="https://docsbrewing-zipkin-server.cfapps.io/">Zipkin for PWS上的啤酒厂</a> ，其<a href="https://github.com/spring-cloud-samples/brewery">Github代码</a> 。确保选择了7天的回溯期。如果没有任何痕迹，请转到“ <a href="https://docsbrewing-presenting.cfapps.io/">呈现应用程序”</a>并订购一些啤酒。然后检查Zipkin是否有痕迹。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-consul"><a class="anchor" href="#spring-cloud-consul"></a> <a class="link" href="#spring-cloud-consul">9。spring-cloud-consul</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="paragraph">
<p>该项目通过自动配置并绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供Consul集成。通过一些简单的注释，您可以快速启用和配置应用程序内部的通用模式，并使用基于Consul的组件构建大型分布式系统。提供的模式包括服务发现，控制总线和配置。通过与Spring Cloud Netflix集成提供智能路由（Zuul）和客户端负载平衡（Ribbon），断路器（Hystrix）。</p>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-install"><a class="anchor" href="#spring-cloud-consul-install"></a> <a class="link" href="#spring-cloud-consul-install">9.1。安装领事</a></h3>
<div class="paragraph">
<p>请参阅<a href="https://www.consul.io/intro/getting-started/install.html">安装文档</a>以获取有关如何安装Consul的说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-agent"><a class="anchor" href="#spring-cloud-consul-agent"></a> <a class="link" href="#spring-cloud-consul-agent">9.2。领事代理</a></h3>
<div class="paragraph">
<p>Consul Agent客户端必须可用于所有Spring Cloud Consul应用程序。默认情况下，代理客户端应位于<code>localhost:8500</code> 。有关如何启动代理客户端以及如何连接到Consul代理服务器群集的详细信息，请参阅<a href="https://consul.io/docs/agent/basics.html">代理文档</a> 。为了进行开发，在安装consul之后，可以使用以下命令启动Consul代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./src/main/bash/local_run_consul.sh</pre>
</div>
</div>
<div class="paragraph">
<p>这将在服务器模式下的端口8500上启动代理，并且ui在<a href="http://localhost:8500" class="bare">localhost：8500</a>可用</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-discovery"><a class="anchor" href="#spring-cloud-consul-discovery"></a> <a class="link" href="#spring-cloud-consul-discovery">9.3。领事服务发现</a></h3>
<div class="paragraph">
<p>服务发现是基于微服务的体系结构的关键原则之一。尝试手动配置每个客户端或某种形式的约定可能非常困难并且非常脆弱。领事通过<a href="https://www.consul.io/docs/agent/http.html">HTTP API</a>和<a href="https://www.consul.io/docs/agent/dns.html">DNS</a>提供服务发现服务。Spring Cloud Consul利用HTTP API进行服务注册和发现。这不会阻止非Spring Cloud应用程序利用DNS接口。Consul Agents服务器在<a href="https://www.consul.io/docs/internals/architecture.html">群集中</a>运行，该<a href="https://www.consul.io/docs/internals/architecture.html">群集</a>通过<a href="https://www.consul.io/docs/internals/gossip.html">八卦协议进行通信</a>并使用<a href="https://www.consul.io/docs/internals/consensus.html">Raft共识协议</a> 。</p>
</div>
<div class="sect3">
<h4 id="how-to-activate"><a class="anchor" href="#how-to-activate"></a> <a class="link" href="#how-to-activate">9.3.1。如何激活</a></h4>
<div class="paragraph">
<p>要激活Consul Service Discovery，请使用带有启动器的组<code>org.springframework.cloud</code>和工件ID <code>spring-cloud-starter-consul-discovery</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="registering-with-consul"><a class="anchor" href="#registering-with-consul"></a> <a class="link" href="#registering-with-consul">9.3.2。向领事注册</a></h4>
<div class="paragraph">
<p>当客户端向Consul注册时，它将提供有关其自身的元数据，例如主机和端口，id，名称和标签。默认情况下会创建一个HTTP <a href="https://www.consul.io/docs/agent/checks.html">Check</a> ，Consul会点击<code>/health</code>每10秒终结一次端点。如果运行状况检查失败，则将该服务实例标记为关键。</p>
</div>
<div class="paragraph">
<p>领事客户端示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>（即完全正常的Spring Boot应用）。如果领事客户不在其他地方<code>localhost:8500</code> ，则需要进行配置才能找到客户端。例：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      host: localhost
      port: 8500</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">如果您使用<a href="#spring-cloud-consul-config">Spring Cloud Consul Config</a> ，则需要将上述值放在<code>bootstrap.yml</code>代替<code>application.yml</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认服务名称，实例ID和端口，取自<code>Environment</code> ， 是<code>${spring.application.name}</code> ，Spring Context ID和<code>${server.port}</code>分别。</p>
</div>
<div class="paragraph">
<p>要禁用Consul Discovery Client，您可以设置<code>spring.cloud.consul.discovery.enabled</code>至<code>false</code> 。Consul Discovery Client在以下情况下也将被禁用<code>spring.cloud.discovery.enabled</code>被设定为<code>false</code> 。</p>
</div>
<div class="paragraph">
<p>要禁用服务注册，您可以设置<code>spring.cloud.consul.discovery.register</code>至<code>false</code> 。</p>
</div>
<div class="sect4">
<h5 id="registering-management-as-a-separate-service"><a class="anchor" href="#registering-management-as-a-separate-service"></a> <a class="link" href="#registering-management-as-a-separate-service">将管理注册为单独的服务</a></h5>
<div class="paragraph">
<p>通过将管理服务器端口设置为与应用程序端口不同的端口时<code>management.server.port</code>物业，管理服务将被注册为与应用程序服务不同的服务。例如：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  application:
    name: myApp
management:
  server:
    port: 4452</pre>
</div>
</div>
<div class="paragraph">
<p>以上配置将注册以下两项服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>申请服务：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>ID: myApp
Name: myApp</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>管理服务：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>ID: myApp-management
Name: myApp-management</pre>
</div>
</div>
<div class="paragraph">
<p>管理服务将继承其<code>instanceId</code>和<code>serviceName</code>从应用程序服务。例如：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  application:
    name: myApp
management:
  server:
    port: 4452
spring:
  cloud:
    consul:
      discovery:
        instance-id: custom-service-id
        serviceName: myprefix-${spring.application.name}</pre>
</div>
</div>
<div class="paragraph">
<p>以上配置将注册以下两项服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>申请服务：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>ID: custom-service-id
Name: myprefix-myApp</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>管理服务：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>ID: custom-service-id-management
Name: myprefix-myApp-management</pre>
</div>
</div>
<div class="paragraph">
<p>通过以下属性可以进行进一步的自定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/** Port to register the management service under (defaults to management port) */
spring.cloud.consul.discovery.management-port

/** Suffix to use when registering management service (defaults to "management" */
spring.cloud.consul.discovery.management-suffix

/** Tags to use when registering management service (defaults to "management" */
spring.cloud.consul.discovery.management-tags</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http-health-check"><a class="anchor" href="#http-health-check"></a> <a class="link" href="#http-health-check">9.3.3。HTTP运行状况检查</a></h4>
<div class="paragraph">
<p>Consul实例的运行状况检查默认为“ / health”，这是Spring Boot Actuator应用程序中有用端点的默认位置。即使您使用非默认上下文路径或servlet路径（例如，对于Actuator应用程序），也需要更改这些设置<code>server.servletPath=/foo</code> ）或管理端点路径（例如<code>management.server.servlet.context-path=/admin</code> ）。还可以配置Consul用于检查运行状况终结点的时间间隔。 “ 10s”和“ 1m”分别代表10秒和1分钟。例：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      discovery:
        healthCheckPath: ${management.server.servlet.context-path}/health
        healthCheckInterval: 15s</pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过设置禁用健康检查<code>management.health.consul.enabled=false</code> 。</p>
</div>
<div class="sect4">
<h5 id="metadata-and-consul-tags"><a class="anchor" href="#metadata-and-consul-tags"></a> <a class="link" href="#metadata-and-consul-tags">元数据和领事标签</a></h5>
<div class="paragraph">
<p>领事尚不支持有关服务的元数据。Spring Cloud的<code>ServiceInstance</code>有个<code>Map<String, String> metadata</code>领域。在Consul正式支持元数据之前，Spring Cloud Consul使用Consul标签来近似元数据。带有形式的标签<code>key=value</code>将被拆分并用作<code>Map</code>键和值。没有相等的标签<code>=</code>符号，将同时用作键和值。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      discovery:
        tags: foo=bar, baz</pre>
</div>
</div>
<div class="paragraph">
<p>上面的配置将生成带有<code>foo→bar</code>和<code>baz→baz</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="making-the-consul-instance-id-unique"><a class="anchor" href="#making-the-consul-instance-id-unique"></a> <a class="link" href="#making-the-consul-instance-id-unique">使领事实例ID唯一</a></h5>
<div class="paragraph">
<p>默认情况下，领事实例的ID等于其Spring Application Context ID。默认情况下，Spring Application Context ID为<code>${spring.application.name}:comma,separated,profiles:${server.port}</code> 。在大多数情况下，这将允许一项服务的多个实例在一台计算机上运行。如果需要进一步的唯一性，则可以使用Spring Cloud通过在<code>spring.cloud.consul.discovery.instanceId</code> 。例如：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      discovery:
        instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}</pre>
</div>
</div>
<div class="paragraph">
<p>有了此元数据，并且在本地主机上部署了多个服务实例，随机值将在其中插入以使实例唯一。在Cloudfoundry中<code>vcap.application.instance_id</code>将在Spring Boot应用程序中自动填充，因此将不需要随机值。</p>
</div>
</div>
<div class="sect4">
<h5 id="applying-headers-to-health-check-requests"><a class="anchor" href="#applying-headers-to-health-check-requests"></a> <a class="link" href="#applying-headers-to-health-check-requests">将标头应用于健康检查请求</a></h5>
<div class="paragraph">
<p>标头可以应用于健康检查请求。例如，如果您尝试注册使用<a href="https://github.com/spring-cloud/spring-cloud-config/blob/master/docs/src/main/asciidoc/spring-cloud-config.adoc#vault-backend">Vault Backend</a>的<a href="https://cloud.spring.io/spring-cloud-config/">Spring Cloud Config</a>服务器：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      discovery:
        health-check-headers:
          X-Config-Token: 6442e58b-d1ea-182e-cfa5-cf9cddef0722</pre>
</div>
</div>
<div class="paragraph">
<p>根据HTTP标准，每个标头可以有多个值，在这种情况下，可以提供一个数组：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      discovery:
        health-check-headers:
          X-Config-Token:
            - "6442e58b-d1ea-182e-cfa5-cf9cddef0722"
            - "Some other value"</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="looking-up-services"><a class="anchor" href="#looking-up-services"></a> <a class="link" href="#looking-up-services">9.3.4。查找服务</a></h4>
<div class="sect4">
<h5 id="using-load-balancer"><a class="anchor" href="#using-load-balancer"></a> <a class="link" href="#using-load-balancer">使用负载均衡器</a></h5>
<div class="paragraph">
<p>Spring Cloud支持<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign">Feign</a> （REST客户端构建器）以及<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon">Spring <code>RestTemplate</code></a>用于使用逻辑服务名称/ ID而非物理URL查找服务。 Feign和可发现发现的RestTemplate都使用<a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon">Ribbon</a>进行客户端负载平衡。</p>
</div>
<div class="paragraph">
<p>如果要使用RestTemplate访问服务STORES，只需声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@LoadBalanced
@Bean
public RestTemplate loadbalancedRestTemplate() {
     return new RestTemplate();
}</pre>
</div>
</div>
<div class="paragraph">
<p>并以这种方式使用它（注意我们如何使用Consul的STORES服务名称/ id代替完全限定的域名）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Autowired
RestTemplate restTemplate;

public String getFirstProduct() {
   return this.restTemplate.getForObject("https://STORES/products/1", String.class);
}</pre>
</div>
</div>
<div class="paragraph">
<p>如果您在多个数据中心中拥有Consul群集，并且要访问另一个数据中心中的服务，则仅靠服务名称/ id是不够的。在这种情况下，您使用财产<code>spring.cloud.consul.discovery.datacenters.STORES=dc-west</code>哪里<code>STORES</code>是服务名称/ ID，并且<code>dc-west</code>是STORES服务所在的数据中心。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Cloud现在还提供对<a href="https://cloud.spring.io/spring-cloud-commons/reference/html/#_spring_resttemplate_as_a_load_balancer_client">Spring Cloud LoadBalancer的</a>支持。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>由于Spring Cloud Ribbon正在维护中，建议您设置<code>spring.cloud.loadbalancer.ribbon.enabled</code>至<code>false</code> ， 以便<code>BlockingLoadBalancerClient</code>用于代替<code>RibbonLoadBalancerClient</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-the-discoveryclient"><a class="anchor" href="#using-the-discoveryclient"></a> <a class="link" href="#using-the-discoveryclient">使用DiscoveryClient</a></h5>
<div class="paragraph">
<p>您也可以使用<code>org.springframework.cloud.client.discovery.DiscoveryClient</code>它为发现客户端提供了一个不特定于Netflix的简单API，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List<ServiceInstance> list = discoveryClient.getInstances("STORES");
    if (list != null && list.size() > 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="consul-catalog-watch"><a class="anchor" href="#consul-catalog-watch"></a> <a class="link" href="#consul-catalog-watch">9.3.5。领事目录手表</a></h4>
<div class="paragraph">
<p>领事目录监视利用领事<a href="https://www.consul.io/docs/agent/watches.html#services">监视服务</a>的能力。Catalog Watch进行了阻塞的Consul HTTP API调用，以确定是否已更改任何服务。如果有新的服务数据，则会发布心跳事件。</p>
</div>
<div class="paragraph">
<p>更改配置监视被称为更改的频率<code>spring.cloud.consul.config.discovery.catalog-services-watch-delay</code> 。默认值为1000，以毫秒为单位。延迟是上一次调用结束与下一次调用开始之间的时间量。</p>
</div>
<div class="paragraph">
<p>禁用目录监视集<code>spring.cloud.consul.discovery.catalogServicesWatch.enabled=false</code> 。</p>
</div>
<div class="paragraph">
<p>手表使用弹簧<code>TaskScheduler</code>安排致电领事。默认情况下是<code>ThreadPoolTaskScheduler</code>与一个<code>poolSize</code>共1。改变<code>TaskScheduler</code> ，创建一个类型的bean <code>TaskScheduler</code>以命名<code>ConsulDiscoveryClientConfiguration.CATALOG_WATCH_TASK_SCHEDULER_NAME</code>不变。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-config"><a class="anchor" href="#spring-cloud-consul-config"></a> <a class="link" href="#spring-cloud-consul-config">9.4。使用Consul进行分布式配置</a></h3>
<div class="paragraph">
<p>领事提供<a href="https://consul.io/docs/agent/http/kv.html">密钥/值存储，</a>用于存储配置和其他元数据。Spring Cloud Consul Config是<a href="https://github.com/spring-cloud/spring-cloud-config">Config Server和Client</a>的替代方案。在特殊的“引导”阶段将配置加载到Spring环境中。配置存储在<code>/config</code>文件夹默认情况下。多<code>PropertySource</code>实例是根据应用程序的名称和模仿Spring Cloud Config解析属性顺序的活动配置文件创建的。例如，名称为“ testApp”且配置文件为“ dev”的应用程序将创建以下属性源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>config/testApp,dev/
config/testApp/
config/application,dev/
config/application/</pre>
</div>
</div>
<div class="paragraph">
<p>最具体的属性来源在顶部，最不具体的属性在底部。中的属性<code>config/application</code>该文件夹适用于使用领事进行配置的所有应用程序。中的属性<code>config/testApp</code>文件夹仅可用于名为“ testApp”的服务的实例。</p>
</div>
<div class="paragraph">
<p>当前在启动应用程序时读取配置。发送HTTP POST到<code>/refresh</code>将导致重新加载配置。<a href="#spring-cloud-consul-config-watch">Config Watch</a>也将自动检测更改并重新加载应用程序上下文。</p>
</div>
<div class="sect3">
<h4 id="how-to-activate-2"><a class="anchor" href="#how-to-activate-2"></a> <a class="link" href="#how-to-activate-2">9.4.1。如何激活</a></h4>
<div class="paragraph">
<p>要开始使用Consul Configuration，请使用带有starter的组<code>org.springframework.cloud</code>和工件ID <code>spring-cloud-starter-consul-config</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="paragraph">
<p>这将启用自动配置，该自动配置将设置Spring Cloud Consul Config。</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing"><a class="anchor" href="#customizing"></a> <a class="link" href="#customizing">9.4.2。客制化</a></h4>
<div class="paragraph">
<p>Consul Config可以使用以下属性来自定义：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      config:
        enabled: true
        prefix: configuration
        defaultContext: apps
        profileSeparator: '::'</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为“ false”将禁用Consul Config</p>
</li>
<li>
<p><code>prefix</code>设置配置值的基本文件夹</p>
</li>
<li>
<p><code>defaultContext</code>设置所有应用程序使用的文件夹名称</p>
</li>
<li>
<p><code>profileSeparator</code>设置用于分隔属性源和配置文件中的配置文件名称的分隔符的值</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-consul-config-watch"><a class="anchor" href="#spring-cloud-consul-config-watch"></a> <a class="link" href="#spring-cloud-consul-config-watch">9.4.3。配置监视</a></h4>
<div class="paragraph">
<p>Consul Config Watch利用consul <a href="https://www.consul.io/docs/agent/watches.html#keyprefix">监视键前缀的功能</a> 。Config Watch进行阻塞Consul HTTP API调用，以确定当前应用程序的任何相关配置数据是否已更改。如果有新的配置数据，则会发布刷新事件。这等效于调用<code>/refresh</code>执行器端点。</p>
</div>
<div class="paragraph">
<p>更改配置监视被称为更改的频率<code>spring.cloud.consul.config.watch.delay</code> 。默认值为1000，以毫秒为单位。延迟是上一次调用结束与下一次调用开始之间的时间量。</p>
</div>
<div class="paragraph">
<p>禁用配置监视集<code>spring.cloud.consul.config.watch.enabled=false</code> 。</p>
</div>
<div class="paragraph">
<p>手表使用弹簧<code>TaskScheduler</code>安排致电领事。默认情况下是<code>ThreadPoolTaskScheduler</code>与一个<code>poolSize</code>共1。改变<code>TaskScheduler</code> ，创建一个类型的bean <code>TaskScheduler</code>以命名<code>ConsulConfigAutoConfiguration.CONFIG_WATCH_TASK_SCHEDULER_NAME</code>不变。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-consul-config-format"><a class="anchor" href="#spring-cloud-consul-config-format"></a> <a class="link" href="#spring-cloud-consul-config-format">9.4.4。YAML或具有配置的属性</a></h4>
<div class="paragraph">
<p>与单个键/值对相反，以YAML或“属性”格式存储属性的对象可能更方便。设置<code>spring.cloud.consul.config.format</code>财产<code>YAML</code>要么<code>PROPERTIES</code> 。例如使用YAML：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      config:
        format: YAML</pre>
</div>
</div>
<div class="paragraph">
<p>必须在适当的位置设置YAML <code>data</code>领事的关键。使用上面的默认值，键看起来像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>config/testApp,dev/data
config/testApp/data
config/application,dev/data
config/application/data</pre>
</div>
</div>
<div class="paragraph">
<p>您可以将YAML文档存储在上面列出的任何键中。</p>
</div>
<div class="paragraph">
<p>您可以使用更改数据密钥<code>spring.cloud.consul.config.data-key</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-consul-config-git2consul"><a class="anchor" href="#spring-cloud-consul-config-git2consul"></a> <a class="link" href="#spring-cloud-consul-config-git2consul">9.4.5。 git2consul与配置</a></h4>
<div class="paragraph">
<p>git2consul是一个Consul社区项目，该项目将git存储库中的文件加载到Consul的各个键中。默认情况下，键的名称是文件的名称。YAML和属性文件受以下文件扩展名的支持<code>.yml</code>和<code>.properties</code>分别。设置<code>spring.cloud.consul.config.format</code>财产<code>FILES</code> 。例如：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre>spring:
  cloud:
    consul:
      config:
        format: FILES</pre>
</div>
</div>
<div class="paragraph">
<p>给定以下键<code>/config</code> ， <code>development</code>配置文件和应用程序名称<code>foo</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.gitignore
application.yml
bar.properties
foo-development.properties
foo-production.yml
foo.properties
master.ref</pre>
</div>
</div>
<div class="paragraph">
<p>将创建以下属性源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>config/foo-development.properties
config/foo.properties
config/application.yml</pre>
</div>
</div>
<div class="paragraph">
<p>每个键的值必须是格式正确的YAML或属性文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-consul-failfast"><a class="anchor" href="#spring-cloud-consul-failfast"></a> <a class="link" href="#spring-cloud-consul-failfast">9.4.6。快速失败</a></h4>
<div class="paragraph">
<p>如果领事不可用于配置，则在某些情况下（例如本地开发或某些测试方案）可能会很方便而不会失败。设置<code>spring.cloud.consul.config.failFast=false</code>在<code>bootstrap.yml</code>将导致配置模块记录警告而不是引发异常。这将允许应用程序继续正常启动。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-retry"><a class="anchor" href="#spring-cloud-consul-retry"></a> <a class="link" href="#spring-cloud-consul-retry">9.5。领事重试</a></h3>
<div class="paragraph">
<p>如果您希望应用启动时领事代理有时不可用，则可以要求它在失败后继续尝试。您需要添加<code>spring-retry</code>和<code>spring-boot-starter-aop</code>到你的classpath。默认行为是重试6次，初始回退间隔为1000ms，随后的回退的指数乘数为1.1。您可以使用以下命令配置这些属性（和其他属性） <code>spring.cloud.consul.retry.*</code>配置属性。这适用于Spring Cloud Consul Config和Discovery注册。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">要完全控制重试，请添加一个<code>@Bean</code>类型的<code>RetryOperationsInterceptor</code> ID为“ consulRetryInterceptor”。春季重试有一个<code>RetryInterceptorBuilder</code>这样就很容易创建一个。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-bus"><a class="anchor" href="#spring-cloud-consul-bus"></a> <a class="link" href="#spring-cloud-consul-bus">9.6。带领事的Spring Cloud Bus</a></h3>
<div class="sect3">
<h4 id="how-to-activate-3"><a class="anchor" href="#how-to-activate-3"></a> <a class="link" href="#how-to-activate-3">9.6.1。如何激活</a></h4>
<div class="paragraph">
<p>要开始使用Consul Bus，请使用带有启动器的组<code>org.springframework.cloud</code>和工件ID <code>spring-cloud-starter-consul-bus</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="https://cloud.spring.io/spring-cloud-bus/">Spring Cloud Bus</a>文档以获取可用的执行器端点和如何发送自定义消息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-hystrix"><a class="anchor" href="#spring-cloud-consul-hystrix"></a> <a class="link" href="#spring-cloud-consul-hystrix">9.7。Hystrix断路器</a></h3>
<div class="paragraph">
<p>通过在项目pom.xml中包含此启动器，应用程序可以使用Spring Cloud Netflix项目提供的Hystrix断路器： <code>spring-cloud-starter-hystrix</code> 。Hystrix不依赖Netflix Discovery Client。的<code>@EnableHystrix</code>注释应放在配置类（通常是主类）上。然后可以用以下方法注释方法<code>@HystrixCommand</code>由断路器保护。有关更多详细信息，请参见<a href="https://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients">文档</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-consul-turbine"><a class="anchor" href="#spring-cloud-consul-turbine"></a> <a class="link" href="#spring-cloud-consul-turbine">9.8。Hystrix指标通过Turbine和Consul进行聚合</a></h3>
<div class="paragraph">
<p>Turbine（由Spring Cloud Netflix项目提供）汇总了多个实例Hystrix指标流，因此仪表板可以显示汇总视图。涡轮使用<code>DiscoveryClient</code>查找相关实例的接口。要将Turbine与Spring Cloud Consul一起使用，请以类似于以下示例的方式配置Turbine应用程序：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-netflix-turbine</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，Turbine依赖项不是启动器。涡轮启动器包括对Netflix Eureka的支持。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre>spring.application.name: turbine
applications: consulhystrixclient
turbine:
  aggregator:
    clusterConfig: ${applications}
  appConfig: ${applications}</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>clusterConfig</code>和<code>appConfig</code>部分必须匹配，因此将以逗号分隔的服务ID列表放入单独的配置属性中很有用。</p>
</div>
<div class="listingblock">
<div class="title">Turbine.java</div>
<div class="content">
<pre>@EnableTurbine
@SpringBootApplication
public class Turbine {
    public static void main(String[] args) {
        SpringApplication.run(DemoturbinecommonsApplication.class, args);
    }
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-6"><a class="anchor" href="#configuration-properties-6"></a> <a class="link" href="#configuration-properties-6">9.9。配置属性</a></h3>
<div class="paragraph">
<p>要查看与Consul相关的所有配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-zookeeper"><a class="anchor" href="#spring-cloud-zookeeper"></a> <a class="link" href="#spring-cloud-zookeeper">10。春季云动物园管理员</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>该项目通过自动配置以及绑定到Spring Environment和其他Spring编程模型习惯用法，为Spring Boot应用程序提供Zookeeper集成。通过一些注释，您可以快速启用和配置应用程序内部的通用模式，并使用基于Zookeeper的组件构建大型分布式系统。提供的模式包括服务发现和配置。与Spring Cloud的集成Netflix提供了智能路由（Zuul），客户端负载平衡（Ribbon）和断路器（Hystrix）。</p>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-install"><a class="anchor" href="#spring-cloud-zookeeper-install"></a> <a class="link" href="#spring-cloud-zookeeper-install">10.1。安装Zookeeper</a></h3>
<div class="paragraph">
<p>请参阅<a href="https://zookeeper.apache.org/doc/current/zookeeperStarted.html">安装文档</a>以获取有关如何安装Zookeeper的说明。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Zookeeper在后台使用Apache Curator。尽管Zookeeper开发团队仍将Zookeeper 3.5.x视为“测试版”，但现实是许多用户在生产中使用了它。但是，Zookeeper 3.4.x也用于生产中。在Apache Curator 4.0之前，两个版本的Apache Curator支持两种版本的Zookeeper。从Curator 4.0开始，通过相同的Curator库支持两个版本的Zookeeper。</p>
</div>
<div class="paragraph">
<p>如果要与版本3.4集成，则需要更改随附的Zookeeper依赖项<code>curator</code> ， 因此<code>spring-cloud-zookeeper</code> 。为此，只需排除该依赖性并添加如下所示的3.4.x版本。</p>
</div>
<div class="listingblock">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zookeeper-all</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.apache.zookeeper</groupId>
    <artifactId>zookeeper</artifactId>
    <version>3.4.12</version>
    <exclusions>
        <exclusion>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
        </exclusion>
    </exclusions>
</dependency></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile('org.springframework.cloud:spring-cloud-starter-zookeeper-all') {
  exclude group: 'org.apache.zookeeper', module: 'zookeeper'
}
compile('org.apache.zookeeper:zookeeper:3.4.12') {
  exclude group: 'org.slf4j', module: 'slf4j-log4j12'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-discovery"><a class="anchor" href="#spring-cloud-zookeeper-discovery"></a> <a class="link" href="#spring-cloud-zookeeper-discovery">10.2。Zookeeper的服务发现</a></h3>
<div class="paragraph">
<p>服务发现是基于微服务的体系结构的关键原则之一。尝试手动配置每个客户端或某种形式的约定可能很困难并且很脆弱。<a href="https://curator.apache.org">Curator</a> （Zookeeper的Java库）通过<a href="https://curator.apache.org/curator-x-discovery/">Service Discovery Extension</a>提供服务发现。Spring Cloud Zookeeper使用此扩展进行服务注册和发现。</p>
</div>
<div class="sect3">
<h4 id="activating"><a class="anchor" href="#activating"></a> <a class="link" href="#activating">10.2.1。激活</a></h4>
<div class="paragraph">
<p>包括对<code>org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</code>启用自动配置以设置Spring Cloud Zookeeper Discovery。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于网络功能，您仍然需要包括<code>org.springframework.boot:spring-boot-starter-web</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">当使用Zookeeper 3.4版时，您需要按<a href="#spring-cloud-zookeeper-install">此处</a>所述更改包含依赖项的方式。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="registering-with-zookeeper"><a class="anchor" href="#registering-with-zookeeper"></a> <a class="link" href="#registering-with-zookeeper">10.2.2。向Zookeeper注册</a></h4>
<div class="paragraph">
<p>客户端向Zookeeper注册时，它会提供有关其自身的元数据（例如主机和端口，ID和名称）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了Zookeeper客户端：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello world";
    }

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的示例是一个普通的Spring Boot应用程序。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果Zookeeper位于除<code>localhost:2181</code> ，配置必须提供服务器的位置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  cloud:
    zookeeper:
      connect-string: localhost:2181</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">如果使用<a href="#spring-cloud-zookeeper-config">Spring Cloud Zookeeper Config</a> ，则上一个示例中显示的值必须位于<code>bootstrap.yml</code>代替<code>application.yml</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认服务名称，实例ID和端口（取自<code>Environment</code> ） 是<code>${spring.application.name}</code> ，Spring Context ID和<code>${server.port}</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>有<code>spring-cloud-starter-zookeeper-discovery</code>在类路径上的，使该应用程序同时成为Zookeeper的“服务”（即它自己注册）和“客户端”（即，它可以查询Zookeeper来定位其他服务）。</p>
</div>
<div class="paragraph">
<p>如果要禁用Zookeeper Discovery Client，可以设置<code>spring.cloud.zookeeper.discovery.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-discoveryclient-2"><a class="anchor" href="#using-the-discoveryclient-2"></a> <a class="link" href="#using-the-discoveryclient-2">10.2.3。使用DiscoveryClient</a></h4>
<div class="paragraph">
<p>Spring Cloud支持<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign">Feign</a> （REST客户端构建器）， <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/ascii">Spring <code>RestTemplate</code></a>和<a href="https://cloud.spring.io/spring-cloud-commons/reference/html/#loadbalanced-webclient">Spring WebFlux</a> ，使用逻辑服务名称而不是物理URL。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>org.springframework.cloud.client.discovery.DiscoveryClient</code> ，它为发现客户端提供了一个不特定于Netflix的简单API，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List<ServiceInstance> list = discoveryClient.getInstances("STORES");
    if (list != null && list.size() > 0 ) {
        return list.get(0).getUri().toString();
    }
    return null;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-netflix"><a class="anchor" href="#spring-cloud-zookeeper-netflix"></a> <a class="link" href="#spring-cloud-zookeeper-netflix">10.3。将Spring Cloud Zookeeper与Spring Cloud Netflix组件一起使用</a></h3>
<div class="paragraph">
<p>Spring Cloud Netflix提供有用的工具，无论使用哪种工具<code>DiscoveryClient</code>您使用的实现。Feign，Turbine，Ribbon和Zuul均与Spring Cloud Zookeeper一起使用。</p>
</div>
<div class="sect3">
<h4 id="ribbon-with-zookeeper"><a class="anchor" href="#ribbon-with-zookeeper"></a> <a class="link" href="#ribbon-with-zookeeper">10.3.1。与Zookeeper的功能区</a></h4>
<div class="paragraph">
<p>Spring Cloud Zookeeper提供了Ribbon的实现<code>ServerList</code> 。当您使用<code>spring-cloud-starter-zookeeper-discovery</code> ，功能区已自动配置为使用<code>ZookeeperServerList</code>默认。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-service-registry"><a class="anchor" href="#spring-cloud-zookeeper-service-registry"></a> <a class="link" href="#spring-cloud-zookeeper-service-registry">10.4。Spring Cloud Zookeeper和服务注册表</a></h3>
<div class="paragraph">
<p>Spring Cloud Zookeeper实现了<code>ServiceRegistry</code>接口，让开发人员以编程方式注册任意服务。</p>
</div>
<div class="paragraph">
<p>的<code>ServiceInstanceRegistration</code>课程提供<code>builder()</code>创建一个方法<code>Registration</code>可以使用的对象<code>ServiceRegistry</code> ，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private ZookeeperServiceRegistry serviceRegistry;

public void registerThings() {
    ZookeeperRegistration registration = ServiceInstanceRegistration.builder()
            .defaultUriSpec()
            .address("anyUrl")
            .port(10)
            .name("/a/b/c/d/anotherservice")
            .build();
    this.serviceRegistry.register(registration);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="instance-status"><a class="anchor" href="#instance-status"></a> <a class="link" href="#instance-status">10.4.1。实例状态</a></h4>
<div class="paragraph">
<p>Netflix Eureka支持具有以下实例<code>OUT_OF_SERVICE</code>在服务器上注册。这些实例不作为活动服务实例返回。这对于诸如蓝色/绿色部署之类的行为很有用。（请注意，“ Curator服务发现”食谱不支持此行为。）利用灵活的有效负载，Spring Cloud Zookeeper得以实现<code>OUT_OF_SERVICE</code>通过更新一些特定的元数据，然后在功能区中对该元数据进行过滤<code>ZookeeperServerList</code> 。的<code>ZookeeperServerList</code>过滤掉所有不相等的非空实例状态<code>UP</code> 。如果实例状态字段为空，则认为是<code>UP</code>向后兼容。要更改实例的状态，请<code>POST</code>与<code>OUT_OF_SERVICE</code>到<code>ServiceRegistry</code>实例状态执行器端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">$ http POST http://localhost:8081/service-registry status=OUT_OF_SERVICE</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的示例使用<code>http</code>来自<a href="https://httpie.org" class="bare">httpie.org的</a>命令。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-dependencies"><a class="anchor" href="#spring-cloud-zookeeper-dependencies"></a> <a class="link" href="#spring-cloud-zookeeper-dependencies">10.5。Zookeeper依赖关系</a></h3>
<div class="paragraph">
<p>以下主题介绍了如何使用Spring Cloud Zookeeper依赖项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-zookeeper-dependencies-using">使用Zookeeper依赖关系</a></p>
</li>
<li>
<p><a href="#spring-cloud-zookeeper-dependencies-activating">激活Zookeeper依赖关系</a></p>
</li>
<li>
<p><a href="#spring-cloud-zookeeper-dependencies-setting-up">设置Zookeeper依赖关系</a></p>
</li>
<li>
<p><a href="#spring-cloud-zookeeper-dependencies-configuring">配置Spring Cloud Zookeeper依赖关系</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-zookeeper-dependencies-using"><a class="anchor" href="#spring-cloud-zookeeper-dependencies-using"></a> <a class="link" href="#spring-cloud-zookeeper-dependencies-using">10.5.1。使用Zookeeper依赖关系</a></h4>
<div class="paragraph">
<p>Spring Cloud Zookeeper使您可以将应用程序的依赖项作为属性提供。作为依赖，你可以明白，在动物园管理员注册其他应用程序，哪些是你想通过调用<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign">假死</a> （REST客户端生成器）， <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/ascii">春<code>RestTemplate</code></a>和<a href="https://cloud.spring.io/spring-cloud-commons/reference/html/#loadbalanced-webclient">Spring WebFlux</a> 。</p>
</div>
<div class="paragraph">
<p>您还可以使用Zookeeper依赖关系观察器功能来控制和监视依赖关系的状态。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-zookeeper-dependencies-activating"><a class="anchor" href="#spring-cloud-zookeeper-dependencies-activating"></a> <a class="link" href="#spring-cloud-zookeeper-dependencies-activating">10.5.2。激活Zookeeper依赖关系</a></h4>
<div class="paragraph">
<p>包括对<code>org.springframework.cloud:spring-cloud-starter-zookeeper-discovery</code>启用自动配置以设置Spring Cloud Zookeeper依赖关系。即使您在属性中提供了依赖关系，也可以关闭依赖关系。为此，请设置<code>spring.cloud.zookeeper.dependency.enabled</code>属性为false（默认为<code>true</code> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-zookeeper-dependencies-setting-up"><a class="anchor" href="#spring-cloud-zookeeper-dependencies-setting-up"></a> <a class="link" href="#spring-cloud-zookeeper-dependencies-setting-up">10.5.3。设置Zookeeper依赖关系</a></h4>
<div class="paragraph">
<p>考虑下面的依赖关系表示示例：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring.application.name: yourServiceName
spring.cloud.zookeeper:
  dependencies:
    newsletter:
      path: /path/where/newsletter/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.newsletter.$version+json
      version: v1
      headers:
        header1:
            - value1
        header2:
            - value2
      required: false
      stubs: org.springframework:foo:stubs
    mailing:
      path: /path/where/mailing/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.mailing.$version+json
      version: v1
      required: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来的几节将逐一介绍依赖关系的每个部分。根属性名称是<code>spring.cloud.zookeeper.dependencies</code> 。</p>
</div>
<div class="sect4">
<h5 id="spring-cloud-zookeeper-dependencies-setting-up-aliases"><a class="anchor" href="#spring-cloud-zookeeper-dependencies-setting-up-aliases"></a> <a class="link" href="#spring-cloud-zookeeper-dependencies-setting-up-aliases">别名</a></h5>
<div class="paragraph">
<p>在root属性下，您必须将每个依赖项表示为别名。这是由于Ribbon的约束所致，它要求将应用程序ID放在URL中。因此，您无法通过任何复杂的路径，例如<code>/myApp/myRoute/name</code> ）。别名是您使用的名称，而不是<code>serviceId</code>对于<code>DiscoveryClient</code> ， <code>Feign</code> ， 要么<code>RestTemplate</code> 。</p>
</div>
<div class="paragraph">
<p>在前面的示例中，别名为<code>newsletter</code>和<code>mailing</code> 。以下示例显示了伪装用法与<code>newsletter</code>别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@FeignClient("newsletter")
public interface NewsletterService {
        @RequestMapping(method = RequestMethod.GET, value = "/newsletter")
        String getNewsletters();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="path"><a class="anchor" href="#path"></a> <a class="link" href="#path">路径</a></h5>
<div class="paragraph">
<p>路径由<code>path</code> YAML属性，是在Zookeeper下注册依赖项的路径。如上<a href="#spring-cloud-zookeeper-dependencies-setting-up-aliases">一节所述</a> ，Ribbon在URL上运行。结果，该路径不符合其要求。这就是为什么Spring Cloud Zookeeper将别名映射到正确的路径。</p>
</div>
</div>
<div class="sect4">
<h5 id="load-balancer-type"><a class="anchor" href="#load-balancer-type"></a> <a class="link" href="#load-balancer-type">负载均衡器类型</a></h5>
<div class="paragraph">
<p>负载均衡器的类型表示为<code>loadBalancerType</code> YAML属性。</p>
</div>
<div class="paragraph">
<p>如果您知道在调用此特定依赖项时必须应用哪种负载平衡策略，则可以在YAML文件中提供它，并自动应用它。您可以选择以下负载平衡策略之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>STICKY：选择后，将始终调用该实例。</p>
</li>
<li>
<p>随机：随机选择一个实例。</p>
</li>
<li>
<p>ROUND_ROBIN：反复遍历实例。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="content-type-template-and-version"><a class="anchor" href="#content-type-template-and-version"></a> <a class="link" href="#content-type-template-and-version"><code>Content-Type</code>模板和版本</a></h5>
<div class="paragraph">
<p>的<code>Content-Type</code>模板和版本由<code>contentTypeTemplate</code>和<code>version</code> YAML属性。</p>
</div>
<div class="paragraph">
<p>如果您在<code>Content-Type</code>标头中，您不想将此标头添加到每个请求中。另外，如果您要调用API的新版本，则不想在代码中漫游以提高API版本。因此，您可以提供<code>contentTypeTemplate</code>特别的<code>$version</code>占位符。该占位符将由<code>version</code> YAML属性。考虑以下示例<code>contentTypeTemplate</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>application/vnd.newsletter.$version+json</pre>
</div>
</div>
<div class="paragraph">
<p>进一步考虑以下<code>version</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>v1</pre>
</div>
</div>
<div class="paragraph">
<p>的结合<code>contentTypeTemplate</code>和版本导致创建一个<code>Content-Type</code>每个请求的标头，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>application/vnd.newsletter.v1+json</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="default-headers"><a class="anchor" href="#default-headers"></a> <a class="link" href="#default-headers">默认标题</a></h5>
<div class="paragraph">
<p>默认标题由<code>headers</code>在YAML中映射。</p>
</div>
<div class="paragraph">
<p>有时，对依赖项的每次调用都需要设置一些默认头。要在代码中不要这样做，可以在YAML文件中进行设置，如以下示例所示<code>headers</code>部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">headers:
    Accept:
        - text/html
        - application/xhtml+xml
    Cache-Control:
        - no-cache</code></pre>
</div>
</div>
<div class="paragraph">
<p>那<code>headers</code>部分导致添加<code>Accept</code>和<code>Cache-Control</code>标头，其中包含HTTP请求中相应的值列表。</p>
</div>
</div>
<div class="sect4">
<h5 id="required-dependencies"><a class="anchor" href="#required-dependencies"></a> <a class="link" href="#required-dependencies">必需的依赖关系</a></h5>
<div class="paragraph">
<p>所需的依赖项表示为<code>required</code> YAML中的属性。</p>
</div>
<div class="paragraph">
<p>如果在应用程序启动时需要建立依赖关系之一，则可以设置<code>required: true</code> YAML文件中的属性。</p>
</div>
<div class="paragraph">
<p>如果您的应用程序在启动期间无法本地化所需的依赖项，则会引发异常，并且Spring Context无法设置。换句话说，如果所需的依赖项未在Zookeeper中注册，则您的应用程序将无法启动。</p>
</div>
<div class="paragraph">
<p>您可以<a href="#spring-cloud-zookeeper-dependency-watcher-presence-checker">在本文档后面</a>阅读更多有关Spring Cloud Zookeeper在线状态检查器的<a href="#spring-cloud-zookeeper-dependency-watcher-presence-checker">信息</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="stubs"><a class="anchor" href="#stubs"></a> <a class="link" href="#stubs">存根</a></h5>
<div class="paragraph">
<p>您可以提供一个冒号分隔的包含依赖项存根的JAR路径，如以下示例所示：</p>
</div>
<div class="paragraph">
<p><code>stubs: org.springframework:myApp:stubs</code></p>
</div>
<div class="paragraph">
<p>哪里：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework</code>是个<code>groupId</code> 。</p>
</li>
<li>
<p><code>myApp</code>是个<code>artifactId</code> 。</p>
</li>
<li>
<p><code>stubs</code>是分类器。（注意<code>stubs</code>是默认值。）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因为<code>stubs</code>是默认分类器，前面的示例等于以下示例：</p>
</div>
<div class="paragraph">
<p><code>stubs: org.springframework:myApp</code></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-zookeeper-dependencies-configuring"><a class="anchor" href="#spring-cloud-zookeeper-dependencies-configuring"></a> <a class="link" href="#spring-cloud-zookeeper-dependencies-configuring">10.5.4。配置Spring Cloud Zookeeper依赖关系</a></h4>
<div class="paragraph">
<p>您可以设置以下属性来启用或禁用部分Zookeeper依赖关系功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.zookeeper.dependencies</code>注意：如果不设置此属性，则不能使用Zookeeper依赖关系。</p>
</li>
<li>
<p><code>spring.cloud.zookeeper.dependency.ribbon.enabled</code> （默认情况下启用）：功能区需要显式全局配置或特定的依赖项配置。通过启用此属性，可以实现运行时负载平衡策略解析，并且您可以使用<code>loadBalancerType</code> Zookeeper依赖关系部分。需要此属性的配置具有以下实现<code>LoadBalancerClient</code>委托给<code>ILoadBalancer</code>在下一个项目符号中介绍。</p>
</li>
<li>
<p><code>spring.cloud.zookeeper.dependency.ribbon.loadbalancer</code> （默认情况下启用）：由于有了此属性，自定义<code>ILoadBalancer</code>知道传递给Ribbon的URI部分实际上可能是必须在Zookeeper中解析为正确路径的别名。没有此属性，您将无法在嵌套路径下注册应用程序。</p>
</li>
<li>
<p><code>spring.cloud.zookeeper.dependency.headers.enabled</code> （默认启用）：此属性注册一个<code>RibbonClient</code>如Dependency配置所示，它会自动在其标题后附加适当的标题和内容类型。没有此设置，这两个参数将不起作用。</p>
</li>
<li>
<p><code>spring.cloud.zookeeper.dependency.resttemplate.enabled</code> （默认情况下启用）：启用后，此属性会修改<code>@LoadBalanced</code> -带注释<code>RestTemplate</code>这样就可以传递标头和内容类型以及在依赖项配置中设置的版本。没有此设置，这两个参数将不起作用。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-dependency-watcher"><a class="anchor" href="#spring-cloud-zookeeper-dependency-watcher"></a> <a class="link" href="#spring-cloud-zookeeper-dependency-watcher">10.6。Spring Cloud Zookeeper依赖性观察程序</a></h3>
<div class="paragraph">
<p>Dependency Watcher机制使您可以将侦听器注册到您的依赖项。该功能实际上是<code>Observator</code>图案。当依赖项发生变化时，其状态（变为UP或DOWN）可以应用一些自定义逻辑。</p>
</div>
<div class="sect3">
<h4 id="activating-2"><a class="anchor" href="#activating-2"></a> <a class="link" href="#activating-2">10.6.1。激活</a></h4>
<div class="paragraph">
<p>需要启用Spring Cloud Zookeeper依赖关系功能，才能使用Dependency Watcher机制。</p>
</div>
</div>
<div class="sect3">
<h4 id="registering-a-listener"><a class="anchor" href="#registering-a-listener"></a> <a class="link" href="#registering-a-listener">10.6.2。注册听众</a></h4>
<div class="paragraph">
<p>要注册一个侦听器，您必须实现一个名为<code>org.springframework.cloud.zookeeper.discovery.watcher.DependencyWatcherListener</code>并将其注册为bean。该接口为您提供了一种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void stateChanged(String dependencyName, DependencyState newState);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您要注册特定依赖项的侦听器，则<code>dependencyName</code>将是您具体实施的区分因素。 <code>newState</code>向您提供有关您的依赖关系是否已更改为<code>CONNECTED</code>要么<code>DISCONNECTED</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-zookeeper-dependency-watcher-presence-checker"><a class="anchor" href="#spring-cloud-zookeeper-dependency-watcher-presence-checker"></a> <a class="link" href="#spring-cloud-zookeeper-dependency-watcher-presence-checker">10.6.3。使用状态检查器</a></h4>
<div class="paragraph">
<p>与“依赖关系观察器”绑定的是称为“状态检查器”的功能。它使您可以在应用程序启动时提供自定义行为，以根据依赖项的状态做出反应。</p>
</div>
<div class="paragraph">
<p>抽象的默认实现<code>org.springframework.cloud.zookeeper.discovery.watcher.presence.DependencyPresenceOnStartupVerifier</code>类是<code>org.springframework.cloud.zookeeper.discovery.watcher.presence.DefaultDependencyPresenceOnStartupVerifier</code> ，其工作方式如下。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果依赖性标记为我们<code>required</code>并且不在Zookeeper中，当您的应用程序启动时，它会引发异常并关闭。</p>
</li>
<li>
<p>如果不依赖<code>required</code> ， <code>org.springframework.cloud.zookeeper.discovery.watcher.presence.LogMissingDependencyChecker</code>记录缺少依赖项<code>WARN</code>水平。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因为<code>DefaultDependencyPresenceOnStartupVerifier</code>仅当没有类型的bean时才注册<code>DependencyPresenceOnStartupVerifier</code> ，此功能可以被覆盖。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-zookeeper-config"><a class="anchor" href="#spring-cloud-zookeeper-config"></a> <a class="link" href="#spring-cloud-zookeeper-config">10.7。Zookeeper的分布式配置</a></h3>
<div class="paragraph">
<p>Zookeeper提供了一个<a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace">分层的名称空间</a> ，该<a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace">名称空间</a>使客户端可以存储任意数据，例如配置数据。Spring Cloud Zookeeper Config是<a href="https://github.com/spring-cloud/spring-cloud-config">Config Server和Client</a>的替代方案。在特殊的“引导”阶段将配置加载到Spring环境中。配置存储在<code>/config</code>默认情况下命名空间。多<code>PropertySource</code>根据应用程序名称和活动配置文件创建实例，以模拟解析属性的Spring Cloud Config顺序。例如，名称为<code>testApp</code>并与<code>dev</code>概要文件具有为其创建的以下属性源：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>config/testApp,dev</code></p>
</li>
<li>
<p><code>config/testApp</code></p>
</li>
<li>
<p><code>config/application,dev</code></p>
</li>
<li>
<p><code>config/application</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最具体的属性来源在顶部，最不具体的属性在底部。中的属性<code>config/application</code>名称空间适用于所有使用zookeeper进行配置的应用程序。中的属性<code>config/testApp</code>名称空间仅适用于名为的服务实例<code>testApp</code> 。</p>
</div>
<div class="paragraph">
<p>当前在启动应用程序时读取配置。发送HTTP <code>POST</code>请求<code>/refresh</code>导致重新加载配置。当前未实现监视配置名称空间（Zookeeper支持）。</p>
</div>
<div class="sect3">
<h4 id="activating-3"><a class="anchor" href="#activating-3"></a> <a class="link" href="#activating-3">10.7.1。激活</a></h4>
<div class="paragraph">
<p>包括对<code>org.springframework.cloud:spring-cloud-starter-zookeeper-config</code>启用自动配置以设置Spring Cloud Zookeeper Config。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="警告"></i>
</td>
<td class="content">当使用Zookeeper 3.4版时，您需要按<a href="#spring-cloud-zookeeper-install">此处</a>所述更改包含依赖项的方式。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="customizing-2"><a class="anchor" href="#customizing-2"></a> <a class="link" href="#customizing-2">10.7.2。客制化</a></h4>
<div class="paragraph">
<p>可以通过设置以下属性来自定义Zookeeper Config：</p>
</div>
<div class="listingblock">
<div class="title">bootstrap.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  cloud:
    zookeeper:
      config:
        enabled: true
        root: configuration
        defaultContext: apps
        profileSeparator: '::'</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code> ：将此值设置为<code>false</code>禁用Zookeeper Config。</p>
</li>
<li>
<p><code>root</code> ：设置配置名称。</p>
</li>
<li>
<p><code>defaultContext</code> ：设置所有应用程序使用的名称。</p>
</li>
<li>
<p><code>profileSeparator</code> ：设置分隔符的值，该分隔符用于在带有概要文件的属性源中分隔概要文件名称。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="access-control-lists-acls"><a class="anchor" href="#access-control-lists-acls"></a> <a class="link" href="#access-control-lists-acls">10.7.3。访问控制列表（ACL）</a></h4>
<div class="paragraph">
<p>您可以通过以下方式添加Zookeeper ACL的身份验证信息： <code>addAuthInfo</code>方法<code>CuratorFramework</code>豆。实现此目的的一种方法是提供自己的<code>CuratorFramework</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@BoostrapConfiguration
public class CustomCuratorFrameworkConfig {

  @Bean
  public CuratorFramework curatorFramework() {
    CuratorFramework curator = new CuratorFramework();
    curator.addAuthInfo("digest", "user:password".getBytes());
    return curator;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>咨询<a href="https://github.com/spring-cloud/spring-cloud-zookeeper/blob/master/spring-cloud-zookeeper-core/src/main/java/org/springframework/cloud/zookeeper/ZookeeperAutoConfiguration.java">ZookeeperAutoConfiguration类</a>以了解如何<code>CuratorFramework</code> bean的默认配置。</p>
</div>
<div class="paragraph">
<p>或者，您可以从依赖现有类的类中添加凭据<code>CuratorFramework</code> bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@BoostrapConfiguration
public class DefaultCuratorFrameworkConfig {

  public ZookeeperConfig(CuratorFramework curator) {
    curator.addAuthInfo("digest", "user:password".getBytes());
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此bean的创建必须在boostrapping阶段进行。您可以使用以下注释来注册要在此阶段运行的配置类： <code>@BootstrapConfiguration</code>并将它们包含在以逗号分隔的列表中，并将其设置为<code>org.springframework.cloud.bootstrap.BootstrapConfiguration</code>物业<code>resources/META-INF/spring.factories</code>文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">资源/META-INF/spring.factories</div>
<div class="content">
<pre>org.springframework.cloud.bootstrap.BootstrapConfiguration=\
my.project.CustomCuratorFrameworkConfig,\
my.project.DefaultCuratorFrameworkConfig</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-boot-cloud-cli"><a class="anchor" href="#spring-boot-cloud-cli"></a> <a class="link" href="#spring-boot-cloud-cli">11。Spring Boot Cloud CLI</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot CLI为<a href="https://github.com/spring-cloud">Spring Cloud</a>提供了<a href="https://projects.spring.io/spring-boot">Spring Boot</a>命令行功能。您可以编写Groovy脚本来运行Spring Cloud组件应用程序（例如<code>@EnableEurekaServer</code> ）。您还可以轻松地进行诸如加密和解密之类的操作，以通过秘密配置值支持Spring Cloud Config客户端。使用启动器CLI，您可以方便地从命令行一次启动Eureka，Zipkin，Config Server等服务（在开发时非常有用）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a href="https://github.com/spring-cloud/spring-cloud-cli/tree/master/docs/src/main/asciidoc">github</a>的项目中找到源代码和问题跟踪程序。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="installation"><a class="anchor" href="#installation"></a> <a class="link" href="#installation">11.1。安装</a></h3>
<div class="paragraph">
<p>要安装，请确保您具有<a href="https://github.com/spring-projects/spring-boot">Spring Boot CLI</a> （2.0.0或更高版本）：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ spring version
Spring CLI v2.2.0.BUILD-SNAPSHOT</pre>
</div>
</div>
<div class="paragraph">
<p>例如，对于SDKMan用户</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ sdk install springboot 2.2.0.BUILD-SNAPSHOT
$ sdk use springboot 2.2.0.BUILD-SNAPSHOT</code></pre>
</div>
</div>
<div class="paragraph">
<p>并安装Spring Cloud插件</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn install
$ spring install org.springframework.cloud:spring-cloud-cli:2.2.0.BUILD-SNAPSHOT</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<strong>先决条件：</strong>要使用加密和解密功能，您需要在JVM中安装完整功能的JCE（默认情况下不存在）。您可以从Oracle下载“ Java密码学扩展（JCE）无限强度管辖权策略文件”，并按照安装说明进行操作（用您下载的文件替换JRE lib / security目录中的2个策略文件）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="running-spring-cloud-services-in-development"><a class="anchor" href="#running-spring-cloud-services-in-development"></a> <a class="link" href="#running-spring-cloud-services-in-development">11.2。在开发中运行Spring Cloud Services</a></h3>
<div class="paragraph">
<p>Launcher CLI可用于从命令行运行常见服务，例如Eureka，Config Server等。列出您可以做的服务<code>spring cloud --list</code> ，并仅启动默认服务集<code>spring cloud</code> 。要选择要部署的服务，只需在命令行上列出它们，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring cloud eureka configserver h2 kafka stubrunner zipkin</pre>
</div>
</div>
<div class="paragraph">
<p>受支持的可部署项目摘要：</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务</th>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">地址</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">尤里卡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尤里卡服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:8761" class="bare">本地主机：8761</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eureka服务器，用于服务注册和发现。默认情况下，所有其他服务都显示在其目录中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:8888" class="bare">本地主机：8888</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Cloud Config Server在“本地”配置文件中运行，并从本地目录./launcher提供配置</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">H2数据库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:9095" class="bare">本地主机：9095</a> （控制台），jdbc：h2：tcp：//本地主机：9096 / {data}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">关系数据库服务。使用文件路径<code>{data}</code> （例如<code>./target/test</code> ），当您连接时。请记住，您可以添加<code>;MODE=MYSQL</code>要么<code>;MODE=POSTGRESQL</code>连接到其他服务器类型的兼容性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">卡夫卡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">卡夫卡经纪人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:9091" class="bare">本地主机：9091</a> （执行器端点），本地主机：9092</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hystrix仪表板</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hystrix仪表板</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:7979" class="bare">本地主机：7979</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何声明Hystrix断路器的Spring Cloud应用程序都会在以下方面发布指标<code>/hystrix.stream</code> 。在仪表板上键入该地址，以可视化所有指标，</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据流</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据流服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:9393" class="bare">本地主机：9393</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带有/ admin-ui的UI的Spring Cloud Dataflow服务器。将Dataflow Shell连接到根路径上的目标。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">邮编</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zipkin服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:9411" class="bare">本地主机：9411</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有UI的Zipkin Server，用于可视化跟踪。将跨区数据存储在内存中，并通过JSON数据的HTTP POST接受它们。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根跑步靴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:8750" class="bare">本地主机：8750</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下载WireMock存根，启动WireMock并使用存储的存根为启动的服务器提供数据。通过<code>stubrunner.ids</code>传递存根坐标，然后转到<code><a href="http://localhost:8750/stubs" class="bare">localhost:8750/stubs</a></code> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用具有相同名称的本地YAML文件（在当前工作目录或名为“ config”的子目录中或在<code>~/.spring-cloud</code> ）。例如<code>configserver.yml</code>您可能想要执行以下操作以找到后端的本地git存储库：</p>
</div>
<div class="listingblock">
<div class="title">configserver.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  profiles:
    active: git
  cloud:
    config:
      server:
        git:
          uri: file://${user.home}/dev/demo/config-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，在Stub Runner应用中，您可以从本地获取Stub <code>.m2</code>以以下方式。</p>
</div>
<div class="listingblock">
<div class="title">stubrunner.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner:
  workOffline: true
  ids:
    - com.example:beer-api-producer:+:9876</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="adding-additional-applications"><a class="anchor" href="#adding-additional-applications"></a> <a class="link" href="#adding-additional-applications">11.2.1。添加其他应用</a></h4>
<div class="paragraph">
<p>可以将其他应用程序添加到<code>./config/cloud.yml</code> （不<code>./config.yml</code>因为它将替换默认值），例如</p>
</div>
<div class="listingblock">
<div class="title">配置/ cloud.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    launcher:
      deployables:
        source:
          coordinates: maven://com.example:source:0.0.1-SNAPSHOT
          port: 7000
        sink:
          coordinates: maven://com.example:sink:0.0.1-SNAPSHOT
          port: 7001</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您列出应用程序时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ spring cloud --list
source sink configserver dataflow eureka h2 hystrixdashboard kafka stubrunner zipkin</code></pre>
</div>
</div>
<div class="paragraph">
<p>（请注意列表开头的其他应用）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="writing-groovy-scripts-and-running-applications"><a class="anchor" href="#writing-groovy-scripts-and-running-applications"></a> <a class="link" href="#writing-groovy-scripts-and-running-applications">11.3。编写Groovy脚本并运行应用程序</a></h3>
<div class="paragraph">
<p>Spring Cloud CLI支持大多数Spring Cloud声明式功能，例如<code>@Enable*</code>注释类。例如，这是功能齐全的Eureka服务器</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@EnableEurekaServer
class Eureka {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以从命令行像这样运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring run app.groovy</pre>
</div>
</div>
<div class="paragraph">
<p>为了包括其他依赖关系，通常只需添加适当的启用功能的注释即可，例如<code>@EnableConfigServer</code> ， <code>@EnableOAuth2Sso</code>要么<code>@EnableEurekaClient</code> 。要手动包含依赖项，您可以使用<code>@Grab</code>具有特殊的“ Spring Boot”短样式工件坐标，即仅具有工件ID（无需组或版本信息），例如，设置客户端应用程序以侦听AMQP上来自Spring CLoud总线的管理事件：</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@Grab('spring-cloud-starter-bus-amqp')
@RestController
class Service {
  @RequestMapping('/')
  def home() { [message: 'Hello'] }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="encryption-and-decryption-3"><a class="anchor" href="#encryption-and-decryption-3"></a> <a class="link" href="#encryption-and-decryption-3">11.4。加密与解密</a></h3>
<div class="paragraph">
<p>Spring Cloud CLI带有“加密”和“解密”命令。两者都接受带有指定为强制性“ --key”的键的相同形式的参数，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>
</div>
</div>
<div class="paragraph">
<p>要在文件中使用密钥（例如用于加密的RSA公钥），请在密钥值前添加“ @”并提供文件路径，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-security"><a class="anchor" href="#spring-cloud-security"></a> <a class="link" href="#spring-cloud-security">12Spring Cloud Security</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud Security提供了一组原语，用于以最少的麻烦构建安全的应用程序和服务。可以在外部（或中央）进行大量配置的声明性模型，通常可以通过中央身份管理服务来实现大型的，相互协作的远程组件系统。在Cloud Foundry等服务平台中使用它也非常容易。在Spring Boot和Spring Security OAuth2的基础上，我们可以快速创建实现常见模式（如单点登录，令牌中继和令牌交换）的系统。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/asciidoc">github</a>的项目中找到源代码和问题跟踪程序。
</td>
</tr>
</tbody></table>
</div>
<div class="sect2">
<h3 id="quickstart"><a class="anchor" href="#quickstart"></a> <a class="link" href="#quickstart">12.1。快速开始</a></h3>
<div class="sect3">
<h4 id="oauth2-single-sign-on"><a class="anchor" href="#oauth2-single-sign-on"></a> <a class="link" href="#oauth2-single-sign-on">12.1.1。OAuth2单点登录</a></h4>
<div class="paragraph">
<p>这是一个具有HTTP Basic身份验证和单个用户帐户的Spring Cloud“ Hello World”应用程序：</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Grab('spring-boot-starter-security')
@Controller
class Application {

  @RequestMapping('/')
  String home() {
    'Hello World'
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用<code>spring run app.groovy</code>并查看日志中的密码（用户名是“ user”）。到目前为止，这只是Spring Boot应用程序的默认设置。</p>
</div>
<div class="paragraph">
<p>这是带有OAuth2 SSO的Spring Cloud应用程序：</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@EnableOAuth2Sso
class Application {

  @RequestMapping('/')
  String home() {
    'Hello World'
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>指出不同？该应用程序实际上将与上一个应用程序完全相同，因为它尚不知道它是OAuth2凭据。</p>
</div>
<div class="paragraph">
<p>您可以很容易地在github中注册一个应用程序，因此如果您想在自己的域上使用生产应用程序，请尝试使用该应用程序。如果您愿意在localhost：8080上进行测试，请在应用程序配置中设置以下属性：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">security:
  oauth2:
    client:
      clientId: bd1c0a783ccdd1c9b9e4
      clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1
      accessTokenUri: https://github.com/login/oauth/access_token
      userAuthorizationUri: https://github.com/login/oauth/authorize
      clientAuthenticationScheme: form
    resource:
      userInfoUri: https://api.github.com/user
      preferTokenInfo: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行上面的应用程序，它将重定向到github进行授权。如果您已经登录github，您甚至不会注意到它已通过身份验证。仅当您的应用程序在端口8080上运行时，这些凭据才有效。</p>
</div>
<div class="paragraph">
<p>要限制客户端在获取访问令牌时要求的范围，可以设置<code>security.oauth2.client.scope</code> （逗号分隔或YAML中的数组）。默认情况下，作用域为空，并且由授权服务器决定默认值是什么，通常取决于它所拥有的客户端注册中的设置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">上面的示例都是Groovy脚本。如果要用Java（或Groovy）编写相同的代码，则需要将Spring Security OAuth2添加到类路径中（例如，参见<a href="https://github.com/spring-cloud-samples/sso">此处</a>的<a href="https://github.com/spring-cloud-samples/sso">示例</a> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2-protected-resource"><a class="anchor" href="#oauth2-protected-resource"></a> <a class="link" href="#oauth2-protected-resource">12.1.2。OAuth2受保护的资源</a></h4>
<div class="paragraph">
<p>您想使用OAuth2令牌保护API资源吗？这是一个简单的示例（与上面的客户端配对）：</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Grab('spring-cloud-starter-security')
@RestController
@EnableResourceServer
class Application {

  @RequestMapping('/')
  def home() {
    [message: 'Hello World']
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">security:
  oauth2:
    resource:
      userInfoUri: https://api.github.com/user
      preferTokenInfo: false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="more-detail"><a class="anchor" href="#more-detail"></a> <a class="link" href="#more-detail">12.2。更多详情</a></h3>
<div class="sect3">
<h4 id="single-sign-on"><a class="anchor" href="#single-sign-on"></a> <a class="link" href="#single-sign-on">12.2.1。单点登录</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">所有OAuth2 SSO和资源服务器功能已在1.3版中移至Spring Boot。您可以在<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">Spring Boot用户指南中</a>找到文档。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="token-relay"><a class="anchor" href="#token-relay"></a> <a class="link" href="#token-relay">12.2.2。令牌中继</a></h4>
<div class="paragraph">
<p>令牌中继是OAuth2使用者充当客户端，并将传入令牌转发到传出资源请求的地方。使用者可以是纯客户端（如SSO应用程序）或资源服务器。</p>
</div>
<div class="sect4">
<h5 id="client-token-relay-in-spring-cloud-gateway"><a class="anchor" href="#client-token-relay-in-spring-cloud-gateway"></a> <a class="link" href="#client-token-relay-in-spring-cloud-gateway">Spring Cloud Gateway中的客户端令牌中继</a></h5>
<div class="paragraph">
<p>如果您的应用程序还具有<a href="https://cloud.spring.io/spring-cloud-static/current/single/spring-cloud.html#_spring_cloud_gateway">Spring Cloud Gateway</a>嵌入式反向代理，则可以要求它向下游转发OAuth2访问令牌到它正在代理的服务。因此，可以像下面这样简单地增强上面的SSO应用程序：</p>
</div>
<div class="listingblock">
<div class="title">App.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private TokenRelayGatewayFilterFactory filterFactory;

@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes()
            .route("resource", r -> r.path("/resource")
                    .filters(f -> f.filter(filterFactory.apply()))
                    .uri("http://localhost:9000"))
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或这个</p>
</div>
<div class="listingblock">
<div class="title">application.yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: resource
        uri: http://localhost:9000
        predicates:
        - Path=/resource
        filters:
        - TokenRelay=</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且它将（除了登录用户并获取令牌之外）还将身份验证令牌传递给服务下游（在这种情况下， <code>/resource</code> ）。</p>
</div>
<div class="paragraph">
<p>要为Spring Cloud Gateway启用此功能，请添加以下依赖项</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.boot:spring-boot-starter-oauth2-client</code></p>
</li>
<li>
<p><code>org.springframework.cloud:spring-cloud-starter-security</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它是如何工作的？<a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/gateway/TokenRelayGatewayFilterFactory.java">过滤器</a>从当前经过身份验证的用户中提取访问令牌，并将其放入下游请求的请求标头中。</p>
</div>
<div class="paragraph">
<p>有关完整的工作示例，请参见此<a href="https://github.com/spring-cloud-samples/sample-gateway-oauth2login">项目</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认实现<code>ReactiveOAuth2AuthorizedClientService</code>被...使用<code>TokenRelayGatewayFilterFactory</code>使用内存中的数据存储。您将需要提供自己的实现<code>ReactiveOAuth2AuthorizedClientService</code>如果您需要更强大的解决方案。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="client-token-relay"><a class="anchor" href="#client-token-relay"></a> <a class="link" href="#client-token-relay">客户令牌中继</a></h5>
<div class="paragraph">
<p>如果您的应用是面向OAuth2客户端的用户（即已声明<code>@EnableOAuth2Sso</code>要么<code>@EnableOAuth2Client</code> ），然后有一个<code>OAuth2ClientContext</code>在Spring Boot的请求范围内。您可以创建自己的<code>OAuth2RestTemplate</code>从这个上下文和自动连线<code>OAuth2ProtectedResourceDetails</code> ，然后上下文将始终将访问令牌转发到下游，如果过期，访问令牌也会自动刷新。（这些是Spring Security和Spring Boot的功能。）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot（1.4.1）不会创建<code>OAuth2ProtectedResourceDetails</code>如果您正在使用，则自动<code>client_credentials</code>令牌。在这种情况下，您需要创建自己的<code>ClientCredentialsResourceDetails</code>并配置它<code>@ConfigurationProperties("security.oauth2.client")</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="client-token-relay-in-zuul-proxy"><a class="anchor" href="#client-token-relay-in-zuul-proxy"></a> <a class="link" href="#client-token-relay-in-zuul-proxy">Zuul代理中的客户端令牌中继</a></h5>
<div class="paragraph">
<p>如果您的应用程序还具有<a href="https://cloud.spring.io/spring-cloud.html#netflix-zuul-reverse-proxy">Spring Cloud Zuul</a>嵌入式反向代理（使用<code>@EnableZuulProxy</code> ），则可以要求其将OAuth2访问令牌下游转发到它正在代理的服务。因此，可以像下面这样简单地增强上面的SSO应用程序：</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Controller
@EnableOAuth2Sso
@EnableZuulProxy
class Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且它将（除了登录用户并获取令牌外）还将身份验证令牌传递到下游<code>/proxy/*</code>服务。如果这些服务是通过<code>@EnableResourceServer</code>那么他们将在正确的标头中获得有效的令牌。</p>
</div>
<div class="paragraph">
<p>它是如何工作的？的<code>@EnableOAuth2Sso</code>注解引入<code>spring-cloud-starter-security</code> （您可以在传统应用中手动完成此操作），然后触发一些自动配置<code>ZuulFilter</code> ，因为Zuul在类路径上（通过<code>@EnableZuulProxy</code> ）。<a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/OAuth2TokenRelayFilter.java">过滤器</a>仅从当前已认证的用户中提取访问令牌，并将其放入下游请求的请求标头中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Boot不会创建一个<code>OAuth2RestOperations</code>自动需要<code>refresh_token</code> 。在这种情况下，您需要创建自己的<code>OAuth2RestOperations</code>所以<code>OAuth2TokenRelayFilter</code>可以根据需要刷新令牌。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="resource-server-token-relay"><a class="anchor" href="#resource-server-token-relay"></a> <a class="link" href="#resource-server-token-relay">资源服务器令牌中继</a></h5>
<div class="paragraph">
<p>如果您的应用有<code>@EnableResourceServer</code>您可能需要将传入令牌下游中继到其他服务。如果您使用<code>RestTemplate</code>联系下游服务，那么这只是如何在正确的上下文中创建模板的问题。</p>
</div>
<div class="paragraph">
<p>如果您的服务使用<code>UserInfoTokenServices</code>验证传入令牌（即它正在使用<code>security.oauth2.user-info-uri</code>配置），那么您只需创建一个<code>OAuth2RestTemplate</code>使用自动接线<code>OAuth2ClientContext</code> （它将在到达后端代码之前由身份验证过程填充）。同样（使用Spring Boot 1.4），您可以注入一个<code>UserInfoRestTemplateFactory</code>抓住它<code>OAuth2RestTemplate</code>在您的配置中。例如：</p>
</div>
<div class="listingblock">
<div class="title">MyConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public OAuth2RestTemplate restTemplate(UserInfoRestTemplateFactory factory) {
    return factory.getUserInfoRestTemplate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其余模板将具有相同的<code>OAuth2ClientContext</code> （请求范围）供身份验证过滤器使用，因此您可以使用它来发送具有相同访问令牌的请求。</p>
</div>
<div class="paragraph">
<p>如果您的应用未使用<code>UserInfoTokenServices</code>但仍然是客户（即它声明<code>@EnableOAuth2Client</code>要么<code>@EnableOAuth2Sso</code> ），然后使用Spring Security Cloud <code>OAuth2RestOperations</code>用户从<code>@Autowired</code><code>OAuth2Context</code>还将转发令牌。默认情况下，此功能作为MVC处理程序拦截器实现，因此仅在Spring MVC中有效。如果您不使用MVC，则可以使用自定义过滤器或AOP拦截器来包装<code>AccessTokenContextRelay</code>提供相同的功能。</p>
</div>
<div class="paragraph">
<p>这是一个基本示例，展示了如何使用在其他位置创建的自动连接的休息模板（“ foo.com”是接受与周围应用程序相同的令牌的资源服务器）：</p>
</div>
<div class="listingblock">
<div class="title">MyController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private OAuth2RestOperations restTemplate;

@RequestMapping("/relay")
public String relay() {
    ResponseEntity<String> response =
      restTemplate.getForEntity("https://foo.com/bar", String.class);
    return "Success! (" + response.getBody() + ")";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不希望转发令牌（这是一个正确的选择，因为您可能想扮演自己的角色，而不是发送令牌的客户端），那么您只需要创建自己的令牌即可<code>OAuth2Context</code>而不是自动装配默认值。</p>
</div>
<div class="paragraph">
<p>假冒客户还会选择使用<code>OAuth2ClientContext</code>如果有的话，那么他们还应该在任何<code>RestTemplate</code>将。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-authentication-downstream-of-a-zuul-proxy"><a class="anchor" href="#configuring-authentication-downstream-of-a-zuul-proxy"></a> <a class="link" href="#configuring-authentication-downstream-of-a-zuul-proxy">12.3。配置Zuul代理的下游身份验证</a></h3>
<div class="paragraph">
<p>您可以控制授权行为的下游<code>@EnableZuulProxy</code>通过<code>proxy.auth.*</code>设置。例：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">proxy:
  auth:
    routes:
      customers: oauth2
      stores: passthru
      recommendations: none</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，“客户”服务获取OAuth2令牌中继，“商店”服务获取直通（授权标头仅向下游传递），而“推荐”服务则删除其授权标头。默认行为是在有令牌可用时进行令牌中继，否则通过。</p>
</div>
<div class="paragraph">
<p>有关完整的详细信息，请参见<a href="https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/ProxyAuthenticationProperties">ProxyAuthenticationProperties</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-for-cloud-foundry"><a class="anchor" href="#spring-cloud-for-cloud-foundry"></a> <a class="link" href="#spring-cloud-for-cloud-foundry">13Spring Cloud for Cloud Foundry</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Cloud for Cloudfoundry使在<a href="https://github.com/cloudfoundry">Cloud Foundry</a> （平台即服务）中轻松运行<a href="https://github.com/spring-cloud">Spring Cloud</a>应用程序变得容易。Cloud Foundry具有“服务”的概念，即您“绑定”到应用程序的中间件，本质上为它提供了一个包含凭证的环境变量（例如，用于服务的位置和用户名）。</p>
</div>
<div class="paragraph">
<p>的<code>spring-cloud-cloudfoundry-commons</code>该模块可配置基于Reactor的Cloud Foundry Java客户端v 3.0，并且可以独立使用。</p>
</div>
<div class="paragraph">
<p>的<code>spring-cloud-cloudfoundry-web</code>该项目为Cloud Foundry中的Webapp的某些增强功能提供了基本支持：自动绑定到单点登录服务，并可以选择启用粘性路由进行发现。</p>
</div>
<div class="paragraph">
<p>的<code>spring-cloud-cloudfoundry-discovery</code>该项目提供了Spring Cloud Commons的实现<code>DiscoveryClient</code>这样你就可以<code>@EnableDiscoveryClient</code>并提供您的凭据<code>spring.cloud.cloudfoundry.discovery.[username,password]</code> （也<code>*.url</code>如果您没有连接到<a href="https://run.pivotal.io">Pivotal Web Services</a> ），则可以使用<code>DiscoveryClient</code>直接或通过<code>LoadBalancerClient</code> 。</p>
</div>
<div class="paragraph">
<p>首次使用它时，发现客户端可能会变慢，原因是它必须从Cloud Foundry获取访问令牌。</p>
</div>
<div class="sect2">
<h3 id="discovery"><a class="anchor" href="#discovery"></a> <a class="link" href="#discovery">13.1。发现</a></h3>
<div class="paragraph">
<p>这是带有Cloud Foundry发现的Spring Cloud应用程序：</p>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Grab('org.springframework.cloud:spring-cloud-cloudfoundry')
@RestController
@EnableDiscoveryClient
class Application {

  @Autowired
  DiscoveryClient client

  @RequestMapping('/')
  String home() {
    'Hello from ' + client.getLocalServiceInstance()
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果运行时没有任何服务绑定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ spring jar app.jar app.groovy
$ cf push -p app.jar</pre>
</div>
</div>
<div class="paragraph">
<p>它将在首页中显示其应用名称。</p>
</div>
<div class="paragraph">
<p>的<code>DiscoveryClient</code>可以根据进行身份验证的凭据列出一个空间中的所有应用程序，其中该空间默认为客户端正在其中运行的应用程序（如果有）。如果未配置组织和空间，则它们将根据Cloud Foundry中用户的配置文件默认设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="single-sign-on-2"><a class="anchor" href="#single-sign-on-2"></a> <a class="link" href="#single-sign-on-2">13.2。单点登录</a></h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">所有OAuth2 SSO和资源服务器功能已在1.3版中移至Spring Boot。您可以在<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/">Spring Boot用户指南中</a>找到文档。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>该项目提供了从CloudFoundry服务凭据到Spring Boot功能的自动绑定。例如，如果您有一个名为“ sso”的CloudFoundry服务，且其凭据包含“ client_id”，“ client_secret”和“ auth_domain”，则该服务将自动绑定到您通过以下方式启用的Spring OAuth2客户端<code>@EnableOAuth2Sso</code> （来自Spring Boot）。服务名称可以使用<code>spring.oauth2.sso.serviceId</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-3"><a class="anchor" href="#configuration-3"></a> <a class="link" href="#configuration-3">13.3。组态</a></h3>
<div class="paragraph">
<p>要查看所有与Spring Cloud Sloud Foundry相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1"><div class="sect1">
<h2 id="spring-cloud-contract-reference-documentation"><a class="anchor" href="#spring-cloud-contract-reference-documentation"></a> <a class="link" href="#spring-cloud-contract-reference-documentation">14。Spring Cloud Contract参考文档</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>亚当·杜德扎克（Adam Dudczak），马蒂亚斯·杜斯特霍夫（MathiasDüsterhöft），马辛·格热兹杰什扎克（Marcin Grzejszczak），丹尼斯·基瑟尔霍斯特，雅库布·库布连斯基，卡罗尔·拉萨克，奥尔加·马西亚塞克·夏玛，马里乌斯·史密库拉，戴夫·瑟尔，杰伊·布莱恩特</p>
</div>
<div class="sect2">
<h3 id="legal"><a class="anchor" href="#legal"></a> <a class="link" href="#legal">法律</a></h3>
<div class="paragraph">
<p>2.2.0。RC2</p>
</div>
<div class="paragraph">
<p>版权所有©2012-2019</p>
</div>
<div class="paragraph">
<p>本文档的副本可以供您自己使用，也可以分发给他人，但前提是您不对此类副本收取任何费用，并且还应确保每份副本均包含本版权声明（无论是印刷版本还是电子版本）。</p>
</div>
</div>
<div class="sect2">
<h3 id="getting-started"><a class="anchor" href="#getting-started"></a> <a class="link" href="#getting-started">14.1。入门</a></h3>
<div class="paragraph">
<p>如果您是开始使用Spring Cloud Contract或一般来说是Spring，请先阅读本节。它回答了基本的“什么？”，“如何？”和“为什么？”问题。它包括对Spring Cloud Contract的介绍以及安装说明。然后，我们将引导您构建第一个Spring Cloud Contract应用程序，并讨论我们进行中的一些核心原则。</p>
</div>
<div class="sect3">
<h4 id="getting-started-introducing-spring-cloud-contract"><a class="anchor" href="#getting-started-introducing-spring-cloud-contract"></a> <a class="link" href="#getting-started-introducing-spring-cloud-contract">14.1.1。介绍Spring Cloud Contract</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract将TDD移至软件架构级别。它使您可以执行消费者驱动和生产者驱动的合同测试。</p>
</div>
<div class="sect4">
<h5 id="getting-started-introducing-spring-cloud-contract-history"><a class="anchor" href="#getting-started-introducing-spring-cloud-contract-history"></a> <a class="link" href="#getting-started-introducing-spring-cloud-contract-history">历史</a></h5>
<div class="paragraph">
<p>在成为Spring Cloud Contract之前，该项目称为<a href="https://github.com/Codearte/accurest">Accurest</a> 。它是由（ <a href="https://github.com/Codearte">Codearte</a> ）的<a href="https://twitter.com/mgrzejszczak">Marcin Grzejszczak</a>和<a href="https://twitter.com/jkubrynski">Jakub Kubrynski</a>创建的。</p>
</div>
<div class="paragraph">
<p>的<code>0.1.0</code>发布于2015年1月26日发布，并在<code>1.0.0</code>发布于2016年2月29日。</p>
</div>
<div class="sect5">
<h6 id="getting-started-introducing-spring-cloud-contract-why"><a class="anchor" href="#getting-started-introducing-spring-cloud-contract-why"></a> <a class="link" href="#getting-started-introducing-spring-cloud-contract-why">你为什么需要它？</a></h6>
<div class="paragraph">
<p>假设我们有一个包含多个微服务的系统，如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Deps.png" alt="微服务架构">
</div>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-introducing-spring-cloud-contract-testing-issues"><a class="anchor" href="#getting-started-introducing-spring-cloud-contract-testing-issues"></a> <a class="link" href="#getting-started-introducing-spring-cloud-contract-testing-issues">测试问题</a></h6>
<div class="paragraph">
<p>如果要在上一节中图像的左上角测试该应用程序，以确定它是否可以与其他服务通信，则可以执行以下两项操作之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>部署所有微服务并执行端到端测试。</p>
</li>
<li>
<p>在单元和集成测试中模拟其他微服务。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两者都有优点，也有很多缺点。</p>
</div>
<div class="paragraph">
<p><strong>部署所有微服务并执行端到端测试</strong></p>
</div>
<div class="paragraph">
<p>好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模拟生产。</p>
</li>
<li>
<p>测试服务之间的真实通信。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为了测试一个微服务，我们必须部署六个微服务，几个数据库以及其他项目。</p>
</li>
<li>
<p>测试运行的环境被锁定为单个测试套件（其他人将无法同时运行测试）。</p>
</li>
<li>
<p>他们需要很长时间才能运行。</p>
</li>
<li>
<p>反馈在此过程中非常晚。</p>
</li>
<li>
<p>他们很难调试。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>在单元和集成测试中模拟其他微服务</strong></p>
</div>
<div class="paragraph">
<p>好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>他们提供了非常快速的反馈。</p>
</li>
<li>
<p>他们没有基础架构要求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务的实现者创建的存根可能与现实无关。</p>
</li>
<li>
<p>您可以通过测试并通过失败的生产。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了解决上述问题，创建了Spring Cloud Contract。主要思想是为您提供非常快速的反馈，而无需建立整个微服务世界。如果使用存根，则仅需要应用程序直接使用的那些应用程序。下图显示了存根与应用程序的关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/Stubs2.png" alt="存根服务">
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Contract可确保您使用的存根是由调用的服务创建的。另外，如果可以使用它们，则意味着它们已针对生产者方面进行了测试。简而言之，您可以信任这些存根。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-introducing-spring-cloud-contract-purposes"><a class="anchor" href="#getting-started-introducing-spring-cloud-contract-purposes"></a> <a class="link" href="#getting-started-introducing-spring-cloud-contract-purposes">目的</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract的主要目的是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为了确保HTTP和Messaging存根（在开发客户端时使用）完全按照实际的服务器端实现方式进行操作。</p>
</li>
<li>
<p>推广ATDD（验收测试驱动的开发）方法和微服务架构风格。</p>
</li>
<li>
<p>提供一种发布合同更改的方法，该更改在双方立即可见。</p>
</li>
<li>
<p>生成要在服务器端使用的样板测试代码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，Spring Cloud Contract与<a href="http://wiremock.org">Wiremock</a>集成为HTTP服务器存根。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">Spring Cloud Contract的目的不是开始在合同中编写业务功能。假设我们有一个欺诈检查的业务用例。如果用户可能出于100种不同的原因而成为欺诈者，那么我们假设您将创建两个合同，一个用于肯定案件，一个用于否定案件。合同测试用于测试应用程序之间的合同，而不是模拟完整的行为。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-what-is-a-contract"><a class="anchor" href="#getting-started-what-is-a-contract"></a> <a class="link" href="#getting-started-what-is-a-contract">什么是合约？</a></h5>
<div class="paragraph">
<p>作为服务的使用者，我们需要定义要实现的目标。我们需要制定我们的期望。这就是为什么我们签订合同的原因。换句话说，合同是关于API或消息通信外观的协议。考虑以下示例：</p>
</div>
<div class="paragraph">
<p>假设您要发送的请求包含客户公司的ID及其要从我们那里借入的金额。您还想将其发送到<code>/fraudcheck</code>通过的网址<code>PUT</code>方法。以下清单显示了一个合同，用于检查在Groovy和YAML中是否都应将客户标记为欺诈：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package contracts

org.springframework.cloud.contract.spec.Contract.make {
    request { // (1)
        method 'PUT' // (2)
        url '/fraudcheck' // (3)
        body([ // (4)
               "client.id": $(regex('[0-9]{10}')),
               loanAmount : 99999
        ])
        headers { // (5)
            contentType('application/json')
        }
    }
    response { // (6)
        status OK() // (7)
        body([ // (8)
               fraudCheckStatus  : "FRAUD",
               "rejection.reason": "Amount too high"
        ])
        headers { // (9)
            contentType('application/json')
        }
    }
}

/*
From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/json.*`
 */</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request: # (1)
  method: PUT # (2)
  url: /yamlfraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json


#From the Consumer perspective, when shooting a request in the integration test:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/yamlfraudcheck"
#(4) - with the JSON body that
# * has a field `client.id`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(6) - and a `client.id` json entry matches the regular expression `[0-9]{10}`
#(7) - then the response will be sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test:
#
#(1) - A request will be sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/yamlfraudcheck"
#(4) - with the JSON body that
# * has a field `client.id` `1234567890`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(7) - then the test will assert if the response has been sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getting-started-three-second-tour"><a class="anchor" href="#getting-started-three-second-tour"></a> <a class="link" href="#getting-started-three-second-tour">14.1.2。三秒游</a></h4>
<div class="paragraph">
<p>这个非常简短的导览将介绍如何使用Spring Cloud Contract。它包含以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-three-second-tour-producer">在生产者方面</a></p>
</li>
<li>
<p><a href="#getting-started-three-second-tour-consumer">在消费者方面</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以<a href="#getting-started-first-application">在这里</a>找到更长的行程。</p>
</div>
<div class="paragraph">
<p>以下UML图显示了Spring Cloud Contract中各部分之间的关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/getting-started-three-second.png" alt="入门三秒钟" width="986" height="704">
</div>
</div>
<div class="sect4">
<h5 id="getting-started-three-second-tour-producer"><a class="anchor" href="#getting-started-three-second-tour-producer"></a> <a class="link" href="#getting-started-three-second-tour-producer">在生产者方面</a></h5>
<div class="paragraph">
<p>要开始使用Spring Cloud Contract，您可以将带有REST的文件或以Groovy DSL或YAML表示的消息传递合同添加到合同目录，该目录由<code>contractsDslDir</code>属性。默认情况下是<code>$rootDir/src/test/resources/contracts</code> 。</p>
</div>
<div class="paragraph">
<p>然后，您可以将Spring Cloud Contract Verifier依赖项和插件添加到您的构建文件中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-verifier</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了如何添加插件，该插件应放在文件的build / plugins部分中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>跑步<code>./mvnw clean install</code>自动生成测试，以验证应用程序是否符合添加的合同。默认情况下，在以下条件下生成测试<code>org.springframework.cloud.contract.verifier.tests.</code> 。</p>
</div>
<div class="paragraph">
<p>由于尚不存在合同描述的功能的实现，因此测试失败。</p>
</div>
<div class="paragraph">
<p>要使它们通过，您必须添加处理HTTP请求或消息的正确实现。另外，必须将用于自动生成的测试的基本测试类添加到项目。该类由所有自动生成的测试扩展，并且应包含运行它们所需的所有设置信息（例如<code>RestAssuredMockMvc</code>控制器设置或消息传递测试设置）。</p>
</div>
<div class="paragraph">
<p>以下示例来自<code>pom.xml</code> ，显示了如何指定基本测试类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre><build>
        <plugins>
            <plugin>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                <version>2.1.2.RELEASE</version>
                <extensions>true</extensions>
                <configuration>
                    <baseClassForTests>com.example.contractTest.BaseTestClass</baseClassForTests> <i class="conum" data-value="1"></i><b>(1)</b>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>baseClassForTests</code>元素可让您指定基本测试类。它必须是<code>configuration</code>内的元素<code>spring-cloud-contract-maven-plugin</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦实现和测试基类就位，测试就会通过，并且应用程序和存根构件都将被构建并安装在本地Maven存储库中。现在，您可以合并更改，并且可以在在线存储库中发布应用程序和存根工件。</p>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-three-second-tour-consumer"><a class="anchor" href="#getting-started-three-second-tour-consumer"></a> <a class="link" href="#getting-started-three-second-tour-consumer">在消费者方面</a></h5>
<div class="paragraph">
<p>您可以使用<code>Spring Cloud Contract Stub Runner</code>在集成测试中获得一个运行的WireMock实例或模拟实际服务的消息传递路由。</p>
</div>
<div class="paragraph">
<p>为此，将依赖项添加到<code>Spring Cloud Contract Stub Runner</code> ，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过以下两种方式之一在Maven资源库中安装生产者端存根：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过检出生产者端存储库并添加合同并通过运行以下命令来生成存根：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ cd local-http-server-repo
$ ./mvnw clean install -DskipTests</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">由于生产者方合同实施尚未到位，因此跳过了测试，因此自动生成的合同测试失败。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>通过从远程存储库获取已经存在的生产者服务存根。为此，请将存根工件ID和工件存储库URL传递为<code>Spring Cloud Contract Stub Runner</code>属性，如以下示例所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner:
  ids: 'com.example:http-server-dsl:+:stubs:8080'
  repositoryRoot: https://repo.spring.io/libs-snapshot</code></pre>
</div>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，您可以使用<code>@AutoConfigureStubRunner</code> 。在注释中，提供<code>group-id</code>和<code>artifact-id</code>的值<code>Spring Cloud Contract Stub Runner</code>为您运行协作者的存根，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"},
        stubsMode = StubRunnerProperties.StubsMode.LOCAL)
public class LoanApplicationServiceTests {</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>REMOTE</code><code>stubsMode</code>从在线存储库下载存根时，以及<code>LOCAL</code>进行离线工作。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，在集成测试中，您可以接收预期由协作服务发出的HTTP响应或消息的存根版本。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getting-started-first-application"><a class="anchor" href="#getting-started-first-application"></a> <a class="link" href="#getting-started-first-application">14.1.3。开发您的第一个基于Spring Cloud Contract的应用程序</a></h4>
<div class="paragraph">
<p>这个简短的导览将介绍如何使用Spring Cloud Contract。它包含以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-first-application-producer">在生产者方面</a></p>
</li>
<li>
<p><a href="#getting-started-first-application-consumer">在消费者方面</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以<a href="#getting-started-three-second-tour">在这里</a>找到更简短的导览。</p>
</div>
<div class="paragraph">
<p>为了这个例子， <code>Stub Storage</code>是Nexus / Artifactory。</p>
</div>
<div class="paragraph">
<p>以下UML图显示了Spring Cloud Contract各部分之间的关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/getting-started-three-second.png" alt="入门第一个应用程序">
</div>
</div>
<div class="sect4">
<h5 id="getting-started-first-application-producer"><a class="anchor" href="#getting-started-first-application-producer"></a> <a class="link" href="#getting-started-first-application-producer">在生产者方面</a></h5>
<div class="paragraph">
<p>开始使用<code>Spring Cloud Contract</code> ，您可以将Spring Cloud Contract Verifier依赖项和插件添加到您的构建文件中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-verifier</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了如何添加插件，该插件应放在文件的build / plugins部分中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>最简单的入门方法是转到<a href="https://start.spring.io">Spring Initializr</a>并添加“ Web”和“ Contract Verifier”作为依赖项。这样做可以吸收前面提到的依赖项以及您在<code>pom.xml</code>文件（设置基本测试类除外，我们将在本节后面介绍）。下图显示了在<a href="https://start.spring.io">Spring Initializr中</a>使用的设置：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/start_spring_io_dependencies.png" alt="具有Web和Contract Verifier的Spring Initializr" width="800">
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，您可以使用<code>REST/</code> Groovy DSL或YAML中表示的消息传递合同到合同目录，该目录由<code>contractsDslDir</code>属性。默认情况下是<code>$rootDir/src/test/resources/contracts</code> 。请注意，文件名无关紧要。您可以使用任何喜欢的命名方案在此目录中组织合同。</p>
</div>
<div class="paragraph">
<p>对于HTTP存根，合同定义了应针对给定请求返回的响应类型（考虑到HTTP方法，URL，标头，状态码等）。以下示例显示了Groovy和YAML中的HTTP存根协定：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package contracts

org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'PUT'
        url '/fraudcheck'
        body([
               "client.id": $(regex('[0-9]{10}')),
               loanAmount: 99999
        ])
        headers {
            contentType('application/json')
        }
    }
    response {
        status OK()
        body([
               fraudCheckStatus: "FRAUD",
               "rejection.reason": "Amount too high"
        ])
        headers {
            contentType('application/json')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  method: PUT
  url: /fraudcheck
  body:
    "client.id": 1234567890
    loanAmount: 99999
  headers:
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id']
        type: by_regex
        value: "[0-9]{10}"
response:
  status: 200
  body:
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers:
    Content-Type: application/json;charset=UTF-8</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果需要使用消息传递，则可以定义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>输入和输出消息（考虑发送消息的位置和位置，消息正文和标头）。</p>
</li>
<li>
<p>收到消息后应调用的方法。</p>
</li>
<li>
<p>调用时应触发消息的方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了骆驼消息传递合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def contractDsl = Contract.make {
    name "foo"
    label 'some_label'
    input {
        messageFrom('jms:delete')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
        assertThat('bookWasDeleted()')
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">label: some_label
input:
  messageFrom: jms:delete
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
  assertThat: bookWasDeleted()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>跑步<code>./mvnw clean install</code>自动生成测试，以验证应用程序是否符合添加的合同。默认情况下，生成的测试处于<code>org.springframework.cloud.contract.verifier.tests.</code> 。</p>
</div>
<div class="paragraph">
<p>生成的测试可能会有所不同，具体取决于您在插件中设置的框架和测试类型。</p>
</div>
<div class="paragraph">
<p>在下一个清单中，您可以找到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP合约中的默认测试模式<code>MockMvc</code></p>
</li>
<li>
<p>一个JAX-RS客户端，带有<code>JAXRS</code>测试模式</p>
</li>
<li>
<p>一种<code>WebTestClient</code>基于测试（特别是在使用反应式测试时， <code>Web-Flux</code>基于应用程序） <code>WEBTESTCLIENT</code>测试模式</p>
</li>
<li>
<p>基于Spock的测试<code>testFramework</code>属性设置为<code>SPOCK</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您仅需要这些测试框架之一。MockMvc是默认设置。要使用其他框架之一，请将其库添加到您的类路径中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下清单显示了所有框架的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">模拟</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"client.id\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("['fraudCheckStatus']").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("['rejection.reason']").isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">jaxrs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SuppressWarnings("rawtypes")
public class FooTest {
  WebTarget webTarget;

  @Test
  public void validate_() throws Exception {

    // when:
      Response response = webTarget
              .path("/users")
              .queryParam("limit", "10")
              .queryParam("offset", "20")
              .queryParam("filter", "email")
              .queryParam("sort", "name")
              .queryParam("search", "55")
              .queryParam("age", "99")
              .queryParam("name", "Denis.Stepanov")
              .queryParam("email", "bob@email.com")
              .request()
              .build("GET")
              .invoke();
      String responseAsString = response.readEntity(String.class);

    // then:
      assertThat(response.getStatus()).isEqualTo(200);

    // and:
      DocumentContext parsedJson = JsonPath.parse(responseAsString);
      assertThatJson(parsedJson).field("['property1']").isEqualTo("a");
  }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">webtestclient</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
    public void validate_shouldRejectABeerIfTooYoung() throws Exception {
        // given:
            WebTestClientRequestSpecification request = given()
                    .header("Content-Type", "application/json")
                    .body("{\"age\":10}");

        // when:
            WebTestClientResponse response = given().spec(request)
                    .post("/check");

        // then:
            assertThat(response.statusCode()).isEqualTo(200);
            assertThat(response.header("Content-Type")).matches("application/json.*");
        // and:
            DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
            assertThatJson(parsedJson).field("['status']").isEqualTo("NOT_OK");
    }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">斯波克</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">given:
     ContractVerifierMessage inputMessage = contractVerifierMessaging.create(
        \'\'\'{"bookName":"foo"}\'\'\',
        ['sample': 'header']
    )

when:
     contractVerifierMessaging.send(inputMessage, 'jms:delete')

then:
     noExceptionThrown()
     bookWasDeleted()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于尚不存在合同描述的功能的实现，因此测试失败。</p>
</div>
<div class="paragraph">
<p>要使它们通过，您必须添加处理HTTP请求或消息的正确实现。另外，必须将用于自动生成的测试的基本测试类添加到项目。该类由所有自动生成的测试扩展，并且应包含运行它们所需的所有设置必要信息（例如， <code>RestAssuredMockMvc</code>控制器设置或消息传递测试设置）。</p>
</div>
<div class="paragraph">
<p>以下示例来自<code>pom.xml</code> ，显示了如何指定基本测试类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre><build>
        <plugins>
            <plugin>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                <version>2.1.2.RELEASE</version>
                <extensions>true</extensions>
                <configuration>
                    <baseClassForTests>com.example.contractTest.BaseTestClass</baseClassForTests> <i class="conum" data-value="1"></i><b>(1)</b>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>的<code>baseClassForTests</code>元素可让您指定基本测试类。它必须是<code>configuration</code>内的元素<code>spring-cloud-contract-maven-plugin</code> 。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了一个最小的（但功能正常的）基本测试类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package com.example.contractTest;

import org.junit.Before;

import io.restassured.module.mockmvc.RestAssuredMockMvc;

public class BaseTestClass {

    @Before
    public void setup() {
        RestAssuredMockMvc.standaloneSetup(new FraudController());
    }
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>实际上，这门最少的课就是使您的测试生效所需的全部。它是自动生成的测试所附加的起点。</p>
</div>
<div class="paragraph">
<p>现在我们可以继续执行。为此，我们首先需要一个数据类，然后在控制器中使用它。以下清单显示了数据类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package com.example.Test;

import com.fasterxml.jackson.annotation.JsonProperty;

public class LoanRequest {

    @JsonProperty("client.id")
    private String clientId;

    private Long loanAmount;

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public Long getLoanAmount() {
        return loanAmount;
    }

    public void setLoanRequestAmount(Long loanAmount) {
        this.loanAmount = loanAmount;
    }
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上一类提供了一个可以在其中存储参数的对象。因为合同中的客户ID被调用<code>client.id</code> ，我们需要使用<code>@JsonProperty("client.id")</code>参数以将其映射到<code>clientId</code>领域。</p>
</div>
<div class="paragraph">
<p>现在，我们可以转到控制器，以下清单显示了该控制器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>package com.example.docTest;

import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class FraudController {

    @PutMapping(value = "/fraudcheck", consumes="application/json", produces="application/json")
    public String check(@RequestBody LoanRequest loanRequest) { <i class="conum" data-value="1"></i><b>(1)</b>

        if (loanRequest.getLoanAmount() > 10000) { <i class="conum" data-value="2"></i><b>(2)</b>
            return "{fraudCheckStatus: FRAUD, rejection.reason: Amount too high}"; <i class="conum" data-value="3"></i><b>(3)</b>
        } else {
            return "{fraudCheckStatus: OK, acceptance.reason: Amount OK}"; <i class="conum" data-value="4"></i><b>(4)</b>
        }
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>我们将传入参数映射到<code>LoanRequest</code>宾语。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>我们检查请求的贷款金额，看是否过多。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>如果太多，我们将返回测试期望的JSON（在此处使用简单字符串创建）。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>如果我们有一个测试可以在什么时候允许该数量，则可以将其与此输出匹配。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>FraudController</code>事情变得简单。您可以做更多的事情，包括记录日志，验证客户端ID等。</p>
</div>
<div class="paragraph">
<p>一旦实现和测试基类就位，测试就会通过，并且应用程序和存根构件都将被构建并安装在本地Maven存储库中。有关将存根jar安装到本地存储库的信息将显示在日志中，因为以下示例显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">[INFO] --- spring-cloud-contract-maven-plugin:1.0.0.BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.5.BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:2.5.2:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，您可以合并更改，并在在线存储库中发布应用程序和存根工件。</p>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-first-application-consumer"><a class="anchor" href="#getting-started-first-application-consumer"></a> <a class="link" href="#getting-started-first-application-consumer">在消费者方面</a></h5>
<div class="paragraph">
<p>您可以在集成测试中使用Spring Cloud Contract Stub Runner获得模拟模拟实际服务的正在运行的WireMock实例或消息传递路由。</p>
</div>
<div class="paragraph">
<p>首先，将依赖项添加到<code>Spring Cloud Contract Stub Runner</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过以下两种方式之一在Maven资源库中安装生产者端存根：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过检出生产者端存储库并添加合同并通过运行以下命令来生成存根：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ cd local-http-server-repo
$ ./mvnw clean install -DskipTests</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">由于生产者方合同实施尚未到位，因此跳过了测试，因此自动生成的合同测试失败。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>从远程存储库获取已经存在的生产者服务存根。为此，请将存根工件ID和工件存储库UR1传递为<code>Spring Cloud Contract Stub Runner</code>属性，如以下示例所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner:
  ids: 'com.example:http-server-dsl:+:stubs:8080'
  repositoryRoot: https://repo.spring.io/libs-snapshot</code></pre>
</div>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，您可以使用<code>@AutoConfigureStubRunner</code> 。在注释中，提供<code>group-id</code>和<code>artifact-id</code>对于<code>Spring Cloud Contract Stub Runner</code>为您运行协作者的存根，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment=WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:6565"},
        stubsMode = StubRunnerProperties.StubsMode.LOCAL)
public class LoanApplicationServiceTests {</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">使用<code>REMOTE</code><code>stubsMode</code>从在线存储库下载存根时，以及<code>LOCAL</code>进行离线工作。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在集成测试中，您可以接收HTTP响应的残存版本或预期由协作服务发出的消息。您可以在构建日志中看到类似于以下内容的条目：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">2016-07-19 14:22:25.403  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
2016-07-19 14:22:25.438  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is 0.0.1-SNAPSHOT
2016-07-19 14:22:25.439  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT using remote repositories []
2016-07-19 14:22:25.451  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar
2016-07-19 14:22:25.465  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar]
2016-07-19 14:22:25.475  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/0p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
2016-07-19 14:22:27.737  INFO 41050 --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:0.0.1-SNAPSHOT:stubs=8080}]</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getting-started-cdc"><a class="anchor" href="#getting-started-cdc"></a> <a class="link" href="#getting-started-cdc">14.1.4。消费者驱动的合同（CDC）分步指南与生产者方的合同</a></h4>
<div class="paragraph">
<p>考虑欺诈检测和贷款发行过程的示例。业务场景是这样的，我们希望向人们发放贷款，但又不想他们从我们那里窃取钱财。我们系统当前的实施情况是向所有人提供贷款。</p>
</div>
<div class="paragraph">
<p>假使，假设<code>Loan Issuance</code>是该客户<code>Fraud Detection</code>服务器。在当前的sprint中，我们必须开发一个新功能：如果客户想要借太多钱，我们会将客户标记为欺诈。</p>
</div>
<div class="paragraph">
<p>技术备注</p>
</div>
<div class="ulist">
<ul>
<li>
<p>欺诈检测有一个<code>artifact-id</code>的<code>http-server</code></p>
</li>
<li>
<p>贷款发行的工件编号为<code>http-client</code></p>
</li>
<li>
<p>都有一个<code>group-id</code>的<code>com.example</code></p>
</li>
<li>
<p>为了这个例子<code>Stub Storage</code>是Nexus / Artifactory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>社会评论</p>
</div>
<div class="ulist">
<ul>
<li>
<p>客户和服务器开发团队都需要在整个过程中直接进行沟通并讨论更改</p>
</li>
<li>
<p>CDC的重点是沟通</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x///home/marcin/repo/spring-cloud-scripts/contract/samples/standalone/dsl/http-server">服务器端代码在此处可用</a> ， <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x///home/marcin/repo/spring-cloud-scripts/contract/samples/standalone/dsl/http-client">客户端代码在此处可用</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在这种情况下，生产者拥有合同。从物理上讲，所有合同都在生产者的存储库中。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="getting-started-cdc-technical-note"><a class="anchor" href="#getting-started-cdc-technical-note"></a> <a class="link" href="#getting-started-cdc-technical-note">技术说明</a></h5>
<div class="paragraph">
<p>如果您使用SNAPSHOT，Milestone或Release Candidate版本，则需要在构建中添加以下部分：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><repositories>
    <repository>
        <id>spring-snapshots</id>
        <name>Spring Snapshots</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-releases</id>
        <name>Spring Releases</name>
        <url>https://repo.spring.io/release</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
        <id>spring-snapshots</id>
        <name>Spring Snapshots</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>spring-releases</id>
        <name>Spring Releases</name>
        <url>https://repo.spring.io/release</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </pluginRepository>
</pluginRepositories></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">repositories {
    mavenCentral()
    mavenLocal()
    maven { url "https://repo.spring.io/snapshot" }
    maven { url "https://repo.spring.io/milestone" }
    maven { url "https://repo.spring.io/release" }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为简单起见，我们使用以下缩写词：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>贷款发行（LI）：HTTP客户端</p>
</li>
<li>
<p>欺诈检测（FD）：HTTP服务器</p>
</li>
<li>
<p>spring-cloud-contract（SCC）</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-cdc-consumer"><a class="anchor" href="#getting-started-cdc-consumer"></a> <a class="link" href="#getting-started-cdc-consumer">消费者方（贷款发行）</a></h5>
<div class="paragraph">
<p>作为贷款发行服务的开发人员（欺诈检测服务器的使用者），您可以执行以下步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过为您的功能编写测试来开始进行TDD。</p>
</li>
<li>
<p>编写缺少的实现。</p>
</li>
<li>
<p>在本地克隆欺诈检测服务存储库。</p>
</li>
<li>
<p>在欺诈检测服务的仓库中本地定义合同。</p>
</li>
<li>
<p>添加Spring Cloud Contract（SCC）插件。</p>
</li>
<li>
<p>运行集成测试。</p>
</li>
<li>
<p>提出拉取请求。</p>
</li>
<li>
<p>创建一个初始实现。</p>
</li>
<li>
<p>接管请求请求。</p>
</li>
<li>
<p>编写缺少的实现。</p>
</li>
<li>
<p>部署您的应用程序。</p>
</li>
<li>
<p>在线工作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们从贷款发行流程开始，以下UML图显示了该流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/getting-started-cdc-client.png" alt="入门cdc客户端" width="1138" height="1223">
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-start"><a class="anchor" href="#getting-started-cdc-consumer-start"></a> <a class="link" href="#getting-started-cdc-consumer-start">通过编写功能测试开始进行TDD</a></h6>
<div class="paragraph">
<p>以下清单显示了一个测试，我们可以用来检查贷款额是否太大：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@Test
public void shouldBeRejectedDueToAbnormalLoanAmount() {
    // given:
    LoanApplication application = new LoanApplication(new Client("1234567890"),
            99999);
    // when:
    LoanApplicationResult loanApplication = service.loanApplication(application);
    // then:
    assertThat(loanApplication.getLoanApplicationStatus())
            .isEqualTo(LoanApplicationStatus.LOAN_APPLICATION_REJECTED);
    assertThat(loanApplication.getRejectionReason()).isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设您已经编写了新功能的测试。如果收到大量贷款申请，则系统应拒绝该贷款申请并提供一些说明。</p>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-write"><a class="anchor" href="#getting-started-cdc-consumer-write"></a> <a class="link" href="#getting-started-cdc-consumer-write">编写缺少的实现</a></h6>
<div class="paragraph">
<p>在某个时间点，您需要向欺诈检测服务发送请求。假设您需要发送包含客户ID和客户希望借入的金额的请求。您要将其发送到<code>/fraudcheck</code>通过使用<code>PUT</code>方法。为此，您可以使用类似于以下代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">ResponseEntity<FraudServiceResponse> response = restTemplate.exchange(
        "http://localhost:" + port + "/fraudcheck", HttpMethod.PUT,
        new HttpEntity<>(request, httpHeaders), FraudServiceResponse.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为简单起见，欺诈检测服务的端口设置为<code>8080</code> ，并且应用程序在<code>8090</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果此时开始测试，则会中断测试，因为当前端口上没有运行任何服务<code>8080</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-clone"><a class="anchor" href="#getting-started-cdc-consumer-clone"></a> <a class="link" href="#getting-started-cdc-consumer-clone">在本地克隆欺诈检测服务存储库</a></h6>
<div class="paragraph">
<p>您可以从服务器端合同开始。为此，必须首先通过运行以下命令克隆它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git clone https://your-git-server.com/server-side.git local-http-server-repo</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-define"><a class="anchor" href="#getting-started-cdc-consumer-define"></a> <a class="link" href="#getting-started-cdc-consumer-define">在欺诈检测服务的存储库中本地定义合同</a></h6>
<div class="paragraph">
<p>作为消费者，您需要定义要实现的目标。您需要制定自己的期望。为此，请编写以下合同：</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">将合同放在<code>src/test/resources/contracts/fraud</code>夹。的<code>fraud</code>文件夹很重要，因为生产者的测试基类名称引用了该文件夹。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了我们在Groovy和YAML中的合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package contracts

org.springframework.cloud.contract.spec.Contract.make {
    request { // (1)
        method 'PUT' // (2)
        url '/fraudcheck' // (3)
        body([ // (4)
               "client.id": $(regex('[0-9]{10}')),
               loanAmount : 99999
        ])
        headers { // (5)
            contentType('application/json')
        }
    }
    response { // (6)
        status OK() // (7)
        body([ // (8)
               fraudCheckStatus  : "FRAUD",
               "rejection.reason": "Amount too high"
        ])
        headers { // (9)
            contentType('application/json')
        }
    }
}

/*
From the Consumer perspective, when shooting a request in the integration test:

(1) - If the consumer sends a request
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the response will be sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` equal to `application/json`

From the Producer perspective, in the autogenerated producer-side test:

(1) - A request will be sent to the producer
(2) - With the "PUT" method
(3) - to the URL "/fraudcheck"
(4) - with the JSON body that
 * has a field `client.id` that will have a generated value that matches a regular expression `[0-9]{10}`
 * has a field `loanAmount` that is equal to `99999`
(5) - with header `Content-Type` equal to `application/json`
(6) - then the test will assert if the response has been sent with
(7) - status equal `200`
(8) - and JSON body equal to
 { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
(9) - with header `Content-Type` matching `application/json.*`
 */</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yaml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request: # (1)
  method: PUT # (2)
  url: /yamlfraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json


#From the Consumer perspective, when shooting a request in the integration test:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/yamlfraudcheck"
#(4) - with the JSON body that
# * has a field `client.id`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(6) - and a `client.id` json entry matches the regular expression `[0-9]{10}`
#(7) - then the response will be sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test:
#
#(1) - A request will be sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/yamlfraudcheck"
#(4) - with the JSON body that
# * has a field `client.id` `1234567890`
# * has a field `loanAmount` that is equal to `99999`
#(5) - with header `Content-Type` equal to `application/json`
#(7) - then the test will assert if the response has been sent with
#(8) - status equal `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejectionReason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>YML合同非常简单。但是，当您查看使用静态类型的Groovy DSL编写的Contract时，您可能会想知道<code>value(client(…​), server(…​))</code>零件是。通过使用这种表示法，Spring Cloud Contract可让您定义JSON块，URL或其他动态结构的部分。如果是标识符或时间戳，则无需对值进行硬编码。您要允许一些不同的值范围。要启用值的范围，可以为使用者方设置与这些值匹配的正则表达式。您可以通过地图符号或带插值的字符串来提供主体。我们强烈建议使用地图符号。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您必须了解地图符号才能设置合同。请参阅<a href="https://groovy-lang.org/json.html">有关JSON</a>的<a href="https://groovy-lang.org/json.html">Groovy文档</a> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面显示的合同是双方之间的协议，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果HTTP请求与所有</p>
<div class="ulist">
<ul>
<li>
<p>一种<code>PUT</code>上的方法<code>/fraudcheck</code>终点</p>
</li>
<li>
<p>带有<code>client.id</code>与正则表达式匹配<code>[0-9]{10}</code>和<code>loanAmount</code>等于<code>99999</code> ，</p>
</li>
<li>
<p>一种<code>Content-Type</code>标头值为<code>application/vnd.fraud.v1+json</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>然后将HTTP响应发送给使用者</p>
<div class="ulist">
<ul>
<li>
<p>有状态<code>200</code></p>
</li>
<li>
<p>包含一个带有<code>fraudCheckStatus</code>包含值的字段<code>FRAUD</code>和<code>rejectionReason</code>值为的字段<code>Amount too high</code></p>
</li>
<li>
<p>有个<code>Content-Type</code>标头值为<code>application/vnd.fraud.v1+json</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>一旦准备好在集成测试中实际检查API，就需要在本地安装存根。</p>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-add"><a class="anchor" href="#getting-started-cdc-consumer-add"></a> <a class="link" href="#getting-started-cdc-consumer-add">添加Spring Cloud Contract Verifier插件</a></h6>
<div class="paragraph">
<p>我们可以添加Maven或Gradle插件。在这个例子中，我们展示了如何添加Maven。首先，我们添加<code>Spring Cloud Contract</code> BOM，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud-release.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，添加<code>Spring Cloud Contract Verifier</code> Maven插件，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">            <plugin>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                <version>${spring-cloud-contract.version}</version>
                <extensions>true</extensions>
                <configuration>
                    <packageWithBaseClasses>com.example.fraud</packageWithBaseClasses>
<!--                    <convertToYaml>true</convertToYaml>-->
                </configuration>
                <!-- if additional dependencies are needed e.g. for Pact -->
                <dependencies>
                    <dependency>
                        <groupId>org.springframework.cloud</groupId>
                        <artifactId>spring-cloud-contract-pact</artifactId>
                        <version>${spring-cloud-contract.version}</version>
                    </dependency>
                </dependencies>
            </plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于添加了插件，您将获得<code>Spring Cloud Contract Verifier</code>功能，根据提供的合同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>生成并运行测试</p>
</li>
<li>
<p>制作并安装存根</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您不想生成测试，因为作为消费者，您只想玩存根。您需要跳过测试的生成和执行。为此，请运行以下命令：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ cd local-http-server-repo
$ ./mvnw clean install -DskipTests</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行这些命令后，您应该在日志中看到类似以下内容的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">[INFO] --- spring-cloud-contract-maven-plugin:1.0.0.BUILD-SNAPSHOT:generateStubs (default-generateStubs) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar
[INFO]
[INFO] --- maven-jar-plugin:2.6:jar (default-jar) @ http-server ---
[INFO] Building jar: /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar
[INFO]
[INFO] --- spring-boot-maven-plugin:1.5.5.BUILD-SNAPSHOT:repackage (default) @ http-server ---
[INFO]
[INFO] --- maven-install-plugin:2.5.2:install (default-install) @ http-server ---
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.jar
[INFO] Installing /some/path/http-server/pom.xml to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT.pom
[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下行非常重要：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">[INFO] Installing /some/path/http-server/target/http-server-0.0.1-SNAPSHOT-stubs.jar to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>它确认了<code>http-server</code>已安装在本地存储库中。</p>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-run"><a class="anchor" href="#getting-started-cdc-consumer-run"></a> <a class="link" href="#getting-started-cdc-consumer-run">运行集成测试</a></h6>
<div class="paragraph">
<p>为了从自动存根下载的Spring Cloud Contract Stub Runner功能中获利，您必须在用户端项目中执行以下操作（ <code>Loan Application service</code> ）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>添加<code>Spring Cloud Contract</code> BOM，如下：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud-release-train.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>将依赖项添加到<code>Spring Cloud Contract Stub Runner</code> ， 如下：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>使用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。在注释中，提供<code>group-id</code>和<code>artifact-id</code>供存根赛跑者下载协作者的存根。（可选步骤）由于您是与离线协作者一起玩，因此您还可以提供离线工作切换器（ <code>StubRunnerProperties.StubsMode.LOCAL</code> ）。</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
@AutoConfigureStubRunner(ids = {
        "com.example:http-server-dsl:0.0.1:stubs" }, stubsMode = StubRunnerProperties.StubsMode.LOCAL)
public class LoanApplicationServiceTests {</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在，在运行测试时，您会在日志中看到类似以下输出的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">2016-07-19 14:22:25.403  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Desired version is + - will try to resolve the latest version
2016-07-19 14:22:25.438  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved version is 0.0.1-SNAPSHOT
2016-07-19 14:22:25.439  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolving artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT using remote repositories []
2016-07-19 14:22:25.451  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Resolved artifact com.example:http-server:jar:stubs:0.0.1-SNAPSHOT to /path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar
2016-07-19 14:22:25.465  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacking stub from JAR [URI: file:/path/to/your/.m2/repository/com/example/http-server/0.0.1-SNAPSHOT/http-server-0.0.1-SNAPSHOT-stubs.jar]
2016-07-19 14:22:25.475  INFO 41050 --- [           main] o.s.c.c.stubrunner.AetherStubDownloader  : Unpacked file to [/var/folders/0p/xwq47sq106x1_g3dtv6qfm940000gq/T/contracts100276532569594265]
2016-07-19 14:22:27.737  INFO 41050 --- [           main] o.s.c.c.stubrunner.StubRunnerExecutor    : All stubs are now running RunningStubs [namesAndPorts={com.example:http-server:0.0.1-SNAPSHOT:stubs=8080}]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此输出意味着Stub Runner已找到您的存根，并为您的应用程序启动了服务器，其组ID为<code>com.example</code>和工件ID为<code>http-server</code>与版本<code>0.0.1-SNAPSHOT</code>存根的和<code>stubs</code>港口分类器<code>8080</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-file"><a class="anchor" href="#getting-started-cdc-consumer-file"></a> <a class="link" href="#getting-started-cdc-consumer-file">提交拉取请求</a></h6>
<div class="paragraph">
<p>到目前为止，您所做的是一个迭代过程。您可以试用合同，将其安装在本地，然后在用户端工作，直到合同按您的意愿运行。</p>
</div>
<div class="paragraph">
<p>对结果满意并通过测试后，可以将拉取请求发布到服务器端。目前，消费者方面的工作已经完成。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-cdc-producer"><a class="anchor" href="#getting-started-cdc-producer"></a> <a class="link" href="#getting-started-cdc-producer">生产者方（欺诈检测服务器）</a></h5>
<div class="paragraph">
<p>作为欺诈检测服务器（贷款发放服务的服务器）的开发人员，您可能需要执行以下操作</p>
</div>
<div class="ulist">
<ul>
<li>
<p>接管请求请求</p>
</li>
<li>
<p>编写缺少的实现</p>
</li>
<li>
<p>部署应用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下UML图显示了欺诈检测流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/getting-started-cdc-server.png" alt="入门cdc服务器" width="688" height="903">
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-producer-pr"><a class="anchor" href="#getting-started-cdc-producer-pr"></a> <a class="link" href="#getting-started-cdc-producer-pr">接管拉取请求</a></h6>
<div class="paragraph">
<p>提醒一下，以下清单显示了初始实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping(value = "/fraudcheck", method = PUT)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以运行以下命令：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git checkout -b contract-change-pr master
$ git pull https://your-git-server.com/server-side-fork.git contract-change-pr</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您必须添加自动生成的测试所需的依赖项，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-verifier</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在Maven插件的配置中，您必须传递<code>packageWithBaseClasses</code>属性，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">            <plugin>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                <version>${spring-cloud-contract.version}</version>
                <extensions>true</extensions>
                <configuration>
                    <packageWithBaseClasses>com.example.fraud</packageWithBaseClasses>
<!--                    <convertToYaml>true</convertToYaml>-->
                </configuration>
                <!-- if additional dependencies are needed e.g. for Pact -->
                <dependencies>
                    <dependency>
                        <groupId>org.springframework.cloud</groupId>
                        <artifactId>spring-cloud-contract-pact</artifactId>
                        <version>${spring-cloud-contract.version}</version>
                    </dependency>
                </dependencies>
            </plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本示例通过设置“ <code>packageWithBaseClasses</code>属性。这样做意味着最后两个软件包组合在一起以成为基础测试类的名称。在我们的案例中，合同被置于<code>src/test/resources/contracts/fraud</code> 。由于您没有从<code>contracts</code>文件夹，只选择一个，应该是<code>fraud</code> 。添加<code>Base</code>后缀和大写<code>fraud</code> 。那给你<code>FraudBase</code>测试类别名称。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>所有生成的测试都扩展了该类。在那儿，您可以设置您的Spring Context或任何必要的东西。在这种情况下，您应该使用<a href="https://github.com/rest-assured/rest-assured">Rest Assured MVC</a>启动服务器端<code>FraudDetectionController</code> 。以下清单显示了<code>FraudBase</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.fraud;

import io.restassured.module.mockmvc.RestAssuredMockMvc;
import org.junit.Before;

public class FraudBase {

    @Before
    public void setup() {
        RestAssuredMockMvc.standaloneSetup(new FraudDetectionController(),
                new FraudStatsController(stubbedStatsProvider()));
    }

    private StatsProvider stubbedStatsProvider() {
        return fraudType -> {
            switch (fraudType) {
            case DRUNKS:
                return 100;
            case ALL:
                return 200;
            }
            return 0;
        };
    }

    public void assertThatRejectionReasonIsNull(Object rejectionReason) {
        assert rejectionReason == null;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，如果您运行<code>./mvnw clean install</code> ，您将获得类似以下输出的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">Results :

Tests in error:
  ContractVerifierTest.validate_shouldMarkClientAsFraud:32 » IllegalState Parsed...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>发生此错误的原因是您有一个新合同，从中生成了一个测试，但由于未实现该功能而失败了。自动生成的测试应类似于以下测试方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void validate_shouldMarkClientAsFraud() throws Exception {
    // given:
        MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/vnd.fraud.v1+json")
                .body("{\"client.id\":\"1234567890\",\"loanAmount\":99999}");

    // when:
        ResponseOptions response = given().spec(request)
                .put("/fraudcheck");

    // then:
        assertThat(response.statusCode()).isEqualTo(200);
        assertThat(response.header("Content-Type")).matches("application/vnd.fraud.v1.json.*");
    // and:
        DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
        assertThatJson(parsedJson).field("['fraudCheckStatus']").matches("[A-Z]{5}");
        assertThatJson(parsedJson).field("['rejection.reason']").isEqualTo("Amount too high");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用了Groovy DSL，则可以看到所有<code>producer()</code>合同中存在于<code>value(consumer(…​), producer(…​))</code>块被注入到测试中。如果使用YAML，则同样适用于<code>matchers</code>的部分<code>response</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，在生产者方面，您也在执行TDD。期望以测试的形式表达。此测试使用合同中定义的URL，标头和正文向我们自己的应用程序发送请求。它还期望响应中精确定义的值。换句话说，您拥有<code>red</code>部分<code>red</code> ， <code>green</code>和<code>refactor</code> 。现在是时候转换<code>red</code>进入<code>green</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-producer-impl"><a class="anchor" href="#getting-started-cdc-producer-impl"></a> <a class="link" href="#getting-started-cdc-producer-impl">编写缺少的实现</a></h6>
<div class="paragraph">
<p>因为您知道预期的输入和预期的输出，所以可以编写缺少的实现，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RequestMapping(value = "/fraudcheck", method = PUT)
public FraudCheckResult fraudCheck(@RequestBody FraudCheck fraudCheck) {
if (amountGreaterThanThreshold(fraudCheck)) {
    return new FraudCheckResult(FraudCheckStatus.FRAUD, AMOUNT_TOO_HIGH);
}
return new FraudCheckResult(FraudCheckStatus.OK, NO_REASON);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当你跑步<code>./mvnw clean install</code>再次，测试通过了。自从<code>Spring Cloud Contract Verifier</code>插件将测试添加到<code>generated-test-sources</code> ，您实际上可以从IDE运行这些测试。</p>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-producer-deploy"><a class="anchor" href="#getting-started-cdc-producer-deploy"></a> <a class="link" href="#getting-started-cdc-producer-deploy">部署您的应用</a></h6>
<div class="paragraph">
<p>完成工作后，即可部署更改。为此，必须首先通过运行以下命令合并分支：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git checkout master
$ git merge --no-ff contract-change-pr
$ git push origin master</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您的CI可能会运行诸如以下命令<code>./mvnw clean deploy</code> ，这将同时发布应用程序和存根工件。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="getting-started-cdc-consumer-final"><a class="anchor" href="#getting-started-cdc-consumer-final"></a> <a class="link" href="#getting-started-cdc-consumer-final">消费者方（贷款发行），最后一步</a></h5>
<div class="paragraph">
<p>作为贷款发行服务的开发人员（欺诈检测服务器的使用者），我希望：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>合并我们的功能分支到<code>master</code></p>
</li>
<li>
<p>切换到在线工作模式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下UML图显示了流程的最终状态：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/getting-started-cdc-client-final.png" alt="CDC客户端入门入门" width="590" height="685">
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-final-merge"><a class="anchor" href="#getting-started-cdc-consumer-final-merge"></a> <a class="link" href="#getting-started-cdc-consumer-final-merge">合并分支到母版</a></h6>
<div class="paragraph">
<p>以下命令显示了使用Git将分支合并到master的一种方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git checkout master
$ git merge --no-ff contract-change-pr</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="getting-started-cdc-consumer-final-online"><a class="anchor" href="#getting-started-cdc-consumer-final-online"></a> <a class="link" href="#getting-started-cdc-consumer-final-online">在线工作</a></h6>
<div class="paragraph">
<p>现在，您可以禁用Spring Cloud Contract Stub Runner的脱机工作，并指定包含您的存根的存储库所在的位置。此时，服务器端的存根会自动从Nexus / Artifactory下载。您可以设置的值<code>stubsMode</code>至<code>REMOTE</code> 。以下代码显示了通过更改属性来实现相同目的的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner:
  ids: 'com.example:http-server-dsl:+:stubs:8080'
  repositoryRoot: https://repo.spring.io/libs-snapshot</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>而已。您已经完成了本教程。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="getting-started-whats-next"><a class="anchor" href="#getting-started-whats-next"></a> <a class="link" href="#getting-started-whats-next">14.1.5。下一步</a></h4>
<div class="paragraph">
<p>希望本节提供一些Spring Cloud Contract基础知识，并帮助您编写自己的应用程序。如果您是面向任务的开发人员，则可能要跳到<a href="https://spring.io" class="bare">spring.io</a>并查看一些解决特定“我如何使用Spring进行操作”的<a href="https://spring.io/guides/">入门</a>指南。问题。我们也有特定<a href="howto.html#howto">于</a> Spring Cloud Contract的“操作<a href="howto.html#howto">方法</a> ”参考文档。</p>
</div>
<div class="paragraph">
<p>否则，下一个逻辑步骤是阅读<a href="using.html#using">Using Spring Cloud Contract</a> 。如果您真的很急，还可以继续阅读并了解<a href="project-features.html#project-features">Spring Cloud Contract功能</a> 。</p>
</div>
<div class="paragraph">
<p>除此之外，您还可以观看以下视频：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Olga Maciaszek-Sharma和Marcin Grzejszczak撰写的“消费者驱动的合同和您的微服务架构”</p>
</li>
</ul>
</div>
<div class="videoblock">
<div class="content">
<iframe width="640" height="480" src="https://www.youtube.com/embed/pDkC_00hhvA?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Marcin Grzejszczak撰写的“企业合同测试”</p>
</li>
</ul>
</div>
<div class="videoblock">
<div class="content">
<iframe width="640" height="480" src="https://www.youtube.com/embed/ZyHG-VOzPZg?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>“为什么合同测试很重要？“作者：Marcin Grzejszczak</p>
</li>
</ul>
</div>
<div class="videoblock">
<div class="content">
<iframe width="640" height="480" src="https://www.youtube.com/embed/TvpkZu1e2Dc?rel=0&start=6262" frameborder="0" allowfullscreen></iframe>
</div>
</div>
<div class="paragraph">
<p>您可以在<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">samples中</a>找到默认的项目<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">示例</a> 。</p>
</div>
<div class="paragraph">
<p>您可以在<a href="https://cloud-samples.spring.io/spring-cloud-contract-samples/">此处</a>找到Spring Cloud Contract研讨会。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using"><a class="anchor" href="#using"></a> <a class="link" href="#using">14.2。使用Spring Cloud Contract</a></h3>
<div class="paragraph">
<p>本节将详细介绍如何使用Spring Cloud Contract。它涵盖了诸如如何使用Spring Cloud Contract的流程之类的主题。我们还将介绍一些Spring Cloud Contract最佳实践。</p>
</div>
<div class="paragraph">
<p>如果您是从Spring Cloud Contract开始的，那么在深入本节之前，您应该阅读<a href="getting-started.html#getting-started">入门指南</a> 。</p>
</div>
<div class="sect3">
<h4 id="flows-provider-nexus"><a class="anchor" href="#flows-provider-nexus"></a> <a class="link" href="#flows-provider-nexus">14.2.1。使用Nexus或Artifactory中的存根进行提供商合同测试</a></h4>
<div class="paragraph">
<p>您可以检查“ <a href="getting-started.html#getting-started-first-application">开发基于第一个Spring Cloud Contract的应用程序”</a>链接，以查看带有Nexus或Artifactory流中的存根的提供商合同测试。</p>
</div>
<div class="paragraph">
<p>您也可以查看<a href="https://cloud-samples.spring.io/spring-cloud-contract-samples/tutorials/contracts_on_the_producer_side.html">研讨会页面</a> ，以获取有关如何执行此流程的分步说明。</p>
</div>
</div>
<div class="sect3">
<h4 id="flows-provider-git"><a class="anchor" href="#flows-provider-git"></a> <a class="link" href="#flows-provider-git">14.2.2。使用Git中的存根进行提供商合同测试</a></h4>
<div class="paragraph">
<p>在此流程中，我们执行提供者合同测试（生产者不了解消费者如何使用其API）。存根被上传到单独的存储库（它们没有被上传到Artifactory或Nexus）。</p>
</div>
<div class="sect4">
<h5 id="prerequisites"><a class="anchor" href="#prerequisites"></a> <a class="link" href="#prerequisites">先决条件</a></h5>
<div class="paragraph">
<p>在使用git中的存根测试提供者合同之前，必须提供一个git存储库，其中包含每个生产者的所有存根。有关此类项目的示例，请参见此<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//contract_git">样本</a>或<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//contract_git">该样本</a> 。由于将存根推送到那里，因此存储库具有以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>$ tree .
└── META-INF
   └── folder.with.group.id.as.its.name
       └── folder-with-artifact-id
           └── folder-with-version
               ├── contractA.groovy
               ├── contractB.yml
               └── contractC.groovy</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还必须提供设置了Spring Cloud Contract Stub Runner的使用者代码。有关此类项目的示例，请参见此<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//consumer">示例</a>并搜索<code>BeerControllerGitTest</code>测试。您还必须提供设置了Spring Cloud Contract的生产者代码以及一个插件。有关此类项目的示例，请参见此<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//producer_with_empty_git">样本</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-git-flow"><a class="anchor" href="#flows-provider-git-flow"></a> <a class="link" href="#flows-provider-git-flow">流</a></h5>
<div class="paragraph">
<p>该流程看起来与<a href="getting-started.html#getting-started-first-application">开发基于第一个Spring Cloud Contract的应用程序中</a>介绍的流程完全相同，但是<code>Stub Storage</code>实现是一个git仓库。</p>
</div>
<div class="paragraph">
<p>您可以在文档的“ <a href="howto.html#how-to-use-git-as-storage">如何”页面</a>上阅读有关设置git存储库以及设置使用者和生产者端的更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-git-consumer"><a class="anchor" href="#flows-provider-git-consumer"></a> <a class="link" href="#flows-provider-git-consumer">消费者设置</a></h5>
<div class="paragraph">
<p>为了从git储存库而不是Nexus或Artifactory中获取存根，您需要使用<code>git</code>网址中的协议<code>repositoryRoot</code> Stub Runner中的属性。以下示例显示了如何进行设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">注解</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        repositoryRoot = "git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git",
        ids = "com.example:artifact-id:0.0.1")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 4规则</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
    public StubRunnerRule rule = new StubRunnerRule()
            .downloadStub("com.example","artifact-id", "0.0.1")
            .repoRoot("git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 5扩展</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RegisterExtension
    public StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
            .downloadStub("com.example","artifact-id", "0.0.1")
            .repoRoot("git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-git-producer"><a class="anchor" href="#flows-provider-git-producer"></a> <a class="link" href="#flows-provider-git-producer">设置生产者</a></h5>
<div class="paragraph">
<p>为了将存根而不是Nexus或Artifactory推送到git存储库，您需要使用<code>git</code>插件设置网址中的协议。另外，您还需要在构建过程结束时明确告诉插件将存根推送。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- Base class mappings etc. -->

        <!-- We want to pick contracts from a Git repository -->
        <contractsRepositoryUrl>git://git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git</contractsRepositoryUrl>

        <!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts -->
        <contractDependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>${project.artifactId}</artifactId>
            <version>${project.version}</version>
        </contractDependency>

        <!-- The contracts mode can't be classpath -->
        <contractsMode>REMOTE</contractsMode>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal -->
                <goal>pushStubsToScm</goal>
            </goals>
        </execution>
    </executions>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    // We want to pick contracts from a Git repository
    contractDependency {
        stringNotation = "${project.group}:${project.name}:${project.version}"
    }
    /*
    We reuse the contract dependency section to set up the path
    to the folder that contains the contract definitions. In our case the
    path will be /groupId/artifactId/version/contracts
     */
    contractRepository {
        repositoryUrl = "git://git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git"
    }
    // The mode can't be classpath
    contractsMode = "REMOTE"
    // Base class mappings etc.
}

/*
In this scenario we want to publish stubs to SCM whenever
the `publish` task is executed
*/
publish.dependsOn("publishStubsToScm")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在文档的“ <a href="howto.html#how-to-use-git-as-storage">如何”页面</a>上阅读有关设置git存储库的更多信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="flows-cdc-contracts-producer"><a class="anchor" href="#flows-cdc-contracts-producer"></a> <a class="link" href="#flows-cdc-contracts-producer">14.2.3。消费者驱动的合同与生产方的合同</a></h4>
<div class="paragraph">
<p>请参阅<a href="getting-started.html#getting-started-cdc">在生产方附带合同的消费者驱动合同的逐步指南（CDC），</a>以查看在生产方附带合同的消费者驱动合同。</p>
</div>
</div>
<div class="sect3">
<h4 id="flows-cdc-contracts-external"><a class="anchor" href="#flows-cdc-contracts-external"></a> <a class="link" href="#flows-cdc-contracts-external">14.2.4。消费者驱动的合同与外部存储库中的合同</a></h4>
<div class="paragraph">
<p>在此流程中，我们执行消费者驱动的合同测试。合同定义存储在单独的存储库中。</p>
</div>
<div class="paragraph">
<p>有关如何执行此流程的分步说明，请参见<a href="https://cloud-samples.spring.io/spring-cloud-contract-samples/tutorials/contracts_on_the_producer_side.html">研讨会页面</a> 。</p>
</div>
<div class="sect4">
<h5 id="prerequisites-2"><a class="anchor" href="#prerequisites-2"></a> <a class="link" href="#prerequisites-2">先决条件</a></h5>
<div class="paragraph">
<p>要将消费者驱动的合同与外部存储库中保存的合同一起使用，您需要设置一个git存储库，该存储库可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含每个生产者的所有合同定义。</p>
</li>
<li>
<p>可以将合同定义打包在JAR中。</p>
</li>
<li>
<p>对于每个合同生产者，包含一个方法（例如， <code>pom.xml</code> ）通过Spring Cloud Contract插件（SCC插件）在本地安装存根</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多信息，请参见方法<a href="howto.html#how-to-common-repo-with-contracts">部分</a> ，我们在其中描述了如何建立这样的存储库。有关此类项目的示例，请参见此<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//beer_contracts">样本</a> 。</p>
</div>
<div class="paragraph">
<p>您还需要设置了Spring Cloud Contract Stub Runner的使用者代码。有关此类项目的示例，请参见此<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//consumer">样本</a> 。您还需要设置了Spring Cloud Contract的生产者代码以及一个插件。有关此类项目的示例，请参见此<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x//producer_with_external_contracts">样本</a> 。存根存储是Nexus或Artifactory</p>
</div>
<div class="paragraph">
<p>从高层次看，流程如下所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用者使用来自单独存储库的合同定义</p>
</li>
<li>
<p>一旦使用方的工作完成，则在使用方的工作分支将完成，并向保存合同定义的单独存储库发出拉取请求。</p>
</li>
<li>
<p>生产者将拉动请求接管到具有合同定义的单独存储库，并在本地安装所有合同的JAR。</p>
</li>
<li>
<p>生产者从本地存储的JAR中生成测试，并编写缺少的实现以使测试通过。</p>
</li>
<li>
<p>生产者的工作完成后，将合并对包含合同定义的存储库的拉取请求。</p>
</li>
<li>
<p>在CI工具使用合同定义构建存储库并将具有合同定义的JAR上传到Nexus或Artifactory之后，生产者可以合并其分支。</p>
</li>
<li>
<p>最终，消费者可以切换到在线工作以从远程位置获取生产者的存根，并且分支可以合并到主节点。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="flows-cdc-contracts-external-consumer"><a class="anchor" href="#flows-cdc-contracts-external-consumer"></a> <a class="link" href="#flows-cdc-contracts-external-consumer">消费者流</a></h5>
<div class="paragraph">
<p>消费者：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>编写一个测试，该测试将向生产者发送请求。</p>
<div class="paragraph">
<p>由于没有服务器，测试失败。</p>
</div>
</li>
<li>
<p>克隆保存合同定义的存储库。</p>
</li>
<li>
<p>在具有消费者名称作为生产者子文件夹的文件夹下的合同中设置需求。</p>
<div class="paragraph">
<p>例如，对于一个名为<code>producer</code>和一个名为<code>consumer</code> ，合同将存储在<code>src/main/resources/contracts/producer/consumer/</code> ）</p>
</div>
</li>
<li>
<p>定义合同后，将生产者存根安装到本地存储，如以下示例所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>$ cd src/main/resource/contracts/producer
$ ./mvnw clean install</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>在使用者测试中设置Spring Cloud Contract（SCC）Stub Runner，以：</p>
<div class="ulist">
<ul>
<li>
<p>从本地存储中获取生产者存根。</p>
</li>
<li>
<p>在“每个消费者的存根”模式下工作（这将启用“消费者驱动的合同”模式）。</p>
<div class="paragraph">
<p>SCC存根赛跑者：</p>
</div>
</li>
<li>
<p>获取生产者存根。</p>
</li>
<li>
<p>使用生产者存根运行内存中的HTTP服务器存根。</p>
</li>
<li>
<p>现在，您的测试与HTTP服务器存根进行通信，并且测试通过了</p>
</li>
<li>
<p>使用合同定义向存储库创建拉取请求，并为生产者提供新合同</p>
</li>
<li>
<p>分支您的消费者代码，直到生产者团队合并他们的代码</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下UML图显示了使用者流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/flow-overview-consumer-cdc-external-consumer.png" alt="流程概览消费者cdc外部消费者" width="886" height="676">
</div>
</div>
</div>
<div class="sect4">
<h5 id="flows-cdc-contracts-external-producer"><a class="anchor" href="#flows-cdc-contracts-external-producer"></a> <a class="link" href="#flows-cdc-contracts-external-producer">生产者流</a></h5>
<div class="paragraph">
<p>制片人：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用合同定义接管对存储库的拉取请求。您可以从命令行执行此操作，如下所示</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>$ git checkout -b the_branch_with_pull_request master
git pull https://github.com/user_id/project_name.git the_branch_with_pull_request</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>安装合同定义，如下所示</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw clean install</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>设置插件以从JAR而不是从JAR获取合同定义<code>src/test/resources/contracts</code> ， 如下：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- We want to use the JAR with contracts with the following coordinates -->
        <contractDependency>
            <groupId>com.example</groupId>
            <artifactId>beer-contracts</artifactId>
        </contractDependency>
        <!-- The JAR with contracts should be taken from Maven local -->
        <contractsMode>LOCAL</contractsMode>
        <!-- ... additional configuration -->
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    // We want to use the JAR with contracts with the following coordinates
    // group id `com.example`, artifact id `beer-contracts`, LATEST version and NO classifier
    contractDependency {
        stringNotation = 'com.example:beer-contracts:+:'
    }
    // The JAR with contracts should be taken from Maven local
    contractsMode = "LOCAL"
    // Additional configuration
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>运行生成以生成测试和存根，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw clean install</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">./gradlew clean build</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>编写缺少的实现，以使测试通过。</p>
</li>
<li>
<p>将拉取请求与合同定义合并到存储库中，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>$ git commit -am "Finished the implementation to make the contract tests pass"
$ git checkout master
$ git merge --no-ff the_branch_with_pull_request
$ git push origin master</pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>CI系统使用合同定义构建项目，并将具有合同定义的JAR上载到Nexus或Artifactory。</p>
</li>
<li>
<p>切换到远程工作。</p>
</li>
<li>
<p>设置插件，以便不再从本地存储而是从远程位置获取合同定义，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- We want to use the JAR with contracts with the following coordinates -->
        <contractDependency>
            <groupId>com.example</groupId>
            <artifactId>beer-contracts</artifactId>
        </contractDependency>
        <!-- The JAR with contracts should be taken from a remote location -->
        <contractsMode>REMOTE</contractsMode>
        <!-- ... additional configuration -->
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    // We want to use the JAR with contracts with the following coordinates
    // group id `com.example`, artifact id `beer-contracts`, LATEST version and NO classifier
    contractDependency {
        stringNotation = 'com.example:beer-contracts:+:'
    }
    // The JAR with contracts should be taken from a remote location
    contractsMode = "REMOTE"
    // Additional configuration
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>将生产者代码与新实现合并。</p>
</li>
<li>
<p>CI系统：</p>
<div class="ulist">
<ul>
<li>
<p>建立项目</p>
</li>
<li>
<p>生成测试，存根和存根JAR</p>
</li>
<li>
<p>将带有应用程序和存根的工件上载到Nexus或Artifactory。</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下UML图显示了生产者流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/flow-overview-consumer-cdc-external-producer.png" alt="流程概览消费者cdc外部生产者" width="1213" height="1341">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="flows-cdc-contracts-stubs-git"><a class="anchor" href="#flows-cdc-contracts-stubs-git"></a> <a class="link" href="#flows-cdc-contracts-stubs-git">14.2.5。消费者驱动的合同与生产方的合同，被推到了Git</a></h4>
<div class="paragraph">
<p>您可以查看<a href="getting-started.html#getting-started-cdc">包含在生产方的合同的《消费者驱动合同的逐步指南》（CDC），</a>以查看包含<a href="getting-started.html#getting-started-cdc">生产方的</a>合同的消费者驱动的合同。</p>
</div>
<div class="paragraph">
<p>存根存储实现是一个git存储库。我们将<a href="#flows-provider-git">在Git中的带有存根</a>的<a href="#flows-provider-git">提供商合同测试</a>部分中描述其设置。</p>
</div>
<div class="paragraph">
<p>您可以在文档的“ <a href="howto.html#how-to-use-git-as-storage">如何”页面</a>上阅读有关为消费者和生产者端设置git存储库的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="flows-provider-non-spring"><a class="anchor" href="#flows-provider-non-spring"></a> <a class="link" href="#flows-provider-non-spring">14.2.6。对于非Spring应用程序，使用工厂中的存根进行提供商合同测试</a></h4>
<div class="sect4">
<h5 id="flows-provider-non-spring-flow"><a class="anchor" href="#flows-provider-non-spring-flow"></a> <a class="link" href="#flows-provider-non-spring-flow">流</a></h5>
<div class="paragraph">
<p>您可以检查<a href="getting-started.html#getting-started-first-application">开发基于第一个Spring Cloud Contract的应用程序，</a>以查看带有Nexus或Artifactory中的存根的提供商合同测试的流程。</p>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-non-spring-consumer"><a class="anchor" href="#flows-provider-non-spring-consumer"></a> <a class="link" href="#flows-provider-non-spring-consumer">设置消费者</a></h5>
<div class="paragraph">
<p>对于使用者，可以使用JUnit规则。这样，您无需启动Spring上下文。以下清单显示了这样的规则（在JUnit4和JUnit 5中）；</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">JUnit 4规则</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
    public StubRunnerRule rule = new StubRunnerRule()
            .downloadStub("com.example","artifact-id", "0.0.1")
            .repoRoot("git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 5扩展</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
    public StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
            .downloadStub("com.example","artifact-id", "0.0.1")
            .repoRoot("git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-non-spring-producer"><a class="anchor" href="#flows-provider-non-spring-producer"></a> <a class="link" href="#flows-provider-non-spring-producer">设置生产者</a></h5>
<div class="paragraph">
<p>默认情况下，Spring Cloud Contract插件使用Rest Assured的<code>MockMvc</code>设置生成的测试。由于非Spring应用程序不使用<code>MockMvc</code> ，您可以更改<code>testMode</code>至<code>EXPLICIT</code>向在特定端口绑定的应用程序发送真实请求。</p>
</div>
<div class="paragraph">
<p>在此示例中，我们使用称为<a href="https://javalin.io">Javalin</a>的框架来启动非Spring HTTP服务器。</p>
</div>
<div class="paragraph">
<p>假设我们有以下应用程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.demo;

import io.javalin.Javalin;

public class DemoApplication {

    public static void main(String[] args) {
        new DemoApplication().run(7000);
    }

    public Javalin start(int port) {
        return Javalin.create().start(port);
    }

    public Javalin registerGet(Javalin app) {
        return app.get("/", ctx -> ctx.result("Hello World"));
    }

    public Javalin run(int port) {
        return registerGet(start(port));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有了该应用程序，我们可以将插件设置为使用<code>EXPLICIT</code>模式（即向真实端口发送请求），如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <baseClassForTests>com.example.demo.BaseClass</baseClassForTests>
        <!-- This will setup the EXPLICIT mode for the tests -->
        <testMode>EXPLICIT</testMode>
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    // This will setup the EXPLICIT mode for the tests
    testMode = "EXPLICIT"
    baseClassForTests = "com.example.demo.BaseClass"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>基类可能类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.javalin.Javalin;
import io.restassured.RestAssured;
import org.junit.After;
import org.junit.Before;
import org.springframework.util.SocketUtils;

public class BaseClass {

    Javalin app;

    @Before
    public void setup() {
        // pick a random port
        int port = SocketUtils.findAvailableTcpPort();
        // start the application at a random port
        this.app = start(port);
        // tell Rest Assured where the started application is
        RestAssured.baseURI = "http://localhost:" + port;
    }

    @After
    public void close() {
        // stop the server after each test
        this.app.stop();
    }

    private Javalin start(int port) {
        // reuse the production logic to start a server
        return new DemoApplication().run(port);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这样的设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们已经设置了Spring Cloud Contract插件以使用<code>EXPLICIT</code>模式发送真实请求而不是模拟请求。</p>
</li>
<li>
<p>我们定义了一个基类：</p>
<div class="ulist">
<ul>
<li>
<p>在每个测试的随机端口上启动HTTP服务器。</p>
</li>
<li>
<p>设置“确保放心”以将请求发送到该端口。</p>
</li>
<li>
<p>每次测试后关闭HTTP服务器。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="flows-provider-non-jvm"><a class="anchor" href="#flows-provider-non-jvm"></a> <a class="link" href="#flows-provider-non-jvm">14.2.7。在非JVM环境中使用工厂中的存根进行提供商合同测试</a></h4>
<div class="paragraph">
<p>在此流程中，我们假设：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API Producer和API Consumer是非JVM应用程序。</p>
</li>
<li>
<p>合同定义使用YAML编写。</p>
</li>
<li>
<p>存根存储是Artifactory或Nexus。</p>
</li>
<li>
<p>使用Spring Cloud Contract Docker（SCC Docker）和Spring Cloud Contract Stub Runner Docker（SCC Stub Runner Docker）映像。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以<a href="#docker-project.adoc">在此页面上</a>阅读有关如何在Docker上使用Spring Cloud Contract的更多信息。</p>
</div>
<div class="paragraph">
<p><a href="https://spring.io/blog/2018/02/13/spring-cloud-contract-in-a-polyglot-world">在这里</a> ，您可以阅读有关如何在多语言世界中使用Spring Cloud Contract的博客文章。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs/">在这里</a> ，您可以找到一个使用Spring Cloud Contract作为生产者和消费者的NodeJS应用程序示例。</p>
</div>
<div class="sect4">
<h5 id="flows-provider-non-jvm-producer"><a class="anchor" href="#flows-provider-non-jvm-producer"></a> <a class="link" href="#flows-provider-non-jvm-producer">生产者流</a></h5>
<div class="paragraph">
<p>在较高的水平上，生产者：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>编写合同定义（例如，在YAML中）。</p>
</li>
<li>
<p>将构建工具设置为：</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>在给定端口上使用模拟服务启动应用程序。</p>
<div class="paragraph">
<p>如果无法进行模拟，则可以设置基础结构并以有状态的方式定义测试。</p>
</div>
</li>
<li>
<p>运行Spring Cloud Contract Docker映像，并将正在运行的应用程序的端口作为环境变量传递。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>SCC Docker映像：*从随附的卷生成测试。*针对正在运行的应用程序运行测试。</p>
</div>
<div class="paragraph">
<p>测试完成后，存根将被上传到存根存储站点（例如Artifactory或Git）。</p>
</div>
<div class="paragraph">
<p>以下UML图显示了生产者流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/flows-provider-non-jvm-producer.png" alt="流提供者非jvm生产者" width="930" height="810">
</div>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-non-jvm-consumer"><a class="anchor" href="#flows-provider-non-jvm-consumer"></a> <a class="link" href="#flows-provider-non-jvm-consumer">消费者流</a></h5>
<div class="paragraph">
<p>从高层次上讲，消费者：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将构建工具设置为：</p>
<div class="ulist">
<ul>
<li>
<p>启动Spring Cloud Contract Stub Runner Docker映像并启动存根。</p>
<div class="paragraph">
<p>环境变量配置：</p>
</div>
</li>
<li>
<p>要获取的存根。</p>
</li>
<li>
<p>存储库的位置。</p>
<div class="paragraph">
<p>注意：</p>
</div>
</li>
<li>
<p>要使用本地存储，您还可以将其作为卷附加。</p>
</li>
<li>
<p>存根运行所在的端口需要暴露。</p>
</li>
</ul>
</div>
</li>
<li>
<p>针对正在运行的存根运行应用程序测试。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下UML图显示了使用者流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/flows-provider-non-jvm-consumer.png" alt="流提供者非jvm使用者" width="815" height="618">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="flows-provider-rest-docs"><a class="anchor" href="#flows-provider-rest-docs"></a> <a class="link" href="#flows-provider-rest-docs">14.2.8。使用Nexus或Artifactory中的REST文档和存根进行提供商合同测试</a></h4>
<div class="paragraph">
<p>在此流程中，我们不使用Spring Cloud Contract插件来生成测试和存根。我们编写<a href="https://spring.io/projects/spring-restdocs">Spring RESTDocs，</a>并从中自动生成存根。最后，我们设置了构建以打包存根并将其上载到存根存储站点（在我们的情况下为Nexus或Artifactory）。</p>
</div>
<div class="paragraph">
<p>有关如何使用此流程的分步说明，请参见<a href="https://cloud-samples.spring.io/spring-cloud-contract-samples/tutorials/rest_docs.html">研讨会页面</a> 。</p>
</div>
<div class="sect4">
<h5 id="flows-provider-rest-docs-producer"><a class="anchor" href="#flows-provider-rest-docs-producer"></a> <a class="link" href="#flows-provider-rest-docs-producer">生产者流</a></h5>
<div class="paragraph">
<p>作为制作人，我们：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>我们编写API的RESTDocs测试。</p>
</li>
<li>
<p>我们将Spring Cloud Contract Stub Runner启动器添加到我们的构建中（ <code>spring-cloud-starter-contract-stub-runner</code> ）， 如下</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    testImplementation 'org.springframework.cloud:spring-cloud-starter-contract-stub-runner'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>我们设置了构建工具来打包存根，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><!-- pom.xml -->
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-assembly-plugin</artifactId>
        <executions>
            <execution>
                <id>stub</id>
                <phase>prepare-package</phase>
                <goals>
                    <goal>single</goal>
                </goals>
                <inherited>false</inherited>
                <configuration>
                    <attach>true</attach>
                    <descriptors>
                        ${basedir}/src/assembly/stub.xml
                    </descriptors>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>

<!-- src/assembly/stub.xml -->
<assembly
    xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd">
    <id>stubs</id>
    <formats>
        <format>jar</format>
    </formats>
    <includeBaseDirectory>false</includeBaseDirectory>
    <fileSets>
        <fileSet>
            <directory>${project.build.directory}/generated-snippets/stubs</directory>
            <outputDirectory>META-INF/${project.groupId}/${project.artifactId}/${project.version}/mappings</outputDirectory>
            <includes>
                <include>**/*</include>
            </includes>
        </fileSet>
    </fileSets>
</assembly></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task stubsJar(type: Jar) {
    classifier = "stubs"
    into("META-INF/${project.group}/${project.name}/${project.version}/mappings") {
        include('**/*.*')
        from("${project.buildDir}/generated-snippets/stubs")
    }
}
// we need the tests to pass to build the stub jar
stubsJar.dependsOn(test)
bootJar.dependsOn(stubsJar)</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在，当我们运行测试时，存根将自动发布并打包。</p>
</div>
<div class="paragraph">
<p>以下UML图显示了生产者流程：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/flows-provider-rest-docs-producer.png" alt="流量提供者其余文档产生者" width="783" height="677">
</div>
</div>
</div>
<div class="sect4">
<h5 id="flows-provider-rest-docs-consumer"><a class="anchor" href="#flows-provider-rest-docs-consumer"></a> <a class="link" href="#flows-provider-rest-docs-consumer">消费者流</a></h5>
<div class="paragraph">
<p>由于使用者流程不受用于生成存根的工具的影响，因此您可以选中“ <a href="getting-started.html#getting-started-first-application-consumer">开发基于第一个Spring Cloud Contract的应用程序”，</a>以查看Nexus或Artifactory中存根的提供商合同测试的消费者方流程。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-whats-next"><a class="anchor" href="#using-whats-next"></a> <a class="link" href="#using-whats-next">14.2.9。接下来要读什么</a></h4>
<div class="paragraph">
<p>现在，您应该了解如何使用Spring Cloud Contract和应遵循的一些最佳实践。现在，您可以继续学习特定的<a href="project-features.html#project-features">Spring Cloud Contract功能</a> ，或者可以跳过并阅读有关<a href="advanced.html">Spring Cloud Contract</a>的<a href="advanced.html">高级功能</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="features"><a class="anchor" href="#features"></a> <a class="link" href="#features">14.3。Spring Cloud合约功能</a></h3>
<div class="paragraph">
<p>本节将深入探讨Spring Cloud Contract的细节。在这里，您可以了解可能要使用和自定义的关键功能。如果您尚未这样做，则可能需要阅读“ <a href="using.html#using">Getting</a> <a href="getting-started.html#getting-started">-started.html</a> ”和“ <a href="using.html#using">using.html</a> ”部分，以便您有足够的基础知识。</p>
</div>
<div class="sect3">
<h4 id="contract-dsl"><a class="anchor" href="#contract-dsl"></a> <a class="link" href="#contract-dsl">14.3.1。合约DSL</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract支持以以下语言编写的DSL：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Groovy</p>
</li>
<li>
<p>YAML</p>
</li>
<li>
<p>爪哇</p>
</li>
<li>
<p>科特林</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">Spring Cloud Contract支持在单个文件中定义多个合同。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示合同定义：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'PUT'
        url '/api/12'
        headers {
            header 'Content-Type': 'application/vnd.org.springframework.cloud.contract.verifier.twitter-places-analyzer.v1+json'
        }
        body '''\
    [{
        "created_at": "Sat Jul 26 09:38:57 +0000 2014",
        "id": 492967299297845248,
        "id_str": "492967299297845248",
        "text": "Gonna see you at Warsaw",
        "place":
        {
            "attributes":{},
            "bounding_box":
            {
                "coordinates":
                    [[
                        [-77.119759,38.791645],
                        [-76.909393,38.791645],
                        [-76.909393,38.995548],
                        [-77.119759,38.995548]
                    ]],
                "type":"Polygon"
            },
            "country":"United States",
            "country_code":"US",
            "full_name":"Washington, DC",
            "id":"01fbe706f872cb32",
            "name":"Washington",
            "place_type":"city",
            "url": "https://api.twitter.com/1/geo/id/01fbe706f872cb32.json"
        }
    }]
'''
    }
    response {
        status OK()
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">description: Some description
name: some name
priority: 8
ignored: true
request:
  url: /foo
  queryParameters:
    a: b
    b: c
  method: PUT
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
    nullValue: null
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
      - path: $.nullValue
        type: by_null
        value: null
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Collection;
import java.util.Collections;
import java.util.function.Supplier;

import org.springframework.cloud.contract.spec.Contract;
import org.springframework.cloud.contract.verifier.util.ContractVerifierUtil;

class contract_rest implements Supplier<Collection<Contract>> {

    @Override
    public Collection<Contract> get() {
        return Collections.singletonList(Contract.make(c -> {
            c.description("Some description");
            c.name("some name");
            c.priority(8);
            c.ignored();
            c.request(r -> {
                r.url("/foo", u -> {
                    u.queryParameters(q -> {
                        q.parameter("a", "b");
                        q.parameter("b", "c");
                    });
                });
                r.method(r.PUT());
                r.headers(h -> {
                    h.header("foo", r.value(r.client(r.regex("bar")), r.server("bar")));
                    h.header("fooReq", "baz");
                });
                r.body(ContractVerifierUtil.map().entry("foo", "bar"));
                r.bodyMatchers(m -> {
                    m.jsonPath("$.foo", m.byRegex("bar"));
                });
            });
            c.response(r -> {
                r.fixedDelayMilliseconds(1000);
                r.status(r.OK());
                r.headers(h -> {
                    h.header("foo2", r.value(r.server(r.regex("bar")), r.client("bar")));
                    h.header("foo3", r.value(r.server(r.execute("andMeToo($it)")),
                            r.client("foo33")));
                    h.header("fooRes", "baz");
                });
                r.body(ContractVerifierUtil.map().entry("foo2", "bar")
                        .entry("foo3", "baz").entry("nullValue", null));
                r.bodyMatchers(m -> {
                    m.jsonPath("$.foo2", m.byRegex("bar"));
                    m.jsonPath("$.foo3", m.byCommand("executeMe($it)"));
                    m.jsonPath("$.nullValue", m.byNull());
                });
            });
        }));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract
import org.springframework.cloud.contract.spec.withQueryParameters

contract {
    name = "some name"
    description = "Some description"
    priority = 8
    ignored = true
    request {
        url = url("/foo") withQueryParameters  {
            parameter("a", "b")
            parameter("b", "c")
        }
        method = PUT
        headers {
            header("foo", value(client(regex("bar")), server("bar")))
            header("fooReq", "baz")
        }
        body = body(mapOf("foo" to "bar"))
        bodyMatchers {
            jsonPath("$.foo", byRegex("bar"))
        }
    }
    response {
        delay = fixedMilliseconds(1000)
        status = OK
        headers {
            header("foo2", value(server(regex("bar")), client("bar")))
            header("foo3", value(server(execute("andMeToo(\$it)")), client("foo33")))
            header("fooRes", "baz")
        }
        body = body(mapOf(
                "foo" to "bar",
                "foo3" to "baz",
                "nullValue" to null
        ))
        bodyMatchers {
            jsonPath("$.foo2", byRegex("bar"))
            jsonPath("$.foo3", byCommand("executeMe(\$it)"))
            jsonPath("$.nullValue", byNull)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用以下独立的Maven命令将合同编译为存根映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:convert</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="contract-groovy"><a class="anchor" href="#contract-groovy"></a> <a class="link" href="#contract-groovy">Groovy中的合约DSL</a></h5>
<div class="paragraph">
<p>如果您不熟悉Groovy，请不要担心-您也可以在Groovy DSL文件中使用Java语法。</p>
</div>
<div class="paragraph">
<p>如果您决定用Groovy编写合同，那么如果您以前没有使用过Groovy，请不要感到惊慌。真正不需要该语言的知识，因为Contract DSL仅使用它的一小部分（仅文字，方法调用和闭包）。同样，DSL是静态类型的，以使其在不了解DSL本身的情况下就可以被程序员读取。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请记住，在Groovy合同文件中，您必须为<code>Contract</code>类和<code>make</code>静态导入，例如<code>org.springframework.cloud.spec.Contract.make { …​ }</code> 。您还可以提供导入到<code>Contract</code>类（ <code>import org.springframework.cloud.spec.Contract</code> ），然后致电<code>Contract.make { …​ }</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="contract-java"><a class="anchor" href="#contract-java"></a> <a class="link" href="#contract-java">用Java签约DSL</a></h5>
<div class="paragraph">
<p>要使用Java编写合同定义，您需要创建一个类，该类可以实现<code>Supplier<Contract></code>单个合同的接口或<code>Supplier<Collection<Contract>></code>用于多个合同。</p>
</div>
<div class="paragraph">
<p>您还可以在以下位置写合同定义<code>src/test/java</code> （例如<code>src/test/java/contracts</code> ），这样您就不必修改项目的类路径。在这种情况下，您必须为Spring Cloud Contract插件提供合同定义的新位置。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <contractsDirectory>src/test/java/contracts</contractsDirectory>
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    contractsDslDir = new File(project.rootDir, "src/test/java/contracts")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="contract-kotlin"><a class="anchor" href="#contract-kotlin"></a> <a class="link" href="#contract-kotlin">在Kotlin签约DSL</a></h5>
<div class="paragraph">
<p>要开始使用Kotlin编写合同，您需要从一个（新创建的）Kotlin脚本文件（.kts）开始。就像Java DSL一样，您可以将合同放在您选择的任何目录中。Maven和Gradle插件将着眼于<code>src/test/resources/contracts</code>目录默认情况下。</p>
</div>
<div class="paragraph">
<p>您需要明确传递<code>spring-cloud-contract-spec-kotlin</code>对项目插件设置的依赖。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- some config -->
    </configuration>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-contract-spec-kotlin</artifactId>
            <version>${spring-cloud-contract.version}</version>
        </dependency>
    </dependencies>
</plugin>

<dependencies>
        <!-- Remember to add this for the DSL support in the IDE and on the consumer side -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-contract-spec-kotlin</artifactId>
            <scope>test</scope>
        </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        // ...
    }
    dependencies {
        classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${scContractVersion}"
        // remember to add this:
        classpath "org.springframework.cloud:spring-cloud-contract-spec-kotlin:${scContractVersion}"
    }
}

dependencies {
    // ...

    // Remember to add this for the DSL support in the IDE and on the consumer side
    testImplementation "org.springframework.cloud:spring-cloud-contract-spec-kotlin"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请记住，在Kotlin脚本文件中，您必须为<code>ContractDSL</code>类。通常，您将使用其合同功能，如下所示： <code>org.springframework.cloud.contract.spec.ContractDsl.contract { …​ }</code> 。您还可以提供导入到<code>contract</code>功能（ <code>import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract</code> ），然后致电<code>contract { …​ }</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="contract-yml"><a class="anchor" href="#contract-yml"></a> <a class="link" href="#contract-yml">YML中的合约DSL</a></h5>
<div class="paragraph">
<p>为了查看YAML合同的架构，您可以签出“ <a href="yml-schema.html">YML架构”</a>页面。</p>
</div>
</div>
<div class="sect4">
<h5 id="contract-limitations"><a class="anchor" href="#contract-limitations"></a> <a class="link" href="#contract-limitations">局限性</a></h5>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">验证JSON数组大小的支持是实验性的。如果要打开它，请将以下系统属性的值设置为<code>true</code> ： <code>spring.cloud.contract.verifier.assert.size</code> 。默认情况下，此功能设置为<code>false</code> 。您还可以设置<code>assertJsonSize</code>插件配置中的属性。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">由于JSON结构可以采用任何形式，因此在使用Groovy DSL和<code>value(consumer(…​), producer(…​))</code>表示法<code>GString</code> 。这就是为什么您应该使用Groovy Map表示法的原因。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="contract-common-top-elements"><a class="anchor" href="#contract-common-top-elements"></a> <a class="link" href="#contract-common-top-elements">常见的顶级元素</a></h5>
<div class="paragraph">
<p>以下各节描述了最常见的顶级元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#contract-dsl-description">描述</a></p>
</li>
<li>
<p><a href="#contract-dsl-name">名称</a></p>
</li>
<li>
<p><a href="#contract-dsl-ignoring-contracts">忽略合同</a></p>
</li>
<li>
<p><a href="#contract-dsl-in-progress">进行中的合同</a></p>
</li>
<li>
<p><a href="#contract-dsl-passing-values-from-files">从文件传递值</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="contract-dsl-description"><a class="anchor" href="#contract-dsl-description"></a> <a class="link" href="#contract-dsl-description">描述</a></h6>
<div class="paragraph">
<p>您可以添加一个<code>description</code>到您的合同。描述是任意文本。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">            org.springframework.cloud.contract.spec.Contract.make {
                description('''
given:
    An input
when:
    Sth happens
then:
    Output
''')
            }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">description: Some description
name: some name
priority: 8
ignored: true
request:
  url: /foo
  queryParameters:
    a: b
    b: c
  method: PUT
  headers:
    foo: bar
    fooReq: baz
  body:
    foo: bar
  matchers:
    body:
      - path: $.foo
        type: by_regex
        value: bar
    headers:
      - key: foo
        regex: bar
response:
  status: 200
  headers:
    foo2: bar
    foo3: foo33
    fooRes: baz
  body:
    foo2: bar
    foo3: baz
    nullValue: null
  matchers:
    body:
      - path: $.foo2
        type: by_regex
        value: bar
      - path: $.foo3
        type: by_command
        value: executeMe($it)
      - path: $.nullValue
        type: by_null
        value: null
    headers:
      - key: foo2
        regex: bar
      - key: foo3
        command: andMeToo($it)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Contract.make(c -> {
    c.description("Some description");
}));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    description = """
given:
    An input
when:
    Sth happens
then:
    Output
"""
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-name"><a class="anchor" href="#contract-dsl-name"></a> <a class="link" href="#contract-dsl-name">名称</a></h6>
<div class="paragraph">
<p>您可以为合同提供名称。假设您提供了以下名称： <code>should register a user</code> 。如果这样做，则自动生成的测试的名称为<code>validate_should_register_a_user</code> 。另外，WireMock存根中的存根名称为<code>should_register_a_user.json</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您必须确保该名称不包含任何使生成的测试无法编译的字符。另外，请记住，如果为多个合同提供相同的名称，则自动生成的测试将无法编译，并且生成的存根会相互覆盖。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了如何为合同添加名称：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    name("some_special_name")
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: some name</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Contract.make(c -> {
    c.name("some name");
}));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    name = "some_special_name"
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-ignoring-contracts"><a class="anchor" href="#contract-dsl-ignoring-contracts"></a> <a class="link" href="#contract-dsl-ignoring-contracts">忽略合同</a></h6>
<div class="paragraph">
<p>如果您想忽略合同，则可以在插件配置中为忽略的合同设置一个值，也可以设置<code>ignored</code>合同本身的财产。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    ignored()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">ignored: true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Contract.make(c -> {
    c.ignored();
}));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    ignored = true
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-in-progress"><a class="anchor" href="#contract-dsl-in-progress"></a> <a class="link" href="#contract-dsl-in-progress">进行中的合同</a></h6>
<div class="paragraph">
<p>正在进行的合同不会在生产方进行测试，但可以生成存根。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请谨慎使用此功能，因为它可能导致误报。您生成存根供消费者使用，而无需实际实施！
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要设置进行中的合同，下面的示例说明了如何进行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    inProgress()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">inProgress: true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Contract.make(c -> {
    c.inProgress();
}));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    inProgress = true
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以设置<code>failOnInProgress</code> Spring Cloud Contract插件属性，以确保当源中至少有一份正在进行的合同时，构建将中断。</p>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-passing-values-from-files"><a class="anchor" href="#contract-dsl-passing-values-from-files"></a> <a class="link" href="#contract-dsl-passing-values-from-files">从文件传递值</a></h6>
<div class="paragraph">
<p>从版本开始<code>1.2.0</code> ，您可以传递文件中的值。假设您在项目中拥有以下资源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── src
    └── test
        └── resources
            └── contracts
                ├── readFromFile.groovy
                ├── request.json
                └── response.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>进一步假设您的合同如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method('PUT')
        headers {
            contentType(applicationJson())
        }
        body(file("request.json"))
        url("/1")
    }
    response {
        status OK()
        body(file("response.json"))
        headers {
            contentType(applicationJson())
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  method: GET
  url: /foo
  bodyFromFile: request.json
response:
  status: 200
  bodyFromFile: response.json</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Collection;
import java.util.Collections;
import java.util.function.Supplier;

import org.springframework.cloud.contract.spec.Contract;

class contract_rest_from_file implements Supplier<Collection<Contract>> {

    @Override
    public Collection<Contract> get() {
        return Collections.singletonList(Contract.make(c -> {
            c.request(r -> {
                r.url("/foo");
                r.method(r.GET());
                r.body(r.file("request.json"));
            });
            c.response(r -> {
                r.status(r.OK());
                r.body(r.file("response.json"));
            });
        }));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        url = url("/1")
        method = PUT
        headers {
            contentType = APPLICATION_JSON
        }
        body = bodyFromFile("request.json")
    }
    response {
        status = OK
        body = bodyFromFile("response.json")
        headers {
            contentType = APPLICATION_JSON
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设JSON文件如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">request.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "status": "REQUEST"
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">response.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">{
  "status": "RESPONSE"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当进行测试或存根生成时， <code>request.json</code>和<code>response.json</code>文件被传递到请求或响应的主体。文件名必须是相对于合同所在文件夹的位置的文件。</p>
</div>
<div class="paragraph">
<p>如果您需要以二进制形式传递文件的内容，则可以使用<code>fileAsBytes</code>编码DSL或<code>bodyFromFileAsBytes</code> YAML中的字段。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何传递二进制文件的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        url("/1")
        method(PUT())
        headers {
            contentType(applicationOctetStream())
        }
        body(fileAsBytes("request.pdf"))
    }
    response {
        status 200
        body(fileAsBytes("response.pdf"))
        headers {
            contentType(applicationOctetStream())
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  url: /1
  method: PUT
  headers:
    Content-Type: application/octet-stream
  bodyFromFileAsBytes: request.pdf
response:
  status: 200
  bodyFromFileAsBytes: response.pdf
  headers:
    Content-Type: application/octet-stream</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Collection;
import java.util.Collections;
import java.util.function.Supplier;

import org.springframework.cloud.contract.spec.Contract;

class contract_rest_from_pdf implements Supplier<Collection<Contract>> {

    @Override
    public Collection<Contract> get() {
        return Collections.singletonList(Contract.make(c -> {
            c.request(r -> {
                r.url("/1");
                r.method(r.PUT());
                r.body(r.fileAsBytes("request.pdf"));
                r.headers(h -> {
                    h.contentType(h.applicationOctetStream());
                });
            });
            c.response(r -> {
                r.status(r.OK());
                r.body(r.fileAsBytes("response.pdf"));
                r.headers(h -> {
                    h.contentType(h.applicationOctetStream());
                });
            });
        }));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        url = url("/1")
        method = PUT
        headers {
            contentType = APPLICATION_OCTET_STREAM
        }
        body = bodyFromFileAsBytes("contracts/request.pdf")
    }
    response {
        status = OK
        body = bodyFromFileAsBytes("contracts/response.pdf")
        headers {
            contentType = APPLICATION_OCTET_STREAM
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">每当您要使用HTTP和消息传递的二进制有效负载时，都应使用此方法。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="features-http"><a class="anchor" href="#features-http"></a> <a class="link" href="#features-http">14.3.2。HTTP合约</a></h4>
<div class="paragraph">
<p>通过Spring Cloud Contract，您可以验证使用REST或HTTP作为通信手段的应用程序。对于符合以下条件的请求，Spring Cloud Contract会进行验证： <code>request</code>在合同的一部分中，服务器提供的响应与<code>response</code>合同的一部分。随后，使用合同生成WireMock存根，对于符合所提供标准的任何请求，WireMock存根将提供适当的响应。</p>
</div>
<div class="sect4">
<h5 id="contract-dsl-http-top-level-elements"><a class="anchor" href="#contract-dsl-http-top-level-elements"></a> <a class="link" href="#contract-dsl-http-top-level-elements">HTTP顶级元素</a></h5>
<div class="paragraph">
<p>您可以在合同定义的顶级闭合中调用以下方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>request</code> ：必填</p>
</li>
<li>
<p><code>response</code> ：必填</p>
</li>
<li>
<p><code>priority</code> ： 可选的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了如何定义HTTP请求协定：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    // Definition of HTTP request part of the contract
    // (this can be a valid request or invalid depending
    // on type of contract being specified).
    request {
        method GET()
        url "/foo"
        //...
    }

    // Definition of HTTP response part of the contract
    // (a service implementing this contract should respond
    // with following response after receiving request
    // specified in "request" part above).
    response {
        status 200
        //...
    }

    // Contract priority, which can be used for overriding
    // contracts (1 is highest). Priority is optional.
    priority 1
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">priority: 8
request:
...
response:
...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    // Definition of HTTP request part of the contract
    // (this can be a valid request or invalid depending
    // on type of contract being specified).
    c.request(r -> {
        r.method(r.GET());
        r.url("/foo");
        // ...
    });

    // Definition of HTTP response part of the contract
    // (a service implementing this contract should respond
    // with following response after receiving request
    // specified in "request" part above).
    c.response(r -> {
        r.status(200);
        // ...
    });

    // Contract priority, which can be used for overriding
    // contracts (1 is highest). Priority is optional.
    c.priority(1);
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    // Definition of HTTP request part of the contract
    // (this can be a valid request or invalid depending
    // on type of contract being specified).
    request {
        method = GET
        url = url("/foo")
        // ...
    }

    // Definition of HTTP response part of the contract
    // (a service implementing this contract should respond
    // with following response after receiving request
    // specified in "request" part above).
    response {
        status = OK
        // ...
    }

    // Contract priority, which can be used for overriding
    // contracts (1 is highest). Priority is optional.
    priority = 1
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您想使合同具有更高的优先级，则需要将较低的数字传递给<code>priority</code>标签或方法。例如，一个<code>priority</code>的值为<code>5</code>具有比<code>priority</code>的值为<code>10</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="contract-dsl-request"><a class="anchor" href="#contract-dsl-request"></a> <a class="link" href="#contract-dsl-request">HTTP请求</a></h5>
<div class="paragraph">
<p>HTTP协议仅需要在请求中指定方法和URL。合同的请求定义中必须包含相同的信息。</p>
</div>
<div class="paragraph">
<p>以下示例显示了请求合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        // HTTP request method (GET/POST/PUT/DELETE).
        method 'GET'

        // Path component of request URL is specified as follows.
        urlPath('/users')
    }

    response {
        //...
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">method: PUT
url: /foo</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        // HTTP request method (GET/POST/PUT/DELETE).
        r.method("GET");

        // Path component of request URL is specified as follows.
        r.urlPath("/users");
    });

    c.response(r -> {
        // ...
        r.status(200);
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        // HTTP request method (GET/POST/PUT/DELETE).
        method = method("GET")

        // Path component of request URL is specified as follows.
        urlPath = path("/users")
    }
    response {
        // ...
        status = code(200)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以指定绝对而不是相对<code>url</code> ，但使用<code>urlPath</code>建议这样做，因为这样做会使测试独立于主机。</p>
</div>
<div class="paragraph">
<p>以下示例使用<code>url</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'GET'

        // Specifying `url` and `urlPath` in one contract is illegal.
        url('http://localhost:8888/users')
    }

    response {
        //...
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  method: PUT
  urlPath: /foo</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        r.method("GET");

        // Specifying `url` and `urlPath` in one contract is illegal.
        r.url("http://localhost:8888/users");
    });

    c.response(r -> {
        // ...
        r.status(200);
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        method = GET

        // Specifying `url` and `urlPath` in one contract is illegal.
        url("http://localhost:8888/users")
    }
    response {
        // ...
        status = OK
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>request</code>可能包含查询参数，如以下示例（使用<code>urlPath</code> ）显示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        //...
        method GET()

        urlPath('/users') {

            // Each parameter is specified in form
            // `'paramName' : paramValue` where parameter value
            // may be a simple literal or one of matcher functions,
            // all of which are used in this example.
            queryParameters {

                // If a simple literal is used as value
                // default matcher function is used (equalTo)
                parameter 'limit': 100

                // `equalTo` function simply compares passed value
                // using identity operator (==).
                parameter 'filter': equalTo("email")

                // `containing` function matches strings
                // that contains passed substring.
                parameter 'gender': value(consumer(containing("[mf]")), producer('mf'))

                // `matching` function tests parameter
                // against passed regular expression.
                parameter 'offset': value(consumer(matching("[0-9]+")), producer(123))

                // `notMatching` functions tests if parameter
                // does not match passed regular expression.
                parameter 'loginStartsWith': value(consumer(notMatching(".{0,2}")), producer(3))
            }
        }

        //...
    }

    response {
        //...
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">request:
...
queryParameters:
  a: b
  b: c</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        // ...
        r.method(r.GET());

        r.urlPath("/users", u -> {

            // Each parameter is specified in form
            // `'paramName' : paramValue` where parameter value
            // may be a simple literal or one of matcher functions,
            // all of which are used in this example.
            u.queryParameters(q -> {

                // If a simple literal is used as value
                // default matcher function is used (equalTo)
                q.parameter("limit", 100);

                // `equalTo` function simply compares passed value
                // using identity operator (==).
                q.parameter("filter", r.equalTo("email"));

                // `containing` function matches strings
                // that contains passed substring.
                q.parameter("gender",
                        r.value(r.consumer(r.containing("[mf]")),
                                r.producer("mf")));

                // `matching` function tests parameter
                // against passed regular expression.
                q.parameter("offset",
                        r.value(r.consumer(r.matching("[0-9]+")),
                                r.producer(123)));

                // `notMatching` functions tests if parameter
                // does not match passed regular expression.
                q.parameter("loginStartsWith",
                        r.value(r.consumer(r.notMatching(".{0,2}")),
                                r.producer(3)));
            });
        });

        // ...
    });

    c.response(r -> {
        // ...
        r.status(200);
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        // ...
        method = GET

        // Each parameter is specified in form
        // `'paramName' : paramValue` where parameter value
        // may be a simple literal or one of matcher functions,
        // all of which are used in this example.
        urlPath = path("/users") withQueryParameters {
            // If a simple literal is used as value
            // default matcher function is used (equalTo)
            parameter("limit", 100)

            // `equalTo` function simply compares passed value
            // using identity operator (==).
            parameter("filter", equalTo("email"))

            // `containing` function matches strings
            // that contains passed substring.
            parameter("gender", value(consumer(containing("[mf]")), producer("mf")))

            // `matching` function tests parameter
            // against passed regular expression.
            parameter("offset", value(consumer(matching("[0-9]+")), producer(123)))

            // `notMatching` functions tests if parameter
            // does not match passed regular expression.
            parameter("loginStartsWith", value(consumer(notMatching(".{0,2}")), producer(3)))
        }

        // ...
    }
    response {
        // ...
        status = code(200)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>request</code>可以包含其他请求标头，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        //...
        method GET()
        url "/foo"

        // Each header is added in form `'Header-Name' : 'Header-Value'`.
        // there are also some helper methods
        headers {
            header 'key': 'value'
            contentType(applicationJson())
        }

        //...
    }

    response {
        //...
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">request:
...
headers:
  foo: bar
  fooReq: baz</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        // ...
        r.method(r.GET());
        r.url("/foo");

        // Each header is added in form `'Header-Name' : 'Header-Value'`.
        // there are also some helper methods
        r.headers(h -> {
            h.header("key", "value");
            h.contentType(h.applicationJson());
        });

        // ...
    });

    c.response(r -> {
        // ...
        r.status(200);
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        // ...
        method = GET
        url = url("/foo")

        // Each header is added in form `'Header-Name' : 'Header-Value'`.
        // there are also some helper variables
        headers {
            header("key", "value")
            contentType = APPLICATION_JSON
        }

        // ...
    }
    response {
        // ...
        status = OK
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>request</code>可能包含其他请求cookie，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        //...
        method GET()
        url "/foo"

        // Each Cookies is added in form `'Cookie-Key' : 'Cookie-Value'`.
        // there are also some helper methods
        cookies {
            cookie 'key': 'value'
            cookie('another_key', 'another_value')
        }

        //...
    }

    response {
        //...
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">request:
...
cookies:
  foo: bar
  fooReq: baz</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        // ...
        r.method(r.GET());
        r.url("/foo");

        // Each Cookies is added in form `'Cookie-Key' : 'Cookie-Value'`.
        // there are also some helper methods
        r.cookies(ck -> {
            ck.cookie("key", "value");
            ck.cookie("another_key", "another_value");
        });

        // ...
    });

    c.response(r -> {
        // ...
        r.status(200);
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        // ...
        method = GET
        url = url("/foo")

        // Each Cookies is added in form `'Cookie-Key' : 'Cookie-Value'`.
        // there are also some helper methods
        cookies {
            cookie("key", "value")
            cookie("another_key", "another_value")
        }

        // ...
    }

    response {
        // ...
        status = code(200)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>request</code>可能包含一个请求主体，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        //...
        method GET()
        url "/foo"

        // Currently only JSON format of request body is supported.
        // Format will be determined from a header or body's content.
        body '''{ "login" : "john", "name": "John The Contract" }'''
    }

    response {
        //...
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">request:
...
body:
  foo: bar</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        // ...
        r.method(r.GET());
        r.url("/foo");

        // Currently only JSON format of request body is supported.
        // Format will be determined from a header or body's content.
        r.body("{ \"login\" : \"john\", \"name\": \"John The Contract\" }");
    });

    c.response(r -> {
        // ...
        r.status(200);
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        // ...
        method = GET
        url = url("/foo")

        // Currently only JSON format of request body is supported.
        // Format will be determined from a header or body's content.
        body = body("{ \"login\" : \"john\", \"name\": \"John The Contract\" }")
    }
    response {
        // ...
        status = OK
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>request</code>可以包含多部分元素。要包含多部分元素，请使用<code>multipart</code>方法/部分，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract contractDsl = org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'PUT'
        url '/multipart'
        headers {
            contentType('multipart/form-data;boundary=AaB03x')
        }
        multipart(
                // key (parameter name), value (parameter value) pair
                formParameter: $(c(regex('".+"')), p('"formParameterValue"')),
                someBooleanParameter: $(c(regex(anyBoolean())), p('true')),
                // a named parameter (e.g. with `file` name) that represents file with
                // `name` and `content`. You can also call `named("fileName", "fileContent")`
                file: named(
                        // name of the file
                        name: $(c(regex(nonEmpty())), p('filename.csv')),
                        // content of the file
                        content: $(c(regex(nonEmpty())), p('file content')),
                        // content type for the part
                        contentType: $(c(regex(nonEmpty())), p('application/json')))
        )
    }
    response {
        status OK()
    }
}
org.springframework.cloud.contract.spec.Contract contractDsl = org.springframework.cloud.contract.spec.Contract.make {
    request {
        method "PUT"
        url "/multipart"
        headers {
            contentType('multipart/form-data;boundary=AaB03x')
        }
        multipart(
                file: named(
                        name: value(stub(regex('.+')), test('file')),
                        content: value(stub(regex('.+')), test([100, 117, 100, 97] as byte[]))
                )
        )
    }
    response {
        status 200
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  method: PUT
  url: /multipart
  headers:
    Content-Type: multipart/form-data;boundary=AaB03x
  multipart:
    params:
      # key (parameter name), value (parameter value) pair
      formParameter: '"formParameterValue"'
      someBooleanParameter: true
    named:
      - paramName: file
        fileName: filename.csv
        fileContent: file content
  matchers:
    multipart:
      params:
        - key: formParameter
          regex: ".+"
        - key: someBooleanParameter
          predefined: any_boolean
      named:
        - paramName: file
          fileName:
            predefined: non_empty
          fileContent:
            predefined: non_empty
response:
  status: 200</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

import org.springframework.cloud.contract.spec.Contract;
import org.springframework.cloud.contract.spec.internal.DslProperty;
import org.springframework.cloud.contract.spec.internal.Request;
import org.springframework.cloud.contract.verifier.util.ContractVerifierUtil;

class contract_multipart implements Supplier<Collection<Contract>> {

    private static Map<String, DslProperty> namedProps(Request r) {
        Map<String, DslProperty> map = new HashMap<>();
        // name of the file
        map.put("name", r.$(r.c(r.regex(r.nonEmpty())), r.p("filename.csv")));
        // content of the file
        map.put("content", r.$(r.c(r.regex(r.nonEmpty())), r.p("file content")));
        // content type for the part
        map.put("contentType", r.$(r.c(r.regex(r.nonEmpty())), r.p("application/json")));
        return map;
    }

    @Override
    public Collection<Contract> get() {
        return Collections.singletonList(Contract.make(c -> {
            c.request(r -> {
                r.method("PUT");
                r.url("/multipart");
                r.headers(h -> {
                    h.contentType("multipart/form-data;boundary=AaB03x");
                });
                r.multipart(ContractVerifierUtil.map()
                        // key (parameter name), value (parameter value) pair
                        .entry("formParameter",
                                r.$(r.c(r.regex("\".+\"")),
                                        r.p("\"formParameterValue\"")))
                        .entry("someBooleanParameter",
                                r.$(r.c(r.regex(r.anyBoolean())), r.p("true")))
                        // a named parameter (e.g. with `file` name) that represents file
                        // with
                        // `name` and `content`. You can also call `named("fileName",
                        // "fileContent")`
                        .entry("file", r.named(namedProps(r))));
            });
            c.response(r -> {
                r.status(r.OK());
            });
        }));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        method = PUT
        url = url("/multipart")
        multipart {
            field("formParameter", value(consumer(regex("\".+\"")), producer("\"formParameterValue\"")))
            field("someBooleanParameter", value(consumer(anyBoolean), producer("true")))
            field("file",
                named(
                    // name of the file
                    value(consumer(regex(nonEmpty)), producer("filename.csv")),
                    // content of the file
                    value(consumer(regex(nonEmpty)), producer("file content")),
                    // content type for the part
                    value(consumer(regex(nonEmpty)), producer("application/json"))
                )
            )
        }
        headers {
            contentType = "multipart/form-data;boundary=AaB03x"
        }
    }
    response {
        status = OK
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们以两种方式之一定义参数：</p>
</div>
<div class="ulist">
<div class="title">编码DSL</div>
<ul>
<li>
<p>直接使用地图符号，其中值可以是动态属性（例如<code>formParameter: $(consumer(…​), producer(…​))</code> ）。</p>
</li>
<li>
<p>通过使用<code>named(…​)</code>设置命名参数的方法。命名参数可以设置<code>name</code>和<code>content</code> 。您可以通过使用带有两个参数的方法来调用它，例如<code>named("fileName", "fileContent")</code> ，或使用地图符号，例如<code>named(name: "fileName", content: "fileContent")</code> 。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">YAML</div>
<ul>
<li>
<p>多部分参数在<code>multipart.params</code>部分。</p>
</li>
<li>
<p>命名参数（ <code>fileName</code>和<code>fileContent</code>对于给定的参数名称）可以在<code>multipart.named</code>部分。该部分包含<code>paramName</code> （参数名称）， <code>fileName</code> （文件名）， <code>fileContent</code> （文件的内容）字段。</p>
</li>
<li>
<p>动态位可以通过设置<code>matchers.multipart</code>部分。</p>
<div class="ulist">
<ul>
<li>
<p>对于参数，请使用<code>params</code>部分，可以接受<code>regex</code>或一个<code>predefined</code>正则表达式。</p>
</li>
<li>
<p>对于命名参数，请使用<code>named</code>首先在其中定义参数名称的部分<code>paramName</code> 。然后，您可以通过其中一个的参数化<code>fileName</code>要么<code>fileContent</code>在一个<code>regex</code>或在<code>predefined</code>正则表达式。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据上例中的协定，生成的测试和存根如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">测试</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// given:
  MockMvcRequestSpecification request = given()
    .header("Content-Type", "multipart/form-data;boundary=AaB03x")
    .param("formParameter", "\"formParameterValue\"")
    .param("someBooleanParameter", "true")
    .multiPart("file", "filename.csv", "file content".getBytes());

 // when:
  ResponseOptions response = given().spec(request)
    .put("/multipart");

 // then:
  assertThat(response.statusCode()).isEqualTo(200);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">存根</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">            '''
{
  "request" : {
    "url" : "/multipart",
    "method" : "PUT",
    "headers" : {
      "Content-Type" : {
        "matches" : "multipart/form-data;boundary=AaB03x.*"
      }
    },
    "bodyPatterns" : [ {
        "matches" : ".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"formParameter\\"\\r\\n(Content-Type: .*\\r\\n)?(Content-Transfer-Encoding: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n\\".+\\"\\r\\n--\\\\1.*"
    }, {
        "matches" : ".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"someBooleanParameter\\"\\r\\n(Content-Type: .*\\r\\n)?(Content-Transfer-Encoding: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n(true|false)\\r\\n--\\\\1.*"
    }, {
      "matches" : ".*--(.*)\\r\\nContent-Disposition: form-data; name=\\"file\\"; filename=\\"[\\\\S\\\\s]+\\"\\r\\n(Content-Type: .*\\r\\n)?(Content-Transfer-Encoding: .*\\r\\n)?(Content-Length: \\\\d+\\r\\n)?\\r\\n[\\\\S\\\\s]+\\r\\n--\\\\1.*"
    } ]
  },
  "response" : {
    "status" : 200,
    "transformers" : [ "response-template", "foo-transformer" ]
  }
}
    '''</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="contract-dsl-response"><a class="anchor" href="#contract-dsl-response"></a> <a class="link" href="#contract-dsl-response">HTTP响应</a></h5>
<div class="paragraph">
<p>响应必须包含HTTP状态代码，并且可能包含其他信息。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        //...
        method GET()
        url "/foo"
    }
    response {
        // Status code sent by the server
        // in response to request specified above.
        status OK()
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">response:
...
status: 200</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        // ...
        r.method(r.GET());
        r.url("/foo");
    });
    c.response(r -> {
        // Status code sent by the server
        // in response to request specified above.
        r.status(r.OK());
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        // ...
        method = GET
        url =url("/foo")
    }
    response {
        // Status code sent by the server
        // in response to request specified above.
        status = OK
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了状态之外，响应还可以包含标头，cookie和主体，它们的指定方式与请求中的方式相同（请参见<a href="#contract-dsl-request">HTTP Request</a> ）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">在Groovy DSL中，您可以参考<code>org.springframework.cloud.contract.spec.internal.HttpStatus</code>提供有意义的状态而不是数字的方法。例如，您可以致电<code>OK()</code>状态<code>200</code>要么<code>BAD_REQUEST()</code>对于<code>400</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="contract-dsl-dynamic-properties"><a class="anchor" href="#contract-dsl-dynamic-properties"></a> <a class="link" href="#contract-dsl-dynamic-properties">动态特性</a></h5>
<div class="paragraph">
<p>合同可以包含一些动态属性：时间戳记，ID等。您不想强迫使用者将自己的时钟设置为总是返回相同的时间值，以使该时间与该存根匹配。</p>
</div>
<div class="paragraph">
<p>对于Groovy DSL，您可以通过两种方式在合同中提供动态部分：将其直接传递到主体中或将其设置在单独的部分中，称为<code>bodyMatchers</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在2.0.0之前，这些设置是通过使用<code>testMatchers</code>和<code>stubMatchers</code> 。有关更多信息，请参见<a href="https://github.com/spring-cloud/spring-cloud-contract/wiki/Spring-Cloud-Contract-2.0-Migration-Guide">迁移指南</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于YAML，您只能使用<code>matchers</code>部分。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">里面的条目<code>matchers</code>必须引用有效载荷的现有元素。有关更多信息，请检查此<a href="https://github.com/spring-cloud/spring-cloud-contract/issues/722">问题</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="contract-dsl-dynamic-properties-in-body"><a class="anchor" href="#contract-dsl-dynamic-properties-in-body"></a> <a class="link" href="#contract-dsl-dynamic-properties-in-body">体内的动态特性</a></h6>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本部分仅对编码DSL（Groovy，Java等）有效。<a href="#contract-dsl-matchers">在“匹配器”</a>部分的“ <a href="#contract-dsl-matchers">动态属性”中</a>查看类似功能的YAML示例。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用<code>value</code>方法，或者，如果您使用Groovy映射符号，请使用<code>$()</code> 。下面的示例演示如何使用value方法设置动态属性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">值</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">value(consumer(...), producer(...))
value(c(...), p(...))
value(stub(...), test(...))
value(client(...), server(...))</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">$</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">$(consumer(...), producer(...))
$(c(...), p(...))
$(stub(...), test(...))
$(client(...), server(...))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>两种方法都同样有效。的<code>stub</code>和<code>client</code>方法是别名<code>consumer</code>方法。随后的部分将仔细研究如何使用这些值。</p>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-regex"><a class="anchor" href="#contract-dsl-regex"></a> <a class="link" href="#contract-dsl-regex">常用表达</a></h6>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本节仅对Groovy DSL有效。 <a href="#contract-dsl-matchers">在“匹配器”</a>部分的“ <a href="#contract-dsl-matchers">动态属性”中</a>查看类似功能的YAML示例。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以使用正则表达式在合同DSL中编写您的请求。当您想指示应遵循给定模式的请求提供给定响应时，这样做特别有用。另外，在测试和服务器端测试都需要使用模式而不是精确值时，可以使用正则表达式。</p>
</div>
<div class="paragraph">
<p>确保正则表达式匹配序列的整个区域，例如在内部<a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#matches"><code>Pattern.matches()</code></a>叫做。例如， <code>abc</code>不匹配<code>aabc</code> ，但是<code>.abc</code>做。还有其他一些<a href="#contract-dsl-regex-limitations">已知的限制</a> 。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用正则表达式编写请求：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method('GET')
        url $(consumer(~/\/[0-9]{2}/), producer('/12'))
    }
    response {
        status OK()
        body(
                id: $(anyNumber()),
                surname: $(
                        consumer('Kowalsky'),
                        producer(regex('[a-zA-Z]+'))
                ),
                name: 'Jan',
                created: $(consumer('2014-02-02 12:23:43'), producer(execute('currentDate(it)'))),
                correlationId: value(consumer('5d1f9fef-e0dc-4f3d-a7e4-72d2220dd827'),
                        producer(regex('[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'))
                )
        )
        headers {
            header 'Content-Type': 'text/plain'
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.request(r -> {
        r.method("GET");
        r.url(r.$(r.consumer(r.regex("\\/[0-9]{2}")), r.producer("/12")));
    });
    c.response(r -> {
        r.status(r.OK());
        r.body(ContractVerifierUtil.map().entry("id", r.$(r.anyNumber()))
                .entry("surname", r.$(r.consumer("Kowalsky"),
                        r.producer(r.regex("[a-zA-Z]+")))));
        r.headers(h -> {
            h.header("Content-Type", "text/plain");
        });
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    request {
        method = method("GET")
        url = url(v(consumer(regex("\\/[0-9]{2}")), producer("/12")))
    }
    response {
        status = OK
        body(mapOf(
                "id" to v(anyNumber),
                "surname" to v(consumer("Kowalsky"), producer(regex("[a-zA-Z]+")))
        ))
        headers {
            header("Content-Type", "text/plain")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也只能为通信的一侧提供正则表达式。如果这样做，那么合同引擎将自动提供与提供的正则表达式匹配的生成的字符串。以下代码显示了Groovy的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'PUT'
        url value(consumer(regex('/foo/[0-9]{5}')))
        body([
                requestElement: $(consumer(regex('[0-9]{5}')))
        ])
        headers {
            header('header', $(consumer(regex('application\\/vnd\\.fraud\\.v1\\+json;.*'))))
        }
    }
    response {
        status OK()
        body([
                responseElement: $(producer(regex('[0-9]{7}')))
        ])
        headers {
            contentType("application/vnd.fraud.v1+json")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，通信的另一端具有为请求和响应而生成的相应数据。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Contract附带了一系列预定义的正则表达式，您可以在合同中使用它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static RegexProperty onlyAlphaUnicode() {
    return new RegexProperty(ONLY_ALPHA_UNICODE).asString();
}

public static RegexProperty alphaNumeric() {
    return new RegexProperty(ALPHA_NUMERIC).asString();
}

public static RegexProperty number() {
    return new RegexProperty(NUMBER).asDouble();
}

public static RegexProperty positiveInt() {
    return new RegexProperty(POSITIVE_INT).asInteger();
}

public static RegexProperty anyBoolean() {
    return new RegexProperty(TRUE_OR_FALSE).asBooleanType();
}

public static RegexProperty anInteger() {
    return new RegexProperty(INTEGER).asInteger();
}

public static RegexProperty aDouble() {
    return new RegexProperty(DOUBLE).asDouble();
}

public static RegexProperty ipAddress() {
    return new RegexProperty(IP_ADDRESS).asString();
}

public static RegexProperty hostname() {
    return new RegexProperty(HOSTNAME_PATTERN).asString();
}

public static RegexProperty email() {
    return new RegexProperty(EMAIL).asString();
}

public static RegexProperty url() {
    return new RegexProperty(URL).asString();
}

public static RegexProperty httpsUrl() {
    return new RegexProperty(HTTPS_URL).asString();
}

public static RegexProperty uuid() {
    return new RegexProperty(UUID).asString();
}

public static RegexProperty isoDate() {
    return new RegexProperty(ANY_DATE).asString();
}

public static RegexProperty isoDateTime() {
    return new RegexProperty(ANY_DATE_TIME).asString();
}

public static RegexProperty isoTime() {
    return new RegexProperty(ANY_TIME).asString();
}

public static RegexProperty iso8601WithOffset() {
    return new RegexProperty(ISO8601_WITH_OFFSET).asString();
}

public static RegexProperty nonEmpty() {
    return new RegexProperty(NON_EMPTY).asString();
}

public static RegexProperty nonBlank() {
    return new RegexProperty(NON_BLANK).asString();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在您的合同中，可以按以下方式使用它（例如Groovy DSL的示例）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract dslWithOptionalsInString = Contract.make {
    priority 1
    request {
        method POST()
        url '/users/password'
        headers {
            contentType(applicationJson())
        }
        body(
                email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
                callback_url: $(consumer(regex(hostname())), producer('http://partners.com'))
        )
    }
    response {
        status 404
        headers {
            contentType(applicationJson())
        }
        body(
                code: value(consumer("123123"), producer(optional("123123"))),
                message: "User not found by email = [${value(producer(regex(email())), consumer('not.existing@user.com'))}]"
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使事情变得更加简单，您可以使用一组预定义的对象，这些对象自动假定您要传递正则表达式。所有这些方法都以<code>any</code>前缀，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">T anyAlphaUnicode();

T anyAlphaNumeric();

T anyNumber();

T anyInteger();

T anyPositiveInt();

T anyDouble();

T anyHex();

T aBoolean();

T anyIpAddress();

T anyHostname();

T anyEmail();

T anyUrl();

T anyHttpsUrl();

T anyUuid();

T anyDate();

T anyDateTime();

T anyTime();

T anyIso8601WithOffset();

T anyNonBlankString();

T anyNonEmptyString();

T anyOf(String... values);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示如何引用这些方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract contractDsl = Contract.make {
    name "foo"
    label 'trigger_event'
    input {
        triggeredBy('toString()')
    }
    outputMessage {
        sentTo 'topic.rateablequote'
        body([
                alpha            : $(anyAlphaUnicode()),
                number           : $(anyNumber()),
                anInteger        : $(anyInteger()),
                positiveInt      : $(anyPositiveInt()),
                aDouble          : $(anyDouble()),
                aBoolean         : $(aBoolean()),
                ip               : $(anyIpAddress()),
                hostname         : $(anyHostname()),
                email            : $(anyEmail()),
                url              : $(anyUrl()),
                httpsUrl         : $(anyHttpsUrl()),
                uuid             : $(anyUuid()),
                date             : $(anyDate()),
                dateTime         : $(anyDateTime()),
                time             : $(anyTime()),
                iso8601WithOffset: $(anyIso8601WithOffset()),
                nonBlankString   : $(anyNonBlankString()),
                nonEmptyString   : $(anyNonEmptyString()),
                anyOf            : $(anyOf('foo', 'bar'))
        ])
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract {
    name = "foo"
    label = "trigger_event"
    input {
        triggeredBy = "toString()"
    }
    outputMessage {
        sentTo = sentTo("topic.rateablequote")
        body(mapOf(
                "alpha" to v(anyAlphaUnicode),
                "number" to v(anyNumber),
                "anInteger" to v(anyInteger),
                "positiveInt" to v(anyPositiveInt),
                "aDouble" to v(anyDouble),
                "aBoolean" to v(aBoolean),
                "ip" to v(anyIpAddress),
                "hostname" to v(anyAlphaUnicode),
                "email" to v(anyEmail),
                "url" to v(anyUrl),
                "httpsUrl" to v(anyHttpsUrl),
                "uuid" to v(anyUuid),
                "date" to v(anyDate),
                "dateTime" to v(anyDateTime),
                "time" to v(anyTime),
                "iso8601WithOffset" to v(anyIso8601WithOffset),
                "nonBlankString" to v(anyNonBlankString),
                "nonEmptyString" to v(anyNonEmptyString),
                "anyOf" to v(anyOf('foo', 'bar'))
        ))
        headers {
            header("Content-Type", "text/plain")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="contract-dsl-regex-limitations"><a class="anchor" href="#contract-dsl-regex-limitations"></a> <a class="link" href="#contract-dsl-regex-limitations">局限性</a></h7>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">由于某些限制<code>Xeger</code>从正则表达式生成字符串的库，请勿使用<code>$</code>和<code>^</code>如果您依靠自动生成，请登录正则表达式。参见<a href="https://github.com/spring-cloud/spring-cloud-contract/issues/899">第899期</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">不要使用<code>LocalDate</code>实例作为值<code>$</code> （例如， <code>$(consumer(LocalDate.now()))</code> ）。它导致<code>java.lang.StackOverflowError</code> 。使用<code>$(consumer(LocalDate.now().toString()))</code>代替。参见<a href="https://github.com/spring-cloud/spring-cloud-contract/issues/900">问题900</a> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-optional-params"><a class="anchor" href="#contract-dsl-optional-params"></a> <a class="link" href="#contract-dsl-optional-params">传递可选参数</a></h6>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本节仅对Groovy DSL有效。 <a href="#contract-dsl-matchers">在“匹配器”</a>部分的“ <a href="#contract-dsl-matchers">动态属性”中</a>查看类似功能的YAML示例。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以在合同中提供可选参数。但是，只能为以下项提供可选参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求的STUB端</p>
</li>
<li>
<p>响应的测试端</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了如何提供可选参数：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    priority 1
    name "optionals"
    request {
        method 'POST'
        url '/users/password'
        headers {
            contentType(applicationJson())
        }
        body(
                email: $(consumer(optional(regex(email()))), producer('abc@abc.com')),
                callback_url: $(consumer(regex(hostname())), producer('https://partners.com'))
        )
    }
    response {
        status 404
        headers {
            header 'Content-Type': 'application/json'
        }
        body(
                code: value(consumer("123123"), producer(optional("123123")))
        )
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.springframework.cloud.contract.spec.Contract.make(c -> {
    c.priority(1);
    c.name("optionals");
    c.request(r -> {
        r.method("POST");
        r.url("/users/password");
        r.headers(h -> {
            h.contentType(h.applicationJson());
        });
        r.body(ContractVerifierUtil.map()
                .entry("email",
                        r.$(r.consumer(r.optional(r.regex(r.email()))),
                                r.producer("abc@abc.com")))
                .entry("callback_url", r.$(r.consumer(r.regex(r.hostname())),
                        r.producer("https://partners.com"))));
    });
    c.response(r -> {
        r.status(404);
        r.headers(h -> {
            h.header("Content-Type", "application/json");
        });
        r.body(ContractVerifierUtil.map().entry("code", r.value(
                r.consumer("123123"), r.producer(r.optional("123123")))));
    });
});</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">contract { c ->
    priority = 1
    name = "optionals"
    request {
        method = POST
        url = url("/users/password")
        headers {
            contentType = APPLICATION_JSON
        }
        body = body(mapOf(
                "email" to v(consumer(optional(regex(email))), producer("abc@abc.com")),
                "callback_url" to v(consumer(regex(hostname)), producer("https://partners.com"))
        ))
    }
    response {
        status = NOT_FOUND
        headers {
            header("Content-Type", "application/json")
        }
        body(mapOf(
                "code" to value(consumer("123123"), producer(optional("123123")))
        ))
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过包裹身体的一部分<code>optional()</code>方法，您将创建一个必须存在0次或多次的正则表达式。</p>
</div>
<div class="paragraph">
<p>如果使用Spock，将从上一个示例生成以下测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    """\
package com.example

import com.jayway.jsonpath.DocumentContext
import com.jayway.jsonpath.JsonPath
import spock.lang.Specification
import io.restassured.module.mockmvc.specification.MockMvcRequestSpecification
import io.restassured.response.ResponseOptions

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson
import static io.restassured.module.mockmvc.RestAssuredMockMvc.*

@SuppressWarnings("rawtypes")
class FooSpec extends Specification {

\tdef validate_optionals() throws Exception {
\t\tgiven:
\t\t\tMockMvcRequestSpecification request = given()
\t\t\t\t\t.header("Content-Type", "application/json")
\t\t\t\t\t.body('''{"email":"abc@abc.com","callback_url":"https://partners.com"}''')

\t\twhen:
\t\t\tResponseOptions response = given().spec(request)
\t\t\t\t\t.post("/users/password")

\t\tthen:
\t\t\tresponse.statusCode() == 404
\t\t\tresponse.header("Content-Type") == 'application/json'

\t\tand:
\t\t\tDocumentContext parsedJson = JsonPath.parse(response.body.asString())
\t\t\tassertThatJson(parsedJson).field("['code']").matches("(123123)?")
\t}

}
"""</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还将生成以下存根：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    '''
{
  "request" : {
    "url" : "/users/password",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.['email'] =~ /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6})?/)]"
    }, {
      "matchesJsonPath" : "$[?(@.['callback_url'] =~ /((http[s]?|ftp):\\\\/)\\\\/?([^:\\\\/\\\\s]+)(:[0-9]{1,5})?/)]"
    } ],
    "headers" : {
      "Content-Type" : {
        "equalTo" : "application/json"
      }
    }
  },
  "response" : {
    "status" : 404,
    "body" : "{\\"code\\":\\"123123\\",\\"message\\":\\"User not found by email == [not.existing@user.com]\\"}",
    "headers" : {
      "Content-Type" : "application/json"
    }
  },
  "priority" : 1
}
'''</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-custom-methods"><a class="anchor" href="#contract-dsl-custom-methods"></a> <a class="link" href="#contract-dsl-custom-methods">在服务器端执行自定义方法</a></h6>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本节仅对Groovy DSL有效。 <a href="#contract-dsl-matchers">在“匹配器”</a>部分的“ <a href="#contract-dsl-matchers">动态属性”中</a>查看类似功能的YAML示例。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以定义在测试期间在服务器端运行的方法调用。可以将这样的方法添加到定义为<code>baseClassForTests</code>在配置中。以下代码显示了测试用例的合同部分的示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">method GET()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">r.method(r.GET());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">method = GET</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下代码显示了测试用例的基类部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">abstract class BaseMockMvcSpec extends Specification {

    def setup() {
        RestAssuredMockMvc.standaloneSetup(new PairIdController())
    }

    void isProperCorrelationId(Integer correlationId) {
        assert correlationId == 123456
    }

    void isEmpty(String value) {
        assert value == null
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您不能同时使用<code>String</code>和<code>execute</code>执行串联。例如，打电话<code>header('Authorization', 'Bearer ' + execute('authToken()'))</code>导致不正确的结果。相反，请致电<code>header('Authorization', execute('authToken()'))</code>并确保<code>authToken()</code>方法返回您需要的一切。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从JSON读取的对象的类型可以是以下之一，具体取决于JSON路径：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code> ：如果您指向<code>String</code> JSON中的值。</p>
</li>
<li>
<p><code>JSONArray</code> ：如果您指向<code>List</code>在JSON中。</p>
</li>
<li>
<p><code>Map</code> ：如果您指向<code>Map</code>在JSON中。</p>
</li>
<li>
<p><code>Number</code> ：如果您指向<code>Integer</code> ， <code>Double</code>以及JSON中的其他数字类型。</p>
</li>
<li>
<p><code>Boolean</code> ：如果您指向<code>Boolean</code>在JSON中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在合同的请求部分，您可以指定<code>body</code>应该采取一种方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您必须同时提供消费者和生产者双方。的<code>execute</code>部分适用于整个身体，而不是局部。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示如何从JSON读取对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract contractDsl = Contract.make {
    request {
        method 'GET'
        url '/something'
        body(
                $(c('foo'), p(execute('hashCode()')))
        )
    }
    response {
        status OK()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例导致调用<code>hashCode()</code>请求正文中的方法。它应类似于以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .body(hashCode());

// when:
 ResponseOptions response = given().spec(request)
   .get("/something");

// then:
 assertThat(response.statusCode()).isEqualTo(200);</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-referencing-request-from-response"><a class="anchor" href="#contract-dsl-referencing-request-from-response"></a> <a class="link" href="#contract-dsl-referencing-request-from-response">引用响应中的请求</a></h6>
<div class="paragraph">
<p>最好的情况是提供固定值，但是有时您需要在响应中引用一个请求。</p>
</div>
<div class="paragraph">
<p>如果您在Groovy DSL中写合同，则可以使用<code>fromRequest()</code>方法，可让您从HTTP请求中引用一堆元素。您可以使用以下选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fromRequest().url()</code> ：返回请求网址和查询参数。</p>
</li>
<li>
<p><code>fromRequest().query(String key)</code> ：返回具有给定名称的第一个查询参数。</p>
</li>
<li>
<p><code>fromRequest().query(String key, int index)</code> ：返回具有给定名称的第n个查询参数。</p>
</li>
<li>
<p><code>fromRequest().path()</code> ：返回完整路径。</p>
</li>
<li>
<p><code>fromRequest().path(int index)</code> ：返回第n个路径元素。</p>
</li>
<li>
<p><code>fromRequest().header(String key)</code> ：返回具有给定名称的第一个标头。</p>
</li>
<li>
<p><code>fromRequest().header(String key, int index)</code> ：返回具有给定名称的第n个标头。</p>
</li>
<li>
<p><code>fromRequest().body()</code> ：返回完整的请求正文。</p>
</li>
<li>
<p><code>fromRequest().body(String jsonPath)</code> ：从请求中返回与JSON路径匹配的元素。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果使用YAML契约定义或Java契约定义，则必须使用<a href="https://handlebarsjs.com/">Handlebars</a> <code>{{{ }}}</code>带有自定义Spring Cloud Contract功能的符号可实现此目的。在这种情况下，您可以使用以下选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>{{{ request.url }}}</code> ：返回请求网址和查询参数。</p>
</li>
<li>
<p><code>{{{ request.query.key.[index] }}}</code> ：返回具有给定名称的第n个查询参数。例如，对于<code>thing</code> ，第一个条目是<code>{{{ request.query.thing.[0] }}}</code></p>
</li>
<li>
<p><code>{{{ request.path }}}</code> ：返回完整路径。</p>
</li>
<li>
<p><code>{{{ request.path.[index] }}}</code> ：返回第n个路径元素。例如，第一个条目是<code>`</code> {{{request.path。[0]}}}</p>
</li>
<li>
<p><code>{{{ request.headers.key }}}</code> ：返回具有给定名称的第一个标头。</p>
</li>
<li>
<p><code>{{{ request.headers.key.[index] }}}</code> ：返回具有给定名称的第n个标头。</p>
</li>
<li>
<p><code>{{{ request.body }}}</code> ：返回完整的请求正文。</p>
</li>
<li>
<p><code>{{{ jsonpath this 'your.json.path' }}}</code> ：从请求中返回与JSON路径匹配的元素。例如，对于的JSON路径<code>$.here</code> ， 使用<code>{{{ jsonpath this '$.here' }}}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract contractDsl = Contract.make {
    request {
        method 'GET'
        url('/api/v1/xxxx') {
            queryParameters {
                parameter('foo', 'bar')
                parameter('foo', 'bar2')
            }
        }
        headers {
            header(authorization(), 'secret')
            header(authorization(), 'secret2')
        }
        body(foo: 'bar', baz: 5)
    }
    response {
        status OK()
        headers {
            header(authorization(), "foo ${fromRequest().header(authorization())} bar")
        }
        body(
                url: fromRequest().url(),
                path: fromRequest().path(),
                pathIndex: fromRequest().path(1),
                param: fromRequest().query('foo'),
                paramIndex: fromRequest().query('foo', 1),
                authorization: fromRequest().header('Authorization'),
                authorization2: fromRequest().header('Authorization', 1),
                fullBody: fromRequest().body(),
                responseFoo: fromRequest().body('$.foo'),
                responseBaz: fromRequest().body('$.baz'),
                responseBaz2: "Bla bla ${fromRequest().body('$.foo')} bla bla",
                rawUrl: fromRequest().rawUrl(),
                rawPath: fromRequest().rawPath(),
                rawPathIndex: fromRequest().rawPath(1),
                rawParam: fromRequest().rawQuery('foo'),
                rawParamIndex: fromRequest().rawQuery('foo', 1),
                rawAuthorization: fromRequest().rawHeader('Authorization'),
                rawAuthorization2: fromRequest().rawHeader('Authorization', 1),
                rawResponseFoo: fromRequest().rawBody('$.foo'),
                rawResponseBaz: fromRequest().rawBody('$.baz'),
                rawResponseBaz2: "Bla bla ${fromRequest().rawBody('$.foo')} bla bla"
        )
    }
}
Contract contractDsl = Contract.make {
    request {
        method 'GET'
        url('/api/v1/xxxx') {
            queryParameters {
                parameter('foo', 'bar')
                parameter('foo', 'bar2')
            }
        }
        headers {
            header(authorization(), 'secret')
            header(authorization(), 'secret2')
        }
        body(foo: "bar", baz: 5)
    }
    response {
        status OK()
        headers {
            contentType(applicationJson())
        }
        body('''
                {
                    "responseFoo": "{{{ jsonPath request.body '$.foo' }}}",
                    "responseBaz": {{{ jsonPath request.body '$.baz' }}},
                    "responseBaz2": "Bla bla {{{ jsonPath request.body '$.foo' }}} bla bla"
                }
        '''.toString())
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  method: GET
  url: /api/v1/xxxx
  queryParameters:
    foo:
      - bar
      - bar2
  headers:
    Authorization:
      - secret
      - secret2
  body:
    foo: bar
    baz: 5
response:
  status: 200
  headers:
    Authorization: "foo {{{ request.headers.Authorization.0 }}} bar"
  body:
    url: "{{{ request.url }}}"
    path: "{{{ request.path }}}"
    pathIndex: "{{{ request.path.1 }}}"
    param: "{{{ request.query.foo }}}"
    paramIndex: "{{{ request.query.foo.1 }}}"
    authorization: "{{{ request.headers.Authorization.0 }}}"
    authorization2: "{{{ request.headers.Authorization.1 }}"
    fullBody: "{{{ request.body }}}"
    responseFoo: "{{{ jsonpath this '$.foo' }}}"
    responseBaz: "{{{ jsonpath this '$.baz' }}}"
    responseBaz2: "Bla bla {{{ jsonpath this '$.foo' }}} bla bla"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package contracts.beer.rest;

import java.util.function.Supplier;

import org.springframework.cloud.contract.spec.Contract;

import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.map;

class shouldReturnStatsForAUser implements Supplier<Contract> {

    @Override
    public Contract get() {
        return Contract.make(c -> {
            c.request(r -> {
                r.method("POST");
                r.url("/stats");
                r.body(map().entry("name", r.anyAlphaUnicode()));
                r.headers(h -> {
                    h.contentType(h.applicationJson());
                });
            });
            c.response(r -> {
                r.status(r.OK());
                r.body(map()
                        .entry("text",
                                "Dear {{{jsonPath request.body '$.name'}}} thanks for your interested in drinking beer")
                        .entry("quantity", r.$(r.c(5), r.p(r.anyNumber()))));
                r.headers(h -> {
                    h.contentType(h.applicationJson());
                });
            });
        });
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">package contracts.beer.rest

import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        method = method("POST")
        url = url("/stats")
        body(mapOf(
            "name" to anyAlphaUnicode
        ))
        headers {
            contentType = APPLICATION_JSON
        }
    }
    response {
        status = OK
        body(mapOf(
            "text" to "Don't worry ${fromRequest().body("$.name")} thanks for your interested in drinking beer",
            "quantity" to v(c(5), p(anyNumber))
        ))
        headers {
            contentType = fromRequest().header(CONTENT_TYPE)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行JUnit测试生成将导致类似于以下示例的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .header("Authorization", "secret")
   .header("Authorization", "secret2")
   .body("{\"foo\":\"bar\",\"baz\":5}");

// when:
 ResponseOptions response = given().spec(request)
   .queryParam("foo","bar")
   .queryParam("foo","bar2")
   .get("/api/v1/xxxx");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Authorization")).isEqualTo("foo secret bar");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("['fullBody']").isEqualTo("{\"foo\":\"bar\",\"baz\":5}");
 assertThatJson(parsedJson).field("['authorization']").isEqualTo("secret");
 assertThatJson(parsedJson).field("['authorization2']").isEqualTo("secret2");
 assertThatJson(parsedJson).field("['path']").isEqualTo("/api/v1/xxxx");
 assertThatJson(parsedJson).field("['param']").isEqualTo("bar");
 assertThatJson(parsedJson).field("['paramIndex']").isEqualTo("bar2");
 assertThatJson(parsedJson).field("['pathIndex']").isEqualTo("v1");
 assertThatJson(parsedJson).field("['responseBaz']").isEqualTo(5);
 assertThatJson(parsedJson).field("['responseFoo']").isEqualTo("bar");
 assertThatJson(parsedJson).field("['url']").isEqualTo("/api/v1/xxxx?foo=bar&foo=bar2");
 assertThatJson(parsedJson).field("['responseBaz2']").isEqualTo("Bla bla bar bla bla");</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，响应中已正确引用了请求中的元素。</p>
</div>
<div class="paragraph">
<p>生成的WireMock存根应类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request" : {
    "urlPath" : "/api/v1/xxxx",
    "method" : "POST",
    "headers" : {
      "Authorization" : {
        "equalTo" : "secret2"
      }
    },
    "queryParameters" : {
      "foo" : {
        "equalTo" : "bar2"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.['baz'] == 5)]"
    }, {
      "matchesJsonPath" : "$[?(@.['foo'] == 'bar')]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"authorization\":\"{{{request.headers.Authorization.[0]}}}\",\"path\":\"{{{request.path}}}\",\"responseBaz\":{{{jsonpath this '$.baz'}}} ,\"param\":\"{{{request.query.foo.[0]}}}\",\"pathIndex\":\"{{{request.path.[1]}}}\",\"responseBaz2\":\"Bla bla {{{jsonpath this '$.foo'}}} bla bla\",\"responseFoo\":\"{{{jsonpath this '$.foo'}}}\",\"authorization2\":\"{{{request.headers.Authorization.[1]}}}\",\"fullBody\":\"{{{escapejsonbody}}}\",\"url\":\"{{{request.url}}}\",\"paramIndex\":\"{{{request.query.foo.[1]}}}\"}",
    "headers" : {
      "Authorization" : "{{{request.headers.Authorization.[0]}}};foo"
    },
    "transformers" : [ "response-template" ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>发送一个请求，例如<code>request</code>合同的一部分导致发送以下响应正文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "url" : "/api/v1/xxxx?foo=bar&foo=bar2",
  "path" : "/api/v1/xxxx",
  "pathIndex" : "v1",
  "param" : "bar",
  "paramIndex" : "bar2",
  "authorization" : "secret",
  "authorization2" : "secret2",
  "fullBody" : "{\"foo\":\"bar\",\"baz\":5}",
  "responseFoo" : "bar",
  "responseBaz" : 5,
  "responseBaz2" : "Bla bla bar bla bla"
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">此功能仅适用于大于或等于2.5.1的WireMock版本。Spring Cloud Contract Verifier使用WireMock的<code>response-template</code>响应变压器。它使用车把来转换胡子<code>{{{ }}}</code>模板转换为适当的值。此外，它注册了两个帮助程序功能：</td>
</tr>
</tbody></table>
</div>
<div class="ulist">
<ul>
<li>
<p><code>escapejsonbody</code> ：以可嵌入JSON的格式转义请求正文。</p>
</li>
<li>
<p><code>jsonpath</code> ：对于给定的参数，在请求正文中找到一个对象。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-matchers"><a class="anchor" href="#contract-dsl-matchers"></a> <a class="link" href="#contract-dsl-matchers">匹配器部分中的动态属性</a></h6>
<div class="paragraph">
<p>如果您使用<a href="https://docs.pact.io/">Pact</a> ，那么以下讨论可能看起来很熟悉。很少有用户习惯于在主体之间进行分隔并设置合同的动态部分。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>bodyMatchers</code>部分有两个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定义应该以存根结尾的动态值。您可以在<code>request</code>要么<code>inputMessage</code>您合同的一部分。</p>
</li>
<li>
<p>验证测试结果。本节位于<code>response</code>要么<code>outputMessage</code>合同一方。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当前，Spring Cloud Contract Verifier仅支持具有以下匹配可能性的基于JSON路径的匹配器：</p>
</div>
<div class="sect6">
<h7 id="coded-dsl"><a class="anchor" href="#coded-dsl"></a> <a class="link" href="#coded-dsl">编码DSL</a></h7>
<div class="ulist">
<ul>
<li>
<p>对于存根（在消费者方面的测试中）：</p>
<div class="ulist">
<ul>
<li>
<p><code>byEquality()</code> ：在提供的JSON路径中从消费者请求中获取的值必须等于合同中提供的值。</p>
</li>
<li>
<p><code>byRegex(…​)</code> ：从提供的JSON路径中的消费者请求中获取的值必须与正则表达式匹配。您还可以传递期望的匹配值的类型（例如， <code>asString()</code> ， <code>asLong()</code> ， 等等）。</p>
</li>
<li>
<p><code>byDate()</code> ：从提供的JSON路径中的消费者请求中获取的值必须与ISO日期值的正则表达式匹配。</p>
</li>
<li>
<p><code>byTimestamp()</code> ：在提供的JSON路径中从使用者请求中获取的值必须与ISO DateTime值的正则表达式匹配。</p>
</li>
<li>
<p><code>byTime()</code> ：在提供的JSON路径中从使用者的请求中获取的值必须与ISO时间值的正则表达式匹配。</p>
</li>
</ul>
</div>
</li>
<li>
<p>进行验证（在生产者方生成的测试中）：</p>
<div class="ulist">
<ul>
<li>
<p><code>byEquality()</code> ：在提供的JSON路径中从生产者的响应中获取的值必须等于合同中提供的值。</p>
</li>
<li>
<p><code>byRegex(…​)</code> ：从提供的JSON路径中的生产者响应中获取的值必须与正则表达式匹配。</p>
</li>
<li>
<p><code>byDate()</code> ：从提供者提供的JSON路径中的生产者响应中获取的值必须与ISO日期值的正则表达式匹配。</p>
</li>
<li>
<p><code>byTimestamp()</code> ：从提供的JSON路径中的生产者响应中获取的值必须与ISO DateTime值的正则表达式匹配。</p>
</li>
<li>
<p><code>byTime()</code> ：从提供者提供的JSON路径中的生产者响应中获取的值必须与ISO时间值的正则表达式匹配。</p>
</li>
<li>
<p><code>byType()</code> ：从提供的JSON路径中的生产者响应中获取的值必须与合同中响应主体中定义的类型相同。
<code>byType</code>可以关闭，在其中可以设置<code>minOccurrence</code>和<code>maxOccurrence</code> 。对于请求端，应使用闭包声明集合的大小。这样，您可以声明展平集合的大小。要检查未展平的集合的大小，请对<code>byCommand(…​)</code><code>testMatcher</code> 。</p>
</li>
<li>
<p><code>byCommand(…​)</code> ：从提供的JSON路径中的生产者的响应中获取的值作为输入传递给您提供的自定义方法。例如， <code>byCommand('thing($it)')</code>导致呼叫<code>thing</code>与JSON路径匹配的值传递到的方法。从JSON读取的对象的类型可以是以下之一，具体取决于JSON路径：</p>
<div class="ulist">
<ul>
<li>
<p><code>String</code> ：如果您指向<code>String</code>值。</p>
</li>
<li>
<p><code>JSONArray</code> ：如果您指向<code>List</code> 。</p>
</li>
<li>
<p><code>Map</code> ：如果您指向<code>Map</code> 。</p>
</li>
<li>
<p><code>Number</code> ：如果您指向<code>Integer</code> ， <code>Double</code>或其他数字。</p>
</li>
<li>
<p><code>Boolean</code> ：如果您指向<code>Boolean</code> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>byNull()</code> ：从提供的JSON路径中的响应中获取的值必须为null。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect6">
<h7 id="yaml"><a class="anchor" href="#yaml"></a> <a class="link" href="#yaml">YAML</a></h7>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">有关类型含义的详细说明，请参见Groovy部分。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于YAML，匹配器的结构类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">- path: $.thing1
  type: by_regex
  value: thing2
  regexType: as_string</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果要使用预定义的正则表达式之一<code>[only_alpha_unicode, number, any_boolean, ip_address, hostname, email, url, uuid, iso_date, iso_date_time, iso_time, iso_8601_with_offset, non_empty, non_blank]</code> ，您可以使用类似于以下示例的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">- path: $.thing1
  type: by_regex
  predefined: only_alpha_unicode</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下列表显示了允许的列表<code>type</code>值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于<code>stubMatchers</code> ：</p>
<div class="ulist">
<ul>
<li>
<p><code>by_equality</code></p>
</li>
<li>
<p><code>by_regex</code></p>
</li>
<li>
<p><code>by_date</code></p>
</li>
<li>
<p><code>by_timestamp</code></p>
</li>
<li>
<p><code>by_time</code></p>
</li>
<li>
<p><code>by_type</code></p>
<div class="ulist">
<ul>
<li>
<p>另外两个字段（ <code>minOccurrence</code>和<code>maxOccurrence</code> ）被接受。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>对于<code>testMatchers</code> ：</p>
<div class="ulist">
<ul>
<li>
<p><code>by_equality</code></p>
</li>
<li>
<p><code>by_regex</code></p>
</li>
<li>
<p><code>by_date</code></p>
</li>
<li>
<p><code>by_timestamp</code></p>
</li>
<li>
<p><code>by_time</code></p>
</li>
<li>
<p><code>by_type</code></p>
<div class="ulist">
<ul>
<li>
<p>另外两个字段（ <code>minOccurrence</code>和<code>maxOccurrence</code> ）被接受。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>by_command</code></p>
</li>
<li>
<p><code>by_null</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以定义正则表达式对应的类型<code>regexType</code>领域。以下列表显示了允许的正则表达式类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>as_integer</code></p>
</li>
<li>
<p><code>as_double</code></p>
</li>
<li>
<p><code>as_float</code></p>
</li>
<li>
<p><code>as_long</code></p>
</li>
<li>
<p><code>as_short</code></p>
</li>
<li>
<p><code>as_boolean</code></p>
</li>
<li>
<p><code>as_string</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract contractDsl = Contract.make {
    request {
        method 'GET'
        urlPath '/get'
        body([
                duck                : 123,
                alpha               : 'abc',
                number              : 123,
                aBoolean            : true,
                date                : '2017-01-01',
                dateTime            : '2017-01-01T01:23:45',
                time                : '01:02:34',
                valueWithoutAMatcher: 'foo',
                valueWithTypeMatch  : 'string',
                key                 : [
                        'complex.key': 'foo'
                ]
        ])
        bodyMatchers {
            jsonPath('$.duck', byRegex("[0-9]{3}").asInteger())
            jsonPath('$.duck', byEquality())
            jsonPath('$.alpha', byRegex(onlyAlphaUnicode()).asString())
            jsonPath('$.alpha', byEquality())
            jsonPath('$.number', byRegex(number()).asInteger())
            jsonPath('$.aBoolean', byRegex(anyBoolean()).asBooleanType())
            jsonPath('$.date', byDate())
            jsonPath('$.dateTime', byTimestamp())
            jsonPath('$.time', byTime())
            jsonPath("\$.['key'].['complex.key']", byEquality())
        }
        headers {
            contentType(applicationJson())
        }
    }
    response {
        status OK()
        body([
                duck                 : 123,
                alpha                : 'abc',
                number               : 123,
                positiveInteger      : 1234567890,
                negativeInteger      : -1234567890,
                positiveDecimalNumber: 123.4567890,
                negativeDecimalNumber: -123.4567890,
                aBoolean             : true,
                date                 : '2017-01-01',
                dateTime             : '2017-01-01T01:23:45',
                time                 : "01:02:34",
                valueWithoutAMatcher : 'foo',
                valueWithTypeMatch   : 'string',
                valueWithMin         : [
                        1, 2, 3
                ],
                valueWithMax         : [
                        1, 2, 3
                ],
                valueWithMinMax      : [
                        1, 2, 3
                ],
                valueWithMinEmpty    : [],
                valueWithMaxEmpty    : [],
                key                  : [
                        'complex.key': 'foo'
                ],
                nullValue            : null
        ])
        bodyMatchers {
            // asserts the jsonpath value against manual regex
            jsonPath('$.duck', byRegex("[0-9]{3}").asInteger())
            // asserts the jsonpath value against the provided value
            jsonPath('$.duck', byEquality())
            // asserts the jsonpath value against some default regex
            jsonPath('$.alpha', byRegex(onlyAlphaUnicode()).asString())
            jsonPath('$.alpha', byEquality())
            jsonPath('$.number', byRegex(number()).asInteger())
            jsonPath('$.positiveInteger', byRegex(anInteger()).asInteger())
            jsonPath('$.negativeInteger', byRegex(anInteger()).asInteger())
            jsonPath('$.positiveDecimalNumber', byRegex(aDouble()).asDouble())
            jsonPath('$.negativeDecimalNumber', byRegex(aDouble()).asDouble())
            jsonPath('$.aBoolean', byRegex(anyBoolean()).asBooleanType())
            // asserts vs inbuilt time related regex
            jsonPath('$.date', byDate())
            jsonPath('$.dateTime', byTimestamp())
            jsonPath('$.time', byTime())
            // asserts that the resulting type is the same as in response body
            jsonPath('$.valueWithTypeMatch', byType())
            jsonPath('$.valueWithMin', byType {
                // results in verification of size of array (min 1)
                minOccurrence(1)
            })
            jsonPath('$.valueWithMax', byType {
                // results in verification of size of array (max 3)
                maxOccurrence(3)
            })
            jsonPath('$.valueWithMinMax', byType {
                // results in verification of size of array (min 1 & max 3)
                minOccurrence(1)
                maxOccurrence(3)
            })
            jsonPath('$.valueWithMinEmpty', byType {
                // results in verification of size of array (min 0)
                minOccurrence(0)
            })
            jsonPath('$.valueWithMaxEmpty', byType {
                // results in verification of size of array (max 0)
                maxOccurrence(0)
            })
            // will execute a method `assertThatValueIsANumber`
            jsonPath('$.duck', byCommand('assertThatValueIsANumber($it)'))
            jsonPath("\$.['key'].['complex.key']", byEquality())
            jsonPath('$.nullValue', byNull())
        }
        headers {
            contentType(applicationJson())
            header('Some-Header', $(c('someValue'), p(regex('[a-zA-Z]{9}'))))
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">request:
  method: GET
  urlPath: /get/1
  headers:
    Content-Type: application/json
  cookies:
    foo: 2
    bar: 3
  queryParameters:
    limit: 10
    offset: 20
    filter: 'email'
    sort: name
    search: 55
    age: 99
    name: John.Doe
    email: 'bob@email.com'
  body:
    duck: 123
    alpha: "abc"
    number: 123
    aBoolean: true
    date: "2017-01-01"
    dateTime: "2017-01-01T01:23:45"
    time: "01:02:34"
    valueWithoutAMatcher: "foo"
    valueWithTypeMatch: "string"
    key:
      "complex.key": 'foo'
    nullValue: null
    valueWithMin:
      - 1
      - 2
      - 3
    valueWithMax:
      - 1
      - 2
      - 3
    valueWithMinMax:
      - 1
      - 2
      - 3
    valueWithMinEmpty: []
    valueWithMaxEmpty: []
  matchers:
    url:
      regex: /get/[0-9]
      # predefined:
      # execute a method
      #command: 'equals($it)'
    queryParameters:
      - key: limit
        type: equal_to
        value: 20
      - key: offset
        type: containing
        value: 20
      - key: sort
        type: equal_to
        value: name
      - key: search
        type: not_matching
        value: '^[0-9]{2}$'
      - key: age
        type: not_matching
        value: '^\\w*$'
      - key: name
        type: matching
        value: 'John.*'
      - key: hello
        type: absent
    cookies:
      - key: foo
        regex: '[0-9]'
      - key: bar
        command: 'equals($it)'
    headers:
      - key: Content-Type
        regex: "application/json.*"
    body:
      - path: $.duck
        type: by_regex
        value: "[0-9]{3}"
      - path: $.duck
        type: by_equality
      - path: $.alpha
        type: by_regex
        predefined: only_alpha_unicode
      - path: $.alpha
        type: by_equality
      - path: $.number
        type: by_regex
        predefined: number
      - path: $.aBoolean
        type: by_regex
        predefined: any_boolean
      - path: $.date
        type: by_date
      - path: $.dateTime
        type: by_timestamp
      - path: $.time
        type: by_time
      - path: "$.['key'].['complex.key']"
        type: by_equality
      - path: $.nullvalue
        type: by_null
      - path: $.valueWithMin
        type: by_type
        minOccurrence: 1
      - path: $.valueWithMax
        type: by_type
        maxOccurrence: 3
      - path: $.valueWithMinMax
        type: by_type
        minOccurrence: 1
        maxOccurrence: 3
response:
  status: 200
  cookies:
    foo: 1
    bar: 2
  body:
    duck: 123
    alpha: "abc"
    number: 123
    aBoolean: true
    date: "2017-01-01"
    dateTime: "2017-01-01T01:23:45"
    time: "01:02:34"
    valueWithoutAMatcher: "foo"
    valueWithTypeMatch: "string"
    valueWithMin:
      - 1
      - 2
      - 3
    valueWithMax:
      - 1
      - 2
      - 3
    valueWithMinMax:
      - 1
      - 2
      - 3
    valueWithMinEmpty: []
    valueWithMaxEmpty: []
    key:
      'complex.key': 'foo'
    nulValue: null
  matchers:
    headers:
      - key: Content-Type
        regex: "application/json.*"
    cookies:
      - key: foo
        regex: '[0-9]'
      - key: bar
        command: 'equals($it)'
    body:
      - path: $.duck
        type: by_regex
        value: "[0-9]{3}"
      - path: $.duck
        type: by_equality
      - path: $.alpha
        type: by_regex
        predefined: only_alpha_unicode
      - path: $.alpha
        type: by_equality
      - path: $.number
        type: by_regex
        predefined: number
      - path: $.aBoolean
        type: by_regex
        predefined: any_boolean
      - path: $.date
        type: by_date
      - path: $.dateTime
        type: by_timestamp
      - path: $.time
        type: by_time
      - path: $.valueWithTypeMatch
        type: by_type
      - path: $.valueWithMin
        type: by_type
        minOccurrence: 1
      - path: $.valueWithMax
        type: by_type
        maxOccurrence: 3
      - path: $.valueWithMinMax
        type: by_type
        minOccurrence: 1
        maxOccurrence: 3
      - path: $.valueWithMinEmpty
        type: by_type
        minOccurrence: 0
      - path: $.valueWithMaxEmpty
        type: by_type
        maxOccurrence: 0
      - path: $.duck
        type: by_command
        value: assertThatValueIsANumber($it)
      - path: $.nullValue
        type: by_null
        value: null
  headers:
    Content-Type: application/json</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，您可以在<code>matchers</code>部分。对于请求部分，您可以看到，除了<code>valueWithoutAMatcher</code> ，存根应包含的正则表达式的值已明确设置。为了<code>valueWithoutAMatcher</code> ，验证的方式与不使用匹配器的方式相同。在这种情况下，测试将执行相等性检查。</p>
</div>
<div class="paragraph">
<p>对于响应方面<code>bodyMatchers</code>部分，我们以类似的方式定义动态部件。唯一的区别是<code>byType</code>匹配器也存在。验证程序引擎检查四个字段，以验证来自测试的响应是否具有与JSON路径匹配给定字段的值，与响应主体中定义的类型相同的类型，并通过以下检查（基于方法被调用）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于<code>$.valueWithTypeMatch</code> ，引擎会检查类型是否相同。</p>
</li>
<li>
<p>对于<code>$.valueWithMin</code> ，引擎检查类型并断言大小是否大于或等于最小出现次数。</p>
</li>
<li>
<p>对于<code>$.valueWithMax</code> ，引擎检查类型并断言大小是否小于或等于最大出现次数。</p>
</li>
<li>
<p>对于<code>$.valueWithMinMax</code> ，引擎会检查类型并断言大小是否介于最小事件和最大事件之间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>结果测试类似于以下示例（请注意， <code>and</code>部分将自动生成的断言和匹配器的断言分开）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// given:
 MockMvcRequestSpecification request = given()
   .header("Content-Type", "application/json")
   .body("{\"duck\":123,\"alpha\":\"abc\",\"number\":123,\"aBoolean\":true,\"date\":\"2017-01-01\",\"dateTime\":\"2017-01-01T01:23:45\",\"time\":\"01:02:34\",\"valueWithoutAMatcher\":\"foo\",\"valueWithTypeMatch\":\"string\",\"key\":{\"complex.key\":\"foo\"}}");

// when:
 ResponseOptions response = given().spec(request)
   .get("/get");

// then:
 assertThat(response.statusCode()).isEqualTo(200);
 assertThat(response.header("Content-Type")).matches("application/json.*");
// and:
 DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
 assertThatJson(parsedJson).field("['valueWithoutAMatcher']").isEqualTo("foo");
// and:
 assertThat(parsedJson.read("$.duck", String.class)).matches("[0-9]{3}");
 assertThat(parsedJson.read("$.duck", Integer.class)).isEqualTo(123);
 assertThat(parsedJson.read("$.alpha", String.class)).matches("[\\p{L}]*");
 assertThat(parsedJson.read("$.alpha", String.class)).isEqualTo("abc");
 assertThat(parsedJson.read("$.number", String.class)).matches("-?(\\d*\\.\\d+|\\d+)");
 assertThat(parsedJson.read("$.aBoolean", String.class)).matches("(true|false)");
 assertThat(parsedJson.read("$.date", String.class)).matches("(\\d\\d\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])");
 assertThat(parsedJson.read("$.dateTime", String.class)).matches("([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat(parsedJson.read("$.time", String.class)).matches("(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])");
 assertThat((Object) parsedJson.read("$.valueWithTypeMatch")).isInstanceOf(java.lang.String.class);
 assertThat((Object) parsedJson.read("$.valueWithMin")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMin", java.util.Collection.class)).as("$.valueWithMin").hasSizeGreaterThanOrEqualTo(1);
 assertThat((Object) parsedJson.read("$.valueWithMax")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMax", java.util.Collection.class)).as("$.valueWithMax").hasSizeLessThanOrEqualTo(3);
 assertThat((Object) parsedJson.read("$.valueWithMinMax")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMinMax", java.util.Collection.class)).as("$.valueWithMinMax").hasSizeBetween(1, 3);
 assertThat((Object) parsedJson.read("$.valueWithMinEmpty")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMinEmpty", java.util.Collection.class)).as("$.valueWithMinEmpty").hasSizeGreaterThanOrEqualTo(0);
 assertThat((Object) parsedJson.read("$.valueWithMaxEmpty")).isInstanceOf(java.util.List.class);
 assertThat((java.lang.Iterable) parsedJson.read("$.valueWithMaxEmpty", java.util.Collection.class)).as("$.valueWithMaxEmpty").hasSizeLessThanOrEqualTo(0);
 assertThatValueIsANumber(parsedJson.read("$.duck"));
 assertThat(parsedJson.read("$.['key'].['complex.key']", String.class)).isEqualTo("foo");</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请注意，对于<code>byCommand</code>方法，该示例调用<code>assertThatValueIsANumber</code> 。此方法必须在测试基类中定义或静态导入到测试中。请注意<code>byCommand</code>通话已转换为<code>assertThatValueIsANumber(parsedJson.read("$.duck"));</code> 。这意味着引擎采用了方法名称，并将正确的JSON路径作为参数传递给它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在下面的示例中，将生成WireMock存根：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">                    '''
{
  "request" : {
    "urlPath" : "/get",
    "method" : "POST",
    "headers" : {
      "Content-Type" : {
        "matches" : "application/json.*"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$.['list'].['some'].['nested'][?(@.['anothervalue'] == 4)]"
    }, {
      "matchesJsonPath" : "$[?(@.['valueWithoutAMatcher'] == 'foo')]"
    }, {
      "matchesJsonPath" : "$[?(@.['valueWithTypeMatch'] == 'string')]"
    }, {
      "matchesJsonPath" : "$.['list'].['someother'].['nested'][?(@.['json'] == 'with value')]"
    }, {
      "matchesJsonPath" : "$.['list'].['someother'].['nested'][?(@.['anothervalue'] == 4)]"
    }, {
      "matchesJsonPath" : "$[?(@.duck =~ /([0-9]{3})/)]"
    }, {
      "matchesJsonPath" : "$[?(@.duck == 123)]"
    }, {
      "matchesJsonPath" : "$[?(@.alpha =~ /([\\\\p{L}]*)/)]"
    }, {
      "matchesJsonPath" : "$[?(@.alpha == 'abc')]"
    }, {
      "matchesJsonPath" : "$[?(@.number =~ /(-?(\\\\d*\\\\.\\\\d+|\\\\d+))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.aBoolean =~ /((true|false))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.date =~ /((\\\\d\\\\d\\\\d\\\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.dateTime =~ /(([0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
    }, {
      "matchesJsonPath" : "$[?(@.time =~ /((2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9]))/)]"
    }, {
      "matchesJsonPath" : "$.list.some.nested[?(@.json =~ /(.*)/)]"
    }, {
      "matchesJsonPath" : "$[?(@.valueWithMin.size() >= 1)]"
    }, {
      "matchesJsonPath" : "$[?(@.valueWithMax.size() <= 3)]"
    }, {
      "matchesJsonPath" : "$[?(@.valueWithMinMax.size() >= 1 && @.valueWithMinMax.size() <= 3)]"
    }, {
      "matchesJsonPath" : "$[?(@.valueWithOccurrence.size() >= 4 && @.valueWithOccurrence.size() <= 4)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\\"duck\\":123,\\"alpha\\":\\"abc\\",\\"number\\":123,\\"aBoolean\\":true,\\"date\\":\\"2017-01-01\\",\\"dateTime\\":\\"2017-01-01T01:23:45\\",\\"time\\":\\"01:02:34\\",\\"valueWithoutAMatcher\\":\\"foo\\",\\"valueWithTypeMatch\\":\\"string\\",\\"valueWithMin\\":[1,2,3],\\"valueWithMax\\":[1,2,3],\\"valueWithMinMax\\":[1,2,3],\\"valueWithOccurrence\\":[1,2,3,4]}",
    "headers" : {
      "Content-Type" : "application/json"
    },
    "transformers" : [ "response-template" ]
  }
}
'''</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您使用<code>matcher</code> ，请求和响应的一部分<code>matcher</code>具有JSON路径的地址将从断言中删除。在验证集合的情况下，必须为集合的<strong>所有</strong>元素创建匹配器。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    request {
        method 'GET'
        url("/foo")
    }
    response {
        status OK()
        body(events: [[
                                 operation          : 'EXPORT',
                                 eventId            : '16f1ed75-0bcc-4f0d-a04d-3121798faf99',
                                 status             : 'OK'
                         ], [
                                 operation          : 'INPUT_PROCESSING',
                                 eventId            : '3bb4ac82-6652-462f-b6d1-75e424a0024a',
                                 status             : 'OK'
                         ]
                ]
        )
        bodyMatchers {
            jsonPath('$.events[0].operation', byRegex('.+'))
            jsonPath('$.events[0].eventId', byRegex('^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})$'))
            jsonPath('$.events[0].status', byRegex('.+'))
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码导致创建以下测试（代码块仅显示断言部分）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">and:
    DocumentContext parsedJson = JsonPath.parse(response.body.asString())
    assertThatJson(parsedJson).array("['events']").contains("['eventId']").isEqualTo("16f1ed75-0bcc-4f0d-a04d-3121798faf99")
    assertThatJson(parsedJson).array("['events']").contains("['operation']").isEqualTo("EXPORT")
    assertThatJson(parsedJson).array("['events']").contains("['operation']").isEqualTo("INPUT_PROCESSING")
    assertThatJson(parsedJson).array("['events']").contains("['eventId']").isEqualTo("3bb4ac82-6652-462f-b6d1-75e424a0024a")
    assertThatJson(parsedJson).array("['events']").contains("['status']").isEqualTo("OK")
and:
    assertThat(parsedJson.read("\$.events[0].operation", String.class)).matches(".+")
    assertThat(parsedJson.read("\$.events[0].eventId", String.class)).matches("^([a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})\$")
    assertThat(parsedJson.read("\$.events[0].status", String.class)).matches(".+")</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，断言的格式不正确。仅声明数组的第一个元素。为了解决这个问题，您应该将断言应用于整个<code>$.events</code>集合并使用<code>byCommand(…​)</code>方法。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="contract-dsl-async"><a class="anchor" href="#contract-dsl-async"></a> <a class="link" href="#contract-dsl-async">异步支持</a></h5>
<div class="paragraph">
<p>如果您在服务器端使用异步通信（您的控制器正在返回<code>Callable</code> ， <code>DeferredResult</code> ，依此类推），然后，您必须在合同中提供一个<code>async()</code>中的方法<code>response</code>部分。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status OK()
        body 'Passed'
        async()
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">response:
    async: true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class contract implements Supplier<Collection<Contract>> {

    @Override
    public Collection<Contract> get() {
        return Collections.singletonList(Contract.make(c -> {
            c.request(r -> {
                // ...
            });
            c.response(r -> {
                r.async();
                // ...
            });
        }));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        // ...
    }
    response {
        async = true
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您也可以使用<code>fixedDelayMilliseconds</code>方法或属性，以增加存根的延迟。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method GET()
        url '/get'
    }
    response {
        status 200
        body 'Passed'
        fixedDelayMilliseconds 1000
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">response:
    fixedDelayMilliseconds: 1000</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class contract implements Supplier<Collection<Contract>> {

    @Override
    public Collection<Contract> get() {
        return Collections.singletonList(Contract.make(c -> {
            c.request(r -> {
                // ...
            });
            c.response(r -> {
                r.fixedDelayMilliseconds(1000);
                // ...
            });
        }));
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        // ...
    }
    response {
        delay = fixedMilliseconds(1000)
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="contract-dsl-xml"><a class="anchor" href="#contract-dsl-xml"></a> <a class="link" href="#contract-dsl-xml">XML对HTTP的支持</a></h5>
<div class="paragraph">
<p>对于HTTP合同，我们还支持在请求和响应正文中使用XML。XML主体必须在<code>body</code>作为一个元素<code>String</code>要么<code>GString</code> 。同样，可以为请求和响应提供正文匹配器。代替<code>jsonPath(…​)</code>方法， <code>org.springframework.cloud.contract.spec.internal.BodyMatchers.xPath</code>应该使用所需的方法<code>xPath</code>作为第一个参数和适当的<code>MatchingType</code>作为第二。除了所有的身体匹配器<code>byType()</code>支持。</p>
</div>
<div class="paragraph">
<p>以下示例显示了响应正文中具有XML的Groovy DSL合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    Contract.make {
                        request {
                            method GET()
                            urlPath '/get'
                            headers {
                                contentType(applicationXml())
                            }
                        }
                        response {
                            status(OK())
                            headers {
                                contentType(applicationXml())
                            }
                            body """
<test>
<duck type='xtype'>123</duck>
<alpha>abc</alpha>
<list>
<elem>abc</elem>
<elem>def</elem>
<elem>ghi</elem>
</list>
<number>123</number>
<aBoolean>true</aBoolean>
<date>2017-01-01</date>
<dateTime>2017-01-01T01:23:45</dateTime>
<time>01:02:34</time>
<valueWithoutAMatcher>foo</valueWithoutAMatcher>
<key><complex>foo</complex></key>
</test>"""
                            bodyMatchers {
                                xPath('/test/duck/text()', byRegex("[0-9]{3}"))
                                xPath('/test/duck/text()', byCommand('equals($it)'))
                                xPath('/test/duck/xxx', byNull())
                                xPath('/test/duck/text()', byEquality())
                                xPath('/test/alpha/text()', byRegex(onlyAlphaUnicode()))
                                xPath('/test/alpha/text()', byEquality())
                                xPath('/test/number/text()', byRegex(number()))
                                xPath('/test/date/text()', byDate())
                                xPath('/test/dateTime/text()', byTimestamp())
                                xPath('/test/time/text()', byTime())
                                xPath('/test/*/complex/text()', byEquality())
                                xPath('/test/duck/@type', byEquality())
                            }
                        }
                    }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">include::/home/marcin/repo/spring-cloud-scripts/contract/spring-cloud-contract-verifier/src/test/resources/yml/contract_rest_xml.yml</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.function.Supplier;

import org.springframework.cloud.contract.spec.Contract;

class contract_xml implements Supplier<Contract> {

    @Override
    public Contract get() {
        return Contract.make(c -> {
            c.request(r -> {
                r.method(r.GET());
                r.urlPath("/get");
                r.headers(h -> {
                    h.contentType(h.applicationXml());
                });
            });
            c.response(r -> {
                r.status(r.OK());
                r.headers(h -> {
                    h.contentType(h.applicationXml());
                });
                r.body("<test>\n" + "<duck type='xtype'>123</duck>\n"
                        + "<alpha>abc</alpha>\n" + "<list>\n" + "<elem>abc</elem>\n"
                        + "<elem>def</elem>\n" + "<elem>ghi</elem>\n" + "</list>\n"
                        + "<number>123</number>\n" + "<aBoolean>true</aBoolean>\n"
                        + "<date>2017-01-01</date>\n"
                        + "<dateTime>2017-01-01T01:23:45</dateTime>\n"
                        + "<time>01:02:34</time>\n"
                        + "<valueWithoutAMatcher>foo</valueWithoutAMatcher>\n"
                        + "<key><complex>foo</complex></key>\n" + "</test>");
                r.bodyMatchers(m -> {
                    m.xPath("/test/duck/text()", m.byRegex("[0-9]{3}"));
                    m.xPath("/test/duck/text()", m.byCommand("equals($it)"));
                    m.xPath("/test/duck/xxx", m.byNull());
                    m.xPath("/test/duck/text()", m.byEquality());
                    m.xPath("/test/alpha/text()", m.byRegex(r.onlyAlphaUnicode()));
                    m.xPath("/test/alpha/text()", m.byEquality());
                    m.xPath("/test/number/text()", m.byRegex(r.number()));
                    m.xPath("/test/date/text()", m.byDate());
                    m.xPath("/test/dateTime/text()", m.byTimestamp());
                    m.xPath("/test/time/text()", m.byTime());
                    m.xPath("/test/*/complex/text()", m.byEquality());
                    m.xPath("/test/duck/@type", m.byEquality());
                });
            });
        });
    };

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

contract {
    request {
        method = GET
        urlPath = path("/get")
        headers {
            contentType = APPLICATION_XML
        }
    }
    response {
        status = OK
        headers {
            contentType =APPLICATION_XML
        }
        body = body("<test>\n" + "<duck type='xtype'>123</duck>\n"
                + "<alpha>abc</alpha>\n" + "<list>\n" + "<elem>abc</elem>\n"
                + "<elem>def</elem>\n" + "<elem>ghi</elem>\n" + "</list>\n"
                + "<number>123</number>\n" + "<aBoolean>true</aBoolean>\n"
                + "<date>2017-01-01</date>\n"
                + "<dateTime>2017-01-01T01:23:45</dateTime>\n"
                + "<time>01:02:34</time>\n"
                + "<valueWithoutAMatcher>foo</valueWithoutAMatcher>\n"
                + "<key><complex>foo</complex></key>\n" + "</test>")
        bodyMatchers {
            xPath("/test/duck/text()", byRegex("[0-9]{3}"))
            xPath("/test/duck/text()", byCommand("equals(\$it)"))
            xPath("/test/duck/xxx", byNull)
            xPath("/test/duck/text()", byEquality)
            xPath("/test/alpha/text()", byRegex(onlyAlphaUnicode))
            xPath("/test/alpha/text()", byEquality)
            xPath("/test/number/text()", byRegex(number))
            xPath("/test/date/text()", byDate)
            xPath("/test/dateTime/text()", byTimestamp)
            xPath("/test/time/text()", byTime)
            xPath("/test/*/complex/text()", byEquality)
            xPath("/test/duck/@type", byEquality)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例在响应正文中显示了针对XML的自动生成的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void validate_xmlMatches() throws Exception {
    // given:
    MockMvcRequestSpecification request = given()
                .header("Content-Type", "application/xml");

    // when:
    ResponseOptions response = given().spec(request).get("/get");

    // then:
    assertThat(response.statusCode()).isEqualTo(200);
    // and:
    DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance()
                    .newDocumentBuilder();
    Document parsedXml = documentBuilder.parse(new InputSource(
                new StringReader(response.getBody().asString())));
    // and:
    assertThat(valueFromXPath(parsedXml, "/test/list/elem/text()")).isEqualTo("abc");
    assertThat(valueFromXPath(parsedXml,"/test/list/elem[2]/text()")).isEqualTo("def");
    assertThat(valueFromXPath(parsedXml, "/test/duck/text()")).matches("[0-9]{3}");
    assertThat(nodeFromXPath(parsedXml, "/test/duck/xxx")).isNull();
    assertThat(valueFromXPath(parsedXml, "/test/alpha/text()")).matches("[\\p{L}]*");
    assertThat(valueFromXPath(parsedXml, "/test/*/complex/text()")).isEqualTo("foo");
    assertThat(valueFromXPath(parsedXml, "/test/duck/@type")).isEqualTo("xtype");
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="contract-dsl-multiple"><a class="anchor" href="#contract-dsl-multiple"></a> <a class="link" href="#contract-dsl-multiple">一个文件中的多个合同</a></h5>
<div class="paragraph">
<p>您可以在一个文件中定义多个合同。这样的合同可能类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

[
    Contract.make {
        name("should post a user")
        request {
            method 'POST'
            url('/users/1')
        }
        response {
            status OK()
        }
    },
    Contract.make {
        request {
            method 'POST'
            url('/users/2')
        }
        response {
            status OK()
        }
    }
]</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">---
name: should post a user
request:
  method: POST
  url: /users/1
response:
  status: 200
---
request:
  method: POST
  url: /users/2
response:
  status: 200
---
request:
  method: POST
  url: /users/3
response:
  status: 200</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">爪哇</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class contract implements Supplier<Collection<Contract>> {

    @Override
    public Collection<Contract> get() {
        return Arrays.asList(
            Contract.make(c -> {
                c.name("should post a user");
                // ...
            }), Contract.make(c -> {
                // ...
            }), Contract.make(c -> {
                // ...
            })
        );
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">科特林</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">import org.springframework.cloud.contract.spec.ContractDsl.Companion.contract

arrayOf(
    contract {
        name("should post a user")
        // ...
    },
    contract {
        // ...
    },
    contract {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，一个合同具有<code>name</code>字段，其他则不行。这导致生成两个看起来或多或少如下的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.cloud.contract.verifier.tests.com.hello;

import com.example.TestBase;
import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import com.jayway.restassured.module.mockmvc.specification.MockMvcRequestSpecification;
import com.jayway.restassured.response.ResponseOptions;
import org.junit.Test;

import static com.jayway.restassured.module.mockmvc.RestAssuredMockMvc.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.assertj.core.api.Assertions.assertThat;

public class V1Test extends TestBase {

    @Test
    public void validate_should_post_a_user() throws Exception {
        // given:
            MockMvcRequestSpecification request = given();

        // when:
            ResponseOptions response = given().spec(request)
                    .post("/users/1");

        // then:
            assertThat(response.statusCode()).isEqualTo(200);
    }

    @Test
    public void validate_withList_1() throws Exception {
        // given:
            MockMvcRequestSpecification request = given();

        // when:
            ResponseOptions response = given().spec(request)
                    .post("/users/2");

        // then:
            assertThat(response.statusCode()).isEqualTo(200);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，对于具有<code>name</code>字段，将生成的测试方法命名为<code>validate_should_post_a_user</code> 。一个没有的<code>name</code>字段称为<code>validate_withList_1</code> 。它对应于文件名<code>WithList.groovy</code>以及列表中合同的索引。</p>
</div>
<div class="paragraph">
<p>下例显示了生成的存根：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>should post a user.json
1_WithList.json</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个文件得到了<code>name</code>合同中的参数。第二个得到合同文件的名称（ <code>WithList.groovy</code> ）以索引开头（在这种情况下，合同的索引为<code>1</code>在文件中的合同列表中）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">最好命名您的合同，因为这样做会使您的测试更有意义。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="contract-stateful-contracts"><a class="anchor" href="#contract-stateful-contracts"></a> <a class="link" href="#contract-stateful-contracts">有状态合同</a></h5>
<div class="paragraph">
<p>有状态合同（也称为方案）是应按顺序阅读的合同定义。在以下情况下这可能很有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您想以精确定义的顺序执行合同，因为您使用Spring Cloud Contract测试您的有状态应用程序</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们真的不鼓励您这样做，因为合同测试应该是无状态的。
</td>
</tr>
</tbody></table>
</div>
<div class="ulist">
<ul>
<li>
<p>您希望同一个端点为同一个请求返回不同的结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要创建有状态合同（或方案），您需要在创建合同时使用正确的命名约定。约定要求在订货号后加上下划线。无论您使用的是YAML还是Groovy，这都有效。以下清单显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>my_contracts_dir\
  scenario1\
    1_login.groovy
    2_showCart.groovy
    3_logout.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样的树使Spring Cloud Contract Verifier生成名称为的WireMock场景<code>scenario1</code>以及以下三个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>登录，标记为<code>Started</code>指向...</p>
</li>
<li>
<p>showCart，标记为<code>Step1</code>指向...</p>
</li>
<li>
<p>注销，标记为<code>Step2</code> （这将关闭方案）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>您可以在<a href="https://wiremock.org/docs/stateful-behaviour/">https://wiremock.org/docs/stateful-behaviour/中</a>找到有关WireMock方案的更多详细信息。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="feature-integrations"><a class="anchor" href="#feature-integrations"></a> <a class="link" href="#feature-integrations">14.3.3。整合方式</a></h4>
<div class="sect4">
<h5 id="features-jax-rs"><a class="anchor" href="#features-jax-rs"></a> <a class="link" href="#features-jax-rs">JAX-RS</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract支持JAX-RS 2客户端API。基类需要定义<code>protected WebTarget webTarget</code>和服务器初始化。测试JAX-RS API的唯一选项是启动Web服务器。同样，带有主体的请求需要设置内容类型。否则，默认为<code>application/octet-stream</code>被习惯。</p>
</div>
<div class="paragraph">
<p>为了使用JAX-RS模式，请使用以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">testMode = 'JAXRSCLIENT'</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了生成的测试API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    """\
package com.example;

import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import org.junit.Test;
import org.junit.Rule;
import javax.ws.rs.client.Entity;
import javax.ws.rs.core.Response;

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static javax.ws.rs.client.Entity.*;

@SuppressWarnings("rawtypes")
public class FooTest {
\tWebTarget webTarget;

\t@Test
\tpublic void validate_() throws Exception {

\t\t// when:
\t\t\tResponse response = webTarget
\t\t\t\t\t\t\t.path("/users")
\t\t\t\t\t\t\t.queryParam("limit", "10")
\t\t\t\t\t\t\t.queryParam("offset", "20")
\t\t\t\t\t\t\t.queryParam("filter", "email")
\t\t\t\t\t\t\t.queryParam("sort", "name")
\t\t\t\t\t\t\t.queryParam("search", "55")
\t\t\t\t\t\t\t.queryParam("age", "99")
\t\t\t\t\t\t\t.queryParam("name", "Denis.Stepanov")
\t\t\t\t\t\t\t.queryParam("email", "bob@email.com")
\t\t\t\t\t\t\t.request()
\t\t\t\t\t\t\t.build("GET")
\t\t\t\t\t\t\t.invoke();
\t\t\tString responseAsString = response.readEntity(String.class);

\t\t// then:
\t\t\tassertThat(response.getStatus()).isEqualTo(200);

\t\t// and:
\t\t\tDocumentContext parsedJson = JsonPath.parse(responseAsString);
\t\t\tassertThatJson(parsedJson).field("['property1']").isEqualTo("a");
\t}

}

"""</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="feature-webflux"><a class="anchor" href="#feature-webflux"></a> <a class="link" href="#feature-webflux">WebFlux与WebTestClient</a></h5>
<div class="paragraph">
<p>您可以使用WebTestClient使用WebFlux。以下清单显示了如何将WebTestClient配置为测试模式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <testMode>WEBTESTCLIENT</testMode>
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
        testMode = 'WEBTESTCLIENT'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何为WebFlux设置WebTestClient基类和RestAssured：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import io.restassured.module.webtestclient.RestAssuredWebTestClient;
import org.junit.Before;

public abstract class BeerRestBase {

    @Before
    public void setup() {
        RestAssuredWebTestClient.standaloneSetup(
        new ProducerController(personToCheck -> personToCheck.age >= 20));
    }
}
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">的<code>WebTestClient</code>模式比<code>EXPLICIT</code>模式。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="feature-webflux-explicit"><a class="anchor" href="#feature-webflux-explicit"></a> <a class="link" href="#feature-webflux-explicit">WebFlux具有显式模式</a></h5>
<div class="paragraph">
<p>您也可以在生成的测试中将WebFlux与显式模式一起使用，以与WebFlux一起使用。以下示例显示如何使用显式模式进行配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <testMode>EXPLICIT</testMode>
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
        testMode = 'EXPLICIT'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何为Web Flux设置基类和RestAssured：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@RunWith(SpringRunner.class)
@SpringBootTest(classes = BeerRestBase.Config.class,
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
        properties = "server.port=0")
public abstract class BeerRestBase {

    // your tests go here

    // in this config class you define all controllers and mocked services
@Configuration
@EnableAutoConfiguration
static class Config {

    @Bean
    PersonCheckingService personCheckingService()  {
        return personToCheck -> personToCheck.age >= 20;
    }

    @Bean
    ProducerController producerController() {
        return new ProducerController(personCheckingService());
    }
}

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-context-paths"><a class="anchor" href="#features-context-paths"></a> <a class="link" href="#features-context-paths">使用上下文路径</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract支持上下文路径。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>完全支持上下文路径所需的唯一更改是生产者端的开关。另外，自动生成的测试必须使用显式模式。消费者方面保持不变。为了使生成的测试通过，必须使用显式模式。以下示例显示了如何将测试模式设置为<code>EXPLICIT</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <testMode>EXPLICIT</testMode>
    </configuration>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
        testMode = 'EXPLICIT'
}</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这样，您生成的测试不使用MockMvc。这意味着您要生成真实的请求，并且需要设置生成的测试的基类以在真实套接字上工作。</p>
</div>
<div class="paragraph">
<p>考虑以下合同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'GET'
        url '/my-context-path/url'
    }
    response {
        status OK()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何设置基类和RestAssured：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import io.restassured.RestAssured;
import org.junit.Before;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(classes = ContextPathTestingBaseClass.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ContextPathTestingBaseClass {

    @LocalServerPort int port;

    @Before
    public void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = this.port;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您这样做：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动生成的测试中的所有请求都将发送到包含您的上下文路径的真实端点（例如， <code>/my-context-path/url</code> ）。</p>
</li>
<li>
<p>您的合同反映出您具有上下文路径。您生成的存根还具有该信息（例如，在存根中，您必须调用<code>/my-context-path/url</code> ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="features-rest-docs"><a class="anchor" href="#features-rest-docs"></a> <a class="link" href="#features-rest-docs">使用REST Docs</a></h5>
<div class="paragraph">
<p>您可以使用<a href="https://projects.spring.io/spring-restdocs">Spring REST Docs</a>使用<a href="https://projects.spring.io/spring-restdocs">Spring</a> MockMvc为HTTP API生成文档（例如，Ascidoc格式）， <code>WebTestClient</code>或RestAssured。在为API生成文档的同时，还可以使用Spring Cloud Contract WireMock生成WireMock存根。为此，请编写常规的REST Docs测试用例并使用<code>@AutoConfigureRestDocs</code>在REST Docs输出目录中自动生成存根。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/rest-docs.png" alt="休息文档" width="1237" height="835">
</div>
</div>
<div class="paragraph">
<p>以下示例使用<code>MockMvc</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void contextLoads() throws Exception {
        mockMvc.perform(get("/resource"))
                .andExpect(content().string("Hello World"))
                .andDo(document("resource"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此测试在以下位置生成WireMock存根<code>target/snippets/stubs/resource.json</code> 。它匹配所有<code>GET</code>要求<code>/resource</code>路径。同一个例子<code>WebTestClient</code> （用于测试Spring WebFlux应用程序）如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureWebTestClient
public class ApplicationTests {

    @Autowired
    private WebTestClient client;

    @Test
    public void contextLoads() throws Exception {
        client.get().uri("/resource").exchange()
                .expectBody(String.class).isEqualTo("Hello World")
                .consumeWith(document("resource"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在没有任何其他配置的情况下，这些测试将为HTTP方法和所有标头创建一个带有请求匹配器的存根。 <code>host</code>和<code>content-length</code> 。为了更精确地匹配请求（例如，匹配POST或PUT的正文），我们需要显式创建一个请求匹配器。这样做有两个效果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建仅以您指定的方式匹配的存根。</p>
</li>
<li>
<p>断言测试用例中的请求也匹配相同的条件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此功能的主要入口点是<code>WireMockRestDocs.verify()</code> ，可以代替<code>document()</code>便捷方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.springframework.cloud.contract.wiremock.restdocs.WireMockRestDocs.verify;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureRestDocs(outputDir = "target/snippets")
@AutoConfigureMockMvc
public class ApplicationTests {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void contextLoads() throws Exception {
        mockMvc.perform(post("/resource")
                .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
                .andExpect(status().isOk())
                .andDo(verify().jsonPath("$.id")
                .andDo(document("resource"));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>先前的合同规定，带有<code>id</code>字段接收此测试中定义的响应。您可以将呼叫链接到<code>.jsonPath()</code>添加其他匹配器。如果不熟悉JSON Path， <a href="https://github.com/jayway/JsonPath">JayWay文档</a>可以帮助您快速<a href="https://github.com/jayway/JsonPath">入门</a> 。的<code>WebTestClient</code>此测试的版本具有相似的<code>verify()</code>您在同一位置插入的静态帮助器。</p>
</div>
<div class="paragraph">
<p>而不是<code>jsonPath</code>和<code>contentType</code>便捷方法，您还可以使用WireMock API验证请求是否与创建的存根匹配，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void contextLoads() throws Exception {
    mockMvc.perform(post("/resource")
            .content("{\"id\":\"123456\",\"message\":\"Hello World\"}"))
            .andExpect(status().isOk())
            .andDo(verify()
                    .wiremock(WireMock.post(
                        urlPathEquals("/resource"))
                        .withRequestBody(matchingJsonPath("$.id"))
                        .andDo(document("post-resource"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WireMock API丰富。您可以通过正则表达式以及JSON路径匹配标头，查询参数和请求正文。您可以使用这些功能来创建具有更广泛参数范围的存根。前面的示例生成一个类似于以下示例的存根：</p>
</div>
<div class="listingblock">
<div class="title">post-resource.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request" : {
    "url" : "/resource",
    "method" : "POST",
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$.id"
    }]
  },
  "response" : {
    "status" : 200,
    "body" : "Hello World",
    "headers" : {
      "X-Application-Context" : "application:-1",
      "Content-Type" : "text/plain"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以使用<code>wiremock()</code>方法或<code>jsonPath()</code>和<code>contentType()</code>创建请求匹配器的方法，但是不能同时使用这两种方法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在消费者方面，您可以<code>resource.json</code>本节前面部分生成的生成可在类路径上使用（例如，通过将<a href="#features-stub-runner-publishing-stubs-as-jars">存根发布为JAR</a> ）。之后，您可以创建以多种不同方式使用WireMock的存根，包括使用<code>@AutoConfigureWireMock(stubs="classpath:resource.json")</code> ，如本文档前面所述。</p>
</div>
<div class="sect5">
<h6 id="features-rest-docs-contracts"><a class="anchor" href="#features-rest-docs-contracts"></a> <a class="link" href="#features-rest-docs-contracts">使用REST文档生成合同</a></h6>
<div class="paragraph">
<p>您还可以使用Spring REST Docs生成Spring Cloud Contract DSL文件和文档。如果与Spring Cloud WireMock结合使用，则会同时获得合同和存根。</p>
</div>
<div class="paragraph">
<p>您为什么要使用此功能？社区中的一些人询问有关他们希望转向基于DSL的合同定义的情况的问题，但是他们已经进行了许多Spring MVC测试。使用此功能，您可以生成合同文件，以后可以修改合同文件并将其移至文件夹（在配置中定义），以便插件找到它们。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可能想知道为什么WireMock模块中有此功能。之所以具有此功能是因为生成合同和存根都是有意义的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑以下测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        this.mockMvc
                .perform(post("/foo").accept(MediaType.APPLICATION_PDF)
                        .accept(MediaType.APPLICATION_JSON)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"foo\": 23, \"bar\" : \"baz\" }"))
                .andExpect(status().isOk()).andExpect(content().string("bar"))
                // first WireMock
                .andDo(WireMockRestDocs.verify().jsonPath("$[?(@.foo >= 20)]")
                        .jsonPath("$[?(@.bar in ['baz','bazz','bazzz'])]")
                        .contentType(MediaType.valueOf("application/json")))
                // then Contract DSL documentation
                .andDo(document("index", SpringCloudContractRestDocs.dslContract()));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的测试将创建上一部分中介绍的存根，同时生成合同和文档文件。</p>
</div>
<div class="paragraph">
<p>合同叫做<code>index.groovy</code>可能类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method 'POST'
        url '/foo'
        body('''
            {"foo": 23 }
        ''')
        headers {
            header('''Accept''', '''application/json''')
            header('''Content-Type''', '''application/json''')
        }
    }
    response {
        status OK()
        body('''
        bar
        ''')
        headers {
            header('''Content-Type''', '''application/json;charset=UTF-8''')
            header('''Content-Length''', '''3''')
        }
        bodyMatchers {
            jsonPath('$[?(@.foo >= 20)]', byType())
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生成的文档（在这种情况下为Asciidoc格式）包含格式化的合同。该文件的位置是<code>index/dsl-contract.adoc</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="features-messaging"><a class="anchor" href="#features-messaging"></a> <a class="link" href="#features-messaging">14.3.4。讯息传递</a></h4>
<div class="paragraph">
<p>通过Spring Cloud Contract，您可以验证使用消息传递作为通信手段的应用程序。本文档中显示的所有集成都可以与Spring一起使用，但是您也可以创建自己的一个并使用它。</p>
</div>
<div class="sect4">
<h5 id="contract-dsl-messaging-top-level"><a class="anchor" href="#contract-dsl-messaging-top-level"></a> <a class="link" href="#contract-dsl-messaging-top-level">消息传送DSL顶级元素</a></h5>
<div class="paragraph">
<p>用于消息传递的DSL与专注于HTTP的DSL看起来有些不同。以下各节说明了差异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#contract-dsl-output-triggered-method">方法触发的输出</a></p>
</li>
<li>
<p><a href="#contract-dsl-output-triggered-message">消息触发的输出</a></p>
</li>
<li>
<p><a href="#contract-dsl-consumer-producer">消费者/生产者</a></p>
</li>
<li>
<p><a href="#contract-dsl-messaging-common">共同</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="contract-dsl-output-triggered-method"><a class="anchor" href="#contract-dsl-output-triggered-method"></a> <a class="link" href="#contract-dsl-output-triggered-method">方法触发的输出</a></h6>
<div class="paragraph">
<p>可以通过调用方法（例如<code>Scheduler</code>当合同开始并发送消息时），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def dsl = Contract.make {
    // Human readable description
    description 'Some description'
    // Label by means of which the output message can be triggered
    label 'some_label'
    // input to the contract
    input {
        // the contract will be triggered by a method
        triggeredBy('bookReturnedTriggered()')
    }
    // output message of the contract
    outputMessage {
        // destination to which the output message will be sent
        sentTo('output')
        // the body of the output message
        body('''{ "bookName" : "foo" }''')
        // the headers of the output message
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy"># Human readable description
description: Some description
# Label by means of which the output message can be triggered
label: some_label
input:
  # the contract will be triggered by a method
  triggeredBy: bookReturnedTriggered()
# output message of the contract
outputMessage:
  # destination to which the output message will be sent
  sentTo: output
  # the body of the output message
  body:
    bookName: foo
  # the headers of the output message
  headers:
    BOOK-NAME: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，输出消息被发送到<code>output</code>如果一个方法叫做<code>bookReturnedTriggered</code>被执行。在消息发布者方面，我们生成了一个测试，该测试调用该方法来触发消息。在消费者方面，您可以使用<code>some_label</code>触发消息。</p>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-output-triggered-message"><a class="anchor" href="#contract-dsl-output-triggered-message"></a> <a class="link" href="#contract-dsl-output-triggered-message">消息触发的输出</a></h6>
<div class="paragraph">
<p>可以通过接收一条消息来触发输出消息，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def dsl = Contract.make {
    description 'Some Description'
    label 'some_label'
    // input is a message
    input {
        // the message was received from this destination
        messageFrom('input')
        // has the following body
        messageBody([
                bookName: 'foo'
        ])
        // and the following headers
        messageHeaders {
            header('sample', 'header')
        }
    }
    outputMessage {
        sentTo('output')
        body([
                bookName: 'foo'
        ])
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy"># Human readable description
description: Some description
# Label by means of which the output message can be triggered
label: some_label
# input is a message
input:
  messageFrom: input
  # has the following body
  messageBody:
    bookName: 'foo'
  # and the following headers
  messageHeaders:
    sample: 'header'
# output message of the contract
outputMessage:
  # destination to which the output message will be sent
  sentTo: output
  # the body of the output message
  body:
    bookName: foo
  # the headers of the output message
  headers:
    BOOK-NAME: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，输出消息被发送到<code>output</code>如果在<code>input</code>目的地。在消息发布者方面，引擎生成一个测试，将该输入消息发送到定义的目的地。在消费者方面，您可以将消息发送到输入目标，也可以使用标签（ <code>some_label</code>在示例中）触发消息。</p>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-consumer-producer"><a class="anchor" href="#contract-dsl-consumer-producer"></a> <a class="link" href="#contract-dsl-consumer-producer">消费者/生产者</a></h6>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本节仅对Groovy DSL有效。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在HTTP中，您有一个概念<code>client</code> / <code>stub and `server</code> / <code>test</code>符号。您也可以在消息传递中使用这些范例。此外，Spring Cloud Contract Verifier还提供了<code>consumer</code>和<code>producer</code>方法，如以下示例所示（请注意，您可以使用<code>$</code>要么<code>value</code>提供方法<code>consumer</code>和<code>producer</code>部分）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    Contract.make {
                name "foo"
                        label 'some_label'
                        input {
                            messageFrom value(consumer('jms:output'), producer('jms:input'))
                            messageBody([
                                    bookName: 'foo'
                            ])
                            messageHeaders {
                                header('sample', 'header')
                            }
                        }
                        outputMessage {
                            sentTo $(consumer('jms:input'), producer('jms:output'))
                            body([
                                    bookName: 'foo'
                            ])
                        }
                    }</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="contract-dsl-messaging-common"><a class="anchor" href="#contract-dsl-messaging-common"></a> <a class="link" href="#contract-dsl-messaging-common">共同</a></h6>
<div class="paragraph">
<p>在里面<code>input</code>要么<code>outputMessage</code>部分，您可以致电<code>assertThat</code>名称为<code>method</code> （例如， <code>assertThatMessageIsOnTheQueue()</code> ），您已经在基类或静态导入中定义了该代码。Spring Cloud Contract在生成的测试中运行该方法。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-integrations"><a class="anchor" href="#features-messaging-integrations"></a> <a class="link" href="#features-messaging-integrations">整合方式</a></h5>
<div class="paragraph">
<p>您可以使用以下四种集成配置之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>阿帕奇骆驼</p>
</li>
<li>
<p>春季整合</p>
</li>
<li>
<p>春季云流</p>
</li>
<li>
<p>春季AMQP</p>
</li>
<li>
<p>Spring JMS（需要嵌入式代理）</p>
</li>
<li>
<p>Spring Kafka（需要嵌入式经纪人）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于我们使用Spring Boot，因此，如果您已将这些库之一添加到类路径中，则会自动设置所有消息传递配置。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">记得放<code>@AutoConfigureMessageVerifier</code>在您生成的测试的基类上。否则，Spring Cloud Contract的消息传递部分将无法正常工作。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要使用Spring Cloud Stream，请记住添加对<code>org.springframework.cloud:spring-cloud-stream-test-support</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-stream-test-support</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">testCompile "org.springframework.cloud:spring-cloud-stream-test-support"</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="features-messaging-manual"><a class="anchor" href="#features-messaging-manual"></a> <a class="link" href="#features-messaging-manual">手动集成测试</a></h6>
<div class="paragraph">
<p>测试使用的主要界面是<code>org.springframework.cloud.contract.verifier.messaging.MessageVerifier</code> 。它定义了如何发送和接收消息。您可以创建自己的实现以实现相同的目标。</p>
</div>
<div class="paragraph">
<p>在测试中，您可以注入一个<code>ContractVerifierMessageExchange</code>发送和接收遵循合同的消息。然后加<code>@AutoConfigureMessageVerifier</code>测试。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringTestRunner.class)
@SpringBootTest
@AutoConfigureMessageVerifier
public static class MessagingContractTests {

  @Autowired
  private MessageVerifier verifier;
  ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您的测试也需要存根，则<code>@AutoConfigureStubRunner</code>包括消息传递配置，因此您只需要一个注释。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-test-generation"><a class="anchor" href="#features-messaging-test-generation"></a> <a class="link" href="#features-messaging-test-generation">生产者端消息传递测试生成</a></h5>
<div class="paragraph">
<p>有<code>input</code>要么<code>outputMessage</code> DSL中的小节会在发布商方面创建测试。默认情况下，将创建JUnit 4测试。但是，也可以创建JUnit 5，TestNG或Spock测试。</p>
</div>
<div class="paragraph">
<p>我们应考虑三种主要情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>方案1：没有输入消息会生成输出消息。输出消息由应用程序内部的组件（例如，调度程序）触发。</p>
</li>
<li>
<p>方案2：输入消息触发输出消息。</p>
</li>
<li>
<p>方案3：输入消息已被使用，并且没有输出消息。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">目的地已传递至<code>messageFrom</code>要么<code>sentTo</code>对于不同的消息传递实现，可以具有不同的含义。对于流和集成，首先将其解析为<code>destination</code>频道那如果没有<code>destination</code>它被解析为频道名称。对于骆驼来说，这是一定的组成部分（例如， <code>jms</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="features-messaging-scenario1"><a class="anchor" href="#features-messaging-scenario1"></a> <a class="link" href="#features-messaging-scenario1">方案1：无输入消息</a></h6>
<div class="paragraph">
<p>考虑以下合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def contractDsl = Contract.make {
    name "foo"
    label 'some_label'
    input {
        triggeredBy('bookReturnedTriggered()')
    }
    outputMessage {
        sentTo('activemq:output')
        body('''{ "bookName" : "foo" }''')
        headers {
            header('BOOK-NAME', 'foo')
            messagingContentType(applicationJson())
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">label: some_label
input:
  triggeredBy: bookReturnedTriggered
outputMessage:
  sentTo: activemq:output
  body:
    bookName: foo
  headers:
    BOOK-NAME: foo
    contentType: application/json</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于前面的示例，将创建以下测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">JUnit的</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">                    '''\
package com.example;

import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import org.junit.Test;
import org.junit.Rule;
import javax.inject.Inject;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierObjectMapper;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessage;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessaging;

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.springframework.cloud.contract.verifier.messaging.util.ContractVerifierMessagingUtil.headers;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.fileToBytes;

@SuppressWarnings("rawtypes")
public class FooTest {
\t@Inject ContractVerifierMessaging contractVerifierMessaging;
\t@Inject ContractVerifierObjectMapper contractVerifierObjectMapper;

\t@Test
\tpublic void validate_foo() throws Exception {
\t\t// when:
\t\t\tbookReturnedTriggered();

\t\t// then:
\t\t\tContractVerifierMessage response = contractVerifierMessaging.receive("activemq:output");
\t\t\tassertThat(response).isNotNull();

\t\t// and:
\t\t\tassertThat(response.getHeader("BOOK-NAME")).isNotNull();
\t\t\tassertThat(response.getHeader("BOOK-NAME").toString()).isEqualTo("foo");
\t\t\tassertThat(response.getHeader("contentType")).isNotNull();
\t\t\tassertThat(response.getHeader("contentType").toString()).isEqualTo("application/json");

\t\t// and:
\t\t\tDocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
\t\t\tassertThatJson(parsedJson).field("['bookName']").isEqualTo("foo");
\t}

}

'''</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">斯波克</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    '''\
package com.example

import com.jayway.jsonpath.DocumentContext
import com.jayway.jsonpath.JsonPath
import spock.lang.Specification
import javax.inject.Inject
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierObjectMapper
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessage
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessaging

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson
import static org.springframework.cloud.contract.verifier.messaging.util.ContractVerifierMessagingUtil.headers
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.fileToBytes

@SuppressWarnings("rawtypes")
class FooSpec extends Specification {
\t@Inject ContractVerifierMessaging contractVerifierMessaging
\t@Inject ContractVerifierObjectMapper contractVerifierObjectMapper

\tdef validate_foo() throws Exception {
\t\twhen:
\t\t\tbookReturnedTriggered()

\t\tthen:
\t\t\tContractVerifierMessage response = contractVerifierMessaging.receive("activemq:output")
\t\t\tresponse != null

\t\tand:
\t\t\tresponse.getHeader("BOOK-NAME") != null
\t\t\tresponse.getHeader("BOOK-NAME").toString() == 'foo'
\t\t\tresponse.getHeader("contentType") != null
\t\t\tresponse.getHeader("contentType").toString() == 'application/json'

\t\tand:
\t\t\tDocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()))
\t\t\tassertThatJson(parsedJson).field("['bookName']").isEqualTo("foo")
\t}

}

'''</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-scenario2"><a class="anchor" href="#features-messaging-scenario2"></a> <a class="link" href="#features-messaging-scenario2">方案2：由输入触发的输出</a></h6>
<div class="paragraph">
<p>考虑以下合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def contractDsl = Contract.make {
    name "foo"
    label 'some_label'
    input {
        messageFrom('jms:input')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
    }
    outputMessage {
        sentTo('jms:output')
        body([
                bookName: 'foo'
        ])
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">label: some_label
input:
  messageFrom: jms:input
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
outputMessage:
  sentTo: jms:output
  body:
    bookName: foo
  headers:
    BOOK-NAME: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于先前的合同，将创建以下测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">JUnit的</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">                    '''\
package com.example;

import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import org.junit.Test;
import org.junit.Rule;
import javax.inject.Inject;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierObjectMapper;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessage;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessaging;

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.springframework.cloud.contract.verifier.messaging.util.ContractVerifierMessagingUtil.headers;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.fileToBytes;

@SuppressWarnings("rawtypes")
public class FooTest {
\t@Inject ContractVerifierMessaging contractVerifierMessaging;
\t@Inject ContractVerifierObjectMapper contractVerifierObjectMapper;

\t@Test
\tpublic void validate_foo() throws Exception {
\t\t// given:
\t\t\tContractVerifierMessage inputMessage = contractVerifierMessaging.create(
\t\t\t\t\t"{\\"bookName\\":\\"foo\\"}"
\t\t\t\t\t\t, headers()
\t\t\t\t\t\t\t.header("sample", "header")
\t\t\t);

\t\t// when:
\t\t\tcontractVerifierMessaging.send(inputMessage, "jms:input");

\t\t// then:
\t\t\tContractVerifierMessage response = contractVerifierMessaging.receive("jms:output");
\t\t\tassertThat(response).isNotNull();

\t\t// and:
\t\t\tassertThat(response.getHeader("BOOK-NAME")).isNotNull();
\t\t\tassertThat(response.getHeader("BOOK-NAME").toString()).isEqualTo("foo");

\t\t// and:
\t\t\tDocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()));
\t\t\tassertThatJson(parsedJson).field("['bookName']").isEqualTo("foo");
\t}

}

'''</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">斯波克</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    """\
package com.example

import com.jayway.jsonpath.DocumentContext
import com.jayway.jsonpath.JsonPath
import spock.lang.Specification
import javax.inject.Inject
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierObjectMapper
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessage
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessaging

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson
import static org.springframework.cloud.contract.verifier.messaging.util.ContractVerifierMessagingUtil.headers
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.fileToBytes

@SuppressWarnings("rawtypes")
class FooSpec extends Specification {
\t@Inject ContractVerifierMessaging contractVerifierMessaging
\t@Inject ContractVerifierObjectMapper contractVerifierObjectMapper

\tdef validate_foo() throws Exception {
\t\tgiven:
\t\t\tContractVerifierMessage inputMessage = contractVerifierMessaging.create(
\t\t\t\t\t'''{"bookName":"foo"}'''
\t\t\t\t\t\t, headers()
\t\t\t\t\t\t\t.header("sample", "header")
\t\t\t)

\t\twhen:
\t\t\tcontractVerifierMessaging.send(inputMessage, "jms:input")

\t\tthen:
\t\t\tContractVerifierMessage response = contractVerifierMessaging.receive("jms:output")
\t\t\tresponse != null

\t\tand:
\t\t\tresponse.getHeader("BOOK-NAME") != null
\t\t\tresponse.getHeader("BOOK-NAME").toString() == 'foo'

\t\tand:
\t\t\tDocumentContext parsedJson = JsonPath.parse(contractVerifierObjectMapper.writeValueAsString(response.getPayload()))
\t\t\tassertThatJson(parsedJson).field("['bookName']").isEqualTo("foo")
\t}

}

"""</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-scenario3"><a class="anchor" href="#features-messaging-scenario3"></a> <a class="link" href="#features-messaging-scenario3">方案3：无输出消息</a></h6>
<div class="paragraph">
<p>考虑以下合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">时髦</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def contractDsl = Contract.make {
    name "foo"
    label 'some_label'
    input {
        messageFrom('jms:delete')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
        assertThat('bookWasDeleted()')
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">label: some_label
input:
  messageFrom: jms:delete
  messageBody:
    bookName: 'foo'
  messageHeaders:
    sample: header
  assertThat: bookWasDeleted()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于先前的合同，将创建以下测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">JUnit的</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">                    """\
package com.example;

import com.jayway.jsonpath.DocumentContext;
import com.jayway.jsonpath.JsonPath;
import org.junit.Test;
import org.junit.Rule;
import javax.inject.Inject;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierObjectMapper;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessage;
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessaging;

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*;
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson;
import static org.springframework.cloud.contract.verifier.messaging.util.ContractVerifierMessagingUtil.headers;
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.fileToBytes;

@SuppressWarnings("rawtypes")
public class FooTest {
\t@Inject ContractVerifierMessaging contractVerifierMessaging;
\t@Inject ContractVerifierObjectMapper contractVerifierObjectMapper;

\t@Test
\tpublic void validate_foo() throws Exception {
\t\t// given:
\t\t\tContractVerifierMessage inputMessage = contractVerifierMessaging.create(
\t\t\t\t\t"{\\"bookName\\":\\"foo\\"}"
\t\t\t\t\t\t, headers()
\t\t\t\t\t\t\t.header("sample", "header")
\t\t\t);

\t\t// when:
\t\t\tcontractVerifierMessaging.send(inputMessage, "jms:delete");
\t\t\tbookWasDeleted();

\t}

}

"""</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">斯波克</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">                    """\
package com.example

import com.jayway.jsonpath.DocumentContext
import com.jayway.jsonpath.JsonPath
import spock.lang.Specification
import javax.inject.Inject
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierObjectMapper
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessage
import org.springframework.cloud.contract.verifier.messaging.internal.ContractVerifierMessaging

import static org.springframework.cloud.contract.verifier.assertion.SpringCloudContractAssertions.assertThat
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.*
import static com.toomuchcoding.jsonassert.JsonAssertion.assertThatJson
import static org.springframework.cloud.contract.verifier.messaging.util.ContractVerifierMessagingUtil.headers
import static org.springframework.cloud.contract.verifier.util.ContractVerifierUtil.fileToBytes

@SuppressWarnings("rawtypes")
class FooSpec extends Specification {
\t@Inject ContractVerifierMessaging contractVerifierMessaging
\t@Inject ContractVerifierObjectMapper contractVerifierObjectMapper

\tdef validate_foo() throws Exception {
\t\tgiven:
\t\t\tContractVerifierMessage inputMessage = contractVerifierMessaging.create(
\t\t\t\t\t'''{"bookName":"foo"}'''
\t\t\t\t\t\t, headers()
\t\t\t\t\t\t\t.header("sample", "header")
\t\t\t)

\t\twhen:
\t\t\tcontractVerifierMessaging.send(inputMessage, "jms:delete")
\t\t\tbookWasDeleted()

\t\tthen:
\t\t\tnoExceptionThrown()
\t}

}
"""</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-consumer"><a class="anchor" href="#features-messaging-consumer"></a> <a class="link" href="#features-messaging-consumer">消费者存根生成</a></h5>
<div class="paragraph">
<p>与HTTP部分不同，在消息传递中，我们需要使用存根在JAR内发布合同定义。然后在用户端对其进行解析，并创建正确的存根路由。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果在类路径上有多个框架，则Stub Runner需要定义应使用的框架。假设您在类路径上具有AMQP，Spring Cloud Stream和Spring Integration，并且您想使用Spring AMQP。那你需要设置<code>stubrunner.stream.enabled=false</code>和<code>stubrunner.integration.enabled=false</code> 。这样，剩下的唯一框架就是Spring AMQP。</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-triggering"><a class="anchor" href="#features-messaging-stub-triggering"></a> <a class="link" href="#features-messaging-stub-triggering">存根触发</a></h6>
<div class="paragraph">
<p>要触发消息，请使用<code>StubTrigger</code>界面，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package org.springframework.cloud.contract.stubrunner;

import java.util.Collection;
import java.util.Map;

/**
 * Contract for triggering stub messages.
 *
 * @author Marcin Grzejszczak
 */
public interface StubTrigger {

    /**
     * Triggers an event by a given label for a given {@code groupid:artifactid} notation.
     * You can use only {@code artifactId} too.
     *
     * Feature related to messaging.
     * @param ivyNotation ivy notation of a stub
     * @param labelName name of the label to trigger
     * @return true - if managed to run a trigger
     */
    boolean trigger(String ivyNotation, String labelName);

    /**
     * Triggers an event by a given label.
     *
     * Feature related to messaging.
     * @param labelName name of the label to trigger
     * @return true - if managed to run a trigger
     */
    boolean trigger(String labelName);

    /**
     * Triggers all possible events.
     *
     * Feature related to messaging.
     * @return true - if managed to run a trigger
     */
    boolean trigger();

    /**
     * Feature related to messaging.
     * @return a mapping of ivy notation of a dependency to all the labels it has.
     */
    Map<String, Collection<String>> labels();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为方便起见， <code>StubFinder</code>接口扩展<code>StubTrigger</code> ，因此您只需要在测试中选择一个即可。</p>
</div>
<div class="paragraph">
<p><code>StubTrigger</code>提供以下选项来触发消息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#features-messaging-trigger-label">按标签触发</a></p>
</li>
<li>
<p><a href="#features-messaging-trigger-group-artifact-ids">按组和工件ID触发</a></p>
</li>
<li>
<p><a href="#features-messaging-trigger-artifact-ids">由工件ID触发</a></p>
</li>
<li>
<p><a href="#features-messaging-trigger-all-messages">触发所有讯息</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-trigger-label"><a class="anchor" href="#features-messaging-trigger-label"></a> <a class="link" href="#features-messaging-trigger-label">按标签触发</a></h6>
<div class="paragraph">
<p>以下示例显示了如何触发带有标签的消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-trigger-group-artifact-ids"><a class="anchor" href="#features-messaging-trigger-group-artifact-ids"></a> <a class="link" href="#features-messaging-trigger-group-artifact-ids">按组和工件ID触发</a></h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('org.springframework.cloud.contract.verifier.stubs:streamService', 'return_book_1')</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-trigger-artifact-ids"><a class="anchor" href="#features-messaging-trigger-artifact-ids"></a> <a class="link" href="#features-messaging-trigger-artifact-ids">由工件ID触发</a></h6>
<div class="paragraph">
<p>以下示例显示了如何从工件ID触发消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('streamService', 'return_book_1')</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-trigger-all-messages"><a class="anchor" href="#features-messaging-trigger-all-messages"></a> <a class="link" href="#features-messaging-trigger-all-messages">触发所有讯息</a></h6>
<div class="paragraph">
<p>以下示例显示了如何触发所有消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-stub-runner-camel"><a class="anchor" href="#features-messaging-stub-runner-camel"></a> <a class="link" href="#features-messaging-stub-runner-camel">使用Apache Camel的用户端消息传递</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner的消息传递模块为您提供了一种与Apache Camel集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-camel-adding"><a class="anchor" href="#features-messaging-stub-runner-camel-adding"></a> <a class="link" href="#features-messaging-stub-runner-camel-adding">将Apache Camel添加到项目中</a></h6>
<div class="paragraph">
<p>您可以在类路径上同时使用Apache Camel和Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-camel-disabling"><a class="anchor" href="#features-messaging-stub-runner-camel-disabling"></a> <a class="link" href="#features-messaging-stub-runner-camel-disabling">禁用功能</a></h6>
<div class="paragraph">
<p>如果您需要禁用此功能，请设置<code>stubrunner.camel.enabled=false</code>属性。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-camel-example"><a class="anchor" href="#features-messaging-stub-runner-camel-example"></a> <a class="link" href="#features-messaging-stub-runner-camel-example">例子</a></h6>
<div class="paragraph">
<p>假设我们有以下Maven存储库，其中包含用于<code>camelService</code>应用。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── camelService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── camelService-0.0.1-SNAPSHOT.pom
                            │   ├── camelService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设存根包含以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下合同（我们分别为它们编号1和2）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_1'
    input {
        triggeredBy('bookReturnedTriggered()')
    }
    outputMessage {
        sentTo('jms:output')
        body('''{ "bookName" : "foo" }''')
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_2'
    input {
        messageFrom('jms:input')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
    }
    outputMessage {
        sentTo('jms:output')
        body([
                bookName: 'foo'
        ])
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-camel-scenario1"><a class="anchor" href="#features-messaging-stub-runner-camel-scenario1"></a> <a class="link" href="#features-messaging-stub-runner-camel-scenario1">方案1（无输入消息）</a></h7>
<div class="paragraph">
<p>从以下位置触发消息<code>return_book_1</code>标签，我们使用<code>StubTigger</code>界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们要监听发送到的消息的输出<code>jms:output</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Exchange receivedMessage = consumerTemplate.receive('jms:output', 5000)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，收到的消息将传递以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-camel-scenario2"><a class="anchor" href="#features-messaging-stub-runner-camel-scenario2"></a> <a class="link" href="#features-messaging-stub-runner-camel-scenario2">场景2（由输入触发输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>jms:output</code>目的地。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">producerTemplate.
        sendBodyAndHeaders('jms:input', new BookReturned('foo'), [sample: 'header'])</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们要监听发送到的消息的输出<code>jms:output</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Exchange receivedMessage = consumerTemplate.receive('jms:output', 5000)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息将通过以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.in.body)
receivedMessage.in.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-camel-scenario3"><a class="anchor" href="#features-messaging-stub-runner-camel-scenario3"></a> <a class="link" href="#features-messaging-stub-runner-camel-scenario3">方案3（输入无输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>jms:output</code>目的地，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">producerTemplate.
        sendBodyAndHeaders('jms:delete', new BookReturned('foo'), [sample: 'header'])</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-stub-runner-integration"><a class="anchor" href="#features-messaging-stub-runner-integration"></a> <a class="link" href="#features-messaging-stub-runner-integration">与Spring集成的用户端消息传递</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner的消息传递模块为您提供了一种与Spring Integration集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-integration-adding"><a class="anchor" href="#features-messaging-stub-runner-integration-adding"></a> <a class="link" href="#features-messaging-stub-runner-integration-adding">将跑步者添加到项目</a></h6>
<div class="paragraph">
<p>您可以在类路径上同时使用Spring Integration和Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-integration-disabling"><a class="anchor" href="#features-messaging-stub-runner-integration-disabling"></a> <a class="link" href="#features-messaging-stub-runner-integration-disabling">禁用功能</a></h6>
<div class="paragraph">
<p>如果您需要禁用此功能，请设置<code>stubrunner.integration.enabled=false</code>属性。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-integration-example"><a class="anchor" href="#features-messaging-stub-runner-integration-example"></a> <a class="link" href="#features-messaging-stub-runner-integration-example">例子</a></h6>
<div class="paragraph">
<p>假设您具有以下Maven存储库，其中包含用于<code>integrationService</code>应用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── integrationService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── integrationService-0.0.1-SNAPSHOT.pom
                            │   ├── integrationService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设存根包含以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>考虑以下合同（编号1和2）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_1'
    input {
        triggeredBy('bookReturnedTriggered()')
    }
    outputMessage {
        sentTo('output')
        body('''{ "bookName" : "foo" }''')
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_2'
    input {
        messageFrom('input')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
    }
    outputMessage {
        sentTo('output')
        body([
                bookName: 'foo'
        ])
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下Spring Integration Route：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns="http://www.springframework.org/schema/integration"
             xsi:schemaLocation="http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/integration
            http://www.springframework.org/schema/integration/spring-integration.xsd">


    <!-- REQUIRED FOR TESTING -->
    <bridge input-channel="output"
            output-channel="outputTest"/>

    <channel id="outputTest">
        <queue/>
    </channel>

</beans:beans></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这些示例适用于三种情况：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#features-messaging-stub-runner-integration-scenario1">方案1（无输入消息）</a></p>
</li>
<li>
<p><a href="#features-messaging-stub-runner-integration-scenario2">场景2（由输入触发输出）</a></p>
</li>
<li>
<p><a href="#features-messaging-stub-runner-integration-scenario3">方案3（输入无输出）</a></p>
</li>
</ol>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-integration-scenario1"><a class="anchor" href="#features-messaging-stub-runner-integration-scenario1"></a> <a class="link" href="#features-messaging-stub-runner-integration-scenario1">方案1（无输入消息）</a></h7>
<div class="paragraph">
<p>从以下位置触发消息<code>return_book_1</code>标签，使用<code>StubTigger</code>界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了如何监听发送到的消息的输出<code>jms:output</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message<?> receivedMessage = messaging.receive('outputTest')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息将通过以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-integration-scenario2"><a class="anchor" href="#features-messaging-stub-runner-integration-scenario2"></a> <a class="link" href="#features-messaging-stub-runner-integration-scenario2">场景2（由输入触发输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>jms:output</code>目的地，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'input')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了如何监听发送到的消息的输出<code>jms:output</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message<?> receivedMessage = messaging.receive('outputTest')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息传递以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-integration-scenario3"><a class="anchor" href="#features-messaging-stub-runner-integration-scenario3"></a> <a class="link" href="#features-messaging-stub-runner-integration-scenario3">方案3（输入无输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>jms:input</code>目的地，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-stub-runner-stream"><a class="anchor" href="#features-messaging-stub-runner-stream"></a> <a class="link" href="#features-messaging-stub-runner-stream">使用Spring Cloud Stream的用户端消息传递</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner的消息传递模块为您提供了一种与Spring Stream集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果Stub Runner与Stream集成<code>messageFrom</code>要么<code>sentTo</code>字符串首先解析为<code>destination</code>一个频道，没有这样的<code>destination</code>存在，将目的地解析为通道名称。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要使用Spring Cloud Stream，请记住添加对<code>org.springframework.cloud:spring-cloud-stream-test-support</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-stream-test-support</artifactId>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">testCompile "org.springframework.cloud:spring-cloud-stream-test-support"</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-stream-adding"><a class="anchor" href="#features-messaging-stub-runner-stream-adding"></a> <a class="link" href="#features-messaging-stub-runner-stream-adding">将跑步者添加到项目</a></h6>
<div class="paragraph">
<p>您可以在类路径上同时使用Spring Cloud Stream和Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-stream-disabling"><a class="anchor" href="#features-messaging-stub-runner-stream-disabling"></a> <a class="link" href="#features-messaging-stub-runner-stream-disabling">禁用功能</a></h6>
<div class="paragraph">
<p>如果您需要禁用此功能，请设置<code>stubrunner.stream.enabled=false</code>属性。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-stream-example"><a class="anchor" href="#features-messaging-stub-runner-stream-example"></a> <a class="link" href="#features-messaging-stub-runner-stream-example">例子</a></h6>
<div class="paragraph">
<p>假设您具有以下Maven存储库，其中包含用于<code>streamService</code>应用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── .m2
    └── repository
        └── io
            └── codearte
                └── accurest
                    └── stubs
                        └── streamService
                            ├── 0.0.1-SNAPSHOT
                            │   ├── streamService-0.0.1-SNAPSHOT.pom
                            │   ├── streamService-0.0.1-SNAPSHOT-stubs.jar
                            │   └── maven-metadata-local.xml
                            └── maven-metadata-local.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设存根包含以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── repository
    ├── accurest
    │   ├── bookDeleted.groovy
    │   ├── bookReturned1.groovy
    │   └── bookReturned2.groovy
    └── mappings</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>考虑以下合同（编号1和2）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_1'
    input { triggeredBy('bookReturnedTriggered()') }
    outputMessage {
        sentTo('returnBook')
        body('''{ "bookName" : "foo" }''')
        headers { header('BOOK-NAME', 'foo') }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_2'
    input {
        messageFrom('bookStorage')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders { header('sample', 'header') }
    }
    outputMessage {
        sentTo('returnBook')
        body([
                bookName: 'foo'
        ])
        headers { header('BOOK-NAME', 'foo') }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下Spring配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner.repositoryRoot: classpath:m2repo/repository/
stubrunner.ids: org.springframework.cloud.contract.verifier.stubs:streamService:0.0.1-SNAPSHOT:stubs
stubrunner.stubs-mode: remote
spring:
  cloud:
    stream:
      bindings:
        output:
          destination: returnBook
        input:
          destination: bookStorage

server:
  port: 0

debug: true</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这些示例适用于三种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#features-messaging-stub-runner-stream-scenario1">方案1（无输入消息）</a></p>
</li>
<li>
<p><a href="#features-messaging-stub-runner-stream-scenario2">场景2（由输入触发输出）</a></p>
</li>
<li>
<p><a href="#features-messaging-stub-runner-stream-scenario3">方案3（输入无输出）</a></p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-stream-scenario1"><a class="anchor" href="#features-messaging-stub-runner-stream-scenario1"></a> <a class="link" href="#features-messaging-stub-runner-stream-scenario1">方案1（无输入消息）</a></h7>
<div class="paragraph">
<p>从以下位置触发消息<code>return_book_1</code>标签，使用<code>StubTrigger</code>界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何侦听发送到其通道的消息的输出<code>destination</code>是<code>returnBook</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message<?> receivedMessage = messaging.receive('returnBook')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息传递以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-stream-scenario2"><a class="anchor" href="#features-messaging-stub-runner-stream-scenario2"></a> <a class="link" href="#features-messaging-stub-runner-stream-scenario2">场景2（由输入触发输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>bookStorage</code><code>destination</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'bookStorage')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何侦听发送到的消息的输出<code>returnBook</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message<?> receivedMessage = messaging.receive('returnBook')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息传递以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertJsons(receivedMessage.payload)
receivedMessage.headers.get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-stream-scenario3"><a class="anchor" href="#features-messaging-stub-runner-stream-scenario3"></a> <a class="link" href="#features-messaging-stub-runner-stream-scenario3">方案3（输入无输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>jms:output</code>目的地，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">messaging.send(new BookReturned('foo'), [sample: 'header'], 'delete')</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-stub-runner-amqp"><a class="anchor" href="#features-messaging-stub-runner-amqp"></a> <a class="link" href="#features-messaging-stub-runner-amqp">使用Spring AMQP的用户端消息传递</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner的消息传递模块提供了一种与Spring AMQP的Rabbit模板集成的简便方法。对于提供的工件，它会自动下载存根并注册所需的路由。</p>
</div>
<div class="paragraph">
<p>集成尝试独立工作（即，不与正在运行的RabbitMQ消息代理进行交互）。它期望一个<code>RabbitTemplate</code>在应用程序上下文中，并将其用作名为<code>@SpyBean</code> 。结果，它可以使用Mockito间谍功能来验证和检查应用程序发送的消息。</p>
</div>
<div class="paragraph">
<p>在消息使用者方面，存根赛跑者考虑所有<code>@RabbitListener</code>带注释的端点和所有<code>SimpleMessageListenerContainer</code>应用程序上下文中的对象。</p>
</div>
<div class="paragraph">
<p>由于通常将消息发送到AMQP中的交易所，因此消息合同包含交易所名称作为目的地。另一端的消息侦听器绑定到队列。绑定将交换连接到队列。如果触发了消息合同，则Spring AMQP存根运行器集成将在与该交换匹配的应用程序上下文中查找绑定。然后，它从Spring交换收集队列，并尝试查找绑定到这些队列的消息侦听器。将为所有匹配的消息侦听器触发该消息。</p>
</div>
<div class="paragraph">
<p>如果您需要使用路由键，则可以使用<code>amqp_receivedRoutingKey</code>消息头。</p>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-amqp-adding"><a class="anchor" href="#features-messaging-stub-runner-amqp-adding"></a> <a class="link" href="#features-messaging-stub-runner-amqp-adding">将跑步者添加到项目</a></h6>
<div class="paragraph">
<p>您可以在类路径上同时使用Spring AMQP和Spring Cloud Contract Stub Runner并设置属性<code>stubrunner.amqp.enabled=true</code> 。记得用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果您已经在类路径上安装了Stream和Integration，则需要通过设置<code>stubrunner.stream.enabled=false</code>和<code>stubrunner.integration.enabled=false</code>属性。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-amqp-example"><a class="anchor" href="#features-messaging-stub-runner-amqp-example"></a> <a class="link" href="#features-messaging-stub-runner-amqp-example">例子</a></h6>
<div class="paragraph">
<p>假设您具有以下Maven存储库，其中包含针对该Maven的已部署存根<code>spring-cloud-contract-amqp-test</code>应用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── .m2
    └── repository
        └── com
            └── example
                └── spring-cloud-contract-amqp-test
                    ├── 0.4.0-SNAPSHOT
                    │   ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT.pom
                    │   ├── spring-cloud-contract-amqp-test-0.4.0-SNAPSHOT-stubs.jar
                    │   └── maven-metadata-local.xml
                    └── maven-metadata-local.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设存根包含以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── META-INF
│   └── MANIFEST.MF
└── contracts
    └── shouldProduceValidPersonData.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后考虑以下合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    // Human readable description
    description 'Should produce valid person data'
    // Label by means of which the output message can be triggered
    label 'contract-test.person.created.event'
    // input to the contract
    input {
        // the contract will be triggered by a method
        triggeredBy('createPerson()')
    }
    // output message of the contract
    outputMessage {
        // destination to which the output message will be sent
        sentTo 'contract-test.exchange'
        headers {
            header('contentType': 'application/json')
            header('__TypeId__': 'org.springframework.cloud.contract.stubrunner.messaging.amqp.Person')
        }
        // the body of the output message
        body([
                id  : $(consumer(9), producer(regex("[0-9]+"))),
                name: "me"
        ])
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下Spring配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids: org.springframework.cloud.contract.verifier.stubs.amqp:spring-cloud-contract-amqp-test:0.4.0-SNAPSHOT:stubs
  stubs-mode: remote
  amqp:
    enabled: true
server:
  port: 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-amqp-triggering"><a class="anchor" href="#features-messaging-stub-runner-amqp-triggering"></a> <a class="link" href="#features-messaging-stub-runner-amqp-triggering">触发讯息</a></h7>
<div class="paragraph">
<p>要使用上一节中的合同触发消息，请使用<code>StubTrigger</code>界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubTrigger.trigger("contract-test.person.created.event")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该邮件的目的地为<code>contract-test.exchange</code> ，因此Spring AMQP存根运行器集成查找与该交换有关的绑定，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Binding binding() {
    return BindingBuilder.bind(new Queue("test.queue"))
            .to(new DirectExchange("contract-test.exchange")).with("#");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>绑定定义绑定了称为<code>test.queue</code> 。结果，以下侦听器定义与合同消息匹配并被调用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SimpleMessageListenerContainer simpleMessageListenerContainer(
        ConnectionFactory connectionFactory,
        MessageListenerAdapter listenerAdapter) {
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    container.setQueueNames("test.queue");
    container.setMessageListener(listenerAdapter);

    return container;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，以下带注释的侦听器将匹配并被调用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RabbitListener(bindings = @QueueBinding(value = @Queue("test.queue"),
        exchange = @Exchange(value = "contract-test.exchange",
                ignoreDeclarationExceptions = "true")))
public void handlePerson(Person person) {
    this.person = person;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">消息直接移交给<code>onMessage</code>的方法<code>MessageListener</code>与匹配相关<code>SimpleMessageListenerContainer</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-amqp-configuration"><a class="anchor" href="#features-messaging-stub-runner-amqp-configuration"></a> <a class="link" href="#features-messaging-stub-runner-amqp-configuration">Spring AMQP测试配置</a></h7>
<div class="paragraph">
<p>为了避免Spring AMQP在测试期间尝试连接到正在运行的代理，我们配置了一个模拟<code>ConnectionFactory</code> 。</p>
</div>
<div class="paragraph">
<p>禁用模拟<code>ConnectionFactory</code> ，设置以下属性： <code>stubrunner.amqp.mockConnection=false</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stubrunner:
  amqp:
    mockConnection: false</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-stub-runner-jms"><a class="anchor" href="#features-messaging-stub-runner-jms"></a> <a class="link" href="#features-messaging-stub-runner-jms">使用Spring JMS进行用户端消息传递</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner的消息传递模块提供了一种与Spring JMS集成的简便方法。</p>
</div>
<div class="paragraph">
<p>集成假定您有一个正在运行的JMS代理实例（例如<code>activemq</code>嵌入式经纪人）。</p>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-jms-adding"><a class="anchor" href="#features-messaging-stub-runner-jms-adding"></a> <a class="link" href="#features-messaging-stub-runner-jms-adding">将跑步者添加到项目</a></h6>
<div class="paragraph">
<p>您需要在类路径上同时具有Spring JMS和Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-jms-example"><a class="anchor" href="#features-messaging-stub-runner-jms-example"></a> <a class="link" href="#features-messaging-stub-runner-jms-example">例子</a></h6>
<div class="paragraph">
<p>假定存根结构如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── stubs
    ├── bookDeleted.groovy
    ├── bookReturned1.groovy
    └── bookReturned2.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设以下测试配置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">stubrunner:
  repository-root: stubs:classpath:/stubs/
  ids: my:stubs
  stubs-mode: remote
spring:
  activemq:
    send-timeout: 1000
  jms:
    template:
      receive-timeout: 1000</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下合同（我们分别为它们编号1和2）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_1'
    input {
        triggeredBy('bookReturnedTriggered()')
    }
    outputMessage {
        sentTo('output')
        body('''{ "bookName" : "foo" }''')
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_2'
    input {
        messageFrom('input')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
    }
    outputMessage {
        sentTo('output')
        body([
                bookName: 'foo'
        ])
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-jms-scenario1"><a class="anchor" href="#features-messaging-stub-runner-jms-scenario1"></a> <a class="link" href="#features-messaging-stub-runner-jms-scenario1">方案1（无输入消息）</a></h7>
<div class="paragraph">
<p>从以下位置触发消息<code>return_book_1</code>标签，我们使用<code>StubTigger</code>界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们要监听发送到的消息的输出<code>output</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">TextMessage receivedMessage = (TextMessage) jmsTemplate.receive('output')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，收到的消息将传递以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.getText())
receivedMessage.getStringProperty('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-jms-scenario2"><a class="anchor" href="#features-messaging-stub-runner-jms-scenario2"></a> <a class="link" href="#features-messaging-stub-runner-jms-scenario2">场景2（由输入触发输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>output</code>目的地。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">jmsTemplate.
        convertAndSend('input', new BookReturned('foo'), new MessagePostProcessor() {
            @Override
            Message postProcessMessage(Message message) throws JMSException {
                message.setStringProperty("sample", "header")
                return message
            }
        })</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们要监听发送到的消息的输出<code>output</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">TextMessage receivedMessage = (TextMessage) jmsTemplate.receive('output')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息将通过以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">receivedMessage != null
assertThatBodyContainsBookNameFoo(receivedMessage.getText())
receivedMessage.getStringProperty('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-jms-scenario3"><a class="anchor" href="#features-messaging-stub-runner-jms-scenario3"></a> <a class="link" href="#features-messaging-stub-runner-jms-scenario3">方案3（输入无输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>output</code>目的地，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">jmsTemplate.
        convertAndSend('delete', new BookReturned('foo'), new MessagePostProcessor() {
            @Override
            Message postProcessMessage(Message message) throws JMSException {
                message.setStringProperty("sample", "header")
                return message
            }
        })</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-messaging-stub-runner-kafka"><a class="anchor" href="#features-messaging-stub-runner-kafka"></a> <a class="link" href="#features-messaging-stub-runner-kafka">使用Spring Kafka进行用户端消息传递</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner的消息传递模块提供了一种与Spring Kafka集成的简便方法。</p>
</div>
<div class="paragraph">
<p>集成假定您有一个嵌入式Kafka代理的运行实例（通过<code>spring-kafka-test</code>依赖性）。</p>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-kafka-adding"><a class="anchor" href="#features-messaging-stub-runner-kafka-adding"></a> <a class="link" href="#features-messaging-stub-runner-kafka-adding">将跑步者添加到项目</a></h6>
<div class="paragraph">
<p>您需要同时具有Spring Kafka和Spring Kafka Test（要运行<code>@EmbeddedBroker</code> ）和类路径上的Spring Cloud Contract Stub Runner。记得用以下注释您的测试课<code>@AutoConfigureStubRunner</code> 。</p>
</div>
<div class="paragraph">
<p>通过Kafka集成，为了轮询单个消息，我们需要在Spring上下文启动时注册使用者。这可能会导致一种情况，当您在使用者方面时，Stub Runner可以为相同的组ID和主题注册其他使用者。这可能导致这样一种情况，即只有一个组件会实际轮询该消息。由于在消费者方面，您同时具有Spring Cloud Contract Stub Runner和Spring Cloud Contract Verifier类路径，因此我们需要能够关闭此类行为。这是通过自动完成的<code>stubrunner.kafka.initializer.enabled</code>标志，将禁用“联系验证者”消费者注册。如果您的应用程序既是kafka消息的使用者又是生产者，则可能需要手动将该属性切换为<code>false</code>在您生成的测试的基类中。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-messaging-stub-runner-kafka-example"><a class="anchor" href="#features-messaging-stub-runner-kafka-example"></a> <a class="link" href="#features-messaging-stub-runner-kafka-example">例子</a></h6>
<div class="paragraph">
<p>假定存根结构如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── stubs
    ├── bookDeleted.groovy
    ├── bookReturned1.groovy
    └── bookReturned2.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>进一步假设以下测试配置（请注意<code>spring.kafka.bootstrap-servers</code>通过指向嵌入式经纪人的IP <code>${spring.embedded.kafka.brokers}</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">stubrunner:
  repository-root: stubs:classpath:/stubs/
  ids: my:stubs
  stubs-mode: remote
spring:
  kafka:
    bootstrap-servers: ${spring.embedded.kafka.brokers}
    producer:
      properties:
        "value.serializer": "org.springframework.kafka.support.serializer.JsonSerializer"
        "spring.json.trusted.packages": "*"
    consumer:
      properties:
        "value.deserializer": "org.springframework.kafka.support.serializer.JsonDeserializer"
        "value.serializer": "org.springframework.kafka.support.serializer.JsonSerializer"
        "spring.json.trusted.packages": "*"
      group-id: groupId</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下合同（我们分别为它们编号1和2）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_1'
    input {
        triggeredBy('bookReturnedTriggered()')
    }
    outputMessage {
        sentTo('output')
        body('''{ "bookName" : "foo" }''')
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Contract.make {
    label 'return_book_2'
    input {
        messageFrom('input')
        messageBody([
                bookName: 'foo'
        ])
        messageHeaders {
            header('sample', 'header')
        }
    }
    outputMessage {
        sentTo('output')
        body([
                bookName: 'foo'
        ])
        headers {
            header('BOOK-NAME', 'foo')
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-kafka-scenario1"><a class="anchor" href="#features-messaging-stub-runner-kafka-scenario1"></a> <a class="link" href="#features-messaging-stub-runner-kafka-scenario1">方案1（无输入消息）</a></h7>
<div class="paragraph">
<p>从以下位置触发消息<code>return_book_1</code>标签，我们使用<code>StubTigger</code>界面如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">stubFinder.trigger('return_book_1')</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们要监听发送到的消息的输出<code>output</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message receivedMessage = receiveFromOutput()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，收到的消息将传递以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">assert receivedMessage != null
assert assertThatBodyContainsBookNameFoo(receivedMessage.getPayload())
assert receivedMessage.getHeaders().get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-kafka-scenario2"><a class="anchor" href="#features-messaging-stub-runner-kafka-scenario2"></a> <a class="link" href="#features-messaging-stub-runner-kafka-scenario2">场景2（由输入触发输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>output</code>目的地。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message message = MessageBuilder.createMessage(new BookReturned('foo'), new MessageHeaders([sample: "header",]))
kafkaTemplate.setDefaultTopic('input')
kafkaTemplate.send(message)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，我们要监听发送到的消息的输出<code>output</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message receivedMessage = receiveFromOutput()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>收到的消息将通过以下断言：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">assert receivedMessage != null
assert assertThatBodyContainsBookNameFoo(receivedMessage.getPayload())
assert receivedMessage.getHeaders().get('BOOK-NAME') == 'foo'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-messaging-stub-runner-kafka-scenario3"><a class="anchor" href="#features-messaging-stub-runner-kafka-scenario3"></a> <a class="link" href="#features-messaging-stub-runner-kafka-scenario3">方案3（输入无输出）</a></h7>
<div class="paragraph">
<p>由于路线是为您设置的，因此您可以向<code>output</code>目的地，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">Message message = MessageBuilder.createMessage(new BookReturned('foo'), new MessageHeaders([sample: "header",]))
kafkaTemplate.setDefaultTopic('delete')
kafkaTemplate.send(message)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="features-stub-runner"><a class="anchor" href="#features-stub-runner"></a> <a class="link" href="#features-stub-runner">14.3.5。Spring Cloud Contract存根转轮</a></h4>
<div class="paragraph">
<p>使用Spring Cloud Contract Verifier时可能遇到的问题之一是将生成的WireMock JSON存根从服务器端传递到客户端（或传递到各种客户端）。在客户端生成消息方面也发生了同样的事情。</p>
</div>
<div class="paragraph">
<p>复制JSON文件并设置客户端手动进行消息传递是不可能的。这就是为什么我们引入了Spring Cloud Contract Stub Runner。它可以自动为您下载并运行存根。</p>
</div>
<div class="sect4">
<h5 id="features-stub-runner-snapshot-versions"><a class="anchor" href="#features-stub-runner-snapshot-versions"></a> <a class="link" href="#features-stub-runner-snapshot-versions">快照版本</a></h5>
<div class="paragraph">
<p>您可以将其他快照存储库添加到您的<code>build.gradle</code>文件以使用快照版本，快照版本在每次成功构建后都会自动上载，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><repositories>
    <repository>
        <id>spring-snapshots</id>
        <name>Spring Snapshots</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-releases</id>
        <name>Spring Releases</name>
        <url>https://repo.spring.io/release</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
        <id>spring-snapshots</id>
        <name>Spring Snapshots</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>spring-releases</id>
        <name>Spring Releases</name>
        <url>https://repo.spring.io/release</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </pluginRepository>
</pluginRepositories></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">/*
 We need to use the [buildscript {}] section when we have to modify
 the classpath for the plugins. If that's not the case this section
 can be skipped.

 If you don't need to modify the classpath (e.g. add a Pact dependency),
 then you can just set the [pluginManagement {}] section in [settings.gradle] file.

 // settings.gradle
 pluginManagement {
    repositories {
        // for snapshots
        maven {url "https://repo.spring.io/snapshot"}
        // for milestones
        maven {url "https://repo.spring.io/milestone"}
        // for GA versions
        gradlePluginPortal()
    }
 }

 */
buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url "https://repo.spring.io/snapshot" }
        maven { url "https://repo.spring.io/milestone" }
        maven { url "https://repo.spring.io/release" }
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-publishing-stubs-as-jars"><a class="anchor" href="#features-stub-runner-publishing-stubs-as-jars"></a> <a class="link" href="#features-stub-runner-publishing-stubs-as-jars">将存根发布为JAR</a></h5>
<div class="paragraph">
<p>将罐子发布为存根的最简单方法是集中存根的存储方式。例如，您可以将它们作为jar保存在Maven存储库中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">对于Maven和Gradle，该设置即可使用。但是，您可以根据需要自定义它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例演示如何将存根发布为jar：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><!-- First disable the default jar setup in the properties section -->
<!-- we don't want the verifier to do a jar for us -->
<spring.cloud.contract.verifier.skip>true</spring.cloud.contract.verifier.skip>

<!-- Next add the assembly plugin to your build -->
<!-- we want the assembly plugin to generate the JAR -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-assembly-plugin</artifactId>
    <executions>
        <execution>
            <id>stub</id>
            <phase>prepare-package</phase>
            <goals>
                <goal>single</goal>
            </goals>
            <inherited>false</inherited>
            <configuration>
                <attach>true</attach>
                <descriptors>
                    $/home/marcin/repo/spring-cloud-scripts/src/assembly/stub.xml
                </descriptors>
            </configuration>
        </execution>
    </executions>
</plugin>

<!-- Finally setup your assembly. Below you can find the contents of src/main/assembly/stub.xml -->
<assembly
    xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd">
    <id>stubs</id>
    <formats>
        <format>jar</format>
    </formats>
    <includeBaseDirectory>false</includeBaseDirectory>
    <fileSets>
        <fileSet>
            <directory>src/main/java</directory>
            <outputDirectory>/</outputDirectory>
            <includes>
                <include>**com/example/model/*.*</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${project.build.directory}/classes</directory>
            <outputDirectory>/</outputDirectory>
            <includes>
                <include>**com/example/model/*.*</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${project.build.directory}/snippets/stubs</directory>
            <outputDirectory>META-INF/${project.groupId}/${project.artifactId}/${project.version}/mappings</outputDirectory>
            <includes>
                <include>**/*</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>$/home/marcin/repo/spring-cloud-scripts/src/test/resources/contracts</directory>
            <outputDirectory>META-INF/${project.groupId}/${project.artifactId}/${project.version}/contracts</outputDirectory>
            <includes>
                <include>**/*.groovy</include>
            </includes>
        </fileSet>
    </fileSets>
</assembly></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">ext {
    contractsDir = file("mappings")
    stubsOutputDirRoot = file("${project.buildDir}/production/${project.name}-stubs/")
}

// Automatically added by plugin:
// copyContracts - copies contracts to the output folder from which JAR will be created
// verifierStubsJar - JAR with a provided stub suffix
// the presented publication is also added by the plugin but you can modify it as you wish

publishing {
    publications {
        stubs(MavenPublication) {
            artifactId "${project.name}-stubs"
            artifact verifierStubsJar
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-core"><a class="anchor" href="#features-stub-runner-core"></a> <a class="link" href="#features-stub-runner-core">存根转轮核心</a></h5>
<div class="paragraph">
<p>存根运行程序核心运行服务协作者的存根。将存根视为服务合同，可以将存根运行器用作“ <a href="https://martinfowler.com/articles/consumerDrivenContracts.html">消费者驱动的合同”的实现</a> 。</p>
</div>
<div class="paragraph">
<p>Stub Runner可让您自动下载提供的依赖项的存根（或从类路径中选择存根），为其启动WireMock服务器，并为它们提供正确的存根定义。对于消息传递，定义了特殊的存根路由。</p>
</div>
<div class="sect5">
<h6 id="features-stub-runner-retrieving"><a class="anchor" href="#features-stub-runner-retrieving"></a> <a class="link" href="#features-stub-runner-retrieving">检索存根</a></h6>
<div class="paragraph">
<p>您可以从以下获取存根的选项中进行选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基于醚的解决方案，可从Artifactory或Nexus下载带有存根的JAR</p>
</li>
<li>
<p>类路径扫描解决方案，使用一种模式搜索类路径以检索存根</p>
</li>
<li>
<p>编写自己的实现<code>org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder</code>完全定制</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>后一个示例在“ <a href="advanced.html#customization-custom-stub-runner">自定义存根运行器”</a>部分中进行了描述。</p>
</div>
<div class="sect6">
<h7 id="features-stub-runner-downloading-stub"><a class="anchor" href="#features-stub-runner-downloading-stub"></a> <a class="link" href="#features-stub-runner-downloading-stub">下载存根</a></h7>
<div class="paragraph">
<p>您可以使用以下命令控制存根的下载<code>stubsMode</code>开关。它从<code>StubRunnerProperties.StubsMode</code>列举。您可以使用以下选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StubRunnerProperties.StubsMode.CLASSPATH</code> （默认值）：从类路径中选择存根</p>
</li>
<li>
<p><code>StubRunnerProperties.StubsMode.LOCAL</code> ：从本地存储区中选择存根（例如， <code>.m2</code> ）</p>
</li>
<li>
<p><code>StubRunnerProperties.StubsMode.REMOTE</code> ：从远程位置选择存根</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例从本地位置选择存根：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(repositoryRoot="https://foo.bar", ids = "com.example:beer-api-producer:+:stubs:8095", stubsMode = StubRunnerProperties.StubsMode.LOCAL)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-stub-runner-classpath-scanning"><a class="anchor" href="#features-stub-runner-classpath-scanning"></a> <a class="link" href="#features-stub-runner-classpath-scanning">类路径扫描</a></h7>
<div class="paragraph">
<p>如果您设定<code>stubsMode</code>财产<code>StubRunnerProperties.StubsMode.CLASSPATH</code> （或自<code>CLASSPATH</code>是默认值），则扫描类路径。考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {
    "com.example:beer-api-producer:+:stubs:8095",
    "com.example.foo:bar:1.0.0:superstubs:8096"
})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以将依赖项添加到类路径中，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>com.example</groupId>
    <artifactId>beer-api-producer-restdocs</artifactId>
    <classifier>stubs</classifier>
    <version>0.0.1-SNAPSHOT</version>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>*</groupId>
            <artifactId>*</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>com.example.thing1</groupId>
    <artifactId>thing2</artifactId>
    <classifier>superstubs</classifier>
    <version>1.0.0</version>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>*</groupId>
            <artifactId>*</artifactId>
        </exclusion>
    </exclusions>
</dependency></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">testCompile("com.example:beer-api-producer-restdocs:0.0.1-SNAPSHOT:stubs") {
    transitive = false
}
testCompile("com.example.thing1:thing2:1.0.0:superstubs") {
    transitive = false
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，将扫描您的类路径上的指定位置。对于<code>com.example:beer-api-producer-restdocs</code> ，将扫描以下位置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/META-INF/com.example/beer-api-producer-restdocs/ <strong>* /</strong> 。*</p>
</li>
<li>
<p>/contracts/com.example/beer-api-producer-restdocs/ <strong>* /</strong> 。*</p>
</li>
<li>
<p>/mappings/com.example/beer-api-producer-restdocs/ <strong>* /</strong> 。*</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于<code>com.example.thing1:thing2</code> ，将扫描以下位置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/META-INF/com.example.thing1/thing2/ <strong>* /</strong> 。*</p>
</li>
<li>
<p>/contracts/com.example.thing1/thing2/ <strong>* /</strong> 。*</p>
</li>
<li>
<p>/mappings/com.example.thing1/thing2/ <strong>* /</strong> 。*</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">打包生产者存根时，必须显式提供组和工件ID。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了实现适当的存根包装，生产者将按以下方式建立合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── src
    └── test
        └── resources
            └── contracts
                └── com.example
                    └── beer-api-producer-restdocs
                        └── nested
                            └── contract3.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过使用<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/2.2.x/producer_with_restdocs/pom.xml">Maven <code>assembly</code>插件</a>或<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/blob/2.2.x/producer_with_restdocs/build.gradle">Gradle Jar</a>任务，则必须在存根jar中创建以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── META-INF
    └── com.example
        └── beer-api-producer-restdocs
            └── 2.0.0
                ├── contracts
                │   └── nested
                │       └── contract2.groovy
                └── mappings
                    └── mapping.json</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过维护此结构，将扫描类路径，您无需下载构件即可从消息传递或HTTP存根中受益。</p>
</div>
</div>
<div class="sect6">
<h7 id="features-stub-runner-configuring-http-server-stubs"><a class="anchor" href="#features-stub-runner-configuring-http-server-stubs"></a> <a class="link" href="#features-stub-runner-configuring-http-server-stubs">配置HTTP服务器存根</a></h7>
<div class="paragraph">
<p>存根赛跑者有一个概念<code>HttpServerStub</code>它抽象了HTTP服务器的基础具体实现（例如，WireMock是实现之一）。有时，您需要对存根服务器执行一些其他调整（这对于给定的实现是具体的）。为此，Stub Runner为您提供了<code>httpServerStubConfigurer</code>批注和JUnit规则中可用的属性，并且可以通过系统属性访问该属性，您可以在其中提供对<code>org.springframework.cloud.contract.stubrunner.HttpServerStubConfigurer</code>接口。这些实现可以更改给定HTTP服务器存根的配置文件。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner附带了一个可以扩展到WireMock的实现： <code>org.springframework.cloud.contract.stubrunner.provider.wiremock.WireMockHttpServerStubConfigurer</code> 。在里面<code>configure</code>方法，您可以为给定的存根提供自己的自定义配置。用例可能是在HTTPS端口上为给定的工件ID启动WireMock。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">范例1。WireMockHttpServerStubConfigurer实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@CompileStatic
static class HttpsForFraudDetection extends WireMockHttpServerStubConfigurer {

    private static final Log log = LogFactory.getLog(HttpsForFraudDetection)

    @Override
    WireMockConfiguration configure(WireMockConfiguration httpStubConfiguration, HttpServerStubConfiguration httpServerStubConfiguration) {
        if (httpServerStubConfiguration.stubConfiguration.artifactId == "fraudDetectionServer") {
            int httpsPort = SocketUtils.findAvailableTcpPort()
            log.info("Will set HTTPs port [" + httpsPort + "] for fraud detection server")
            return httpStubConfiguration
                    .httpsPort(httpsPort)
        }
        return httpStubConfiguration
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用<code>@AutoConfigureStubRunner</code>注释，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@AutoConfigureStubRunner(mappingsOutputFolder = "target/outputmappings/",
        httpServerStubConfigurer = HttpsForFraudDetection)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>只要找到HTTPS端口，它就会优先于HTTP端口。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-running-stubs"><a class="anchor" href="#features-stub-runner-running-stubs"></a> <a class="link" href="#features-stub-runner-running-stubs">正在运行的存根</a></h6>
<div class="paragraph">
<p>本节介绍如何运行存根。它包含以下主题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#features-stub-runner-http-stubs">HTTP存根</a></p>
</li>
<li>
<p><a href="#features-stub-runner-viewing">查看注册的映射</a></p>
</li>
<li>
<p><a href="#features-stub-runner-messaging">消息存根</a></p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="features-stub-runner-http-stubs"><a class="anchor" href="#features-stub-runner-http-stubs"></a> <a class="link" href="#features-stub-runner-http-stubs">HTTP存根</a></h7>
<div class="paragraph">
<p>存根在JSON文档中定义，其语法在<a href="http://wiremock.org/stubbing.html">WireMock文档中</a>定义</p>
</div>
<div class="paragraph">
<p>以下示例在JSON中定义了一个存根：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
    "request": {
        "method": "GET",
        "url": "/ping"
    },
    "response": {
        "status": 200,
        "body": "pong",
        "headers": {
            "Content-Type": "text/plain"
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-stub-runner-viewing"><a class="anchor" href="#features-stub-runner-viewing"></a> <a class="link" href="#features-stub-runner-viewing">查看注册的映射</a></h7>
<div class="paragraph">
<p>每个存根协作者都会在<code>__/admin/</code>端点。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>mappingsOutputFolder</code>属性以将映射转储到文件。对于基于注释的方法，它将类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids="a.b.c:loanIssuance,a.b.c:fraudDetectionServer",
mappingsOutputFolder = "target/outputmappings/")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于JUnit方法，它类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ClassRule @Shared StubRunnerRule rule = new StubRunnerRule()
            .repoRoot("https://some_url")
            .downloadStub("a.b.c", "loanIssuance")
            .downloadStub("a.b.c:fraudDetectionServer")
            .withMappingsOutputFolder("target/outputmappings")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，如果您签出<code>target/outputmappings</code>文件夹，您将看到以下结构；</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">.
├── fraudDetectionServer_13705
└── loanIssuance_12255</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这意味着注册了两个存根。 <code>fraudDetectionServer</code>在港口注册<code>13705</code>和<code>loanIssuance</code>在港口<code>12255</code> 。如果我们查看其中一个文件，则将看到（对于WireMock）可用于给定服务器的映射：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[{
  "id" : "f9152eb9-bf77-4c38-8289-90be7d10d0d7",
  "request" : {
    "url" : "/name",
    "method" : "GET"
  },
  "response" : {
    "status" : 200,
    "body" : "fraudDetectionServer"
  },
  "uuid" : "f9152eb9-bf77-4c38-8289-90be7d10d0d7"
},
...
]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-stub-runner-messaging"><a class="anchor" href="#features-stub-runner-messaging"></a> <a class="link" href="#features-stub-runner-messaging">消息存根</a></h7>
<div class="paragraph">
<p>根据提供的Stub Runner依赖性和DSL，将自动设置消息传递路由。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-junit"><a class="anchor" href="#features-stub-runner-junit"></a> <a class="link" href="#features-stub-runner-junit">Stub Runner JUnit规则和Stub Runner JUnit5扩展</a></h5>
<div class="paragraph">
<p>Stub Runner带有JUnit规则，可让您下载并运行给定组和工件ID的Stub，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ClassRule
public static StubRunnerRule rule = new StubRunnerRule().repoRoot(repoRoot())
        .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
        .downloadStub("org.springframework.cloud.contract.verifier.stubs",
                "loanIssuance")
        .downloadStub(
                "org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer");

@BeforeClass
@AfterClass
public static void setupProps() {
    System.clearProperty("stubrunner.repository.root");
    System.clearProperty("stubrunner.classifier");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种<code>StubRunnerExtension</code>也可用于JUnit 5。 <code>StubRunnerRule</code>和<code>StubRunnerExtension</code>以非常相似的方式工作执行规则或扩展后，Stub Runner连接到您的Maven存储库，并针对给定的依赖项列表尝试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>下载它们</p>
</li>
<li>
<p>本地缓存它们</p>
</li>
<li>
<p>将它们解压缩到一个临时文件夹</p>
</li>
<li>
<p>从提供的端口范围或提供的端口为随机端口上的每个Maven依赖项启动WireMock服务器</p>
</li>
<li>
<p>向WireMock服务器提供有效的WireMock定义的所有JSON文件</p>
</li>
<li>
<p>发送消息（记住要通过一个实现<code>MessageVerifier</code>接口）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Stub Runner使用<a href="https://wiki.eclipse.org/Aether">Eclipse Aether</a>机制下载Maven依赖项。检查他们的<a href="https://wiki.eclipse.org/Aether">文档</a>以获取更多信息。</p>
</div>
<div class="paragraph">
<p>自从<code>StubRunnerRule</code>和<code>StubRunnerExtension</code>实施<code>StubFinder</code>它们使您可以找到启动的存根，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package org.springframework.cloud.contract.stubrunner;

import java.net.URL;
import java.util.Collection;
import java.util.Map;

import org.springframework.cloud.contract.spec.Contract;

/**
 * Contract for finding registered stubs.
 *
 * @author Marcin Grzejszczak
 */
public interface StubFinder extends StubTrigger {

    /**
     * For the given groupId and artifactId tries to find the matching URL of the running
     * stub.
     * @param groupId - might be null. In that case a search only via artifactId takes
     * place
     * @param artifactId - artifact id of the stub
     * @return URL of a running stub or throws exception if not found
     * @throws StubNotFoundException in case of not finding a stub
     */
    URL findStubUrl(String groupId, String artifactId) throws StubNotFoundException;

    /**
     * For the given Ivy notation {@code [groupId]:artifactId:[version]:[classifier]}
     * tries to find the matching URL of the running stub. You can also pass only
     * {@code artifactId}.
     * @param ivyNotation - Ivy representation of the Maven artifact
     * @return URL of a running stub or throws exception if not found
     * @throws StubNotFoundException in case of not finding a stub
     */
    URL findStubUrl(String ivyNotation) throws StubNotFoundException;

    /**
     * @return all running stubs
     */
    RunningStubs findAllRunningStubs();

    /**
     * @return the list of Contracts
     */
    Map<StubConfiguration, Collection<Contract>> getContracts();

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例提供有关使用Stub Runner的更多详细信息：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">斯波克</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@ClassRule
@Shared
StubRunnerRule rule = new StubRunnerRule()
        .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
        .repoRoot(StubRunnerRuleSpec.getResource("/m2repo/repository").toURI().toString())
        .downloadStub("org.springframework.cloud.contract.verifier.stubs", "loanIssuance")
        .downloadStub("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")
        .withMappingsOutputFolder("target/outputmappingsforrule")


def 'should start WireMock servers'() {
    expect: 'WireMocks are running'
        rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
        rule.findStubUrl('loanIssuance') != null
        rule.findStubUrl('loanIssuance') == rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
        rule.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
    and:
        rule.findAllRunningStubs().isPresent('loanIssuance')
        rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
        rule.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
    and: 'Stubs were registered'
        "${rule.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
        "${rule.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
}

def 'should output mappings to output folder'() {
    when:
        def url = rule.findStubUrl('fraudDetectionServer')
    then:
        new File("target/outputmappingsforrule", "fraudDetectionServer_${url.port}").exists()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">初级4</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void should_start_wiremock_servers() throws Exception {
    // expect: 'WireMocks are running'
    then(rule.findStubUrl("org.springframework.cloud.contract.verifier.stubs",
            "loanIssuance")).isNotNull();
    then(rule.findStubUrl("loanIssuance")).isNotNull();
    then(rule.findStubUrl("loanIssuance")).isEqualTo(rule.findStubUrl(
            "org.springframework.cloud.contract.verifier.stubs", "loanIssuance"));
    then(rule.findStubUrl(
            "org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"))
                    .isNotNull();
    // and:
    then(rule.findAllRunningStubs().isPresent("loanIssuance")).isTrue();
    then(rule.findAllRunningStubs().isPresent(
            "org.springframework.cloud.contract.verifier.stubs",
            "fraudDetectionServer")).isTrue();
    then(rule.findAllRunningStubs().isPresent(
            "org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer"))
                    .isTrue();
    // and: 'Stubs were registered'
    then(httpGet(rule.findStubUrl("loanIssuance").toString() + "/name"))
            .isEqualTo("loanIssuance");
    then(httpGet(rule.findStubUrl("fraudDetectionServer").toString() + "/name"))
            .isEqualTo("fraudDetectionServer");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">初级5</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Visible for Junit
@RegisterExtension
static StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
        .repoRoot(repoRoot()).stubsMode(StubRunnerProperties.StubsMode.REMOTE)
        .downloadStub("org.springframework.cloud.contract.verifier.stubs",
                "loanIssuance")
        .downloadStub(
                "org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")
        .withMappingsOutputFolder("target/outputmappingsforrule");

@BeforeAll
@AfterAll
static void setupProps() {
    System.clearProperty("stubrunner.repository.root");
    System.clearProperty("stubrunner.classifier");
}

private static String repoRoot() {
    try {
        return StubRunnerRuleJUnitTest.class.getResource("/m2repo/repository/")
                .toURI().toString();
    }
    catch (Exception e) {
        return "";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有关如何应用Stub Runner的全局配置的更多信息，请参见<a href="#features-stub-runner-common-properties-junit-spring">JUnit和Spring</a>的<a href="#features-stub-runner-common-properties-junit-spring">通用属性</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">要将JUnit规则或JUnit 5扩展与消息传递一起使用，您必须提供<code>MessageVerifier</code>规则构建器的界面（例如， <code>rule.messageVerifier(new MyMessageVerifier())</code> ）。如果不这样做，则每当您尝试发送消息时，都会引发异常。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="features-stub-runner-rule-maven-settings"><a class="anchor" href="#features-stub-runner-rule-maven-settings"></a> <a class="link" href="#features-stub-runner-rule-maven-settings">Maven设置</a></h6>
<div class="paragraph">
<p>存根下载程序会使用其他本地存储库文件夹的Maven设置。当前不考虑存储库和概要文件的认证详细信息，因此您需要使用上述属性来指定它。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-rule-fixed-ports"><a class="anchor" href="#features-stub-runner-rule-fixed-ports"></a> <a class="link" href="#features-stub-runner-rule-fixed-ports">提供固定端口</a></h6>
<div class="paragraph">
<p>您还可以在固定端口上运行存根。您可以通过两种不同的方式来实现。一种是在属性中传递它，另一种是使用JUnit规则的流畅API。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-rule-fluent-api"><a class="anchor" href="#features-stub-runner-rule-fluent-api"></a> <a class="link" href="#features-stub-runner-rule-fluent-api">流利的API</a></h6>
<div class="paragraph">
<p>使用时<code>StubRunnerRule</code>要么<code>StubRunnerExtension</code> ，您可以添加一个存根进行下载，然后将最近下载的存根的端口传递给该端口。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ClassRule
public static StubRunnerRule rule = new StubRunnerRule().repoRoot(repoRoot())
        .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
        .downloadStub("org.springframework.cloud.contract.verifier.stubs",
                "loanIssuance")
        .withPort(12345).downloadStub(
                "org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer:12346");

@BeforeClass
@AfterClass
public static void setupProps() {
    System.clearProperty("stubrunner.repository.root");
    System.clearProperty("stubrunner.classifier");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于前面的示例，以下测试有效：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">then(rule.findStubUrl("loanIssuance"))
        .isEqualTo(URI.create("http://localhost:12345").toURL());
then(rule.findStubUrl("fraudDetectionServer"))
        .isEqualTo(URI.create("http://localhost:12346").toURL());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-rule-spring"><a class="anchor" href="#features-stub-runner-rule-spring"></a> <a class="link" href="#features-stub-runner-rule-spring">春天的存根转轮</a></h6>
<div class="paragraph">
<p>使用Spring的Stub Runner设置Stub Runner项目的Spring配置。</p>
</div>
<div class="paragraph">
<p>通过在配置文件中提供存根列表，Stub Runner会自动下载并在WireMock中注册所选存根。</p>
</div>
<div class="paragraph">
<p>如果要查找存根依赖项的URL，可以自动连接<code>StubFinder</code>接口并使用其方法，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest(properties = [" stubrunner.cloud.enabled=false",
        'foo=${stubrunner.runningstubs.fraudDetectionServer.port}',
        'fooWithGroup=${stubrunner.runningstubs.org.springframework.cloud.contract.verifier.stubs.fraudDetectionServer.port}'])
@AutoConfigureStubRunner(mappingsOutputFolder = "target/outputmappings/",
        httpServerStubConfigurer = HttpsForFraudDetection)
@ActiveProfiles("test")
class StubRunnerConfigurationSpec extends Specification {

    @Autowired
    StubFinder stubFinder
    @Autowired
    Environment environment
    @StubRunnerPort("fraudDetectionServer")
    int fraudDetectionServerPort
    @StubRunnerPort("org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer")
    int fraudDetectionServerPortWithGroupId
    @Value('${foo}')
    Integer foo

    @BeforeClass
    @AfterClass
    void setupProps() {
        System.clearProperty("stubrunner.repository.root")
        System.clearProperty("stubrunner.classifier")
        WireMockHttpServerStubAccessor.clear()
    }

    def 'should mark all ports as random'() {
        expect:
            WireMockHttpServerStubAccessor.everyPortRandom()
    }

    def 'should start WireMock servers'() {
        expect: 'WireMocks are running'
            stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance') != null
            stubFinder.findStubUrl('loanIssuance') != null
            stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs', 'loanIssuance')
            stubFinder.findStubUrl('loanIssuance') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance')
            stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT') == stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs')
            stubFinder.findStubUrl('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer') != null
        and:
            stubFinder.findAllRunningStubs().isPresent('loanIssuance')
            stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs', 'fraudDetectionServer')
            stubFinder.findAllRunningStubs().isPresent('org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer')
        and: 'Stubs were registered'
            "${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
            "${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
        and: 'Fraud Detection is an HTTPS endpoint'
            stubFinder.findStubUrl('fraudDetectionServer').toString().startsWith("https")
    }

    def 'should throw an exception when stub is not found'() {
        when:
            stubFinder.findStubUrl('nonExistingService')
        then:
            thrown(StubNotFoundException)
        when:
            stubFinder.findStubUrl('nonExistingGroupId', 'nonExistingArtifactId')
        then:
            thrown(StubNotFoundException)
    }

    def 'should register started servers as environment variables'() {
        expect:
            environment.getProperty("stubrunner.runningstubs.loanIssuance.port") != null
            stubFinder.findAllRunningStubs().getPort("loanIssuance") == (environment.getProperty("stubrunner.runningstubs.loanIssuance.port") as Integer)
        and:
            environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") != null
            stubFinder.findAllRunningStubs().getPort("fraudDetectionServer") == (environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") as Integer)
        and:
            environment.getProperty("stubrunner.runningstubs.fraudDetectionServer.port") != null
            stubFinder.findAllRunningStubs().getPort("fraudDetectionServer") == (environment.getProperty("stubrunner.runningstubs.org.springframework.cloud.contract.verifier.stubs.fraudDetectionServer.port") as Integer)
    }

    def 'should be able to interpolate a running stub in the passed test property'() {
        given:
            int fraudPort = stubFinder.findAllRunningStubs().getPort("fraudDetectionServer")
        expect:
            fraudPort > 0
            environment.getProperty("foo", Integer) == fraudPort
            environment.getProperty("fooWithGroup", Integer) == fraudPort
            foo == fraudPort
    }

    @Issue("#573")
    def 'should be able to retrieve the port of a running stub via an annotation'() {
        given:
            int fraudPort = stubFinder.findAllRunningStubs().getPort("fraudDetectionServer")
        expect:
            fraudPort > 0
            fraudDetectionServerPort == fraudPort
            fraudDetectionServerPortWithGroupId == fraudPort
    }

    def 'should dump all mappings to a file'() {
        when:
            def url = stubFinder.findStubUrl("fraudDetectionServer")
        then:
            new File("target/outputmappings/", "fraudDetectionServer_${url.port}").exists()
    }

    @Configuration
    @EnableAutoConfiguration
    static class Config {}

    @CompileStatic
    static class HttpsForFraudDetection extends WireMockHttpServerStubConfigurer {

        private static final Log log = LogFactory.getLog(HttpsForFraudDetection)

        @Override
        WireMockConfiguration configure(WireMockConfiguration httpStubConfiguration, HttpServerStubConfiguration httpServerStubConfiguration) {
            if (httpServerStubConfiguration.stubConfiguration.artifactId == "fraudDetectionServer") {
                int httpsPort = SocketUtils.findAvailableTcpPort()
                log.info("Will set HTTPs port [" + httpsPort + "] for fraud detection server")
                return httpStubConfiguration
                        .httpsPort(httpsPort)
            }
            return httpStubConfiguration
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样做取决于以下配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">stubrunner:
  repositoryRoot: classpath:m2repo/repository/
  ids:
    - org.springframework.cloud.contract.verifier.stubs:loanIssuance
    - org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer
    - org.springframework.cloud.contract.verifier.stubs:bootService
  stubs-mode: remote</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了使用属性外，您还可以在<code>@AutoConfigureStubRunner</code> 。以下示例通过在注释上设置值来实现相同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@AutoConfigureStubRunner(
        ids = ["org.springframework.cloud.contract.verifier.stubs:loanIssuance",
                "org.springframework.cloud.contract.verifier.stubs:fraudDetectionServer",
                "org.springframework.cloud.contract.verifier.stubs:bootService"],
        stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        repositoryRoot = "classpath:m2repo/repository/")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stub Runner Spring以下列方式为每个已注册的WireMock服务器注册环境变量。以下示例显示了Stub Runner ID <code>com.example:thing1</code>和<code>com.example:thing2</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stubrunner.runningstubs.thing1.port</code></p>
</li>
<li>
<p><code>stubrunner.runningstubs.com.example.thing1.port</code></p>
</li>
<li>
<p><code>stubrunner.runningstubs.thing2.port</code></p>
</li>
<li>
<p><code>stubrunner.runningstubs.com.example.thing2.port</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在代码中引用这些值。</p>
</div>
<div class="paragraph">
<p>您也可以使用<code>@StubRunnerPort</code>注释以注入正在运行的存根的端口。注释的值可以是<code>groupid:artifactid</code>或只是<code>artifactid</code> 。以下示例作品显示了Stub Runner ID <code>com.example:thing1</code>和<code>com.example:thing2</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@StubRunnerPort("thing1")
int thing1Port;
@StubRunnerPort("com.example:thing2")
int thing2Port;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-cloud"><a class="anchor" href="#features-stub-runner-cloud"></a> <a class="link" href="#features-stub-runner-cloud">存根赛跑者春天云</a></h5>
<div class="paragraph">
<p>Stub Runner可以与Spring Cloud集成。</p>
</div>
<div class="paragraph">
<p>有关真实示例，请参阅：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/producer">生产者应用示例</a></p>
</li>
<li>
<p><a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/consumer_with_discovery">消费者应用样本</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="features-stub-runner-cloud-stubbing-discovery"><a class="anchor" href="#features-stub-runner-cloud-stubbing-discovery"></a> <a class="link" href="#features-stub-runner-cloud-stubbing-discovery">存根服务发现</a></h6>
<div class="paragraph">
<p>最重要的特点<code>Stub Runner Spring Cloud</code>它存根的事实是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscoveryClient</code></p>
</li>
<li>
<p><code>Ribbon</code> <code>ServerList</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着，无论您使用Zookeeper，Consul，Eureka还是其他任何工具，您都不需要在测试中使用它。我们将启动依赖项的WireMock实例，并在您使用时告诉您的应用程序<code>Feign</code> ，以平衡<code>RestTemplate</code>要么<code>DiscoveryClient</code>直接调用那些存根服务器，而不用调用真正的服务发现工具。</p>
</div>
<div class="paragraph">
<p>例如，以下测试通过：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def 'should make service discovery work'() {
    expect: 'WireMocks are running'
        "${stubFinder.findStubUrl('loanIssuance').toString()}/name".toURL().text == 'loanIssuance'
        "${stubFinder.findStubUrl('fraudDetectionServer').toString()}/name".toURL().text == 'fraudDetectionServer'
    and: 'Stubs can be reached via load service discovery'
        restTemplate.getForObject('http://loanIssuance/name', String) == 'loanIssuance'
        restTemplate.getForObject('http://someNameThatShouldMapFraudDetectionServer/name', String) == 'fraudDetectionServer'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，前面的示例需要以下配置文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">stubrunner:
  idsToServiceIds:
    ivyNotation: someValueInsideYourCode
    fraudDetectionServer: someNameThatShouldMapFraudDetectionServer</code></pre>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="features-stub-runner-cloud-stubbing-profiles"><a class="anchor" href="#features-stub-runner-cloud-stubbing-profiles"></a> <a class="link" href="#features-stub-runner-cloud-stubbing-profiles">测试配置文件和服务发现</a></h7>
<div class="paragraph">
<p>在集成测试中，通常不希望调用发现服务（例如Eureka）或Config Server。这就是为什么您要在其中创建其他测试配置以禁用这些功能的原因。</p>
</div>
<div class="paragraph">
<p>由于以下限制<a href="https://github.com/spring-cloud/spring-cloud-commons/issues/156"><code>spring-cloud-commons</code></a>为此，您必须在静态块中禁用这些属性，例如以下示例（适用于Eureka）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    //Hack to work around https://github.com/spring-cloud/spring-cloud-commons/issues/156
    static {
        System.setProperty("eureka.client.enabled", "false");
        System.setProperty("spring.cloud.config.failFast", "false");
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-additional-config"><a class="anchor" href="#features-stub-runner-additional-config"></a> <a class="link" href="#features-stub-runner-additional-config">附加配置</a></h6>
<div class="paragraph">
<p>您可以匹配<code>artifactId</code>使用您的应用程序的名称存根<code>stubrunner.idsToServiceIds:</code>地图。您可以通过设置禁用Stub Runner功能区支持<code>stubrunner.cloud.ribbon.enabled</code>至<code>false</code>您可以通过设置禁用Stub Runner支持<code>stubrunner.cloud.enabled</code>至<code>false</code></p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">默认情况下，所有服务发现均已存根。这意味着，无论您是否已有<code>DiscoveryClient</code> ，其结果将被忽略。但是，如果要重用它，可以设置<code>stubrunner.cloud.delegate.enabled</code>至<code>true</code> ，然后是您现有的<code>DiscoveryClient</code>结果与存根的结果合并。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以通过设置以下系统属性或设置相应的环境变量来调整Stub Runner使用的默认Maven配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>maven.repo.local</code> ：定制maven本地存储库位置的路径</p>
</li>
<li>
<p><code>org.apache.maven.user-settings</code> ：定制maven用户设置位置的路径</p>
</li>
<li>
<p><code>org.apache.maven.global-settings</code> ：Maven全局设置位置的路径</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-boot"><a class="anchor" href="#features-stub-runner-boot"></a> <a class="link" href="#features-stub-runner-boot">使用Stub Runner引导应用程序</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract Stub Runner Boot是一个Spring Boot应用程序，它公开REST端点以触发消息传递标签并访问WireMock服务器。</p>
</div>
<div class="paragraph">
<p>用例之一是在已部署的应用程序上运行一些冒烟（端到端）测试。您可以检出<a href="https://github.com/spring-cloud/spring-cloud-pipelines">Spring Cloud Pipelines</a>项目以获取更多信息。</p>
</div>
<div class="sect5">
<h6 id="features-stub-runner-boot-server"><a class="anchor" href="#features-stub-runner-boot-server"></a> <a class="link" href="#features-stub-runner-boot-server">存根转轮服务器</a></h6>
<div class="paragraph">
<p>要使用Stub Runner Server，请添加以下依赖项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">compile "org.springframework.cloud:spring-cloud-starter-stub-runner"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后用<code>@EnableStubRunnerServer</code> ，建立一个胖子罐，就可以开始工作了。</p>
</div>
<div class="paragraph">
<p>有关属性，请参见“ <a href="#features-stub-runner-rule-spring">Stub Runner Spring”</a>部分。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-boot-how-fat-jar"><a class="anchor" href="#features-stub-runner-boot-how-fat-jar"></a> <a class="link" href="#features-stub-runner-boot-how-fat-jar">存根转轮服务器胖子</a></h6>
<div class="paragraph">
<p>您可以从Maven下载独立的JAR（例如，版本2.0.1）。通过运行以下命令来释放：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ wget -O stub-runner.jar 'https://search.maven.org/remotecontent?filepath=org/springframework/cloud/spring-cloud-contract-stub-runner-boot/2.0.1.RELEASE/spring-cloud-contract-stub-runner-boot-2.0.1.RELEASE.jar'
$ java -jar stub-runner.jar --stubrunner.ids=... --stubrunner.repositoryRoot=...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-boot-how-cli"><a class="anchor" href="#features-stub-runner-boot-how-cli"></a> <a class="link" href="#features-stub-runner-boot-how-cli">Spring Cloud CLI</a></h6>
<div class="paragraph">
<p>从开始<code>1.4.0.RELEASE</code>版本的<a href="https://cloud.spring.io/spring-cloud-cli">Spring Cloud CLI</a>项目，您可以通过运行以下<a href="https://cloud.spring.io/spring-cloud-cli">命令</a>启动Stub Runner Boot <code>spring cloud stubrunner</code> 。</p>
</div>
<div class="paragraph">
<p>为了通过配置，您可以创建一个<code>stubrunner.yml</code>文件在当前工作目录中的子目录中<code>config</code> ，或<code>~/.spring-cloud</code> 。该文件可能类似于以下示例，用于运行本地安装的存根：</p>
</div>
<div class="exampleblock">
<div class="title">例子2. stubrunner.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">stubrunner:
  stubsMode: LOCAL
  ids:
    - com.example:beer-api-producer:+:9876</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>那你可以打电话<code>spring cloud stubrunner</code>从终端窗口启动Stub Runner服务器。在港口可以买到<code>8750</code> 。</p>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-boot-endpoints"><a class="anchor" href="#features-stub-runner-boot-endpoints"></a> <a class="link" href="#features-stub-runner-boot-endpoints">终点</a></h6>
<div class="paragraph">
<p>Stub Runner Boot提供两个端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#features-stub-runner-boot-endpoints-http">HTTP</a></p>
</li>
<li>
<p><a href="#features-stub-runner-boot-endpoints-messaging">讯息传递</a></p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="features-stub-runner-boot-endpoints-http"><a class="anchor" href="#features-stub-runner-boot-endpoints-http"></a> <a class="link" href="#features-stub-runner-boot-endpoints-http">HTTP</a></h7>
<div class="paragraph">
<p>对于HTTP，Stub Runner Boot使以下端点可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>得到<code>/stubs</code> ：返回中所有正在运行的存根的列表<code>ivy:integer</code>符号</p>
</li>
<li>
<p>得到<code>/stubs/{ivy}</code> ：返回给定的端口<code>ivy</code>表示法（调用端点时<code>ivy</code>也可以是<code>artifactId</code>只要）</p>
</li>
</ul>
</div>
</div>
<div class="sect6">
<h7 id="features-stub-runner-boot-endpoints-messaging"><a class="anchor" href="#features-stub-runner-boot-endpoints-messaging"></a> <a class="link" href="#features-stub-runner-boot-endpoints-messaging">讯息传递</a></h7>
<div class="paragraph">
<p>对于消息传递，Stub Runner Boot使以下端点可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>得到<code>/triggers</code> ：返回中所有正在运行的标签的列表<code>ivy : [ label1, label2 …​]</code>符号</p>
</li>
<li>
<p>开机自检<code>/triggers/{label}</code> ：使用以下命令运行触发器<code>label</code></p>
</li>
<li>
<p>开机自检<code>/triggers/{ivy}/{label}</code> ：使用<code>label</code>给定的<code>ivy</code>表示法（调用端点时， <code>ivy</code>也可以是<code>artifactId</code>只要）</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-boot-endpoints-example"><a class="anchor" href="#features-stub-runner-boot-endpoints-example"></a> <a class="link" href="#features-stub-runner-boot-endpoints-example">例</a></h6>
<div class="paragraph">
<p>以下示例显示了Stub Runner Boot的典型用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@ContextConfiguration(classes = StubRunnerBoot, loader = SpringBootContextLoader)
@SpringBootTest(properties = "spring.cloud.zookeeper.enabled=false")
@ActiveProfiles("test")
class StubRunnerBootSpec extends Specification {

    @Autowired
    StubRunning stubRunning

    def setup() {
        RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning),
                new TriggerController(stubRunning))
    }

    def 'should return a list of running stub servers in "full ivy:port" notation'() {
        when:
            String response = RestAssuredMockMvc.get('/stubs').body.asString()
        then:
            def root = new JsonSlurper().parseText(response)
            root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs' instanceof Integer
    }

    def 'should return a port on which a [#stubId] stub is running'() {
        when:
            def response = RestAssuredMockMvc.get("/stubs/${stubId}")
        then:
            response.statusCode == 200
            Integer.valueOf(response.body.asString()) > 0
        where:
            stubId << ['org.springframework.cloud.contract.verifier.stubs:bootService:+:stubs',
                       'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs',
                       'org.springframework.cloud.contract.verifier.stubs:bootService:+',
                       'org.springframework.cloud.contract.verifier.stubs:bootService',
                       'bootService']
    }

    def 'should return 404 when missing stub was called'() {
        when:
            def response = RestAssuredMockMvc.get("/stubs/a:b:c:d")
        then:
            response.statusCode == 404
    }

    def 'should return a list of messaging labels that can be triggered when version and classifier are passed'() {
        when:
            String response = RestAssuredMockMvc.get('/triggers').body.asString()
        then:
            def root = new JsonSlurper().parseText(response)
            root.'org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs'?.containsAll(["delete_book", "return_book_1", "return_book_2"])
    }

    def 'should trigger a messaging label'() {
        given:
            StubRunning stubRunning = Mock()
            RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
        when:
            def response = RestAssuredMockMvc.post("/triggers/delete_book")
        then:
            response.statusCode == 200
        and:
            1 * stubRunning.trigger('delete_book')
    }

    def 'should trigger a messaging label for a stub with [#stubId] ivy notation'() {
        given:
            StubRunning stubRunning = Mock()
            RestAssuredMockMvc.standaloneSetup(new HttpStubsController(stubRunning), new TriggerController(stubRunning))
        when:
            def response = RestAssuredMockMvc.post("/triggers/$stubId/delete_book")
        then:
            response.statusCode == 200
        and:
            1 * stubRunning.trigger(stubId, 'delete_book')
        where:
            stubId << ['org.springframework.cloud.contract.verifier.stubs:bootService:stubs', 'org.springframework.cloud.contract.verifier.stubs:bootService', 'bootService']
    }

    def 'should throw exception when trigger is missing'() {
        when:
            RestAssuredMockMvc.post("/triggers/missing_label")
        then:
            Exception e = thrown(Exception)
            e.message.contains("Exception occurred while trying to return [missing_label] label.")
            e.message.contains("Available labels are")
            e.message.contains("org.springframework.cloud.contract.verifier.stubs:loanIssuance:0.0.1-SNAPSHOT:stubs=[]")
            e.message.contains("org.springframework.cloud.contract.verifier.stubs:bootService:0.0.1-SNAPSHOT:stubs=")
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="features-stub-runner-boot-service-discovery"><a class="anchor" href="#features-stub-runner-boot-service-discovery"></a> <a class="link" href="#features-stub-runner-boot-service-discovery">具有服务发现功能的存根运行器引导</a></h6>
<div class="paragraph">
<p>使用Stub Runner Boot的一种方法是将其用作“烟雾测试”的存根的提要。这意味着什么？假设您不想将50个微服务部署到测试环境以查看您的应用程序是否正常工作。在构建过程中，您已经执行了一组测试，但是您还想确保应用程序的打包有效。您可以将应用程序部署到环境中，启动它，然后在其上运行一些测试以查看其是否正常运行。我们可以将这些测试称为“烟雾测试”，因为它们的目的只是检查少数几种测试场景。</p>
</div>
<div class="paragraph">
<p>这种方法的问题在于，如果您使用微服务，则很可能还会使用服务发现工具。Stub Runner Boot可通过启动所需的stub并将其注册到服务发现工具中来解决此问题。考虑以下使用Eureka进行安装的示例（假设Eureka已经在运行）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableStubRunnerServer
@EnableEurekaClient
@AutoConfigureStubRunner
public class StubRunnerBootEurekaExample {

    public static void main(String[] args) {
        SpringApplication.run(StubRunnerBootEurekaExample.class, args);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们要启动一个Stub Runner Boot服务器（ <code>@EnableStubRunnerServer</code> ），启用Eureka客户端（ <code>@EnableEurekaClient</code> ），并启用了存根流转功能（ <code>@AutoConfigureStubRunner</code> ）。</p>
</div>
<div class="paragraph">
<p>现在假设我们要启动此应用程序，以便存根自动注册。我们可以这样运行应用程序： <code>java -jar ${SYSTEM_PROPS} stub-runner-boot-eureka-example.jar</code> ，在哪里<code>${SYSTEM_PROPS}</code>包含以下属性列表：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">* -Dstubrunner.repositoryRoot=https://repo.spring.io/snapshot (1)
* -Dstubrunner.cloud.stubbed.discovery.enabled=false (2)
* -Dstubrunner.ids=org.springframework.cloud.contract.verifier.stubs:loanIssuance,org.
* springframework.cloud.contract.verifier.stubs:fraudDetectionServer,org.springframework.
* cloud.contract.verifier.stubs:bootService (3)
* -Dstubrunner.idsToServiceIds.fraudDetectionServer=
* someNameThatShouldMapFraudDetectionServer (4)
*
* (1) - we tell Stub Runner where all the stubs reside (2) - we don't want the default
* behaviour where the discovery service is stubbed. That's why the stub registration will
* be picked (3) - we provide a list of stubs to download (4) - we provide a list of</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，您部署的应用程序可以通过服务发现将请求发送到启动的WireMock服务器。最有可能在默认情况下将点1到3设置为<code>application.yml</code> ，因为它们不太可能改变。这样，您每次启动Stub Runner Boot时都只能提供要下载的存根列表。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-stubs-per-consumer"><a class="anchor" href="#features-stub-runner-stubs-per-consumer"></a> <a class="link" href="#features-stub-runner-stubs-per-consumer">消费者驱动的合同：每个消费者存根</a></h5>
<div class="paragraph">
<p>在某些情况下，同一端点的两个使用者希望有两个不同的响应。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">这种方法还使您立即知道哪个使用者使用了API的哪一部分。您可以删除API产生的部分响应，并查看哪些自动生成的测试失败。如果没有失败，则可以安全地删除响应的那部分，因为没有人使用它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑以下为生产者定义的合同示例，该合同称为<code>producer</code> ，其中有两个消费者（ <code>foo-consumer</code>和<code>bar-consumer</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">消费者<code>foo-service</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">request {
   url '/foo'
   method GET()
}
response {
    status OK()
    body(
       foo: "foo"
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">消费者<code>bar-service</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">request {
   url '/bar'
   method GET()
}
response {
    status OK()
    body(
       bar: "bar"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您不能为同一请求产生两个不同的响应。因此，您可以正确打包合同，然后从中获利<code>stubsPerConsumer</code>特征。</p>
</div>
<div class="paragraph">
<p>在生产者方面，消费者可以有一个文件夹，其中包含仅与他们相关的合同。通过设置<code>stubrunner.stubs-per-consumer</code>标记为<code>true</code> ，我们不再注册所有存根，而是仅注册与使用者应用程序名称相对应的存根。换句话说，我们扫描每个存根的路径，如果它在路径中包含带有使用者名称的子文件夹，则只有它才被注册。</p>
</div>
<div class="paragraph">
<p>在<code>foo</code>生产者方合同看起来像这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">.
└── contracts
    ├── bar-consumer
    │   ├── bookReturnedForBar.groovy
    │   └── shouldCallBar.groovy
    └── foo-consumer
        ├── bookReturnedForFoo.groovy
        └── shouldCallFoo.groovy</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>bar-consumer</code>消费者可以设置<code>spring.application.name</code>或者<code>stubrunner.consumer-name</code>至<code>bar-consumer</code>或者，您可以按以下方式设置测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest(properties = ["spring.application.name=bar-consumer"])
@AutoConfigureStubRunner(ids = "org.springframework.cloud.contract.verifier.stubs:producerWithMultipleConsumers",
        repositoryRoot = "classpath:m2repo/repository/",
        stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        stubsPerConsumer = true)
class StubRunnerStubsPerConsumerSpec extends Specification {
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后只有在包含以下内容的路径下注册的存根<code>bar-consumer</code>以其名称（即来自<code>src/test/resources/contracts/bar-consumer/some/contracts/…​</code>文件夹）被允许引用。</p>
</div>
<div class="paragraph">
<p>您还可以显式设置使用者名称，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@ContextConfiguration(classes = Config, loader = SpringBootContextLoader)
@SpringBootTest
@AutoConfigureStubRunner(ids = "org.springframework.cloud.contract.verifier.stubs:producerWithMultipleConsumers",
        repositoryRoot = "classpath:m2repo/repository/",
        consumerName = "foo-consumer",
        stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        stubsPerConsumer = true)
class StubRunnerStubsPerConsumerWithConsumerNameSpec extends Specification {
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，仅在包含以下内容的路径下注册的存根<code>foo-consumer</code>以其名称（即来自<code>src/test/resources/contracts/foo-consumer/some/contracts/…​</code>文件夹）被允许引用。</p>
</div>
<div class="paragraph">
<p>有关此更改背后原因的更多信息，请参见<a href="https://github.com/spring-cloud/spring-cloud-contract/issues/224">问题224</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-stubs-protocol"><a class="anchor" href="#features-stub-runner-stubs-protocol"></a> <a class="link" href="#features-stub-runner-stubs-protocol">从某个位置获取存根或合同定义</a></h5>
<div class="paragraph">
<p>与其从Artifactory / Nexus或Git中选择存根或合同定义，不如只想指向驱动器或类路径上的某个位置。这在多模块项目中尤其有用，在该项目中，一个模块要重用来自另一个模块的存根或合同，而无需在本地maven存储库中实际安装存根或合同，而将这些更改提交给Git。</p>
</div>
<div class="paragraph">
<p>为了实现这一点，使用<code>stubs://</code>在Stub Runner或Spring Cloud Contract插件中设置存储库根参数时的协议。</p>
</div>
<div class="paragraph">
<p>在这个例子中<code>producer</code>项目已成功构建，并且在<code>target/stubs</code>夹。作为消费者，可以设置Stub Runner以使用该位置从该位置选择Stub。 <code>stubs://</code>协议。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">注解</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        repositoryRoot = "stubs://file://location/to/the/producer/target/stubs/",
        ids = "com.example:some-producer")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 4规则</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
    public StubRunnerRule rule = new StubRunnerRule()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/producer/target/stubs/")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 5扩展</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RegisterExtension
    public StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/producer/target/stubs/")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>合同和存根可以存储在一个位置，每个生产者都有一个自己的专用文件夹，用于合同和存根映射。在该文件夹下，每个使用者都可以有自己的设置。为了使Stub Runner从提供的ID中找到专用文件夹，可以传递属性<code>stubs.find-producer=true</code>或系统属性<code>stubrunner.stubs.find-producer=true</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">└── com.example <i class="conum" data-value="1"></i><b>(1)</b>
    ├── some-artifact-id <i class="conum" data-value="2"></i><b>(2)</b>
    │   └── 0.0.1
    │       ├── contracts <i class="conum" data-value="3"></i><b>(3)</b>
    │       │   └── shouldReturnStuffForArtifactId.groovy
    │       └── mappings <i class="conum" data-value="4"></i><b>(4)</b>
    │           └── shouldReturnStuffForArtifactId.json
    └── some-other-artifact-id <i class="conum" data-value="5"></i><b>(5)</b>
        ├── contracts
        │   └── shouldReturnStuffForOtherArtifactId.groovy
        └── mappings
            └── shouldReturnStuffForOtherArtifactId.json</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>消费者的组ID</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>具有人工制品ID [some-artifact-id]的消费者</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>具有工件ID [some-artifact-id]的消费者的合同</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>具有工件ID [some-artifact-id]的消费者的映射</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>具有人工制品ID [其他人工制品ID]的消费者</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">注解</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        repositoryRoot = "stubs://file://location/to/the/contracts/directory",
        ids = "com.example:some-producer",
        properties="stubs.find-producer=true")</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 4规则</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    static Map<String, String> contractProperties() {
        Map<String, String> map = new HashMap<>();
        map.put("stubs.find-producer", "true");
        return map;
    }

@Rule
    public StubRunnerRule rule = new StubRunnerRule()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/contracts/directory")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
            .properties(contractProperties());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 5扩展</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    static Map<String, String> contractProperties() {
        Map<String, String> map = new HashMap<>();
        map.put("stubs.find-producer", "true");
        return map;
    }

@RegisterExtension
    public StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/contracts/directory")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
            .properties(contractProperties());</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-generate-stubs-at-runtime"><a class="anchor" href="#features-stub-runner-generate-stubs-at-runtime"></a> <a class="link" href="#features-stub-runner-generate-stubs-at-runtime">在运行时生成存根</a></h5>
<div class="paragraph">
<p>作为消费者，您可能不想等待生产者完成其实现，然后发布其存根。解决此问题的方法是在运行时生成存根。</p>
</div>
<div class="paragraph">
<p>作为生产者，在定义合同后，您需要使生成的测试通过才能发布存根。在某些情况下，您希望解除对使用者的阻止，以便他们可以在测试通过之前就获取存根。在这种情况下，您应将此类合同设置为进行中。您可以<a href="#contract-dsl-in-progress">在“正在进行</a>的<a href="#contract-dsl-in-progress">合同”</a>部分中阅读有关此内容的更多信息。这样，将不会生成您的测试，但会生成存根。</p>
</div>
<div class="paragraph">
<p>作为使用者，您可以切换开关以在运行时生成存根。Stub Runner将忽略所有现有的Stub映射，并将为所有合同定义生成新的Stub映射。另一种选择是通过<code>stubrunner.generate-stubs</code>系统属性。您可以在下面找到此类设置的示例。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">注解</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        repositoryRoot = "stubs://file://location/to/the/contracts",
        ids = "com.example:some-producer",
        generateStubs = true)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 4规则</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
    public StubRunnerRule rule = new StubRunnerRule()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/contracts")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
            .withGenerateStubs(true);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 5扩展</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RegisterExtension
    public StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/contracts")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
            .withGenerateStubs(true);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-fail-on-no-stubs"><a class="anchor" href="#features-stub-runner-fail-on-no-stubs"></a> <a class="link" href="#features-stub-runner-fail-on-no-stubs">没有存根失败</a></h5>
<div class="paragraph">
<p>默认情况下，如果未找到存根，则存根运行器将失败。为了更改该行为，只需将<code>false</code>的<code>failOnNoStubs</code>注释中的属性或调用<code>withFailOnNoStubs(false)</code> JUnit规则或扩展上的方法。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">注解</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        repositoryRoot = "stubs://file://location/to/the/contracts",
        ids = "com.example:some-producer",
        failOnNoStubs = false)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 4规则</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Rule
    public StubRunnerRule rule = new StubRunnerRule()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/contracts")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
            .withFailOnNoStubs(false);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JUnit 5扩展</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RegisterExtension
    public StubRunnerExtension stubRunnerExtension = new StubRunnerExtension()
            .downloadStub("com.example:some-producer")
            .repoRoot("stubs://file://location/to/the/contracts")
            .stubsMode(StubRunnerProperties.StubsMode.REMOTE)
            .withFailOnNoStubs(false);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-stub-runner-common"><a class="anchor" href="#features-stub-runner-common"></a> <a class="link" href="#features-stub-runner-common">共同属性</a></h5>
<div class="paragraph">
<p>本节简要介绍了常用属性，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#features-stub-runner-common-properties-junit-spring">JUnit和Spring的通用属性</a></p>
</li>
<li>
<p><a href="#features-stub-runner-stub-runner-stub-ids">存根转轮存根ID</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="features-stub-runner-common-properties-junit-spring"><a class="anchor" href="#features-stub-runner-common-properties-junit-spring"></a> <a class="link" href="#features-stub-runner-common-properties-junit-spring">JUnit和Spring的通用属性</a></h6>
<div class="paragraph">
<p>您可以使用系统属性或Spring配置属性来设置重复属性。下表显示了它们的名称及其默认值：</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">物业名称</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.minPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带存根的已启动WireMock的端口的最小值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.maxPort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带存根的已启动WireMock的端口的最大值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.repositoryRoot</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maven回购网址。如果为空，则调用本地Maven存储库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.classifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根工件的默认分类器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.stubsMode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类路径</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您想要获取和注册存根的方式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.ids</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要下载的常春藤符号存根数组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选的用户名，用于访问使用存根存储JAR的工具。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选密码，用于访问使用存根存储JAR的工具。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.stubsPerConsumer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">调成<code>true</code>如果要为每个使用者使用不同的存根，而不是为每个使用者注册所有存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.consumerName</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果要为每个使用者使用一个存根并想覆盖使用者名称，请更改此值。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="features-stub-runner-stub-runner-stub-ids"><a class="anchor" href="#features-stub-runner-stub-runner-stub-ids"></a> <a class="link" href="#features-stub-runner-stub-runner-stub-ids">存根转轮存根ID</a></h6>
<div class="paragraph">
<p>您可以将存根设置为在<code>stubrunner.ids</code>系统属性。他们使用以下模式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">groupId:artifactId:version:classifier:port</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意<code>version</code> ， <code>classifier</code>和<code>port</code>是可选的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您不提供<code>port</code> ，随机选择一个。</p>
</li>
<li>
<p>如果您不提供<code>classifier</code> ，使用默认值。（请注意，您可以通过以下方式传递空的分类器： <code>groupId:artifactId:version:</code> ）。</p>
</li>
<li>
<p>如果您不提供<code>version</code> ， 然后<code>+</code>通过，并下载最新的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>port</code>表示WireMock服务器的端口。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">从1.0.4版开始，您可以提供希望Stub Runner考虑的一系列版本。您可以<a href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges">在此处</a>阅读有关<a href="https://wiki.eclipse.org/Aether/New_and_Noteworthy#Version_Ranges">Aether版本控制范围的</a>更多信息。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="features-wiremock"><a class="anchor" href="#features-wiremock"></a> <a class="link" href="#features-wiremock">14.3.6。Spring Cloud Contract WireMock</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract WireMock模块使您可以在Spring Boot应用程序中使用<a href="https://github.com/tomakehurst/wiremock">WireMock</a> 。查看<a href="https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples">样本</a>以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>如果您有一个使用Tomcat作为嵌入式服务器的Spring Boot应用程序（默认情况下是<code>spring-boot-starter-web</code> ）， 你可以加<code>spring-cloud-starter-contract-stub-runner</code>到您的类路径并添加<code>@AutoConfigureWireMock</code>在测试中使用Wiremock。Wiremock作为存根服务器运行，您可以在测试中使用Java API或使用静态JSON声明来注册存根行为。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
public class WiremockForDocsTests {

    // A service that calls out over HTTP
    @Autowired
    private Service service;

    @Before
    public void setup() {
        this.service.setBase("http://localhost:"
                + this.environment.getProperty("wiremock.server.port"));
    }

    // Using the WireMock APIs in the normal way:
    @Test
    public void contextLoads() throws Exception {
        // Stubbing WireMock
        stubFor(get(urlEqualTo("/resource")).willReturn(aResponse()
                .withHeader("Content-Type", "text/plain").withBody("Hello World!")));
        // We're asserting if WireMock responded properly
        assertThat(this.service.go()).isEqualTo("Hello World!");
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在其他端口上启动存根服务器，请使用（例如）， <code>@AutoConfigureWireMock(port=9999)</code> 。对于随机端口，请使用值<code>0</code> 。可以在测试应用程序上下文中通过“ wiremock.server.port”属性绑定存根服务器端口。使用<code>@AutoConfigureWireMock</code>添加一个类型的bean <code>WiremockConfiguration</code>到您的测试应用程序上下文中，将其缓存在具有相同上下文的方法和类之间。Spring集成测试也是如此。另外，您可以注入类型为的bean <code>WireMockServer</code>进入您的测试。</p>
</div>
<div class="sect4">
<h5 id="features-wiremock-registering-stubs"><a class="anchor" href="#features-wiremock-registering-stubs"></a> <a class="link" href="#features-wiremock-registering-stubs">自动注册存根</a></h5>
<div class="paragraph">
<p>如果您使用<code>@AutoConfigureWireMock</code> ，它将从文件系统或类路径中注册WireMock JSON存根（默认情况下，从<code>file:src/test/resources/mappings</code> ）。您可以使用<code>stubs</code>批注中的属性，它可以是Ant样式的资源模式或目录。如果是目录， <code><strong>*/</strong>.json</code>附加。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWireMock(stubs="classpath:/stubs")
public class WiremockImportApplicationTests {

    @Autowired
    private Service service;

    @Test
    public void contextLoads() throws Exception {
        assertThat(this.service.go()).isEqualTo("Hello World!");
    }

}</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">实际上，WireMock总是从<code>src/test/resources/mappings</code> <strong>以及</strong> <code>stubs</code>属性。要更改此行为，您还可以指定文件根目录，如本文档下一节所述。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您使用Spring Cloud Contract的默认存根jar，则您的存根将存储在<code>/META-INF/group-id/artifact-id/versions/mappings/</code>夹。如果要从该位置，所有嵌入式JAR中注册所有存根，则可以使用以下语法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureWireMock(port = 0, stubs = "classpath*:/META-INF/**/mappings/**/*.json")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="features-wiremock-using-files"><a class="anchor" href="#features-wiremock-using-files"></a> <a class="link" href="#features-wiremock-using-files">使用文件指定存根实体</a></h5>
<div class="paragraph">
<p>WireMock可以从类路径或文件系统上的文件中读取响应正文。对于文件系统，您可以在JSON DSL中看到响应包含一个<code>bodyFileName</code>而不是（文字） <code>body</code> 。相对于根目录解析文件（默认情况下， <code>src/test/resources/__files</code> ）。要自定义此位置，您可以设置<code>files</code>中的属性<code>@AutoConfigureWireMock</code>父目录位置的注释（换句话说， <code>__files</code>是一个子目录）。您可以使用Spring资源表示法来引用<code>file:…​</code>要么<code>classpath:…​</code>位置。不支持通用网址。可以给出值列表-在这种情况下，WireMock会在需要查找响应正文时解析存在的第一个文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当您配置<code>files</code>根目录，它也会影响存根的自动加载，因为它们来自子目录中的根目录<code>mappings</code> 。的价值<code>files</code>对从显式加载的存根没有影响<code>stubs</code>属性。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="features-wiremock-junit-rule"><a class="anchor" href="#features-wiremock-junit-rule"></a> <a class="link" href="#features-wiremock-junit-rule">替代方案：使用JUnit规则</a></h5>
<div class="paragraph">
<p>要获得更常规的WireMock体验，可以使用JUnit <code>@Rules</code>启动和停止服务器。为此，请使用<code>WireMockSpring</code>便利班获得<code>Options</code>实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class WiremockForDocsClassRuleTests {

    // Start WireMock on some dynamic port
    // for some reason `dynamicPort()` is not working properly
    @ClassRule
    public static WireMockClassRule wiremock = new WireMockClassRule(
            WireMockSpring.options().dynamicPort());

    // A service that calls out over HTTP to wiremock's port
    @Autowired
    private Service service;

    @Before
    public void setup() {
        this.service.setBase("http://localhost:" + wiremock.port());
    }

    // Using the WireMock APIs in the normal way:
    @Test
    public void contextLoads() throws Exception {
        // Stubbing WireMock
        wiremock.stubFor(get(urlEqualTo("/resource")).willReturn(aResponse()
                .withHeader("Content-Type", "text/plain").withBody("Hello World!")));
        // We're asserting if WireMock responded properly
        assertThat(this.service.go()).isEqualTo("Hello World!");
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>@ClassRule</code>表示在运行了此类中的所有方法之后，服务器将关闭。</p>
</div>
</div>
<div class="sect4">
<h5 id="features-wiremock-relaxed-ssl"><a class="anchor" href="#features-wiremock-relaxed-ssl"></a> <a class="link" href="#features-wiremock-relaxed-ssl">放松模板的SSL验证</a></h5>
<div class="paragraph">
<p>通过WireMock，您可以将“安全”服务器与<code>https</code> URL协议。如果您的应用程序希望在集成测试中联系该存根服务器，它将发现SSL证书无效（自安装证书的常见问题）。最好的选择通常是重新配置客户端以使用<code>http</code> 。如果这不是一个选择，则可以要求Spring配置忽略SSL验证错误的HTTP客户端（当然，仅对测试如此）。</p>
</div>
<div class="paragraph">
<p>为了使此工作最小，您需要使用Spring Boot <code>RestTemplateBuilder</code>在您的应用程序中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
    return builder.build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你需要<code>RestTemplateBuilder</code>因为构建器是通过回调传递来初始化的，所以此时可以在客户端中设置SSL验证。如果您使用<code>@AutoConfigureWireMock</code>注释或存根运行器。如果您使用JUnit <code>@Rule</code>方法，您需要添加<code>@AutoConfigureHttpClient</code>注释也是如此，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest("app.baseUrl=https://localhost:6443")
@AutoConfigureHttpClient
public class WiremockHttpsServerApplicationTests {

    @ClassRule
    public static WireMockClassRule wiremock = new WireMockClassRule(
            WireMockSpring.options().httpsPort(6443));
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>spring-boot-starter-test</code> ，您的类路径上有Apache HTTP客户端，并且由<code>RestTemplateBuilder</code>并配置为忽略SSL错误。如果使用默认<code>java.net</code>客户端，则不需要注释（但不会造成伤害）。当前不支持其他客户端，但可能会在将来的版本中添加。</p>
</div>
<div class="paragraph">
<p>禁用自定义<code>RestTemplateBuilder</code> ，将<code>wiremock.rest-template-ssl-enabled</code>财产<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="features-wiremock-spring-mvc-mocks"><a class="anchor" href="#features-wiremock-spring-mvc-mocks"></a> <a class="link" href="#features-wiremock-spring-mvc-mocks">WireMock和Spring MVC模拟</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract提供了一个便利类，可以将JSON WireMock存根加载到Spring中<code>MockRestServiceServer</code> 。以下代码显示了一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
public class WiremockForDocsMockServerApplicationTests {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private Service service;

    @Test
    public void contextLoads() throws Exception {
        // will read stubs classpath
        MockRestServiceServer server = WireMockRestServiceServer.with(this.restTemplate)
                .baseUrl("https://example.org").stubs("classpath:/stubs/resource.json")
                .build();
        // We're asserting if WireMock responded properly
        assertThat(this.service.go()).isEqualTo("Hello World");
        server.verify();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>的<code>baseUrl</code>值将附加到所有模拟调用中，并且<code>stubs()</code>方法将存根路径资源模式作为参数。在前面的示例中，存根定义为<code>/stubs/resource.json</code>被加载到模拟服务器中。如果<code>RestTemplate</code>被要求参观<code><a href="https://example.org/" class="bare">example.org/</a></code> ，它将获得在该URL处声明的响应。可以指定多个存根模式，并且每个存根模式都可以是一个目录（对于所有的递归列表） <code>.json</code> ），固定的文件名（如上例所示）或Ant样式的模式。JSON格式是标准的WireMock格式，您可以在<a href="https://wiremock.org/docs/stubbing/">WireMock网站上</a>阅读该<a href="https://wiremock.org/docs/stubbing/">格式</a> 。</p>
</div>
<div class="paragraph">
<p>当前，Spring Cloud Contract Verifier支持Tomcat，Jetty和Undertow作为Spring Boot嵌入式服务器，而Wiremock本身对特定版本的Jetty（当前为9.2）具有“本机”支持。要使用本地Jetty，您需要添加本地Wiremock依赖项，并排除Spring Boot容器（如果有）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="features-build-tools"><a class="anchor" href="#features-build-tools"></a> <a class="link" href="#features-build-tools">14.3.7。构建工具集成</a></h4>
<div class="paragraph">
<p>您可以通过多种方式运行测试生成和存根执行。最常见的情况如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="maven-project.html">马文</a></p>
</li>
<li>
<p><a href="gradle-project.html">摇篮</a></p>
</li>
<li>
<p><a href="docker-project.html">码头工人</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="features-whats-next"><a class="anchor" href="#features-whats-next"></a> <a class="link" href="#features-whats-next">14.3.8。接下来要读什么</a></h4>
<div class="paragraph">
<p>如果您想了解有关本节讨论的任何类的更多信息，则可以<a href="https://github.com/spring-cloud/tree/master">直接</a>浏览<a href="https://github.com/spring-cloud/tree/master">源代码</a> 。如果您有特定问题，请参阅操作<a href="howto.html#howto">方法</a>部分。</p>
</div>
<div class="paragraph">
<p>如果您熟悉Spring Cloud Contract的核心功能，则可以继续阅读有关<a href="#advanced.adoc">Spring Cloud Contract的高级功能的信息</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="maven-project"><a class="anchor" href="#maven-project"></a> <a class="link" href="#maven-project">14.4。Maven项目</a></h3>
<div class="paragraph">
<p>要了解如何为Spring Cloud Contract Verifier设置Maven项目，请阅读以下部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#maven-add-plugin">添加Maven插件</a></p>
</li>
<li>
<p><a href="#maven-rest-assured">Maven和安心保障2.0</a></p>
</li>
<li>
<p><a href="#maven-snapshot-versions">对Maven使用快照和里程碑版本</a></p>
</li>
<li>
<p><a href="#maven-add-stubs">添加存根</a></p>
</li>
<li>
<p><a href="#maven-run-plugin">运行插件</a></p>
</li>
<li>
<p><a href="#maven-configure-plugin">配置插件</a></p>
</li>
<li>
<p><a href="#maven-configuration-options">配置选项</a></p>
</li>
<li>
<p><a href="#maven-single-base">所有测试的单一基类</a></p>
</li>
<li>
<p><a href="#maven-different-base">对合同使用不同的基类</a></p>
</li>
<li>
<p><a href="#maven-invoking-generated-tests">调用生成的测试</a></p>
</li>
<li>
<p><a href="#maven-pushing-stubs-to-scm">将存根推送到SCM</a></p>
</li>
<li>
<p><a href="#maven-sts">Maven插件和STS</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您也可以在<a href="../../spring-cloud-contract-maven-plugin/index.html">此处</a>查看插件的文档。</p>
</div>
<div class="sect3">
<h4 id="maven-add-plugin"><a class="anchor" href="#maven-add-plugin"></a> <a class="link" href="#maven-add-plugin">14.4.1。添加Maven插件</a></h4>
<div class="paragraph">
<p>以类似于以下方式添加Spring Cloud Contract BOM：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud-release.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，添加<code>Spring Cloud Contract Verifier</code> Maven插件，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">            <plugin>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                <version>${spring-cloud-contract.version}</version>
                <extensions>true</extensions>
                <configuration>
                    <packageWithBaseClasses>com.example.fraud</packageWithBaseClasses>
<!--                    <convertToYaml>true</convertToYaml>-->
                </configuration>
                <!-- if additional dependencies are needed e.g. for Pact -->
                <dependencies>
                    <dependency>
                        <groupId>org.springframework.cloud</groupId>
                        <artifactId>spring-cloud-contract-pact</artifactId>
                        <version>${spring-cloud-contract.version}</version>
                    </dependency>
                </dependencies>
            </plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以在spring-cloud-contract-maven-plugin / index.html [Spring Cloud Contract Maven插件文档]中阅读更多内容。</p>
</div>
<div class="paragraph">
<p>有时，无论选择哪种IDE，您都可以看到<code>target/generated-test-source</code>文件夹在IDE的类路径上不可见。为了确保它始终存在，您可以将以下条目添加到您的<code>pom.xml</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>build-helper-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>add-source</id>
                        <phase>generate-test-sources</phase>
                        <goals>
                            <goal>add-test-source</goal>
                        </goals>
                        <configuration>
                            <sources>
                                <source>${project.build.directory}/generated-test-sources/contracts/</source>
                            </sources>
                        </configuration>
                    </execution>
                </executions>
            </plugin></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-rest-assured"><a class="anchor" href="#maven-rest-assured"></a> <a class="link" href="#maven-rest-assured">14.4.2。Maven和安心保障2.0</a></h4>
<div class="paragraph">
<p>默认情况下，Rest Assured 3.x被添加到类路径中。但是，可以通过将其添加到插件类路径中来使用Rest Assured 2.x，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <packageWithBaseClasses>com.example</packageWithBaseClasses>
    </configuration>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-contract-verifier</artifactId>
            <version>${spring-cloud-contract.version}</version>
        </dependency>
        <dependency>
           <groupId>com.jayway.restassured</groupId>
           <artifactId>rest-assured</artifactId>
           <version>2.5.0</version>
           <scope>compile</scope>
        </dependency>
        <dependency>
           <groupId>com.jayway.restassured</groupId>
           <artifactId>spring-mock-mvc</artifactId>
           <version>2.5.0</version>
           <scope>compile</scope>
        </dependency>
    </dependencies>
</plugin>

<dependencies>
    <!-- all dependencies -->
    <!-- you can exclude rest-assured from spring-cloud-contract-verifier -->
    <dependency>
       <groupId>com.jayway.restassured</groupId>
       <artifactId>rest-assured</artifactId>
       <version>2.5.0</version>
       <scope>test</scope>
    </dependency>
    <dependency>
       <groupId>com.jayway.restassured</groupId>
       <artifactId>spring-mock-mvc</artifactId>
       <version>2.5.0</version>
       <scope>test</scope>
    </dependency>
</dependencies></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，该插件会自动看到类路径中存在Rest Assured 2.x，并相应地修改了导入。</p>
</div>
</div>
<div class="sect3">
<h4 id="maven-snapshot-versions"><a class="anchor" href="#maven-snapshot-versions"></a> <a class="link" href="#maven-snapshot-versions">14.4.3。对Maven使用快照和里程碑版本</a></h4>
<div class="paragraph">
<p>要使用Snapshot和Milestone版本，必须将以下部分添加到您的<code>pom.xml</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><repositories>
    <repository>
        <id>spring-snapshots</id>
        <name>Spring Snapshots</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-releases</id>
        <name>Spring Releases</name>
        <url>https://repo.spring.io/release</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
<pluginRepositories>
    <pluginRepository>
        <id>spring-snapshots</id>
        <name>Spring Snapshots</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </pluginRepository>
    <pluginRepository>
        <id>spring-releases</id>
        <name>Spring Releases</name>
        <url>https://repo.spring.io/release</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </pluginRepository>
</pluginRepositories></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-add-stubs"><a class="anchor" href="#maven-add-stubs"></a> <a class="link" href="#maven-add-stubs">14.4.4。添加存根</a></h4>
<div class="paragraph">
<p>默认情况下，Spring Cloud Contract Verifier会在<code>src/test/resources/contracts</code>目录。包含存根定义的目录被视为类名，每个存根定义均被视为单个测试。我们假定它至少包含一个目录用作测试类名称。如果嵌套目录有多个级别，则将最后一个嵌套目录用作包名称。考虑以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种结构下，Spring Cloud Contract Verifier将创建一个名为<code>defaultBasePackage.MyService</code>有两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shouldCreateUser()</code></p>
</li>
<li>
<p><code>shouldReturnUser()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="maven-run-plugin"><a class="anchor" href="#maven-run-plugin"></a> <a class="link" href="#maven-run-plugin">14.4.5。运行插件</a></h4>
<div class="paragraph">
<p>的<code>generateTests</code>分配插件目标以在称为的阶段中调用<code>generate-test-sources</code> 。如果您希望它成为构建过程的一部分，则无需执行任何操作。如果您只想生成测试，请调用<code>generateTests</code>目标。</p>
</div>
<div class="paragraph">
<p>如果您想通过Maven运行存根，则足以调用<code>run</code>存根作为目标运行<code>spring.cloud.contract.verifier.stubs</code>系统属性如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>mvn org.springframework.cloud:spring-cloud-contract-maven-plugin:run \ -Dspring.cloud.contract.verifier.stubs =“ com.acme：service-name”</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-configure-plugin"><a class="anchor" href="#maven-configure-plugin"></a> <a class="link" href="#maven-configure-plugin">14.4.6。配置插件</a></h4>
<div class="paragraph">
<p>要更改默认配置，您可以添加一个<code>configuration</code>插件定义或<code>execution</code>定义如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <executions>
        <execution>
            <goals>
                <goal>convert</goal>
                <goal>generateStubs</goal>
                <goal>generateTests</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <basePackageForTests>org.springframework.cloud.verifier.twitter.place</basePackageForTests>
        <baseClassForTests>org.springframework.cloud.verifier.twitter.place.BaseMockMvcSpec</baseClassForTests>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-configuration-options"><a class="anchor" href="#maven-configuration-options"></a> <a class="link" href="#maven-configuration-options">14.4.7。配置选项</a></h4>
<div class="ulist">
<ul>
<li>
<p><code>testMode</code> ：定义验收测试的模式。默认情况下，模式为<code>MockMvc</code> ，它基于Spring的MockMvc。您也可以将其更改为<code>WebTestClient</code> ， <code>JaxRsClient</code> ， 要么<code>Explicit</code> （用于实际的HTTP调用）。</p>
</li>
<li>
<p><code>basePackageForTests</code> ：指定所有生成的测试的基本软件包。如果未设置，则从<code>baseClassForTests</code>和从<code>packageWithBaseClasses</code> 。如果未设置这些值，则将值设置为<code>org.springframework.cloud.contract.verifier.tests</code> 。</p>
</li>
<li>
<p><code>ruleClassForTests</code> ：指定应添加到生成的测试类的规则。</p>
</li>
<li>
<p><code>baseClassForTests</code> ：为所有生成的测试创建基类。默认情况下，如果使用Spock类，则该类为<code>spock.lang.Specification</code> 。</p>
</li>
<li>
<p>contractDirectory：指定一个目录，其中包含用Groovyn DSL编写的合同。默认目录是<code>/src/test/resources/contracts</code> 。</p>
</li>
<li>
<p><code>generatedTestSourcesDir</code> ：指定应放置从Groovy DSL生成的测试的测试源目录。默认情况下，其值为<code>$buildDir/generated-test-sources/contracts</code> 。</p>
</li>
<li>
<p><code>generatedTestResourcesDir</code> ：为生成的测试所使用的资源指定测试资源目录。</p>
</li>
<li>
<p><code>testFramework</code> ：指定要使用的目标测试框架。目前，Spock是JUnit 4（ <code>TestFramework.JUNIT</code> ），并支持JUnit 5，而JUnit 4是默认框架。</p>
</li>
<li>
<p><code>packageWithBaseClasses</code> ：定义所有基类所在的包。此设置优先于<code>baseClassForTests</code> 。约定是这样的，如果您根据（例如）有合同<code>src/test/resources/contract/foo/bar/baz/</code>并设置<code>packageWithBaseClasses</code>财产<code>com.example.base</code> ，Spring Cloud Contract Verifier假设存在一个<code>BarBazBase</code>下课<code>com.example.base</code>包。换句话说，系统采用包的最后两个部分（如果存在），并与<code>Base</code>作为后缀。</p>
</li>
<li>
<p><code>baseClassMappings</code> ：指定提供以下内容的基类映射的列表<code>contractPackageRegex</code> （根据合同所在的包检查），以及<code>baseClassFQN</code> （映射到匹配合同的基类的完全限定名称）。例如，如果您根据<code>src/test/resources/contract/foo/bar/baz/</code>并映射<code>.* → com.example.base.BaseClass</code>属性，从这些合同生成的测试类将扩展<code>com.example.base.BaseClass</code> 。此设置优先于<code>packageWithBaseClasses</code>和<code>baseClassForTests</code> 。</p>
</li>
<li>
<p><code>contractsProperties</code> ：包含要传递给Spring Cloud Contract组件的属性的映射。这些属性可能由（例如）内置或自定义存根下载器使用。</p>
</li>
<li>
<p><code>failOnNoContracts</code> ：启用后，如果未找到任何合同，将引发异常。默认为<code>true</code> 。</p>
</li>
<li>
<p><code>failOnInProgress</code> ：如果设置为true，则如果找到任何正在进行的合同，则将中断构建。在生产者方面，您需要明确说明您正在执行合同的事实，并考虑到可能在消费者方面导致错误的肯定测试执行结果。默认为<code>true</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果要从Maven存储库下载合同定义，则可以使用以下选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>contractDependency</code> ：包含所有打包合同的合同依赖关系。</p>
</li>
<li>
<p><code>contractsPath</code> ：包含打包合同的JAR中具体合同的路径。默认为<code>groupid/artifactid</code>哪里<code>gropuid</code>斜线分隔。</p>
</li>
<li>
<p><code>contractsMode</code> ：选择找到和注册存根的模式。</p>
</li>
<li>
<p><code>deleteStubsAfterTest</code> ：如果设置为<code>false</code>不会从临时目录中删除任何下载的合同。</p>
</li>
<li>
<p><code>contractsRepositoryUrl</code> ：包含具有合同的工件的资源库的URL。如果未提供，请使用当前的Maven。</p>
</li>
<li>
<p><code>contractsRepositoryUsername</code> ：用于通过合同连接到仓库的用户名。</p>
</li>
<li>
<p><code>contractsRepositoryPassword</code> ：用于通过合同连接到仓库的密码。</p>
</li>
<li>
<p><code>contractsRepositoryProxyHost</code> ：用于通过合同连接到仓库的代理主机。</p>
</li>
<li>
<p><code>contractsRepositoryProxyPort</code> ：用于通过合同连接到仓库的代理端口。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们仅缓存非快照的显式提供的版本（例如<code>+</code>要么<code>1.0.0.BUILD-SNAPSHOT</code>不要被缓存）。默认情况下，此功能处于打开状态。</p>
</div>
<div class="paragraph">
<p>以下列表描述了您可以在插件中打开的实验性功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>convertToYaml</code> ：将所有DSL转换为声明性YAML格式。当您在Groovy DSL中使用外部库时，这可能非常有用。通过启用此功能（将其设置为<code>true</code> ），则无需在使用者端添加库依赖项。</p>
</li>
<li>
<p><code>assertJsonSize</code> ：您可以在生成的测试中检查JSON数组的大小。默认情况下禁用此功能。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="maven-single-base"><a class="anchor" href="#maven-single-base"></a> <a class="link" href="#maven-single-base">14.4.8。所有测试的单一基类</a></h4>
<div class="paragraph">
<p>在默认情况下使用Spring Cloud Contract Verifier时（ <code>MockMvc</code> ），则需要为所有生成的验收测试创建基本规范。在此类中，您需要指向一个端点，该端点应进行验证。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package org.mycompany.tests

import org.mycompany.ExampleSpringController
import com.jayway.restassured.module.mockmvc.RestAssuredMockMvc
import spock.lang.Specification

class MvcSpec extends Specification {
  def setup() {
   RestAssuredMockMvc.standaloneSetup(new ExampleSpringController())
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以根据需要设置整个上下文，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.restassured.module.mockmvc.RestAssuredMockMvc;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.context.WebApplicationContext;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, classes = SomeConfig.class, properties="some=property")
public abstract class BaseTestClass {

    @Autowired
    WebApplicationContext context;

    @Before
    public void setup() {
        RestAssuredMockMvc.webAppContextSetup(this.context);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>EXPLICIT</code>模式下，您可以使用基类来初始化整个测试的应用程序，类似于您在常规集成测试中可能执行的操作。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.restassured.RestAssured;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.context.WebApplicationContext;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, classes = SomeConfig.class, properties="some=property")
public abstract class BaseTestClass {

    @LocalServerPort
    int port;

    @Before
    public void setup() {
        RestAssured.baseURI = "http://localhost:" + this.port;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>JAXRSCLIENT</code>模式，此基类还应包含一个<code>protected WebTarget webTarget</code>领域。目前，测试JAX-RS API的唯一方法是启动Web服务器。</p>
</div>
</div>
<div class="sect3">
<h4 id="maven-different-base"><a class="anchor" href="#maven-different-base"></a> <a class="link" href="#maven-different-base">14.4.9。对合同使用不同的基类</a></h4>
<div class="paragraph">
<p>如果合同之间的基类不同，则可以告诉Spring Cloud Contract插件应通过自动生成的测试扩展哪个类。您有两种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>遵循惯例，为<code>packageWithBaseClasses</code></p>
</li>
<li>
<p>提供显式映射<code>baseClassMappings</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="by-convention"><a class="anchor" href="#by-convention"></a> <a class="link" href="#by-convention">按照惯例</a></h5>
<div class="paragraph">
<p>约定是，例如，如果您根据（例如） <code>src/test/resources/contract/foo/bar/baz/</code>并设置<code>packageWithBaseClasses</code>财产<code>com.example.base</code> ，则Spring Cloud Contract Verifier假设存在一个<code>BarBazBase</code>下课<code>com.example.base</code>包。换句话说，系统将获取程序包的最后两个部分（如果存在），并使用<code>Base</code>后缀。此规则优先于<code>baseClassForTests</code> 。以下示例显示了它如何在<code>contracts</code>关闭：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <configuration>
        <packageWithBaseClasses>hello</packageWithBaseClasses>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="by-mapping"><a class="anchor" href="#by-mapping"></a> <a class="link" href="#by-mapping">通过映射</a></h5>
<div class="paragraph">
<p>您可以将合同包的正则表达式手动映射到匹配合同的基类的标准名称。您必须提供一个名为<code>baseClassMappings</code>包括<code>baseClassMapping</code>每个都带有一个对象<code>contractPackageRegex</code>至<code>baseClassFQN</code>映射。考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <configuration>
        <baseClassForTests>com.example.FooBase</baseClassForTests>
        <baseClassMappings>
            <baseClassMapping>
                <contractPackageRegex>.*com.*</contractPackageRegex>
                <baseClassFQN>com.example.TestBase</baseClassFQN>
            </baseClassMapping>
        </baseClassMappings>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设您在以下两个地点有合同：* <code>src/test/resources/contract/com/</code> *<code>src/test/resources/contract/foo/</code></p>
</div>
<div class="paragraph">
<p>通过提供<code>baseClassForTests</code> ，如果映射不成功，我们会有一个退路。（您还可以提供<code>packageWithBaseClasses</code>作为备用。）这样，从<code>src/test/resources/contract/com/</code>合同扩展了<code>com.example.ComBase</code> ，而其余测试将扩展<code>com.example.FooBase</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-invoking-generated-tests"><a class="anchor" href="#maven-invoking-generated-tests"></a> <a class="link" href="#maven-invoking-generated-tests">14.4.10。调用生成的测试</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract Maven插件在名为的目录中生成验证代码<code>/generated-test-sources/contractVerifier</code>并将此目录附加到<code>testCompile</code>目标。</p>
</div>
<div class="paragraph">
<p>对于Groovy Spock代码，可以使用以下代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.codehaus.gmavenplus</groupId>
    <artifactId>gmavenplus-plugin</artifactId>
    <version>1.5</version>
    <executions>
        <execution>
            <goals>
                <goal>testCompile</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <testSources>
            <testSource>
                <directory>${project.basedir}/src/test/groovy</directory>
                <includes>
                    <include>**/*.groovy</include>
                </includes>
            </testSource>
            <testSource>
                <directory>${project.build.directory}/generated-test-sources/contractVerifier</directory>
                <includes>
                    <include>**/*.groovy</include>
                </includes>
            </testSource>
        </testSources>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了确保提供方符合已定义的合同，您需要调用<code>mvn generateTest test</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="maven-pushing-stubs-to-scm"><a class="anchor" href="#maven-pushing-stubs-to-scm"></a> <a class="link" href="#maven-pushing-stubs-to-scm">14.4.11。将存根推送到SCM</a></h4>
<div class="paragraph">
<p>如果使用SCM（源代码管理管理）存储库保留合同和存根，则可能需要自动化将存根推入存储库的步骤。为此，您可以添加<code>pushStubsToScm</code>目标。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- Base class mappings etc. -->

        <!-- We want to pick contracts from a Git repository -->
        <contractsRepositoryUrl>git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git</contractsRepositoryUrl>

        <!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts -->
        <contractDependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>${project.artifactId}</artifactId>
            <version>${project.version}</version>
        </contractDependency>

        <!-- The contracts mode can't be classpath -->
        <contractsMode>REMOTE</contractsMode>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal -->
                <goal>pushStubsToScm</goal>
            </goals>
        </execution>
    </executions>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在“ <a href="#scm-stub-downloader">使用SCM存根下载器”下</a> ，您可以找到所有可以通过<code><configuration><contractProperties></code>映射，系统属性或环境变量。</p>
</div>
</div>
<div class="sect3">
<h4 id="maven-sts"><a class="anchor" href="#maven-sts"></a> <a class="link" href="#maven-sts">14.4.12。Maven插件和STS</a></h4>
<div class="paragraph">
<p>下图显示了使用STS时可能会看到的异常：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.github.com/spring-cloud/master/docs/src/main/asciidoc/images/sts_exception.png" alt="STS异常">
</div>
</div>
<div class="paragraph">
<p>当您单击错误标记时，您应该看到类似以下的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"> plugin:1.1.0.M1:convert:default-convert:process-test-resources) org.apache.maven.plugin.PluginExecutionException: Execution default-convert of goal org.springframework.cloud:spring-
 cloud-contract-maven-plugin:1.1.0.M1:convert failed. at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:145) at
 org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:331) at org.eclipse.m2e.core.internal.embedder.MavenImpl$11.call(MavenImpl.java:1362) at
...
 org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) Caused by: java.lang.NullPointerException at
 org.eclipse.m2e.core.internal.builder.plexusbuildapi.EclipseIncrementalBuildContext.hasDelta(EclipseIncrementalBuildContext.java:53) at
 org.sonatype.plexus.build.incremental.ThreadBuildContext.hasDelta(ThreadBuildContext.java:59) at</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了解决此问题，请在您的<code>pom.xml</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><build>
    <pluginManagement>
        <plugins>
            <!--This plugin's configuration is used to store Eclipse m2e settings
                only. It has no influence on the Maven build itself. -->
            <plugin>
                <groupId>org.eclipse.m2e</groupId>
                <artifactId>lifecycle-mapping</artifactId>
                <version>1.0.0</version>
                <configuration>
                    <lifecycleMappingMetadata>
                        <pluginExecutions>
                             <pluginExecution>
                                <pluginExecutionFilter>
                                    <groupId>org.springframework.cloud</groupId>
                                    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                                    <versionRange>[1.0,)</versionRange>
                                    <goals>
                                        <goal>convert</goal>
                                    </goals>
                                </pluginExecutionFilter>
                                <action>
                                    <execute />
                                </action>
                             </pluginExecution>
                        </pluginExecutions>
                    </lifecycleMappingMetadata>
                </configuration>
            </plugin>
        </plugins>
    </pluginManagement>
</build></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="maven-plugin-with-spock-tests"><a class="anchor" href="#maven-plugin-with-spock-tests"></a> <a class="link" href="#maven-plugin-with-spock-tests">14.4.13。具有Spock测试的Maven插件</a></h4>
<div class="paragraph">
<p>您可以选择<a href="http://spockframework.org/">Spock框架</a>来使用Maven和Gradle创建和运行自动生成的合同验证测试。但是，尽管使用Gradle很简单，但是在Maven中，您将需要一些其他设置才能使测试正确编译和执行。</p>
</div>
<div class="paragraph">
<p>首先，您必须使用诸如<a href="https://github.com/groovy/GMavenPlus">GMavenPlus</a>插件之<a href="https://github.com/groovy/GMavenPlus">类的</a>插件将Groovy添加到您的项目中。在GMavenPlus插件中，您需要显式设置测试源，包括定义基本测试类的路径和添加了生成的合同测试的路径。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.codehaus.gmavenplus</groupId>
    <artifactId>gmavenplus-plugin</artifactId>
    <version>1.6.1</version>
    <executions>
        <execution>
            <goals>
                <goal>compileTests</goal>
                <goal>addTestSources</goal>
            </goals>
        </execution>
    </executions>
    <configuration>
        <testSources>
            <testSource>
                <directory>${project.basedir}/src/test/groovy</directory>
                <includes>
                    <include>**/*.groovy</include>
                </includes>
            </testSource>
            <testSource>
                <directory>
                    ${project.basedir}/target/generated-test-sources/contracts/com/example/beer
                </directory>
                <includes>
                    <include>**/*.groovy</include>
                    <include>**/*.gvy</include>
                </includes>
            </testSource>
        </testSources>
    </configuration>
    <dependencies>
        <dependency>
            <groupId>org.codehaus.groovy</groupId>
            <artifactId>groovy-all</artifactId>
            <version>${groovy.version}</version>
            <scope>runtime</scope>
            <type>pom</type>
        </dependency>
    </dependencies></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您坚持Spock约定以测试类名结尾<code>Spec</code> ，您还需要调整Maven Surefire插件设置，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <includes>
            <include>**/*Test.java</include>
            <include>**/*Spec.java</include>
        </includes>
        <failIfNoTests>true</failIfNoTests>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gradle-project"><a class="anchor" href="#gradle-project"></a> <a class="link" href="#gradle-project">14.5。摇篮项目</a></h3>
<div class="paragraph">
<p>要了解如何为Spring Cloud Contract Verifier设置Gradle项目，请阅读以下部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#gradle-prerequisites">先决条件</a></p>
</li>
<li>
<p><a href="#gradle-add-gradle-plugin">添加具有依赖项的Gradle插件</a></p>
</li>
<li>
<p><a href="#gradle-and-rest-assured">Gradle and Rest Assured 2.0</a></p>
</li>
<li>
<p><a href="#gradle-snapshot-versions">Gradle的快照版本</a></p>
</li>
<li>
<p><a href="#gradle-add-stubs">添加存根</a></p>
</li>
<li>
<p><a href="#gradle-default-setup">默认设置</a></p>
</li>
<li>
<p><a href="#gradle-configure-plugin">配置插件</a></p>
</li>
<li>
<p><a href="#gradle-configuration-options">配置选项</a></p>
</li>
<li>
<p><a href="#gradle-single-base-class">所有测试的单一基类</a></p>
</li>
<li>
<p><a href="#gradle-different-base-classes">合同的不同基本类别</a></p>
</li>
<li>
<p><a href="#gradle-invoking-generated-tests">调用生成的测试</a></p>
</li>
<li>
<p><a href="#gradle-pushing-stubs-to-scm">将存根推送到SCM</a></p>
</li>
<li>
<p><a href="#gradle-consumer">消费者方的Spring Cloud Contract Verifier</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="gradle-prerequisites"><a class="anchor" href="#gradle-prerequisites"></a> <a class="link" href="#gradle-prerequisites">14.5.1。先决条件</a></h4>
<div class="paragraph">
<p>为了在WireMock中使用Spring Cloud Contract Verifier，您必须使用Gradle或Maven插件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">如果要在项目中使用Spock，则必须单独添加<code>spock-core</code>和<code>spock-spring</code>模块。有关<a href="https://spockframework.github.io/">更多信息，</a>请参见<a href="https://spockframework.github.io/">Spock的文档。</a>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="gradle-add-gradle-plugin"><a class="anchor" href="#gradle-add-gradle-plugin"></a> <a class="link" href="#gradle-add-gradle-plugin">14.5.2。添加具有依赖项的Gradle插件</a></h4>
<div class="paragraph">
<p>要添加具有依赖项的Gradle插件，可以使用类似于以下代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">插件DSL GA版本</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">// build.gradle
plugins {
  id "groovy"
  // this will work only for GA versions of Spring Cloud Contract
  id "org.springframework.cloud.contract" version "${GAVerifierVersion}"
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-contract-dependencies:${GAVerifierVersion}"
    }
}

dependencies {
    testCompile "org.codehaus.groovy:groovy-all:${groovyVersion}"
    // example with adding Spock core and Spock Spring
    testCompile "org.spockframework:spock-core:${spockVersion}"
    testCompile "org.spockframework:spock-spring:${spockVersion}"
    testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">插件DSL非GA版本</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">// settings.gradle
pluginManagement {
    plugins {
        id "org.springframework.cloud.contract" version "${verifierVersion}"
    }
    repositories {
        // to pick from local .m2
        mavenLocal()
        // for snapshots
        maven { url "https://repo.spring.io/snapshot" }
        // for milestones
        maven { url "https://repo.spring.io/milestone" }
        // for GA versions
        gradlePluginPortal()
    }
}

// build.gradle
plugins {
  id "groovy"
  id "org.springframework.cloud.contract"
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-contract-dependencies:${verifierVersion}"
    }
}

dependencies {
    testCompile "org.codehaus.groovy:groovy-all:${groovyVersion}"
    // example with adding Spock core and Spock Spring
    testCompile "org.spockframework:spock-core:${spockVersion}"
    testCompile "org.spockframework:spock-spring:${spockVersion}"
    testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">旧版插件应用</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">// build.gradle
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"
        classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"
        // here you can also pass additional dependencies such as Pact or Kotlin spec e.g.:
        // classpath "org.springframework.cloud:spring-cloud-contract-spec-kotlin:${verifier_version}"
    }
}

apply plugin: 'groovy'
apply plugin: 'spring-cloud-contract'

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-contract-dependencies:${verifier_version}"
    }
}

dependencies {
    testCompile "org.codehaus.groovy:groovy-all:${groovyVersion}"
    // example with adding Spock core and Spock Spring
    testCompile "org.spockframework:spock-core:${spockVersion}"
    testCompile "org.spockframework:spock-spring:${spockVersion}"
    testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-and-rest-assured"><a class="anchor" href="#gradle-and-rest-assured"></a> <a class="link" href="#gradle-and-rest-assured">14.5.3。Gradle and Rest Assured 2.0</a></h4>
<div class="paragraph">
<p>默认情况下，Rest Assured 3.x被添加到类路径中。但是，要使用Rest Assured 2.x，可以将其添加到插件的classpath中，如下清单所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "org.springframework.boot:spring-boot-gradle-plugin:${springboot_version}"
        classpath "org.springframework.cloud:spring-cloud-contract-gradle-plugin:${verifier_version}"
        classpath "com.jayway.restassured:rest-assured:2.5.0"
        classpath "com.jayway.restassured:spring-mock-mvc:2.5.0"
    }
}

depenendencies {
    // all dependencies
    // you can exclude rest-assured from spring-cloud-contract-verifier
    testCompile "com.jayway.restassured:rest-assured:2.5.0"
    testCompile "com.jayway.restassured:spring-mock-mvc:2.5.0"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，该插件会自动看到类路径中存在Rest Assured 2.x，并相应地修改了导入。</p>
</div>
</div>
<div class="sect3">
<h4 id="gradle-snapshot-versions"><a class="anchor" href="#gradle-snapshot-versions"></a> <a class="link" href="#gradle-snapshot-versions">14.5.4。Gradle的快照版本</a></h4>
<div class="paragraph">
<p>您可以将其他快照存储库添加到您的<code>build.gradle</code>使用快照版本，快照版本在每次成功构建后都会自动上载，如下清单所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">/*
 We need to use the [buildscript {}] section when we have to modify
 the classpath for the plugins. If that's not the case this section
 can be skipped.

 If you don't need to modify the classpath (e.g. add a Pact dependency),
 then you can just set the [pluginManagement {}] section in [settings.gradle] file.

 // settings.gradle
 pluginManagement {
    repositories {
        // for snapshots
        maven {url "https://repo.spring.io/snapshot"}
        // for milestones
        maven {url "https://repo.spring.io/milestone"}
        // for GA versions
        gradlePluginPortal()
    }
 }

 */
buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url "https://repo.spring.io/snapshot" }
        maven { url "https://repo.spring.io/milestone" }
        maven { url "https://repo.spring.io/release" }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-add-stubs"><a class="anchor" href="#gradle-add-stubs"></a> <a class="link" href="#gradle-add-stubs">14.5.5。添加存根</a></h4>
<div class="paragraph">
<p>默认情况下，Spring Cloud Contract Verifier会在<code>src/test/resources/contracts</code>目录。</p>
</div>
<div class="paragraph">
<p>包含存根定义的目录被视为类名，每个存根定义均被视为单个测试。 Spring Cloud Contract Verifier假定它至少包含将用作测试类名称的一级目录。如果存在多个嵌套目录，则使用除最后一个嵌套目录以外的所有目录作为包名。考虑以下结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">src/test/resources/contracts/myservice/shouldCreateUser.groovy
src/test/resources/contracts/myservice/shouldReturnUser.groovy</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>给定上述结构，Spring Cloud Contract Verifier将创建一个名为<code>defaultBasePackage.MyService</code>有两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shouldCreateUser()</code></p>
</li>
<li>
<p><code>shouldReturnUser()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="gradle-run-plugin"><a class="anchor" href="#gradle-run-plugin"></a> <a class="link" href="#gradle-run-plugin">14.5.6。运行插件</a></h4>
<div class="paragraph">
<p>该插件会注册自己，以便在<code>check</code>任务。如果您希望它成为构建过程的一部分，则无需执行其他任何操作。如果您只想生成测试，请调用<code>generateContractTests</code>任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="gradle-default-setup"><a class="anchor" href="#gradle-default-setup"></a> <a class="link" href="#gradle-default-setup">14.5.7。默认设置</a></h4>
<div class="paragraph">
<p>默认的Gradle插件设置创建了以下构建的Gradle部分（以伪代码）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    testFramework ='JUNIT'
    testMode = 'MockMvc'
    generatedTestSourcesDir = project.file("${project.buildDir}/generated-test-sources/contracts")
    generatedTestResourcesDir = project.file("${project.buildDir}/generated-test-resources/contracts")
    contractsDslDir = project.file("${project.rootDir}/src/test/resources/contracts")
    basePackageForTests = 'org.springframework.cloud.verifier.tests'
    stubsOutputDir = project.file("${project.buildDir}/stubs")
    sourceSet = null

    // the following properties are used when you want to provide where the JAR with contract lays
    contractDependency {
        stringNotation = ''
    }
    contractsPath = ''
    contractsWorkOffline = false
    contractRepository {
        cacheDownloadedContracts(true)
    }
}

tasks.create(type: Jar, name: 'verifierStubsJar', dependsOn: 'generateClientStubs') {
    baseName = project.name
    classifier = contracts.stubsSuffix
    from contractVerifier.stubsOutputDir
}

project.artifacts {
    archives task
}

tasks.create(type: Copy, name: 'copyContracts') {
    from contracts.contractsDslDir
    into contracts.stubsOutputDir
}

verifierStubsJar.dependsOn 'copyContracts'

publishing {
    publications {
        stubs(MavenPublication) {
            artifactId project.name
            artifact verifierStubsJar
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-configure-plugin"><a class="anchor" href="#gradle-configure-plugin"></a> <a class="link" href="#gradle-configure-plugin">14.5.8。配置插件</a></h4>
<div class="paragraph">
<p>要更改默认配置，您可以添加一个<code>contracts</code>摘录到您的Gradle配置，如以下清单所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    testMode = 'MockMvc'
    baseClassForTests = 'org.mycompany.tests'
    generatedTestSourcesDir = project.file('src/generatedContract')
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-configuration-options"><a class="anchor" href="#gradle-configuration-options"></a> <a class="link" href="#gradle-configuration-options">14.5.9。配置选项</a></h4>
<div class="ulist">
<ul>
<li>
<p><code>testMode</code> ：定义验收测试的模式。默认情况下，该模式是MockMvc，它基于Spring的MockMvc。也可以将其更改为WebTestClient，JaxRsClient或Explicit（用于真正的HTTP调用）。</p>
</li>
<li>
<p><code>imports</code> ：创建一个带有导入的数组，该数组应包含在生成的测试中（例如， <code>['org.myorg.Matchers']</code> ）。默认情况下，它将创建一个空数组。</p>
</li>
<li>
<p><code>staticImports</code> ：使用静态导入创建一个数组，该数组应包含在生成的测试中（例如， <code>['org.myorg.Matchers.*']</code> ）。默认情况下，它将创建一个空数组。</p>
</li>
<li>
<p><code>basePackageForTests</code> ：指定所有生成的测试的基本软件包。如果未设置，则从<code>baseClassForTests</code>和从<code>packageWithBaseClasses</code> 。如果未设置这些值，则将值设置为<code>org.springframework.cloud.contract.verifier.tests</code> 。</p>
</li>
<li>
<p><code>baseClassForTests</code> ：为所有生成的测试创建基类。默认情况下，如果使用Spock类，则该类为<code>spock.lang.Specification</code> 。</p>
</li>
<li>
<p><code>packageWithBaseClasses</code> ：定义所有基类所在的包。此设置优先于<code>baseClassForTests</code> 。</p>
</li>
<li>
<p><code>baseClassMappings</code> ：显式将合同包映射到基类的FQN。此设置优先于<code>packageWithBaseClasses</code>和<code>baseClassForTests</code> 。</p>
</li>
<li>
<p><code>ruleClassForTests</code> ：指定应添加到生成的测试类的规则。</p>
</li>
<li>
<p><code>ignoredFiles</code> ：使用<code>Antmatcher</code>允许定义应跳过其处理的存根文件。默认情况下，它是一个空数组。</p>
</li>
<li>
<p><code>contractsDslDir</code> ：指定包含使用GroovyDSL编写的合同的目录。默认情况下，其值为<code>$rootDir/src/test/resources/contracts</code> 。</p>
</li>
<li>
<p><code>generatedTestSourcesDir</code> ：指定应放置从Groovy DSL生成的测试的测试源目录。默认情况下，其值为<code>$buildDir/generated-test-sources/contracts</code> 。</p>
</li>
<li>
<p><code>generatedTestResourcesDir</code> ：指定测试资源目录，应放置Groovy DSL生成的测试所使用的资源。默认情况下，其值为<code>$buildDir/generated-test-resources/contracts</code> 。</p>
</li>
<li>
<p><code>stubsOutputDir</code> ：指定应放置Groovy DSL生成的WireMock存根的目录。</p>
</li>
<li>
<p><code>testFramework</code> ：指定要使用的目标测试框架。目前，Spock是JUnit 4（ <code>TestFramework.JUNIT</code> ），并支持JUnit 5，而JUnit 4是默认框架。</p>
</li>
<li>
<p><code>contractsProperties</code> ：包含要传递给Spring Cloud Contract组件的属性的映射。这些属性可能由（例如）内置或自定义存根下载器使用。</p>
</li>
<li>
<p><code>sourceSet</code> ：存储合同的源集。如果未提供，将承担<code>test</code> （例如<code>project.sourceSets.test.java</code>对于JUnit或<code>project.sourceSets.test.groovy</code> Spock）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当您要指定包含合同的JAR的位置时，可以使用以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>contractDependency</code> ：指定提供的依赖关系<code>groupid:artifactid:version:classifier</code>坐标。您可以使用<code>contractDependency</code>关闭以进行设置。</p>
</li>
<li>
<p><code>contractsPath</code> ：指定jar的路径。如果下载了合同依存关系，则路径默认为<code>groupid/artifactid</code>哪里<code>groupid</code>斜线分隔。否则，它将在提供的目录下扫描合同。</p>
</li>
<li>
<p><code>contractsMode</code> ：指定下载合同的方式（JAR是否可以脱机使用，远程使用等）。</p>
</li>
<li>
<p><code>deleteStubsAfterTest</code> ：如果设置为<code>false</code> ，请勿从临时目录中删除任何下载的合同。</p>
</li>
<li>
<p><code>failOnNoContracts</code> ：启用后，如果未找到任何合同，将引发异常。默认为<code>true</code> 。</p>
</li>
<li>
<p><code>failOnInProgress</code> ：如果设置为true，则如果找到任何正在进行的合同，则将中断构建。在生产者方面，您需要明确说明您正在执行合同的事实，并考虑到可能在消费者方面导致错误的肯定测试执行结果。默认为<code>true</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有<code>contractRepository { …​ }</code>包含以下属性的闭包</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>repositoryUrl</code> ：带有合同定义的资源库的URL</p>
</li>
<li>
<p><code>username</code> ：存储库用户名</p>
</li>
<li>
<p><code>password</code> ：存储库密码</p>
</li>
<li>
<p><code>proxyPort</code> ：代理的端口</p>
</li>
<li>
<p><code>proxyHost</code> ：代理的主机</p>
</li>
<li>
<p><code>cacheDownloadedContracts</code> ：如果设置为<code>true</code>然后将缓存下载非快照合同工件的文件夹。默认为<code>true</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您还可以在插件中启用以下实验功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>convertToYaml</code> ：将所有DSL转换为声明性YAML格式。当您在Groovy DSL中使用外部库时，这可能非常有用。通过启用此功能（将其设置为<code>true</code> ），则无需在使用者端添加库依赖项。</p>
</li>
<li>
<p><code>assertJsonSize</code> ：您可以在生成的测试中检查JSON数组的大小。默认情况下禁用此功能。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="gradle-single-base-class"><a class="anchor" href="#gradle-single-base-class"></a> <a class="link" href="#gradle-single-base-class">14.5.10。所有测试的单一基类</a></h4>
<div class="paragraph">
<p>在默认的MockMvc中使用Spring Cloud Contract Verifier时，您需要为所有生成的验收测试创建基本规范。在此类中，您需要指向一个端点，该端点应进行验证。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">abstract class BaseMockMvcSpec extends Specification {

    def setup() {
        RestAssuredMockMvc.standaloneSetup(new PairIdController())
    }

    void isProperCorrelationId(Integer correlationId) {
        assert correlationId == 123456
    }

    void isEmpty(String value) {
        assert value == null
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用<code>Explicit</code>模式，您可以使用基类来初始化整个测试的应用程序，就像在常规集成测试中看到的那样。如果您使用<code>JAXRSCLIENT</code>模式，此基类还应包含一个<code>protected WebTarget webTarget</code>领域。现在，测试JAX-RS API的唯一选择是启动Web服务器。</p>
</div>
</div>
<div class="sect3">
<h4 id="gradle-different-base-classes"><a class="anchor" href="#gradle-different-base-classes"></a> <a class="link" href="#gradle-different-base-classes">14.5.11。合同的不同基本类别</a></h4>
<div class="paragraph">
<p>如果合同之间的基类不同，则可以告诉Spring Cloud Contract插件应通过自动生成的测试扩展哪个类。您有两种选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>遵循惯例，提供<code>packageWithBaseClasses</code></p>
</li>
<li>
<p>通过使用提供显式映射<code>baseClassMappings</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="by-convention-2"><a class="anchor" href="#by-convention-2"></a> <a class="link" href="#by-convention-2">按照惯例</a></h5>
<div class="paragraph">
<p>约定是这样的，如果您有一份合同（例如） <code>src/test/resources/contract/foo/bar/baz/</code>并设置<code>packageWithBaseClasses</code>财产<code>com.example.base</code> ，则Spring Cloud Contract Verifier假设存在一个<code>BarBazBase</code>下课<code>com.example.base</code>包。换句话说，系统将获取程序包的最后两个部分（如果存在），并使用<code>Base</code>后缀。此规则优先于<code>baseClassForTests</code> 。以下示例显示了它如何在<code>contracts</code>关闭：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">packageWithBaseClasses = 'com.example.base'</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="by-mapping-2"><a class="anchor" href="#by-mapping-2"></a> <a class="link" href="#by-mapping-2">通过映射</a></h5>
<div class="paragraph">
<p>您可以将合同包的正则表达式手动映射到匹配合同的基类的标准名称。您必须提供一个名为<code>baseClassMappings</code>包括<code>baseClassMapping</code>带一个物体<code>contractPackageRegex</code>至<code>baseClassFQN</code>映射。考虑以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">baseClassForTests = "com.example.FooBase"
baseClassMappings {
    baseClassMapping('.*/com/.*', 'com.example.ComBase')
    baseClassMapping('.*/bar/.*': 'com.example.BarBase')
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设您在以下目录中有合同：- <code>src/test/resources/contract/com/</code> --<code>src/test/resources/contract/foo/</code></p>
</div>
<div class="paragraph">
<p>通过提供<code>baseClassForTests</code> ，如果映射不成功，我们会有一个退路。（您也可以提供<code>packageWithBaseClasses</code>作为备用。）这样，从<code>src/test/resources/contract/com/</code>合同扩展了<code>com.example.ComBase</code> ，而其余测试将扩展<code>com.example.FooBase</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-invoking-generated-tests"><a class="anchor" href="#gradle-invoking-generated-tests"></a> <a class="link" href="#gradle-invoking-generated-tests">14.5.12。调用生成的测试</a></h4>
<div class="paragraph">
<p>为了确保提供方符合您定义的合同，您需要运行以下命令：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./gradlew generateContractTests test</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-pushing-stubs-to-scm"><a class="anchor" href="#gradle-pushing-stubs-to-scm"></a> <a class="link" href="#gradle-pushing-stubs-to-scm">14.5.13。将存根推送到SCM</a></h4>
<div class="paragraph">
<p>如果使用SCM存储库保留合同和存根，则可能需要自动化将存根推送到存储库的步骤。为此，您可以致电<code>pushStubsToScm</code>通过运行以下命令执行任务：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew pushStubsToScm</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在“ <a href="#scm-stub-downloader">使用SCM存根下载器”下，</a>您可以找到所有可以通过<code>contractsProperties</code>字段（例如， <code>contracts { contractsProperties = [foo:"bar"] }</code> ），通过<code>contractsProperties</code>方法（例如， <code>contracts { contractsProperties([foo:"bar"]) }</code> ），或通过系统属性或环境变量。</p>
</div>
</div>
<div class="sect3">
<h4 id="gradle-consumer"><a class="anchor" href="#gradle-consumer"></a> <a class="link" href="#gradle-consumer">14.5.14。消费者方的Spring Cloud Contract Verifier</a></h4>
<div class="paragraph">
<p>在消费服务中，您需要以与提供商相同的方式配置Spring Cloud Contract Verifier插件。如果您不想使用Stub Runner，则需要复制存储在<code>src/test/resources/contracts</code>并使用以下命令生成WireMock JSON存根：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./gradlew generateClientStubs</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>stubsOutputDir</code>必须设置选项以使存根生成工作。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果存在，则JSON存根可用于自动化测试中以使用服务。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">@ContextConfiguration(loader == SpringApplicationContextLoader, classes == Application)
class LoanApplicationServiceSpec extends Specification {

 @ClassRule
 @Shared
 WireMockClassRule wireMockRule == new WireMockClassRule()

 @Autowired
 LoanApplicationService sut

 def 'should successfully apply for loan'() {
   given:
    LoanApplication application =
            new LoanApplication(client: new Client(clientPesel: '12345678901'), amount: 123.123)
   when:
    LoanApplicationResult loanApplication == sut.loanApplication(application)
   then:
    loanApplication.loanApplicationStatus == LoanApplicationStatus.LOAN_APPLIED
    loanApplication.rejectionReason == null
 }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>LoanApplication</code>打电话给<code>FraudDetection</code>服务。该请求由配置有由Spring Cloud Contract Verifier生成的存根的WireMock服务器处理。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docker"><a class="anchor" href="#docker"></a> <a class="link" href="#docker">14.6。Docker项目</a></h3>
<div class="paragraph">
<p>在本节中，我们发布了<code>springcloud/spring-cloud-contract</code>包含用于生成测试并在其中运行测试的项目的Docker映像<code>EXPLICIT</code>模式针对正在运行的应用程序。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">的<code>EXPLICIT</code>模式意味着从合同生成的测试发送真实的请求，而不发送模拟的请求。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>我们还发布了<code>spring-cloud/spring-cloud-contract-stub-runner</code>启动独立版本的Stub Runner的Docker映像。</p>
</div>
<div class="sect3">
<h4 id="docker-intro"><a class="anchor" href="#docker-intro"></a> <a class="link" href="#docker-intro">14.6.1。Maven，JAR和二进制存储的简短介绍</a></h4>
<div class="paragraph">
<p>由于非JVM项目可以使用Docker映像，因此最好解释一下Spring Cloud Contract打包默认设置背后的基本术语。</p>
</div>
<div class="paragraph">
<p>以下定义的部分内容摘自<a href="https://maven.apache.org/glossary.html">Maven词汇表</a> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Project</code> ：Maven考虑项目。项目就是您构建的全部。这些项目遵循定义明确的“项目对象模型”。项目可以依赖于其他项目，在这种情况下，后者称为“依赖项”。一个项目可能与几个子项目一致。但是，这些子项目仍被视为项目。</p>
</li>
<li>
<p><code>Artifact</code> ：工件是项目产生或使用的东西。Maven为项目生成的工件示例包括JAR文件以及源和二进制发行版。每个工件都由组ID和组内唯一的工件ID唯一标识。</p>
</li>
<li>
<p><code>JAR</code> ：JAR表示Java ARchive。其格式基于ZIP文件格式。Spring Cloud Contract将合同和生成的存根打包在JAR文件中。</p>
</li>
<li>
<p><code>GroupId</code> ：组ID是项目的通用唯一标识符。虽然这通常只是项目名称（例如， <code>commons-collections</code> ），使用完全限定的包名称将其与其他具有类似名称的项目（例如， <code>org.apache.maven</code> ）。通常，当发布到工件管理器时， <code>GroupId</code>将斜杠分开并形成URL的一部分。例如，对于组ID为<code>com.example</code>和工件ID为<code>application</code> ，结果将是<code>/com/example/application/</code> 。</p>
</li>
<li>
<p><code>Classifier</code> ：Maven依赖项表示法如下所示： <code>groupId:artifactId:version:classifier</code> 。分类器是传递给依赖项的附加后缀-例如， <code>stubs</code>要么<code>sources</code> 。相同的依存关系（例如， <code>com.example:application</code> ）可能会产生多个分类器彼此不同的工件。</p>
</li>
<li>
<p><code>Artifact manager</code> ：生成二进制文件，源文件或程序包时，希望其他人可以下载，参考或重用它们。在JVM世界中，这些工件通常是JAR。对于Ruby而言，这些工件是宝石。对于Docker，这些工件是Docker映像。您可以将这些工件存储在管理器中。此类管理器的示例包括<a href="https://jfrog.com/artifactory/">Artifactory</a>或<a href="https://www.sonatype.org/nexus/">Nexus</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="docker-how-it-works"><a class="anchor" href="#docker-how-it-works"></a> <a class="link" href="#docker-how-it-works">14.6.2。在生产方进行测试</a></h4>
<div class="paragraph">
<p>该图像在<code>/contracts</code>夹。运行测试的输出位于<code>/spring-cloud-contract/build</code>文件夹（用于调试目的）。</p>
</div>
<div class="paragraph">
<p>您可以挂载合同并传递环境变量。图像然后：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>生成合同测试</p>
</li>
<li>
<p>针对提供的URL运行测试</p>
</li>
<li>
<p>生成<a href="https://github.com/tomakehurst/wiremock">WireMock</a>存根</p>
</li>
<li>
<p>将存根发布到Artifact Manager（可选-默认情况下处于启用状态）</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="docker-env-vars"><a class="anchor" href="#docker-env-vars"></a> <a class="link" href="#docker-env-vars">环境变量</a></h5>
<div class="paragraph">
<p>Docker映像需要一些环境变量以指向您正在运行的应用程序，Artifact管理器实例等。以下列表描述了环境变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PROJECT_GROUP</code> ：您项目的组ID。默认为<code>com.example</code> 。</p>
</li>
<li>
<p><code>PROJECT_VERSION</code> ：您项目的版本。默认为<code>0.0.1-SNAPSHOT</code> 。</p>
</li>
<li>
<p><code>PROJECT_NAME</code> ：项目的工件ID。默认为<code>example</code> 。</p>
</li>
<li>
<p><code>PRODUCER_STUBS_CLASSIFIER</code> ：用于生成的生产者存根的存档分类器。默认为<code>stubs</code> 。</p>
</li>
<li>
<p><code>REPO_WITH_BINARIES_URL</code> ：您的工件管理器的网址。默认为<code><a href="http://localhost:8081/artifactory/libs-release-local" class="bare">localhost:8081/artifactory/libs-release-local</a></code> ，这是本地运行的<a href="https://jfrog.com/artifactory/">Artifactory</a>的默认网址。</p>
</li>
<li>
<p><code>REPO_WITH_BINARIES_USERNAME</code> ：（可选）保护Artifact Manager时的用户名。默认为<code>admin</code> 。</p>
</li>
<li>
<p><code>REPO_WITH_BINARIES_PASSWORD</code> ：（可选）保护Artifact Manager时的密码。默认为<code>password</code> 。</p>
</li>
<li>
<p><code>PUBLISH_ARTIFACTS</code> ：如果设置为<code>true</code> ，将工件发布到二进制存储。默认为<code>true</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当合同位于外部存储库中时，将使用这些环境变量。要启用此功能，您必须设置<code>EXTERNAL_CONTRACTS_ARTIFACT_ID</code>环境变量。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EXTERNAL_CONTRACTS_GROUP_ID</code> ：带有合同的项目的组ID。默认为<code>com.example</code></p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_ARTIFACT_ID</code> ：带有合同的项目的工件ID。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_CLASSIFIER</code> ：带有合同的项目分类。默认为空。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_VERSION</code> ：带有合同的项目版本。默认为<code>+</code> ，相当于选择最新的。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_URL</code> ：您的工件管理器的网址。它的默认值为<code>REPO_WITH_BINARIES_URL</code>环境变量。如果未设置，则默认为<code><a href="http://localhost:8081/artifactory/libs-release-local" class="bare">localhost:8081/artifactory/libs-release-local</a></code> ，这是本地运行的<a href="https://jfrog.com/artifactory/">Artifactory</a>的默认网址。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_USERNAME</code> ：（可选）用户名，如果<code>EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_URL</code>需要认证。默认为<code>REPO_WITH_BINARIES_USERNAME</code> 。如果未设置，则默认为<code>admin</code> 。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_PASSWORD</code> ：（可选）密码，如果<code>EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_URL</code>需要认证。默认为<code>REPO_WITH_BINARIES_PASSWORD</code> 。如果未设置，则默认为<code>password</code> 。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_PATH</code> ：给定项目的合同路径，包含合同的项目内部。默认为斜杠分隔<code>EXTERNAL_CONTRACTS_GROUP_ID</code>与<code>/</code>和<code>EXTERNAL_CONTRACTS_ARTIFACT_ID</code> 。例如，对于组ID <code>cat-server-side.dog</code>和工件ID <code>fish</code> ，会导致<code>cat/dog/fish</code>合同路径。</p>
</li>
<li>
<p><code>EXTERNAL_CONTRACTS_WORK_OFFLINE</code> ;如果设置为<code>true</code> ，从容器的容器中获取带有合同的工件<code>.m2</code> 。挂载您的本地<code>.m2</code>作为容器的可用体积<code>/root/.m2</code>路径。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">您不能同时设置<code>EXTERNAL_CONTRACTS_WORK_OFFLINE</code>和<code>EXTERNAL_CONTRACTS_REPO_WITH_BINARIES_URL</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>执行测试时使用以下环境变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>APPLICATION_BASE_URL</code> ：应针对其运行测试的URL。请记住，必须可以从Docker容器访问它（例如， <code>localhost</code>不起作用）</p>
</li>
<li>
<p><code>APPLICATION_USERNAME</code> ：（可选）对应用程序进行基本身份验证的用户名。</p>
</li>
<li>
<p><code>APPLICATION_PASSWORD</code> ：（可选）用于对应用程序进行基本身份验证的密码。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="docker-example-of-usage"><a class="anchor" href="#docker-example-of-usage"></a> <a class="link" href="#docker-example-of-usage">使用范例</a></h5>
<div class="paragraph">
<p>在本节中，我们探索一个简单的MVC应用程序。首先，通过运行以下命令将以下git存储库和cd克隆到结果目录：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ cd bookstore</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>合同位于<code>/contracts</code>夹。</p>
</div>
<div class="paragraph">
<p>由于我们要运行测试，因此可以运行以下命令：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ npm test</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，出于学习目的，我们将其分为以下几部分：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Stop docker infra (nodejs, artifactory)
$ ./stop_infra.sh
# Start docker infra (nodejs, artifactory)
$ ./setup_infra.sh

# Kill & Run app
$ pkill -f "node app"
$ nohup node app &

# Prepare environment variables
$ SC_CONTRACT_DOCKER_VERSION="..."
$ APP_IP="192.168.0.100"
$ APP_PORT="3000"
$ ARTIFACTORY_PORT="8081"
$ APPLICATION_BASE_URL="http://${APP_IP}:${APP_PORT}"
$ ARTIFACTORY_URL="http://${APP_IP}:${ARTIFACTORY_PORT}/artifactory/libs-release-local"
$ CURRENT_DIR="$( pwd )"
$ CURRENT_FOLDER_NAME=${PWD##*/}
$ PROJECT_VERSION="0.0.1.RELEASE"

# Execute contract tests
$ docker run  --rm -e "APPLICATION_BASE_URL=${APPLICATION_BASE_URL}" -e "PUBLISH_ARTIFACTS=true" -e "PROJECT_NAME=${CURRENT_FOLDER_NAME}" -e "REPO_WITH_BINARIES_URL=${ARTIFACTORY_URL}" -e "PROJECT_VERSION=${PROJECT_VERSION}" -v "${CURRENT_DIR}/contracts/:/contracts:ro" -v "${CURRENT_DIR}/node_modules/spring-cloud-contract/output:/spring-cloud-contract-output/" springcloud/spring-cloud-contract:"${SC_CONTRACT_DOCKER_VERSION}"

# Kill app
$ pkill -f "node app"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过bash脚本，将发生以下情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基础设施（MongoDb和Artifactory）已建立。在实际场景中，您将使用模拟数据库运行NodeJS应用程序。在此示例中，我们想展示如何在极短的时间内从Spring Cloud Contract中受益。</p>
</li>
<li>
<p>由于这些限制，合同也代表了有状态的情况。</p>
<div class="ulist">
<ul>
<li>
<p>第一个请求是<code>POST</code>导致将数据插入数据库。</p>
</li>
<li>
<p>第二个请求是<code>GET</code>返回具有1个先前插入的元素的数据列表。</p>
</li>
</ul>
</div>
</li>
<li>
<p>NodeJS应用程序已启动（在端口上<code>3000</code> ）。</p>
</li>
<li>
<p>合同测试是通过Docker生成的，并且测试是针对正在运行的应用程序运行的。</p>
<div class="ulist">
<ul>
<li>
<p>合同取自<code>/contracts</code>夹。</p>
</li>
<li>
<p>测试执行的输出在下<code>node_modules/spring-cloud-contract/output</code> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>存根被上传到Artifactory。您可以在<a href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/" class="bare">localhost：8081 / artifactory / libs-release-local / com / example / bookstore / 0.0.1中找到它们</a><a href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/" class="bare">。发布/</a> 。存根位于<a href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/bookstore-0.0.1.RELEASE-stubs.jar" class="bare">localhost：8081 / artifactory / libs-release-local / com / example / bookstore / 0.0.1。RELEASE / bookstore-0.0.1。RELEASE-stubs.jar</a> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docker-stubrunner"><a class="anchor" href="#docker-stubrunner"></a> <a class="link" href="#docker-stubrunner">14.6.3。在消费者端运行存根</a></h4>
<div class="paragraph">
<p>本节描述了如何在用户端使用Docker来获取和运行存根。</p>
</div>
<div class="paragraph">
<p>我们发布了<code>spring-cloud/spring-cloud-contract-stub-runner</code>启动独立版本的Stub Runner的Docker映像。</p>
</div>
<div class="sect4">
<h5 id="docker-stubrunner-env-vars"><a class="anchor" href="#docker-stubrunner-env-vars"></a> <a class="link" href="#docker-stubrunner-env-vars">环境变量</a></h5>
<div class="paragraph">
<p>您可以运行docker映像，并将<a href="project-features.html#features-stub-runner-common-properties-junit-spring">JUnit和Spring的</a>任何<a href="project-features.html#features-stub-runner-common-properties-junit-spring">通用属性</a>作为环境变量传递。惯例是所有字母都应大写。点（ <code>.</code> ）应该用下划线（ <code>_</code> ）字符。例如， <code>stubrunner.repositoryRoot</code>属性应表示为<code>STUBRUNNER_REPOSITORY_ROOT</code>环境变量。</p>
</div>
</div>
<div class="sect4">
<h5 id="docker-stubrunner-example"><a class="anchor" href="#docker-stubrunner-example"></a> <a class="link" href="#docker-stubrunner-example">使用范例</a></h5>
<div class="paragraph">
<p>我们要使用在<a href="#docker-server-side">[docker-server-side]</a>步骤中创建的存根。假设我们要在端口上运行存根<code>9876</code> 。您可以通过克隆存储库并更改为以下命令中指示的目录来查看NodeJS代码：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ cd bookstore</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以通过运行以下命令，使用存根来运行Stub Runner Boot应用程序：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Provide the Spring Cloud Contract Docker version
$ SC_CONTRACT_DOCKER_VERSION="..."
# The IP at which the app is running and Docker container can reach it
$ APP_IP="192.168.0.100"
# Spring Cloud Contract Stub Runner properties
$ STUBRUNNER_PORT="8083"
# Stub coordinates 'groupId:artifactId:version:classifier:port'
$ STUBRUNNER_IDS="com.example:bookstore:0.0.1.RELEASE:stubs:9876"
$ STUBRUNNER_REPOSITORY_ROOT="http://${APP_IP}:8081/artifactory/libs-release-local"
# Run the docker with Stub Runner Boot
$ docker run  --rm -e "STUBRUNNER_IDS=${STUBRUNNER_IDS}" -e "STUBRUNNER_REPOSITORY_ROOT=${STUBRUNNER_REPOSITORY_ROOT}" -e "STUBRUNNER_STUBS_MODE=REMOTE" -p "${STUBRUNNER_PORT}:${STUBRUNNER_PORT}" -p "9876:9876" springcloud/spring-cloud-contract-stub-runner:"${SC_CONTRACT_DOCKER_VERSION}"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当上述命令运行时，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个独立的Stub Runner应用程序将启动。</p>
</li>
<li>
<p>下载带有坐标的存根<code>com.example:bookstore:0.0.1.RELEASE:stubs</code>在港口<code>9876</code> 。</p>
</li>
<li>
<p>它可以从Artifactory下载，运行地址为<code><a href="http://192.168.0.100:8081/artifactory/libs-release-local" class="bare">192.168.0.100:8081/artifactory/libs-release-local</a></code> 。</p>
</li>
<li>
<p>哭泣后，Stub Runner在端口上运行<code>8083</code> 。</p>
</li>
<li>
<p>存根在端口上运行<code>9876</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在服务器端，我们构建了一个有状态的存根。我们可以使用curl声明存根已正确设置。为此，请运行以下命令：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># let's execute the first request (no response is returned)
$ curl -H "Content-Type:application/json" -X POST --data '{ "title" : "Title", "genre" : "Genre", "description" : "Description", "author" : "Author", "publisher" : "Publisher", "pages" : 100, "image_url" : "https://d213dhlpdb53mu.cloudfront.net/assets/pivotal-square-logo-41418bd391196c3022f3cd9f3959b3f6d7764c47873d858583384e759c7db435.svg", "buy_url" : "https://pivotal.io" }' http://localhost:9876/api/books
# Now time for the second request
$ curl -X GET http://localhost:9876/api/books
# You will receive contents of the JSON</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果要使用在本地构建的存根，请在主机上设置<code>-e STUBRUNNER_STUBS_MODE=LOCAL</code>环境变量并安装本地m2的音量（ <code>-v "${HOME}/.m2/:/root/.m2:ro"</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contract-customization"><a class="anchor" href="#contract-customization"></a> <a class="link" href="#contract-customization">14.7。Spring Cloud Contract定制</a></h3>
<div class="paragraph">
<p>在本节中，我们描述如何自定义Spring Cloud Contract的各个部分。</p>
</div>
<div class="sect3">
<h4 id="customization-customization"><a class="anchor" href="#customization-customization"></a> <a class="link" href="#customization-customization">14.7.1。DSL定制</a></h4>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">本部分仅对Groovy DSL有效</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以通过扩展DSL来定制Spring Cloud Contract Verifier，如本节其余部分所示。</p>
</div>
<div class="sect4">
<h5 id="customization-extending"><a class="anchor" href="#customization-extending"></a> <a class="link" href="#customization-extending">扩展DSL</a></h5>
<div class="paragraph">
<p>您可以为DSL提供自己的功能。此功能的关键要求是保持静态兼容性。在本文档的后面，您可以看到以下示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建具有可重用类的JAR。</p>
</li>
<li>
<p>在DSL中引用这些类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以在<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples">此处</a>找到完整的示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="customization-extending-common-jar"><a class="anchor" href="#customization-extending-common-jar"></a> <a class="link" href="#customization-extending-common-jar">普通JAR</a></h5>
<div class="paragraph">
<p>以下示例显示了可以在DSL中重用的三个类。</p>
</div>
<div class="paragraph">
<p><code>PatternUtils</code>包含消费者和生产者都使用的功能。以下清单显示了<code>PatternUtils</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

import java.util.regex.Pattern;

/**
 * If you want to use {@link Pattern} directly in your tests
 * then you can create a class resembling this one. It can
 * contain all the {@link Pattern} you want to use in the DSL.
 *
 * <pre>
 * {@code
 * request {
 *     body(
 *         [ age: $(c(PatternUtils.oldEnough()))]
 *     )
 * }
 * </pre>
 *
 * Notice that we're using both {@code $()} for dynamic values
 * and {@code c()} for the consumer side.
 *
 * @author Marcin Grzejszczak
 */
//tag::impl[]
public class PatternUtils {

    public static String tooYoung() {
        //remove::start[]
        return "[0-1][0-9]";
        //remove::end[return]
    }

    public static Pattern oldEnough() {
        //remove::start[]
        return Pattern.compile("[2-9][0-9]");
        //remove::end[return]
    }

    /**
     * Makes little sense but it's just an example ;)
     */
    public static Pattern ok() {
        //remove::start[]
        return Pattern.compile("OK");
        //remove::end[return]
    }
}
//end::impl[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ConsumerUtils</code>包含使用者使用的功能。以下清单显示了<code>ConsumerUtils</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

import org.springframework.cloud.contract.spec.internal.ClientDslProperty;

/**
 * DSL Properties passed to the DSL from the consumer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you can have a regular expression.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you have to have a concrete value.
 *
 * @author Marcin Grzejszczak
 */
//tag::impl[]
public class ConsumerUtils {
    /**
     * Consumer side property. By using the {@link ClientDslProperty}
     * you can omit most of boilerplate code from the perspective
     * of dynamic values. Example
     *
     * <pre>
     * {@code
     * request {
     *     body(
     *         [ age: $(ConsumerUtils.oldEnough())]
     *     )
     * }
     * </pre>
     *
     * That way it's in the implementation that we decide what value we will pass to the consumer
     * and which one to the producer.
     *
     * @author Marcin Grzejszczak
     */
    public static ClientDslProperty oldEnough() {
        //remove::start[]
        // this example is not the best one and
        // theoretically you could just pass the regex instead of `ServerDslProperty` but
        // it's just to show some new tricks :)
        return new ClientDslProperty(PatternUtils.oldEnough(), 40);
        //remove::end[return]
    }

}
//end::impl[]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ProducerUtils</code>包含生产者使用的功能。以下清单显示了<code>ProducerUtils</code>类：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

import org.springframework.cloud.contract.spec.internal.ServerDslProperty;

/**
 * DSL Properties passed to the DSL from the producer's perspective.
 * That means that on the input side {@code Request} for HTTP
 * or {@code Input} for messaging you have to have a concrete value.
 * On the {@code Response} for HTTP or {@code Output} for messaging
 * you can have a regular expression.
 *
 * @author Marcin Grzejszczak
 */
//tag::impl[]
public class ProducerUtils {

    /**
     * Producer side property. By using the {@link ProducerUtils}
     * you can omit most of boilerplate code from the perspective
     * of dynamic values. Example
     *
     * <pre>
     * {@code
     * response {
     *     body(
     *         [ status: $(ProducerUtils.ok())]
     *     )
     * }
     * </pre>
     *
     * That way it's in the implementation that we decide what value we will pass to the consumer
     * and which one to the producer.
     */
    public static ServerDslProperty ok() {
        // this example is not the best one and
        // theoretically you could just pass the regex instead of `ServerDslProperty` but
        // it's just to show some new tricks :)
        return new ServerDslProperty( PatternUtils.ok(), "OK");
    }
}
//end::impl[]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="customization-test-dep"><a class="anchor" href="#customization-test-dep"></a> <a class="link" href="#customization-test-dep">在项目的依存关系中添加测试依存关系</a></h5>
<div class="paragraph">
<p>要将测试依赖项添加到项目的依赖项中，必须首先添加公共jar依赖项作为测试依赖项。因为您的合同文件在测试资源路径上可用，所以常见的jar类自动在Groovy文件中可见。以下示例显示如何测试依赖关系：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>com.example</groupId>
    <artifactId>beer-common</artifactId>
    <version>${project.version}</version>
    <scope>test</scope>
</dependency></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">testCompile("com.example:beer-common:0.0.1.BUILD-SNAPSHOT")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="customization-plugin-dep"><a class="anchor" href="#customization-plugin-dep"></a> <a class="link" href="#customization-plugin-dep">在插件的依赖项中添加测试依赖项</a></h5>
<div class="paragraph">
<p>现在，您必须添加插件的依赖关系，以便在运行时重用，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <packageWithBaseClasses>com.example</packageWithBaseClasses>
        <baseClassMappings>
            <baseClassMapping>
                <contractPackageRegex>.*intoxication.*</contractPackageRegex>
                <baseClassFQN>com.example.intoxication.BeerIntoxicationBase</baseClassFQN>
            </baseClassMapping>
        </baseClassMappings>
    </configuration>
    <dependencies>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>beer-common</artifactId>
            <version>${project.version}</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">classpath "com.example:beer-common:0.0.1.BUILD-SNAPSHOT"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="customization-referencing"><a class="anchor" href="#customization-referencing"></a> <a class="link" href="#customization-referencing">DSL中的引用类</a></h5>
<div class="paragraph">
<p>现在，您可以在DSL中引用您的类，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package contracts.beer.rest

import com.example.ConsumerUtils
import com.example.ProducerUtils
import org.springframework.cloud.contract.spec.Contract

Contract.make {
    description("""
Represents a successful scenario of getting a beer

```
given:
    client is old enough
when:
    he applies for a beer
then:
    we'll grant him the beer
```

""")
    request {
        method 'POST'
        url '/check'
        body(
                age: $(ConsumerUtils.oldEnough())
        )
        headers {
            contentType(applicationJson())
        }
    }
    response {
        status 200
        body("""
            {
                "status": "${value(ProducerUtils.ok())}"
            }
            """)
        headers {
            contentType(applicationJson())
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您可以通过设置来设置Spring Cloud Contract插件<code>convertToYaml</code>至<code>true</code> 。这样，您不必将具有扩展功能的依赖项添加到使用者方，因为使用者方使用YAML合同而不是Groovy合同。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customization-wiremock"><a class="anchor" href="#customization-wiremock"></a> <a class="link" href="#customization-wiremock">14.7.2。WireMock定制</a></h4>
<div class="paragraph">
<p>在本节中，我们将展示如何自定义<a href="https://wiremock.org">WireMock的</a>工作方式。</p>
</div>
<div class="sect4">
<h5 id="customization-wiremock-extension"><a class="anchor" href="#customization-wiremock-extension"></a> <a class="link" href="#customization-wiremock-extension">注册自己的WireMock扩展</a></h5>
<div class="paragraph">
<p>WireMock允许您注册自定义扩展。默认情况下，Spring Cloud Contract注册该转换器，使您可以引用响应中的请求。如果您想提供自己的扩展程序，则可以注册<code>org.springframework.cloud.contract.verifier.dsl.wiremock.WireMockExtensions</code>接口。由于我们使用<code>spring.factories</code>扩展方法，您可以在<code>META-INF/spring.factories</code>文件类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">org.springframework.cloud.contract.verifier.dsl.wiremock.WireMockExtensions=\
org.springframework.cloud.contract.stubrunner.provider.wiremock.TestWireMockExtensions
org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.stubrunner.TestCustomYamlContractConverter</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了一个自定义扩展：</p>
</div>
<div class="exampleblock">
<div class="title">范例3。TestWireMockExtensions.groovy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">/*
 * Copyright 2013-2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.cloud.contract.verifier.dsl.wiremock

import com.github.tomakehurst.wiremock.extension.Extension

/**
 * Extension that registers the default transformer and the custom one
 */
class TestWireMockExtensions implements WireMockExtensions {
    @Override
    List<Extension> extensions() {
        return [
                new DefaultResponseTransformer(),
                new CustomExtension()
        ]
    }
}

class CustomExtension implements Extension {

    @Override
    String getName() {
        return "foo-transformer"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">记住要覆盖<code>applyGlobally()</code>方法并将其设置为<code>false</code>如果您希望仅将转换应用于明确需要转换的映射。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="customization-wiremock-configuration"><a class="anchor" href="#customization-wiremock-configuration"></a> <a class="link" href="#customization-wiremock-configuration">定制WireMock配置</a></h5>
<div class="paragraph">
<p>您可以注册一个类型的bean <code>org.springframework.cloud.contract.wiremock.WireMockConfigurationCustomizer</code>自定义WireMock配置（例如，添加自定义转换器）。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        @Bean
        WireMockConfigurationCustomizer optionsCustomizer() {
            return new WireMockConfigurationCustomizer() {
                @Override
                public void customize(WireMockConfiguration options) {
// perform your customization here
                }
            };
        }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customization-pluggable-architecture"><a class="anchor" href="#customization-pluggable-architecture"></a> <a class="link" href="#customization-pluggable-architecture">14.7.3。使用可插拔架构</a></h4>
<div class="paragraph">
<p>您可能会遇到以其他格式（例如YAML，RAML或PACT）定义合同的情况。在那些情况下，您仍然想从自动生成测试和存根中受益。您可以添加自己的实现以生成测试和存根。另外，您可以自定义测试的生成方式（例如，可以生成其他语言的测试）和存根的生成方式（例如，可以为其他HTTP服务器实现生成存根）。</p>
</div>
<div class="sect4">
<h5 id="customization-custom-contract-converter"><a class="anchor" href="#customization-custom-contract-converter"></a> <a class="link" href="#customization-custom-contract-converter">定制合同转换器</a></h5>
<div class="paragraph">
<p>的<code>ContractConverter</code>界面可让您注册自己的合同结构转换器实现。以下代码清单显示了<code>ContractConverter</code>接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.springframework.cloud.contract.spec;

import java.io.File;
import java.util.Collection;

/**
 * Converter to be used to convert FROM {@link File} TO {@link Contract} and from
 * {@link Contract} to {@code T}.
 *
 * @param <T> - type to which we want to convert the contract
 * @author Marcin Grzejszczak
 * @since 1.1.0
 */
public interface ContractConverter<T> extends ContractStorer<T> {

    /**
     * Should this file be accepted by the converter. Can use the file extension to check
     * if the conversion is possible.
     * @param file - file to be considered for conversion
     * @return - {@code true} if the given implementation can convert the file
     */
    boolean isAccepted(File file);

    /**
     * Converts the given {@link File} to its {@link Contract} representation.
     * @param file - file to convert
     * @return - {@link Contract} representation of the file
     */
    Collection<Contract> convertFrom(File file);

    /**
     * Converts the given {@link Contract} to a {@link T} representation.
     * @param contract - the parsed contract
     * @return - {@link T} the type to which we do the conversion
     */
    T convertTo(Collection<Contract> contract);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您的实现必须定义启动转换的条件。另外，您必须定义如何在两个方向上执行该转换。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">创建实施后，您必须创建一个<code>/META-INF/spring.factories</code>您在其中提供实施的完全限定名称的文件。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了一个典型的<code>spring.factories</code>文件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.springframework.cloud.contract.spec.ContractConverter=\
org.springframework.cloud.contract.verifier.converter.YamlContractConverter</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="customization-custom-test-generator"><a class="anchor" href="#customization-custom-test-generator"></a> <a class="link" href="#customization-custom-test-generator">使用自定义测试生成器</a></h5>
<div class="paragraph">
<p>如果要针对Java以外的语言生成测试，或者对验证程序构建Java测试的方式不满意，则可以注册自己的实现。</p>
</div>
<div class="paragraph">
<p>的<code>SingleTestGenerator</code>介面可让您注册自己的实作。以下代码清单显示了<code>SingleTestGenerator</code>接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package org.springframework.cloud.contract.verifier.builder;

import java.nio.file.Path;
import java.util.Collection;

import org.springframework.cloud.contract.verifier.config.ContractVerifierConfigProperties;
import org.springframework.cloud.contract.verifier.file.ContractMetadata;

/**
 * Builds a single test.
 *
 * @since 1.1.0
 */
public interface SingleTestGenerator {

    /**
     * Creates contents of a single test class in which all test scenarios from the
     * contract metadata should be placed.
     * @param properties - properties passed to the plugin
     * @param listOfFiles - list of parsed contracts with additional metadata
     * @param className - the name of the generated test class
     * @param classPackage - the name of the package in which the test class should be
     * stored
     * @param includedDirectoryRelativePath - relative path to the included directory
     * @return contents of a single test class
     * @deprecated use{@link SingleTestGenerator#buildClass(ContractVerifierConfigProperties, Collection, String, GeneratedClassData)}
     */
    @Deprecated
    String buildClass(ContractVerifierConfigProperties properties,
            Collection<ContractMetadata> listOfFiles, String className,
            String classPackage, String includedDirectoryRelativePath);

    /**
     * Creates contents of a single test class in which all test scenarios from the
     * contract metadata should be placed.
     * @param properties - properties passed to the plugin
     * @param listOfFiles - list of parsed contracts with additional metadata
     * @param generatedClassData - information about the generated class
     * @param includedDirectoryRelativePath - relative path to the included directory
     * @return contents of a single test class
     */
    default String buildClass(ContractVerifierConfigProperties properties,
            Collection<ContractMetadata> listOfFiles,
            String includedDirectoryRelativePath, GeneratedClassData generatedClassData) {
        String className = generatedClassData.className;
        String classPackage = generatedClassData.classPackage;
        String path = includedDirectoryRelativePath;
        return buildClass(properties, listOfFiles, className, classPackage, path);
    }

    /**
     * Extension that should be appended to the generated test class. E.g. {@code .java}
     * or {@code .php}
     * @param properties - properties passed to the plugin
     */
    @Deprecated
    String fileExtension(ContractVerifierConfigProperties properties);

    class GeneratedClassData {

        public final String className;

        public final String classPackage;

        public final Path testClassPath;

        public GeneratedClassData(String className, String classPackage,
                Path testClassPath) {
            this.className = className;
            this.classPackage = classPackage;
            this.testClassPath = testClassPath;
        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，您必须提供一个<code>spring.factories</code>文件，如以下示例中所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.springframework.cloud.contract.verifier.builder.SingleTestGenerator=/
com.example.MyGenerator</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="customization-custom-stub-generator"><a class="anchor" href="#customization-custom-stub-generator"></a> <a class="link" href="#customization-custom-stub-generator">使用自定义存根生成器</a></h5>
<div class="paragraph">
<p>如果要为WireMock以外的存根服务器生成存根，则可以插入自己的<code>StubGenerator</code>接口。以下代码清单显示了<code>StubGenerator</code>接口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package org.springframework.cloud.contract.verifier.converter;

import java.util.Map;

import org.springframework.cloud.contract.spec.Contract;
import org.springframework.cloud.contract.verifier.file.ContractMetadata;

/**
 * Converts contracts into their stub representation.
 *
 * @since 1.1.0
 */
public interface StubGenerator {

    /**
     * @param fileName - file name
     * @return {@code true} if the converter can handle the file to convert it into a
     * stub.
     */
    default boolean canHandleFileName(String fileName) {
        return fileName.endsWith(fileExtension());
    }

    /**
     * @param rootName - root name of the contract
     * @param content - metadata of the contract
     * @return the collection of converted contracts into stubs. One contract can result
     * in multiple stubs.
     */
    Map<Contract, String> convertContents(String rootName, ContractMetadata content);

    /**
     * @param inputFileName - name of the input file
     * @return the name of the converted stub file. If you have multiple contracts in a
     * single file then a prefix will be added to the generated file. If you provide the
     * {@link Contract#name} field then that field will override the generated file name.
     *
     * Example: name of file with 2 contracts is {@code foo.groovy}, it will be converted
     * by the implementation to {@code foo.json}. The recursive file converter will create
     * two files {@code 0_foo.json} and {@code 1_foo.json}
     */
    String generateOutputFileNameForInput(String inputFileName);

    /**
     * Describes the file extension that this stub generator can handle.
     * @return string describing the file extension
     */
    default String fileExtension() {
        return ".json";
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，您必须提供一个<code>spring.factories</code>文件，如以下示例中所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code># Stub converters
org.springframework.cloud.contract.verifier.converter.StubGenerator=\
org.springframework.cloud.contract.verifier.wiremock.DslToWireMockClientConverter</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认实现是WireMock存根生成。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您可以提供多个存根生成器实现。例如，从单个DSL，您可以同时生成WireMock存根和Pact文件。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="customization-custom-stub-runner"><a class="anchor" href="#customization-custom-stub-runner"></a> <a class="link" href="#customization-custom-stub-runner">使用自定义存根运行器</a></h5>
<div class="paragraph">
<p>如果决定使用自定义存根生成，则还需要使用自定义方式与其他存根提供程序一起运行存根。</p>
</div>
<div class="paragraph">
<p>假设您使用<a href="https://github.com/dreamhead/moco">Moco</a>来构建存根，并且已经编写了存根生成器并将存根放置在JAR文件中。</p>
</div>
<div class="paragraph">
<p>为了使Stub Runner知道如何运行您的存根，您必须定义一个自定义HTTP Stub服务器实现，该实现可能类似于以下示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package org.springframework.cloud.contract.stubrunner.provider.moco

import com.github.dreamhead.moco.bootstrap.arg.HttpArgs
import com.github.dreamhead.moco.runner.JsonRunner
import com.github.dreamhead.moco.runner.RunnerSetting
import groovy.transform.CompileStatic
import groovy.util.logging.Commons

import org.springframework.cloud.contract.stubrunner.HttpServerStub
import org.springframework.util.SocketUtils

@Commons
@CompileStatic
class MocoHttpServerStub implements HttpServerStub {

    private boolean started
    private JsonRunner runner
    private int port

    @Override
    int port() {
        if (!isRunning()) {
            return -1
        }
        return port
    }

    @Override
    boolean isRunning() {
        return started
    }

    @Override
    HttpServerStub start() {
        return start(SocketUtils.findAvailableTcpPort())
    }

    @Override
    HttpServerStub start(int port) {
        this.port = port
        return this
    }

    @Override
    HttpServerStub stop() {
        if (!isRunning()) {
            return this
        }
        this.runner.stop()
        return this
    }

    @Override
    HttpServerStub registerMappings(Collection<File> stubFiles) {
        List<RunnerSetting> settings = stubFiles.findAll { it.name.endsWith("json") }
            .collect {
            log.info("Trying to parse [${it.name}]")
            try {
                return RunnerSetting.aRunnerSetting().addStream(it.newInputStream()).
                    build()
            }
            catch (Exception e) {
                log.warn("Exception occurred while trying to parse file [${it.name}]", e)
                return null
            }
        }.findAll { it }
        this.runner = JsonRunner.newJsonRunnerWithSetting(settings,
            HttpArgs.httpArgs().withPort(this.port).build())
        this.runner.run()
        this.started = true
        return this
    }

    @Override
    String registeredMappings() {
        return ""
    }

    @Override
    boolean isAccepted(File file) {
        return file.name.endsWith(".json")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后你可以在你的<code>spring.factories</code>文件，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.springframework.cloud.contract.stubrunner.HttpServerStub=\
org.springframework.cloud.contract.stubrunner.provider.moco.MocoHttpServerStub</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，您可以使用Moco运行存根。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果不提供任何实现，则使用默认（WireMock）实现。如果提供多个，则使用列表中的第一个。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="customization-custom-stub-downloader"><a class="anchor" href="#customization-custom-stub-downloader"></a> <a class="link" href="#customization-custom-stub-downloader">使用自定义存根下载器</a></h5>
<div class="paragraph">
<p>您可以通过创建以下代码的实现来自定义存根的下载方式<code>StubDownloaderBuilder</code>界面，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

class CustomStubDownloaderBuilder implements StubDownloaderBuilder {

    @Override
    public StubDownloader build(final StubRunnerOptions stubRunnerOptions) {
        return new StubDownloader() {
            @Override
            public Map.Entry<StubConfiguration, File> downloadAndUnpackStubJar(
                    StubConfiguration config) {
                File unpackedStubs = retrieveStubs();
                return new AbstractMap.SimpleEntry<>(
                        new StubConfiguration(config.getGroupId(), config.getArtifactId(), version,
                                config.getClassifier()), unpackedStubs);
            }

            File retrieveStubs() {
                // here goes your custom logic to provide a folder where all the stubs reside
            }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后你可以在你的<code>spring.factories</code>文件，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code># Example of a custom Stub Downloader Provider
org.springframework.cloud.contract.stubrunner.StubDownloaderBuilder=\
com.example.CustomStubDownloaderBuilder</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在，您可以选择包含存根源的文件夹。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">如果不提供任何实现，则使用默认设置（扫描类路径）。如果您提供<code>stubsMode = StubRunnerProperties.StubsMode.LOCAL</code>要么<code>stubsMode = StubRunnerProperties.StubsMode.REMOTE</code> ，则使用Aether实施。如果您提供多个，则使用列表中的第一个。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="scm-stub-downloader"><a class="anchor" href="#scm-stub-downloader"></a> <a class="link" href="#scm-stub-downloader">使用SCM存根下载器</a></h5>
<div class="paragraph">
<p>每当<code>repositoryRoot</code>从SCM协议开始（当前，我们仅支持<code>git://</code> ），存根下载器将尝试克隆存储库，并将其用作生成测试或存根的合同来源。</p>
</div>
<div class="paragraph">
<p>通过环境变量，系统属性或插件或合同存储库配置中设置的属性，您可以调整下载程序的行为。下表描述了可用的属性：</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表4。SCM存根下载器属性</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">物业类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">物业名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>git.branch</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.git.branch</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_GIT_BRANCH</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结帐哪个分支</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>git.username</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.git.username</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_GIT_USERNAME</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Git克隆用户名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>git.password</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.git.password</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_GIT_PASSWORD</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Git克隆密码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>git.no-of-attempts</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.git.no-of-attempts</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_GIT_NO_OF_ATTEMPTS</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将提交推送到的尝试次数<code>origin</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>git.wait-between-attempts</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.git.wait-between-attempts</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_GIT_WAIT_BETWEEN_ATTEMPTS</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">两次尝试将提交推送到之间要等待的毫秒数<code>origin</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="howto"><a class="anchor" href="#howto"></a> <a class="link" href="#howto">14.8。“使用方法”指南</a></h3>
<div class="paragraph">
<p>本节提供了使用Spring Cloud Contract时经常出现的一些常见的“我该怎么做……”问题的答案。它的覆盖范围不是很详尽，但是确实覆盖了很多。</p>
</div>
<div class="paragraph">
<p>如果您有一个我们不在此讨论的特定问题，则可能需要查看<a href="https://stackoverflow.com/tags/spring-cloud">stackoverflow.com</a>来查看是否有人已经提供了答案。堆栈溢出也是一个提出新问题的好地方（请使用<code>spring-cloud</code>标签）。</p>
</div>
<div class="paragraph">
<p>我们也很乐意扩展此部分。如果您要添加“操作方法”，请向我们发送<a href="https://github.com/spring-cloud/tree/master">请求请求</a> 。</p>
</div>
<div class="sect3">
<h4 id="why-spring-cloud-contract"><a class="anchor" href="#why-spring-cloud-contract"></a> <a class="link" href="#why-spring-cloud-contract">14.8.1。为什么要使用Spring Cloud Contract？</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract在多语言环境中非常有效。这个项目有很多非常有趣的功能。这些功能中的许多无疑使Spring Cloud Contract Verifier在消费者驱动合同（CDC）工具市场上脱颖而出。最有趣的功能包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>能够通过消息进行CDC。</p>
</li>
<li>
<p>清晰易用的静态类型DSL。</p>
</li>
<li>
<p>能够将当前JSON文件复制粘贴到合同中，并且仅编辑其元素。</p>
</li>
<li>
<p>根据定义的合同自动生成测试。</p>
</li>
<li>
<p>存根运行器功能：存根将在运行时从Nexus / Artifactory自动下载。</p>
</li>
<li>
<p>Spring Cloud集成：集成测试不需要发现服务。</p>
</li>
<li>
<p>Spring Cloud Contract与Pact集成，并提供简单的挂钩来扩展其功能。</p>
</li>
<li>
<p>能够通过Docker添加对任何语言和框架的支持。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="how-to-not-write-contracts-in-groovy"><a class="anchor" href="#how-to-not-write-contracts-in-groovy"></a> <a class="link" href="#how-to-not-write-contracts-in-groovy">14.8.2。如何用Groovy以外的语言编写合同？</a></h4>
<div class="paragraph">
<p>您可以在YAML中编写合同。有关更多信息，请参见<a href="project-features.html#contract-dsl">本节</a> 。</p>
</div>
<div class="paragraph">
<p>我们正在努力提供更多描述合同的方式。您可以检查<a href="https://github.com/spring-cloud/spring-cloud/issues/">github问题</a>以获得更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-provide-dynamic-values"><a class="anchor" href="#how-to-provide-dynamic-values"></a> <a class="link" href="#how-to-provide-dynamic-values">14.8.3。如何为合同提供动态价值？</a></h4>
<div class="paragraph">
<p>与存根相关的最大挑战之一是它们的可重用性。只有它们能够被广泛使用，它们才能达到目的。请求和响应元素的硬编码值（例如日期和ID）通常使这一点变得困难。考虑以下JSON请求：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在考虑以下JSON响应：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>想象一下设置适当值的痛苦。 <code>time</code>字段（假定此内容由数据库生成）可通过更改系统中的时钟或通过提供数据提供程序的存根实现来实现。与此有关的领域<code>id</code> 。您可以创建UUID生成器的存根实现，但是这样做没有任何意义。</p>
</div>
<div class="paragraph">
<p>因此，作为使用者，您想发送与任何时间形式或任何UUID匹配的请求。这样，您的系统就可以照常工作，而无需存储任何内容即可生成数据。假设在上述JSON的情况下，最重要的部分是<code>body</code>领域。您可以专注于此并为其他字段提供匹配。换句话说，您希望存根按照以下方式工作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "foo"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>就响应而言，作为消费者，您需要一个可操作的具体价值。因此，以下JSON有效：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 21:10:15",
    "id" : "c4231e1f-3ca9-48d3-b7e7-567d55f0d051",
    "body" : "bar"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的部分中，我们从合同生成了测试。因此，从生产者的角度来看，情况似乎大不相同。我们解析提供的合同，并且在测试中，我们想向您的端点发送真实请求。因此，对于请求的生产者而言，我们无法进行任何形式的匹配。我们需要生产者后端可以工作的具体价值。因此，以下JSON将有效：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "2016-10-10 20:10:15",
    "id" : "9febab1c-6f36-4a0b-88d6-3b6a6d81cd4a",
    "body" : "foo"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另一方面，从合同有效性的角度来看，回应不一定包含具体的价值。 <code>time</code>要么<code>id</code> 。假设您在生产者端生成那些。同样，您必须进行大量的存根处理以确保始终返回相同的值。这就是为什么在生产者方面，您可能需要以下响应：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "time" : "SOMETHING THAT MATCHES TIME",
    "id" : "SOMETHING THAT MATCHES UUID",
    "body" : "bar"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，如何为消费者提供匹配器，为生产者提供具体的价值（在其他时间则相反）？Spring Cloud Contract可让您提供动态价值。这意味着通信的双方可能会有所不同。</p>
</div>
<div class="paragraph">
<p>您可以在“ <a href="project-features.html#contract-dsl">合同DSL”</a>部分中阅读有关此内容的更多信息。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">阅读<a href="https://groovy-lang.org/json.html">与JSON相关</a>的<a href="https://groovy-lang.org/json.html">Groovy文档，</a>以了解如何正确构造请求和响应主体。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="how-to-do-stubs-versioning"><a class="anchor" href="#how-to-do-stubs-versioning"></a> <a class="link" href="#how-to-do-stubs-versioning">14.8.4。如何进行存根版本控制？</a></h4>
<div class="paragraph">
<p>本节介绍了存根的版本，您可以用多种不同的方式来处理它们：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#how-to-api-versioning">API版本控制</a></p>
</li>
<li>
<p><a href="#how-to-jar-versioning">JAR版本控制</a></p>
</li>
<li>
<p><a href="#how-to-dev-or-prod-stubs">开发或生产存根</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="how-to-api-versioning"><a class="anchor" href="#how-to-api-versioning"></a> <a class="link" href="#how-to-api-versioning">API版本控制</a></h5>
<div class="paragraph">
<p>版本控制的真正含义是什么？如果您引用的是API版本，则有不同的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用超媒体链接，请勿以任何方式对API进行版本控制</p>
</li>
<li>
<p>通过标题和URL传递版本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们不会尝试回答哪种方法更好的问题。您应该选择适合自己需求的任何东西，并让您产生业务价值。</p>
</div>
<div class="paragraph">
<p>假设您确实对API进行了版本控制。在这种情况下，您应该提供所支持的尽可能多的合同和版本。您可以为每个版本创建一个子文件夹，也可以将其附加到合同名称中-最适合您的名称。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-jar-versioning"><a class="anchor" href="#how-to-jar-versioning"></a> <a class="link" href="#how-to-jar-versioning">JAR版本控制</a></h5>
<div class="paragraph">
<p>如果用版本控制来表示包含存根的JAR版本，则实质上有两种主要方法。</p>
</div>
<div class="paragraph">
<p>假定您进行连续交付和部署，这意味着您每次通过管道时都会生成一个新版本的jar，并且该jar可以随时投入生产。例如，您的jar版本如下所示（因为它建立在20.10.2016 at 20:15:21上）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">1.0.0.20161020-201521-RELEASE</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，生成的存根jar应该如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">1.0.0.20161020-201521-RELEASE-stubs.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，您应该<code>application.yml</code>要么<code>@AutoConfigureStubRunner</code>引用存根时，请提供最新版本的存根。您可以通过传递<code>+</code>标志。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，如果版本控制是固定的（例如， <code>1.0.4.RELEASE</code>要么<code>2.1.1</code> ），则必须设置jar版本的具体值。以下示例显示了如何针对2.1.1版执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:2.1.1:stubs:8080"})</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-to-dev-or-prod-stubs"><a class="anchor" href="#how-to-dev-or-prod-stubs"></a> <a class="link" href="#how-to-dev-or-prod-stubs">开发或生产存根</a></h5>
<div class="paragraph">
<p>您可以操纵分类器，以针对其他服务或已部署到生产中的服务的最新开发版本运行测试。如果您更改构建以通过以下方式部署存根<code>prod-stubs</code>分类器一旦进入生产部署，就可以在一种情况下使用开发存根运行测试，而在一种情况下使用生产存根运行测试。</p>
</div>
<div class="paragraph">
<p>以下示例适用于使用存根的开发版本的测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:stubs:8080"})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例适用于使用存根的生产版本的测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(ids = {"com.example:http-server-dsl:+:prod-stubs:8080"})</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以在部署管道的属性中传递这些值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-common-repo-with-contracts"><a class="anchor" href="#how-to-common-repo-with-contracts"></a> <a class="link" href="#how-to-common-repo-with-contracts">14.8.5。如何与合同一起使用公共存储库，而不是与生产者存储它们？</a></h4>
<div class="paragraph">
<p>存储合同而不是与生产者拥有合同的另一种方法是将它们放在一个公共位置。这种情况可能与安全性问题（使用者无法克隆生产者的代码）有关。同样，如果您将合同放在一个地方，那么作为生产者，您将知道您拥有多少个消费者，您可能会因本地变更而破坏哪个消费者。</p>
</div>
<div class="sect4">
<h5 id="how-to-repo-structure"><a class="anchor" href="#how-to-repo-structure"></a> <a class="link" href="#how-to-repo-structure">回购结构</a></h5>
<div class="paragraph">
<p>假设我们有一个生产者，其坐标为<code>com.example:server</code>和三个消费者： <code>client1</code> ， <code>client2</code>和<code>client3</code> 。然后，在具有公共合同的存储库中，您可以进行以下设置（您可以在<a href="https://github.com/spring-cloud/spring-cloud-contract/tree/master/samples/standalone/contracts">此处</a>签出）。以下清单显示了这样的结构：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── com
│   └── example
│       └── server
│           ├── client1
│           │   └── expectation.groovy
│           ├── client2
│           │   └── expectation.groovy
│           ├── client3
│           │   └── expectation.groovy
│           └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，以斜杠分隔<code>groupid/artifact id</code>文件夹（ <code>com/example/server</code> ）您对三个消费者都有期望（ <code>client1</code> ， <code>client2</code>和<code>client3</code> ）。期望是标准的Groovy DSL合同文件，如本文档中所述。该存储库必须生成一个JAR文件，该文件将一对一映射到存储库的内容。</p>
</div>
<div class="paragraph">
<p>以下示例显示了<code>pom.xml</code>在 - 的里面<code>server</code>夹：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>server</artifactId>
    <version>0.0.1</version>

    <name>Server Stubs</name>
    <description>POM used to install locally stubs for consumer side</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.2.0.BUILD-SNAPSHOT</version>
        <relativePath/>
    </parent>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>1.8</java.version>
        <spring-cloud-contract.version>2.2.0.BUILD-SNAPSHOT</spring-cloud-contract.version>
        <spring-cloud-release.version>Hoxton.BUILD-SNAPSHOT</spring-cloud-release.version>
        <excludeBuildFolders>true</excludeBuildFolders>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud-release.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-contract-maven-plugin</artifactId>
                <version>${spring-cloud-contract.version}</version>
                <extensions>true</extensions>
                <configuration>
                    <!-- By default it would search under src/test/resources/ -->
                    <contractsDirectory>${project.basedir}</contractsDirectory>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <repositories>
        <repository>
            <id>spring-snapshots</id>
            <name>Spring Snapshots</name>
            <url>https://repo.spring.io/snapshot</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>spring-releases</id>
            <name>Spring Releases</name>
            <url>https://repo.spring.io/release</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository>
            <id>spring-snapshots</id>
            <name>Spring Snapshots</name>
            <url>https://repo.spring.io/snapshot</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </pluginRepository>
        <pluginRepository>
            <id>spring-milestones</id>
            <name>Spring Milestones</name>
            <url>https://repo.spring.io/milestone</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
        <pluginRepository>
            <id>spring-releases</id>
            <name>Spring Releases</name>
            <url>https://repo.spring.io/release</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </pluginRepository>
    </pluginRepositories>

</project></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了Spring Cloud Contract Maven插件外，没有其他依赖项。这些pom文件对于用户端运行是必需的<code>mvn clean install -DskipTests</code>在本地安装生产者项目的存根。</p>
</div>
<div class="paragraph">
<p>的<code>pom.xml</code>根文件夹中的内容如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example.standalone</groupId>
    <artifactId>contracts</artifactId>
    <version>0.0.1</version>

    <name>Contracts</name>
    <description>Contains all the Spring Cloud Contracts, well, contracts. JAR used by the
        producers to generate tests and stubs
    </description>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <executions>
                    <execution>
                        <id>contracts</id>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                        <configuration>
                            <attach>true</attach>
                            <descriptor>${basedir}/src/assembly/contracts.xml</descriptor>
                            <!-- If you want an explicit classifier remove the following line -->
                            <appendAssemblyId>false</appendAssemblyId>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>它使用组装插件来构建包含所有合同的JAR。以下示例显示了这样的设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><assembly xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd">
    <id>project</id>
    <formats>
        <format>jar</format>
    </formats>
    <includeBaseDirectory>false</includeBaseDirectory>
    <fileSets>
        <fileSet>
            <directory>${project.basedir}</directory>
            <outputDirectory>/</outputDirectory>
            <useDefaultExcludes>true</useDefaultExcludes>
            <excludes>
                <exclude>**/${project.build.directory}/**</exclude>
                <exclude>mvnw</exclude>
                <exclude>mvnw.cmd</exclude>
                <exclude>.mvn/**</exclude>
                <exclude>src/**</exclude>
            </excludes>
        </fileSet>
    </fileSets>
</assembly></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-to-workflow"><a class="anchor" href="#how-to-workflow"></a> <a class="link" href="#how-to-workflow">工作流程</a></h5>
<div class="paragraph">
<p>该工作流假定在消费者方和生产方都设置了Spring Cloud Contract。在公共资源库中也有带有合同的正确插件设置。为公共存储库设置了CI作业，以构建所有合同的工件并将其上载到Nexus / Artifactory。下图显示了此工作流程的UML：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/how-to-common-repo.png" alt="如何共同回购" width="1588" height="1421">
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-to-workflow-consumer"><a class="anchor" href="#how-to-workflow-consumer"></a> <a class="link" href="#how-to-workflow-consumer">消费者</a></h5>
<div class="paragraph">
<p>当使用者希望脱机处理合同时，而不是克隆生产者代码，消费者团队将克隆公共存储库，转到所需的生产者文件夹（例如， <code>com/example/server</code> ）并运行<code>mvn clean install -DskipTests</code>在本地安装从合同转换的存根。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您需要在<a href="https://maven.apache.org/download.cgi">本地安装Maven</a>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="how-to-workflow-producer"><a class="anchor" href="#how-to-workflow-producer"></a> <a class="link" href="#how-to-workflow-producer">制片人</a></h5>
<div class="paragraph">
<p>作为生产者，您可以更改Spring Cloud Contract Verifier，以提供URL和包含合同的JAR的依赖关系，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <configuration>
        <contractsMode>REMOTE</contractsMode>
        <contractsRepositoryUrl>
            https://link/to/your/nexus/or/artifactory/or/sth
        </contractsRepositoryUrl>
        <contractDependency>
            <groupId>com.example.standalone</groupId>
            <artifactId>contracts</artifactId>
        </contractDependency>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过此设置，组ID为的JAR <code>com.example.standalone</code>和神器<code>contracts</code>从下载<code><a href="https://link/to/your/nexus/or/artifactory/or/sth" class="bare">link/to/your/nexus/or/artifactory/or/sth</a></code> 。然后将其解压缩到本地临时文件夹中，并将合同存在<code>com/example/server</code>选择用于生成测试和存根的那些。根据此约定，当进行一些不兼容的更改时，生产者团队可以知道哪些消费者团队将被破坏。</p>
</div>
<div class="paragraph">
<p>其余流程看起来相同。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-define-messaging-contracts-per-topic"><a class="anchor" href="#how-to-define-messaging-contracts-per-topic"></a> <a class="link" href="#how-to-define-messaging-contracts-per-topic">如何按主题而不是按生产者定义消息传递合同？</a></h5>
<div class="paragraph">
<p>为了避免在公共存储库中重复进行消息传递合同，当几个生产者将消息写到一个主题时，我们可以创建一个结构，其中REST合同在每个生产者的文件夹中放置，而消息传递合同在每个主题的文件夹中放置。</p>
</div>
<div class="sect5">
<h6 id="how-to-define-messaging-contracts-per-topic-maven"><a class="anchor" href="#how-to-define-messaging-contracts-per-topic-maven"></a> <a class="link" href="#how-to-define-messaging-contracts-per-topic-maven">对于Maven项目</a></h6>
<div class="paragraph">
<p>为了能够在生产者端进行工作，我们应该指定一种包含模式，用于通过我们感兴趣的消息传递主题来过滤通用存储库jar文件。的<code>includedFiles</code> Maven Spring Cloud Contract插件的属性使我们可以这样做。也， <code>contractsPath</code>需要指定，因为默认路径将是公共存储库<code>groupid/artifactid</code> 。以下示例显示了Spring Cloud Contract的Maven插件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
   <groupId>org.springframework.cloud</groupId>
   <artifactId>spring-cloud-contract-maven-plugin</artifactId>
   <version>${spring-cloud-contract.version}</version>
   <configuration>
      <contractsMode>REMOTE</contractsMode>
      <contractsRepositoryUrl>https://link/to/your/nexus/or/artifactory/or/sth</contractsRepositoryUrl>
      <contractDependency>
         <groupId>com.example</groupId>
         <artifactId>common-repo-with-contracts</artifactId>
         <version>+</version>
      </contractDependency>
      <contractsPath>/</contractsPath>
      <baseClassMappings>
         <baseClassMapping>
            <contractPackageRegex>.*messaging.*</contractPackageRegex>
            <baseClassFQN>com.example.services.MessagingBase</baseClassFQN>
         </baseClassMapping>
         <baseClassMapping>
            <contractPackageRegex>.*rest.*</contractPackageRegex>
            <baseClassFQN>com.example.services.TestBase</baseClassFQN>
         </baseClassMapping>
      </baseClassMappings>
      <includedFiles>
         <includedFile>**/${project.artifactId}/**</includedFile>
         <includedFile>**/${first-topic}/**</includedFile>
         <includedFile>**/${second-topic}/**</includedFile>
      </includedFiles>
   </configuration>
</plugin></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的Maven插件中的许多值都可以更改。我们将其包括在内是出于说明目的，而不是试图提供“典型”示例。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="how-to-define-messaging-contracts-per-topic-gradle"><a class="anchor" href="#how-to-define-messaging-contracts-per-topic-gradle"></a> <a class="link" href="#how-to-define-messaging-contracts-per-topic-gradle">对于Gradle项目</a></h6>
<div class="paragraph">
<p>要使用Gradle项目：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>为通用存储库依赖项添加定制配置，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">ext {
    conractsGroupId = "com.example"
    contractsArtifactId = "common-repo"
    contractsVersion = "1.2.3"
}

configurations {
    contracts {
        transitive = false
    }
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>将公共存储库依赖项添加到您的类路径中，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    contracts "${conractsGroupId}:${contractsArtifactId}:${contractsVersion}"
    testCompile "${conractsGroupId}:${contractsArtifactId}:${contractsVersion}"
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>将依赖项下载到适当的文件夹，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task getContracts(type: Copy) {
    from configurations.contracts
    into new File(project.buildDir, "downloadedContracts")
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>解压缩JAR，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task unzipContracts(type: Copy) {
    def zipFile = new File(project.buildDir, "downloadedContracts/${contractsArtifactId}-${contractsVersion}.jar")
    def outputDir = file("${buildDir}/unpackedContracts")

    from zipTree(zipFile)
    into outputDir
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>清理未使用的合同，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task deleteUnwantedContracts(type: Delete) {
    delete fileTree(dir: "${buildDir}/unpackedContracts",
        include: "**/*",
        excludes: [
            "**/${project.name}/**"",
            "**/${first-topic}/**",
            "**/${second-topic}/**"])
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>创建任务依赖项，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">unzipContracts.dependsOn("getContracts")
deleteUnwantedContracts.dependsOn("unzipContracts")
build.dependsOn("deleteUnwantedContracts")</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>通过指定包含合同的目录，通过设置插件来配置插件<code>contractsDslDir</code>属性，如下所示：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    contractsDslDir = new File("${buildDir}/unpackedContracts")
}</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-use-git-as-storage"><a class="anchor" href="#how-to-use-git-as-storage"></a> <a class="link" href="#how-to-use-git-as-storage">14.8.6。如何使用Git作为合同和存根的存储？</a></h4>
<div class="paragraph">
<p>在多语言的世界中，有些语言不像Artifactory或Nexus那样使用二进制存储。从Spring Cloud Contract版本2.0.0开始，我们提供了将合同和存根存储在SCM（源代码管理）存储库中的机制。当前，唯一支持的SCM是Git。</p>
</div>
<div class="paragraph">
<p>存储库必须具有以下设置（您可以从<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/contracts_git/">此处</a>签出）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>.
└── META-INF
    └── com.example
        └── beer-api-producer-git
            └── 0.0.1-SNAPSHOT
                ├── contracts
                │   └── beer-api-consumer
                │       ├── messaging
                │       │   ├── shouldSendAcceptedVerification.groovy
                │       │   └── shouldSendRejectedVerification.groovy
                │       └── rest
                │           ├── shouldGrantABeerIfOldEnough.groovy
                │           └── shouldRejectABeerIfTooYoung.groovy
                └── mappings
                    └── beer-api-consumer
                        └── rest
                            ├── shouldGrantABeerIfOldEnough.json
                            └── shouldRejectABeerIfTooYoung.json</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在下面<code>META-INF</code>夹：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们将申请分组<code>groupId</code> （如<code>com.example</code> ）。</p>
</li>
<li>
<p>每个应用程序都由其表示<code>artifactId</code> （例如， <code>beer-api-producer-git</code> ）。</p>
</li>
<li>
<p>接下来，每个应用程序都按其版本进行组织（例如<code>0.0.1-SNAPSHOT</code> ）。从Spring Cloud Contract版本开始<code>2.1.0</code> ，您可以指定以下版本（假设您的版本遵循语义版本控制）：</p>
<div class="ulist">
<ul>
<li>
<p><code>+</code>要么<code>latest</code> ：查找存根的最新版本（假设快照始终是给定修订版本的最新工件）。这意味着：</p>
<div class="ulist">
<ul>
<li>
<p>如果你有<code>1.0.0.RELEASE</code> ， <code>2.0.0.BUILD-SNAPSHOT</code>和<code>2.0.0.RELEASE</code> ，我们假设最新的是<code>2.0.0.BUILD-SNAPSHOT</code> 。</p>
</li>
<li>
<p>如果你有<code>1.0.0.RELEASE</code>和<code>2.0.0.RELEASE</code> ，我们假设最新的是<code>2.0.0.RELEASE</code> 。</p>
</li>
<li>
<p>如果您有一个名为<code>latest</code>要么<code>+</code> ，我们将选择该文件夹。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>release</code> ：查找存根的最新发行版。这意味着：</p>
<div class="ulist">
<ul>
<li>
<p>如果你有<code>1.0.0.RELEASE</code> ， <code>2.0.0.BUILD-SNAPSHOT</code>和<code>2.0.0.RELEASE</code>我们认为最新的是<code>2.0.0.RELEASE</code> 。</p>
</li>
<li>
<p>如果您有一个名为<code>release</code> ，我们选择该文件夹。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，有两个文件夹：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>contracts</code> ：最佳做法是将每个使用者所需的合同存储在具有使用者名称（例如<code>beer-api-consumer</code> ）。这样，您可以使用<code>stubs-per-consumer</code>特征。进一步的目录结构是任意的。</p>
</li>
<li>
<p><code>mappings</code> ：Maven或Gradle Spring Cloud Contract插件将存根服务器映射推送到此文件夹中。在使用者方面，Stub Runner扫描此文件夹以使用存根定义启动存根服务器。文件夹结构是在<code>contracts</code>子文件夹。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="how-to-protocol-convention"><a class="anchor" href="#how-to-protocol-convention"></a> <a class="link" href="#how-to-protocol-convention">协议公约</a></h5>
<div class="paragraph">
<p>要控制合同来源（二进制存储或SCM存储库）的类型和位置，可以在存储库URL中使用协议。Spring Cloud Contract遍历已注册的协议解析器，并尝试获取合同（通过使用插件）或存根（从Stub Runner）。</p>
</div>
<div class="paragraph">
<p>目前，对于SCM功能，我们支持Git存储库。要使用它，在需要放置存储库URL的属性中，必须为连接URL加上前缀<code>git://</code> 。以下清单显示了一些示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>git://file:///foo/bar
git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git
git://git@github.com:spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-to-protocol-convention-producer"><a class="anchor" href="#how-to-protocol-convention-producer"></a> <a class="link" href="#how-to-protocol-convention-producer">制片人</a></h5>
<div class="paragraph">
<p>对于生产者，要使用SCM（源代码管理管理）方法，我们可以重用与外部合同相同的机制。我们将Spring Cloud Contract路由为从以<code>git://</code>协议。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">您必须手动添加<code>pushStubsToScm</code>在Maven中实现目标或执行（绑定） <code>pushStubsToScm</code> Gradle中的任务。我们不会将存根推送到<code>origin</code>您的git存储库。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下清单包括Maven和Gradle构建文件的相关部分：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- Base class mappings etc. -->

        <!-- We want to pick contracts from a Git repository -->
        <contractsRepositoryUrl>git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git</contractsRepositoryUrl>

        <!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts -->
        <contractDependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>${project.artifactId}</artifactId>
            <version>${project.version}</version>
        </contractDependency>

        <!-- The contracts mode can't be classpath -->
        <contractsMode>REMOTE</contractsMode>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal -->
                <goal>pushStubsToScm</goal>
            </goals>
        </execution>
    </executions>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
    // We want to pick contracts from a Git repository
    contractDependency {
        stringNotation = "${project.group}:${project.name}:${project.version}"
    }
    /*
    We reuse the contract dependency section to set up the path
    to the folder that contains the contract definitions. In our case the
    path will be /groupId/artifactId/version/contracts
     */
    contractRepository {
        repositoryUrl = "git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git"
    }
    // The mode can't be classpath
    contractsMode = "REMOTE"
    // Base class mappings etc.
}

/*
In this scenario we want to publish stubs to SCM whenever
the `publish` task is executed
*/
publish.dependsOn("publishStubsToScm")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这样的设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>git项目被克隆到一个临时目录</p>
</li>
<li>
<p>SCM存根下载器转到<code>META-INF/groupId/artifactId/version/contracts</code>文件夹中查找合同。例如，对于<code>com.example:foo:1.0.0</code> ，路径将是<code>META-INF/com.example/foo/1.0.0/contracts</code> 。</p>
</li>
<li>
<p>测试是根据合同生成的。</p>
</li>
<li>
<p>存根是根据合同创建的。</p>
</li>
<li>
<p>一旦测试通过，则将存根提交到克隆的存储库中。</p>
</li>
<li>
<p>最后，将推送发送到该回购协议的<code>origin</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="how-to-protocol-convention-producer-with-contracts-stored-locally"><a class="anchor" href="#how-to-protocol-convention-producer-with-contracts-stored-locally"></a> <a class="link" href="#how-to-protocol-convention-producer-with-contracts-stored-locally">生产者，合同存储在本地</a></h5>
<div class="paragraph">
<p>将SCM用作存根和合同目的地的另一种选择是与生产者一起在本地存储合同，并且仅将合同和存根推送到SCM。以下清单显示了使用Maven和Gradle实现此目的所需的设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <!-- In the default configuration, we want to use the contracts stored locally -->
    <configuration>
        <baseClassMappings>
            <baseClassMapping>
                <contractPackageRegex>.*messaging.*</contractPackageRegex>
                <baseClassFQN>com.example.BeerMessagingBase</baseClassFQN>
            </baseClassMapping>
            <baseClassMapping>
                <contractPackageRegex>.*rest.*</contractPackageRegex>
                <baseClassFQN>com.example.BeerRestBase</baseClassFQN>
            </baseClassMapping>
        </baseClassMappings>
        <basePackageForTests>com.example</basePackageForTests>
    </configuration>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <!-- By default we will not push the stubs back to SCM,
                you have to explicitly add it as a goal -->
                <goal>pushStubsToScm</goal>
            </goals>
            <configuration>
                <!-- We want to pick contracts from a Git repository -->
                <contractsRepositoryUrl>git://file://${env.ROOT}/target/contract_empty_git/
                </contractsRepositoryUrl>
                <!-- Example of URL via git protocol -->
                <!--<contractsRepositoryUrl>git://git@github.com:spring-cloud-samples/spring-cloud-contract-samples.git</contractsRepositoryUrl>-->
                <!-- Example of URL via http protocol -->
                <!--<contractsRepositoryUrl>git://https://github.com/spring-cloud-samples/spring-cloud-contract-samples.git</contractsRepositoryUrl>-->
                <!-- We reuse the contract dependency section to set up the path
                to the folder that contains the contract definitions. In our case the
                path will be /groupId/artifactId/version/contracts -->
                <contractDependency>
                    <groupId>${project.groupId}</groupId>
                    <artifactId>${project.artifactId}</artifactId>
                    <version>${project.version}</version>
                </contractDependency>
                <!-- The mode can't be classpath -->
                <contractsMode>LOCAL</contractsMode>
            </configuration>
        </execution>
    </executions>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">contracts {
        // Base package for generated tests
    basePackageForTests = "com.example"
    baseClassMappings {
        baseClassMapping(".*messaging.*", "com.example.BeerMessagingBase")
        baseClassMapping(".*rest.*", "com.example.BeerRestBase")
    }
}

/*
In this scenario we want to publish stubs to SCM whenever
the `publish` task is executed
*/
publishStubsToScm {
    // We want to modify the default set up of the plugin when publish stubs to scm is called
    customize {
        // We want to pick contracts from a Git repository
        contractDependency {
            stringNotation = "${project.group}:${project.name}:${project.version}"
        }
        /*
        We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts
         */
        contractRepository {
            repositoryUrl = "git://file://${new File(project.rootDir, "../target")}/contract_empty_git/"
        }
        // The mode can't be classpath
        contractsMode = "LOCAL"
    }
}

publish.dependsOn("publishStubsToScm")
publishToMavenLocal.dependsOn("publishStubsToScm")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这样的设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>违约合同<code>src/test/resources/contracts</code>目录被选中。</p>
</li>
<li>
<p>测试是根据合同生成的。</p>
</li>
<li>
<p>存根是根据合同创建的。</p>
</li>
<li>
<p>一旦测试通过：</p>
<div class="ulist">
<ul>
<li>
<p>git项目被克隆到一个临时目录。</p>
</li>
<li>
<p>存根和合同在克隆的存储库中提交。</p>
</li>
</ul>
</div>
</li>
<li>
<p>最后，推送到该存储库的<code>origin</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="how-to-protocol-convention-contracts-producer-stubs-external"><a class="anchor" href="#how-to-protocol-convention-contracts-producer-stubs-external"></a> <a class="link" href="#how-to-protocol-convention-contracts-producer-stubs-external">保持与生产者和外部存储库中的存根的合同</a></h5>
<div class="paragraph">
<p>您还可以将合同保留在生产者存储库中，但将存根保留在外部git存储库中。当您想使用基本的消费者-生产者协作流程但不能使用工件存储库来存储存根时，这是最有用的。</p>
</div>
<div class="paragraph">
<p>为此，请使用常规的生产者设置，然后添加<code>pushStubsToScm</code>目标和设定<code>contractsRepositoryUrl</code>到要保留存根的存储库。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-protocol-convention-contracts-producer-stubs-external-consumer"><a class="anchor" href="#how-to-protocol-convention-contracts-producer-stubs-external-consumer"></a> <a class="link" href="#how-to-protocol-convention-contracts-producer-stubs-external-consumer">消费者</a></h5>
<div class="paragraph">
<p>在消费者方面，通过<code>repositoryRoot</code>参数，从<code>@AutoConfigureStubRunner</code>注释，JUnit规则，JUnit 5扩展或属性，您可以传递SCM存储库的URL，该URL的前缀为<code>git://</code>协议。以下示例显示了如何执行此操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoConfigureStubRunner(
    stubsMode="REMOTE",
    repositoryRoot="git://https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs-contracts-git.git",
    ids="com.example:bookstore:0.0.1.RELEASE"
)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这样的设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>git项目被克隆到一个临时目录。</p>
</li>
<li>
<p>SCM存根下载器转到<code>META-INF/groupId/artifactId/version/</code>文件夹以查找存根定义和合同。例如，对于<code>com.example:foo:1.0.0</code> ，路径将是<code>META-INF/com.example/foo/1.0.0/</code> 。</p>
</li>
<li>
<p>存根服务器启动，并提供映射。</p>
</li>
<li>
<p>在消息传递测试中读取并使用了消息传递定义。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-use-pact-broker"><a class="anchor" href="#how-to-use-pact-broker"></a> <a class="link" href="#how-to-use-pact-broker">14.8.7。如何使用契约代理？</a></h4>
<div class="paragraph">
<p>使用<a href="https://pact.io/">Pact时</a> ，可以使用<a href="https://github.com/pact-foundation/pact_broker">Pact Broker</a>来存储和共享Pact定义。从Spring Cloud Contract 2.0.0开始，您可以从Pact Broker获取Pact文件以生成测试和存根。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">条约遵循消费者合同约定。这意味着消费者首先创建契约约定，然后与生产者共享文件。这些期望是由消费者的代码产生的，如果不满足期望，则可能破坏生产者。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="how-to-use-pact-broker-pact"><a class="anchor" href="#how-to-use-pact-broker-pact"></a> <a class="link" href="#how-to-use-pact-broker-pact">如何达成协议</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract包括对<a href="https://docs.pact.io/">契约的Pact</a>表示的支持，直到版本4。除了使用DSL，您还可以使用Pact文件。在本节中，我们显示如何为您的项目添加Pact支持。但是请注意，并非所有功能都受支持。从版本3开始，您可以为同一个元素组合多个匹配器。您可以将匹配器用于正文，标头，请求和路径；您可以使用价值生成器。Spring Cloud Contract当前仅支持通过使用<code>AND</code>规则逻辑。紧接着，在转换过程中将跳过请求和路径匹配器。当使用具有给定格式的日期，时间或日期时间值生成器时，将跳过给定格式并使用ISO格式。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-use-pact-broker-pact-converter"><a class="anchor" href="#how-to-use-pact-broker-pact-converter"></a> <a class="link" href="#how-to-use-pact-broker-pact-converter">契约转换器</a></h5>
<div class="paragraph">
<p>为了正确支持Spring Cloud Contract与Pact进行消息传递的方式，您必须提供一些其他元数据条目。</p>
</div>
<div class="paragraph">
<p>要定义发送消息的目的地，您必须设置一个<code>metaData</code>在Pact文件中输入<code>sentTo</code>等于要向其发送消息的目的地的密钥（例如， <code>"metaData": { "sentTo": "activemq:output" }</code> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-use-pact-broker-pact-contract"><a class="anchor" href="#how-to-use-pact-broker-pact-contract"></a> <a class="link" href="#how-to-use-pact-broker-pact-contract">契约合同</a></h5>
<div class="paragraph">
<p>Spring Cloud Contract可以读取Pact JSON定义。您可以将文件放在<code>src/test/resources/contracts</code>夹。记得把<code>spring-cloud-contract-pact</code>对您的类路径的依赖。以下示例显示了这样的契约合同：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
  "provider": {
    "name": "Provider"
  },
  "consumer": {
    "name": "Consumer"
  },
  "interactions": [
    {
      "description": "",
      "request": {
        "method": "PUT",
        "path": "/pactfraudcheck",
        "headers": {
          "Content-Type": "application/json"
        },
        "body": {
          "clientId": "1234567890",
          "loanAmount": 99999
        },
        "generators": {
          "body": {
            "$.clientId": {
              "type": "Regex",
              "regex": "[0-9]{10}"
            }
          }
        },
        "matchingRules": {
          "header": {
            "Content-Type": {
              "matchers": [
                {
                  "match": "regex",
                  "regex": "application/json.*"
                }
              ],
              "combine": "AND"
            }
          },
          "body": {
            "$.clientId": {
              "matchers": [
                {
                  "match": "regex",
                  "regex": "[0-9]{10}"
                }
              ],
              "combine": "AND"
            }
          }
        }
      },
      "response": {
        "status": 200,
        "headers": {
          "Content-Type": "application/json"
        },
        "body": {
          "fraudCheckStatus": "FRAUD",
          "rejection.reason": "Amount too high"
        },
        "matchingRules": {
          "header": {
            "Content-Type": {
              "matchers": [
                {
                  "match": "regex",
                  "regex": "application/json.*"
                }
              ],
              "combine": "AND"
            }
          },
          "body": {
            "$.fraudCheckStatus": {
              "matchers": [
                {
                  "match": "regex",
                  "regex": "FRAUD"
                }
              ],
              "combine": "AND"
            }
          }
        }
      }
    }
  ],
  "metadata": {
    "pact-specification": {
      "version": "3.0.0"
    },
    "pact-jvm": {
      "version": "3.5.13"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-to-use-pact-broker-pact-for-producers"><a class="anchor" href="#how-to-use-pact-broker-pact-for-producers"></a> <a class="link" href="#how-to-use-pact-broker-pact-for-producers">生产者契约</a></h5>
<div class="paragraph">
<p>在生产者端，您必须在插件配置中添加两个其他依赖项。一个是Spring Cloud Contract Pact支持，另一个是您使用的当前Pact版本。以下清单显示了如何对Maven和Gradle进行操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">// if additional dependencies are needed e.g. for Pact
classpath "org.springframework.cloud:spring-cloud-contract-pact:${findProperty('verifierVersion') ?: verifierVersion}"</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当您执行应用程序的构建时，将生成一个测试和存根。以下示例显示了来自此过程的测试和存根：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">测试</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
    public void validate_shouldMarkClientAsFraud() throws Exception {
        // given:
            MockMvcRequestSpecification request = given()
                    .header("Content-Type", "application/vnd.fraud.v1+json")
                    .body("{\"clientId\":\"1234567890\",\"loanAmount\":99999}");

        // when:
            ResponseOptions response = given().spec(request)
                    .put("/fraudcheck");

        // then:
            assertThat(response.statusCode()).isEqualTo(200);
            assertThat(response.header("Content-Type")).matches("application/vnd\\.fraud\\.v1\\+json.*");
        // and:
            DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
            assertThatJson(parsedJson).field("['rejectionReason']").isEqualTo("Amount too high");
        // and:
            assertThat(parsedJson.read("$.fraudCheckStatus", String.class)).matches("FRAUD");
    }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">存根</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id" : "996ae5ae-6834-4db6-8fac-358ca187ab62",
  "uuid" : "996ae5ae-6834-4db6-8fac-358ca187ab62",
  "request" : {
    "url" : "/fraudcheck",
    "method" : "PUT",
    "headers" : {
      "Content-Type" : {
        "matches" : "application/vnd\\.fraud\\.v1\\+json.*"
      }
    },
    "bodyPatterns" : [ {
      "matchesJsonPath" : "$[?(@.['loanAmount'] = 99999)]"
    }, {
      "matchesJsonPath" : "$[?(@.clientId =~ /([0-9]{10})/)]"
    } ]
  },
  "response" : {
    "status" : 200,
    "body" : "{\"fraudCheckStatus\":\"FRAUD\",\"rejectionReason\":\"Amount too high\"}",
    "headers" : {
      "Content-Type" : "application/vnd.fraud.v1+json;charset=UTF-8"
    },
    "transformers" : [ "response-template" ]
  },
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="how-to-use-pact-broker-pact-consumers"><a class="anchor" href="#how-to-use-pact-broker-pact-consumers"></a> <a class="link" href="#how-to-use-pact-broker-pact-consumers">消费者契约</a></h5>
<div class="paragraph">
<p>在使用者方面，您必须在项目依赖项中添加两个其他依赖项。一个是Spring Cloud Contract Pact支持，另一个是您使用的当前Pact版本。以下清单显示了如何对Maven和Gradle进行操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">马文</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇篮</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy"></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pact-stub-downloader"><a class="anchor" href="#pact-stub-downloader"></a> <a class="link" href="#pact-stub-downloader">与契约经纪人沟通</a></h5>
<div class="paragraph">
<p>每当<code>repositoryRoot</code>属性以Pact协议开头（以<code>pact://</code> ），存根下载器将尝试从Pact Broker中获取Pact合同定义。以后设置什么<code>pact://</code>被解析为Pact Broker URL。</p>
</div>
<div class="paragraph">
<p>通过设置环境变量，系统属性或在插件或合同存储库配置中设置的属性，可以调整下载程序的行为。下表描述了这些属性：</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表5。契约存根下载器属性</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">物业名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.host</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.host</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_HOST</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主机从URL传递到<code>repositoryRoot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">契约经纪人的URL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.port</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.port</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_PORT</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL的端口传递到<code>repositoryRoot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pact Broker的端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.protocol</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.protocol</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_PROTOCOL</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL的协议传递给<code>repositoryRoot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pact Broker的协议。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.tags</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.tags</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_TAGS</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根的版本，或<code>latest</code>如果版本是<code>+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该用于获取存根的标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.auth.scheme</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.auth.scheme</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_AUTH_SCHEME</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Basic</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于连接至Pact Broker的身份验证类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.auth.username</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.auth.username</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_AUTH_USERNAME</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户名传递给<code>contractsRepositoryUsername</code> （专家）或<code>contractRepository.username</code> （等级）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到Pact Broker时使用的用户名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.auth.password</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.auth.password</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_AUTH_PASSWORD</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">密码传递给<code>contractsRepositoryPassword</code> （专家）或<code>contractRepository.password</code> （等级）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到Pact Broker时使用的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">* <code>pactbroker.provider-name-with-group-id</code> （插件道具）</p>
<p class="tableblock">* <code>stubrunner.properties.pactbroker.provider-name-with-group-id</code> （系统道具）</p>
<p class="tableblock">* <code>STUBRUNNER_PROPERTIES_PACTBROKER_PROVIDER_NAME_WITH_GROUP_ID</code> （环境道具）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">什么时候<code>true</code> ，提供者名称是<code>groupId:artifactId</code> 。如果<code>false</code> ， 只要<code>artifactId</code>用来。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="how-to-pact-consumer"><a class="anchor" href="#how-to-pact-consumer"></a> <a class="link" href="#how-to-pact-consumer">流程：与Pact Broker签订的消费者合同方法|消费者方</a></h5>
<div class="paragraph">
<p>使用者使用Pact框架生成Pact文件。该契约文件将发送到契约代理。您可以<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/consumer_pact">在此处</a>找到此类设置的示例。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-pact-producer"><a class="anchor" href="#how-to-pact-producer"></a> <a class="link" href="#how-to-pact-producer">流程：与生产者方面的契约经纪人签订的消费者合同方法</a></h5>
<div class="paragraph">
<p>为了使生产者能够使用Pact Broker中的Pact文件，我们可以重复使用与外部合同相同的机制。我们将Spring Cloud Contract路由为将Pact实现与包含以下内容的URL一起使用<code>pact://</code>协议。您可以将URL传递给Pact Broker。您可以<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/producer_pact">在此处</a>找到此类设置的示例。以下清单显示了Maven和Gradle的配置详细信息：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!-- Base class mappings etc. -->

        <!-- We want to pick contracts from a Git repository -->
        <contractsRepositoryUrl>pact://http://localhost:8085</contractsRepositoryUrl>

        <!-- We reuse the contract dependency section to set up the path
        to the folder that contains the contract definitions. In our case the
        path will be /groupId/artifactId/version/contracts -->
        <contractDependency>
            <groupId>${project.groupId}</groupId>
            <artifactId>${project.artifactId}</artifactId>
            <!-- When + is passed, a latest tag will be applied when fetching pacts -->
            <version>+</version>
        </contractDependency>

        <!-- The contracts mode can't be classpath -->
        <contractsMode>REMOTE</contractsMode>
    </configuration>
    <!-- Don't forget to add spring-cloud-contract-pact to the classpath! -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-contract-pact</artifactId>
            <version>${spring-cloud-contract.version}</version>
        </dependency>
    </dependencies>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        //...
    }

    dependencies {
        // ...
        // Don't forget to add spring-cloud-contract-pact to the classpath!
        classpath "org.springframework.cloud:spring-cloud-contract-pact:${contractVersion}"
    }
}

contracts {
    // When + is passed, a latest tag will be applied when fetching pacts
    contractDependency {
        stringNotation = "${project.group}:${project.name}:+"
    }
    contractRepository {
        repositoryUrl = "pact://http://localhost:8085"
    }
    // The mode can't be classpath
    contractsMode = "REMOTE"
    // Base class mappings etc.
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这样的设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>契约文件是从契约代理下载的。</p>
</li>
<li>
<p>Spring Cloud Contract将Pact文件转换为测试和存根。</p>
</li>
<li>
<p>像往常一样，带有存根的JAR会自动创建。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="how-to-pact-consumer-producer-contract"><a class="anchor" href="#how-to-pact-consumer-producer-contract"></a> <a class="link" href="#how-to-pact-consumer-producer-contract">流程：在消费者方面具有契约的生产者合同方法</a></h5>
<div class="paragraph">
<p>在您不想执行消费者合同方法（为每个消费者定义期望）但您更愿意执行生产者合同（生产者提供合同并发布存根）的情况下，可以将Spring Cloud Contract与Stub Runner选项。您可以<a href="https://github.com/spring-cloud-samples/spring-cloud-contract-samples/tree/2.2.x/consumer_pact_stubrunner">在此处</a>找到此类设置的示例。</p>
</div>
<div class="paragraph">
<p>切记添加Stub Runner和Spring Cloud Contract Pact模块作为测试依赖项。</p>
</div>
<div class="paragraph">
<p>以下清单显示了Maven和Gradle的配置详细信息：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- Don't forget to add spring-cloud-contract-pact to the classpath! -->
<dependencies>
    <!-- ... -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-contract-pact</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
    }
}

dependencies {
    //...
    testCompile("org.springframework.cloud:spring-cloud-starter-contract-stub-runner")
    // Don't forget to add spring-cloud-contract-pact to the classpath!
    testCompile("org.springframework.cloud:spring-cloud-contract-pact")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，您可以将Pact Broker的URL传递到<code>repositoryRoot</code> ，以开头<code>pact://</code>协议（例如， <code>pact://http://localhost:8085</code> ），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureStubRunner(stubsMode = StubRunnerProperties.StubsMode.REMOTE,
        ids = "com.example:beer-api-producer-pact",
        repositoryRoot = "pact://http://localhost:8085")
public class BeerControllerTest {
    //Inject the port of the running stub
    @StubRunnerPort("beer-api-producer-pact") int producerPort;
    //...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这样的设置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>契约文件是从契约代理下载的。</p>
</li>
<li>
<p>Spring Cloud Contract将Pact文件转换为存根定义。</p>
</li>
<li>
<p>存根服务器将启动并被存入存根。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-debug"><a class="anchor" href="#how-to-debug"></a> <a class="link" href="#how-to-debug">14.8.8。如何调试生成的测试客户端发送的请求/响应？</a></h4>
<div class="paragraph">
<p>生成的测试全部以某种形式或方式归结为RestAssured。RestAssured依赖于<a href="https://hc.apache.org/httpcomponents-client-ga/">Apache HttpClient</a> 。HttpClient具有一种称为<a href="https://hc.apache.org/httpcomponents-client-ga/logging.html#Wire_Logging">Wire logging的功能</a> ，该功能会将整个请求和响应记录到HttpClient中。Spring Boot具有一个日志记录<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">通用应用程序属性，</a>用于执行此类操作。要使用它，请将其添加到您的应用程序属性中，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.org.apache.http.wire=DEBUG</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-debug-wiremock"><a class="anchor" href="#how-to-debug-wiremock"></a> <a class="link" href="#how-to-debug-wiremock">14.8.9。如何调试WireMock发送的映射，请求或响应？</a></h4>
<div class="paragraph">
<p>从版本开始<code>1.2.0</code> ，我们打开WireMock日志记录到<code>info</code>并将WireMock通知程序设置为冗长。现在，您可以确切知道WireMock服务器收到了什么请求，以及选择了哪个匹配的响应定义。</p>
</div>
<div class="paragraph">
<p>要关闭此功能，请将WireMock日志记录设置为<code>ERROR</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">logging.level.com.github.tomakehurst.wiremock=ERROR</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-see-registered-stubs"><a class="anchor" href="#how-to-see-registered-stubs"></a> <a class="link" href="#how-to-see-registered-stubs">14.8.10。如何查看HTTP Server存根中注册了什么？</a></h4>
<div class="paragraph">
<p>您可以使用<code>mappingsOutputFolder</code>财产<code>@AutoConfigureStubRunner</code> ， <code>StubRunnerRule</code>或`StubRunnerExtension`以按工件ID转储所有映射。还连接了启动给定存根服务器的端口。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-reference-text-from-file"><a class="anchor" href="#how-to-reference-text-from-file"></a> <a class="link" href="#how-to-reference-text-from-file">14.8.11。如何引用文件中的文本？</a></h4>
<div class="paragraph">
<p>在1.2.0版中，我们添加了此功能。你可以打电话给<code>file(…​)</code> DSL中的方法，并提供相对于合同所在位置的路径。如果您使用YAML，则可以使用<code>bodyFromFile</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-generate-pact-from-scc"><a class="anchor" href="#how-to-generate-pact-from-scc"></a> <a class="link" href="#how-to-generate-pact-from-scc">14.8.12。如何从Spring Cloud合同生成合同，YAML或X文件？</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract附带了一个<code>ToFileContractsTransformer</code>允许您将合同转储为给定文件的类<code>ContractConverter</code> 。它包含一个<code>static void main</code>使您可以将转换器作为可执行文件执行的方法。它采用以下参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>参数1： <code>FQN</code> ：的全限定名称<code>ContractConverter</code> （例如， <code>PactContractConverter</code> ）。<strong>必需的</strong> 。</p>
</li>
<li>
<p>论点2： <code>path</code> ：应存储转储文件的路径。<strong>可选</strong> -默认为<code>target/converted-contracts</code> 。</p>
</li>
<li>
<p>论点3： <code>path</code> ：应搜索合同的路径。<strong>可选</strong> -默认为<code>src/test/resources/contracts</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>执行完转换器后，将处理Spring Cloud Contract文件，具体取决于所提供的FQN <code>ContractTransformer</code> ，合同将转换为所需格式并转储到提供的文件夹中。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何为Maven和Gradle配置Pact集成：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>exec-maven-plugin</artifactId>
    <version>1.6.0</version>
    <executions>
        <execution>
            <id>convert-dsl-to-pact</id>
            <phase>process-test-classes</phase>
            <configuration>
                <classpathScope>test</classpathScope>
                <mainClass>
                    org.springframework.cloud.contract.verifier.util.ToFileContractsTransformer
                </mainClass>
                <arguments>
                    <argument>
                        org.springframework.cloud.contract.verifier.spec.pact.PactContractConverter
                    </argument>
                    <argument>${project.basedir}/target/pacts</argument>
                    <argument>
                        ${project.basedir}/src/test/resources/contracts
                    </argument>
                </arguments>
            </configuration>
            <goals>
                <goal>java</goal>
            </goals>
        </execution>
    </executions>
</plugin></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">task convertContracts(type: JavaExec) {
    main = "org.springframework.cloud.contract.verifier.util.ToFileContractsTransformer"
    classpath = sourceSets.test.compileClasspath
    args("org.springframework.cloud.contract.verifier.spec.pact.PactContractConverter",
            "${project.rootDir}/build/pacts", "${project.rootDir}/src/test/resources/contracts")
}

test.dependsOn("convertContracts")</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-work-with-transitivie"><a class="anchor" href="#how-to-work-with-transitivie"></a> <a class="link" href="#how-to-work-with-transitivie">14.8.13。如何处理传递依赖项？</a></h4>
<div class="paragraph">
<p>Spring Cloud Contract插件添加了为您创建存根jar的任务。出现的一个问题是，当重用存根时，您可能会错误地导入该存根的所有依赖项。构建Maven工件时，即使您有几个不同的罐子，它们也共享一个pom，如以下清单所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">├── producer-0.0.1.BUILD-20160903.075506-1-stubs.jar
├── producer-0.0.1.BUILD-20160903.075506-1-stubs.jar.sha1
├── producer-0.0.1.BUILD-20160903.075655-2-stubs.jar
├── producer-0.0.1.BUILD-20160903.075655-2-stubs.jar.sha1
├── producer-0.0.1.BUILD-SNAPSHOT.jar
├── producer-0.0.1.BUILD-SNAPSHOT.pom
├── producer-0.0.1.BUILD-SNAPSHOT-stubs.jar
├── ...
└── ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用这些依赖项有三种可能性，以使传递依赖项没有任何问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将所有应用程序依赖项标记为可选</p>
</li>
<li>
<p>为存根创建一个单独的artifactid</p>
</li>
<li>
<p>排除消费者方面的依赖</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="how-to-work-with-transitivie-optional"><a class="anchor" href="#how-to-work-with-transitivie-optional"></a> <a class="link" href="#how-to-work-with-transitivie-optional">如何将所有应用程序依赖项标记为可选？</a></h5>
<div class="paragraph">
<p>如果，在<code>producer</code>应用程序，当您包含<code>producer</code>然后，由于所有依赖项都是可选的，因此不会下载另一个应用程序中的存根（或当Stub Runner下载该依赖项时）。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-work-with-transitivie-separate"><a class="anchor" href="#how-to-work-with-transitivie-separate"></a> <a class="link" href="#how-to-work-with-transitivie-separate">如何创建单独的<code>artifactid</code>存根？</a></h5>
<div class="paragraph">
<p>如果您创建一个单独的<code>artifactid</code> ，您可以按照自己的方式进行设置。例如，您可能决定完全没有依赖项。</p>
</div>
</div>
<div class="sect4">
<h5 id="how-to-work-with-transitivie-exclude"><a class="anchor" href="#how-to-work-with-transitivie-exclude"></a> <a class="link" href="#how-to-work-with-transitivie-exclude">如何排除消费者方面的依赖关系？</a></h5>
<div class="paragraph">
<p>作为使用者，如果将存根依赖项添加到类路径中，则可以显式排除不需要的依赖项。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="contract-dsl-rest-docs"><a class="anchor" href="#contract-dsl-rest-docs"></a> <a class="link" href="#contract-dsl-rest-docs">14.8.14。如何从合同中生成Spring REST文档片段？</a></h4>
<div class="paragraph">
<p>如果要使用Spring REST Docs包含API的请求和响应，则仅在使用MockMvc和RestAssuredMockMvc时才需要对设置进行一些小的更改。为此，请包括以下依赖项（如果尚未这样做）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">专家</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-verifier</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework.restdocs</groupId>
    <artifactId>spring-restdocs-mockmvc</artifactId>
    <optional>true</optional>
</dependency></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">摇动</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">testCompile 'org.springframework.cloud:spring-cloud-starter-contract-verifier'
testCompile 'org.springframework.restdocs:spring-restdocs-mockmvc'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，您需要对基类进行一些更改。以下示例使用<code>WebAppContext</code>以及RestAssured的独立选项：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">WebAppContext</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.fraud;

import io.restassured.module.mockmvc.RestAssuredMockMvc;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.restdocs.JUnitRestDocumentation;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.documentationConfiguration;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public abstract class FraudBaseWithWebAppSetup {

    private static final String OUTPUT = "target/generated-snippets";

    @Rule
    public JUnitRestDocumentation restDocumentation = new JUnitRestDocumentation(OUTPUT);

    @Rule
    public TestName testName = new TestName();

    @Autowired
    private WebApplicationContext context;

    @Before
    public void setup() {
        RestAssuredMockMvc.mockMvc(MockMvcBuilders.webAppContextSetup(this.context)
                .apply(documentationConfiguration(this.restDocumentation))
                .alwaysDo(document(
                        getClass().getSimpleName() + "_" + testName.getMethodName()))
                .build());
    }

    protected void assertThatRejectionReasonIsNull(Object rejectionReason) {
        assert rejectionReason == null;
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">单机版</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example.fraud;

import io.restassured.module.mockmvc.RestAssuredMockMvc;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;

import org.springframework.restdocs.JUnitRestDocumentation;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.documentationConfiguration;

public abstract class FraudBaseWithStandaloneSetup {

    private static final String OUTPUT = "target/generated-snippets";

    @Rule
    public JUnitRestDocumentation restDocumentation = new JUnitRestDocumentation(OUTPUT);

    @Rule
    public TestName testName = new TestName();

    @Before
    public void setup() {
        RestAssuredMockMvc.standaloneSetup(MockMvcBuilders
                .standaloneSetup(new FraudDetectionController())
                .apply(documentationConfiguration(this.restDocumentation))
                .alwaysDo(document(
                        getClass().getSimpleName() + "_" + testName.getMethodName())));
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">您无需为生成的代码片段指定输出目录（从1.2.0版开始）。Spring REST文档的发布）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="how-to-use-stubs-from-a-location"><a class="anchor" href="#how-to-use-stubs-from-a-location"></a> <a class="link" href="#how-to-use-stubs-from-a-location">14.8.15。如何从某个位置使用存根</a></h4>
<div class="paragraph">
<p>如果您想从给定位置获取合同或存根，而无需克隆存储库或获取JAR，只需使用<code>stubs://</code>提供Stub Runner或Spring Cloud Contract插件的存储库根参数时的协议。您可以在文档的<a href="project-features.html#features-stub-runner-stubs-protocol">此部分</a>中阅读有关此内容的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-generate-stubs-at-runtime"><a class="anchor" href="#how-to-generate-stubs-at-runtime"></a> <a class="link" href="#how-to-generate-stubs-at-runtime">14.8.16。如何在运行时生成存根</a></h4>
<div class="paragraph">
<p>如果您想在运行时为合同生成存根，则只需切换<code>generateStubs</code>物业<code>@AutoConfigureStubRunner</code>注释，或调用<code>withGenerateStubs(true)</code> JUnit规则或扩展上的方法。您可以在文档的<a href="project-features.html#features-stub-runner-generate-stubs-at-runtime">此部分</a>中阅读有关此内容的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-use-the-failonnostubs-feature"><a class="anchor" href="#how-to-use-the-failonnostubs-feature"></a> <a class="link" href="#how-to-use-the-failonnostubs-feature">14.8.17。如果没有合同或存根，我该如何通过建造通行证</a></h4>
<div class="paragraph">
<p>如果您希望Stub Runner在未找到存根的情况下不会失败，则只需切换<code>generateStubs</code>物业<code>@AutoConfigureStubRunner</code>注释，或调用<code>withFailOnNoStubs(false)</code> JUnit规则或扩展上的方法。您可以在文档的<a href="project-features.html#features-stub-runner-fail-on-no-stubs">此部分</a>中阅读有关此内容的更多信息。</p>
</div>
<div class="paragraph">
<p>如果您希望在未找到合同时插件不会使构建失败，则可以设置<code>failOnNoStubs</code>在Maven中标记或调用<code>contractRepository { failOnNoStubs(false) }</code>在Gradle中关闭。</p>
</div>
</div>
<div class="sect3">
<h4 id="how-to-mark-contract-in-progress"><a class="anchor" href="#how-to-mark-contract-in-progress"></a> <a class="link" href="#how-to-mark-contract-in-progress">14.8.18。如何标记合同正在进行中</a></h4>
<div class="paragraph">
<p>如果正在进行合同，则意味着不会生成生产者端的测试，但会生成存根。您可以在文档的<a href="project-features.html#contract-dsl-in-progress">此部分</a>中阅读有关此内容的更多信息。</p>
</div>
<div class="paragraph">
<p>在CI构建中，要投入生产，您要确保类路径上没有正在进行的合同。那是因为您可能会导致误报。因此，默认情况下，在Spring Cloud Contract插件中，我们设置了<code>failOnInProgress</code>至<code>true</code> 。如果要在生成测试时允许此类合同，只需将标志设置为<code>false</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="common-application-properties"><a class="anchor" href="#common-application-properties"></a> <a class="link" href="#common-application-properties">附录A：常见的应用程序属性</a></h4>
<div class="paragraph">
<p>您可以在内部指定各种属性<code>application.properties</code>文件，在您的内部<code>application.yml</code>文件，或作为命令行开关。本附录提供了常见的Spring Cloud Contract属性列表，并引用了使用它们的基础类。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">属性贡献可能来自类路径上的其他jar文件，因此您不应将其视为详尽的列表。另外，您可以定义自己的属性。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="default-application-properties"><a class="anchor" href="#default-application-properties"></a> <a class="link" href="#default-application-properties">默认应用程序属性</a></h5>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.amqp.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用对Stub Runner和AMQP的支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.amqp.mock连接</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用对Stub Runner和AMQP模拟连接工厂的支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.classifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，在常春藤坐标中用于存根的分类器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用stubrunner.cloud.consul。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在领事中启用存根注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.delegate.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用DiscoveryClient的Stub Runner实现。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否为Stub Runner启用Spring Cloud支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.eureka.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在尤里卡启用存根注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.ribbon.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner的Ribbon功能区集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用了stubrunner.cloud.stubbed.discovery。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否对Stub Runner存根Service Discovery。如果设置为false，则将在实时服务发现中注册存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在Zookeeper中启用存根注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.consumer-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您可以通过为此参数设置一个值来覆盖此字段的默认{@code spring.application.name}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.delete测试后存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置为{@code false}，则在运行测试后不会从临时文件夹中删除存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.failing-on-stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用后，如果未找到存根/合同，此标志将告诉存根运行器引发异常。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.generate-stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用后，此标志将告诉存根运行程序不加载生成的存根，而是在运行时将找到的合同转换为存根格式并运行这些存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.http-server-stub-configurer</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP服务器存根的配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.ids</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根的ID以“ ivy”表示法（[groupId]：artifactId：[version]：[classifier] [：port]）运行。 {@code groupId}，{@ code classifier}，{@ code version}和{@code port}是可选的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.ids到服务ID</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将基于常春藤表示法的ID映射到应用程序内的serviceId。示例“ a：b”→“ myService”“ artifactId”→“ myOtherService”</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.integration.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner与Spring Integration集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.jms.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner与Spring JMS集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.kafka.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用与Spring Kafka的Stub Runner集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.kafka.initializer.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否允许Stub Runner负责轮询消息而不是KafkaStubMessages组件。后者应仅在生产方使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.mappings-输出文件夹</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将每个HTTP服务器的映射转储到所选文件夹。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.max端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动启动的WireMock服务器的端口最大值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.min端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动启动的WireMock服务器的端口的最小值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">储存库密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以传递给自定义{@link org.springframework.cloud.contract.stubrunner的属性的地图。StubDownloaderBuilder}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.proxy主机</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库代理主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.proxy端口</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库代理端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.stream.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner与Spring Cloud Stream集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根模式</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择存根应该来自哪里。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个消费者的存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅应将此特定使用者的存根在HTTP服务器存根中注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">储存库用户名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.placeholders.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示应过滤生成的Wiremock存根中的http URL的标记，以添加或解析动态端口的占位符。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">已启用wiremock.rest-template-ssl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.https端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.https-port-dynamic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8080</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.port-dynamic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="additional-application-properties"><a class="anchor" href="#additional-application-properties"></a> <a class="link" href="#additional-application-properties">其他应用程序属性</a></h5>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">可以将以下属性作为系统属性来传递（例如， <code>stubrunner.properties.git.branch</code> ）或通过环境变量（例如<code>STUBRUNNER_PROPERTIES_GIT_BRANCH</code> ），也可以将其作为存根运行器注释或JUnit规则/扩展内的属性。在后一种情况下，您可以通过<code>git.branch</code>属性名称，而不是<code>stubrunner.properties.git.branch</code>一。
</td>
</tr>
</tbody></table>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表6。Stubrunner属性选项</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.pactbroker.provider-name-with-group-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于Pact Broker的方法时，可以自动将ID分组为提供程序名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.git.branch</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于SCM的方法时，您可以自定义分支名称以签出。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.git.commit-message</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用存根更新项目[$ project]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于SCM的方法时，可以为创建的存根定制提交消息。的<code>$project</code>文本将替换为项目名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.git。无尝试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于SCM的方法时，您可以自定义重试次数以将存根推送到Git。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.git。用户名</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于SCM的方法时，您可以传递用户名以连接到Git存储库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.git.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于SCM的方法时，您可以传递密码以连接到Git存储库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.git.wait-between-尝试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用基于SCM的方法时，您可以自定义尝试将存根推送到Git之间的等待时间（以毫秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties.stubs.find生产者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用存根协议时，您可以切换此标志以通过<code>group id / artifact id</code>而不是直接从提供的文件夹中提取存根。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div></div>
<div class="sect1">
<h2 id="spring-cloud-vault"><a class="anchor" href="#spring-cloud-vault"></a> <a class="link" href="#spring-cloud-vault">15Spring Cloud Vault</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>©2016-2019原作者。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<em>本文档的副本可以供您自己使用，也可以分发给他人，但前提是您不对此类副本收取任何费用，并且还应确保每份副本均包含本版权声明（无论是印刷版本还是电子版本）。</em>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Vault Config为分布式系统中的外部化配置提供了客户端支持。使用<a href="https://www.vaultproject.io">HashiCorp的保管库，</a>您可以在中心位置管理所有环境中应用程序的外部秘密属性。保险柜可以管理静态和动态机密，例如远程应用程序/资源的用户名/密码，并为外部服务（例如MySQL，PostgreSQL，Apache Cassandra，MongoDB，Consul，AWS等）提供凭据。</p>
</div>
<div class="sect2">
<h3 id="quick-start-3"><a class="anchor" href="#quick-start-3"></a> <a class="link" href="#quick-start-3">15.1。快速开始</a></h3>
<div class="paragraph">
<p><strong>先决条件</strong></p>
</div>
<div class="paragraph">
<p>要开始使用Vault和本指南，您需要一个类似* NIX的操作系统，该操作系统提供：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>wget</code> ， <code>openssl</code>和<code>unzip</code></p>
</li>
<li>
<p>至少Java 7和正确配置的<code>JAVA_HOME</code>环境变量</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>安装保险柜</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ src/test/bash/install_vault.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>为保险柜创建SSL证书</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ src/test/bash/create_certificates.sh</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>create_certificates.sh</code>在以下位置创建证书<code>work/ca</code>和JKS信任库<code>work/keystore.jks</code> 。如果要使用此快速入门指南运行Spring Cloud Vault，则需要配置信任库<code>spring.cloud.vault.ssl.trust-store</code>财产<code>file:work/keystore.jks</code> 。
</td>
</tr>
</tbody></table>
</div>
<div id="quickstart.vault.start" class="paragraph">
<p><strong>启动保险柜服务器</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ src/test/bash/local_run_vault.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>保管箱开始监听<code>0.0.0.0:8200</code>使用<code>inmem</code>储存和<code>https</code> 。启动时，保管箱已密封且未初始化。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果要运行测试，请使保管库未初始化。测试将初始化Vault并创建一个根令牌<code>00000000-0000-0000-0000-000000000000</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果要为应用程序使用保管箱或尝试使用保管箱，则需要先对其进行初始化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ export VAULT_ADDR="https://localhost:8200"
$ export VAULT_SKIP_VERIFY=true # Don't do this for production
$ vault init</code></pre>
</div>
</div>
<div class="paragraph">
<p>您应该看到类似以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">Key 1: 7149c6a2e16b8833f6eb1e76df03e47f6113a3288b3093faf5033d44f0e70fe701
Key 2: 901c534c7988c18c20435a85213c683bdcf0efcd82e38e2893779f152978c18c02
Key 3: 03ff3948575b1165a20c20ee7c3e6edf04f4cdbe0e82dbff5be49c63f98bc03a03
Key 4: 216ae5cc3ddaf93ceb8e1d15bb9fc3176653f5b738f5f3d1ee00cd7dccbe926e04
Key 5: b2898fc8130929d569c1677ee69dc5f3be57d7c4b494a6062693ce0b1c4d93d805
Initial Root Token: 19aefa97-cccc-bbbb-aaaa-225940e63d76

Vault initialized with 5 keys and a key threshold of 3. Please
securely distribute the above keys. When the Vault is re-sealed,
restarted, or stopped, you must provide at least 3 of these keys
to unseal it again.

Vault does not store the master key. Without at least 3 keys,
your Vault will remain permanently sealed.</code></pre>
</div>
</div>
<div class="paragraph">
<p>保管箱将初始化并返回一组启封密钥和根令牌。选择3个钥匙并解开保险柜。将保险柜令牌存储在<code>VAULT_TOKEN</code>环境变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ vault unseal (Key 1)
$ vault unseal (Key 2)
$ vault unseal (Key 3)
$ export VAULT_TOKEN=(Root token)
# Required to run Spring Cloud Vault tests after manual initialization
$ vault token-create -id="00000000-0000-0000-0000-000000000000" -policy="root"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Vault访问不同的资源。默认情况下，启用秘密后端，该后端通过JSON端点访问秘密配置设置。</p>
</div>
<div class="paragraph">
<p>HTTP服务具有以下形式的资源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/secret/{application}/{profile}
/secret/{application}
/secret/{defaultContext}/{profile}
/secret/{defaultContext}</pre>
</div>
</div>
<div class="paragraph">
<p>将“应用程序”作为<code>spring.application.name</code>在里面<code>SpringApplication</code> （即常规Spring Boot应用程序中通常的“应用程序”），“配置文件”是活动配置文件（或属性的逗号分隔列表）。从保管库检索到的属性将按原样使用，而无需进一步加前缀属性名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="client-side-usage-2"><a class="anchor" href="#client-side-usage-2"></a> <a class="link" href="#client-side-usage-2">15.2。客户端使用</a></h3>
<div class="paragraph">
<p>要在应用程序中使用这些功能，只需将其构建为依赖于<code>spring-cloud-vault-config</code> （例如，查看测试用例）。Maven配置示例：</p>
</div>
<div class="exampleblock">
<div class="title">例子4. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.0.0.RELEASE</version>
    <relativePath /> <!-- lookup parent from repository -->
</parent>

<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-vault-config</artifactId>
        <version>2.2.0.RC2</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

<!-- repositories also needed for snapshots and milestones --></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以创建一个标准的Spring Boot应用程序，例如以下简单的HTTP服务器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>运行时，它将从端口上的默认本地Vault服务器获取外部配置<code>8200</code>如果它正在运行。要修改启动行为，您可以使用以下方法更改Vault服务器的位置<code>bootstrap.properties</code> （喜欢<code>application.properties</code>但针对应用程序上下文的引导阶段），例如</p>
</div>
<div class="exampleblock">
<div class="title">例子5. bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    host: localhost
    port: 8200
    scheme: https
    uri: https://localhost:8200
    connection-timeout: 5000
    read-timeout: 15000
    config:
        order: -10</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>host</code>设置Vault主机的主机名。主机名将用于SSL证书验证</p>
</li>
<li>
<p><code>port</code>设置保管库端口</p>
</li>
<li>
<p><code>scheme</code>将方案设置为<code>http</code>将使用纯HTTP。支持的方案是<code>http</code>和<code>https</code> 。</p>
</li>
<li>
<p><code>uri</code>使用URI配置Vault端点。优先于主机/端口/方案配置</p>
</li>
<li>
<p><code>connection-timeout</code>设置连接超时（以毫秒为单位）</p>
</li>
<li>
<p><code>read-timeout</code>设置读取超时（以毫秒为单位）</p>
</li>
<li>
<p><code>config.order</code>设置属性来源的顺序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>启用进一步的集成需要附加的依赖关系和配置。根据您设置保险柜的方式，您可能需要其他配置，例如<a href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.ssl">SSL</a>和<a href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.authentication">身份验证</a> 。</p>
</div>
<div class="paragraph">
<p>如果应用程序导入了<code>spring-boot-starter-actuator</code>项目，可以通过以下方式查看Vault服务器的状态<code>/health</code>端点。</p>
</div>
<div class="paragraph">
<p>可以通过属性启用或禁用Vault运行状况指示器<code>management.health.vault.enabled</code> （默认为<code>true</code> ）。</p>
</div>
<div class="sect3">
<h4 id="authentication-2"><a class="anchor" href="#authentication-2"></a> <a class="link" href="#authentication-2">15.2.1。认证方式</a></h4>
<div class="paragraph">
<p>Vault需要一种<a href="https://www.vaultproject.io/docs/concepts/auth.html">身份验证机制</a>来<a href="https://www.vaultproject.io/docs/concepts/tokens.html">授权客户端请求</a> 。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Vault支持多种<a href="https://cloud.spring.io/spring-cloud-vault/spring-cloud-vault.html#vault.config.authentication">身份验证机制，</a>以通过Vault验证应用程序。</p>
</div>
<div class="paragraph">
<p>为了快速入门，请使用<a href="#quickstart.vault.start">保管库初始化</a>打印的根令牌。</p>
</div>
<div class="exampleblock">
<div class="title">例子6. bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    token: 19aefa97-cccc-bbbb-aaaa-225940e63d76</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">请仔细考虑您的安全要求。如果您想快速开始使用Vault，则可以使用静态令牌身份验证，但是静态令牌不再受到任何保护。向非预期方的任何披露都允许保险柜与关联的令牌角色一起使用。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.authentication"><a class="anchor" href="#vault.config.authentication"></a> <a class="link" href="#vault.config.authentication">15.3。认证方式</a></h3>
<div class="paragraph">
<p>不同的组织对安全性和身份验证有不同的要求。保险柜通过提供多种身份验证方法来反映这种需求。Spring Cloud Vault支持令牌和AppId身份验证。</p>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.token"><a class="anchor" href="#vault.config.authentication.token"></a> <a class="link" href="#vault.config.authentication.token">15.3.1。令牌认证</a></h4>
<div class="paragraph">
<p>令牌是保险柜中身份验证的核心方法。令牌认证要求使用<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/docs/src/main/asciidoc/spring-cloud-commons.adoc#the-bootstrap-application-context">Bootstrap应用程序上下文</a>提供静态令牌。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">令牌认证是默认的认证方法。如果公开了令牌，则意外的一方将获得对保险柜的访问权，并可以访问目标客户的机密。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">例子7. bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: TOKEN
    token: 00000000-0000-0000-0000-000000000000</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>authentication</code>将此值设置为<code>TOKEN</code>选择令牌认证方法</p>
</li>
<li>
<p><code>token</code>设置要使用的静态令牌</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/concepts/tokens.html">保险柜文件：令牌</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.appid"><a class="anchor" href="#vault.config.authentication.appid"></a> <a class="link" href="#vault.config.authentication.appid">15.3.2。AppId验证</a></h4>
<div class="paragraph">
<p>保管箱支持由两个难以猜测的令牌组成的<a href="https://www.vaultproject.io/docs/auth/app-id.html">AppId</a>身份验证。AppId默认为<code>spring.application.name</code>是静态配置的。第二个令牌是UserId，它是应用程序确定的一部分，通常与运行时环境有关。IP地址，Mac地址或Docker容器名称就是很好的例子。Spring Cloud Vault Config支持IP地址，Mac地址和静态UserId（例如，通过系统属性提供）。IP和Mac地址表示为十六进制编码的SHA256哈希。</p>
</div>
<div class="paragraph">
<p>基于IP地址的UserId使用本地主机的IP地址。</p>
</div>
<div class="exampleblock">
<div class="title">例子8.使用SHA256 IP地址UserId的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: IP_ADDRESS</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>authentication</code>将此值设置为<code>APPID</code>选择AppId身份验证方法</p>
</li>
<li>
<p><code>app-id-path</code>设置要使用的AppId安装的路径</p>
</li>
<li>
<p><code>user-id</code>设置UserId方法。可能的值为<code>IP_ADDRESS</code> ， <code>MAC_ADDRESS</code>或实现自定义的类名<code>AppIdUserIdMechanism</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>从命令行生成IP地址UserId的相应命令是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ echo -n 192.168.99.1 | sha256sum</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">包括换行符<code>echo</code>导致产生不同的哈希值，因此请确保包括<code>-n</code>旗。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>基于Mac地址的UserId从本地主机绑定的设备获取其网络设备。该配置还允许指定<code>network-interface</code>提示选择正确的设备。的价值<code>network-interface</code>是可选的，可以是接口名称或接口索引（从0开始）。</p>
</div>
<div class="exampleblock">
<div class="title">例子9.使用SHA256 Mac-Address用户ID的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: MAC_ADDRESS
        network-interface: eth0</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>network-interface</code>设置网络接口以获得物理地址</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>从命令行生成IP地址UserId的相应命令是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ echo -n 0AFEDE1234AC | sha256sum</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Mac地址指定为大写且没有冒号。包括换行符<code>echo</code>导致产生不同的哈希值，因此请确保包括<code>-n</code>旗。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="custom-userid"><a class="anchor" href="#custom-userid"></a> <a class="link" href="#custom-userid">自定义用户ID</a></h5>
<div class="paragraph">
<p>UserId生成是一种开放机制。你可以设定<code>spring.cloud.vault.app-id.user-id</code>设置为任何字符串，配置的值将用作静态UserId。</p>
</div>
<div class="paragraph">
<p>更高级的方法可让您设置<code>spring.cloud.vault.app-id.user-id</code>到一个类名。此类必须在您的类路径上，并且必须实现<code>org.springframework.cloud.vault.AppIdUserIdMechanism</code>界面和<code>createUserId</code>方法。Spring Cloud Vault将通过调用获取UserId <code>createUserId</code>每次它使用AppId进行身份验证以获得令牌时。</p>
</div>
<div class="exampleblock">
<div class="title">例子10. bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: APPID
    app-id:
        user-id: com.examlple.MyUserIdMechanism</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例11MyUserIdMechanism.java</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">public class MyUserIdMechanism implements AppIdUserIdMechanism {

  @Override
  public String createUserId() {
    String userId = ...
    return userId;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/app-id.html">保管库文档：使用App ID auth后端</a></p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="approle-authentication"><a class="anchor" href="#approle-authentication"></a> <a class="link" href="#approle-authentication">15.3.3。AppRole身份验证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/app-id.html">AppRole</a>用于机器身份验证，例如已过时（自Vault 0.6.1起）的<a href="#vault.config.authentication.appid">AppId身份验证</a> 。AppRole身份验证包含两个很难猜测（秘密）的令牌：RoleId和SecretId。</p>
</div>
<div class="paragraph">
<p>Spring Vault支持各种AppRole方案（推/拉模式和包装）。</p>
</div>
<div class="paragraph">
<p>RoleId和可选的SecretId必须由配置提供，Spring Vault不会查找它们或创建自定义SecretId。</p>
</div>
<div class="exampleblock">
<div class="title">例子12.具有AppRole身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: APPROLE
    app-role:
        role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>支持以下方案以及必需的配置详细信息：</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表7。组态</caption>
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>方法</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>角色编号</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>SecretId</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>角色名</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>代币</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供的RoleId / SecretId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供的RoleId不带SecretId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供的RoleId，Pull SecretId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉出RoleId，提供SecretId</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">全拉模式</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包装好的RoleId，提供SecretId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供的RoleId，包装好的SecretId</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表8。拉/推/包裹矩阵</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>角色编号</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>SecretId</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>支持的</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缺席</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缺席</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✅</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">包裹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缺席</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❌</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您还可以通过提供已配置的配置来使用推/拉/包模式的所有组合<code>AppRoleAuthentication</code>引导上下文中的bean。Spring Cloud Vault无法从配置属性中导出所有可能的AppRole组合。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">AppRole身份验证仅限于使用反应式基础结构的简单拉模式。尚不支持全拉模式。将Spring Cloud Vault与Spring WebFlux堆栈一起使用可启用Vault的反应式自动配置，可通过设置来禁用<code>spring.cloud.vault.reactive.enabled=false</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">例子13.具有所有AppRole身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: APPROLE
    app-role:
        role-id: bde2076b-cccb-3cf0-d57e-bca7b1e83a52
        secret-id: 1696536f-1976-73b1-b241-0b4213908d39
        role: my-role
        app-role-path: approle</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role-id</code>设置RoleId。</p>
</li>
<li>
<p><code>secret-id</code>设置SecretId。如果在不要求SecretId的情况下配置了AppRole，则可以忽略SecretId（请参见<code>bind_secret_id</code> ）。</p>
</li>
<li>
<p><code>role</code> ：设置拉动模式的AppRole名称。</p>
</li>
<li>
<p><code>app-role-path</code>设置要使用的方法认证安装的路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/approle.html">保管库文档：使用AppRole身份验证后端</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.awsec2"><a class="anchor" href="#vault.config.authentication.awsec2"></a> <a class="link" href="#vault.config.authentication.awsec2">15.3.4。AWS-EC2身份验证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/aws-ec2.html">aws-ec2</a> auth后端为AWS EC2实例提供了一种安全的引入机制，允许自动检索Vault令牌。与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。而是将AWS视为受信任的第三方，并使用经过加密签名的动态元数据信息来唯一表示每个EC2实例。</p>
</div>
<div class="exampleblock">
<div class="title">示例14.使用AWS-EC2身份验证的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AWS_EC2</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>AWS-EC2身份验证默认使随机数遵循首次使用信任（TOFU）原则。任何有权访问PKCS＃7身份元数据的意外方都可以针对保险柜进行身份验证。</p>
</div>
<div class="paragraph">
<p>在首次登录期间，Spring Cloud Vault会生成一个随机数，该随机数存储在身份验证后端中，与实例ID无关。重新认证要求发送相同的随机数。任何其他方都没有该随机数，可以在保险柜中发出警报以进行进一步调查。</p>
</div>
<div class="paragraph">
<p>随机数保留在内存中，在应用程序重新启动期间丢失。您可以使用配置静态随机数<code>spring.cloud.vault.aws-ec2.nonce</code> 。</p>
</div>
<div class="paragraph">
<p>AWS-EC2身份验证角色是可选的，默认为AMI。您可以通过设置身份验证角色<code>spring.cloud.vault.aws-ec2.role</code>属性。</p>
</div>
<div class="exampleblock">
<div class="title">例子15.具有配置角色的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AWS_EC2
    aws-ec2:
        role: application-server</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例16.具有所有AWS EC2身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AWS_EC2
    aws-ec2:
        role: application-server
        aws-ec2-path: aws-ec2
        identity-document: http://...
        nonce: my-static-nonce</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>authentication</code>将此值设置为<code>AWS_EC2</code>选择AWS EC2身份验证方法</p>
</li>
<li>
<p><code>role</code>设置尝试进行登录的角色的名称。</p>
</li>
<li>
<p><code>aws-ec2-path</code>设置要使用的AWS EC2安装的路径</p>
</li>
<li>
<p><code>identity-document</code>设置PKCS＃7 AWS EC2身份文档的URL</p>
</li>
<li>
<p><code>nonce</code>用于AWS-EC2身份验证。空随机数默认为随机数生成</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/aws.html">Vault文档：使用aws auth后端</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.awsiam"><a class="anchor" href="#vault.config.authentication.awsiam"></a> <a class="link" href="#vault.config.authentication.awsiam">15.3.5。AWS-IAM身份验证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/aws-ec2.html">aws</a>后端为AWS IAM角色提供了一种安全的身份验证机制，从而可以基于正在运行的应用程序的当前IAM角色，通过保管库进行自动身份验证。与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。相反，它将AWS视为受信任的第三方，并使用呼叫者使用其IAM凭据签名的4条信息来验证呼叫者确实在使用该IAM角色。</p>
</div>
<div class="paragraph">
<p>应用程序正在其中运行的当前IAM角色是自动计算的。如果您在AWS ECS上运行应用程序，则该应用程序将使用分配给正在运行的容器的ECS任务的IAM角色。如果您在EC2实例上裸身运行应用程序，则使用的IAM角色将是分配给EC2实例的角色。</p>
</div>
<div class="paragraph">
<p>使用AWS-IAM身份验证时，您必须在Vault中创建一个角色并将其分配给您的IAM角色。一个空的<code>role</code>默认为当前IAM角色的友好名称。</p>
</div>
<div class="exampleblock">
<div class="title">示例17.具有必需的AWS-IAM身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AWS_IAM</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例18.具有所有AWS-IAM身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AWS_IAM
    aws-iam:
        role: my-dev-role
        aws-path: aws
        server-id: some.server.name
        endpoint-uri: https://sts.eu-central-1.amazonaws.com</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role</code>设置尝试进行登录的角色的名称。这应该与您的IAM角色绑定。如果未提供，则当前IAM用户的友好名称将用作保管库角色。</p>
</li>
<li>
<p><code>aws-path</code>设置要使用的AWS装载的路径</p>
</li>
<li>
<p><code>server-id</code>设置要用于的值<code>X-Vault-AWS-IAM-Server-ID</code>标头可防止某些类型的重放攻击。</p>
</li>
<li>
<p><code>endpoint-uri</code>设置要用于AWS STS API的值<code>iam_request_url</code>参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>AWS-IAM需要AWS Java SDK依赖项（ <code>com.amazonaws:aws-java-sdk-core</code> ），因为身份验证实现将AWS开发工具包类型用于凭证和请求签名。</p>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/aws.html">Vault文档：使用aws auth后端</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.azuremsi"><a class="anchor" href="#vault.config.authentication.azuremsi"></a> <a class="link" href="#vault.config.authentication.azuremsi">15.3.6。Azure MSI身份验证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/azure.html">天蓝色的</a>身份验证后端为Azure VM实例提供了一种安全的引入机制，允许自动检索保险柜令牌。与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。而是将Azure视为受信任的第三方，并使用可以绑定到VM实例的托管服务身份和实例元数据信息。</p>
</div>
<div class="exampleblock">
<div class="title">示例19.具有必需的Azure身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AZURE_MSI
    azure-msi:
        role: my-dev-role</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">示例20.具有所有Azure身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: AZURE_MSI
    azure-msi:
        role: my-dev-role
        azure-path: azure</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role</code>设置尝试进行登录的角色的名称。</p>
</li>
<li>
<p><code>azure-path</code>设置要使用的Azure装载的路径</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Azure MSI身份验证从实例元数据服务中获取有关虚拟机的环境详细信息（订阅ID，资源组，VM名称）。</p>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/azure.html">Vault文档：使用Azure身份验证后端</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.clientcert"><a class="anchor" href="#vault.config.authentication.clientcert"></a> <a class="link" href="#vault.config.authentication.clientcert">15.3.7。TLS证书认证</a></h4>
<div class="paragraph">
<p>的<code>cert</code> auth后端允许使用由CA签名或自签名的SSL / TLS客户端证书进行身份验证。</p>
</div>
<div class="paragraph">
<p>启用<code>cert</code>身份验证您需要：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用SSL，请参阅<a href="#vault.config.ssl">Vault Client SSL配置</a></p>
</li>
<li>
<p>配置Java <code>Keystore</code>包含客户端证书和私钥</p>
</li>
<li>
<p>设置<code>spring.cloud.vault.authentication</code>至<code>CERT</code></p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="title">例子21. bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: CERT
    ssl:
        key-store: classpath:keystore.jks
        key-store-password: changeit
        cert-auth-path: cert</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/cert.html">保管库文档：使用Cert auth后端</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.cubbyhole"><a class="anchor" href="#vault.config.authentication.cubbyhole"></a> <a class="link" href="#vault.config.authentication.cubbyhole">15.3.8。隔间认证</a></h4>
<div class="paragraph">
<p>Cubbyhole身份验证使用保管库原语提供安全的身份验证工作流。Cubbyhole身份验证使用令牌作为主要登录方法。临时令牌用于从Vault的Cubbyhole秘密后端获取第二个登录VaultToken。登录令牌通常使用寿命更长，并用于与保险柜进行交互。登录令牌将从存储在以下位置的包装响应中检索<code>/cubbyhole/response</code> 。</p>
</div>
<div class="paragraph">
<p><strong>创建包装的令牌</strong></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">用于创建令牌的响应包装需要Vault 0.6.0或更高版本。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">示例22创建和存储令牌</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">$ vault token-create -wrap-ttl="10m"
Key                            Value
---                            -----
wrapping_token:                397ccb93-ff6c-b17b-9389-380b01ca2645
wrapping_token_ttl:            0h10m0s
wrapping_token_creation_time:  2016-09-18 20:29:48.652957077 +0200 CEST
wrapped_accessor:              46b6aebb-187f-932a-26d7-4f3d86a68319</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例子23. bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: CUBBYHOLE
    token: 397ccb93-ff6c-b17b-9389-380b01ca2645</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以看看：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.vaultproject.io/docs/concepts/tokens.html">保险柜文档：令牌</a></p>
</li>
<li>
<p><a href="https://www.vaultproject.io/docs/secrets/cubbyhole/index.html">保险柜文件：Cubbyhole秘密后端</a></p>
</li>
<li>
<p><a href="https://www.vaultproject.io/docs/concepts/response-wrapping.html">保险柜文件：响应包装</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.gcpgce"><a class="anchor" href="#vault.config.authentication.gcpgce"></a> <a class="link" href="#vault.config.authentication.gcpgce">15.3.9。GCP-GCE认证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/gcp.html">gcp</a> auth后端允许使用现有的GCP（Google云平台）IAM和GCE凭据登录保险柜。</p>
</div>
<div class="paragraph">
<p>GCP GCE（Google Compute Engine）身份验证为服务帐户创建JSON Web令牌（JWT）形式的签名。使用<a href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity">实例标识</a>从GCE元数据服务获得Compute Engine实例的JWT。此API创建一个JSON Web令牌，可用于确认实例身份。</p>
</div>
<div class="paragraph">
<p>与大多数Vault身份验证后端不同，此后端不需要先部署或配置对安全敏感的凭据（令牌，用户名/密码，客户端证书等）。而是将GCP视为受信任的第三方，并使用经过加密签名的动态元数据信息来唯一表示每个GCP服务帐户。</p>
</div>
<div class="exampleblock">
<div class="title">例子24.具有必需的GCP-GCE认证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: GCP_GCE
    gcp-gce:
        role: my-dev-role</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例子25.具有所有GCP-GCE身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: GCP_GCE
    gcp-gce:
        gcp-path: gcp
        role: my-dev-role
        service-account: my-service@projectid.iam.gserviceaccount.com</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role</code>设置尝试进行登录的角色的名称。</p>
</li>
<li>
<p><code>gcp-path</code>设置要使用的GCP安装的路径</p>
</li>
<li>
<p><code>service-account</code>允许将服务帐户ID覆盖为特定值。默认为<code>default</code>服务帐户。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>也可以看看：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.vaultproject.io/docs/auth/gcp.html">保险柜文件：使用GCP身份验证后端</a></p>
</li>
<li>
<p><a href="https://cloud.google.com/compute/docs/instances/verifying-instance-identity">GCP文档：验证实例的身份</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.gcpiam"><a class="anchor" href="#vault.config.authentication.gcpiam"></a> <a class="link" href="#vault.config.authentication.gcpiam">15.3.10。GCP-IAM认证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/gcp.html">gcp</a> auth后端允许使用现有的GCP（Google云平台）IAM和GCE凭据登录保险柜。</p>
</div>
<div class="paragraph">
<p>GCP IAM身份验证以服务帐户的JSON Web令牌（JWT）形式创建签名。通过调用GCP IAM获得服务帐户的JWT <a href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt"><code>projects.serviceAccounts.signJwt</code></a> API。呼叫者针对GCP IAM进行身份验证，从而证明其身份。该保险柜后端将GCP视为受信任的第三方。</p>
</div>
<div class="paragraph">
<p>可以从运行时环境（特别是<a href="https://cloud.google.com/docs/authentication/production"><code>GOOGLE_APPLICATION_CREDENTIALS</code></a>环境变量，Google Compute元数据服务，或外部提供，例如JSON或base64编码。JSON是首选形式，因为它带有调用所需的项目ID和服务帐户标识符<code>projects.serviceAccounts.signJwt</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子26.具有必需的GCP-IAM身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: GCP_IAM
    gcp-iam:
        role: my-dev-role</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例子27.具有所有GCP-IAM身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: GCP_IAM
    gcp-iam:
        credentials:
            location: classpath:credentials.json
            encoded-key: e+KApn0=
        gcp-path: gcp
        jwt-validity: 15m
        project-id: my-project-id
        role: my-dev-role
        service-account-id: my-service@projectid.iam.gserviceaccount.com</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role</code>设置尝试进行登录的角色的名称。</p>
</li>
<li>
<p><code>credentials.location</code>包含JSON格式的Google凭据的凭据资源的路径。</p>
</li>
<li>
<p><code>credentials.encoded-key</code> JSON格式的OAuth2帐户私钥的base64编码内容。</p>
</li>
<li>
<p><code>gcp-path</code>设置要使用的GCP安装的路径</p>
</li>
<li>
<p><code>jwt-validity</code>配置JWT令牌有效性。默认为15分钟。</p>
</li>
<li>
<p><code>project-id</code>允许将项目ID覆盖为特定值。从获得的凭据中默认为项目ID。</p>
</li>
<li>
<p><code>service-account</code>允许将服务帐户ID覆盖为特定值。默认为获取的凭证中的服务帐户。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>GCP IAM身份验证需要Google Cloud Java SDK依赖项（ <code>com.google.apis:google-api-services-iam</code>和<code>com.google.auth:google-auth-library-oauth2-http</code> ），因为身份验证实现将Google API用于凭据和JWT签名。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Google凭据需要OAuth 2令牌来维护令牌的生命周期。因此，所有API都是同步的， <code>GcpIamAuthentication</code>不支持<code>AuthenticationSteps</code>这是被动使用所必需的。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>也可以看看：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.vaultproject.io/docs/auth/gcp.html">保险柜文件：使用GCP身份验证后端</a></p>
</li>
<li>
<p><a href="https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signJwt">GCP文档：projects.serviceAccounts.signJwt</a><a id="vault.authentication.gcpiam"></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.kubernetes"><a class="anchor" href="#vault.config.authentication.kubernetes"></a> <a class="link" href="#vault.config.authentication.kubernetes">15.3.11。Kubernetes认证</a></h4>
<div class="paragraph">
<p>Kubernetes身份验证机制（自Vault 0.8.3起）允许使用Kubernetes服务帐户令牌向Vault进行身份验证。身份验证基于角色，并且角色绑定到服务帐户名称和名称空间。</p>
</div>
<div class="paragraph">
<p>包含Pod服务帐户的JWT令牌的文件会自动安装在<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子28.具有所有Kubernetes身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: KUBERNETES
    kubernetes:
        role: my-dev-role
        kubernetes-path: kubernetes
        service-account-token-file: /var/run/secrets/kubernetes.io/serviceaccount/token</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role</code>设置角色。</p>
</li>
<li>
<p><code>kubernetes-path</code>设置要使用的Kubernetes安装的路径。</p>
</li>
<li>
<p><code>service-account-token-file</code>设置包含Kubernetes服务帐户令牌的文件的位置。默认为<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>也可以看看：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.vaultproject.io/docs/auth/kubernetes.html">保管库文件：Kubernetes</a></p>
</li>
<li>
<p><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Kubernetes文档：为Pod配置服务帐户</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.authentication.pcf"><a class="anchor" href="#vault.config.authentication.pcf"></a> <a class="link" href="#vault.config.authentication.pcf">15.3.12。Pivotal CloudFoundry身份验证</a></h4>
<div class="paragraph">
<p><a href="https://www.vaultproject.io/docs/auth/pcf.html">pcf</a> auth后端为在Pivotal的CloudFoundry实例中运行的应用程序提供了一种安全的引入机制，从而可以自动检索Vault令牌。与大多数Vault身份验证后端不同，此后端不需要先部署或配置安全敏感的凭据（令牌，用户名/密码，客户端证书等），因为身份配置由PCF本身处理。而是将PCF视为受信任的第三方，并使用托管实例身份。</p>
</div>
<div class="exampleblock">
<div class="title">例子29. bootstrap.yml具有必需的PCF身份验证属性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: PCF
    pcf:
        role: my-dev-role</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例子30.具有所有PCF身份验证属性的bootstrap.yml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    authentication: PCF
    pcf:
        role: my-dev-role
        pcf-path: path
        instance-certificate: /etc/cf-instance-credentials/instance.crt
        instance-key: /etc/cf-instance-credentials/instance.key</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>role</code>设置尝试进行登录的角色的名称。</p>
</li>
<li>
<p><code>pcf-path</code>设置要使用的PCF安装的路径。</p>
</li>
<li>
<p><code>instance-certificate</code>设置PCF实例身份证书的路径。默认为<code>${CF_INSTANCE_CERT}</code> env变量。</p>
</li>
<li>
<p><code>instance-key</code>设置PCF实例身份密钥的路径。默认为<code>${CF_INSTANCE_KEY}</code> env变量。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">PCF身份验证要求BouncyCastle（bcpkix-jdk15on）位于用于RSA PSS签名的类路径中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/auth/pcf.html">Vault文档：使用pcf auth后端</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.backends"><a class="anchor" href="#vault.config.backends"></a> <a class="link" href="#vault.config.backends">15.4。秘密后端</a></h3>
<div class="sect3">
<h4 id="vault.config.backends.generic"><a class="anchor" href="#vault.config.backends.generic"></a> <a class="link" href="#vault.config.backends.generic">15.4.1。通用后端</a></h4>
<div class="paragraph">
<p>Spring Cloud Vault在基本级别上支持通用秘密后端。通用秘密后端允许将任意值存储为键值存储。单个上下文可以存储一个或多个键值元组。上下文可以按层次进行组织。Spring Cloud Vault允许使用应用程序名称和默认上下文名称（ <code>application</code> ）与有效配置文件结合使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/secret/{application}/{profile}
/secret/{application}
/secret/{default-context}/{profile}
/secret/{default-context}</pre>
</div>
</div>
<div class="paragraph">
<p>应用程序名称由以下属性确定：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.vault.generic.application-name</code></p>
</li>
<li>
<p><code>spring.cloud.vault.application-name</code></p>
</li>
<li>
<p><code>spring.application.name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过在通用后端中的其他上下文中获取秘密，方法是将其路径添加到应用程序名称中，并用逗号分隔。例如，给定应用程序名称<code>usefulapp,mysql1,projectx/aws</code> ，将使用以下每个文件夹：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/secret/usefulapp</code></p>
</li>
<li>
<p><code>/secret/mysql1</code></p>
</li>
<li>
<p><code>/secret/projectx/aws</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Vault将所有活动配置文件添加到可能的上下文路径列表中。没有活动的个人资料会跳过使用个人资料名称的访问上下文。</p>
</div>
<div class="paragraph">
<p>就像存储属性一样公开属性（即，没有其他前缀）。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    generic:
        enabled: true
        backend: secret
        profile-separator: '/'
        default-context: application
        application-name: my-app</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>false</code>禁用秘密后端配置用法</p>
</li>
<li>
<p><code>backend</code>设置要使用的秘密装载的路径</p>
</li>
<li>
<p><code>default-context</code>设置所有应用程序使用的上下文名称</p>
</li>
<li>
<p><code>application-name</code>覆盖在通用后端中使用的应用程序名称</p>
</li>
<li>
<p><code>profile-separator</code>使用配置文件在属性源中将配置文件名称与上下文分开</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">键值秘密后端可以在版本控制（v2）和非版本控制（v1）模式下运行。根据操作模式，需要不同的API来访问机密。确保启用<code>generic</code>非版本化键值后端的秘密后端用法，以及<code>kv</code>版本化键值后端的秘密后端用法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/kv/kv-v1.html">保管库文档：使用KV秘密引擎-版本1（通用秘密后端）</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.kv.versioned"><a class="anchor" href="#vault.config.backends.kv.versioned"></a> <a class="link" href="#vault.config.backends.kv.versioned">15.4.2。版本化键值后端</a></h4>
<div class="paragraph">
<p>Spring Cloud Vault支持版本化的Key-Value秘密后端。键值后端允许存储任意值作为键值存储。单个上下文可以存储一个或多个键值元组。上下文可以按层次进行组织。Spring Cloud Vault允许使用应用程序名称和默认上下文名称（ <code>application</code> ）与有效配置文件结合使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/secret/{application}/{profile}
/secret/{application}
/secret/{default-context}/{profile}
/secret/{default-context}</pre>
</div>
</div>
<div class="paragraph">
<p>应用程序名称由以下属性确定：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.vault.kv.application-name</code></p>
</li>
<li>
<p><code>spring.cloud.vault.application-name</code></p>
</li>
<li>
<p><code>spring.application.name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以从键值后端的其他上下文中获取秘密，方法是将其路径添加到应用程序名称中，并用逗号分隔。例如，给定应用程序名称<code>usefulapp,mysql1,projectx/aws</code> ，将使用以下每个文件夹：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/secret/usefulapp</code></p>
</li>
<li>
<p><code>/secret/mysql1</code></p>
</li>
<li>
<p><code>/secret/projectx/aws</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Vault将所有活动配置文件添加到可能的上下文路径列表中。没有活动的个人资料会跳过使用个人资料名称的访问上下文。</p>
</div>
<div class="paragraph">
<p>就像存储属性一样公开属性（即，没有其他前缀）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud Vault添加了<code>data/</code>安装路径和实际上下文路径之间的上下文。
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    kv:
        enabled: true
        backend: secret
        profile-separator: '/'
        default-context: application
        application-name: my-app</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>false</code>禁用秘密后端配置用法</p>
</li>
<li>
<p><code>backend</code>设置要使用的秘密装载的路径</p>
</li>
<li>
<p><code>default-context</code>设置所有应用程序使用的上下文名称</p>
</li>
<li>
<p><code>application-name</code>覆盖在通用后端中使用的应用程序名称</p>
</li>
<li>
<p><code>profile-separator</code>使用配置文件在属性源中将配置文件名称与上下文分开</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">键值秘密后端可以在版本控制（v2）和非版本控制（v1）模式下运行。根据操作模式，需要不同的API来访问机密。确保启用<code>generic</code>非版本化键值后端的秘密后端用法，以及<code>kv</code>版本化键值后端的秘密后端用法。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/kv/kv-v2.html">保管库文档：使用KV Secrets Engine-版本2（版本化的键值后端）</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.consul"><a class="anchor" href="#vault.config.backends.consul"></a> <a class="link" href="#vault.config.backends.consul">15.4.3。领事</a></h4>
<div class="paragraph">
<p>Spring Cloud Vault可以获取HashiCorp Consul的凭据。领事整合要求<code>spring-cloud-vault-config-consul</code>依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">例子31. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-consul</artifactId>
        <version>2.2.0.RC2</version>
    </dependency>
</dependencies></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以通过设置启用集成<code>spring.cloud.vault.consul.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.consul.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>获得的令牌存储在<code>spring.cloud.consul.token</code>因此使用Spring Cloud Consul无需进一步配置即可获取生成的凭证。您可以通过设置配置属性名称<code>spring.cloud.vault.consul.token-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    consul:
        enabled: true
        role: readonly
        backend: consul
        token-property: spring.cloud.consul.token</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用Consul后端配置用法</p>
</li>
<li>
<p><code>role</code>设置领事角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置使用Consul挂载的路径</p>
</li>
<li>
<p><code>token-property</code>设置存储Consul ACL令牌的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/consul/index.html">Vault文档：使用Vault设置Consul</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.rabbitmq"><a class="anchor" href="#vault.config.backends.rabbitmq"></a> <a class="link" href="#vault.config.backends.rabbitmq">15.4.4。兔子MQ</a></h4>
<div class="paragraph">
<p>Spring Cloud Vault可以获取RabbitMQ的凭据。</p>
</div>
<div class="paragraph">
<p>RabbitMQ集成需要<code>spring-cloud-vault-config-rabbitmq</code>依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">例子32. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-rabbitmq</artifactId>
        <version>2.2.0.RC2</version>
    </dependency>
</dependencies></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以通过设置启用集成<code>spring.cloud.vault.rabbitmq.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.rabbitmq.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>用户名和密码存储在<code>spring.rabbitmq.username</code>和<code>spring.rabbitmq.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code>spring.cloud.vault.rabbitmq.username-property</code>和<code>spring.cloud.vault.rabbitmq.password-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    rabbitmq:
        enabled: true
        role: readonly
        backend: rabbitmq
        username-property: spring.rabbitmq.username
        password-property: spring.rabbitmq.password</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用RabbitMQ后端配置用法</p>
</li>
<li>
<p><code>role</code>设置RabbitMQ角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的RabbitMQ安装的路径</p>
</li>
<li>
<p><code>username-property</code>设置存储RabbitMQ用户名的属性名称</p>
</li>
<li>
<p><code>password-property</code>设置存储RabbitMQ密码的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/rabbitmq/index.html">Vault文档：使用Vault设置RabbitMQ</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.aws"><a class="anchor" href="#vault.config.backends.aws"></a> <a class="link" href="#vault.config.backends.aws">15.4.5。AWS</a></h4>
<div class="paragraph">
<p>Spring Cloud Vault可以获取AWS的凭证。</p>
</div>
<div class="paragraph">
<p>AWS集成要求<code>spring-cloud-vault-config-aws</code>依赖性。</p>
</div>
<div class="exampleblock">
<div class="title">例子33. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-aws</artifactId>
        <version>2.2.0.RC2</version>
    </dependency>
</dependencies></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以通过设置启用集成<code>spring.cloud.vault.aws=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.aws.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>访问密钥和秘密密钥存储在<code>cloud.aws.credentials.accessKey</code>和<code>cloud.aws.credentials.secretKey</code>因此使用Spring Cloud AWS无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code>spring.cloud.vault.aws.access-key-property</code>和<code>spring.cloud.vault.aws.secret-key-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    aws:
        enabled: true
        role: readonly
        backend: aws
        access-key-property: cloud.aws.credentials.accessKey
        secret-key-property: cloud.aws.credentials.secretKey</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用AWS后端配置使用</p>
</li>
<li>
<p><code>role</code>设置AWS角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的AWS装载的路径</p>
</li>
<li>
<p><code>access-key-property</code>设置存储AWS访问密钥的属性名称</p>
</li>
<li>
<p><code>secret-key-property</code>设置存储AWS密钥的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/aws/index.html">保险柜文档：使用保险柜设置AWS</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.backends.database-backends"><a class="anchor" href="#vault.config.backends.database-backends"></a> <a class="link" href="#vault.config.backends.database-backends">15.5。数据库后端</a></h3>
<div class="paragraph">
<p>Vault支持多个数据库机密后端，以根据配置的角色动态生成数据库凭据。这意味着需要访问数据库的服务不再需要配置凭据：它们可以从Vault请求它们，并使用Vault的租赁机制更轻松地滚动密钥。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Vault与以下后端集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#vault.config.backends.database">数据库</a></p>
</li>
<li>
<p><a href="#vault.config.backends.cassandra">阿帕奇·卡桑德拉（Apache Cassandra）</a></p>
</li>
<li>
<p><a href="#vault.config.backends.mongodb">MongoDB</a></p>
</li>
<li>
<p><a href="#vault.config.backends.mysql">的MySQL</a></p>
</li>
<li>
<p><a href="#vault.config.backends.postgresql">PostgreSQL的</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用数据库秘密后端需要在配置中启用后端，并且<code>spring-cloud-vault-config-databases</code>依赖性。</p>
</div>
<div class="paragraph">
<p>自0.7.1起，保管箱会专门运送<code>database</code>允许通过插件集成数据库的秘密后端。您可以通过使用通用数据库后端来使用该特定后端。确保指定适当的后端路径，例如<code>spring.cloud.vault.mysql.role.backend=database</code> 。</p>
</div>
<div class="exampleblock">
<div class="title">例子34. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-vault-config-databases</artifactId>
        <version>2.2.0.RC2</version>
    </dependency>
</dependencies></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">启用多个JDBC兼容数据库将生成凭据，并且默认情况下将它们存储在相同的属性密钥中，因此需要分别配置JDBC机密的属性名称。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="vault.config.backends.database"><a class="anchor" href="#vault.config.backends.database"></a> <a class="link" href="#vault.config.backends.database">15.5.1。数据库</a></h4>
<div class="paragraph">
<p>Spring Cloud Vault可以获取<a href="https://www.vaultproject.io/api/secret/databases/index.html" class="bare">www.vaultproject.io/api/secret/databases/index.html上</a>列出的任何数据库的凭据。可以通过设置启用集成<code>spring.cloud.vault.database.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.database.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>虽然数据库后端是通用后端， <code>spring.cloud.vault.database</code>专门针对JDBC数据库。用户名和密码存储在<code>spring.datasource.username</code>和<code>spring.datasource.password</code>因此使用Spring Boot将为您获取生成的凭据<code>DataSource</code>无需进一步配置。您可以通过设置来配置属性名称<code>spring.cloud.vault.database.username-property</code>和<code>spring.cloud.vault.database.password-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    database:
        enabled: true
        role: readonly
        backend: database
        username-property: spring.datasource.username
        password-property: spring.datasource.password</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用数据库后端配置用法</p>
</li>
<li>
<p><code>role</code>设置数据库角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的数据库安装路径</p>
</li>
<li>
<p><code>username-property</code>设置存储数据库用户名的属性名称</p>
</li>
<li>
<p><code>password-property</code>设置存储数据库密码的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/databases/index.html">保管库文档：数据库机密后端</a></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">Spring Cloud Vault不支持获取新凭据并配置您的<code>DataSource</code>与他们达成最大租约时间后。也就是说，如果<code>max_ttl</code>保险柜中数据库角色的设置为<code>24h</code>这意味着您的应用程序启动后24小时将无法再通过数据库进行身份验证。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.cassandra"><a class="anchor" href="#vault.config.backends.cassandra"></a> <a class="link" href="#vault.config.backends.cassandra">15.5.2。阿帕奇·卡桑德拉（Apache Cassandra）</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>cassandra</code> Vault 0.7.1已弃用后端，建议使用<code>database</code>后端并将其安装为<code>cassandra</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Vault可以获取Apache Cassandra的凭据。可以通过设置启用集成<code>spring.cloud.vault.cassandra.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.cassandra.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>用户名和密码存储在<code>spring.data.cassandra.username</code>和<code>spring.data.cassandra.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code>spring.cloud.vault.cassandra.username-property</code>和<code>spring.cloud.vault.cassandra.password-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    cassandra:
        enabled: true
        role: readonly
        backend: cassandra
        username-property: spring.data.cassandra.username
        password-property: spring.data.cassandra.password</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用Cassandra后端配置用法</p>
</li>
<li>
<p><code>role</code>设置Cassandra角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的Cassandra安装的路径</p>
</li>
<li>
<p><code>username-property</code>设置存储Cassandra用户名的属性名称</p>
</li>
<li>
<p><code>password-property</code>设置存储Cassandra密码的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/cassandra/index.html">Vault文档：使用Vault设置Apache Cassandra</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.mongodb"><a class="anchor" href="#vault.config.backends.mongodb"></a> <a class="link" href="#vault.config.backends.mongodb">15.5.3。MongoDB</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>mongodb</code> Vault 0.7.1已弃用后端，建议使用<code>database</code>后端并将其安装为<code>mongodb</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Vault可以获取MongoDB的凭据。可以通过设置启用集成<code>spring.cloud.vault.mongodb.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.mongodb.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>用户名和密码存储在<code>spring.data.mongodb.username</code>和<code>spring.data.mongodb.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code>spring.cloud.vault.mongodb.username-property</code>和<code>spring.cloud.vault.mongodb.password-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    mongodb:
        enabled: true
        role: readonly
        backend: mongodb
        username-property: spring.data.mongodb.username
        password-property: spring.data.mongodb.password</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用MongodB后端配置用法</p>
</li>
<li>
<p><code>role</code>设置MongoDB角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的MongoDB安装的路径</p>
</li>
<li>
<p><code>username-property</code>设置存储MongoDB用户名的属性名称</p>
</li>
<li>
<p><code>password-property</code>设置存储MongoDB密码的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/mongodb/index.html">保管库文档：使用保管库设置MongoDB</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.mysql"><a class="anchor" href="#vault.config.backends.mysql"></a> <a class="link" href="#vault.config.backends.mysql">15.5.4。的MySQL</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>mysql</code> Vault 0.7.1已弃用后端，建议使用<code>database</code>后端并将其安装为<code>mysql</code> 。配置<code>spring.cloud.vault.mysql</code>将在以后的版本中删除。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Vault可以获取MySQL的凭据。可以通过设置启用集成<code>spring.cloud.vault.mysql.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.mysql.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>用户名和密码存储在<code>spring.datasource.username</code>和<code>spring.datasource.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code>spring.cloud.vault.mysql.username-property</code>和<code>spring.cloud.vault.mysql.password-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    mysql:
        enabled: true
        role: readonly
        backend: mysql
        username-property: spring.datasource.username
        password-property: spring.datasource.password</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用MySQL后端配置用法</p>
</li>
<li>
<p><code>role</code>设置MySQL角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的MySQL安装的路径</p>
</li>
<li>
<p><code>username-property</code>设置存储MySQL用户名的属性名称</p>
</li>
<li>
<p><code>password-property</code>设置存储MySQL密码的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/mysql/index.html">保管库文档：使用保管库设置MySQL</a></p>
</div>
</div>
<div class="sect3">
<h4 id="vault.config.backends.postgresql"><a class="anchor" href="#vault.config.backends.postgresql"></a> <a class="link" href="#vault.config.backends.postgresql">15.5.5。PostgreSQL的</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>postgresql</code> Vault 0.7.1已弃用后端，建议使用<code>database</code>后端并将其安装为<code>postgresql</code> 。配置<code>spring.cloud.vault.postgresql</code>将在以后的版本中删除。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Vault可以获取PostgreSQL的凭据。可以通过设置启用集成<code>spring.cloud.vault.postgresql.enabled=true</code> （默认<code>false</code> ），并提供角色名称<code>spring.cloud.vault.postgresql.role=…</code> 。</p>
</div>
<div class="paragraph">
<p>用户名和密码存储在<code>spring.datasource.username</code>和<code>spring.datasource.password</code>因此使用Spring Boot将无需进一步配置即可获取生成的凭证。您可以通过设置来配置属性名称<code>spring.cloud.vault.postgresql.username-property</code>和<code>spring.cloud.vault.postgresql.password-property</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    postgresql:
        enabled: true
        role: readonly
        backend: postgresql
        username-property: spring.datasource.username
        password-property: spring.datasource.password</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>将此值设置为<code>true</code>启用PostgreSQL后端配置用法</p>
</li>
<li>
<p><code>role</code>设置PostgreSQL角色定义的角色名称</p>
</li>
<li>
<p><code>backend</code>设置要使用的PostgreSQL安装的路径</p>
</li>
<li>
<p><code>username-property</code>设置存储PostgreSQL用户名的属性名称</p>
</li>
<li>
<p><code>password-property</code>设置存储PostgreSQL密码的属性名称</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/secrets/postgresql/index.html">Vault文档：使用Vault设置PostgreSQL</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.backends.configurer"><a class="anchor" href="#vault.config.backends.configurer"></a> <a class="link" href="#vault.config.backends.configurer">15.6。配置<code>PropertySourceLocator</code>行为</a></h3>
<div class="paragraph">
<p>Spring Cloud Vault使用基于属性的配置来创建<code>PropertySource</code>用于通用和发现的秘密后端。</p>
</div>
<div class="paragraph">
<p>发现的后端提供<code>VaultSecretBackendDescriptor</code> bean描述使用秘密后端作为的配置状态<code>PropertySource</code> 。一种<code>SecretBackendMetadataFactory</code>需要创建一个<code>SecretBackendMetadata</code>包含路径，名称和属性转换配置的对象。</p>
</div>
<div class="paragraph">
<p><code>SecretBackendMetadata</code>用于支持特定<code>PropertySource</code> 。</p>
</div>
<div class="paragraph">
<p>您可以注册任意数量的Bean实现<code>VaultConfigurer</code>用于定制。如果Spring Cloud Vault发现至少一个，则默认的通用和发现的后端注册被禁用<code>VaultConfigurer</code>豆。但是，您可以通过以下方式启用默认注册<code>SecretBackendConfigurer.registerDefaultGenericSecretBackends()</code>和<code>SecretBackendConfigurer.registerDefaultDiscoveredSecretBackends()</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomizationBean implements VaultConfigurer {

    @Override
    public void addSecretBackends(SecretBackendConfigurer configurer) {

        configurer.add("secret/my-application");

        configurer.registerDefaultGenericSecretBackends(false);
        configurer.registerDefaultDiscoveredSecretBackends(true);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">所有定制都必须在引导上下文中进行。将配置类添加到<code>META-INF/spring.factories</code>在<code>org.springframework.cloud.bootstrap.BootstrapConfiguration</code>在您的应用程序中。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="service-registry-configuration"><a class="anchor" href="#service-registry-configuration"></a> <a class="link" href="#service-registry-configuration">15.7。服务注册表配置</a></h3>
<div class="paragraph">
<p>您可以使用<code>DiscoveryClient</code> （例如来自Spring Cloud Consul）通过设置spring.cloud.vault.discovery.enabled = true（默认值）来定位Vault服务器<code>false</code> ）。最终结果是您的应用程序需要带有适当发现配置的bootstrap.yml（或环境变量）。好处是，只要发现服务是固定点，保管箱就可以更改其坐标。默认服务ID为<code>vault</code>但您可以通过以下方式在客户端上进行更改<code>spring.cloud.vault.discovery.serviceId</code> 。</p>
</div>
<div class="paragraph">
<p>发现客户端实现均支持某种元数据映射（例如，对于Eureka，我们拥有eureka.instance.metadataMap）。服务的某些其他属性可能需要在其服务注册元数据中进行配置，以便客户端可以正确连接。没有提供有关传输层安全性详细信息的服务注册表需要提供一个<code>scheme</code>元数据条目设置为<code>https</code>要么<code>http</code> 。如果未配置任何方案，并且该服务未作为安全服务公开，则配置默认为<code>spring.cloud.vault.scheme</code>这是<code>https</code>未设置时。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault.discovery:
    enabled: true
    service-id: my-vault-service</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.fail-fast"><a class="anchor" href="#vault.config.fail-fast"></a> <a class="link" href="#vault.config.fail-fast">15.8。Vault Client快速失败</a></h3>
<div class="paragraph">
<p>在某些情况下，如果服务无法连接到Vault服务器，则可能无法启动服务。如果这是所需的行为，请设置引导程序配置属性<code>spring.cloud.vault.fail-fast=true</code>并且客户端将因异常而停止。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    fail-fast: true</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.namespaces"><a class="anchor" href="#vault.config.namespaces"></a> <a class="link" href="#vault.config.namespaces">15.9。Vault Enterprise命名空间支持</a></h3>
<div class="paragraph">
<p>Vault Enterprise允许使用名称空间在单个Vault服务器上隔离多个Vault。通过设置配置名称空间<code>spring.cloud.vault.namespace=…</code>启用名称空间标题<code>X-Vault-Namespace</code>使用保管库时，在每个传出的HTTP请求上<code>RestTemplate</code>要么<code>WebClient</code> 。</p>
</div>
<div class="paragraph">
<p>请注意，Vault Community Edition不支持此功能，并且对Vault操作没有影响。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    namespace: my-namespace</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/enterprise/namespaces/index.html">Vault Enterprise：命名空间</a></p>
</div>
</div>
<div class="sect2">
<h3 id="vault.config.ssl"><a class="anchor" href="#vault.config.ssl"></a> <a class="link" href="#vault.config.ssl">15.10。Vault Client SSL配置</a></h3>
<div class="paragraph">
<p>可以通过设置各种属性来声明性地配置SSL。您可以设置<code>javax.net.ssl.trustStore</code>配置JVM范围的SSL设置，或<code>spring.cloud.vault.ssl.trust-store</code>仅为Spring Cloud Vault Config设置SSL设置。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    ssl:
        trust-store: classpath:keystore.jks
        trust-store-password: changeit</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>trust-store</code>设置信任库的资源。受SSL保护的保管箱通信将使用指定的信任库验证保管箱SSL证书。</p>
</li>
<li>
<p><code>trust-store-password</code>设置信任库密码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，配置<code>spring.cloud.vault.ssl.*</code>仅当Apache Http Components或OkHttp客户端在您的类路径上时才可以应用。</p>
</div>
</div>
<div class="sect2">
<h3 id="vault-lease-renewal"><a class="anchor" href="#vault-lease-renewal"></a> <a class="link" href="#vault-lease-renewal">15.11。租赁生命周期管理（续订和吊销）</a></h3>
<div class="paragraph">
<p>Vault会利用每个秘密创建一个租约：元数据，其中包含诸如持续时间，可更新性等信息。</p>
</div>
<div class="paragraph">
<p>保管箱保证数据在给定的持续时间内或生存时间（TTL）内有效。租约到期后，保险柜可以撤消数据，并且秘密使用方不再可以确定其有效。</p>
</div>
<div class="paragraph">
<p>除了创建登录令牌和机密之外，Spring Cloud Vault还维护着租赁生命周期。就是说，与租约相关的登录令牌和机密计划在租约到期之前立即更新，直到终端到期为止。应用程序关闭会撤消获得的登录令牌和可更新的租约。</p>
</div>
<div class="paragraph">
<p>秘密服务和数据库后端（例如MongoDB或MySQL）通常会生成可更新的租约，因此在应用程序关闭时将禁用生成的凭据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">静态令牌不会更新或吊销。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>租约续订和吊销默认为启用状态，可以通过设置禁用<code>spring.cloud.vault.config.lifecycle.enabled</code>至<code>false</code> 。不建议使用此方法，因为租约可能到期，并且Spring Cloud Vault无法再使用生成的凭据访问Vault或服务，并且在应用程序关闭后有效凭据仍处于活动状态。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring.cloud.vault:
    config.lifecycle:
        enabled: true
        min-renewal: 10s
        expiry-threshold: 1m
        lease-endpoints: Legacy</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>enabled</code>控制是否将与机密关联的租约视为已续签，并将到期的机密轮换。默认启用。</p>
</li>
<li>
<p><code>min-renewal</code>设置续约之前至少需要的期限。此设置可防止续订过于频繁。</p>
</li>
<li>
<p><code>expiry-threshold</code>设置到期阈值。租约在到期前会经过配置的时间段进行更新。</p>
</li>
<li>
<p><code>lease-endpoints</code>设置端点以进行续订和吊销。0.8之前的Vault版本的旧版，以及更高版本的SysLeases的旧版。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另请参阅： <a href="https://www.vaultproject.io/docs/concepts/lease.html">Vault文档：租赁，续订和吊销</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-gateway"><a class="anchor" href="#spring-cloud-gateway"></a> <a class="link" href="#spring-cloud-gateway">16。Spring Cloud Gateway</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="paragraph">
<p>该项目提供了一个在Spring生态系统之上构建的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。Spring Cloud Gateway旨在提供一种简单而有效的方法来路由到API，并为它们提供跨领域的关注，例如：安全性，监视/指标和弹性。</p>
</div>
<div class="sect2">
<h3 id="gateway-starter"><a class="anchor" href="#gateway-starter"></a> <a class="link" href="#gateway-starter">16.1。如何包括Spring Cloud Gateway</a></h3>
<div class="paragraph">
<p>要将Spring Cloud Gateway包括在您的项目中，请使用带有以下内容的启动器： <code>org.springframework.cloud</code>和工件ID <code>spring-cloud-starter-gateway</code> 。有关使用当前Spring Cloud Release Train设置构建系统的详细信息，请参见<a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project页面</a> 。</p>
</div>
<div class="paragraph">
<p>如果包括启动器，但是由于某种原因，您不希望启用网关，请设置<code>spring.cloud.gateway.enabled=false</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">Spring Cloud Gateway是基于<a href="https://spring.io/projects/spring-boot#learn">Spring Boot 2.x</a> ， <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">Spring WebFlux</a>和<a href="https://projectreactor.io/docs">Project Reactor</a> <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html">构建的</a> 。因此，在使用Spring Cloud Gateway时，许多不熟悉的同步库（例如，Spring Data和Spring Security）和模式可能不适用。如果您对这些项目不熟悉，建议您在使用Spring Cloud Gateway之前先阅读它们的文档以熟悉一些新概念。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行时。它不能在传统的Servlet容器中或作为WAR构建。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="glossary"><a class="anchor" href="#glossary"></a> <a class="link" href="#glossary">16.2。词汇表</a></h3>
<div class="ulist">
<ul>
<li>
<p><strong>路由</strong> ：路由网关的基本构建块。它由ID，目标URI，谓词集合和过滤器集合定义。如果聚合谓词为true，则匹配路由。</p>
</li>
<li>
<p><strong>谓词</strong> ：这是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">Java 8 Function谓词</a> 。输入类型是<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html">Spring框架<code>ServerWebExchange</code></a> 。这使开发人员可以匹配HTTP请求中的任何内容，例如标头或参数。</p>
</li>
<li>
<p><strong>筛选器</strong> ：这些是<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/GatewayFilter.html">Spring框架的</a>实例<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/GatewayFilter.html"><code>GatewayFilter</code></a>与特定工厂一起建造。在此，可以在发送下游请求之前或之后修改请求和响应。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="gateway-how-it-works"><a class="anchor" href="#gateway-how-it-works"></a> <a class="link" href="#gateway-how-it-works">16.3。怎么运行的</a></h3>
<div class="paragraph">
<p>image :: {imagesurl} /spring_cloud_gateway_diagram.png [Spring Cloud Gateway Diagram]</p>
</div>
<div class="paragraph">
<p>客户端向Spring Cloud Gateway发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。该处理程序运行通过特定于请求的筛选器链发送请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前或之后执行逻辑。执行所有“前置”过滤器逻辑，然后发出代理请求。发出代理请求后，将执行“发布”过滤器逻辑。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在没有端口的路由中定义的URI将分别将HTTP和HTTPS URI的默认端口分别设置为80和443。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="gateway-request-predicates-factories"><a class="anchor" href="#gateway-request-predicates-factories"></a> <a class="link" href="#gateway-request-predicates-factories">16.4。路线谓词工厂</a></h3>
<div class="paragraph">
<p>Spring Cloud Gateway将路由作为Spring WebFlux的一部分进行匹配<code>HandlerMapping</code>基础设施。Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些谓词都与HTTP请求的不同属性匹配。多个路由谓词工厂可以合并，也可以通过逻辑合并<code>and</code> 。</p>
</div>
<div class="sect3">
<h4 id="after-route-predicate-factory"><a class="anchor" href="#after-route-predicate-factory"></a> <a class="link" href="#after-route-predicate-factory">16.4.1。后路线谓词工厂</a></h4>
<div class="paragraph">
<p>After Route Predicate Factory采用一个参数，即日期时间。该谓词匹配在当前日期时间之后发生的请求。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - After=2017-01-20T17:42:47.789-07:00[America/Denver]</code></pre>
</div>
</div>
<div class="paragraph">
<p>此路线与2017年1月20日17:42山区时间（丹佛）之后的所有请求匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="before-route-predicate-factory"><a class="anchor" href="#before-route-predicate-factory"></a> <a class="link" href="#before-route-predicate-factory">16.4.2。路线谓词工厂之前</a></h4>
<div class="paragraph">
<p>路由谓词前工厂采用一个参数，即日期时间。该谓词匹配当前日期时间之前发生的请求。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: before_route
        uri: https://example.org
        predicates:
        - Before=2017-01-20T17:42:47.789-07:00[America/Denver]</code></pre>
</div>
</div>
<div class="paragraph">
<p>此路线与2017年1月20日17:42山区时间（丹佛）之前的所有请求匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="between-route-predicate-factory"><a class="anchor" href="#between-route-predicate-factory"></a> <a class="link" href="#between-route-predicate-factory">16.4.3。路线谓词工厂之间</a></h4>
<div class="paragraph">
<p>路由谓词间工厂之间有两个参数，datetime1和datetime2。该谓词匹配在datetime1之后和datetime2之前发生的请求。datetime2参数必须在datetime1之后。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: between_route
        uri: https://example.org
        predicates:
        - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]</code></pre>
</div>
</div>
<div class="paragraph">
<p>此路线与2017年1月20日山区时间（丹佛）之后和2017年1月21日17:42山时间（丹佛）之后的所有请求匹配。这对于维护时段可能很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="cookie-route-predicate-factory"><a class="anchor" href="#cookie-route-predicate-factory"></a> <a class="link" href="#cookie-route-predicate-factory">16.4.4。Cookie路线谓词工厂</a></h4>
<div class="paragraph">
<p>Cookie Route Predicate Factory采用两个参数，即cookie名称和正则表达式。该谓词匹配具有给定名称的cookie，并且值匹配正则表达式。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: cookie_route
        uri: https://example.org
        predicates:
        - Cookie=chocolate, ch.p</code></pre>
</div>
</div>
<div class="paragraph">
<p>此路线与请求匹配，且有一个名为<code>chocolate</code>谁的价值与<code>ch.p</code>正则表达式。</p>
</div>
</div>
<div class="sect3">
<h4 id="header-route-predicate-factory"><a class="anchor" href="#header-route-predicate-factory"></a> <a class="link" href="#header-route-predicate-factory">16.4.5。标头路由谓词工厂</a></h4>
<div class="paragraph">
<p>标头路由谓词工厂采用两个参数，标头名称和正则表达式。该谓词与具有给定名称的标头匹配，并且值与正则表达式匹配。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: header_route
        uri: https://example.org
        predicates:
        - Header=X-Request-Id, \d+</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求的标题为，则此路由匹配<code>X-Request-Id</code>其值与<code>\d+</code>正则表达式（具有一个或多个数字的值）。</p>
</div>
</div>
<div class="sect3">
<h4 id="host-route-predicate-factory"><a class="anchor" href="#host-route-predicate-factory"></a> <a class="link" href="#host-route-predicate-factory">16.4.6。主机路由谓词工厂</a></h4>
<div class="paragraph">
<p>主机路由谓词工厂采用一个参数：主机名模式列表。该模式是具有<code>.</code>作为分隔符。这个谓词匹配<code>Host</code>与模式匹配的标题。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: host_route
        uri: https://example.org
        predicates:
        - Host=**.somehost.org,**.anotherhost.org</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI模板变量也受支持，例如<code>{sub}.myhost.org</code> 。</p>
</div>
<div class="paragraph">
<p>如果请求中包含一个<code>Host</code>标头具有值<code>www.somehost.org</code>要么<code>beta.somehost.org</code>要么<code>www.anotherhost.org</code> 。</p>
</div>
<div class="paragraph">
<p>该谓词提取URI模板变量（例如<code>sub</code>在上面的示例中定义）作为名称和值的映射，并将其放置在<code>ServerWebExchange.getAttributes()</code>用定义在<code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code> 。这些值可供<a href="#gateway-route-filters">GatewayFilter工厂</a>使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="method-route-predicate-factory"><a class="anchor" href="#method-route-predicate-factory"></a> <a class="link" href="#method-route-predicate-factory">16.4.7。方法路线谓词工厂</a></h4>
<div class="paragraph">
<p>方法路由谓词工厂使用一个参数：要匹配的HTTP方法。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: method_route
        uri: https://example.org
        predicates:
        - Method=GET</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求方法是<code>GET</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="path-route-predicate-factory"><a class="anchor" href="#path-route-predicate-factory"></a> <a class="link" href="#path-route-predicate-factory">16.4.8。路径路线谓词工厂</a></h4>
<div class="paragraph">
<p>路径路由谓词工厂采用两个参数：Spring列表<code>PathMatcher</code>模式和一个可选标志<code>matchOptionalTrailingSeparator</code> 。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: host_route
        uri: https://example.org
        predicates:
        - Path=/foo/{segment},/bar/{segment}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求路径为，则此路由将匹配，例如： <code>/foo/1</code>要么<code>/foo/bar</code>要么<code>/bar/baz</code> 。</p>
</div>
<div class="paragraph">
<p>该谓词提取URI模板变量（例如<code>segment</code>在上面的示例中定义）作为名称和值的映射，并将其放置在<code>ServerWebExchange.getAttributes()</code>用定义在<code>ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE</code> 。这些值可供<a href="#gateway-route-filters">GatewayFilter工厂</a>使用。</p>
</div>
<div class="paragraph">
<p>可以使用实用程序方法来简化对这些变量的访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Map<String, String> uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);

String segment = uriVariables.get("segment");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="query-route-predicate-factory"><a class="anchor" href="#query-route-predicate-factory"></a> <a class="link" href="#query-route-predicate-factory">16.4.9。查询路由谓词工厂</a></h4>
<div class="paragraph">
<p>查询路由谓词工厂采用两个参数：必需<code>param</code>和一个可选的<code>regexp</code> 。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: https://example.org
        predicates:
        - Query=baz</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求包含一个<code>baz</code>查询参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: https://example.org
        predicates:
        - Query=foo, ba.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求包含一个<code>foo</code>查询参数，其值与<code>ba.</code>正则表达式<code>bar</code>和<code>baz</code>会匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="remoteaddr-route-predicate-factory"><a class="anchor" href="#remoteaddr-route-predicate-factory"></a> <a class="link" href="#remoteaddr-route-predicate-factory">16.4.10。RemoteAddr路由谓词工厂</a></h4>
<div class="paragraph">
<p>RemoteAddr路由谓词工厂采用CIDR标记（IPv4或IPv6）字符串的列表（最小大小为1），例如<code>192.168.0.1/16</code> （哪里<code>192.168.0.1</code>是IP地址， <code>16</code>是子网掩码）。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: remoteaddr_route
        uri: https://example.org
        predicates:
        - RemoteAddr=192.168.1.1/24</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，如果请求的远程地址是<code>192.168.1.10</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="weight-route-predicate-factory"><a class="anchor" href="#weight-route-predicate-factory"></a> <a class="link" href="#weight-route-predicate-factory">16.4.11。重量路线谓词工厂</a></h4>
<div class="paragraph">
<p>权重路由谓词工厂采用两个参数组和权重。权重是按组计算的。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: weight_high
        uri: https://weighthigh.org
        predicates:
        - Weight=group1, 8
      - id: weight_low
        uri: https://weightlow.org
        predicates:
        - Weight=group1, 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这条路线会将约80％的流量转发至<a href="https://weighthigh.org" class="bare">weighthigh.org，</a>并将约20％的流量<a href="https://weighlow.org" class="bare">转发</a>至<a href="https://weighlow.org" class="bare">weightlow.org。</a></p>
</div>
<div class="sect4">
<h5 id="modifying-the-way-remote-addresses-are-resolved"><a class="anchor" href="#modifying-the-way-remote-addresses-are-resolved"></a> <a class="link" href="#modifying-the-way-remote-addresses-are-resolved">修改远程地址的解析方式</a></h5>
<div class="paragraph">
<p>默认情况下，RemoteAddr路由谓词工厂使用传入请求中的远程地址。如果Spring Cloud Gateway位于代理层后面，则此地址可能与实际的客户端IP地址不匹配。</p>
</div>
<div class="paragraph">
<p>您可以通过设置自定义来自定义解析远程地址的方式<code>RemoteAddressResolver</code> 。Spring Cloud Gateway随附了一个基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For">X-Forwarded-For标头的</a>非默认远程地址解析器， <code>XForwardedRemoteAddressResolver</code> 。</p>
</div>
<div class="paragraph">
<p><code>XForwardedRemoteAddressResolver</code>有两种静态构造方法，它们采用不同的安全性方法：</p>
</div>
<div class="paragraph">
<p><code>XForwardedRemoteAddressResolver::trustAll</code>返回一个<code>RemoteAddressResolver</code>它始终采用在<code>X-Forwarded-For</code>标头。这种方法容易受到欺骗的攻击，因为恶意客户端可能会为<code>X-Forwarded-For</code>解析器将接受。</p>
</div>
<div class="paragraph">
<p><code>XForwardedRemoteAddressResolver::maxTrustedIndex</code>取得与Spring Cloud Gateway前面运行的受信任基础架构数量相关的索引。例如，如果只能通过HAProxy访问Spring Cloud Gateway，则应使用值1。如果在访问Spring Cloud Gateway之前需要两跳可信基础架构，则应使用值2。</p>
</div>
<div class="paragraph">
<p>给定以下标头值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>X-Forwarded-For: 0.0.0.1, 0.0.0.2, 0.0.0.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>maxTrustedIndex</code>下面的值将产生以下远程地址。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>maxTrustedIndex</code></th>
<th class="tableblock halign-left valign-top">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ <code>Integer.MIN_VALUE</code> ，0]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（无效， <code>IllegalArgumentException</code>在初始化期间）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[4， <code>Integer.MAX_VALUE</code> ]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.0.0.1</p></td>
</tr>
</tbody>
</table>
<div id="gateway-route-filters" class="paragraph">
<p>使用Java配置：</p>
</div>
<div class="paragraph">
<p>GatewayConfig.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">RemoteAddressResolver resolver = XForwardedRemoteAddressResolver
    .maxTrustedIndex(1);

...

.route("direct-route",
    r -> r.remoteAddr("10.1.1.1", "10.10.1.1/24")
        .uri("https://downstream1")
.route("proxied-route",
    r -> r.remoteAddr(resolver,  "10.10.1.1", "10.10.1.1/24")
        .uri("https://downstream2")
)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gatewayfilter-factories"><a class="anchor" href="#gatewayfilter-factories"></a> <a class="link" href="#gatewayfilter-factories">16.5。GatewayFilter工厂</a></h3>
<div class="paragraph">
<p>路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路由过滤器适用于特定路由。Spring Cloud Gateway包括许多内置的GatewayFilter工厂。</p>
</div>
<div class="paragraph">
<p>注意有关如何使用以下任何过滤器的更多详细示例，请查看<a href="https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-core/src/test/java/org/springframework/cloud/gateway/filter/factory">单元测试</a> 。</p>
</div>
<div class="sect3">
<h4 id="addrequestheader-gatewayfilter-factory"><a class="anchor" href="#addrequestheader-gatewayfilter-factory"></a> <a class="link" href="#addrequestheader-gatewayfilter-factory">16.5.1。AddRequestHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>AddRequestHeader GatewayFilter工厂采用名称和值参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        filters:
        - AddRequestHeader=X-Request-Foo, Bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将添加<code>X-Request-Foo:Bar</code>所有匹配请求的下游请求标头的标头。</p>
</div>
<div class="paragraph">
<p>AddRequestHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        predicates:
        - Path=/foo/{segment}
        filters:
        - AddRequestHeader=X-Request-Foo, Bar-{segment}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="addrequestparameter-gatewayfilter-factory"><a class="anchor" href="#addrequestparameter-gatewayfilter-factory"></a> <a class="link" href="#addrequestparameter-gatewayfilter-factory">16.5.2。AddRequestParameter GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>AddRequestParameter GatewayFilter工厂采用名称和值参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: https://example.org
        filters:
        - AddRequestParameter=foo, bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将添加<code>foo=bar</code>所有匹配请求的下游请求的查询字符串。</p>
</div>
<div class="paragraph">
<p>AddRequestParameter知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - AddRequestParameter=foo, bar-{segment}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="addresponseheader-gatewayfilter-factory"><a class="anchor" href="#addresponseheader-gatewayfilter-factory"></a> <a class="link" href="#addresponseheader-gatewayfilter-factory">16.5.3。AddResponseHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>AddResponseHeader GatewayFilter工厂采用名称和值参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: add_response_header_route
        uri: https://example.org
        filters:
        - AddResponseHeader=X-Response-Foo, Bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将添加<code>X-Response-Foo:Bar</code>所有匹配请求的下游响应的标头的标头。</p>
</div>
<div class="paragraph">
<p>AddResponseHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: add_response_header_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - AddResponseHeader=foo, bar-{segment}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deduperesponseheader-gatewayfilter-factory"><a class="anchor" href="#deduperesponseheader-gatewayfilter-factory"></a> <a class="link" href="#deduperesponseheader-gatewayfilter-factory">16.5.4。DedupeResponseHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>DedupeResponseHeader GatewayFilter工厂需要一个<code>name</code>参数和可选<code>strategy</code>参数。 <code>name</code>可以包含标题名称列表，以空格分隔。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: dedupe_response_header_route
        uri: https://example.org
        filters:
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将删除重复的值<code>Access-Control-Allow-Credentials</code>和<code>Access-Control-Allow-Origin</code>网关CORS逻辑和下游CORS逻辑都添加它们时的响应头。</p>
</div>
<div class="paragraph">
<p>DedupeResponseHeader过滤器还接受可选<code>strategy</code>参数。可接受的值为<code>RETAIN_FIRST</code> （默认）， <code>RETAIN_LAST</code>和<code>RETAIN_UNIQUE</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="hystrix"><a class="anchor" href="#hystrix"></a> <a class="link" href="#hystrix">16.5.5。Hystrix GatewayFilter工厂</a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi__modules_in_maintenance_mode.html">Netflix已将Hystrix置于维护模式</a> 。建议您将<a href="#spring-cloud-circuitbreaker-filter-factory">Spring Cloud CircuitBreaker网关过滤器</a>与Resilience4J一起使用，因为在将来的版本中将不再支持Hystrix。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://github.com/Netflix/Hystrix">Hystrix</a>是Netflix的一个库，用于实现<a href="https://martinfowler.com/bliki/CircuitBreaker.html">断路器模式</a> 。Hystrix GatewayFilter允许您将断路器引入网关路由，从而保护您的服务免受级联故障的影响，并允许您在下游故障的情况下提供后备响应。</p>
</div>
<div class="paragraph">
<p>要在项目中启用Hystrix GatewayFilters，请添加对<code>spring-cloud-starter-netflix-hystrix</code>来自<a href="https://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix</a> 。</p>
</div>
<div class="paragraph">
<p>Hystrix GatewayFilter工厂需要一个<code>name</code>参数，它是名称<code>HystrixCommand</code> 。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: hystrix_route
        uri: https://example.org
        filters:
        - Hystrix=myCommandName</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将剩余的过滤器包装在<code>HystrixCommand</code>带有命令名称<code>myCommandName</code> 。</p>
</div>
<div class="paragraph">
<p>Hystrix过滤器也可以接受可选<code>fallbackUri</code>参数。目前，只有<code>forward:</code>支持计划的URI。如果调用了后备，则请求将被转发到与URI相匹配的控制器。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: hystrix_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingserviceendpoint
        filters:
        - name: Hystrix
          args:
            name: fallbackcmd
            fallbackUri: forward:/incaseoffailureusethis
        - RewritePath=/consumingserviceendpoint, /backingserviceendpoint</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将转发给<code>/incaseoffailureusethis</code>调用Hystrix后备时的URI。请注意，此示例还通过展示了（可选）Spring Cloud Netflix Ribbon负载平衡。 <code>lb</code>目标URI上的前缀。</p>
</div>
<div class="paragraph">
<p>主要方案是使用<code>fallbackUri</code>到网关应用程序中的内部控制器或处理程序。但是，也可以将请求重新路由到外部应用程序中的控制器或处理程序，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: Hystrix
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，没有<code>fallback</code>网关应用程序中的端点或处理程序，但是，另一个应用程序中有一个端点或处理程序，在<code><a href="http://localhost:9994" class="bare">localhost:9994</a></code> 。</p>
</div>
<div class="paragraph">
<p>如果将请求转发给后备，Hystrix网关过滤器还会提供<code>Throwable</code>造成了它。它已添加到<code>ServerWebExchange</code>作为<code>ServerWebExchangeUtils.HYSTRIX_EXECUTION_EXCEPTION_ATTR</code>在网关应用程序中处理后备时可以使用的属性。</p>
</div>
<div class="paragraph">
<p>对于外部控制器/处理程序方案，可以添加带有异常详细信息的标头。您可以在<a href="#fallback-headers">FallbackHeaders GatewayFilter Factory部分中</a>找到有关它的更多信息。</p>
</div>
<div class="paragraph">
<p>Hystrix设置（例如超时）可以配置为全局默认值，也可以使用<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix Wiki</a>上说明的应用程序属性在<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">逐条</a>路由的基础上进行配置。</p>
</div>
<div class="paragraph">
<p>要为上述示例路由设置5秒超时，将使用以下配置：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">hystrix.command.fallbackcmd.execution.isolation.thread.timeoutInMilliseconds: 5000</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-circuitbreaker-filter-factory"><a class="anchor" href="#spring-cloud-circuitbreaker-filter-factory"></a> <a class="link" href="#spring-cloud-circuitbreaker-filter-factory">16.5.6。Spring Cloud CircuitBreaker GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>Spring Cloud CircuitBreaker过滤器工厂利用Spring Cloud CircuitBreaker API将网关路由包装在断路器中。Spring Cloud CircuitBreaker支持可与Spring Cloud Gateway一起使用的两个库Hystrix和Resilience4J。由于Netflix将Hystrix置于仅维护模式，因此我们建议您使用Resilience4J。</p>
</div>
<div class="paragraph">
<p>要启用Spring Cloud CircuitBreaker过滤器，您将需要放置<code>spring-cloud-starter-circuitbreaker-reactor-resilience4j</code>要么<code>spring-cloud-starter-netflix-hystrix</code>在类路径上。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: https://example.org
        filters:
        - CircuitBreaker=myCircuitBreaker</code></pre>
</div>
</div>
<div class="paragraph">
<p>要配置断路器，请参阅所使用的基础断路器实现的配置。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html">Resilience4J文档</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-netflix/reference/html/">Hystrix文档</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud CircuitBreaker过滤器也可以接受可选<code>fallbackUri</code>参数。目前，只有<code>forward:</code>支持计划的URI。如果调用了后备，则请求将被转发到与URI相匹配的控制器。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingServiceEndpoint
        filters:
        - name: CircuitBreaker
          args:
            name: myCircuitBreaker
            fallbackUri: forward:/inCaseOfFailureUseThis
        - RewritePath=/consumingServiceEndpoint, /backingServiceEndpoint</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("circuitbreaker_route", r -> r.path("/consumingServiceEndpoint")
            .filters(f -> f.circuitBreaker(c -> c.name("myCircuitBreaker").fallbackUri("forward:/inCaseOfFailureUseThis"))
                .rewritePath("/consumingServiceEndpoint", "/backingServiceEndpoint")).uri("lb://backing-service:8088")
        .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将转发给<code>/inCaseofFailureUseThis</code>调用断路器回退时的URI。请注意，此示例还通过展示了（可选）Spring Cloud Netflix Ribbon负载平衡。 <code>lb</code>目标URI上的前缀。</p>
</div>
<div class="paragraph">
<p>主要方案是使用<code>fallbackUri</code>到网关应用程序中的内部控制器或处理程序。但是，也可以将请求重新路由到外部应用程序中的控制器或处理程序，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: CircuitBreaker
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，没有<code>fallback</code>网关应用程序中的端点或处理程序，但是，另一个应用程序中有一个端点或处理程序，在<code><a href="http://localhost:9994" class="bare">localhost:9994</a></code> 。</p>
</div>
<div class="paragraph">
<p>如果将请求转发给后备，则Spring Cloud CircuitBreaker网关过滤器还会提供<code>Throwable</code>造成了它。它已添加到<code>ServerWebExchange</code>作为<code>ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR</code>在网关应用程序中处理后备时可以使用的属性。</p>
</div>
<div class="paragraph">
<p>对于外部控制器/处理程序方案，可以添加带有异常详细信息的标头。您可以在<a href="#fallback-headers">FallbackHeaders GatewayFilter Factory部分中</a>找到有关它的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="fallback-headers"><a class="anchor" href="#fallback-headers"></a> <a class="link" href="#fallback-headers">16.5.7。FallbackHeaders GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>的<code>FallbackHeaders</code>工厂允许您在转发到请求的请求的标头中添加Hystrix或Spring Cloud CircuitBreaker执行异常详细信息<code>fallbackUri</code>在外部应用程序中，例如在以下情况下：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: CircuitBreaker
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback
        filters:
        - name: FallbackHeaders
          args:
            executionExceptionTypeHeaderName: Test-Header</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，在运行断路器时发生执行异常后，该请求将被转发到<code>fallback</code>在上运行的应用程序中的终结点或处理程序<code>localhost:9994</code> 。具有异常类型，消息和-if available-根本原因异常类型和消息的标头将由<code>FallbackHeaders</code>过滤。</p>
</div>
<div class="paragraph">
<p>通过设置下面列出的参数的值及其默认值，可以在配置中覆盖标头的名称：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>executionExceptionTypeHeaderName</code> （ <code>"Execution-Exception-Type"</code> ）</p>
</li>
<li>
<p><code>executionExceptionMessageHeaderName</code> （ <code>"Execution-Exception-Message"</code> ）</p>
</li>
<li>
<p><code>rootCauseExceptionTypeHeaderName</code> （ <code>"Root-Cause-Exception-Type"</code> ）</p>
</li>
<li>
<p><code>rootCauseExceptionMessageHeaderName</code> （ <code>"Root-Cause-Exception-Message"</code> ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关电路烧杯和网关的更多信息，请参见<a href="#hystrix">Hystrix GatewayFilter Factory部分</a>或<a href="#spring-cloud-circuitbreaker-filter-factory">Spring Cloud CircuitBreaker Factory部分</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="maprequestheader-gatewayfilter-factory"><a class="anchor" href="#maprequestheader-gatewayfilter-factory"></a> <a class="link" href="#maprequestheader-gatewayfilter-factory">16.5.8。MapRequestHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>MapRequestHeader GatewayFilter工厂采用'fromHeader'和'toHeader'参数。它创建一个新的命名标头（toHeader），并从传入的HTTP请求中从一个现有的命名标头（fromHeader）中提取值。如果输入标头不存在，则过滤器不起作用。如果新的命名标头已经存在，则其值将使用新值进行扩充。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: map_request_header_route
        uri: https://example.org
        filters:
        - MapRequestHeader=Bar, X-Request-Foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将添加<code>X-Request-Foo:<values></code>下游请求的标头，其中包含传入的http请求的更新值<code>Bar</code>标头。</p>
</div>
</div>
<div class="sect3">
<h4 id="prefixpath-gatewayfilter-factory"><a class="anchor" href="#prefixpath-gatewayfilter-factory"></a> <a class="link" href="#prefixpath-gatewayfilter-factory">16.5.9。PrefixPath GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>PrefixPath GatewayFilter工厂需要一个<code>prefix</code>参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - PrefixPath=/mypath</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将前缀<code>/mypath</code>到所有匹配请求的路径。所以要求<code>/hello</code> ，将被发送到<code>/mypath/hello</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="preservehostheader-gatewayfilter-factory"><a class="anchor" href="#preservehostheader-gatewayfilter-factory"></a> <a class="link" href="#preservehostheader-gatewayfilter-factory">16.5.10。PreserveHostHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>PreserveHostHeader GatewayFilter工厂没有参数。此筛选器设置请求属性，路由筛选器将检查该请求属性，以确定是否应发送原始主机头，而不是由HTTP客户端确定的主机头。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: preserve_host_route
        uri: https://example.org
        filters:
        - PreserveHostHeader</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="requestratelimiter-gatewayfilter-factory"><a class="anchor" href="#requestratelimiter-gatewayfilter-factory"></a> <a class="link" href="#requestratelimiter-gatewayfilter-factory">16.5.11。RequestRateLimiter GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RequestRateLimiter GatewayFilter工厂使用<code>RateLimiter</code>确定当前请求是否被允许进行的实现。如果不是，则状态为<code>HTTP 429 - Too Many Requests</code> （默认）返回。</p>
</div>
<div class="paragraph">
<p>该过滤器需要一个可选的<code>keyResolver</code>参数和速率限制器特定的参数（请参见下文）。</p>
</div>
<div class="paragraph">
<p><code>keyResolver</code>是实现了<code>KeyResolver</code>接口。在配置中，使用SpEL按名称引用bean。 <code>#{@myKeyResolver}</code>是SpEL表达式，其引用具有以下名称的bean <code>myKeyResolver</code> 。</p>
</div>
<div class="listingblock">
<div class="title">KeyResolver.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface KeyResolver {
    Mono<String> resolve(ServerWebExchange exchange);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>KeyResolver</code>接口允许可插拔策略派生用于限制请求的密钥。在未来的里程碑中，将会有一些<code>KeyResolver</code>实现。</p>
</div>
<div class="paragraph">
<p>默认实现<code>KeyResolver</code>是个<code>PrincipalNameKeyResolver</code>检索<code>Principal</code>来自<code>ServerWebExchange</code>和电话<code>Principal.getName()</code> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果<code>KeyResolver</code>找不到密钥，请求将被拒绝。可以使用<code>spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key</code> （对或错）和<code>spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code</code>属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">无法通过“快捷方式”符号配置RequestRateLimiter。以下示例<em>无效</em>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre># INVALID SHORTCUT CONFIGURATION
spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=2, 2, #{@userkeyresolver}</pre>
</div>
</div>
<div class="sect4">
<h5 id="redis-ratelimiter"><a class="anchor" href="#redis-ratelimiter"></a> <a class="link" href="#redis-ratelimiter">Redis RateLimiter</a></h5>
<div class="paragraph">
<p>redis实现基于<a href="https://stripe.com/blog/rate-limiters">Stripe</a>所做的工作。它需要使用<code>spring-boot-starter-data-redis-reactive</code> Spring Boot启动器。</p>
</div>
<div class="paragraph">
<p>使用的算法是<a href="https://en.wikipedia.org/wiki/Token_bucket">令牌桶算法</a> 。</p>
</div>
<div class="paragraph">
<p>的<code>redis-rate-limiter.replenishRate</code>是您希望用户每秒允许多少个请求，而没有任何丢弃的请求。这是令牌桶被填充的速率。</p>
</div>
<div class="paragraph">
<p>的<code>redis-rate-limiter.burstCapacity</code>是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以容纳的令牌数。将此值设置为零将阻止所有请求。</p>
</div>
<div class="paragraph">
<p>通过设置相同的值可以实现稳定的速率<code>replenishRate</code>和<code>burstCapacity</code> 。通过设置可以允许临时连拍<code>burstCapacity</code>比......高<code>replenishRate</code> 。在这种情况下，速率限制器需要在两次突发之间留出一些时间（根据<code>replenishRate</code> ），因为连续2次突发会导致请求丢弃（ <code>HTTP 429 - Too Many Requests</code> ）。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            redis-rate-limiter.replenishRate: 10
            redis-rate-limiter.burstCapacity: 20</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">配置文件</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
KeyResolver userKeyResolver() {
    return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst("user"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这定义了每个用户10的请求速率限制。允许20个突发，但是下一秒只有10个请求可用。的<code>KeyResolver</code>是一个简单的<code>user</code>请求参数（注意：不建议在生产中使用）。</p>
</div>
<div class="paragraph">
<p>速率限制器也可以定义为实现<code>RateLimiter</code>接口。在配置中，使用SpEL按名称引用bean。 <code>#{@myRateLimiter}</code>是SpEL表达式，其引用具有以下名称的bean <code>myRateLimiter</code> 。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            rate-limiter: "#{@myRateLimiter}"
            key-resolver: "#{@userKeyResolver}"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redirectto-gatewayfilter-factory"><a class="anchor" href="#redirectto-gatewayfilter-factory"></a> <a class="link" href="#redirectto-gatewayfilter-factory">16.5.12。重定向到GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RedirectTo GatewayFilter工厂需要一个<code>status</code>和一个<code>url</code>参数。状态应该是300系列重定向http代码，例如301。该网址应为有效的网址。这将是<code>Location</code>标头。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - RedirectTo=302, https://acme.org</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将发送状态302和<code>Location:https://acme.org</code>标头以执行重定向。</p>
</div>
</div>
<div class="sect3">
<h4 id="removehopbyhopheadersfilter-gatewayfilter-factory"><a class="anchor" href="#removehopbyhopheadersfilter-gatewayfilter-factory"></a> <a class="link" href="#removehopbyhopheadersfilter-gatewayfilter-factory">16.5.13。RemoveHopByHopHeadersFilter GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RemoveHopByHopHeadersFilter GatewayFilter工厂从转发的请求中删除标头。被删除的头的默认列表来自<a href="https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3">IETF</a> 。</p>
</div>
<div class="ulist">
<div class="title">默认删除的标题是：</div>
<ul>
<li>
<p>连接</p>
</li>
<li>
<p>活着</p>
</li>
<li>
<p>代理验证</p>
</li>
<li>
<p>代理授权</p>
</li>
<li>
<p>TE</p>
</li>
<li>
<p>预告片</p>
</li>
<li>
<p>传输编码</p>
</li>
<li>
<p>升级</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要更改此设置，请设置<code>spring.cloud.gateway.filter.remove-non-proxy-headers.headers</code>属性以删除标题名称列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="removerequestheader-gatewayfilter-factory"><a class="anchor" href="#removerequestheader-gatewayfilter-factory"></a> <a class="link" href="#removerequestheader-gatewayfilter-factory">16.5.14。RemoveRequestHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RemoveRequestHeader GatewayFilter工厂需要一个<code>name</code>参数。它是要删除的标题的名称。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: removerequestheader_route
        uri: https://example.org
        filters:
        - RemoveRequestHeader=X-Request-Foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将删除<code>X-Request-Foo</code>标头发送到下游之前。</p>
</div>
</div>
<div class="sect3">
<h4 id="removeresponseheader-gatewayfilter-factory"><a class="anchor" href="#removeresponseheader-gatewayfilter-factory"></a> <a class="link" href="#removeresponseheader-gatewayfilter-factory">16.5.15。RemoveResponseHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RemoveResponseHeader GatewayFilter工厂需要一个<code>name</code>参数。它是要删除的标题的名称。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: removeresponseheader_route
        uri: https://example.org
        filters:
        - RemoveResponseHeader=X-Response-Foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将删除<code>X-Response-Foo</code>响应的标头，然后返回给网关客户端。</p>
</div>
<div class="paragraph">
<p>要删除任何类型的敏感标头，应为可能需要的任何路由配置此过滤器。此外，您可以使用一次配置此过滤器<code>spring.cloud.gateway.default-filters</code>并将其应用于所有路线。</p>
</div>
</div>
<div class="sect3">
<h4 id="removerequestparameter-gatewayfilter-factory"><a class="anchor" href="#removerequestparameter-gatewayfilter-factory"></a> <a class="link" href="#removerequestparameter-gatewayfilter-factory">16.5.16。RemoveRequestParameter GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RemoveRequestParameter GatewayFilter工厂需要一个<code>name</code>参数。它是要删除的查询参数的名称。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: removerequestparameter_route
        uri: https://example.org
        filters:
        - RemoveRequestParameter=foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将删除<code>foo</code>参数在向下游发送之前。</p>
</div>
</div>
<div class="sect3">
<h4 id="rewritepath-gatewayfilter-factory"><a class="anchor" href="#rewritepath-gatewayfilter-factory"></a> <a class="link" href="#rewritepath-gatewayfilter-factory">16.5.17。RewritePath GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RewritePath GatewayFilter工厂采用路径<code>regexp</code>参数和一个<code>replacement</code>参数。这使用Java正则表达式提供了一种灵活的方式来重写请求路径。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: rewritepath_route
        uri: https://example.org
        predicates:
        - Path=/foo/**
        filters:
        - RewritePath=/foo(?<segment>/?.*), $\{segment}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于的请求路径<code>/foo/bar</code> ，这会将路径设置为<code>/bar</code>在发出下游请求之前。注意<code>$</code>应该换成<code>$\</code>由于YAML规范。</p>
</div>
</div>
<div class="sect3">
<h4 id="rewritelocationresponseheader-gatewayfilter-factory"><a class="anchor" href="#rewritelocationresponseheader-gatewayfilter-factory"></a> <a class="link" href="#rewritelocationresponseheader-gatewayfilter-factory">16.5.18。RewriteLocationResponseHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RewriteLocationResponseHeader GatewayFilter Factory修改的值<code>Location</code>响应标头，通常摆脱后端特定的细节。它需要<code>stripVersionMode</code> ， <code>locationHeaderName</code> ， <code>hostValue</code>和<code>protocolsRegex</code>参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: rewritelocationresponseheader_route
        uri: http://example.org
        filters:
        - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, ,</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，对于一个请求<code>POST <a href="https://api.example.com/some/object/name" class="bare">api.example.com/some/object/name</a></code> ， <code>Location</code>响应头值<code><a href="https://object-service.prod.example.net/v2/some/object/id" class="bare">object-service.prod.example.net/v2/some/object/id</a></code>将被重写为<code><a href="https://api.example.com/some/object/id" class="bare">api.example.com/some/object/id</a></code> 。</p>
</div>
<div class="paragraph">
<p>参数<code>stripVersionMode</code>具有以下可能的值： <code>NEVER_STRIP</code> ， <code>AS_IN_REQUEST</code> （默认）， <code>ALWAYS_STRIP</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NEVER_STRIP</code> -即使原始请求路径不包含任何版本，也不会剥离版本</p>
</li>
<li>
<p><code>AS_IN_REQUEST</code> -仅当原始请求路径不包含版本时，版本才会被剥离</p>
</li>
<li>
<p><code>ALWAYS_STRIP</code> -即使原始请求路径包含版本，也会删除版本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>参数<code>hostValue</code> （如果提供），将用于替换<code>host:port</code>响应的一部分<code>Location</code>标头。如果未提供，则<code>Host</code>将使用请求标头。</p>
</div>
<div class="paragraph">
<p>参数<code>protocolsRegex</code>必须是有效的正则表达式<code>String</code> ，协议名称将与之匹配。如果不匹配，过滤器将不执行任何操作。默认为<code>http|https|ftp|ftps</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="rewriteresponseheader-gatewayfilter-factory"><a class="anchor" href="#rewriteresponseheader-gatewayfilter-factory"></a> <a class="link" href="#rewriteresponseheader-gatewayfilter-factory">16.5.19。RewriteResponseHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>RewriteResponseHeader GatewayFilter工厂需要<code>name</code> ， <code>regexp</code>和<code>replacement</code>参数。它使用Java正则表达式以灵活的方式重写响应标头值。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: rewriteresponseheader_route
        uri: https://example.org
        filters:
        - RewriteResponseHeader=X-Response-Foo, , password=[^&]+, password=***</code></pre>
</div>
</div>
<div class="paragraph">
<p>标头值为<code>/42?user=ford&password=omg!what&flag=true</code> ，它将设置为<code>/42?user=ford&password=***&flag=true</code>发出下游请求后。请用<code>$\</code>意思是<code>$</code>由于YAML规范。</p>
</div>
</div>
<div class="sect3">
<h4 id="savesession-gatewayfilter-factory"><a class="anchor" href="#savesession-gatewayfilter-factory"></a> <a class="link" href="#savesession-gatewayfilter-factory">16.5.20。SaveSession GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>SaveSession GatewayFilter工厂强制执行<code>WebSession::save</code>将呼叫转接到下游<em>之前进行</em>这在将诸如<a href="https://projects.spring.io/spring-session/">Spring Session之类的内容</a>与惰性数据存储一起使用时特别有用，并且需要确保在进行转发呼叫之前已保存会话状态。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: save_session
        uri: https://example.org
        predicates:
        - Path=/foo/**
        filters:
        - SaveSession</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您将<a href="https://projects.spring.io/spring-security/">Spring Security</a>与Spring Session集成在一起，并且想要确保安全性详细信息已转发到远程进程，那么这一点至关重要。</p>
</div>
</div>
<div class="sect3">
<h4 id="secureheaders-gatewayfilter-factory"><a class="anchor" href="#secureheaders-gatewayfilter-factory"></a> <a class="link" href="#secureheaders-gatewayfilter-factory">16.5.21。SecureHeaders GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>根据<a href="https://blog.appcanary.com/2017/http-security-headers.html">此博客文章</a>的建议，SecureHeaders GatewayFilter Factory在响应中添加了许多标头。</p>
</div>
<div class="ulist">
<div class="title">添加了以下标头（以及默认值）：</div>
<ul>
<li>
<p><code>X-Xss-Protection:1; mode=block</code></p>
</li>
<li>
<p><code>Strict-Transport-Security:max-age=631138519</code></p>
</li>
<li>
<p><code>X-Frame-Options:DENY</code></p>
</li>
<li>
<p><code>X-Content-Type-Options:nosniff</code></p>
</li>
<li>
<p><code>Referrer-Policy:no-referrer</code></p>
</li>
<li>
<p><code>Content-Security-Policy:default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline'</code></p>
</li>
<li>
<p><code>X-Download-Options:noopen</code></p>
</li>
<li>
<p><code>X-Permitted-Cross-Domain-Policies:none</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要更改默认值，请在<code>spring.cloud.gateway.filter.secure-headers</code>命名空间：</p>
</div>
<div class="ulist">
<div class="title">要更改的属性：</div>
<ul>
<li>
<p><code>xss-protection-header</code></p>
</li>
<li>
<p><code>strict-transport-security</code></p>
</li>
<li>
<p><code>frame-options</code></p>
</li>
<li>
<p><code>content-type-options</code></p>
</li>
<li>
<p><code>referrer-policy</code></p>
</li>
<li>
<p><code>content-security-policy</code></p>
</li>
<li>
<p><code>download-options</code></p>
</li>
<li>
<p><code>permitted-cross-domain-policies</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要禁用默认值，请设置属性<code>spring.cloud.gateway.filter.secure-headers.disable</code>用逗号分隔的值。</p>
</div>
<div class="paragraph">
<div class="title">例：</div>
<p><code>spring.cloud.gateway.filter.secure-headers.disable=frame-options,download-options</code></p>
</div>
</div>
<div class="sect3">
<h4 id="setpath-gatewayfilter-factory"><a class="anchor" href="#setpath-gatewayfilter-factory"></a> <a class="link" href="#setpath-gatewayfilter-factory">16.5.22。SetPath GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>SetPath GatewayFilter工厂采用路径<code>template</code>参数。通过允许路径的模板段，它提供了一种操作请求路径的简单方法。这使用了Spring Framework中的uri模板。允许多个匹配段。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setpath_route
        uri: https://example.org
        predicates:
        - Path=/foo/{segment}
        filters:
        - SetPath=/{segment}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于的请求路径<code>/foo/bar</code> ，这会将路径设置为<code>/bar</code>在发出下游请求之前。</p>
</div>
</div>
<div class="sect3">
<h4 id="setrequestheader-gatewayfilter-factory"><a class="anchor" href="#setrequestheader-gatewayfilter-factory"></a> <a class="link" href="#setrequestheader-gatewayfilter-factory">16.5.23。SetRequestHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>SetRequestHeader GatewayFilter工厂需要<code>name</code>和<code>value</code>参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        filters:
        - SetRequestHeader=X-Request-Foo, Bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>该GatewayFilter用给定的名称替换所有标头，而不是添加。因此，如果下游服务器以<code>X-Request-Foo:1234</code> ，它将被替换为<code>X-Request-Foo:Bar</code> ，这是下游服务将收到的。</p>
</div>
<div class="paragraph">
<p>SetRequestHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - SetRequestHeader=foo, bar-{segment}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setresponseheader-gatewayfilter-factory"><a class="anchor" href="#setresponseheader-gatewayfilter-factory"></a> <a class="link" href="#setresponseheader-gatewayfilter-factory">16.5.24。SetResponseHeader GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>SetResponseHeader GatewayFilter工厂需要<code>name</code>和<code>value</code>参数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setresponseheader_route
        uri: https://example.org
        filters:
        - SetResponseHeader=X-Response-Foo, Bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>该GatewayFilter用给定的名称替换所有标头，而不是添加。因此，如果下游服务器以<code>X-Response-Foo:1234</code> ，它将被替换为<code>X-Response-Foo:Bar</code> ，这是网关客户端将收到的。</p>
</div>
<div class="paragraph">
<p>SetResponseHeader知道用于匹配路径或主机的URI变量。URI变量可用于该值，并将在运行时扩展。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setresponseheader_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - SetResponseHeader=foo, bar-{segment}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setstatus-gatewayfilter-factory"><a class="anchor" href="#setstatus-gatewayfilter-factory"></a> <a class="link" href="#setstatus-gatewayfilter-factory">16.5.25。SetStatus GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>SetStatus GatewayFilter工厂需要一个<code>status</code>参数。它必须是有效的Spring <code>HttpStatus</code> 。可能是整数值<code>404</code>或枚举的字符串表示形式<code>NOT_FOUND</code> 。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setstatusstring_route
        uri: https://example.org
        filters:
        - SetStatus=BAD_REQUEST
      - id: setstatusint_route
        uri: https://example.org
        filters:
        - SetStatus=401</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论哪种情况，响应的HTTP状态都将设置为401。</p>
</div>
<div class="paragraph">
<p>可以将SetStatus GatewayFilter配置为在响应的标头中从代理请求返回原始HTTP状态代码。如果使用以下属性配置标题，则会将其添加到响应中。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      set-status:
        original-status-header-name: original-http-status</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stripprefix-gatewayfilter-factory"><a class="anchor" href="#stripprefix-gatewayfilter-factory"></a> <a class="link" href="#stripprefix-gatewayfilter-factory">16.5.26。StripPrefix GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>StripPrefix GatewayFilter工厂采用一个参数， <code>parts</code> 。的<code>parts</code>参数指示在向下游发送请求之前要从请求中剥离的路径中的零件数。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: nameRoot
        uri: https://nameservice
        predicates:
        - Path=/name/**
        filters:
        - StripPrefix=2</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过网关发出请求时<code>/name/bar/foo</code>要求<code>nameservice</code>看起来像<code><a href="https://nameservice/foo" class="bare">nameservice/foo</a></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="retry-gatewayfilter-factory"><a class="anchor" href="#retry-gatewayfilter-factory"></a> <a class="link" href="#retry-gatewayfilter-factory">16.5.27。重试GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>重试GatewayFilter工厂支持以下参数集：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>retries</code> ：应尝试的重试次数</p>
</li>
<li>
<p><code>statuses</code> ：应重试的HTTP状态代码，用表示<code>org.springframework.http.HttpStatus</code></p>
</li>
<li>
<p><code>methods</code> ：应重试的HTTP方法，使用表示<code>org.springframework.http.HttpMethod</code></p>
</li>
<li>
<p><code>series</code> ：要重试的一系列状态代码，用表示<code>org.springframework.http.HttpStatus.Series</code></p>
</li>
<li>
<p><code>exceptions</code> ：应重试引发的异常列表</p>
</li>
<li>
<p><code>backoff</code> ：为重试配置了指数补偿。重试间隔为<code>firstBackoff * (factor ^ n)</code>哪里<code>n</code>是迭代。如果<code>maxBackoff</code>配置后，应用的最大退避将被限制为<code>maxBackoff</code> 。如果<code>basedOnPreviousValue</code>是真实的，退避将使用<code>prevBackoff * factor</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为以下配置了默认值<code>Retry</code>过滤器（如果启用）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>retries</code> - 3次</p>
</li>
<li>
<p><code>series</code> — 5XX系列</p>
</li>
<li>
<p><code>methods</code> — GET方法</p>
</li>
<li>
<p><code>exceptions</code> - <code>IOException</code>和<code>TimeoutException</code></p>
</li>
<li>
<p><code>backoff</code> —禁用</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: retry_test
        uri: http://localhost:8080/flakey
        predicates:
        - Host=*.retry.com
        filters:
        - name: Retry
          args:
            retries: 3
            statuses: BAD_GATEWAY
            backoff:
              firstBackoff: 10ms
              maxBackoff: 50ms
              factor: 2
              basedOnPreviousValue: false</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">重试过滤器当前不支持使用主体重试（例如，使用主体进行POST或PUT请求）。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">将重试过滤器与<code>forward:</code>带有前缀URL的目标端点应仔细编写，以便在发生错误的情况下不会执行任何可能导致响应发送到客户端并提交的操作。例如，如果目标端点是带注释的控制器，则目标控制器方法不应返回<code>ResponseEntity</code>错误状态代码。相反，它应该抛出一个<code>Exception</code> ，或发出错误信号，例如通过<code>Mono.error(ex)</code>返回值，可以将重试过滤器配置为通过重试处理。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="requestsize-gatewayfilter-factory"><a class="anchor" href="#requestsize-gatewayfilter-factory"></a> <a class="link" href="#requestsize-gatewayfilter-factory">16.5.28。RequestSize GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>当请求大小大于允许的限制时，RequestSize GatewayFilter Factory可以限制请求到达下游服务。过滤器需要<code>RequestSize</code>作为参数，它是请求的允许大小限制（以字节为单位）。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: request_size_route
        uri: http://localhost:8080/upload
        predicates:
        - Path=/upload
        filters:
        - name: RequestSize
          args:
            maxSize: 5000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>RequestSize GatewayFilter Factory将响应状态设置为<code>413 Payload Too Large</code>带有额外的标题<code>errorMessage</code>当请求由于大小而被拒绝时。以下是这样一个例子<code>errorMessage</code> 。</p>
</div>
<div class="paragraph">
<p><code>errorMessage</code> ：<code>Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB</code></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果未在路由定义中作为过滤器参数提供，则默认请求大小将设置为5 MB。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="modify-request-body-gatewayfilter-factory"><a class="anchor" href="#modify-request-body-gatewayfilter-factory"></a> <a class="link" href="#modify-request-body-gatewayfilter-factory">16.5.29。修改请求正文GatewayFilter工厂</a></h4>
<div class="paragraph">
<p><strong>该过滤器被认为是BETA，API将来可能会更改</strong></p>
</div>
<div class="paragraph">
<p>此过滤器可用于在网关将请求主体发送到下游之前修改请求主体。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">只能使用Java DSL配置此过滤器</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("rewrite_request_obj", r -> r.host("*.rewriterequestobj.org")
            .filters(f -> f.prefixPath("/httpbin")
                .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE,
                    (exchange, s) -> return Mono.just(new Hello(s.toUpperCase())))).uri(uri))
        .build();
}

static class Hello {
    String message;

    public Hello() { }

    public Hello(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="modify-response-body-gatewayfilter-factory"><a class="anchor" href="#modify-response-body-gatewayfilter-factory"></a> <a class="link" href="#modify-response-body-gatewayfilter-factory">16.5.30。修改响应主体GatewayFilter工厂</a></h4>
<div class="paragraph">
<p><strong>该过滤器被认为是BETA，API将来可能会更改</strong></p>
</div>
<div class="paragraph">
<p>此过滤器可用于在将响应正文发送回客户端之前对其进行修改。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">只能使用Java DSL配置此过滤器</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("rewrite_response_upper", r -> r.host("*.rewriteresponseupper.org")
            .filters(f -> f.prefixPath("/httpbin")
                .modifyResponseBody(String.class, String.class,
                    (exchange, s) -> Mono.just(s.toUpperCase()))).uri(uri)
        .build();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="default-filters"><a class="anchor" href="#default-filters"></a> <a class="link" href="#default-filters">16.5.31。默认过滤器</a></h4>
<div class="paragraph">
<p>如果您想添加过滤器并将其应用于所有路由，则可以使用<code>spring.cloud.gateway.default-filters</code> 。该属性采用过滤器列表</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      default-filters:
      - AddResponseHeader=X-Response-Default-Foo, Default-Bar
      - PrefixPath=/httpbin</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="global-filters"><a class="anchor" href="#global-filters"></a> <a class="link" href="#global-filters">16.6。全局过滤器</a></h3>
<div class="paragraph">
<p>的<code>GlobalFilter</code>接口具有与以下相同的签名<code>GatewayFilter</code> 。这些是特殊过滤器，有条件地应用于所有路由。（此界面和用法可能会在将来的里程碑中更改）。</p>
</div>
<div class="sect3">
<h4 id="combined-global-filter-and-gatewayfilter-ordering"><a class="anchor" href="#combined-global-filter-and-gatewayfilter-ordering"></a> <a class="link" href="#combined-global-filter-and-gatewayfilter-ordering">16.6.1。全局过滤器和GatewayFilter的组合订购</a></h4>
<div class="paragraph">
<p>当请求进入（并与路由匹配）时，过滤网络处理程序将添加的所有实例<code>GlobalFilter</code>以及的所有路由特定实例<code>GatewayFilter</code>过滤器链。该组合的过滤器链按<code>org.springframework.core.Ordered</code>接口，可以通过实施<code>getOrder()</code>方法。</p>
</div>
<div class="paragraph">
<p>由于Spring Cloud Gateway区分了执行过滤器逻辑的“前”阶段和“后”阶段（请参阅： <a href="#gateway-how-it-works">工作原理</a> ），因此优先级最高的过滤器将在“前”阶段中处于第一个阶段，而在“后”阶段中处于最后一个阶段“-相。</p>
</div>
<div class="listingblock">
<div class="title">ExampleConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public GlobalFilter customFilter() {
    return CustomGlobalFilter();
}

public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("custom global filter");
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return -1;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="forward-routing-filter"><a class="anchor" href="#forward-routing-filter"></a> <a class="link" href="#forward-routing-filter">16.6.2。正向路由过滤器</a></h4>
<div class="paragraph">
<p>的<code>ForwardRoutingFilter</code>在交换属性中查找URI <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 。如果网址中有一个<code>forward</code>方案（即<code>forward:///localendpoint</code> ），它将使用Spring <code>DispatcherHandler</code>处理请求。请求URL的路径部分将被转发URL中的路径覆盖。未经修改的原始网址会附加到列表中<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="loadbalancerclient-filter"><a class="anchor" href="#loadbalancerclient-filter"></a> <a class="link" href="#loadbalancerclient-filter">16.6.3。LoadBalancerClient筛选器</a></h4>
<div class="paragraph">
<p>的<code>LoadBalancerClientFilter</code>在交换属性中查找URI <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 。如果网址中有一个<code>lb</code>方案（即<code>lb://myservice</code> ），它将使用Spring Cloud <code>LoadBalancerClient</code>解析名称（ <code>myservice</code>在上一个示例中）到实际的主机和端口，并替换相同属性中的URI。未经修改的原始网址会附加到列表中<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性。过滤器还会在<code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>属性以查看是否等于<code>lb</code>然后适用相同的规则。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: myRoute
        uri: lb://service
        predicates:
        - Path=/service/**</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，当无法在<code>LoadBalancer</code>一种<code>503</code>将被退回。您可以配置网关以返回<code>404</code>通过设置<code>spring.cloud.gateway.loadbalancer.use404=true</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>isSecure</code>的价值<code>ServiceInstance</code>从返回<code>LoadBalancer</code>将覆盖对网关的请求中指定的方案。例如，如果请求通过<code>HTTPS</code>但是<code>ServiceInstance</code>表示它是不安全的，则下游请求将被<code>HTTP</code> 。相反的情况也可以适用。但是如果<code>GATEWAY_SCHEME_PREFIX_ATTR</code>在网关配置中为路由指定了，前缀将被删除，路由URL产生的方案将覆盖<code>ServiceInstance</code>组态。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="警告"></i>
</td>
<td class="content">
<code>LoadBalancerClientFilter</code>使用阻挡色带<code>LoadBalancerClient</code>在引擎盖下。我们建议您使用<a href="#reactive-loadbalancer-client-filter"><code>ReactiveLoadBalancerClientFilter</code>相反</a> 。您可以通过设置<code>spring.cloud.loadbalancer.ribbon.enabled</code>至<code>false</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="reactive-loadbalancer-client-filter"><a class="anchor" href="#reactive-loadbalancer-client-filter"></a> <a class="link" href="#reactive-loadbalancer-client-filter">16.6.4。ReactiveLoadBalancerClientFilter</a></h4>
<div class="paragraph">
<p>的<code>ReactiveLoadBalancerClientFilter</code>在交换属性中查找URI <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> 。如果网址中有一个<code>lb</code>方案（即<code>lb://myservice</code> ），它将使用Spring Cloud <code>ReactorLoadBalancer</code>解析名称（ <code>myservice</code>在上一个示例中）到实际的主机和端口，并替换相同属性中的URI。未经修改的原始网址会附加到列表中<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>属性。过滤器还会在<code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>属性以查看是否等于<code>lb</code>然后适用相同的规则。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: myRoute
        uri: lb://service
        predicates:
        - Path=/service/**</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认情况下，当服务实例无法通过<code>ReactorLoadBalancer</code> ， 一种<code>503</code>将被退回。您可以配置网关以返回<code>404</code>通过设置<code>spring.cloud.gateway.loadbalancer.use404=true</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>isSecure</code>的价值<code>ServiceInstance</code>从返回<code>ReactiveLoadBalancerClientFilter</code>将覆盖对网关的请求中指定的方案。例如，如果请求通过<code>HTTPS</code>但是<code>ServiceInstance</code>表示它是不安全的，则下游请求将被<code>HTTP</code> 。相反的情况也可以适用。但是如果<code>GATEWAY_SCHEME_PREFIX_ATTR</code>在网关配置中为路由指定了，前缀将被删除，路由URL产生的方案将覆盖<code>ServiceInstance</code>组态。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="netty-routing-filter"><a class="anchor" href="#netty-routing-filter"></a> <a class="link" href="#netty-routing-filter">16.6.5。网络路由过滤器</a></h4>
<div class="paragraph">
<p>如果网址位于<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>交换属性有一个<code>http</code>要么<code>https</code>方案。它使用净额<code>HttpClient</code>发出下游代理请求。响应放在<code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code>交换属性，供以后的过滤器使用。（有一个实验性的<code>WebClientHttpRoutingFilter</code>执行相同的功能，但不需要净值）</p>
</div>
</div>
<div class="sect3">
<h4 id="netty-write-response-filter"><a class="anchor" href="#netty-write-response-filter"></a> <a class="link" href="#netty-write-response-filter">16.6.6。净写响应过滤器</a></h4>
<div class="paragraph">
<p>的<code>NettyWriteResponseFilter</code>如果有净额，则运行<code>HttpClientResponse</code>在里面<code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code>交换属性。它在所有其他筛选器完成后运行，并将代理响应写回到网关客户端响应。（有一个实验性的<code>WebClientWriteResponseFilter</code>执行相同的功能，但不需要净值）</p>
</div>
</div>
<div class="sect3">
<h4 id="routetorequesturl-filter"><a class="anchor" href="#routetorequesturl-filter"></a> <a class="link" href="#routetorequesturl-filter">16.6.7。RouteToRequestUrl过滤器</a></h4>
<div class="paragraph">
<p>的<code>RouteToRequestUrlFilter</code>如果有<code>Route</code>中的对象<code>ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR</code>交换属性。它根据请求URI创建一个新URI，但使用URI的URI属性进行更新<code>Route</code>宾语。新的URI放置在<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>交换属性`。</p>
</div>
<div class="paragraph">
<p>如果URI具有方案前缀，例如<code>lb:ws://serviceid</code> ， <code>lb</code>方案已从URI中剥离，并放置在<code>ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR</code>供以后在过滤器链中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-routing-filter"><a class="anchor" href="#websocket-routing-filter"></a> <a class="link" href="#websocket-routing-filter">16.6.8。Websocket路由过滤器</a></h4>
<div class="paragraph">
<p>如果Websocket路由过滤器中的网址位于<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>交换属性有一个<code>ws</code>要么<code>wss</code>方案。它使用Spring Web Socket基础结构向下游转发Websocket请求。</p>
</div>
<div class="paragraph">
<p>Websocket可以通过在URI前面加上前缀来实现负载均衡<code>lb</code> ， 如<code>lb:ws://serviceid</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您将<a href="https://github.com/sockjs">SockJS</a>用作常规http的后备，则应配置常规HTTP路由以及Websocket路由。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      # SockJS route
      - id: websocket_sockjs_route
        uri: http://localhost:3001
        predicates:
        - Path=/websocket/info/**
      # Normwal Websocket route
      - id: websocket_route
        uri: ws://localhost:3001
        predicates:
        - Path=/websocket/**</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gateway-metrics-filter"><a class="anchor" href="#gateway-metrics-filter"></a> <a class="link" href="#gateway-metrics-filter">16.6.9。网关指标过滤器</a></h4>
<div class="paragraph">
<p>要启用网关度量标准，请添加spring-boot-starter-actuator作为项目依赖项。然后，默认情况下，只要该属性运行网关度量过滤器<code>spring.cloud.gateway.metrics.enabled</code>未设置为<code>false</code> 。该过滤器添加了一个带有以下标记的名为“ gateway.requests”的计时器指标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>routeId</code> ：路线ID</p>
</li>
<li>
<p><code>routeUri</code> ：API将被路由到的URI</p>
</li>
<li>
<p><code>outcome</code> ：按<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html">HttpStatus分类的结果</a><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html">。系列</a></p>
</li>
<li>
<p><code>status</code> ：请求返回给客户端的Http状态</p>
</li>
<li>
<p><code>httpStatusCode</code> ：请求返回给客户端的Http状态</p>
</li>
<li>
<p><code>httpMethod</code> ：用于请求的Http方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后可以从这些指标中进行刮取<code>/actuator/metrics/gateway.requests</code>并且可以轻松地与Prometheus集成以创建<a href="images/gateway-grafana-dashboard.jpeg">Grafana</a> <a href="gateway-grafana-dashboard.json">仪表板</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要启用Prometheus端点，请添加micrometer-registry-prometheus作为项目依赖项。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="marking-an-exchange-as-routed"><a class="anchor" href="#marking-an-exchange-as-routed"></a> <a class="link" href="#marking-an-exchange-as-routed">16.6.10。将交换标记为已路由</a></h4>
<div class="paragraph">
<p>网关路由后<code>ServerWebExchange</code>它将通过添加将该交换标记为“已路由” <code>gatewayAlreadyRouted</code>交换属性。将请求标记为已路由后，其他路由筛选器将不会再次路由请求，实质上会跳过该过滤器。您可以使用多种便捷方法将交换标记为已路由，或者检查交换是否已路由。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ServerWebExchangeUtils.isAlreadyRouted</code>需要一个<code>ServerWebExchange</code>对象并检查它是否已被“路由”</p>
</li>
<li>
<p><code>ServerWebExchangeUtils.setAlreadyRouted</code>需要一个<code>ServerWebExchange</code>对象并将其标记为“已路由”</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tls-ssl"><a class="anchor" href="#tls-ssl"></a> <a class="link" href="#tls-ssl">16.7。TLS / SSL</a></h3>
<div class="paragraph">
<p>网关可以通过遵循常规的Spring服务器配置来侦听https上的请求。例：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">server:
  ssl:
    enabled: true
    key-alias: scg
    key-store-password: scg1234
    key-store: classpath:scg-keystore.p12
    key-store-type: PKCS12</code></pre>
</div>
</div>
<div class="paragraph">
<p>网关路由可以同时路由到http和https后端。如果路由到https后端，则可以使用以下配置将网关配置为信任所有下游证书：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          useInsecureTrustManager: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用不安全的信任管理器不适用于生产。对于生产部署，可以使用以下配置为网关配置一组可以信任的已知证书：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          trustedX509Certificates:
          - cert1.pem
          - cert2.pem</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未为Spring Cloud Gateway提供受信任的证书，则会使用默认的信任存储（可以用系统属性javax.net.ssl.trustStore覆盖）。</p>
</div>
<div class="sect3">
<h4 id="tls-handshake"><a class="anchor" href="#tls-handshake"></a> <a class="link" href="#tls-handshake">16.7.1。TLS握手</a></h4>
<div class="paragraph">
<p>网关维护用于路由到后端的客户端池。通过https进行通信时，客户端会启动TLS握手。许多超时与此握手相关联。可以配置以下超时（显示默认值）：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          handshake-timeout-millis: 10000
          close-notify-flush-timeout-millis: 3000
          close-notify-read-timeout-millis: 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-4"><a class="anchor" href="#configuration-4"></a> <a class="link" href="#configuration-4">16.8。组态</a></h3>
<div class="paragraph">
<p>Spring Cloud Gateway的配置由RouteDefinitionLocator的集合驱动。</p>
</div>
<div class="listingblock">
<div class="title">RouteDefinitionLocator.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface RouteDefinitionLocator {
    Flux<RouteDefinition> getRouteDefinitions();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <code>PropertiesRouteDefinitionLocator</code>使用Spring Boot的加载属性<code>@ConfigurationProperties</code>机制。</p>
</div>
<div class="paragraph">
<p>上面的所有配置示例都使用一种快捷方式符号，该快捷方式符号使用位置参数而不是命名参数。以下两个示例是等效的：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: setstatus_route
        uri: https://example.org
        filters:
        - name: SetStatus
          args:
            status: 401
      - id: setstatusshortcut_route
        uri: https://example.org
        filters:
        - SetStatus=401</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于网关的某些用法，属性将是足够的，但是某些生产用例将受益于从外部源（例如数据库）加载配置。未来的里程碑版本将具有<code>RouteDefinitionLocator</code>基于Spring数据存储库的实现，例如：Redis，MongoDB和Cassandra。</p>
</div>
</div>
<div class="sect2">
<h3 id="route-metadata-configuration"><a class="anchor" href="#route-metadata-configuration"></a> <a class="link" href="#route-metadata-configuration">16.9。路由元数据配置</a></h3>
<div class="paragraph">
<p>可以使用元数据为每个路由配置其他参数：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      routes:
      - id: route_with_metadata
        uri: https://example.org
        metadata:
          optionName: "OptionValue"
          compositeObject:
            name: "value"
          iAmNumber: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以从交换中获取所有元数据属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
// get all metadata properties
route.getMetadata();
// get a single metadata property
route.getMetadata(someKey);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="fluent-java-routes-api"><a class="anchor" href="#fluent-java-routes-api"></a> <a class="link" href="#fluent-java-routes-api">16.9.1。流利的Java Routes API</a></h4>
<div class="paragraph">
<p>为了允许在Java中进行简单的配置，在<code>RouteLocatorBuilder</code>豆。</p>
</div>
<div class="listingblock">
<div class="title">GatewaySampleApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// static imports from GatewayFilters and RoutePredicates
@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) {
    return builder.routes()
            .route(r -> r.host("**.abc.org").and().path("/image/png")
                .filters(f ->
                        f.addResponseHeader("X-TestHeader", "foobar"))
                .uri("http://httpbin.org:80")
            )
            .route(r -> r.path("/image/webp")
                .filters(f ->
                        f.addResponseHeader("X-AnotherHeader", "baz"))
                .uri("http://httpbin.org:80")
                .metadata("key", "value")
            )
            .route(r -> r.order(-1)
                .host("**.throttle.org").and().path("/get")
                .filters(f -> f.filter(throttle.apply(1,
                        1,
                        10,
                        TimeUnit.SECONDS)))
                .uri("http://httpbin.org:80")
                .metadata("key", "value")
            )
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此样式还允许更多自定义谓词断言。谓词定义为<code>RouteDefinitionLocator</code>豆结合使用逻辑<code>and</code> 。通过使用流畅的Java API，您可以使用<code>and()</code> ， <code>or()</code>和<code>negate()</code>运算符<code>Predicate</code>类。</p>
</div>
</div>
<div class="sect3">
<h4 id="discoveryclient-route-definition-locator"><a class="anchor" href="#discoveryclient-route-definition-locator"></a> <a class="link" href="#discoveryclient-route-definition-locator">16.9.2。DiscoveryClient路由定义定位器</a></h4>
<div class="paragraph">
<p>可以将网关配置为根据向网络服务提供商注册的服务创建路由。 <code>DiscoveryClient</code>兼容的服务注册表。</p>
</div>
<div class="paragraph">
<p>要启用此功能，请设置<code>spring.cloud.gateway.discovery.locator.enabled=true</code>并确保<code>DiscoveryClient</code>实现是在类路径上并启用的（例如Netflix Eureka，Consul或Zookeeper）。</p>
</div>
<div class="sect4">
<h5 id="configuring-predicates-and-filters-for-discoveryclient-routes"><a class="anchor" href="#configuring-predicates-and-filters-for-discoveryclient-routes"></a> <a class="link" href="#configuring-predicates-and-filters-for-discoveryclient-routes">为DiscoveryClient路由配置谓词和过滤器</a></h5>
<div class="paragraph">
<p>默认情况下，网关为通过网络创建的路由定义单个谓词和过滤器<code>DiscoveryClient</code> 。</p>
</div>
<div class="paragraph">
<p>默认谓词是使用模式定义的路径谓词<code>/serviceId/**</code> ，在哪里<code>serviceId</code>是来自的服务的ID <code>DiscoveryClient</code> 。</p>
</div>
<div class="paragraph">
<p>默认过滤器是使用正则表达式的重写路径过滤器<code>/serviceId/(?<remaining>.*)</code>和替换<code>/${remaining}</code> 。这只是在将请求发送到下游之前从路径中剥离服务ID。</p>
</div>
<div class="paragraph">
<p>如果您想自定义谓词和/或过滤器使用的过滤器<code>DiscoveryClient</code>您可以通过设置以下路线<code>spring.cloud.gateway.discovery.locator.predicates[x]</code>和<code>spring.cloud.gateway.discovery.locator.filters[y]</code> 。这样做时，如果要保留该功能，则需要确保在上面包含默认谓词和过滤器。以下是此示例的示例。</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre>spring.cloud.gateway.discovery.locator.predicates[0].name: Path
spring.cloud.gateway.discovery.locator.predicates[0].args[pattern]: "'/'+serviceId+'/**'"
spring.cloud.gateway.discovery.locator.predicates[1].name: Host
spring.cloud.gateway.discovery.locator.predicates[1].args[pattern]: "'**.foo.com'"
spring.cloud.gateway.discovery.locator.filters[0].name: Hystrix
spring.cloud.gateway.discovery.locator.filters[0].args[name]: serviceId
spring.cloud.gateway.discovery.locator.filters[1].name: RewritePath
spring.cloud.gateway.discovery.locator.filters[1].args[regexp]: "'/' + serviceId + '/(?<remaining>.*)'"
spring.cloud.gateway.discovery.locator.filters[1].args[replacement]: "'/${remaining}'"</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor-netty-access-logs"><a class="anchor" href="#reactor-netty-access-logs"></a> <a class="link" href="#reactor-netty-access-logs">16.10。Reactor Netty访问日志</a></h3>
<div class="paragraph">
<p>要启用Reactor Netty访问日志，请设置<code>-Dreactor.netty.http.server.accessLogEnabled=true</code> 。（它必须是Java System属性，而不是Spring Boot属性）。</p>
</div>
<div class="paragraph">
<p>日志系统可以配置为具有单独的访问日志文件。以下是示例登录配置：</p>
</div>
<div class="listingblock">
<div class="title">logback.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    <appender name="accessLog" class="ch.qos.logback.core.FileAppender">
        <file>access_log.log</file>
        <encoder>
            <pattern>%msg%n</pattern>
        </encoder>
    </appender>
    <appender name="async" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="accessLog" />
    </appender>

    <logger name="reactor.netty.http.server.AccessLog" level="INFO" additivity="false">
        <appender-ref ref="async"/>
    </logger></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cors-configuration"><a class="anchor" href="#cors-configuration"></a> <a class="link" href="#cors-configuration">16.11。CORS配置</a></h3>
<div class="paragraph">
<p>可以将网关配置为控制CORS行为。“全局” CORS配置是URL模式到<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html">Spring Framework</a>的映射<a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html"><code>CorsConfiguration</code></a> 。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          '[/**]':
            allowedOrigins: "https://docs.spring.io"
            allowedMethods:
            - GET</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，将从docs.spring.io发出的所有GET请求路径的请求中允许CORS请求。</p>
</div>
<div class="paragraph">
<p>要为某些网关路由谓词未处理的请求提供相同的CORS配置，请设置属性<code>spring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping</code>等于真实。当尝试支持CORS预检请求并且您的路由谓词未评估为true时，这很有用，因为http方法是<code>options</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="actuator-api"><a class="anchor" href="#actuator-api"></a> <a class="link" href="#actuator-api">16.12。执行器API</a></h3>
<div class="paragraph">
<p>的<code>/gateway</code>执行器端点允许监视Spring Cloud Gateway应用程序并与之交互。为了可远程访问，必须在应用程序属性中<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints">通过HTTP或JMX</a> <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints">启用</a>和<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints">公开</a>端点。</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">management.endpoint.gateway.enabled=true # default value
management.endpoints.web.exposure.include=gateway</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="verbose-actuator-format"><a class="anchor" href="#verbose-actuator-format"></a> <a class="link" href="#verbose-actuator-format">16.12.1。详细执行器格式</a></h4>
<div class="paragraph">
<p>一种新的，更详细的格式已添加到网关。这为每个路由添加了更多细节，从而允许查看与每个路由关联的谓词和过滤器以及任何可用的配置。</p>
</div>
<div class="paragraph">
<p><code>/actuator/gateway/routes</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
  {
    "predicate": "(Hosts: [**.addrequestheader.org] && Paths: [/headers], match trailing slash: true)",
    "route_id": "add_request_header_test",
    "filters": [
      "[[AddResponseHeader X-Response-Default-Foo = 'Default-Bar'], order = 1]",
      "[[AddRequestHeader X-Request-Foo = 'Bar'], order = 1]",
      "[[PrefixPath prefix = '/httpbin'], order = 2]"
    ],
    "uri": "lb://testservice",
    "order": 0
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下启用此功能。要禁用它，请设置以下属性：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cloud.gateway.actuator.verbose.enabled=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>在将来的版本中，它将默认为true。</p>
</div>
</div>
<div class="sect3">
<h4 id="retrieving-route-filters"><a class="anchor" href="#retrieving-route-filters"></a> <a class="link" href="#retrieving-route-filters">16.12.2。检索路由过滤器</a></h4>
<div class="sect4">
<h5 id="global-filters-2"><a class="anchor" href="#global-filters-2"></a> <a class="link" href="#global-filters-2">全局过滤器</a></h5>
<div class="paragraph">
<p>要检索应用于所有路线的<a href="#global-filters">全局过滤器</a> ，请<code>GET</code>请求<code>/actuator/gateway/globalfilters</code> 。产生的响应类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
  "org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@77856cc5": 10100,
  "org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@4f6fd101": 10000,
  "org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@32d22650": -1,
  "org.springframework.cloud.gateway.filter.ForwardRoutingFilter@106459d9": 2147483647,
  "org.springframework.cloud.gateway.filter.NettyRoutingFilter@1fbd5e0": 2147483647,
  "org.springframework.cloud.gateway.filter.ForwardPathFilter@33a71d23": 0,
  "org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@135064ea": 2147483637,
  "org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@23c05889": 2147483646
}</pre>
</div>
</div>
<div class="paragraph">
<p>该响应包含适当的全局过滤器的详细信息。为每个全局过滤器提供了过滤器对象的字符串表示形式（例如， <code>org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@77856cc5</code> ）以及过滤器链中的相应<a href="#combined-global-filter-and-gatewayfilter-ordering">顺序</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="route-filters"><a class="anchor" href="#route-filters"></a> <a class="link" href="#route-filters">路线过滤器</a></h5>
<div class="paragraph">
<p>要检索应用于路由的<a href="#gatewayfilter-factories">GatewayFilter工厂</a> ，请创建一个<code>GET</code>请求<code>/actuator/gateway/routefilters</code> 。产生的响应类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
  "[AddRequestHeaderGatewayFilterFactory@570ed9c configClass = AbstractNameValueGatewayFilterFactory.NameValueConfig]": null,
  "[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]": null,
  "[SaveSessionGatewayFilterFactory@4449b273 configClass = Object]": null
}</pre>
</div>
</div>
<div class="paragraph">
<p>该响应包含应用于任何特定路由的GatewayFilter工厂的详细信息。为每个工厂提供相应对象的字符串表示形式（例如， <code>[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]</code> ）。请注意<code>null</code>该值是由于端点控制器的实现不完整而导致的，因为它尝试设置对象在过滤器链中的顺序，而该顺序不适用于GatewayFilter工厂对象。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="refreshing-the-route-cache"><a class="anchor" href="#refreshing-the-route-cache"></a> <a class="link" href="#refreshing-the-route-cache">16.12.3。刷新路由缓存</a></h4>
<div class="paragraph">
<p>要清除路由缓存，请<code>POST</code>请求<code>/actuator/gateway/refresh</code> 。该请求返回200，但没有响应主体。</p>
</div>
</div>
<div class="sect3">
<h4 id="retrieving-the-routes-defined-in-the-gateway"><a class="anchor" href="#retrieving-the-routes-defined-in-the-gateway"></a> <a class="link" href="#retrieving-the-routes-defined-in-the-gateway">16.12.4。检索网关中定义的路由</a></h4>
<div class="paragraph">
<p>要检索网关中定义的路由，请创建一个<code>GET</code>请求<code>/actuator/gateway/routes</code> 。产生的响应类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[{
  "route_id": "first_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@1e9d7e7d",
    "filters": [
      "OrderedGatewayFilter{delegate=org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactory$$Lambda$436/674480275@6631ef72, order=0}"
    ]
  },
  "order": 0
},
{
  "route_id": "second_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@cd8d298",
    "filters": []
  },
  "order": 0
}]</pre>
</div>
</div>
<div class="paragraph">
<p>该响应包含网关中定义的所有路由的详细信息。下表描述了响应的每个元素（即路线）的结构。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:22.2222%">
<col style="width:44.4445%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>route_id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路线编号。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>route_object.predicate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">宾语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由谓词。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>route_object.filters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#gatewayfilter-factories">GatewayFilter工厂已</a>应用于路由。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路线顺序。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="retrieving-information-about-a-particular-route"><a class="anchor" href="#retrieving-information-about-a-particular-route"></a> <a class="link" href="#retrieving-information-about-a-particular-route">16.12.5。检索有关特定路线的信息</a></h4>
<div class="paragraph">
<p>要检索有关一条路线的信息，请<code>GET</code>请求<code>/actuator/gateway/routes/{id}</code> （例如， <code>/actuator/gateway/routes/first_route</code> ）。产生的响应类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
  "id": "first_route",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"/first"}
  }],
  "filters": [],
  "uri": "https://www.uri-destination.org",
  "order": 0
}]</pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了响应的结构。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:22.2222%">
<col style="width:44.4445%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路线编号。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>predicates</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由谓词的集合。每个项目都定义给定谓词的名称和自变量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>filters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用于路线的过滤器集合。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由的目标URI。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>order</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路线顺序。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="creating-and-deleting-a-particular-route"><a class="anchor" href="#creating-and-deleting-a-particular-route"></a> <a class="link" href="#creating-and-deleting-a-particular-route">16.12.6。创建和删除特定路线</a></h4>
<div class="paragraph">
<p>要创建路线，请创建一个<code>POST</code>请求<code>/gateway/routes/{id_route_to_create}</code>带有指定路由字段的JSON主体（请参阅上一小节）。</p>
</div>
<div class="paragraph">
<p>要删除路线，请<code>DELETE</code>请求<code>/gateway/routes/{id_route_to_delete}</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="recap-list-of-all-endpoints"><a class="anchor" href="#recap-list-of-all-endpoints"></a> <a class="link" href="#recap-list-of-all-endpoints">16.12.7。回顾：所有端点的列表</a></h4>
<div class="paragraph">
<p>下表总结了Spring Cloud Gateway执行器端点。请注意，每个端点都有<code>/actuator/gateway</code>作为基本路径。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:22.2222%">
<col style="width:22.2222%">
<col style="width:55.5556%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>globalfilters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用于路由的全局过滤器列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routefilters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用于特定路由的GatewayFilter工厂列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refresh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">清除路由缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示网关中定义的路由列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示有关特定路线的信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将新路由添加到网关。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>routes/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从网关删除现有路由。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="troubleshooting"><a class="anchor" href="#troubleshooting"></a> <a class="link" href="#troubleshooting">16.13。故障排除</a></h3>
<div class="sect3">
<h4 id="log-levels"><a class="anchor" href="#log-levels"></a> <a class="link" href="#log-levels">16.13.1。日志级别</a></h4>
<div class="paragraph">
<p>以下是一些有用的记录器，其中包含在<code>DEBUG</code>和<code>TRACE</code>水平。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.cloud.gateway</code></p>
</li>
<li>
<p><code>org.springframework.http.server.reactive</code></p>
</li>
<li>
<p><code>org.springframework.web.reactive</code></p>
</li>
<li>
<p><code>org.springframework.boot.autoconfigure.web</code></p>
</li>
<li>
<p><code>reactor.netty</code></p>
</li>
<li>
<p><code>redisratelimiter</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="wiretap"><a class="anchor" href="#wiretap"></a> <a class="link" href="#wiretap">16.13.2。窃听</a></h4>
<div class="paragraph">
<p>反应堆净值<code>HttpClient</code>和<code>HttpServer</code>可以启用监听。与设定<code>reactor.netty</code>日志级别<code>DEBUG</code>要么<code>TRACE</code>将启用信息记录，例如通过电线发送和接收的标题和正文。要启用此功能，请设置<code>spring.cloud.gateway.httpserver.wiretap=true</code>和/或<code>spring.cloud.gateway.httpclient.wiretap=true</code>为了<code>HttpServer</code>和<code>HttpClient</code>分别。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="developer-guide"><a class="anchor" href="#developer-guide"></a> <a class="link" href="#developer-guide">16.14。开发人员指南</a></h3>
<div class="paragraph">
<p>TODO：编写定制集成概述</p>
</div>
<div class="sect3">
<h4 id="writing-custom-route-predicate-factories"><a class="anchor" href="#writing-custom-route-predicate-factories"></a> <a class="link" href="#writing-custom-route-predicate-factories">16.14.1。编写自定义路线谓词工厂</a></h4>
<div class="paragraph">
<p>TODO：编写自定义路线谓词工厂的文档</p>
</div>
</div>
<div class="sect3">
<h4 id="writing-custom-gatewayfilter-factories"><a class="anchor" href="#writing-custom-gatewayfilter-factories"></a> <a class="link" href="#writing-custom-gatewayfilter-factories">16.14.2。编写自定义GatewayFilter工厂</a></h4>
<div class="paragraph">
<p>为了编写GatewayFilter，您将需要实现<code>GatewayFilterFactory</code> 。有一个抽象类叫做<code>AbstractGatewayFilterFactory</code>您可以扩展。</p>
</div>
<div class="listingblock">
<div class="title">PreGatewayFilterFactory.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PreGatewayFilterFactory extends AbstractGatewayFilterFactory<PreGatewayFilterFactory.Config> {

    public PreGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        // grab configuration from Config object
        return (exchange, chain) -> {
            //If you want to build a "pre" filter you need to manipulate the
            //request before calling chain.filter
            ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
            //use builder to manipulate the request
            return chain.filter(exchange.mutate().request(request).build());
        };
    }

    public static class Config {
        //Put the configuration properties for your filter here
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PostGatewayFilterFactory.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory<PostGatewayFilterFactory.Config> {

    public PostGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        // grab configuration from Config object
        return (exchange, chain) -> {
            return chain.filter(exchange).then(Mono.fromRunnable(() -> {
                ServerHttpResponse response = exchange.getResponse();
                //Manipulate the response in some way
            }));
        };
    }

    public static class Config {
        //Put the configuration properties for your filter here
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-custom-global-filters"><a class="anchor" href="#writing-custom-global-filters"></a> <a class="link" href="#writing-custom-global-filters">16.14.3。编写自定义全局过滤器</a></h4>
<div class="paragraph">
<p>为了编写自定义全局过滤器，您需要实现<code>GlobalFilter</code>接口。这会将过滤器应用于所有请求。</p>
</div>
<div class="paragraph">
<p>如何分别设置全局前置和后置过滤器的示例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public GlobalFilter customGlobalFilter() {
    return (exchange, chain) -> exchange.getPrincipal()
        .map(Principal::getName)
        .defaultIfEmpty("Default User")
        .map(userName -> {
          //adds header to proxied request
          exchange.getRequest().mutate().header("CUSTOM-REQUEST-HEADER", userName).build();
          return exchange;
        })
        .flatMap(chain::filter);
}

@Bean
public GlobalFilter customGlobalPostFilter() {
    return (exchange, chain) -> chain.filter(exchange)
        .then(Mono.just(exchange))
        .map(serverWebExchange -> {
          //adds header to response
          serverWebExchange.getResponse().getHeaders().set("CUSTOM-RESPONSE-HEADER",
              HttpStatus.OK.equals(serverWebExchange.getResponse().getStatusCode()) ? "It worked": "It did not work");
          return serverWebExchange;
        })
        .then();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="writing-custom-route-locators-and-writers"><a class="anchor" href="#writing-custom-route-locators-and-writers"></a> <a class="link" href="#writing-custom-route-locators-and-writers">16.14.4。编写自定义路线定位器和编写器</a></h4>
<div class="paragraph">
<p>TODO：编写自定义路线定位器和编写器的文档</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="building-a-simple-gateway-using-spring-mvc-or-webflux"><a class="anchor" href="#building-a-simple-gateway-using-spring-mvc-or-webflux"></a> <a class="link" href="#building-a-simple-gateway-using-spring-mvc-or-webflux">16.15。使用Spring MVC或Webflux构建简单的网关</a></h3>
<div class="paragraph">
<p>Spring Cloud Gateway提供了一个名为<code>ProxyExchange</code>您可以在常规的Spring Web处理程序中将其用作方法参数。它通过镜像HTTP动词的方法支持基本的下游HTTP交换。借助MVC，它还支持通过以下方式转发到本地处理程序： <code>forward()</code>方法。要使用<code>ProxyExchange</code>只需在您的类路径中包含正确的模块即可（ <code>spring-cloud-gateway-mvc</code>要么<code>spring-cloud-gateway-webflux</code> ）。</p>
</div>
<div class="paragraph">
<p>MVC示例（将请求“代理”到远程服务器的下游“ /测试”）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@SpringBootApplication
public class GatewaySampleApplication {

    @Value("${remote.home}")
    private URI home;

    @GetMapping("/test")
    public ResponseEntity<?> proxy(ProxyExchange<byte[]> proxy) throws Exception {
        return proxy.uri(home.toString() + "/image/png").get();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与Webflux相同的是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RestController
@SpringBootApplication
public class GatewaySampleApplication {

    @Value("${remote.home}")
    private URI home;

    @GetMapping("/test")
    public Mono<ResponseEntity<?>> proxy(ProxyExchange<byte[]> proxy) throws Exception {
        return proxy.uri(home.toString() + "/image/png").get();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有方便的方法<code>ProxyExchange</code>使处理程序方法能够发现并增强传入请求的URI路径。例如，您可能希望提取路径的尾随元素以将它们传递到下游：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/proxy/path/**")
public ResponseEntity<?> proxyPath(ProxyExchange<byte[]> proxy) throws Exception {
  String path = proxy.path("/proxy/path/");
  return proxy.uri(home.toString() + "/foos/" + path).get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>网关处理程序方法可以使用Spring MVC或Webflux的所有功能。因此，例如，您可以注入请求标头和查询参数，并且可以使用映射批注中的声明来约束传入的请求。请参阅有关的文档<code>@RequestMapping</code>有关这些功能的更多详细信息，请参见Spring MVC。</p>
</div>
<div class="paragraph">
<p>可以使用以下命令将标头添加到下游响应中<code>header()</code>方法<code>ProxyExchange</code> 。</p>
</div>
<div class="paragraph">
<p>您还可以通过将映射器添加到响应标头（以及响应中您喜欢的其他任何内容）来操作<code>get()</code>等方法。映射器是<code>Function</code>需要传入<code>ResponseEntity</code>并将其转换为外发的</p>
</div>
<div class="paragraph">
<p>为不传递到下游的“敏感”标头（默认情况下为“ cookie”和“授权”）以及“代理”标头（ <code>x-forwarded-*</code> ）。</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-7"><a class="anchor" href="#configuration-properties-7"></a> <a class="link" href="#configuration-properties-7">16.16。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与Spring Cloud Gateway相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-function"><a class="anchor" href="#spring-cloud-function"></a> <a class="link" href="#spring-cloud-function">17。spring-cloud-function</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>马克·费舍尔（Mark Fisher），戴夫·瑟（Dave Syer），奥列格·朱拉库斯基（Oleg Zhurakousky），安舒尔·梅赫拉（Anshul Mehra）</p>
</div>
<div class="paragraph">
<p><strong>3.0.0。RC2</strong></p>
</div>
<hr>
<div class="sect2">
<h3 id="introduction-3"><a class="anchor" href="#introduction-3"></a> <a class="link" href="#introduction-3">17.1。介绍</a></h3>
<div class="paragraph">
<p>Spring Cloud Function是一个具有以下高级目标的项目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过功能促进业务逻辑的实现。</p>
</li>
<li>
<p>将业务逻辑的开发生命周期与任何特定的运行时目标脱钩，以便相同的代码可以作为Web端点，流处理器或任务运行。</p>
</li>
<li>
<p>支持跨无服务器提供程序的统一编程模型，以及独立运行（本地或在PaaS中）的能力。</p>
</li>
<li>
<p>在无服务器提供程序上启用Spring Boot功能（自动配置，依赖项注入，指标）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它抽象出所有传输详细信息和基础结构，使开发人员可以保留所有熟悉的工具和流程，并专注于业务逻辑。</p>
</div>
<div class="paragraph">
<p>这是一个完整的，可执行的，可测试的Spring Boot应用程序（实现简单的字符串操作）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class Application {

  @Bean
  public Function<Flux<String>, Flux<String>> uppercase() {
    return flux -> flux.map(value -> value.toUpperCase());
  }

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它只是一个Spring Boot应用程序，因此可以像其他任何Spring Boot应用程序一样在本地以CI构建，运行和测试。的<code>Function</code>来自<code>java.util</code>和<code>Flux</code>是<a href="https://www.reactive-streams.org/">反应流</a> <code>Publisher</code>来自<a href="https://projectreactor.io/">Project Reactor</a> 。可以通过HTTP或消息传递来访问该功能。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Function具有4个主要功能：</p>
</div>
<div class="paragraph">
<p>简而言之，Spring Cloud Function提供以下功能：1。包装纸<code>@Beans</code>类型的<code>Function</code> ， <code>Consumer</code>和<code>Supplier</code> ，使用RabbitMQ，Kafka等将它们作为HTTP终结点和/或消息流侦听器/发布器公开给外界。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>编程风格的选择-反应式，命令式或混合式。</em></p>
</li>
<li>
<p><em>功能组成和适应（例如，将命令性功能与反应性组合）。</em></p>
</li>
<li>
<p><em>支持具有多个输入和输出的反应式功能，从而允许功能处理合并，联接和其他复杂的流操作。</em></p>
</li>
<li>
<p><em>输入和输出的透明类型转换。</em></p>
</li>
<li>
<p><em>特定于目标平台的部署打包功能（例如，Project Riff，AWS Lambda等）</em></p>
</li>
<li>
<p><em>适配器将功能作为HTTP端点等向外界公开</em></p>
</li>
<li>
<p><em>使用隔离的类装入器部署包含此类应用程序上下文的JAR文件，以便可以将它们打包在一起在单个JVM中。</em></p>
</li>
<li>
<p><em>将作为Java函数体的字符串编译为字节码，然后将其转换为<code>@Beans</code>可以像上面那样包装。</em></p>
</li>
<li>
<p><em>适用于<a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws">AWS Lambda</a> ， <a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure">Azure</a> ， <a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk">Apache OpenWhisk</a>以及其他“无服务器”服务提供商的适配器。</em></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Spring Cloud是根据非限制性Apache 2.0许可发布的。如果您想为文档的这一部分做出贡献或发现错误，请在<a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/docs/src/main/asciidoc">github</a>的项目中找到源代码和问题跟踪程序。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-2"><a class="anchor" href="#getting-started-2"></a> <a class="link" href="#getting-started-2">17.2。入门</a></h3>
<div class="paragraph">
<p>从命令行构建（并“安装”示例）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw clean install</pre>
</div>
</div>
<div class="paragraph">
<p>（如果您想向YOLO添加<code>-DskipTests</code> ）</p>
</div>
<div class="paragraph">
<p>运行其中一个样本，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar spring-cloud-function-samples/function-sample/target/*.jar</pre>
</div>
</div>
<div class="paragraph">
<p>这将运行该应用程序并通过HTTP公开其功能，因此您可以将字符串转换为大写，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d Hello
HELLO</pre>
</div>
</div>
<div class="paragraph">
<p>您可以转换多个字符串（一个<code>Flux<String></code> ），用新行分隔</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -H "Content-Type: text/plain" localhost:8080/uppercase -d 'Hello
> World'
HELLOWORLD</pre>
</div>
</div>
<div class="paragraph">
<p>（您可以使用<code><sup>Q</sup>J</code>在终端中在这样的文字字符串中插入新行。）</p>
</div>
</div>
<div class="sect2">
<h3 id="programming-model"><a class="anchor" href="#programming-model"></a> <a class="link" href="#programming-model">17.3。编程模型</a></h3>
<div class="sect3">
<h4 id="function-catalog-and-flexible-function-signatures"><a class="anchor" href="#function-catalog-and-flexible-function-signatures"></a> <a class="link" href="#function-catalog-and-flexible-function-signatures">17.3.1。功能目录和灵活的功能签名</a></h4>
<div class="paragraph">
<p>Spring Cloud Function的主要功能之一是为用户定义的函数适应和支持各种类型签名，同时提供一致的执行模型。这就是为什么所有用户定义的函数都可以通过以下方式转换为规范表示形式的原因<code>FunctionCatalog</code> 。</p>
</div>
<div class="paragraph">
<p>尽管用户通常不必关心<code>FunctionCatalog</code>完全了解用户代码支持哪些功能是很有用的。</p>
</div>
<div class="paragraph">
<p>同样重要的是要了解，Spring Cloud Function为<a href="https://projectreactor.io/">Project Reactor</a>提供的反应式API提供了一流的支持，从而允许诸如<code>Mono</code>和<code>Flux</code>在用户定义函数中用作类型时，在为函数实现选择编程模型时提供更大的灵活性。响应式编程模型还可以为功能提供功能支持，这些功能否则将很难使用命令式编程样式实现。有关更多信息，请阅读<a href="#function-arity">功能Arity</a>部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="java-8-function-support"><a class="anchor" href="#java-8-function-support"></a> <a class="link" href="#java-8-function-support">17.3.2。Java 8功能支持</a></h4>
<div class="paragraph">
<p>Spring Cloud Function包含并建立在Java定义的三个核心功能接口之上，并且自Java 8开始就可以使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>供应商<o></o></p>
</li>
<li>
<p>功能<i, o=""></i,></p>
</li>
<li>
<p>消费者<i></i></p><i>
</i></li><i>
</i></ul><i>
</i></div><i>
<div class="sect4">
<h5 id="supplier"><a class="anchor" href="#supplier"></a> <a class="link" href="#supplier">供应商</a></h5>
<div class="paragraph">
<p>供应商可以做出<em>反应</em> - <code>Supplier<Flux<T>></code>或<em>必须</em> - <code>Supplier<T></code> 。从调用的角度来看，这对此类供应商的实现者没有任何影响。但是，当在框架（例如<a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream</a> ）中使用供应商时，尤其是反应性供应商，通常用于表示流的来源，因此，它们被调用一次，以获取消费者可以订阅的流（例如Flux）。换句话说，这些供应商代表着<em>无限的物流</em> 。但是，相同的反应式供应商也可以表示<em>有限的</em>流（例如，轮询的JDBC数据上的结果集）。在这些情况下，此类被动供应商必须与基础框架的某种轮询机制挂钩。</p>
</div>
<div class="paragraph">
<p>为了帮助该功能，Spring Cloud Function提供了标记注释<code>org.springframework.cloud.function.context.PollableSupplier</code>表示该供应商产生的流量有限，可能需要再次轮询。就是说，了解Spring Cloud Function本身对此注释不提供任何行为非常重要。</p>
</div>
<div class="paragraph">
<p>此外<code>PollableSupplier</code>批注公开了<em>splittable</em>属性，以通知产生的流需要进行拆分（请参阅<a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Sequencer.html">Splitter EIP</a> ）</p>
</div>
<div class="paragraph">
<p>这是示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PollableSupplier(splittable = true)
public Supplier<Flux<String>> someSupplier() {
    return () -> {
        String v1 = String.valueOf(System.nanoTime());
        String v2 = String.valueOf(System.nanoTime());
        String v3 = String.valueOf(System.nanoTime());
        return Flux.just(v1, v2, v3);
    };
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="function"><a class="anchor" href="#function"></a> <a class="link" href="#function">功能</a></h5>
<div class="paragraph">
<p>函数也可以以命令式或反应式方式编写，但是与供应商和消费者不同，实现者没有特殊的考虑，而是理解在框架（如<a href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream</a>等）中使用时，反应式功能仅被调用一次以传递引用到流（Flux或Mono），命令式每个事件调用一次。</p>
</div>
</div>
<div class="sect4">
<h5 id="consumer"><a class="anchor" href="#consumer"></a> <a class="link" href="#consumer">消费者</a></h5>
<div class="paragraph">
<p>消费者有点特殊，因为它具有<code>void</code>返回类型，这意味着至少有可能阻塞。您极有可能不需要写<code>Consumer<Flux<?>></code> ，但如果确实需要这样做，请记住订阅输入流量。如果您声明<code>Consumer</code>非发布者类型（通常），它将转换为返回发布者的函数，以便可以通过受控方式进行订阅。</p>
</div>
</div>
</i></div><i>
<div class="sect3">
<h4 id="function-composition"><a class="anchor" href="#function-composition"></a> <a class="link" href="#function-composition">17.3.3。功能组成</a></h4>
<div class="paragraph">
<p>功能组合是一项功能，可以将多个功能组合为一个功能。核心支持基于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#andThen-java.util.function.Function-">Function.andThen（..）</a>提供的功能组合功能自Java 8起提供支持。但是，除此之外，我们还提供一些其他功能。</p>
</div>
<div class="sect4">
<h5 id="declarative-function-composition"><a class="anchor" href="#declarative-function-composition"></a> <a class="link" href="#declarative-function-composition">声明式函数组成</a></h5>
<div class="paragraph">
<p>此功能使您可以使用以下方式以声明方式提供合成指令： <code>|</code> （管道）或<code>,</code>提供时（逗号）分隔符<code>spring.cloud.function.definition</code>属性。</p>
</div>
<div class="paragraph">
<p>例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--spring.cloud.function.definition=uppercase|reverse</pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们有效地提供了单个功能的定义，该功能本身就是功能的组合<code>uppercase</code>和功能<code>reverse</code> 。实际上，这就是属性名称是<em>definition</em>而不是<em>name</em>的原因之一，因为函数的定义可以由多个命名函数组成。如前所述，您可以使用<code>,</code>而不是管道（例如<code>…​definition=uppercase,reverse</code> ）。</p>
</div>
</div>
<div class="sect4">
<h5 id="composing-non-functions"><a class="anchor" href="#composing-non-functions"></a> <a class="link" href="#composing-non-functions">组成非功能</a></h5>
<div class="paragraph">
<p>Spring Cloud Function还支持将供应商与<code>Consumer</code>要么<code>Function</code>以及<code>Function</code>与<code>Consumer</code> 。在这里重要的是要了解此类定义的最终产品。将供应商与功能组合在一起仍会导致供应商，而将供应商与消费者组合将有效地使Runnable。遵循与消费者组成功能的相同逻辑将产生消费者。</p>
</div>
<div class="paragraph">
<p>当然，您不能撰写诸如消费者和功能，消费者和供应商之类的不可组合的东西。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="function-routing"><a class="anchor" href="#function-routing"></a> <a class="link" href="#function-routing">17.3.4。功能路由</a></h4>
<div class="paragraph">
<p>自2.2版以来，Spring Cloud Function提供了路由功能，使您可以调用单个功能，充当要调用的实际功能的路由器那么一个功能是不可能的。</p>
</div>
<div class="paragraph">
<p>的<code>RoutingFunction</code>在<em>FunctionCatalog中</em>以名称注册<code>functionRouter</code> 。为了简单和一致，您还可以参考<code>RoutingFunction.FUNCTION_NAME</code>不变。</p>
</div>
<div class="paragraph">
<p>此功能具有以下签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class RoutingFunction implements Function<Object, Object> {
. . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>路由指令可以通过几种方式进行通信。</p>
</div>
<div class="paragraph">
<p><strong>邮件标题</strong></p>
</div>
<div class="paragraph">
<p>如果输入参数是类型<code>Message<?></code> ，您可以通过设置以下一项来传达路由指令<code>spring.cloud.function.definition</code>要么<code>spring.cloud.function.routing-expression</code>邮件标题。对于更多静态情况，您可以使用<code>spring.cloud.function.definition</code>标头，可让您提供单个函数的名称（例如， <code>…​definition=foo</code> ）或撰写说明（例如， <code>…​definition=foo|bar|baz</code> ）。对于更动态的情况，您可以使用<code>spring.cloud.function.routing-expression</code>标头，可让您使用Spring表达式语言（SpEL）并提供应解析为函数定义的SpEL表达式（如上所述）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">SpEL评估上下文的根对象是实际的输入参数，因此在这种情况下<code>Message<?></code>您可以构造同时访问两个<code>payload</code>和<code>headers</code> （例如， <code>spring.cloud.function.routing-expression=headers.function_name</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在特定的执行环境/模型中，适配器负责翻译和交流<code>spring.cloud.function.definition</code>和/或<code>spring.cloud.function.routing-expression</code>通过消息头。例如，当使用<em>spring-cloud-function-web时，</em>您可以提供<code>spring.cloud.function.definition</code>作为HTTP标头，框架将传播它以及其他HTTP标头作为消息标头。</p>
</div>
<div class="paragraph">
<p><strong>应用属性</strong></p>
</div>
<div class="paragraph">
<p>路由指令也可以通过<code>spring.cloud.function.definition</code>要么<code>spring.cloud.function.routing-expression</code>作为应用程序属性。上一节中描述的规则也适用于此。唯一的不同是您将这些说明作为应用程序属性（例如， <code>--spring.cloud.function.definition=foo</code> ）。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">处理无功输入（例如Publisher）时，只能通过Function属性提供路由指令。这是由于反应性函数的性质，反应性函数仅被调用一次以传递发布者，其余的由反应堆处理，因此我们无法访问和/或依赖通过单个值（例如，消息）传递的路由指令。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="function-arity"><a class="anchor" href="#function-arity"></a> <a class="link" href="#function-arity">17.3.5。功能性</a></h4>
<div class="paragraph">
<p>有时需要对数据流进行分类和组织。例如，考虑一个经典的大数据用例，即处理包含“订单”和“发票”的无组织数据，并且您希望每个人都进入一个单独的数据存储中。在这里发挥功能支持（具有多个输入和输出的功能）的支持。</p>
</div>
<div class="paragraph">
<p>让我们看一个这样的函数的示例（ <a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/test/java/org/springframework/cloud/stream/function/MultipleInputOutputFunctionTests.java#L342">此处</a>提供<a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream/src/test/java/org/springframework/cloud/stream/function/MultipleInputOutputFunctionTests.java#L342">了</a>完整的实现细节），</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Function<Flux<Integer>, Tuple2<Flux<String>, Flux<String>>> organise() {
    return flux -> ...;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>鉴于Project Reactor是SCF的核心依赖项，我们将使用其Tuple库。元组通过向我们传达<em>基数</em>和<em>类型</em>信息而给我们带来了独特的优势。两者对于SCSt而言都是极其重要的。基数让我们知道需要创建多少个输入和输出绑定并将其绑定到一个函数的相应输入和输出。知道类型信息可确保正确的类型转换。</p>
</div>
<div class="paragraph">
<p>另外，这是绑定名称命名约定的“索引”部分起作用的地方，因为在此函数中，两个输出绑定名称是<code>organise-out-0</code>和<code>organise-out-1</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">重要提示：目前， <strong>仅对</strong>反应式功能（ <code>Function<TupleN<Flux<?>…​>, TupleN<Flux<?>…​>></code> ）以复杂事件处理为中心，其中对事件融合的评估和计算通常需要查看事件流，而不是单个事件。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="kotlin-lambda-support"><a class="anchor" href="#kotlin-lambda-support"></a> <a class="link" href="#kotlin-lambda-support">17.3.6。Kotlin Lambda支持</a></h4>
<div class="paragraph">
<p>我们还为Kotlin lambdas（自v2.0起）提供支持。考虑以下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
open fun kotlinSupplier(): () -> String {
    return  { "Hello from Kotlin" }
}

@Bean
open fun kotlinFunction(): (String) -> String {
    return  { it.toUpperCase() }
}

@Bean
open fun kotlinConsumer(): (String) -> Unit {
    return  { println(it) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面代表配置为Spring bean的Kotlin lambda。每个签名都映射到Java的等价物<code>Supplier</code> ， <code>Function</code>和<code>Consumer</code> ，因此框架支持/识别的签名。尽管Kotlin到Java的映射机制不在本文档的讨论范围之内，但重要的是要理解，此处也适用“ Java 8函数支持”部分中概述的相同的签名转换规则。</p>
</div>
<div class="paragraph">
<p>要启用Kotlin支持，您需要添加<code>spring-cloud-function-kotlin</code>模块到您的类路径，其中包含适当的自动配置和支持的类。</p>
</div>
</div>
<div class="sect3">
<h4 id="function-component-scan"><a class="anchor" href="#function-component-scan"></a> <a class="link" href="#function-component-scan">17.3.7。功能组件扫描</a></h4>
<div class="paragraph">
<p>Spring Cloud Function将扫描以下内容的实现<code>Function</code> ， <code>Consumer</code>和<code>Supplier</code>在一个叫做<code>functions</code>如果存在。使用此功能，您可以编写不依赖于Spring的函数-甚至<code>@Component</code>需要注释。如果要使用其他软件包，可以设置<code>spring.cloud.function.scan.packages</code> 。您也可以使用<code>spring.cloud.function.scan.enabled=false</code>完全关闭扫描。</p>
</div>
</div>
</i></div><i>
<div class="sect2">
<h3 id="standalone-web-applications"><a class="anchor" href="#standalone-web-applications"></a> <a class="link" href="#standalone-web-applications">17.4。独立的Web应用程序</a></h3>
<div class="paragraph">
<p>的<code>spring-cloud-function-web</code>模块具有自动配置功能，当将其包含在Spring Boot Web应用程序中（具有MVC支持）时，该配置将激活。还有一个<code>spring-cloud-starter-function-web</code>收集所有可选的依赖项，以防您只需要简单的入门经验。</p>
</div>
<div class="paragraph">
<p>启用网络配置后，您的应用将具有MVC端点（默认情况下位于“ /”上，但可以通过<code>spring.cloud.function.web.path</code> ），可用于访问应用程序上下文中的功能。支持的内容类型是纯文本和JSON。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
<col style="width:20%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">请求</th>
<th class="tableblock halign-left valign-top">响应</th>
<th class="tableblock halign-left valign-top">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ {供应商}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自指定供应商的物品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/{消费者}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON对象或文本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">镜像输入并将请求主体推入消费者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">202接受</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/{消费者}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON数组或带有新行的文本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">反映输入并将身体一一推入消费者</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">202接受</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/{功能}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON对象或文本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用命名函数的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/{功能}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON数组或带有新行的文本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用命名函数的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ {功能} / {项目}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将项目转换为对象并返回应用函数的结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如上表所示，端点的行为取决于方法以及传入请求数据的类型。当传入的数据是单值的，并且目标函数被声明为显然是单值的（即不返回集合或<code>Flux</code> ），那么响应也将包含一个值。对于多值响应，客户端可以通过发送“接受：文本/事件流”来请求服务器发送的事件流。</p>
</div>
<div class="paragraph">
<p>如果目录中只有一个功能（消费者等），则路径中的名称是可选的。可以使用管道或逗号分隔功能名称来解决复合函数（管道在URL路径中是合法的，但在命令行上键入会有点尴尬）。</p>
</div>
<div class="paragraph">
<p>如果目录中只有一个功能，并且您想将特定功能映射到根路径（例如，“ /”），或者想要组合多个功能然后映射到根路径，则可以这样做通过提供<code>spring.cloud.function.definition</code>该属性实际上由spring- = cloud-function-web模块用来为存在某种类型的冲突（例如，多个可用功能等）提供默认映射。</p>
</div>
<div class="paragraph">
<p>例如，</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--spring.cloud.function.definition=foo|bar</pre>
</div>
</div>
<div class="paragraph">
<p>上面的属性将组成'foo'和'bar'函数，并将组成的函数映射到“ /”路径。</p>
</div>
<div class="paragraph">
<p>在输入和输出中声明的函数和使用者<code>Message<?></code>将在输入消息上看到请求标头，并且输出消息标头将转换为HTTP标头。</p>
</div>
<div class="paragraph">
<p>在发布文本时，Spring Boot 2.0和更早的版本的响应格式可能会有所不同，具体取决于内容协商（提供内容类型和accpt标头以获得最佳效果）。</p>
</div>
</div>
<div class="sect2">
<h3 id="standalone-streaming-applications"><a class="anchor" href="#standalone-streaming-applications"></a> <a class="link" href="#standalone-streaming-applications">17.5。独立流媒体应用程序</a></h3>
<div class="paragraph">
<p>要从代理（例如RabbitMQ或Kafka）发送或接收消息，您可以利用<code>spring-cloud-stream</code>项目及其与Spring Cloud Function的集成。有关更多详细信息和示例，请参考Spring Cloud Stream参考手册的<a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/htmlsingle/#_spring_cloud_function">Spring Cloud Function</a>部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="deploying-a-packaged-function"><a class="anchor" href="#deploying-a-packaged-function"></a> <a class="link" href="#deploying-a-packaged-function">17.6。部署打包功能</a></h3>
<div class="paragraph">
<p>Spring Cloud Function提供了一个“部署程序”库，通过该库，您可以使用隔离的类加载器启动jar文件（或爆炸存档或jar文件集），并公开其中定义的功能。这是一个非常强大的工具，例如，您可以在不更改目标jar文件的情况下，使函数适应各种不同的输入输出适配器。无服务器平台通常具有内置的此类功能，因此您可以将其视为此类平台中函数调用程序的构建块（实际上， <a href="https://projectriff.io">Riff</a> Java函数调用程序使用此库）。</p>
</div>
<div class="paragraph">
<p>标准入口点是添加<code>spring-cloud-function-deployer</code>到类路径时，部署者将启动并寻找一些配置以告知其在何处找到函数jar。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-function-deployer</artifactId>
    <version>${spring.cloud.function.version}</version>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>用户至少必须提供一个<code>spring.cloud.function.location</code>这是包含函数的存档的URL或资源位置。它可以选择使用<code>maven:</code>前缀以通过依赖关系查找来定位工件（请参见<code>FunctionProperties</code>有关完整的详细信息）。使用jar文件从jar文件引导Spring Boot应用程序。 <code>MANIFEST.MF</code>例如，找到一个起始类，以便标准的Spring Boot胖子罐工作良好。如果目标jar可以成功启动，则结果是在主应用程序的<code>FunctionCatalog</code> 。已注册的函数可以通过主应用程序中的代码来应用，即使它是在隔离的类加载器中创建的（通过deault实现）。</p>
</div>
<div class="paragraph">
<p>这是部署包含“大写”功能的JAR并调用它的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class DeployFunctionDemo {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(DeployFunctionDemo.class,
                "--spring.cloud.function.location=..../target/uppercase-0.0.1-SNAPSHOT.jar",
                "--spring.cloud.function.definition=uppercase");

        FunctionCatalog catalog = context.getBean(FunctionCatalog.class);
        Function<String, String> function = catalog.lookup("uppercase");
        System.out.println(function.apply("hello"));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="functional-bean-definitions"><a class="anchor" href="#functional-bean-definitions"></a> <a class="link" href="#functional-bean-definitions">17.7。功能Bean定义</a></h3>
<div class="paragraph">
<p>对于需要快速启动的小型应用程序，Spring Cloud Function支持“功能性”风格的Bean声明。bean声明的功能样式是Spring Framework 5.0的功能，在5.1中进行了重大增强。</p>
</div>
<div class="sect3">
<h4 id="comparing-functional-with-traditional-bean-definitions"><a class="anchor" href="#comparing-functional-with-traditional-bean-definitions"></a> <a class="link" href="#comparing-functional-with-traditional-bean-definitions">17.7.1。将功能与传统Bean定义进行比较</a></h4>
<div class="paragraph">
<p>这是熟悉的普通Spring Cloud Function应用程序<code>@Configuration</code>和<code>@Bean</code>声明风格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class DemoApplication {

  @Bean
  public Function<String, String> uppercase() {
    return value -> value.toUpperCase();
  }

  public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在无服务器平台（例如AWS Lambda或Azure Functions）中运行以上命令，也可以仅通过包含<code>spring-cloud-function-starter-web</code>在类路径上。运行main方法将公开可用于ping的终结点<code>uppercase</code>功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ curl localhost:8080 -d foo
FOO</code></pre>
</div>
</div>
<div class="paragraph">
<p>Web适配器在<code>spring-cloud-function-starter-web</code>使用Spring MVC，因此您需要一个Servlet容器。您也可以在默认服务器为netty的地方使用Webflux（即使您仍然愿意使用Servlet容器也可以）-只需添加<code>spring-cloud-starter-function-webflux</code>依赖。功能相同，并且两者都可以使用用户应用程序代码。</p>
</div>
<div class="paragraph">
<p>现在介绍功能Bean：可以将用户应用程序代码重铸为“功能”形式，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootConfiguration
public class DemoApplication implements ApplicationContextInitializer<GenericApplicationContext> {

  public static void main(String[] args) {
    FunctionalSpringApplication.run(DemoApplication.class, args);
  }

  public Function<String, String> uppercase() {
    return value -> value.toUpperCase();
  }

  @Override
  public void initialize(GenericApplicationContext context) {
    context.registerBean("demo", FunctionRegistration.class,
        () -> new FunctionRegistration<>(uppercase())
            .type(FunctionType.from(String.class).to(String.class)));
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>主要区别在于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>主班是<code>ApplicationContextInitializer</code> 。</p>
</li>
<li>
<p>的<code>@Bean</code>方法已转换为对<code>context.registerBean()</code></p>
</li>
<li>
<p>的<code>@SpringBootApplication</code>已被替换为<code>@SpringBootConfiguration</code>表示我们没有启用Spring Boot自动配置，但仍将该类标记为“入口点”。</p>
</li>
<li>
<p>的<code>SpringApplication</code>从Spring Boot已替换为<code>FunctionalSpringApplication</code>来自Spring Cloud Function（它是一个子类）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您在Spring Cloud Function应用程序中注册的业务逻辑bean是类型<code>FunctionRegistration</code> 。这是一个包装，其中包含函数以及有关输入和输出类型的信息。在里面<code>@Bean</code>可以反射性地导出信息的应用程序形式，但是在功能性bean注册中，除非我们使用<code>FunctionRegistration</code> 。</p>
</div>
<div class="paragraph">
<p>替代使用<code>ApplicationContextInitializer</code>和<code>FunctionRegistration</code>是使应用程序本身实现<code>Function</code> （要么<code>Consumer</code>要么<code>Supplier</code> ）。示例（与上述等效）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootConfiguration
public class DemoApplication implements Function<String, String> {

  public static void main(String[] args) {
    FunctionalSpringApplication.run(DemoApplication.class, args);
  }

  @Override
  public String uppercase(String value) {
    return value.toUpperCase();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您添加一个单独的独立类型的类，它也将起作用<code>Function</code>并在<code>SpringApplication</code>使用另一种形式的<code>run()</code>方法。最主要的是，泛型类型信息可在运行时通过类声明获得。</p>
</div>
<div class="paragraph">
<p>如果添加，该应用程序将在其自己的HTTP服务器中运行<code>spring-cloud-starter-function-webflux</code> （由于尚未实现嵌入式Servlet容器的功能形式，因此目前无法与MVC启动器一起使用）。该应用程序还可以在AWS Lambda或Azure Functions中正常运行，并且启动时间的改善是巨大的。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">“精简版” Web服务器在以下方面存在一些限制： <code>Function</code>签名-特别是尚不支持<code>Message</code>输入和输出，但POJO和任何种类的<code>Publisher</code>应该没事。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="testing-functional-applications"><a class="anchor" href="#testing-functional-applications"></a> <a class="link" href="#testing-functional-applications">17.7.2。测试功能应用</a></h4>
<div class="paragraph">
<p>Spring Cloud Function还具有一些用于集成测试的实用程序，这些实用程序对于Spring Boot用户而言非常熟悉。例如，这是包装以上应用程序的HTTP服务器的集成测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@FunctionalSpringBootTest
@AutoConfigureWebTestClient
public class FunctionalTests {

    @Autowired
    private WebTestClient client;

    @Test
    public void words() throws Exception {
        client.post().uri("/").body(Mono.just("foo"), String.class).exchange()
                .expectStatus().isOk().expectBody(String.class).isEqualTo("FOO");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该测试几乎与您要编写的测试相同<code>@Bean</code>同一应用的版本-唯一的区别是<code>@FunctionalSpringBootTest</code>注释，而不是常规<code>@SpringBootTest</code> 。所有其他作品，例如<code>@Autowired</code><code>WebTestClient</code>是标准的Spring Boot功能。</p>
</div>
<div class="paragraph">
<p>或者，您可以只使用非HTTP应用编写测试<code>FunctionCatalog</code> 。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@FunctionalSpringBootTest
public class FunctionalTests {

    @Autowired
    private FunctionCatalog catalog;

    @Test
    public void words() throws Exception {
        Function<Flux<String>, Flux<String>> function = catalog.lookup(Function.class,
                "function");
        assertThat(function.apply(Flux.just("foo")).blockFirst()).isEqualTo("FOO");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>（ <code>FunctionCatalog</code>总是从返回函数<code>Flux</code>至<code>Flux</code> ，即使用户使用更简单的签名声明它们。）</p>
</div>
</div>
<div class="sect3">
<h4 id="limitations-of-functional-bean-declaration"><a class="anchor" href="#limitations-of-functional-bean-declaration"></a> <a class="link" href="#limitations-of-functional-bean-declaration">17.7.3。功能Bean声明的局限性</a></h4>
<div class="paragraph">
<p>与整个Spring Boot相比，大多数Spring Cloud Function应用程序的范围相对较小，因此我们能够轻松地使其适应这些功能Bean定义。如果您超出了有限的范围，则可以通过切换回来扩展Spring Cloud Function应用程序<code>@Bean</code>样式配置，或使用混合方法。例如，如果您想利用Spring Boot自动配置来与外部数据存储区集成，则需要使用<code>@EnableAutoConfiguration</code> 。如果需要，仍可以使用函数声明来定义函数（即“混合”样式），但是在这种情况下，您将需要使用<code>spring.functional.enabled=false</code>这样Spring Boot可以收回控制权。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-compilation"><a class="anchor" href="#dynamic-compilation"></a> <a class="link" href="#dynamic-compilation">17.8。动态编译</a></h3>
<div class="paragraph">
<p>有一个示例应用程序，它使用函数编译器从配置属性中创建函数。原始的“功能样本”也具有该功能。您可以运行一些脚本来查看编译在运行时发生的情况。要运行这些示例，请更改为<code>scripts</code>目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>cd scripts</pre>
</div>
</div>
<div class="paragraph">
<p>另外，在本地启动RabbitMQ服务器（例如执行<code>rabbitmq-server</code> ）。</p>
</div>
<div class="paragraph">
<p>启动功能注册表服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./function-registry.sh</pre>
</div>
</div>
<div class="paragraph">
<p>注册功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./registerFunction.sh -n uppercase -f "f->f.map(s->s.toString().toUpperCase())"</pre>
</div>
</div>
<div class="paragraph">
<p>使用该功能运行REST微服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./web.sh -f uppercase -p 9000
curl -H "Content-Type: text/plain" -H "Accept: text/plain" localhost:9000/uppercase -d foo</pre>
</div>
</div>
<div class="paragraph">
<p>注册供应商：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./registerSupplier.sh -n words -f "()->Flux.just(\"foo\",\"bar\")"</pre>
</div>
</div>
<div class="paragraph">
<p>使用该供应商运行REST微服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./web.sh -s words -p 9001
curl -H "Accept: application/json" localhost:9001/words</pre>
</div>
</div>
<div class="paragraph">
<p>注册消费者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./registerConsumer.sh -n print -t String -f "System.out::println"</pre>
</div>
</div>
<div class="paragraph">
<p>使用该使用者运行REST微服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./web.sh -c print -p 9002
curl -X POST -H "Content-Type: text/plain" -d foo localhost:9002/print</pre>
</div>
</div>
<div class="paragraph">
<p>运行流处理微服务：</p>
</div>
<div class="paragraph">
<p>首先注册流字供应商：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./registerSupplier.sh -n wordstream -f "()->Flux.interval(Duration.ofMillis(1000)).map(i->\"message-\"+i)"</pre>
</div>
</div>
<div class="paragraph">
<p>然后启动源（供应商），处理器（功能）和宿（消费者）应用程序（以相反的顺序）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./stream.sh -p 9103 -i uppercaseWords -c print
./stream.sh -p 9102 -i words -f uppercase -o uppercaseWords
./stream.sh -p 9101 -s wordstream -o words</pre>
</div>
</div>
<div class="paragraph">
<p>输出将显示在接收器应用程序的控制台中（每秒一条消息，转换为大写字母）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>MESSAGE-0
MESSAGE-1
MESSAGE-2
MESSAGE-3
MESSAGE-4
MESSAGE-5
MESSAGE-6
MESSAGE-7
MESSAGE-8
MESSAGE-9
...</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="serverless-platform-adapters"><a class="anchor" href="#serverless-platform-adapters"></a> <a class="link" href="#serverless-platform-adapters">17.9。无服务器平台适配器</a></h3>
<div class="paragraph">
<p>除了能够作为独立进程运行之外，Spring Cloud Function应用程序还可以适应运行现有的无服务器平台之一。在项目中，有适用于<a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws">AWS Lambda</a> ， <a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure">Azure</a>和<a href="https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-openwhisk">Apache OpenWhisk的适配器</a> 。<a href="https://github.com/fnproject/fn">Oracle Fn平台</a>具有自己的Spring Cloud Function适配器。<a href="https://projectriff.io">Riff</a>支持Java函数，其<a href="https://github.com/projectriff/java-function-invoker">Java Function Invoker</a>本机运行是Spring Cloud Function jar的适配器。</p>
</div>
<div class="sect3">
<h4 id="aws-lambda"><a class="anchor" href="#aws-lambda"></a> <a class="link" href="#aws-lambda">17.9.1。AWS Lambda</a></h4>
<div class="paragraph">
<p><a href="https://aws.amazon.com/">AWS</a>适配器将使用Spring Cloud Function应用并将其转换为可以在AWS Lambda中运行的表单。</p>
</div>
<div class="paragraph">
<p>适配器具有几个可以使用的通用请求处理程序。最通用的是<code>SpringBootStreamHandler</code> ，它使用杰克逊<code>ObjectMapper</code>由Spring Boot提供，用于序列化和反序列化函数中的对象。还有一个<code>SpringBootRequestHandler</code>您可以对其进行扩展，并提供输入和输出类型作为类型参数（使AWS能够检查类并自己进行JSON转换）。</p>
</div>
<div class="paragraph">
<p>如果您的应用有多个<code>@Bean</code>类型的<code>Function</code>等等，那么您可以通过配置选择要使用的一种<code>function.name</code> （例如<code>FUNCTION_NAME</code> AWS中的环境变量）。这些功能是从Spring Cloud中提取的<code>FunctionCatalog</code> （首先搜索<code>Function</code>然后<code>Consumer</code>最后<code>Supplier</code> ）。</p>
</div>
<div class="sect4">
<h5 id="notes-on-jar-layout"><a class="anchor" href="#notes-on-jar-layout"></a> <a class="link" href="#notes-on-jar-layout">有关JAR布局的注意事项</a></h5>
<div class="paragraph">
<p>Lambda在运行时不需要Spring Cloud Function Web或Stream适配器，因此在创建发送到AWS的JAR之前，可能需要排除那些适配器。 Lambda应用程序必须着色，但Spring Boot独立应用程序不必着色，因此您可以使用2个单独的jar（根据示例）运行同一应用程序。该示例应用程序将创建2个jar文件，其中一个包含一个<code>aws</code>用于在Lambda中部署的分类器，以及一个<a id="thin-jar"></a>可执行文件（瘦）jar，其中包括<code>spring-cloud-function-web</code>在运行时。Spring Cloud Function将尝试使用JAR文件清单为您找到一个“主类” <code>Start-Class</code>属性（如果您使用入门级父级，它将由Spring Boot工具为您添加）。如果没有<code>Start-Class</code>在清单中，您可以使用环境变量或系统属性<code>MAIN_CLASS</code>将功能部署到AWS时。</p>
</div>
<div class="paragraph">
<p>如果您不使用功能Bean定义，而是依靠Spring Boot的自动配置，则必须在maven-shade-plugin执行中配置其他转换器。</p>
</div>
<div id="shade-plugin-setup" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </dependency>
    </dependencies>
    <configuration>
        <createDependencyReducedPom>false</createDependencyReducedPom>
        <shadedArtifactAttached>true</shadedArtifactAttached>
        <shadedClassifierName>aws</shadedClassifierName>
        <transformers>
            <transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                <resource>META-INF/spring.handlers</resource>
            </transformer>
            <transformer implementation="org.springframework.boot.maven.PropertiesMergingResourceTransformer">
                <resource>META-INF/spring.factories</resource>
            </transformer>
            <transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                <resource>META-INF/spring.schemas</resource>
            </transformer>
        </transformers>
    </configuration>
</plugin></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="build-file-setup"><a class="anchor" href="#build-file-setup"></a> <a class="link" href="#build-file-setup">构建文件设置</a></h5>
<div class="paragraph">
<p>为了在AWS Lambda上运行Spring Cloud Function应用程序，您可以利用云平台提供商提供的Maven或Gradle插件。</p>
</div>
<div class="sect5">
<h6 id="maven"><a class="anchor" href="#maven"></a> <a class="link" href="#maven">马文</a></h6>
<div class="paragraph">
<p>为了将适配器插件用于Maven，请将插件依赖项添加到您的<code>pom.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-function-adapter-aws</artifactId>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="paragraph">
<p>如<a href="#notes-on-jar-layout">《 JAR布局说明》中</a>指出的那样，您需要一个有阴影的jar才能将其上传到AWS Lambda。您可以为此使用<a href="https://maven.apache.org/plugins/maven-shade-plugin/">Maven Shade插件</a> 。可以在上面找到<a href="#shade-plugin-setup">设置</a>示例。</p>
</div>
<div class="paragraph">
<p>您可以使用Spring Boot Maven插件生成<a href="#thin-jar">瘦罐</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot.experimental</groupId>
            <artifactId>spring-boot-thin-layout</artifactId>
            <version>${wrapper.version}</version>
        </dependency>
    </dependencies>
</plugin></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以找到整个样本<code>pom.xml</code> <a href="https://github.com/spring-cloud/spring-cloud-function/blob/master/spring-cloud-function-samples/function-sample-aws/pom.xml">此处</a>使用Maven将Spring Cloud Function应用程序部署到AWS Lambda的文件。</p>
</div>
</div>
<div class="sect5">
<h6 id="gradle"><a class="anchor" href="#gradle"></a> <a class="link" href="#gradle">摇篮</a></h6>
<div class="paragraph">
<p>为了将适配器插件用于Gradle，请将依赖项添加到您的<code>build.gradle</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    compile("org.springframework.cloud:spring-cloud-function-adapter-aws:${version}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如<a href="#notes-on-jar-layout">有关JAR布局的Notes中</a>所指出的那样，您需要一个有阴影的jar才能将其上传到AWS Lambda。您可以为此使用<a href="https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow/">Gradle Shadow插件</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    dependencies {
        classpath "com.github.jengelman.gradle.plugins:shadow:${shadowPluginVersion}"
    }
}
apply plugin: 'com.github.johnrengelman.shadow'

assemble.dependsOn = [shadowJar]

import com.github.jengelman.gradle.plugins.shadow.transformers.*

shadowJar {
    classifier = 'aws'
    dependencies {
        exclude(
            dependency("org.springframework.cloud:spring-cloud-function-web:${springCloudFunctionVersion}"))
    }
    // Required for Spring
    mergeServiceFiles()
    append 'META-INF/spring.handlers'
    append 'META-INF/spring.schemas'
    append 'META-INF/spring.tooling'
    transform(PropertiesFileTransformer) {
        paths = ['META-INF/spring.factories']
        mergeStrategy = "append"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用Spring Boot Gradle插件和Spring Boot Thin Gradle插件来生成Thin <a href="#thin-jar">jar</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    dependencies {
        classpath("org.springframework.boot.experimental:spring-boot-thin-gradle-plugin:${wrapperVersion}")
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}
apply plugin: 'org.springframework.boot'
apply plugin: 'org.springframework.boot.experimental.thin-launcher'
assemble.dependsOn = [thinJar]</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以找到整个样本<code>build.gradle</code> <a href="https://github.com/spring-cloud/spring-cloud-function/blob/master/spring-cloud-function-samples/function-sample-aws/build.gradle">此处</a>使用Gradle将Spring Cloud Function应用程序部署到AWS Lambda的文件。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="upload"><a class="anchor" href="#upload"></a> <a class="link" href="#upload">上载</a></h5>
<div class="paragraph">
<p>建立样本<code>spring-cloud-function-samples/function-sample-aws</code>并上传<code>-aws</code> jar文件到Lambda。该处理程序可以是<code>example.Handler</code>要么<code>org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler</code> （该类的FQN， <em>而不是</em>方法引用，尽管Lambda确实接受方法引用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./mvnw -U clean package</pre>
</div>
</div>
<div class="paragraph">
<p>使用AWS命令行工具，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>aws lambda create-function --function-name Uppercase --role arn:aws:iam::[USERID]:role/service-role/[ROLE] --zip-file fileb://function-sample-aws/target/function-sample-aws-2.0.0.BUILD-SNAPSHOT-aws.jar --handler org.springframework.cloud.function.adapter.aws.SpringBootStreamHandler --description "Spring Cloud Function Adapter Example" --runtime java8 --region us-east-1 --timeout 30 --memory-size 1024 --publish</pre>
</div>
</div>
<div class="paragraph">
<p>AWS示例中函数的输入类型是Foo，它具有一个称为“ value”的单个属性。因此，您需要使用它进行测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
  "value": "test"
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">AWS示例应用程序以“功能”风格编写（作为<code>ApplicationContextInitializer</code> ）。在Lambda中启动时，这比传统启动快得多<code>@Bean</code>样式，所以如果您不需要<code>@Beans</code> （要么<code>@EnableAutoConfiguration</code> ），这是一个不错的选择。暖启动不受影响。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="type-conversion"><a class="anchor" href="#type-conversion"></a> <a class="link" href="#type-conversion">类型转换</a></h5>
<div class="paragraph">
<p>Spring Cloud Function将尝试透明地处理原始输入流和函数声明的类型之间的类型转换。</p>
</div>
<div class="paragraph">
<p>例如，如果您的函数签名是这样的<code>Function<Foo, Bar></code>我们将尝试将传入流事件转换为的实例<code>Foo</code> 。</p>
</div>
<div class="paragraph">
<p>如果类型未知或无法确定（例如， <code>Function<?, ?></code> ），我们将尝试将传入的流事件转换为通用事件<code>Map</code> 。</p>
</div>
<div class="sect6">
<h7 id="raw-input"><a class="anchor" href="#raw-input"></a> <a class="link" href="#raw-input">原始输入</a></h7>
<div class="paragraph">
<p>有时您可能想访问原始输入。在这种情况下，您需要声明函数签名以接受<code>InputStream</code> 。例如， <code>Function<InputStream, ?></code> 。在这种情况下，我们将不尝试任何转换，而是将原始输入直接传递给函数。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="microsoft-azure"><a class="anchor" href="#microsoft-azure"></a> <a class="link" href="#microsoft-azure">17.9.2。微软Azure</a></h4>
<div class="paragraph">
<p><a href="https://azure.microsoft.com">Azure</a>适配器引导Spring Cloud Function上下文，并在必要时使用Spring Boot配置将来自Azure框架的函数调用引导到用户函数中。Azure Functions具有一个非常独特但具有侵入性的编程模型，涉及特定于平台的用户代码中的注释。在Spring Cloud中使用它的最简单方法是扩展基类并使用<code>@FunctionName</code>委托给基类方法的注释。</p>
</div>
<div class="paragraph">
<p>该项目为Azure上的Spring Cloud Function应用程序提供了一个适配器层。您可以编写一个应用程序<code>@Bean</code>类型的<code>Function</code>如果您正确布置了JAR文件，它将可以在Azure中部署。</p>
</div>
<div class="paragraph">
<p>有一个<code>AzureSpringBootRequestHandler</code>您必须对其进行扩展，并提供输入和输出类型作为带注释的方法参数（使Azure能够检查类并创建JSON绑定）。基类有两个有用的方法（ <code>handleRequest</code>和<code>handleOutput</code> ），您可以将实际的函数调用委派给该函数，因此大多数情况下，该函数只会有一行。</p>
</div>
<div class="paragraph">
<p>例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class FooHandler extends AzureSpringBootRequestHandler<Foo, Bar> {
    @FunctionName("uppercase")
    public Bar execute(
            @HttpTrigger(name = "req", methods = { HttpMethod.GET,
                    HttpMethod.POST }, authLevel = AuthorizationLevel.ANONYMOUS)
                    Foo foo,
            ExecutionContext context) {
        return handleRequest(foo, context);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此Azure处理程序将委派给<code>Function<Foo,Bar></code>豆（或<code>Function<Publisher<Foo>,Publisher<Bar>></code> ）。一些Azure触发器（例如<code>@CosmosDBTrigger</code> ）导致输入类型为<code>List</code>在这种情况下，您可以绑定到<code>List</code>在Azure处理程序中，或<code>String</code> （原始JSON）。的<code>List</code>输入代表<code>Function</code>输入类型<code>Map<String,Object></code> ， 要么<code>Publisher</code>要么<code>List</code>相同类型的。输出<code>Function</code>可以是<code>List</code> （一对一）或单个值（聚合），并且Azure声明中的输出绑定应匹配。</p>
</div>
<div class="paragraph">
<p>如果您的应用有多个<code>@Bean</code>类型的<code>Function</code>等等，那么您可以通过配置选择要使用的一种<code>function.name</code> 。或者，如果您使<code>@FunctionName</code>在Azure处理程序方法中，使它与应该以这种方式工作的函数名称匹配（也适用于具有多个函数的函数应用程序）。这些功能是从Spring Cloud中提取的<code>FunctionCatalog</code>因此默认函数名称与Bean名称相同。</p>
</div>
<div class="sect4">
<h5 id="accessing-azure-executioncontext"><a class="anchor" href="#accessing-azure-executioncontext"></a> <a class="link" href="#accessing-azure-executioncontext">访问Azure ExecutionContext</a></h5>
<div class="paragraph">
<p>有时需要访问Azure运行时提供的目标执行上下文，形式为<code>com.microsoft.azure.functions.ExecutionContext</code> 。例如，此类需求之一就是日志记录，因此它可以显示在Azure控制台中。</p>
</div>
<div class="paragraph">
<p>为此，Spring Cloud Function将注册<code>ExecutionContext</code>作为Application上下文中的bean，因此可以将其注入您的函数中。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Function<Foo, Bar> uppercase(ExecutionContext targetContext) {
    return foo -> {
        targetContext.getLogger().info("Invoking 'uppercase' on " + foo.getValue());
        return new Bar(foo.getValue().toUpperCase());
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，基于类型的注入就足够了，但是如果需要，您还可以利用注册它的bean名称（即<code>targetExecutionContext</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="notes-on-jar-layout-2"><a class="anchor" href="#notes-on-jar-layout-2"></a> <a class="link" href="#notes-on-jar-layout-2">有关JAR布局的注意事项</a></h5>
<div class="paragraph">
<p>在Azure的运行时中不需要Spring Cloud Function Web，因此可以在创建部署到Azure的JAR之前将其排除在外，但是如果包含它，则不会使用它，因此离开时不会有任何伤害它在。Azure上的功能应用程序是由Maven插件生成的存档。该函数位于此项目生成的JAR文件中。该示例使用精简版式将其创建为可执行jar，以便Azure可以找到处理程序类。如果愿意，可以只使用常规的平面JAR文件。依赖性<strong>不</strong>应该包括在内。</p>
</div>
</div>
<div class="sect4">
<h5 id="build-file-setup-2"><a class="anchor" href="#build-file-setup-2"></a> <a class="link" href="#build-file-setup-2">构建文件设置</a></h5>
<div class="paragraph">
<p>为了在Microsoft Azure上运行Spring Cloud Function应用程序，您可以利用云平台提供商提供的Maven插件。</p>
</div>
<div class="paragraph">
<p>为了将适配器插件用于Maven，请将插件依赖项添加到您的<code>pom.xml</code>文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-function-adapter-azure</artifactId>
    </dependency>
</dependencies></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，配置插件。您将需要为应用程序提供特定于Azure的配置，并指定<code>resourceGroup</code> ， <code>appName</code>和其他可选属性，然后添加<code>package</code>目标执行，以便<code>function.json</code>将为您生成Azure所需的文件。完整的插件文档可在<a href="https://github.com/microsoft/azure-maven-plugins">插件库中</a>找到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><plugin>
    <groupId>com.microsoft.azure</groupId>
    <artifactId>azure-functions-maven-plugin</artifactId>
    <configuration>
        <resourceGroup>${functionResourceGroup}</resourceGroup>
        <appName>${functionAppName}</appName>
    </configuration>
    <executions>
        <execution>
            <id>package-functions</id>
            <goals>
                <goal>package</goal>
            </goals>
        </execution>
    </executions>
</plugin></code></pre>
</div>
</div>
<div class="paragraph">
<p>您还必须确保要在Azure函数暂存目录中找到要由插件扫描的文件（有关暂存目录及其默认位置的详细信息，请参阅<a href="https://github.com/microsoft/azure-maven-plugins">插件存储库</a> ）。</p>
</div>
<div class="paragraph">
<p>您可以找到整个样本<code>pom.xml</code> <a href="https://github.com/spring-cloud/spring-cloud-function/blob/master/spring-cloud-function-samples/function-sample-azure/pom.xml">此处</a>使用Maven将Spring Cloud Function应用程序部署到Microsoft Azure的文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">到目前为止，仅Maven插件可用。云平台提供商尚未创建Gradle插件。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="build"><a class="anchor" href="#build"></a> <a class="link" href="#build">建立</a></h5>
<div class="listingblock">
<div class="content">
<pre>./mvnw -U clean package</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="running-the-sample"><a class="anchor" href="#running-the-sample"></a> <a class="link" href="#running-the-sample">运行样本</a></h5>
<div class="paragraph">
<p>您可以像其他Spring Cloud Function示例一样在本地运行示例：</p>
</div>
<hr>
<hr>
<div class="paragraph">
<p>和<code>curl -H "Content-Type: text/plain" localhost:8080/function -d '{"value": "hello foobar"}'</code> 。</p>
</div>
<div class="paragraph">
<p>您将需要<code>az</code> CLI应用程序（有关更多详细信息，请参阅<a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven" class="bare">docs.microsoft.com/zh-cn/azure/azure-functions/functions-create-first-java-maven</a> ）。要将功能部署在Azure运行时上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ az login
$ mvn azure-functions:deploy</pre>
</div>
</div>
<div class="paragraph">
<p>在另一个终端上，尝试以下操作： <code>curl <a href="https://<azure-function-url-from-the-log>/api/uppercase" class="bare"><azure-function-url-from-the-log>/api/uppercase</a> -d '{"value": "hello foobar!"}'</code> 。请确保为上述功能使用正确的URL。或者，您可以在Azure仪表板UI中测试该功能（单击功能名称，转到右侧，然后单击“测试”，然后单击右下角的“运行”）。</p>
</div>
<div class="paragraph">
<p>Azure示例中函数的输入类型是具有单个属性“ Foo”的Foo。因此，您需要使用以下代码进行测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
  "value": "foobar"
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Azure示例应用程序以“非功能性”样式编写（使用<code>@Bean</code> ）。功能风格（与<code>Function</code>要么<code>ApplicationContextInitializer</code> ）在Azure中启动时比传统方式快得多<code>@Bean</code>样式，所以如果您不需要<code>@Beans</code> （要么<code>@EnableAutoConfiguration</code> ），这是一个不错的选择。暖启动不受影响。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</i></div><i>
</i></div><i><i>
<div class="sect1">
<h2 id="spring-cloud-kubernetes"><a class="anchor" href="#spring-cloud-kubernetes"></a> <a class="link" href="#spring-cloud-kubernetes">18岁Spring Cloud Kubernetes</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本参考指南介绍了如何使用Spring Cloud Kubernetes。</p>
</div>
<div class="sect2">
<h3 id="why-do-you-need-spring-cloud-kubernetes"><a class="anchor" href="#why-do-you-need-spring-cloud-kubernetes"></a> <a class="link" href="#why-do-you-need-spring-cloud-kubernetes">18.1。为什么需要Spring Cloud Kubernetes？</a></h3>
<div class="paragraph">
<p>Spring Cloud Kubernetes提供使用Kubernetes本机服务的Spring Cloud通用接口实现。该存储库中提供的项目的主要目的是促进Kubernetes中运行的Spring Cloud和Spring Boot应用程序的集成。</p>
</div>
</div>
<div class="sect2">
<h3 id="starters"><a class="anchor" href="#starters"></a> <a class="link" href="#starters">18.2。初学者</a></h3>
<div class="paragraph">
<p>入门程序是方便的依赖项描述符，您可以在应用程序中包含它们。包括一个启动器以获取功能集的依赖关系和Spring Boot自动配置。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">起动机</th>
<th class="tableblock halign-left valign-top">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes</artifactId>
</dependency></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将服务名称解析为Kubernetes Services的<a href="#discoveryclient-for-kubernetes">Discovery Client</a>实现。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-config</artifactId>
</dependency></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从Kubernetes <a href="#ConfigMap PropertySource">ConfigMap</a>和<a href="#secrets-propertysource">Secrets</a>加载应用程序属性。
ConfigMap或Secret更改时， <a href="#PropertySource Reload">重新加载</a>应用程序属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-ribbon</artifactId>
</dependency></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从Kubernetes端点获取具有服务器列表的<a href="#Ribbon discovery in Kubernetes">功能区</a>客户端负载均衡器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-all</artifactId>
</dependency></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Cloud Kubernetes的所有功能。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="discoveryclient-for-kubernetes"><a class="anchor" href="#discoveryclient-for-kubernetes"></a> <a class="link" href="#discoveryclient-for-kubernetes">18.3。Kubernetes的DiscoveryClient</a></h3>
<div class="paragraph">
<p>该项目提供了<a href="https://kubernetes.io">Kubernetes</a>的<a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/DiscoveryClient.java">Discovery Client</a>的<a href="https://kubernetes.io">实现</a> 。通过此客户端，您可以按名称查询Kubernetes端点（请参阅<a href="https://kubernetes.io/docs/user-guide/services/">服务</a> ）。Kubernetes API服务器通常将服务公开为代表以下内容的端点的集合： <code>http</code>和<code>https</code>地址，客户端可以从作为Pod运行的Spring Boot应用程序访问。Spring Cloud Kubernetes Ribbon项目还使用此发现功能来获取为要进行负载平衡的应用程序定义的端点列表。</p>
</div>
<div class="paragraph">
<p>您可以通过在项目内部添加以下依赖项来免费获得这些东西：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes</artifactId>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>启用加载<code>DiscoveryClient</code> ，添加<code>@EnableDiscoveryClient</code>到相应的配置或应用程序类，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableDiscoveryClient
public class Application {
  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，您可以简单地通过自动装配将客户端注入代码中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowired
private DiscoveryClient discoveryClient;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以选择启用<code>DiscoveryClient</code>在所有名称空间中设置以下属性<code>application.properties</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.kubernetes.discovery.all-namespaces=true</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果出于任何原因需要禁用<code>DiscoveryClient</code> ，您可以在中设置以下属性<code>application.properties</code> ：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.kubernetes.discovery.enabled=false</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一些Spring Cloud组件使用<code>DiscoveryClient</code>为了获取有关本地服务实例的信息。为此，您需要将Kubernetes服务名称与<code>spring.application.name</code>属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>spring.application.name</code>对于在Kubernetes中为该应用程序注册的名称无效</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Spring Cloud Kubernetes也可以查看Kubernetes服务目录以进行更改并更新<code>DiscoveryClient</code>相应地实施。为了启用此功能，您需要添加<code>@EnableScheduling</code>在应用程序中的配置类上。</p>
</div>
</div>
<div class="sect2">
<h3 id="kubernetes-native-service-discovery"><a class="anchor" href="#kubernetes-native-service-discovery"></a> <a class="link" href="#kubernetes-native-service-discovery">18.4。Kubernetes本机服务发现</a></h3>
<div class="paragraph">
<p>Kubernetes本身具有（服务器端）服务发现的能力（请参阅： <a href="https://kubernetes.io/docs/concepts/services-networking/service/#discovering-services" class="bare">kubernetes.io/docs/concepts/services-networking/service/#discovering-services</a> ）。使用本机kubernetes服务发现可确保与其他工具的兼容性，例如Istio（ <a href="https://istio.io" class="bare">istio.io</a> ），该服务网格可实现负载平衡，功能区，断路器，故障转移等。</p>
</div>
<div class="paragraph">
<p>然后，调用者服务仅需要引用特定Kubernetes群集中可解析的名称。一个简单的实现可以使用spring <code>RestTemplate</code>指的是完全限定域名（FQDN），例如<code><a href="https://{service-name}.{namespace}.svc.{cluster}.local:{service-port}" class="bare">{service-name}.{namespace}.svc.{cluster}.local:{service-port}</a></code> 。</p>
</div>
<div class="paragraph">
<p>此外，您可以将Hystrix用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>调用方的断路器实现，方法是在Spring Boot应用程序类中添加注释<code>@EnableCircuitBreaker</code></p>
</li>
<li>
<p>后备功能，通过使用注释相应的方法<code>@HystrixCommand(fallbackMethod=</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="kubernetes-propertysource-implementations"><a class="anchor" href="#kubernetes-propertysource-implementations"></a> <a class="link" href="#kubernetes-propertysource-implementations">18.5。Kubernetes PropertySource实现</a></h3>
<div class="paragraph">
<p>配置Spring Boot应用程序的最常见方法是创建一个<code>application.properties</code>要么<code>application.yaml</code>或<code>application-profile.properties</code>要么<code>application-profile.yaml</code>包含键值对的文件，这些键值对为您的应用程序或Spring Boot启动器提供自定义值。您可以通过指定系统属性或环境变量来覆盖这些属性。</p>
</div>
<div class="sect3">
<h4 id="configmap-propertysource"><a class="anchor" href="#configmap-propertysource"></a> <a class="link" href="#configmap-propertysource">18.5.1。用一个<code>ConfigMap</code> <code>PropertySource</code></a></h4>
<div class="paragraph">
<p>Kubernetes提供了一个名为<a href="https://kubernetes.io/docs/user-guide/configmap/"><code>ConfigMap</code></a>外部化参数以键值对或嵌入式的形式传递到您的应用程序<code>application.properties</code>要么<code>application.yaml</code>文件。<a href="./spring-cloud-kubernetes-config">Spring Cloud Kubernetes Config</a>项目使Kubernetes <code>ConfigMap</code>在应用程序引导期间可用的实例，并在检测到发现变化时触发Bean或Spring上下文的热重载<code>ConfigMap</code>实例。</p>
</div>
<div class="paragraph">
<p>默认行为是创建一个<code>ConfigMapPropertySource</code>基于Kubernetes <code>ConfigMap</code>有一个<code>metadata.name</code> Spring应用程序名称的值（由其定义） <code>spring.application.name</code>属性）或在<code>bootstrap.properties</code>文件按以下键： <code>spring.cloud.kubernetes.config.name</code> 。</p>
</div>
<div class="paragraph">
<p>但是，可以在其中使用多个配置的情况下进行更高级的配置<code>ConfigMap</code>实例。的<code>spring.cloud.kubernetes.config.sources</code>列表使这成为可能。例如，您可以定义以下内容<code>ConfigMap</code>实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  application:
    name: cloud-k8s-app
  cloud:
    kubernetes:
      config:
        name: default-name
        namespace: default-namespace
        sources:
         # Spring Cloud Kubernetes looks up a ConfigMap named c1 in namespace default-namespace
         - name: c1
         # Spring Cloud Kubernetes looks up a ConfigMap named default-name in whatever namespace n2
         - namespace: n2
         # Spring Cloud Kubernetes looks up a ConfigMap named c3 in namespace n3
         - namespace: n3
           name: c3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果<code>spring.cloud.kubernetes.config.namespace</code>尚未设置， <code>ConfigMap</code>命名<code>c1</code>将在应用程序运行的名称空间中查找。</p>
</div>
<div class="paragraph">
<p>任何匹配<code>ConfigMap</code>找到的内容按以下方式处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>应用单个配置属性。</p>
</li>
<li>
<p>申请为<code>yaml</code>任何名为属性的内容<code>application.yaml</code> 。</p>
</li>
<li>
<p>将名为以下内容的任何属性的内容用作属性文件<code>application.properties</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>上述流程的唯一例外是<code>ConfigMap</code>包含指示所述文件中的<strong>单个</strong>密钥是YAML或属性文件。在这种情况下，密钥的名称不必是<code>application.yaml</code>要么<code>application.properties</code> （可以是任何值），并且属性的值已正确处理。此功能有助于在以下情况下使用： <code>ConfigMap</code>是通过使用以下内容创建的：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>kubectl create configmap game-config --from-file=/path/to/app-config.yaml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设我们有一个名为Spring Boot的应用程序<code>demo</code>使用以下属性读取其线程池配置。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pool.size.core</code></p>
</li>
<li>
<p><code>pool.size.maximum</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可以外部化到配置映射中<code>yaml</code>格式如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  pool.size.core: 1
  pool.size.max: 16</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>个别属性在大多数情况下都能正常工作。但是，有时嵌入<code>yaml</code>比较方便在这种情况下，我们使用一个名为<code>application.yaml</code>嵌入我们的<code>yaml</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yaml: |-
    pool:
      size:
        core: 1
        max:16</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例也适用：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  custom-name.yaml: |-
    pool:
      size:
        core: 1
        max:16</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以根据活动配置文件的不同方式配置Spring Boot应用程序，这些活动配置文件在<code>ConfigMap</code>被读取。您可以使用来为不同的配置文件提供不同的属性值<code>application.properties</code>要么<code>application.yaml</code>属性，指定特定于配置文件的值，每个值都在各自的文档中（由<code>---</code>顺序），如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yml: |-
    greeting:
      message: Say Hello to the World
    farewell:
      message: Say Goodbye
    ---
    spring:
      profiles: development
    greeting:
      message: Say Hello to the Developers
    farewell:
      message: Say Goodbye to the Developers
    ---
    spring:
      profiles: production
    greeting:
      message: Say Hello to the Ops</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在上述情况下，配置将通过<code>development</code>简介如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">  greeting:
    message: Say Hello to the Developers
  farewell:
    message: Say Goodbye to the Developers</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，如果<code>production</code>配置文件处于活动状态，配置变为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">  greeting:
    message: Say Hello to the Ops
  farewell:
    message: Say Goodbye</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果两个配置文件均处于活动状态，则在<code>ConfigMap</code>覆盖任何先前的值。</p>
</div>
<div class="paragraph">
<p>另一个选择是为每个配置文件创建一个不同的配置映射，Spring Boot会根据活动的配置文件自动获取它</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo
data:
  application.yml: |-
    greeting:
      message: Say Hello to the World
    farewell:
      message: Say Goodbye</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo-development
data:
  application.yml: |-
    spring:
      profiles: development
    greeting:
      message: Say Hello to the Developers
    farewell:
      message: Say Goodbye to the Developers</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: ConfigMap
apiVersion: v1
metadata:
  name: demo-production
data:
  application.yml: |-
    spring:
      profiles: production
    greeting:
      message: Say Hello to the Ops
    farewell:
      message: Say Goodbye</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>告诉Spring Boot哪个<code>profile</code>应该在启动时启用，您可以通过<code>SPRING_PROFILES_ACTIVE</code>环境变量。为此，您可以使用环境变量启动您的Spring Boot应用程序，您可以在容器规范的PodSpec中定义它。部署资源文件，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployment-name
  labels:
    app: deployment-name
spec:
  replicas: 1
  selector:
    matchLabels:
      app: deployment-name
  template:
    metadata:
      labels:
        app: deployment-name
    spec:
        containers:
        - name: container-name
          image: your-image
          env:
          - name: SPRING_PROFILES_ACTIVE
            value: "development"</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您应该检查安全性配置部分。要从Pod内部访问配置映射，您需要具有正确的Kubernetes服务帐户，角色和角色绑定。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用的另一种选择<code>ConfigMap</code>实例是通过运行Spring Cloud Kubernetes应用程序并使Spring Cloud Kubernetes从文件系统读取它们来将它们装入Pod。此行为由<code>spring.cloud.kubernetes.config.paths</code>属性。您可以使用它作为上述机制的补充或替代。您可以在中指定多个（完全）文件路径<code>spring.cloud.kubernetes.config.paths</code>通过使用<code>,</code>定界符。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您必须提供每个属性文件的完整确切路径，因为不会递归解析目录。
</td>
</tr>
</tbody></table>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表9。特性：</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.config.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用ConfigMaps<code>PropertySource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.config.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring.application.name}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置名称<code>ConfigMap</code>去查查看</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.config.namespace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">客户端名称空间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置Kubernetes命名空间的查找位置</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.config.paths</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置路径<code>ConfigMap</code>实例已安装</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.config.enableApi</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用或禁用消费<code>ConfigMap</code>通过API实例</p></td>
</tr>
</tfoot>
</table>
</div>
<div class="sect3">
<h4 id="secrets-propertysource"><a class="anchor" href="#secrets-propertysource"></a> <a class="link" href="#secrets-propertysource">18.5.2。秘密PropertySource</a></h4>
<div class="paragraph">
<p>Kubernetes具有用于存储敏感数据（例如密码，OAuth令牌等）的<a href="https://kubernetes.io/docs/concepts/configuration/secret/">秘密</a>的概念。该项目提供了与<code>Secrets</code>通过Spring Boot应用程序访问机密。您可以通过设置以下选项来显式启用或禁用此功能<code>spring.cloud.kubernetes.secrets.enabled</code>属性。</p>
</div>
<div class="paragraph">
<p>启用后， <code>SecretsPropertySource</code>查找Kubernetes <code>Secrets</code>来自以下来源：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>从秘密坐骑递归读取</p>
</li>
<li>
<p>以应用程序命名（由定义<code>spring.application.name</code> ）</p>
</li>
<li>
<p>匹配一些标签</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>注意：</strong></p>
</div>
<div class="paragraph">
<p>默认情况下，出于安全原因， <strong>未启用</strong>通过API消费机密（以上第2点和第3点）。机密上的权限“列表”允许客户端检查指定名称空间中的机密值。此外，我们建议容器通过安装的卷共享机密。</p>
</div>
<div class="paragraph">
<p>如果您通过API启用使用机密，我们建议您使用授权策略（例如RBAC）限制对机密的访问。有关通过API使用“机密”时的风险和最佳做法的更多信息，请参阅<a href="https://kubernetes.io/docs/concepts/configuration/secret/#best-practices">此文档</a> 。</p>
</div>
<div class="paragraph">
<p>如果找到了机密，则其数据可供应用程序使用。</p>
</div>
<div class="paragraph">
<p>假设我们有一个名为Spring Boot的应用程序<code>demo</code>使用属性读取其数据库配置。我们可以使用以下命令创建Kubernetes机密：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>oc create secret generic db-secret --from-literal=username=user --from-literal=password=p455w0rd</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的命令将创建以下秘密（您可以使用来查看<code>oc get secrets db-secret -o yaml</code> ）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
data:
  password: cDQ1NXcwcmQ=
  username: dXNlcg==
kind: Secret
metadata:
  creationTimestamp: 2017-07-04T09:15:57Z
  name: db-secret
  namespace: default
  resourceVersion: "357496"
  selfLink: /api/v1/namespaces/default/secrets/db-secret
  uid: 63c89263-6099-11e7-b3da-76d6186905a8
type: Opaque</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，数据包含Base64编码版本的文字， <code>create</code>命令。</p>
</div>
<div class="paragraph">
<p>然后，您的应用程序可以使用此机密-例如，通过将机密的值导出为环境变量：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Deployment
metadata:
  name: ${project.artifactId}
spec:
   template:
     spec:
       containers:
         - env:
            - name: DB_USERNAME
              valueFrom:
                 secretKeyRef:
                   name: db-secret
                   key: username
            - name: DB_PASSWORD
              valueFrom:
                 secretKeyRef:
                   name: db-secret
                   key: password</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过多种方式选择要使用的秘密：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>通过列出映射机密的目录：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets/db-secret,etc/secrets/postgresql</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果将所有机密映射到公共根，则可以将它们设置为：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">-Dspring.cloud.kubernetes.secrets.paths=/etc/secrets</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>通过设置命名机密：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">-Dspring.cloud.kubernetes.secrets.name=db-secret</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>通过定义标签列表：</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">-Dspring.cloud.kubernetes.secrets.labels.broker=activemq
-Dspring.cloud.kubernetes.secrets.labels.db=postgresql</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>视情况而定<code>ConfigMap</code> ，也可以在其中使用多个高级配置<code>Secret</code>实例。的<code>spring.cloud.kubernetes.secrets.sources</code>列表使这成为可能。例如，您可以定义以下内容<code>Secret</code>实例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  application:
    name: cloud-k8s-app
  cloud:
    kubernetes:
      secrets:
        name: default-name
        namespace: default-namespace
        sources:
         # Spring Cloud Kubernetes looks up a Secret named s1 in namespace default-namespace
         - name: s1
         # Spring Cloud Kubernetes looks up a Secret named default-name in whatever namespace n2
         - namespace: n2
         # Spring Cloud Kubernetes looks up a Secret named s3 in namespace n3
         - namespace: n3
           name: s3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果<code>spring.cloud.kubernetes.secrets.namespace</code>尚未设置， <code>Secret</code>命名<code>s1</code>将在应用程序运行的名称空间中查找。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表10。特性：</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.secrets.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用秘密<code>PropertySource</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.secrets.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring.application.name}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置要查找的机密名称</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.secrets.namespace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">客户端名称空间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置Kubernetes命名空间的查找位置</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.secrets.labels</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Map</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置用于查找机密的标签</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.secrets.paths</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置安装机密的路径（示例1）</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.secrets.enableApi</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过API启用或禁用使用机密（示例2和3）</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>笔记：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>spring.cloud.kubernetes.secrets.labels</code>属性的行为与<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#map-based-binding">基于Map的binding</a>定义的行为相同。</p>
</li>
<li>
<p>的<code>spring.cloud.kubernetes.secrets.paths</code>属性的行为与<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-Configuration-Binding#collection-based-binding">基于Collection的binding</a>定义的行为相同。</p>
</li>
<li>
<p>出于安全原因，可能会限制通过API访问机密。首选方法是将机密安装到Pod。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以找到使用机密的应用程序示例（尽管尚未更新为使用新机密）。 <code>spring-cloud-kubernetes</code>项目）在<a href="https://github.com/fabric8-quickstarts/spring-boot-camel-config">spring-boot-camel-config</a></p>
</div>
</div>
<div class="sect3">
<h4 id="propertysource-reload"><a class="anchor" href="#propertysource-reload"></a> <a class="link" href="#propertysource-reload">18.5.3。 <code>PropertySource</code>重装</a></h4>
<div class="paragraph">
<p>某些应用程序可能需要检测外部属性源上的更改并更新其内部状态以反映新配置。Spring Cloud Kubernetes的重新加载功能能够在相关<code>ConfigMap</code>要么<code>Secret</code>变化。</p>
</div>
<div class="paragraph">
<p>默认情况下，此功能处于禁用状态。您可以使用<code>spring.cloud.kubernetes.reload.enabled=true</code>配置属性（例如，在<code>application.properties</code>文件）。</p>
</div>
<div class="paragraph">
<p>支持以下级别的重载（通过设置<code>spring.cloud.kubernetes.reload.strategy</code>财产）：* <code>refresh</code> （默认）：仅使用注释的配置Bean <code>@ConfigurationProperties</code>要么<code>@RefreshScope</code>重新加载。此重新加载级别利用了Spring Cloud Context的刷新功能。* <code>restart_context</code> ：整个春天<code>ApplicationContext</code>正常重启。使用新配置重新创建Bean。* <code>shutdown</code> ： 春天<code>ApplicationContext</code>关闭以激活容器的重新启动。使用此级别时，请确保所有非守护程序线程的生命周期都绑定到<code>ApplicationContext</code>并且复制控制器或副本集已配置为重新启动Pod。</p>
</div>
<div class="paragraph">
<p>假设使用默认设置启用了重新加载功能（ <code>refresh</code>模式），则当配置映射更改时，以下bean会刷新：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>@Configuration
@ConfigurationProperties(prefix = "bean")
public class MyConfig {

    private String message = "a message that can be changed live";

    // getter and setters

}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了看到更改有效地发生，您可以创建另一个Bean，该Bean定期打印消息，如下所示</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Component
public class MyBean {

    @Autowired
    private MyConfig config;

    @Scheduled(fixedDelay = 5000)
    public void hello() {
        System.out.println("The message is: " + config.getMessage());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下命令更改应用程序打印的消息<code>ConfigMap</code> ， 如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: reload-example
data:
  application.properties: |-
    bean.message=Hello World!</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对名为属性的任何更改<code>bean.message</code>在里面<code>ConfigMap</code>与pod关联的内容会反映在输出中。一般而言，与属性相关联的更改的前缀为<code>prefix</code>的领域<code>@ConfigurationProperties</code>注释被检测到并反映在应用程序中。
<a href="#configmap-propertysource">关联一个<code>ConfigMap</code></a>本章前面已说明<a href="#configmap-propertysource">了带有吊舱的产品</a> 。</p>
</div>
<div class="paragraph">
<p>完整的示例在<a href="https://github.com/fabric8io/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples/kubernetes-reload-example"><code>spring-cloud-kubernetes-reload-example</code></a> 。</p>
</div>
<div class="paragraph">
<p>重新加载功能支持两种操作模式：*事件（默认）：使用Kubernetes API（Web套接字）监视配置映射或机密的更改。任何事件都会对配置进行重新检查，并在发生更改的情况下重新加载。的<code>view</code>为了侦听配置映射更改，需要在服务帐户上具有角色。更高级别的角色（例如<code>edit</code> ）是机密信息所必需的（默认情况下，不监视机密信息）。*轮询：根据配置映射和机密信息定期重新创建配置，以查看配置是否已更改。您可以使用以下命令配置轮询周期<code>spring.cloud.kubernetes.reload.period</code>属性，默认为15秒。它需要与受监视的属性源相同的角色。例如，这意味着对文件挂载的秘密源使用轮询不需要特定的特权。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表11。特性：</caption>
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.reload.enabled</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用对属性源的监视和配置重载</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.reload.monitoring-config-maps</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许监视配置映射中的更改</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.reload.monitoring-secrets</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许监视机密更改</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.reload.strategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Enum</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refresh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">触发重新加载时使用的策略（ <code>refresh</code> ， <code>restart_context</code> ， 要么<code>shutdown</code> ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.reload.mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Enum</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>event</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定如何侦听属性源中的更改（ <code>event</code>要么<code>polling</code> ）</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.cloud.kubernetes.reload.period</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Duration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>15s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用<code>polling</code>战略</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>注意：*您不应在以下位置使用属性<code>spring.cloud.kubernetes.reload</code>在配置映射或秘密中。在运行时更改此类属性可能会导致意外结果。*删除属性或整个配置映射不会恢复使用Bean的原始状态<code>refresh</code>水平。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ribbon-discovery-in-kubernetes"><a class="anchor" href="#ribbon-discovery-in-kubernetes"></a> <a class="link" href="#ribbon-discovery-in-kubernetes">18.6。Kubernetes中的Ribbon发现</a></h3>
<div class="paragraph">
<p>调用微服务的Spring Cloud客户端应用程序应该对依靠客户端负载平衡功能感兴趣，以便自动发现它可以在哪个端点到达给定服务。该机制已在<a href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-ribbon">spring-cloud-kubernetes-ribbon</a>项目中实现，其中Kubernetes客户端填充了<a href="https://github.com/Netflix/ribbon">Ribbon</a> <code>ServerList</code>包含有关此类端点的信息。</p>
</div>
<div class="paragraph">
<p>该实现是以下启动器的一部分，您可以通过将其依赖项添加到pom文件中来使用该实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-ribbon</artifactId>
    <version>${latest.version}</version>
</dependency></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>填充端点列表后，Kubernetes客户端通过匹配功能区客户端注释中定义的服务名称来搜索当前名称空间或项目中存在的已注册端点，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RibbonClient(name = "name-service")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过在您的属性中提供属性来配置功能区的行为<code>application.properties</code> （通过您应用的专用<code>ConfigMap</code> ），请使用以下格式： <code><name of your service>.ribbon.<Ribbon configuration key></code> ，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><name of your service></code>对应于您通过功能区访问的服务名称，使用<code>@RibbonClient</code>注释（例如<code>name-service</code>在前面的示例中）。</p>
</li>
<li>
<p><code><Ribbon configuration key></code>是功能区定义的<a href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java">功能</a>区配置键之一<a href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java"><code>CommonClientConfigKey</code>上课</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外， <code>spring-cloud-kubernetes-ribbon</code>该项目定义了两个附加的配置键，以进一步控制Ribbon与Kubernetes的交互方式。特别是，如果端点定义了多个端口，则默认行为是使用找到的第一个端口。要更具体地选择在多端口服务中使用哪个端口，可以使用<code>PortName</code>键。如果您想指定应在哪个Kubernetes命名空间中查找目标服务，则可以使用<code>KubernetesNamespace</code>密钥，请记住在两种情况下都要在这些密钥前加上您的服务名称和<code>ribbon</code>前缀，如前所述。</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表12。Spring Cloud Kubernetes功能区配置</caption>
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性键</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.ribbon.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">布尔值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.ribbon.mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>KubernetesRibbonMode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">荚</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.ribbon.cluster-domain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cluster.local</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<ul>
<li>
<p><code>spring.cloud.kubernetes.ribbon.mode</code>支持<code>POD</code>和<code>SERVICE</code>模式。</p>
<div class="ulist">
<ul>
<li>
<p>POD模式是通过获取Kubernetes的Pod IP地址并使用功能区来实现负载平衡的。POD模式使用功能区的负载平衡不支持Kubernetes负载平衡<code>Istio</code>不支持。</p>
</li>
<li>
<p>的<code>SERVICE</code>模式直接基于<code>service name</code>功能区。获取Kubernetes服务并入<code>service-name.{namespace}.svc.{cluster.domain}:{port}</code>如： <code>demo1.default.svc.cluster.local:8080</code> 。的<code>SERVICE</code>模式使用Kubernetes服务的负载平衡来支持Istio的流量策略。</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>spring.cloud.kubernetes.ribbon.cluster-domain</code>设置自定义Kubernetes集群域后缀。默认值为：“ cluster.local”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例使用此模块进行功能区发现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="./spring-cloud-kubernetes-examples/kubernetes-circuitbreaker-ribbon-example">spring-cloud-circuitbreaker和功能区</a></p>
</li>
<li>
<p><a href="https://github.com/fabric8-quickstarts/spring-boot-ribbon">fabric8-quickstarts-弹簧靴-功能区</a></p>
</li>
<li>
<p><a href="https://github.com/fabric8io/kubeflix/tree/master/examples/loanbroker/bank">Kubeflix-贷款经纪人-银行</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您可以通过设置<code>spring.cloud.kubernetes.ribbon.enabled=false</code>应用程序属性文件中的密钥。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="kubernetes-ecosystem-awareness"><a class="anchor" href="#kubernetes-ecosystem-awareness"></a> <a class="link" href="#kubernetes-ecosystem-awareness">18.7。Kubernetes生态系统意识</a></h3>
<div class="paragraph">
<p>无论您的应用程序是否在Kubernetes中运行，本指南前面介绍的所有功能都可以很好地工作。这对于开发和故障排除确实很有帮助。从开发的角度来看，这使您可以启动Spring Boot应用程序并调试属于该项目的模块之一。您无需将其部署在Kubernetes中，因为该项目的代码依赖于<a href="https://github.com/fabric8io/kubernetes-client">Fabric8 Kubernetes Java客户端</a> ，它是一种流利的DSL，可以通过以下方式进行通信： <code>http</code> Kubernetes服务器的REST API的协议。</p>
</div>
<div class="sect3">
<h4 id="kubernetes-profile-autoconfiguration"><a class="anchor" href="#kubernetes-profile-autoconfiguration"></a> <a class="link" href="#kubernetes-profile-autoconfiguration">18.7.1。Kubernetes配置文件自动配置</a></h4>
<div class="paragraph">
<p>当应用程序在Kubernetes中作为Pod运行时，名为Spring的配置文件<code>kubernetes</code>自动被激活。这使您可以自定义配置，以定义在Kubernetes平台中部署Spring Boot应用程序时要应用的bean（例如，不同的开发和生产配置）。</p>
</div>
</div>
<div class="sect3">
<h4 id="istio-awareness"><a class="anchor" href="#istio-awareness"></a> <a class="link" href="#istio-awareness">18.7.2。Istio意识</a></h4>
<div class="paragraph">
<p>当您包括<code>spring-cloud-kubernetes-istio</code>模块中的应用程序的类路径，一个新的配置文件被添加到应用程序，所提供的应用程序正在运行一个Kubernetes集群里面<a href="https://istio.io">Istio</a>安装。然后可以使用弹簧<code>@Profile("istio")</code> Bean中的注释和<code>@Configuration</code>类。</p>
</div>
<div class="paragraph">
<p>Istio意识模块使用<code>me.snowdrop:istio-client</code>与Istio API交互，使我们能够发现流量规则，断路器等，从而使我们的Spring Boot应用程序可以轻松使用此数据，以根据环境动态配置自身。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pod-health-indicator"><a class="anchor" href="#pod-health-indicator"></a> <a class="link" href="#pod-health-indicator">18.8。豆荚健康指标</a></h3>
<div class="paragraph">
<p>Spring Boot的用途<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpoint.java"><code>HealthIndicator</code></a>公开有关应用程序运行状况的信息。这对于将与健康相关的信息公开给用户非常有用，并且非常适合用作<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">就绪探针</a> 。</p>
</div>
<div class="paragraph">
<p>Kubernetes运行状况指示器（是核心模块的一部分）提供以下信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>窗格名称，IP地址，名称空间，服务帐户，节点名称及其IP地址</p>
</li>
<li>
<p>一个标志，指示Spring Boot应用程序在Kubernetes内部还是外部</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="leader-election"><a class="anchor" href="#leader-election"></a> <a class="link" href="#leader-election">18.9。领导人选举</a></h3>
<div class="paragraph">
<p><tbd></tbd></p>
</div>
</div>
<div class="sect2">
<h3 id="security-configurations-inside-kubernetes"><a class="anchor" href="#security-configurations-inside-kubernetes"></a> <a class="link" href="#security-configurations-inside-kubernetes">18.10。Kubernetes内部的安全配置</a></h3>
<div class="sect3">
<h4 id="namespace"><a class="anchor" href="#namespace"></a> <a class="link" href="#namespace">18.10.1。命名空间</a></h4>
<div class="paragraph">
<p>该项目中提供的大多数组件都需要知道名称空间。对于Kubernetes（1.3+），名称空间作为服务帐户密码的一部分可供Pod使用，并由客户端自动检测到。对于早期版本，需要将其指定为Pod的环境变量。一种快速的方法如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>      env:
      - name: "KUBERNETES_NAMESPACE"
        valueFrom:
          fieldRef:
            fieldPath: "metadata.namespace"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="service-account"><a class="anchor" href="#service-account"></a> <a class="link" href="#service-account">18.10.2。服务帐号</a></h4>
<div class="paragraph">
<p>对于支持集群内基于角色的更细粒度访问的Kubernetes发行版，您需要确保与<code>spring-cloud-kubernetes</code>有权访问Kubernetes API。对于您分配给部署或Pod的任何服务帐户，都需要确保它们具有正确的角色。</p>
</div>
<div class="paragraph">
<p>根据要求，您需要<code>get</code> ， <code>list</code>和<code>watch</code>对以下资源的许可：</p>
</div>
<table class="tableblock frame-topbot grid-all stretch">
<caption class="title">表13。Kubernetes资源权限</caption>
<colgroup>
<col style="width:50%">
<col style="width:50%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">相依性</th>
<th class="tableblock halign-left valign-top">资源资源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-starter-kubernetes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">吊舱，服务，端点</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-cloud-starter-kubernetes-config</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">configmaps，秘密</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring-Cloud-Starter-Kubernetes功能区</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">吊舱，服务，端点</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>出于开发目的，您可以添加<code>cluster-reader</code>您的权限<code>default</code>服务帐户。在生产系统上，您可能需要提供更精细的权限。</p>
</div>
<div class="paragraph">
<p>以下Role和RoleBinding是该对象的命名空间权限的示例。 <code>default</code>帐户：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: YOUR-NAME-SPACE
  name: namespace-reader
rules:
  - apiGroups: ["", "extensions", "apps"]
    resources: ["configmaps", "pods", "services", "endpoints", "secrets"]
    verbs: ["get", "list", "watch"]

---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: namespace-reader-binding
  namespace: YOUR-NAME-SPACE
subjects:
- kind: ServiceAccount
  name: default
  apiGroup: ""
roleRef:
  kind: Role
  name: namespace-reader
  apiGroup: ""</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="service-registry-implementation"><a class="anchor" href="#service-registry-implementation"></a> <a class="link" href="#service-registry-implementation">18.11。服务注册表实施</a></h3>
<div class="paragraph">
<p>在Kubernetes服务注册由平台控制的情况下，应用程序本身不像其他平台那样控制注册。因此，使用<code>spring.cloud.service-registry.auto-registration.enabled</code>或设置<code>@EnableDiscoveryClient(autoRegister=false)</code>在Spring Cloud Kubernetes中将无效。</p>
</div>
</div>
<div class="sect2">
<h3 id="examples"><a class="anchor" href="#examples"></a> <a class="link" href="#examples">18.12。例子</a></h3>
<div class="paragraph">
<p>Spring Cloud Kubernetes尝试通过遵循Spring Cloud接口使应用程序使用Kubernetes Native Services透明化。</p>
</div>
<div class="paragraph">
<p>在您的应用程序中，您需要添加<code>spring-cloud-kubernetes-discovery</code>对您的类路径的依赖关系，并删除任何其他包含<code>DiscoveryClient</code>实施（即Eureka发现客户端）。同样适用于<code>PropertySourceLocator</code> ，您需要在其中添加类路径<code>spring-cloud-kubernetes-config</code>并删除任何其他包含<code>PropertySourceLocator</code>实现（即配置服务器客户端）。</p>
</div>
<div class="paragraph">
<p>以下项目重点介绍了这些依赖项的用法，并演示了如何从任何Spring Boot应用程序中使用这些库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples">Spring Cloud Kubernetes示例</a> ：位于此存储<a href="https://github.com/spring-cloud/spring-cloud-kubernetes/tree/master/spring-cloud-kubernetes-examples">库内的示例</a> 。</p>
</li>
<li>
<p>Spring Cloud Kubernetes完整示例：奴才和上司</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/salaboy/spring-cloud-k8s-minion">奴才</a></p>
</li>
<li>
<p><a href="https://github.com/salaboy/spring-cloud-k8s-boss">老板</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Spring Cloud Kubernetes完整示例： <a href="https://github.com/salaboy/s1p_docs">SpringOne Platform Tickets Service</a></p>
</li>
<li>
<p><a href="https://github.com/salaboy/s1p_gateway">具有Spring Cloud Kubernetes发现和配置的Spring Cloud Gateway</a></p>
</li>
<li>
<p><a href="https://github.com/salaboy/showcase-admin-tool">使用Spring Cloud Kubernetes发现和配置进行Spring Boot Admin</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="other-resources"><a class="anchor" href="#other-resources"></a> <a class="link" href="#other-resources">18.13。其他资源</a></h3>
<div class="paragraph">
<p>本节列出了其他资源，例如有关Spring Cloud Kubernetes的演示（幻灯片）和视频。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://salaboy.com/2018/09/27/the-s1p-experience/">PKS上的S1P Spring Cloud</a></p>
</li>
<li>
<p><a href="https://salaboy.com/2018/07/18/ljc-july-18-spring-cloud-docker-k8s/">Spring Cloud，Docker，Kubernetes→伦敦Java社区2018年7月</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请随时通过拉取请求向<a href="https://github.com/spring-cloud/spring-cloud-kubernetes">此存储库</a>提交其他资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-properties-8"><a class="anchor" href="#configuration-properties-8"></a> <a class="link" href="#configuration-properties-8">18.14。配置属性</a></h3>
<div class="paragraph">
<p>要查看所有与Sleuth相关的配置属性的列表，请检查<a href="appendix.html">附录页面</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="building"><a class="anchor" href="#building"></a> <a class="link" href="#building">18.15。建造</a></h3>
<div class="sect3">
<h4 id="basic-compile-and-test"><a class="anchor" href="#basic-compile-and-test"></a> <a class="link" href="#basic-compile-and-test">18.15.1。基本编译和测试</a></h4>
<div class="paragraph">
<p>要构建源代码，您将需要安装JDK 1.7。</p>
</div>
<div class="paragraph">
<p>Spring Cloud使用Maven进行大多数与构建相关的活动，并且您应该能够通过克隆您感兴趣的项目并键入来快速启动</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw install</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以自己安装Maven（> = 3.3.3）并运行<code>mvn</code>命令代替<code>./mvnw</code>在下面的示例中。如果这样做，您可能还需要添加<code>-P spring</code>如果您的本地Maven设置不包含Spring预发行项目的存储库声明。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，您可能需要通过设置以下选项来增加Maven可用的内存量： <code>MAVEN_OPTS</code>具有以下值的环境变量<code>-Xmx512m -XX:MaxPermSize=128m</code> 。我们尝试在<code>.mvn</code>配置，因此，如果发现必须执行此操作才能使构建成功，请提出票证以将设置添加到源代码管理中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关如何构建项目的提示，请参阅<code>.travis.yml</code>如果有一个。应该有一个“脚本”甚至“安装”命令。还请查看“服务”部分，以查看是否需要在本地运行任何服务（例如mongo或Rabbit）。忽略您可能在“ before_install”中找到的与git相关的位，因为它们与设置git凭据有关，并且您已经拥有了这些。</p>
</div>
<div class="paragraph">
<p>需要中间件的项目通常包括<code>docker-compose.yml</code> ，因此请考虑使用<a href="https://docs.docker.com/compose/">Docker Compose</a>在Docker容器中运行中间件服务器。有关mongo，rabbit和redis常见情况的特定说明，请参见<a href="https://github.com/spring-cloud-samples/scripts">脚本演示存储库中</a>的README。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果其他所有方法均失败，则使用以下命令进行构建<code>.travis.yml</code> （通常<code>./mvnw install</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="documentation"><a class="anchor" href="#documentation"></a> <a class="link" href="#documentation">18.15.2。文献资料</a></h4>
<div class="paragraph">
<p>spring-cloud-build模块有一个“ docs”配置文件，如果打开它，将尝试从以下目录构建asciidoc源<code>src/main/asciidoc</code> 。作为该过程的一部分，它将寻找<code>README.adoc</code>并通过加载所有包含项进行处理，但不进行解析或渲染，只需将其复制到<code>${main.basedir}</code> （默认为<code>$/home/marcin/repo/spring-cloud-scripts</code> ，即项目的根目录）。如果自述文件有任何更改，它将在Maven构建后显示为正确位置的修改文件。只需提交并推动更改即可。</p>
</div>
</div>
<div class="sect3">
<h4 id="working-with-the-code"><a class="anchor" href="#working-with-the-code"></a> <a class="link" href="#working-with-the-code">18.15.3。使用代码</a></h4>
<div class="paragraph">
<p>如果您没有IDE偏好设置，我们建议您在使用代码时使用<a href="https://www.springsource.com/developer/sts">Spring Tools Suite</a>或<a href="https://eclipse.org">Eclipse</a> 。我们使用<a href="https://eclipse.org/m2e/">m2eclipse</a> eclipse插件来获得maven支持。只要其他IDE和工具使用Maven 3.3.3或更高版本，它们也应该可以正常工作。</p>
</div>
<div class="sect4">
<h5 id="importing-into-eclipse-with-m2eclipse"><a class="anchor" href="#importing-into-eclipse-with-m2eclipse"></a> <a class="link" href="#importing-into-eclipse-with-m2eclipse">使用m2eclipse导入eclipse</a></h5>
<div class="paragraph">
<p>使用eclipse时，我们建议使用<a href="https://eclipse.org/m2e/">m2eclipse</a> eclipse插件。如果尚未安装m2eclipse，则可以从“ eclipse市场”中获得。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">较旧的m2e版本不支持Maven 3.3，因此，一旦将项目导入Eclipse，您还需要告诉m2eclipse为项目使用正确的配置文件。如果您在项目中看到许多与POM相关的错误，请检查您是否具有最新的安装。如果您无法升级m2e，请将“ spring”配置文件添加到您的<code>settings.xml</code> 。或者，您可以将存储库设置从父pom的“ spring”配置文件复制到您的<code>settings.xml</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="importing-into-eclipse-without-m2eclipse"><a class="anchor" href="#importing-into-eclipse-without-m2eclipse"></a> <a class="link" href="#importing-into-eclipse-without-m2eclipse">不使用m2eclipse导入eclipse</a></h5>
<div class="paragraph">
<p>如果您不想使用m2eclipse，则可以使用以下命令生成eclipse项目元数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw eclipse:eclipse</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过选择导入生成的Eclipse项目<code>import existing projects</code>来自<code>file</code>菜单。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contributing"><a class="anchor" href="#contributing"></a> <a class="link" href="#contributing">18.16。贡献</a></h3>
<div class="paragraph">
<p>Spring Cloud是在非限制性Apache 2.0许可下发布的，并且遵循非常标准的Github开发流程，使用Github跟踪程序解决问题并将合并请求合并到master中。如果您想贡献些微不足道的东西，请不要犹豫，但请遵循以下准则。</p>
</div>
<div class="sect3">
<h4 id="sign-the-contributor-license-agreement"><a class="anchor" href="#sign-the-contributor-license-agreement"></a> <a class="link" href="#sign-the-contributor-license-agreement">18.16.1。签署贡献者许可协议</a></h4>
<div class="paragraph">
<p>在我们接受不重要的补丁或请求请求之前，我们将需要您签署“ <a href="https://cla.pivotal.io/sign/spring">贡献者许可协议”</a> 。签署贡献者协议并不会授予任何人对主存储库的提交权，但这确实意味着我们可以接受您的贡献，并且如果您这样做，您将获得作者的荣誉。可能需要活跃的贡献者加入核心团队，并具有合并合并请求的能力。</p>
</div>
</div>
<div class="sect3">
<h4 id="code-of-conduct"><a class="anchor" href="#code-of-conduct"></a> <a class="link" href="#code-of-conduct">18.16.2。行为守则</a></h4>
<div class="paragraph">
<p>该项目遵守《贡献者公约》 <a href="https://github.com/spring-cloud/spring-cloud-build/blob/master/docs/src/main/asciidoc/code-of-conduct.adoc">行为守则</a> 。通过参与，您将遵守此代码。请向<a href="mailto:spring-code-of-conduct@pivotal.io">spring-code-of-conduct@pivotal.io</a>报告不可接受的行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="code-conventions-and-housekeeping"><a class="anchor" href="#code-conventions-and-housekeeping"></a> <a class="link" href="#code-conventions-and-housekeeping">18.16.3。规范和内务守则</a></h4>
<div class="paragraph">
<p>这些对于拉取请求都不是必不可少的，但是它们都会有所帮助。也可以在原始请求请求之后但在合并之前添加它们。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Spring Framework代码格式约定。如果您使用Eclipse，则可以使用<code>eclipse-code-formatter.xml</code> <a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-dependencies-parent/eclipse-code-formatter.xml">Spring Cloud Build</a>项目中的文件。如果使用IntelliJ，则可以使用<a href="https://plugins.jetbrains.com/plugin/6546">Eclipse Code Formatter插件</a>来导入相同的文件。</p>
</li>
<li>
<p>确保所有新<code>.java</code>文件具有简单的Javadoc类注释，且至少包含一个<code>@author</code>标签，用于识别您的身份，最好是至少包含有关该类目的的段落。</p>
</li>
<li>
<p>将ASF许可证标头注释添加到所有新的<code>.java</code>文件（从项目中的现有文件复制）</p>
</li>
<li>
<p>将自己添加为<code>@author</code>到您进行了实质性修改（不仅仅是外观更改）的.java文件。</p>
</li>
<li>
<p>添加一些Javadocs，如果更改名称空间，则添加一些XSD doc元素。</p>
</li>
<li>
<p>进行一些单元测试也有很大帮助-有人必须这样做。</p>
</li>
<li>
<p>如果没有其他人在使用您的分支，请根据当前的主节点（或主项目中的其他目标分支）对其进行重新设置。</p>
</li>
<li>
<p>编写提交消息时，请遵循<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">以下约定</a> ，如果要解决现有问题，请添加<code>Fixes gh-XXXX</code>在提交消息的末尾（其中XXXX是发行号）。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="checkstyle"><a class="anchor" href="#checkstyle"></a> <a class="link" href="#checkstyle">18.16.4。Checkstyle</a></h4>
<div class="paragraph">
<p>Spring Cloud Build带有一组checkstyle规则。您可以在<code>spring-cloud-build-tools</code>模块。该模块下最值得注意的文件是：</p>
</div>
<div class="listingblock">
<div class="title">spring-cloud-build-tools /</div>
<div class="content">
<pre>└── src
    ├── checkstyle
    │   └── checkstyle-suppressions.xml <i class="conum" data-value="3"></i><b>(3)</b>
    └── main
        └── resources
            ├── checkstyle-header.txt <i class="conum" data-value="2"></i><b>(2)</b>
            └── checkstyle.xml <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>默认Checkstyle规则</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>文件头设置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认禁止规则</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="checkstyle-configuration"><a class="anchor" href="#checkstyle-configuration"></a> <a class="link" href="#checkstyle-configuration">Checkstyle配置</a></h5>
<div class="paragraph">
<p>Checkstyle规则<strong>默认</strong>为<strong>禁用</strong> 。要将checkstyle添加到项目中，只需定义以下属性和插件。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre><properties>
<maven-checkstyle-plugin.failsOnError>true</maven-checkstyle-plugin.failsOnError> <i class="conum" data-value="1"></i><b>(1)</b>
        <maven-checkstyle-plugin.failsOnViolation>true
        </maven-checkstyle-plugin.failsOnViolation> <i class="conum" data-value="2"></i><b>(2)</b>
        <maven-checkstyle-plugin.includeTestSourceDirectory>true
        </maven-checkstyle-plugin.includeTestSourceDirectory> <i class="conum" data-value="3"></i><b>(3)</b>
</properties>

<build>
        <plugins>
            <plugin> <i class="conum" data-value="4"></i><b>(4)</b>
                <groupId>io.spring.javaformat</groupId>
                <artifactId>spring-javaformat-maven-plugin</artifactId>
            </plugin>
            <plugin> <i class="conum" data-value="5"></i><b>(5)</b>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
            </plugin>
        </plugins>

    <reporting>
        <plugins>
            <plugin> <i class="conum" data-value="5"></i><b>(5)</b>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
            </plugin>
        </plugins>
    </reporting>
</build></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>因Checkstyle错误而无法构建</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>因Checkstyle违规而无法构建</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>Checkstyle还分析测试源</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加Spring Java Format插件，该插件将重新格式化您的代码以通过大多数Checkstyle格式化规则</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>将Checkstyle插件添加到构建和报告阶段</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要取消某些规则（例如，行长需要更长），那么在下面定义一个文件就足够了<code>${project.root}/src/checkstyle/checkstyle-suppressions.xml</code>你的压抑。例：</p>
</div>
<div class="listingblock">
<div class="title">projectRoot / src / checkstyle / checkstyle-suppresions.xml</div>
<div class="content">
<pre><?xml version="1.0"?>
<!DOCTYPE suppressions PUBLIC
        "-//Puppy Crawl//DTD Suppressions 1.1//EN"
        "https://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
<suppressions>
    <suppress files=".*ConfigServerApplication\.java" checks="HideUtilityClassConstructor"/>
    <suppress files=".*ConfigClientWatch\.java" checks="LineLengthCheck"/>
</suppressions></pre>
</div>
</div>
<div class="paragraph">
<p>建议复制<code>${spring-cloud-build.rootFolder}/.editorconfig</code>和<code>${spring-cloud-build.rootFolder}/.springformat</code>到您的项目。这样，将应用一些默认格式设置规则。您可以通过运行以下脚本来这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ curl https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/.editorconfig -o .editorconfig
$ touch .springformat</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ide-setup"><a class="anchor" href="#ide-setup"></a> <a class="link" href="#ide-setup">18.16.5。IDE设置</a></h4>
<div class="sect4">
<h5 id="intellij-idea"><a class="anchor" href="#intellij-idea"></a> <a class="link" href="#intellij-idea">Intellij IDEA</a></h5>
<div class="paragraph">
<p>为了设置Intellij，您应该导入我们的编码约定，检查配置文件并设置checkstyle插件。在<a href="https://github.com/spring-cloud/spring-cloud-build/tree/master/spring-cloud-build-tools">Spring Cloud Build</a>项目中可以找到以下文件。</p>
</div>
<div class="listingblock">
<div class="title">spring-cloud-build-tools /</div>
<div class="content">
<pre>└── src
    ├── checkstyle
    │   └── checkstyle-suppressions.xml <i class="conum" data-value="3"></i><b>(3)</b>
    └── main
        └── resources
            ├── checkstyle-header.txt <i class="conum" data-value="2"></i><b>(2)</b>
            ├── checkstyle.xml <i class="conum" data-value="1"></i><b>(1)</b>
            └── intellij
                ├── Intellij_Project_Defaults.xml <i class="conum" data-value="4"></i><b>(4)</b>
                └── Intellij_Spring_Boot_Java_Conventions.xml <i class="conum" data-value="5"></i><b>(5)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>默认Checkstyle规则</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>文件头设置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认禁止规则</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>适用于大多数Checkstyle规则的Intellij项目默认值</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>适用于大多数Checkstyle规则的Intellij的项目样式约定</td>
</tr>
</tbody></table>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-code-style.png" alt="代码风格">
</div>
<div class="title">图4。代码风格</div>
</div>
<div class="paragraph">
<p>去<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>Code style</code> 。在那里，单击旁边的图标<code>Scheme</code>部分。在那里，点击<code>Import Scheme</code>值并选择<code>Intellij IDEA code style XML</code>选项。导入<code>spring-cloud-build-tools/src/main/resources/intellij/Intellij_Spring_Boot_Java_Conventions.xml</code>文件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-inspections.png" alt="代码风格">
</div>
<div class="title">图5。检验概况</div>
</div>
<div class="paragraph">
<p>去<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>Inspections</code> 。在那里，单击旁边的图标<code>Profile</code>部分。在那里，点击<code>Import Profile</code>并导入<code>spring-cloud-build-tools/src/main/resources/intellij/Intellij_Project_Defaults.xml</code>文件。</p>
</div>
<div class="paragraph">
<div class="title">Checkstyle</div>
<p>要使Intellij与Checkstyle一起使用，您必须安装<code>Checkstyle</code>插入。建议也安装<code>Assertions2Assertj</code>自动转换JUnit断言</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-checkstyle.png" alt="Checkstyle">
</div>
</div>
<div class="paragraph">
<p>去<code>File</code> → <code>Settings</code> → <code>Other settings</code> → <code>Checkstyle</code> 。那里点击<code>+</code>中的图标<code>Configuration file</code>部分。在这里，您必须定义应从何处选择checkstyle规则。在上图中，我们从克隆的Spring Cloud Build存储库中选择了规则。但是，您可以指向Spring Cloud Build的GitHub存储库（例如，对于<code>checkstyle.xml</code> ： <code><a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml" class="bare">raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml</a></code> ）。我们需要提供以下变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>checkstyle.header.file</code> -请指向Spring Cloud Build的<code>spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</code>文件在您的克隆存储库中或通过<code><a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt" class="bare">raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</a></code>网址。</p>
</li>
<li>
<p><code>checkstyle.suppressions.file</code> -默认抑制。请把它指向Spring Cloud Build的， <code>spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</code>文件在您的克隆存储库中或通过<code><a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml" class="bare">raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</a></code>网址。</p>
</li>
<li>
<p><code>checkstyle.additional.suppressions.file</code> -此变量对应于本地项目中的抑制。例如，您正在从事<code>spring-cloud-contract</code> 。然后指向<code>project-root/src/checkstyle/checkstyle-suppressions.xml</code>夹。范例<code>spring-cloud-contract</code>将会： <code>/home/username/spring-cloud-contract/src/checkstyle/checkstyle-suppressions.xml</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请记住设置<code>Scan Scope</code>至<code>All sources</code>因为我们将checkstyle规则应用于生产和测试源。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1" data-splitx="2"></div>
<div class="sect1">
<h2 id="spring-cloud-circuit-breaker-2"><a class="anchor" href="#spring-cloud-circuit-breaker-2"></a> <a class="link" href="#spring-cloud-circuit-breaker-2">20spring-cloud-circuitbreaker</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>霍克斯顿。发布</strong></p>
</div>
<div class="sect3">
<h4 id="configuring-resilience4j-circuit-breakers"><a class="anchor" href="#configuring-resilience4j-circuit-breakers"></a> <a class="link" href="#configuring-resilience4j-circuit-breakers">20.1。配置Resilience4J断路器</a></h4>
<div class="sect4">
<h5 id="starters-2"><a class="anchor" href="#starters-2"></a> <a class="link" href="#starters-2">初学者</a></h5>
<div class="paragraph">
<p>Resilience4J实现有两个启动器，一个用于响应式应用程序，一个用于非响应式应用程序。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j</code> -非反应性应用</p>
</li>
<li>
<p><code>org.springframework.cloud:spring-cloud-starter-circuitbreaker-reactor-resilience4j</code> -反应性应用</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="auto-configuration"><a class="anchor" href="#auto-configuration"></a> <a class="link" href="#auto-configuration">自动配置</a></h5>
<div class="paragraph">
<p>您可以通过设置来禁用Resilience4J自动配置<code>spring.cloud.circuitbreaker.resilience4j.enabled</code>至<code>false</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="default-configuration-2"><a class="anchor" href="#default-configuration-2"></a> <a class="link" href="#default-configuration-2">默认配置</a></h5>
<div class="paragraph">
<p>要为所有断路器提供默认配置，请创建一个<code>Customize</code>通过的豆<code>Resilience4JCircuitBreakerFactory</code>要么<code>ReactiveResilience4JCircuitBreakerFactory</code> 。的<code>configureDefault</code>方法可用于提供默认配置。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<Resilience4JCircuitBreakerFactory> defaultCustomizer() {
    return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
            .timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(4)).build())
            .circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
            .build());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="reactive-example-3"><a class="anchor" href="#reactive-example-3"></a> <a class="link" href="#reactive-example-3">反应性例子</a></h6>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<ReactiveResilience4JCircuitBreakerFactory> defaultCustomizer() {
    return factory -> factory.configureDefault(id -> new Resilience4JConfigBuilder(id)
            .circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
            .timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(4)).build()).build());
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specific-circuit-breaker-configuration-2"><a class="anchor" href="#specific-circuit-breaker-configuration-2"></a> <a class="link" href="#specific-circuit-breaker-configuration-2">特定断路器配置</a></h5>
<div class="paragraph">
<p>与提供默认配置类似，您可以创建一个<code>Customize</code>豆这是通过<code>Resilience4JCircuitBreakerFactory</code>要么<code>ReactiveResilience4JCircuitBreakerFactory</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<Resilience4JCircuitBreakerFactory> slowCustomizer() {
    return factory -> factory.configure(builder -> builder.circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())
            .timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(2)).build()), "slow");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了配置已创建的断路器之外，您还可以在创建断路器之后但将其返回给调用方之前自定义断路器。为此，您可以使用<code>addCircuitBreakerCustomizer</code>方法。这对于将事件处理程序添加到Resilience4J断路器很有用。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<Resilience4JCircuitBreakerFactory> slowCustomizer() {
    return factory -> factory.addCircuitBreakerCustomizer(circuitBreaker -> circuitBreaker.getEventPublisher()
    .onError(normalFluxErrorConsumer).onSuccess(normalFluxSuccessConsumer), "normalflux");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="reactive-example-4"><a class="anchor" href="#reactive-example-4"></a> <a class="link" href="#reactive-example-4">反应性例子</a></h6>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<ReactiveResilience4JCircuitBreakerFactory> slowCusomtizer() {
    return factory -> {
        factory.configure(builder -> builder
        .timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(2)).build())
        .circuitBreakerConfig(CircuitBreakerConfig.ofDefaults()), "slow", "slowflux");
        factory.addCircuitBreakerCustomizer(circuitBreaker -> circuitBreaker.getEventPublisher()
            .onError(normalFluxErrorConsumer).onSuccess(normalFluxSuccessConsumer), "normalflux");
     };
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collecting-metrics"><a class="anchor" href="#collecting-metrics"></a> <a class="link" href="#collecting-metrics">收集指标</a></h5>
<div class="paragraph">
<p>只要正确的依赖项在类路径上，Spring Cloud Circuit Breaker Resilience4j就会包括自动配置以设置指标收集。要启用指标收集，您必须包括<code>org.springframework.boot:spring-boot-starter-actuator</code>和<code>io.github.resilience4j:resilience4j-micrometer</code> 。有关存在这些依赖项时产生的度量的更多信息，请参见<a href="https://resilience4j.readme.io/docs/micrometer">Resilience4j文档</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您不必包括<code>micrometer-core</code>直接由它带来<code>spring-boot-starter-actuator</code>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-spring-retry-circuit-breakers"><a class="anchor" href="#configuring-spring-retry-circuit-breakers"></a> <a class="link" href="#configuring-spring-retry-circuit-breakers">20.2。配置弹簧重试断路器</a></h4>
<div class="paragraph">
<p>Spring Retry为Spring应用程序提供了声明式重试支持。该项目的子集包括实现断路器功能的能力。Spring Retry通过结合以下几种方式来提供断路器实现<a href="https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/policy/CircuitBreakerRetryPolicy.java"><code>CircuitBreakerRetryPolicy</code></a>和有<a href="https://github.com/spring-projects/spring-retry#stateful-retry">状态的重试</a> 。使用Spring Retry创建的所有断路器将使用<code>CircuitBreakerRetryPolicy</code>和一个<a href="https://github.com/spring-projects/spring-retry/blob/master/src/main/java/org/springframework/retry/support/DefaultRetryState.java"><code>DefaultRetryState</code></a> 。这两个类都可以使用<code>SpringRetryConfigBuilder</code> 。</p>
</div>
<div class="sect4">
<h5 id="default-configuration-3"><a class="anchor" href="#default-configuration-3"></a> <a class="link" href="#default-configuration-3">默认配置</a></h5>
<div class="paragraph">
<p>要为所有断路器提供默认配置，请创建一个<code>Customize</code>通过的豆<code>SpringRetryCircuitBreakerFactory</code> 。的<code>configureDefault</code>方法可用于提供默认配置。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<SpringRetryCircuitBreakerFactory> defaultCustomizer() {
    return factory -> factory.configureDefault(id -> new SpringRetryConfigBuilder(id)
        .retryPolicy(new TimeoutRetryPolicy()).build());
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specific-circuit-breaker-configuration-3"><a class="anchor" href="#specific-circuit-breaker-configuration-3"></a> <a class="link" href="#specific-circuit-breaker-configuration-3">特定断路器配置</a></h5>
<div class="paragraph">
<p>与提供默认配置类似，您可以创建一个<code>Customize</code>豆这是通过<code>SpringRetryCircuitBreakerFactory</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<SpringRetryCircuitBreakerFactory> slowCustomizer() {
    return factory -> factory.configure(builder -> builder.retryPolicy(new SimpleRetryPolicy(1)).build(), "slow");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了配置已创建的断路器之外，您还可以在创建断路器之后但将其返回给调用方之前自定义断路器。为此，您可以使用<code>addRetryTemplateCustomizers</code>方法。这对于将事件处理程序添加到<code>RetryTemplate</code> 。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Customizer<SpringRetryCircuitBreakerFactory> slowCustomizer() {
    return factory -> factory.addRetryTemplateCustomizers(retryTemplate -> retryTemplate.registerListener(new RetryListener() {

        @Override
        public <T, E extends Throwable> boolean open(RetryContext context, RetryCallback<T, E> callback) {
            return false;
        }

        @Override
        public <T, E extends Throwable> void close(RetryContext context, RetryCallback<T, E> callback, Throwable throwable) {

        }

        @Override
        public <T, E extends Throwable> void onError(RetryContext context, RetryCallback<T, E> callback, Throwable throwable) {

        }
    }));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="building-2"><a class="anchor" href="#building-2"></a> <a class="link" href="#building-2">20.3。建造</a></h3>
<div class="sect3">
<h4 id="basic-compile-and-test-2"><a class="anchor" href="#basic-compile-and-test-2"></a> <a class="link" href="#basic-compile-and-test-2">20.3.1。基本编译和测试</a></h4>
<div class="paragraph">
<p>要构建源代码，您将需要安装JDK 1.8。</p>
</div>
<div class="paragraph">
<p>Spring Cloud使用Maven进行大多数与构建相关的活动，并且您应该能够通过克隆您感兴趣的项目并键入来快速启动</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw install</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您也可以自己安装Maven（> = 3.3.3）并运行<code>mvn</code>命令代替<code>./mvnw</code>在下面的示例中。如果这样做，您可能还需要添加<code>-P spring</code>如果您的本地Maven设置不包含Spring预发行项目的存储库声明。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">请注意，您可能需要通过设置以下选项来增加Maven可用的内存量： <code>MAVEN_OPTS</code>具有以下值的环境变量<code>-Xmx512m -XX:MaxPermSize=128m</code> 。我们尝试在<code>.mvn</code>配置，因此，如果发现必须执行此操作才能使构建成功，请提出票证以将设置添加到源代码管理中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关如何构建项目的提示，请参阅<code>.travis.yml</code>如果有一个。应该有一个“脚本”甚至“安装”命令。还请查看“服务”部分，以查看是否需要在本地运行任何服务（例如mongo或Rabbit）。忽略您可能在“ before_install”中找到的与git相关的位，因为它们与设置git凭据有关，并且您已经拥有了这些。</p>
</div>
<div class="paragraph">
<p>需要中间件的项目通常包括<code>docker-compose.yml</code> ，因此请考虑使用<a href="https://docs.docker.com/compose/">Docker Compose</a>在Docker容器中运行中间件服务器。有关mongo，rabbit和redis常见情况的特定说明，请参见<a href="https://github.com/spring-cloud-samples/scripts">脚本演示存储库中</a>的README。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果其他所有方法均失败，则使用以下命令进行构建<code>.travis.yml</code> （通常<code>./mvnw install</code> ）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="documentation-2"><a class="anchor" href="#documentation-2"></a> <a class="link" href="#documentation-2">20.3.2。文献资料</a></h4>
<div class="paragraph">
<p>spring-cloud-build模块有一个“ docs”配置文件，如果打开它，将尝试从以下目录构建asciidoc源<code>src/main/asciidoc</code> 。作为该过程的一部分，它将寻找<code>README.adoc</code>并通过加载所有包含项进行处理，但不进行解析或渲染，只需将其复制到<code>${main.basedir}</code> （默认为<code>$/home/marcin/repo/spring-cloud-scripts</code> ，即项目的根目录）。如果自述文件有任何更改，它将在Maven构建后显示为正确位置的修改文件。只需提交并推动更改即可。</p>
</div>
</div>
<div class="sect3">
<h4 id="working-with-the-code-2"><a class="anchor" href="#working-with-the-code-2"></a> <a class="link" href="#working-with-the-code-2">20.3.3。使用代码</a></h4>
<div class="paragraph">
<p>如果您没有IDE偏好设置，我们建议您在使用代码时使用<a href="https://www.springsource.com/developer/sts">Spring Tools Suite</a>或<a href="https://eclipse.org">Eclipse</a> 。我们使用<a href="https://eclipse.org/m2e/">m2eclipse</a> eclipse插件来获得maven支持。只要其他IDE和工具使用Maven 3.3.3或更高版本，它们也应该可以正常工作。</p>
</div>
<div class="sect4">
<h5 id="importing-into-eclipse-with-m2eclipse-2"><a class="anchor" href="#importing-into-eclipse-with-m2eclipse-2"></a> <a class="link" href="#importing-into-eclipse-with-m2eclipse-2">使用m2eclipse导入eclipse</a></h5>
<div class="paragraph">
<p>使用eclipse时，我们建议使用<a href="https://eclipse.org/m2e/">m2eclipse</a> eclipse插件。如果尚未安装m2eclipse，则可以从“ eclipse市场”中获得。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">较旧的m2e版本不支持Maven 3.3，因此，一旦将项目导入Eclipse，您还需要告诉m2eclipse为项目使用正确的配置文件。如果您在项目中看到许多与POM相关的错误，请检查您是否具有最新的安装。如果您无法升级m2e，请将“ spring”配置文件添加到您的<code>settings.xml</code> 。或者，您可以将存储库设置从父pom的“ spring”配置文件复制到您的<code>settings.xml</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="importing-into-eclipse-without-m2eclipse-2"><a class="anchor" href="#importing-into-eclipse-without-m2eclipse-2"></a> <a class="link" href="#importing-into-eclipse-without-m2eclipse-2">不使用m2eclipse导入eclipse</a></h5>
<div class="paragraph">
<p>如果您不想使用m2eclipse，则可以使用以下命令生成eclipse项目元数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw eclipse:eclipse</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过选择导入生成的Eclipse项目<code>import existing projects</code>来自<code>file</code>菜单。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contributing-2"><a class="anchor" href="#contributing-2"></a> <a class="link" href="#contributing-2">20.4。贡献</a></h3>
<div class="paragraph">
<p>Spring Cloud是在非限制性Apache 2.0许可下发布的，并且遵循非常标准的Github开发流程，使用Github跟踪程序解决问题并将合并请求合并到master中。如果您想贡献些微不足道的东西，请不要犹豫，但请遵循以下准则。</p>
</div>
<div class="sect3">
<h4 id="sign-the-contributor-license-agreement-2"><a class="anchor" href="#sign-the-contributor-license-agreement-2"></a> <a class="link" href="#sign-the-contributor-license-agreement-2">20.4.1。签署贡献者许可协议</a></h4>
<div class="paragraph">
<p>在我们接受不重要的补丁或请求请求之前，我们将需要您签署“ <a href="https://cla.pivotal.io/sign/spring">贡献者许可协议”</a> 。签署贡献者协议并不会授予任何人对主存储库的提交权，但这确实意味着我们可以接受您的贡献，并且如果您这样做，您将获得作者的荣誉。可能需要活跃的贡献者加入核心团队，并具有合并合并请求的能力。</p>
</div>
</div>
<div class="sect3">
<h4 id="code-of-conduct-2"><a class="anchor" href="#code-of-conduct-2"></a> <a class="link" href="#code-of-conduct-2">20.4.2。行为守则</a></h4>
<div class="paragraph">
<p>该项目遵守《贡献者公约》 <a href="https://github.com/spring-cloud/spring-cloud-build/blob/master/docs/src/main/asciidoc/code-of-conduct.adoc">行为守则</a> 。通过参与，您将遵守此代码。请向<a href="mailto:spring-code-of-conduct@pivotal.io">spring-code-of-conduct@pivotal.io</a>报告不可接受的行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="code-conventions-and-housekeeping-2"><a class="anchor" href="#code-conventions-and-housekeeping-2"></a> <a class="link" href="#code-conventions-and-housekeeping-2">20.4.3。规范和内务守则</a></h4>
<div class="paragraph">
<p>这些对于拉取请求都不是必不可少的，但是它们都会有所帮助。也可以在原始请求请求之后但在合并之前添加它们。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Spring Framework代码格式约定。如果您使用Eclipse，则可以使用<code>eclipse-code-formatter.xml</code> <a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-dependencies-parent/eclipse-code-formatter.xml">Spring Cloud Build</a>项目中的文件。如果使用IntelliJ，则可以使用<a href="https://plugins.jetbrains.com/plugin/6546">Eclipse Code Formatter插件</a>来导入相同的文件。</p>
</li>
<li>
<p>确保所有新<code>.java</code>文件具有简单的Javadoc类注释，且至少包含一个<code>@author</code>标签，用于识别您的身份，最好是至少包含有关该类目的的段落。</p>
</li>
<li>
<p>将ASF许可证标头注释添加到所有新的<code>.java</code>文件（从项目中的现有文件复制）</p>
</li>
<li>
<p>将自己添加为<code>@author</code>到您进行了实质性修改（不仅仅是外观更改）的.java文件。</p>
</li>
<li>
<p>添加一些Javadocs，如果更改名称空间，则添加一些XSD doc元素。</p>
</li>
<li>
<p>进行一些单元测试也有很大帮助-有人必须这样做。</p>
</li>
<li>
<p>如果没有其他人在使用您的分支，请根据当前的主节点（或主项目中的其他目标分支）对其进行重新设置。</p>
</li>
<li>
<p>编写提交消息时，请遵循<a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">以下约定</a> ，如果要解决现有问题，请添加<code>Fixes gh-XXXX</code>在提交消息的末尾（其中XXXX是发行号）。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="checkstyle-2"><a class="anchor" href="#checkstyle-2"></a> <a class="link" href="#checkstyle-2">20.4.4。Checkstyle</a></h4>
<div class="paragraph">
<p>Spring Cloud Build带有一组checkstyle规则。您可以在<code>spring-cloud-build-tools</code>模块。该模块下最值得注意的文件是：</p>
</div>
<div class="listingblock">
<div class="title">spring-cloud-build-tools /</div>
<div class="content">
<pre>└── src
    ├── checkstyle
    │   └── checkstyle-suppressions.xml <i class="conum" data-value="3"></i><b>(3)</b>
    └── main
        └── resources
            ├── checkstyle-header.txt <i class="conum" data-value="2"></i><b>(2)</b>
            └── checkstyle.xml <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>默认Checkstyle规则</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>文件头设置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认禁止规则</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="checkstyle-configuration-2"><a class="anchor" href="#checkstyle-configuration-2"></a> <a class="link" href="#checkstyle-configuration-2">Checkstyle配置</a></h5>
<div class="paragraph">
<p>Checkstyle规则<strong>默认</strong>为<strong>禁用</strong> 。要将checkstyle添加到项目中，只需定义以下属性和插件。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre><properties>
<maven-checkstyle-plugin.failsOnError>true</maven-checkstyle-plugin.failsOnError> <i class="conum" data-value="1"></i><b>(1)</b>
        <maven-checkstyle-plugin.failsOnViolation>true
        </maven-checkstyle-plugin.failsOnViolation> <i class="conum" data-value="2"></i><b>(2)</b>
        <maven-checkstyle-plugin.includeTestSourceDirectory>true
        </maven-checkstyle-plugin.includeTestSourceDirectory> <i class="conum" data-value="3"></i><b>(3)</b>
</properties>

<build>
        <plugins>
            <plugin> <i class="conum" data-value="4"></i><b>(4)</b>
                <groupId>io.spring.javaformat</groupId>
                <artifactId>spring-javaformat-maven-plugin</artifactId>
            </plugin>
            <plugin> <i class="conum" data-value="5"></i><b>(5)</b>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
            </plugin>
        </plugins>

    <reporting>
        <plugins>
            <plugin> <i class="conum" data-value="5"></i><b>(5)</b>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-checkstyle-plugin</artifactId>
            </plugin>
        </plugins>
    </reporting>
</build></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>因Checkstyle错误而无法构建</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>因Checkstyle违规而无法构建</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>Checkstyle还分析测试源</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>添加Spring Java Format插件，该插件将重新格式化您的代码以通过大多数Checkstyle格式化规则</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>将Checkstyle插件添加到构建和报告阶段</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果您需要取消某些规则（例如，行长需要更长），那么在下面定义一个文件就足够了<code>${project.root}/src/checkstyle/checkstyle-suppressions.xml</code>你的压抑。例：</p>
</div>
<div class="listingblock">
<div class="title">projectRoot / src / checkstyle / checkstyle-suppresions.xml</div>
<div class="content">
<pre><?xml version="1.0"?>
<!DOCTYPE suppressions PUBLIC
        "-//Puppy Crawl//DTD Suppressions 1.1//EN"
        "https://www.puppycrawl.com/dtds/suppressions_1_1.dtd">
<suppressions>
    <suppress files=".*ConfigServerApplication\.java" checks="HideUtilityClassConstructor"/>
    <suppress files=".*ConfigClientWatch\.java" checks="LineLengthCheck"/>
</suppressions></pre>
</div>
</div>
<div class="paragraph">
<p>建议复制<code>${spring-cloud-build.rootFolder}/.editorconfig</code>和<code>${spring-cloud-build.rootFolder}/.springformat</code>到您的项目。这样，将应用一些默认格式设置规则。您可以通过运行以下脚本来这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ curl https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/.editorconfig -o .editorconfig
$ touch .springformat</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ide-setup-2"><a class="anchor" href="#ide-setup-2"></a> <a class="link" href="#ide-setup-2">20.4.5。IDE设置</a></h4>
<div class="sect4">
<h5 id="intellij-idea-2"><a class="anchor" href="#intellij-idea-2"></a> <a class="link" href="#intellij-idea-2">Intellij IDEA</a></h5>
<div class="paragraph">
<p>为了设置Intellij，您应该导入我们的编码约定，检查配置文件并设置checkstyle插件。在<a href="https://github.com/spring-cloud/spring-cloud-build/tree/master/spring-cloud-build-tools">Spring Cloud Build</a>项目中可以找到以下文件。</p>
</div>
<div class="listingblock">
<div class="title">spring-cloud-build-tools /</div>
<div class="content">
<pre>└── src
    ├── checkstyle
    │   └── checkstyle-suppressions.xml <i class="conum" data-value="3"></i><b>(3)</b>
    └── main
        └── resources
            ├── checkstyle-header.txt <i class="conum" data-value="2"></i><b>(2)</b>
            ├── checkstyle.xml <i class="conum" data-value="1"></i><b>(1)</b>
            └── intellij
                ├── Intellij_Project_Defaults.xml <i class="conum" data-value="4"></i><b>(4)</b>
                └── Intellij_Spring_Boot_Java_Conventions.xml <i class="conum" data-value="5"></i><b>(5)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>默认Checkstyle规则</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>文件头设置</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>默认禁止规则</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>适用于大多数Checkstyle规则的Intellij项目默认值</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i> <b>5</b></td>
<td>适用于大多数Checkstyle规则的Intellij的项目样式约定</td>
</tr>
</tbody></table>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-code-style.png" alt="代码风格">
</div>
<div class="title">图6。代码风格</div>
</div>
<div class="paragraph">
<p>去<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>Code style</code> 。在那里，单击旁边的图标<code>Scheme</code>部分。在那里，点击<code>Import Scheme</code>值并选择<code>Intellij IDEA code style XML</code>选项。导入<code>spring-cloud-build-tools/src/main/resources/intellij/Intellij_Spring_Boot_Java_Conventions.xml</code>文件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-inspections.png" alt="代码风格">
</div>
<div class="title">图7。检验概况</div>
</div>
<div class="paragraph">
<p>去<code>File</code> → <code>Settings</code> → <code>Editor</code> → <code>Inspections</code> 。在那里，单击旁边的图标<code>Profile</code>部分。在那里，点击<code>Import Profile</code>并导入<code>spring-cloud-build-tools/src/main/resources/intellij/Intellij_Project_Defaults.xml</code>文件。</p>
</div>
<div class="paragraph">
<div class="title">Checkstyle</div>
<p>要使Intellij与Checkstyle一起使用，您必须安装<code>Checkstyle</code>插入。建议也安装<code>Assertions2Assertj</code>自动转换JUnit断言</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/docs/src/main/asciidoc/images/intellij-checkstyle.png" alt="Checkstyle">
</div>
</div>
<div class="paragraph">
<p>去<code>File</code> → <code>Settings</code> → <code>Other settings</code> → <code>Checkstyle</code> 。那里点击<code>+</code>中的图标<code>Configuration file</code>部分。在这里，您必须定义应从何处选择checkstyle规则。在上图中，我们从克隆的Spring Cloud Build存储库中选择了规则。但是，您可以指向Spring Cloud Build的GitHub存储库（例如，对于<code>checkstyle.xml</code> ： <code><a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml" class="bare">raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle.xml</a></code> ）。我们需要提供以下变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>checkstyle.header.file</code> -请指向Spring Cloud Build的<code>spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</code>文件在您的克隆存储库中或通过<code><a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt" class="bare">raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/main/resources/checkstyle-header.txt</a></code>网址。</p>
</li>
<li>
<p><code>checkstyle.suppressions.file</code> -默认抑制。请把它指向Spring Cloud Build的， <code>spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</code>文件在您的克隆存储库中或通过<code><a href="https://raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml" class="bare">raw.githubusercontent.com/spring-cloud/spring-cloud-build/master/spring-cloud-build-tools/src/checkstyle/checkstyle-suppressions.xml</a></code>网址。</p>
</li>
<li>
<p><code>checkstyle.additional.suppressions.file</code> -此变量对应于本地项目中的抑制。例如，您正在从事<code>spring-cloud-contract</code> 。然后指向<code>project-root/src/checkstyle/checkstyle-suppressions.xml</code>夹。范例<code>spring-cloud-contract</code>将会： <code>/home/username/spring-cloud-contract/src/checkstyle/checkstyle-suppressions.xml</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">请记住设置<code>Scan Scope</code>至<code>All sources</code>因为我们将checkstyle规则应用于生产和测试源。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-stream-2"><a class="anchor" href="#spring-cloud-stream-2"></a> <a class="link" href="#spring-cloud-stream-2">21春季云流</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="a-brief-history-of-springs-data-integration-journey"><a class="anchor" href="#a-brief-history-of-springs-data-integration-journey"></a> <a class="link" href="#a-brief-history-of-springs-data-integration-journey">21.1。Spring数据集成之旅简史</a></h3>
<div class="paragraph">
<p>Spring的Data Integration之旅始于<a href="https://projects.spring.io/spring-integration/">Spring Integration</a> 。通过其编程模型，它为开发人员提供了一致的开发经验，以构建可以包含<a href="http://www.enterpriseintegrationpatterns.com/">企业集成模式</a>以与外部系统（例如数据库，消息代理等）连接的应用程序。</p>
</div>
<div class="paragraph">
<p>快进到云时代，微服务已在企业环境中变得突出。<a href="https://projects.spring.io/spring-boot/">Spring Boot</a>改变了开发人员构建应用程序的方式。借助Spring的编程模型和Spring Boot处理的运行时职责，开发独立的，生产级的基于Spring的微服务变得无缝。</p>
</div>
<div class="paragraph">
<p>为了将其扩展到数据集成工作负载，将Spring Integration和Spring Boot合并到一个新项目中。Spring Cloud Stream诞生了。</p>
</div>
<div class="paragraph">
<p>借助Spring Cloud Stream，开发人员可以：*隔离地构建，测试，迭代和部署以数据为中心的应用程序。*应用现代微服务架构模式，包括通过消息传递进行组合。*以事件为中心的思维将应用程序职责分离。事件可以表示及时发生的事件，下游消费者应用程序可以在不知道事件起源或生产者身份的情况下做出反应。*将业务逻辑移植到消息代理（例如RabbitMQ，Apache Kafka，Amazon Kinesis）上。通过使用Project Reactor的Flux和Kafka Streams API在基于通道的应用程序和基于非通道的应用程序绑定方案之间进行互操作，以支持无状态和有状态的计算。 *依靠框架对常见用例的自动内容类型支持。可以扩展到不同的数据转换类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="quick-start-5"><a class="anchor" href="#quick-start-5"></a> <a class="link" href="#quick-start-5">21.2。快速开始</a></h3>
<div class="paragraph">
<p>您可以按照以下三步指南在不到5分钟的时间内尝试使用Spring Cloud Stream，甚至无需跳入任何细节。</p>
</div>
<div class="paragraph">
<p>我们向您展示了如何创建一个Spring Cloud Stream应用程序，该应用程序接收来自您选择的消息传递中间件的消息（稍后会详细介绍），并将接收到的消息记录到控制台。我们称之为<code>LoggingConsumer</code> 。尽管不是很实用，但它很好地介绍了一些主要概念和抽象，使您更容易理解本用户指南的其余部分。</p>
</div>
<div class="paragraph">
<p>三个步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#spring-cloud-stream-preface-creating-sample-application">使用Spring Initializr创建示例应用程序</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-importing-project">将项目导入您的IDE</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-adding-message-handler">添加消息处理程序，构建并运行</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-creating-sample-application"><a class="anchor" href="#spring-cloud-stream-preface-creating-sample-application"></a> <a class="link" href="#spring-cloud-stream-preface-creating-sample-application">使用Spring Initializr创建示例应用程序</a></h5>
<div class="paragraph">
<p>首先，请访问<a href="https://start.spring.io">Spring Initializr</a> 。从那里，您可以生成我们的<code>LoggingConsumer</code>应用。为此：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在“ <strong>依赖关系”</strong>部分，开始输入<code>stream</code> 。当出现“云流”选项时，选择它。</p>
</li>
<li>
<p>开始输入“ kafka”或“兔子”。</p>
</li>
<li>
<p>选择“ Kafka”或“ RabbitMQ”。</p>
<div class="paragraph">
<p>基本上，您选择应用程序绑定到的消息传递中间件。我们建议您使用已经安装的一种，或者对安装和运行感到更舒适。另外，从“启动器”屏幕上可以看到，还有一些其他选项可以选择。例如，您可以选择Gradle作为构建工具，而不是Maven（默认设置）。</p>
</div>
</li>
<li>
<p>在<strong>工件</strong>字段中，输入“ logging-consumer”。</p>
<div class="paragraph">
<p><strong>Artifact</strong>字段的值成为应用程序名称。如果您选择RabbitMQ作为中间件，那么Spring Initializr现在应该如下所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/stream-initializr.png" alt="流初始化">
</div>
</div>
</li>
<li>
<p>单击<strong>生成项目</strong>按钮。</p>
<div class="paragraph">
<p>这样做会将生成的项目的压缩版本下载到硬盘上。</p>
</div>
</li>
<li>
<p>将文件解压缩到要用作项目目录的文件夹中。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="小费"></i>
</td>
<td class="content">我们鼓励您探索Spring Initializr中可用的许多可能性。它使您可以创建许多不同种类的Spring应用程序。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-importing-project"><a class="anchor" href="#spring-cloud-stream-preface-importing-project"></a> <a class="link" href="#spring-cloud-stream-preface-importing-project">将项目导入您的IDE</a></h5>
<div class="paragraph">
<p>现在，您可以将项目导入到IDE中。请记住，取决于IDE，您可能需要遵循特定的导入过程。例如，根据项目的生成方式（Maven或Gradle），您可能需要遵循特定的导入过程（例如，在Eclipse或STS中，您需要使用File→Import→Maven→Existing Maven Project）。</p>
</div>
<div class="paragraph">
<p>导入后，该项目必须没有任何类型的错误。也， <code>src/main/java</code>应该包含<code>com.example.loggingconsumer.LoggingConsumerApplication</code> 。</p>
</div>
<div class="paragraph">
<p>从技术上讲，此时，您可以运行应用程序的主类。它已经是一个有效的Spring Boot应用程序。但是，它没有任何作用，因此我们想添加一些代码。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-adding-message-handler"><a class="anchor" href="#spring-cloud-stream-preface-adding-message-handler"></a> <a class="link" href="#spring-cloud-stream-preface-adding-message-handler">添加消息处理程序，构建并运行</a></h5>
<div class="paragraph">
<p>修改<code>com.example.loggingconsumer.LoggingConsumerApplication</code>该类看起来如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class LoggingConsumerApplication {

    public static void main(String[] args) {
        SpringApplication.run(LoggingConsumerApplication.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void handle(Person person) {
        System.out.println("Received: " + person);
    }

    public static class Person {
        private String name;
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public String toString() {
            return this.name;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从前面的清单中可以看到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们已经启用<code>Sink</code>通过使用绑定（输入无输出） <code>@EnableBinding(Sink.class)</code> 。这样做会向框架发出信号，以启动对消息传递中间件的绑定，在该消息传递中间件中，它会自动创建绑定到消息传递中间件的目标（即队列，主题等）。 <code>Sink.INPUT</code>渠道。</p>
</li>
<li>
<p>我们添加了一个<code>handler</code>接收类型为传入消息的方法<code>Person</code> 。这样做可以使您看到框架的核心功能之一：它尝试自动将传入的消息有效负载转换为类型<code>Person</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在，您有了一个功能齐全的Spring Cloud Stream应用程序，该应用程序确实侦听消息。从这里开始，为简单起见，我们假设您在<a href="#spring-cloud-stream-preface-creating-sample-application">第一步中</a>选择RabbitMQ。假设您已安装并运行RabbitMQ，则可以通过运行它来启动应用程序<code>main</code> IDE中的方法。</p>
</div>
<div class="paragraph">
<p>您应该看到以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>    --- [ main] c.s.b.r.p.RabbitExchangeQueueProvisioner : declaring queue for inbound: input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg, bound to: input
    --- [ main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [localhost:5672]
    --- [ main] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory#2a3a299:0/SimpleConnection@66c83fc8. . .
    . . .
    --- [ main] o.s.i.a.i.AmqpInboundChannelAdapter      : started inbound.input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg
    . . .
    --- [ main] c.e.l.LoggingConsumerApplication         : Started LoggingConsumerApplication in 2.531 seconds (JVM running for 2.897)</code></pre>
</div>
</div>
<div class="paragraph">
<p>转到RabbitMQ管理控制台或任何其他RabbitMQ客户端并将消息发送至<code>input.anonymous.CbMIwdkJSBO1ZoPDOtHtCg</code> 。的<code>anonymous.CbMIwdkJSBO1ZoPDOtHtCg</code> part代表组名并生成，因此它在您的环境中必然是不同的。对于更可预测的内容，您可以通过设置<code>spring.cloud.stream.bindings.input.group=hello</code> （或您喜欢的任何名称）。</p>
</div>
<div class="paragraph">
<p>消息的内容应为的JSON表示形式<code>Person</code>类，如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{"name":"Sam Spade"}</pre>
</div>
</div>
<div class="paragraph">
<p>然后，在控制台中，您应该看到：</p>
</div>
<div class="paragraph">
<p><code>Received: Sam Spade</code></p>
</div>
<div class="paragraph">
<p>您还可以将应用程序生成并打包到启动jar中（通过使用<code>./mvnw clean install</code> ），然后使用来运行内置的JAR <code>java -jar</code>命令。</p>
</div>
<div class="paragraph">
<p>现在，您有了一个正在运行的（尽管非常基础）Spring Cloud Stream应用程序。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="whats-new-in-2-0"><a class="anchor" href="#whats-new-in-2-0"></a> <a class="link" href="#whats-new-in-2-0">21.3。2.0中有什么新功能？</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream引入了许多新功能，增强功能和更改。以下各节概述了最值得注意的部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-preface-new-features">新功能和组件</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-notable-enhancements">显着增强</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-new-features"><a class="anchor" href="#spring-cloud-stream-preface-new-features"></a> <a class="link" href="#spring-cloud-stream-preface-new-features">21.3.1。新功能和组件</a></h4>
<div class="ulist">
<ul>
<li>
<p><strong>轮询使用者</strong> ：引入轮询使用者，使应用程序可以控制消息处理速率。有关更多详细信息，请参见“ <a href="#spring-cloud-streams-overview-using-polled-consumers">使用轮询的使用者</a> ”。您也可以阅读<a href="https://spring.io/blog/2018/02/27/spring-cloud-stream-2-0-polled-consumers">此博客文章</a>以获取更多详细信息。</p>
</li>
<li>
<p><strong>千分尺支持</strong> ：度量标准已切换为使用<a href="https://micrometer.io/">千分尺</a> 。
<code>MeterRegistry</code>还以Bean的形式提供，以便自定义应用程序可以将其自动连接以捕获自定义指标。有关更多详细信息，请参见“ <a href="#spring-cloud-stream-overview-metrics-emitter">度量标准发射器</a> ”。</p>
</li>
<li>
<p><strong>新的执行器绑定控件</strong> ：新的执行器绑定控件使您可以可视化并控制绑定的生命周期。有关更多详细信息，请参见<a href="#binding-visualization-and-control">绑定可视化和控件</a> 。</p>
</li>
<li>
<p><strong>可配置的RetryTemplate</strong> ：除了提供要配置的属性外<code>RetryTemplate</code> ，我们现在让您提供自己的模板，有效地覆盖框架提供的模板。要使用它，请将其配置为<code>@Bean</code>在您的应用程序中。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-notable-enhancements"><a class="anchor" href="#spring-cloud-stream-preface-notable-enhancements"></a> <a class="link" href="#spring-cloud-stream-preface-notable-enhancements">21.3.2。显着增强</a></h4>
<div class="paragraph">
<p>此版本包括以下显着增强：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-preface-actuator-web-dependencies">执行器和Web依赖关系现在都是可选的</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-content-type-negotiation-improvements">内容类型协商的改进</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-notable-deprecations">显着的弃用</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-actuator-web-dependencies"><a class="anchor" href="#spring-cloud-stream-preface-actuator-web-dependencies"></a> <a class="link" href="#spring-cloud-stream-preface-actuator-web-dependencies">执行器和Web依赖关系现在都是可选的</a></h5>
<div class="paragraph">
<p>如果既不需要执行器也不需要Web依赖项，此更改将减少已部署应用程序的占用空间。还可以通过手动添加以下依赖项之一，在反应式和常规Web范例之间进行切换。</p>
</div>
<div class="paragraph">
<p>以下清单显示了如何添加常规Web框架：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下清单显示了如何添加反应式Web框架：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>下表显示了如何添加执行器依赖性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-content-type-negotiation-improvements"><a class="anchor" href="#spring-cloud-stream-preface-content-type-negotiation-improvements"></a> <a class="link" href="#spring-cloud-stream-preface-content-type-negotiation-improvements">内容类型协商的改进</a></h5>
<div class="paragraph">
<p>Verion 2.0的核心主题之一是围绕内容类型协商和消息转换的改进（在一致性和性能方面）。以下摘要概述了该领域的显着变化和改进。有关更多详细信息，请参见“ <a href="#content-type-management">内容类型协商</a> ”部分。此外， <a href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation">此博客文章还</a>包含更多详细信息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>现在，所有邮件转换<strong>仅</strong>由<code>MessageConverter</code>对象。</p>
</li>
<li>
<p>我们介绍了<code>@StreamMessageConverter</code>提供自定义的注释<code>MessageConverter</code>对象。</p>
</li>
<li>
<p>我们引入了默认<code>Content Type</code>如<code>application/json</code> ，在迁移1.3应用程序或以混合模式运行（即1.3生产者→2.0消费者）时需要考虑到这一点。</p>
</li>
<li>
<p>带有文本有效载荷和<code>contentType</code>的<code>text/…​</code>要么<code>…​/json</code>不再转换为<code>Message<String></code>对于提供的参数类型<code>MessageHandler</code>无法确定（即， <code>public void handle(Message<?> message)</code>要么<code>public void handle(Object payload)</code> ）。此外，强参数类型可能不足以正确转换消息，因此<code>contentType</code>标头可能被某些人用作补充<code>MessageConverters</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-preface-notable-deprecations"><a class="anchor" href="#spring-cloud-stream-preface-notable-deprecations"></a> <a class="link" href="#spring-cloud-stream-preface-notable-deprecations">21.3.3。显着的弃用</a></h4>
<div class="paragraph">
<p>从2.0版开始，不推荐使用以下项目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-preface-deprecation-java-serialization">Java序列化（Java本机和Kryo）</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-preface-deprecation-classes-methods">不推荐使用的类和方法</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-deprecation-java-serialization"><a class="anchor" href="#spring-cloud-stream-preface-deprecation-java-serialization"></a> <a class="link" href="#spring-cloud-stream-preface-deprecation-java-serialization">Java序列化（Java本机和Kryo）</a></h5>
<div class="paragraph">
<p><code>JavaSerializationMessageConverter</code>和<code>KryoMessageConverter</code>暂时保留。但是，我们计划将来将它们移出核心软件包和支持。弃用此文件的主要原因是要标记基于类型，特定于语言的序列化可能在分布式环境中引起的问题，在该环境中，生产者和使用者可能依赖于不同的JVM版本或具有不同版本的支持库（即Kryo）。我们还想提请注意这样一个事实，即消费者和生产者甚至可能都不基于Java，因此多语言风格的序列化（即JSON）更适合。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-preface-deprecation-classes-methods"><a class="anchor" href="#spring-cloud-stream-preface-deprecation-classes-methods"></a> <a class="link" href="#spring-cloud-stream-preface-deprecation-classes-methods">不推荐使用的类和方法</a></h5>
<div class="paragraph">
<p>以下是显着弃用的快速摘要。有关更多详细信息，请参见相应的{spring-cloud-stream-javadoc-current} [javadoc]。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SharedChannelRegistry</code> 。使用<code>SharedBindingTargetRegistry</code> 。</p>
</li>
<li>
<p><code>Bindings</code> 。符合条件的Bean已通过其类型进行了唯一标识-例如， <code>Source</code> ， <code>Processor</code>或自定义绑定：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>public interface Sample {
    String OUTPUT = "sampleOutput";

    @Output(Sample.OUTPUT)
    MessageChannel output();
}</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HeaderMode.raw</code> 。使用<code>none</code> ， <code>headers</code>要么<code>embeddedHeaders</code></p>
</li>
<li>
<p><code>ProducerProperties.partitionKeyExtractorClass</code>有利于<code>partitionKeyExtractorName</code>和<code>ProducerProperties.partitionSelectorClass</code>有利于<code>partitionSelectorName</code> 。这项更改确保了两个组件都由Spring配置和管理，并且以对Spring友好的方式被引用。</p>
</li>
<li>
<p><code>BinderAwareRouterBeanPostProcessor</code> 。虽然组件仍然存在，但它不再是<code>BeanPostProcessor</code>并将在将来重命名。</p>
</li>
<li>
<p><code>BinderProperties.setEnvironment(Properties environment)</code> 。使用<code>BinderProperties.setEnvironment(Map<String, Object> environment)</code> 。</p>
</li>
</ul>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>本节将详细介绍如何使用Spring Cloud Stream。它涵盖了诸如创建和运行流应用程序之类的主题。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-introducing"><a class="anchor" href="#spring-cloud-stream-overview-introducing"></a> <a class="link" href="#spring-cloud-stream-overview-introducing">21.4。介绍Spring Cloud Stream</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream是用于构建消息驱动的微服务应用程序的框架。Spring Cloud Stream基于Spring Boot来创建独立的生产级Spring应用程序，并使用Spring Integration提供与消息代理的连接。它提供了来自多家供应商的中间件的合理配置，并介绍了持久性发布-订阅语义，使用者组和分区的概念。</p>
</div>
<div class="paragraph">
<p>您可以添加<code>@EnableBinding</code>批注到您的应用程序以立即连接到消息代理，您可以添加<code>@StreamListener</code>一种使它接收事件以进行流处理的方法。以下示例显示了接收外部消息的接收器应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class VoteRecordingSinkApplication {

  public static void main(String[] args) {
    SpringApplication.run(VoteRecordingSinkApplication.class, args);
  }

  @StreamListener(Sink.INPUT)
  public void processVote(Vote vote) {
      votingService.recordVote(vote);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@EnableBinding</code>注释将一个或多个接口作为参数（在这种情况下，参数为单个<code>Sink</code>接口）。接口声明输入和输出通道。Spring Cloud Stream提供了<code>Source</code> ， <code>Sink</code>和<code>Processor</code>接口。您也可以定义自己的接口。</p>
</div>
<div class="paragraph">
<p>以下清单显示了<code>Sink</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Sink {
  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>@Input</code>批注标识一个输入通道，接收到的消息通过该输入通道进入应用程序。的<code>@Output</code>批注标识一个输出通道，已发布的消息通过该输出通道离开应用程序。的<code>@Input</code>和<code>@Output</code>批注可以使用频道名称作为参数。如果未提供名称，则使用带注释的方法的名称。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream为您创建接口的实现。您可以通过自动装配在应用程序中使用它，如以下示例所示（来自测试用例）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = VoteRecordingSinkApplication.class)
@WebAppConfiguration
@DirtiesContext
public class StreamApplicationTests {

  @Autowired
  private Sink sink;

  @Test
  public void contextLoads() {
    assertNotNull(this.sink.input());
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="main-concepts"><a class="anchor" href="#main-concepts"></a> <a class="link" href="#main-concepts">21.5。主要概念</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream提供了许多抽象和原语，简化了消息驱动的微服务应用程序的编写。本节概述了以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#spring-cloud-stream-overview-application-model">Spring Cloud Stream的应用程序模型</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-overview-binder-abstraction">活页夹抽象</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-overview-persistent-publish-subscribe-support">持久的发布-订阅支持</a></p>
</li>
<li>
<p><a href="#consumer-groups">消费者群体支持</a></p>
</li>
<li>
<p><a href="#partitioning">分区支持</a></p>
</li>
<li>
<p><a href="#spring-cloud-stream-overview-binder-api">可插拔的Binder SPI</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-application-model"><a class="anchor" href="#spring-cloud-stream-overview-application-model"></a> <a class="link" href="#spring-cloud-stream-overview-application-model">21.5.1。应用模式</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream应用程序由与中间件无关的核心组成。该应用程序通过Spring Cloud Stream注入的输入和输出通道与外界进行通信。通道通过特定于中间件的Binder实现连接到外部代理。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/SCSt-with-binder.png" alt="带粘合剂的SCSt" width="800">
</div>
<div class="title">图8。Spring Cloud Stream应用程序</div>
</div>
<div class="sect4">
<h5 id="fat-jar"><a class="anchor" href="#fat-jar"></a> <a class="link" href="#fat-jar">胖子</a></h5>
<div class="paragraph">
<p>可以从您的IDE以独立模式运行Spring Cloud Stream应用程序以进行测试。要在生产中运行Spring Cloud Stream应用程序，您可以使用为Maven或Gradle提供的标准Spring Boot工具来创建可执行（或“胖”）JAR。有关更多详细信息，请参见《 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto-build.html#howto-create-an-executable-jar-with-maven">Spring Boot参考指南》</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-binder-abstraction"><a class="anchor" href="#spring-cloud-stream-overview-binder-abstraction"></a> <a class="link" href="#spring-cloud-stream-overview-binder-abstraction">21.5.2。活页夹抽象</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream为<a href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka">Kafka</a>和<a href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit">Rabbit MQ</a>提供了Binder实现。 Spring Cloud Stream还包含一个<a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java">TestSupportBinder</a> ，该通道使通道保持<a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java">不变</a> ，以便测试可以直接与通道交互并可靠地断言所接收的内容。您还可以使用可扩展的API编写自己的Binder。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream使用Spring Boot进行配置，而Binder抽象使Spring Cloud Stream应用程序可以灵活地连接到中间件。例如，部署者可以在运行时动态选择通道连接到的目的地（例如Kafka主题或RabbitMQ交换）。可以通过外部配置属性以及Spring Boot支持的任何形式（包括应用程序参数，环境变量和<code>application.yml</code>要么<code>application.properties</code>文件）。在<a href="#spring-cloud-stream-overview-introducing">介绍Spring Cloud Stream</a>部分的接收器示例中，设置<code>spring.cloud.stream.bindings.input.destination</code>应用属性<code>raw-sensor-data</code>使它从<code>raw-sensor-data</code> Kafka主题或绑定到队列<code>raw-sensor-data</code> RabbitMQ交换。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream自动检测并使用在类路径上找到的绑定器。您可以使用具有相同代码的不同类型的中间件。为此，在构建时包括一个不同的活页夹。对于更复杂的用例，您还可以在应用程序中打包多个活页夹，并让它在运行时选择活页夹（甚至为不同的通道使用不同的活页夹）。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-persistent-publish-subscribe-support"><a class="anchor" href="#spring-cloud-stream-overview-persistent-publish-subscribe-support"></a> <a class="link" href="#spring-cloud-stream-overview-persistent-publish-subscribe-support">21.5.3。持久的发布-订阅支持</a></h4>
<div class="paragraph">
<p>应用程序之间的通信遵循发布-订阅模型，其中数据通过共享主题进行广播。在下图中可以看到，该图显示了一组交互的Spring Cloud Stream应用程序的典型部署。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/SCSt-sensors.png" alt="SCSt传感器" width="800">
</div>
<div class="title">图9。Spring Cloud Stream发布-订阅</div>
</div>
<div class="paragraph">
<p>传感器报告给HTTP端点的数据将发送到名为<code>raw-sensor-data</code> 。从目的地开始，它由计算时间窗平均值的微服务应用程序和另一个将原始数据摄取到HDFS（Hadoop分布式文件系统）的微服务应用程序独立处理。为了处理数据，两个应用程序都在运行时将主题声明为其输入。</p>
</div>
<div class="paragraph">
<p>发布-订阅通信模型降低了生产者和使用者的复杂性，并允许在不中断现有流程的情况下将新应用程序添加到拓扑中。例如，在平均计算应用程序的下游，您可以添加一个计算最高温度值以进行显示和监视的应用程序。然后，您可以添加另一个解释相同平均值流以进行故障检测的应用程序。通过共享主题而不是点对点队列进行所有通信可以减少微服务之间的耦合。</p>
</div>
<div class="paragraph">
<p>尽管发布-订阅消息传递的概念并不新鲜，但是Spring Cloud Stream采取了额外的步骤，使其成为其应用程序模型的明智选择。通过使用本机中间件支持，Spring Cloud Stream还简化了跨不同平台的发布-订阅模型的使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="consumer-groups"><a class="anchor" href="#consumer-groups"></a> <a class="link" href="#consumer-groups">21.5.4。消费群体</a></h4>
<div class="paragraph">
<p>尽管发布-订阅模型使通过共享主题轻松连接应用程序变得很重要，但是通过创建给定应用程序的多个实例进行扩展的能力同样重要。这样做时，会将应用程序的不同实例置于竞争的消费者关系中，在该消费者关系中，只有一个实例可以处理给定消息。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream通过消费者群体的概念对这种行为进行建模。（Spring Cloud Stream用户组与Kafka用户组相似并受其启发。）每个消费者绑定都可以使用<code>spring.cloud.stream.bindings.<channelName>.group</code>属性以指定组名。对于下图所示的消费者，此属性将设置为<code>spring.cloud.stream.bindings.<channelName>.group=hdfsWrite</code>要么<code>spring.cloud.stream.bindings.<channelName>.group=average</code> 。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/SCSt-groups.png" alt="SCSt小组" width="800">
</div>
<div class="title">图10。Spring Cloud Stream消费群</div>
</div>
<div class="paragraph">
<p>订阅给定目标的所有组都将收到已发布数据的副本，但是每个组中只有一个成员从该目标接收给定消息。默认情况下，当未指定组时，Spring Cloud Stream会将应用程序分配给与所有其他使用者组具有发布-订阅关系的匿名且独立的单成员使用者组。</p>
</div>
</div>
<div class="sect3">
<h4 id="consumer-types"><a class="anchor" href="#consumer-types"></a> <a class="link" href="#consumer-types">21.5.5。消费者类型</a></h4>
<div class="paragraph">
<p>支持两种类型的使用者：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消息驱动（有时称为异步）</p>
</li>
<li>
<p>轮询（有时称为同步）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在2.0版之前，仅支持异步使用者。消息一旦可用，就会被传递，并且有线程可以处理它。</p>
</div>
<div class="paragraph">
<p>当您希望控制消息的处理速率时，可能需要使用同步使用者。</p>
</div>
<div class="sect4">
<h5 id="durability"><a class="anchor" href="#durability"></a> <a class="link" href="#durability">耐用性</a></h5>
<div class="paragraph">
<p>与Spring Cloud Stream公认的应用程序模型一致，消费者组订阅是持久的。也就是说，活页夹实现可确保组订阅是持久的，并且一旦创建了至少一个组订阅，该组就可以接收消息，即使消息是在组中所有应用程序停止时发送的也是如此。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>匿名订阅本质上是非持久的。对于某些绑定器实现（例如RabbitMQ），可能具有非持久的组订阅。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常，在将应用程序绑定到给定目标时，最好始终指定使用者组。扩展Spring Cloud Stream应用程序时，必须为其每个输入绑定指定使用者组。这样做可以防止应用程序的实例接收重复的消息（除非需要这种行为，这是不寻常的）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="partitioning"><a class="anchor" href="#partitioning"></a> <a class="link" href="#partitioning">21.5.6。分区支持</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream支持在给定应用程序的多个实例之间对数据进行分区。在分区方案中，物理通信介质（例如代理主题）被视为结构化为多个分区。一个或多个生产者应用程序实例将数据发送到多个消费者应用程序实例，并确保由共同特征标识的数据由同一消费者实例处理。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream提供了用于以统一方式实现分区处理用例的通用抽象。因此，无论代理本身是自然分区（例如，Kafka）还是非自然分区（例如，RabbitMQ），都可以使用分区。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/SCSt-partitioning.png" alt="SCSt分区" width="800">
</div>
<div class="title">图11。Spring Cloud Stream分区</div>
</div>
<div class="paragraph">
<p>分区是有状态处理中的关键概念，对于确保所有相关数据都一起处理，分区是至关重要的（出于性能或一致性方面的考虑）。例如，在带时间窗的平均计算示例中，重要的是，来自任何给定传感器的所有测量都应由同一应用实例处理。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要设置分区处理方案，必须同时配置数据产生端和数据消耗端。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="programming-model-2"><a class="anchor" href="#programming-model-2"></a> <a class="link" href="#programming-model-2">21.6。程式设计模型</a></h3>
<div class="paragraph">
<p>要了解编程模型，您应该熟悉以下核心概念：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>目标绑定器：</strong>负责与外部消息传递系统集成的组件。</p>
</li>
<li>
<p><strong>目标绑定：</strong>外部消息传递系统和应用程序之间提供的桥梁（消息的<em>生产者</em>和<em>消费者</em> ）（由<strong>目标绑定</strong>程序创建）。</p>
</li>
<li>
<p><strong>消息：</strong>生产者和消费者使用的规范数据结构，用于与目标绑定程序（以及通过外部消息传递系统进行的其他应用程序）进行通信。</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/SCSt-overview.png" alt="SCSt概述" width="800">
</div>
</div>
<div class="sect3">
<h4 id="destination-binders"><a class="anchor" href="#destination-binders"></a> <a class="link" href="#destination-binders">21.6.1。目标绑定</a></h4>
<div class="paragraph">
<p>Destination Binders是Spring Cloud Stream的扩展组件，负责提供必要的配置和实现以促进与外部消息传递系统的集成。这种集成负责连接性，委派权以及与生产者和消费者之间的消息的路由，数据类型转换，用户代码的调用等等。</p>
</div>
<div class="paragraph">
<p>粘合剂承担着许多样板工作，否则这些工作就落在了您的肩膀上。但是，要实现这一点，活页夹仍然需要用户提供的一些帮助，包括一些简单但必需的说明，这些说明通常以某种类型的配置形式出现。</p>
</div>
<div class="paragraph">
<p>尽管讨论所有可用的绑定器和绑定配置选项（本手册的其余部分全面介绍它们）不在本节的讨论范围之内，但<em>目标绑定</em>确实需要特别注意。下一节将详细讨论。</p>
</div>
</div>
<div class="sect3">
<h4 id="destination-bindings"><a class="anchor" href="#destination-bindings"></a> <a class="link" href="#destination-bindings">21.6.2。目标绑定</a></h4>
<div class="paragraph">
<p>如前所述， <em>目标绑定</em>提供了外部消息传递系统与应用程序提供的<em>生产者</em>和<em>消费者</em>之间的桥梁。</p>
</div>
<div class="paragraph">
<p>将@EnableBinding批注应用于应用程序的配置类之一可定义目标绑定。的<code>@EnableBinding</code>注释本身是使用元注释的<code>@Configuration</code>并触发Spring Cloud Stream基础架构的配置。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个已完全配置且可以正常运行的Spring Cloud Stream应用程序，该应用程序从以下位置接收消息的有效负载： <code>INPUT</code>作为目的地<code>String</code>类型（请参阅“ <a href="#content-type-management">内容类型协商”</a>部分），将其记录到控制台并将其发送到<code>OUTPUT</code>转换为大写字母后的目标。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Processor.class)
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @StreamListener(Processor.INPUT)
    @SendTo(Processor.OUTPUT)
    public String handle(String value) {
        System.out.println("Received: " + value);
        return value.toUpperCase();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见<code>@EnableBinding</code>批注可以将一个或多个接口类作为参数。这些参数称为<em>绑定</em> ，它们包含表示<em>可绑定组件的</em>方法。这些组件通常是消息通道（请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-messaging.html">Spring Messaging</a> ），用于基于通道的活页夹（例如Rabbit，Kafka和其他）。但是，其他类型的绑定可以为相应技术的本机功能提供支持。例如，Kafka Streams活页夹（以前称为KStream）允许直接绑定到Kafka Streams（有关更多详细信息，请参见<a href="https://docs.spring.io/autorepo/docs/spring-cloud-stream-binder-kafka-docs/1.1.0.M1/reference/htmlsingle/">Kafka Streams</a> ）。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream已经为典型的消息交换合同提供了<em>绑定</em>接口，其中包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>水槽：</strong>识别由提供来自该消息所消耗的目的地为所述消息用户的合同。</p>
</li>
<li>
<p><strong>源：</strong>通过提供将生成的消息发送到的目的地来标识消息生产者的合同。</p>
</li>
<li>
<p><strong>处理器：</strong>通过公开两个允许使用和产生消息的目的地，来封装接收器和源协定。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Sink {

  String INPUT = "input";

  @Input(Sink.INPUT)
  SubscribableChannel input();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Source {

  String OUTPUT = "output";

  @Output(Source.OUTPUT)
  MessageChannel output();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Processor extends Source, Sink {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管前面的示例满足了大多数情况，但是您也可以通过定义自己的绑定接口和使用来定义自己的合同<code>@Input</code>和<code>@Output</code>注释以标识实际的<em>可绑定组件</em> 。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Barista {

    @Input
    SubscribableChannel orders();

    @Output
    MessageChannel hotDrinks();

    @Output
    MessageChannel coldDrinks();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用上例中显示的接口作为参数<code>@EnableBinding</code>触发三个绑定通道的创建<code>orders</code> ， <code>hotDrinks</code>和<code>coldDrinks</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>您可以根据需要提供任意数量的绑定接口，作为<code>@EnableBinding</code>注释，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(value = { Orders.class, Payment.class })</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Spring Cloud Stream中，可绑定<code>MessageChannel</code>组件是Spring Messaging <code>MessageChannel</code> （对于出站）及其扩展名， <code>SubscribableChannel</code> ，（用于入站）。</p>
</div>
<div class="paragraph">
<p><strong>可轮询的目标绑定</strong></p>
</div>
<div class="paragraph">
<p>尽管前面描述的绑定支持基于事件的消息使用，但是有时您需要更多控制，例如使用率。</p>
</div>
<div class="paragraph">
<p>从2.0版开始，您现在可以绑定可轮询的使用者：</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何绑定可轮询的使用者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface PolledBarista {

    @Input
    PollableMessageSource orders();
    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>PollableMessageSource</code>绑定到<code>orders</code> “渠道”。有关更多详细信息，请参见<a href="#spring-cloud-streams-overview-using-polled-consumers">使用轮询的使用者</a> 。</p>
</div>
<div class="paragraph">
<p><strong>自定义频道名称</strong></p>
</div>
<div class="paragraph">
<p>通过使用<code>@Input</code>和<code>@Output</code>注释，您可以为频道指定自定义的频道名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Barista {
    @Input("inboundOrders")
    SubscribableChannel orders();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，创建的绑定通道被命名为<code>inboundOrders</code> 。</p>
</div>
<div class="paragraph">
<p>通常，您无需直接访问单个通道或绑定（然后通过<code>@EnableBinding</code>注解）。但是，您有时可能会遇到诸如测试或其他极端情况的情况。</p>
</div>
<div class="paragraph">
<p>除了为每个绑定生成通道并将其注册为Spring Bean之外，Spring Cloud Stream还为每个绑定接口生成一个实现该接口的bean。这意味着您可以通过在应用程序中自动进行接线来访问表示绑定或各个通道的接口，如以下两个示例所示：</p>
</div>
<div class="paragraph">
<p><em>自动接线绑定界面</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowire
private Source source

public void sayHello(String name) {
    source.output().send(MessageBuilder.withPayload(name).build());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>自动连线个别频道</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowire
private MessageChannel output;

public void sayHello(String name) {
    output.send(MessageBuilder.withPayload(name).build());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以使用标准的Spring <code>@Qualifier</code>注释，用于自定义渠道名称或需要特别命名的渠道的多渠道方案。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何以这种方式使用@Qualifier批注：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Autowire
@Qualifier("myChannel")
private MessageChannel output;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-producing-consuming-messages"><a class="anchor" href="#spring-cloud-stream-overview-producing-consuming-messages"></a> <a class="link" href="#spring-cloud-stream-overview-producing-consuming-messages">21.6.3。生产和消费信息</a></h4>
<div class="paragraph">
<p>您可以使用Spring Integration批注或Spring Cloud Stream本机批注编写Spring Cloud Stream应用程序。</p>
</div>
<div class="sect4">
<h5 id="spring-integration-support"><a class="anchor" href="#spring-integration-support"></a> <a class="link" href="#spring-integration-support">Spring集成支持</a></h5>
<div class="paragraph">
<p>Spring Cloud Stream建立在<a href="http://www.enterpriseintegrationpatterns.com/">Enterprise Integration Patterns</a>定义的概念和模式的基础上，并依赖于其内部实现，该内部实现依赖于Spring项目组合中已建立且流行的Enterprise Integration Patterns实现： <a href="https://projects.spring.io/spring-integration/">Spring Integration</a>框架。</p>
</div>
<div class="paragraph">
<p>因此，它自然支持Spring Integration已经建立的基础，语义和配置选项。</p>
</div>
<div class="paragraph">
<p>例如，您可以附加一个<code>Source</code>到一个<code>MessageSource</code>并使用熟悉的<code>@InboundChannelAdapter</code>注释，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Source.class)
public class TimerSource {

  @Bean
  @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = "10", maxMessagesPerPoll = "1"))
  public MessageSource<String> timerMessageSource() {
    return () -> new GenericMessage<>("Hello Spring Cloud Stream");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，可以在提供<em>处理器</em>绑定协定的消息处理程序方法的实现时，使用@Transformer或@ServiceActivator，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Processor.class)
public class TransformProcessor {
  @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
  public Object transform(String message) {
    return message.toUpperCase();
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">尽管这可能会略过一些，但重要的是要了解，当您使用<code>@StreamListener</code>注解，使用发布-订阅模型。每种方法都带有注释<code>@StreamListener</code>收到自己的消息副本，每个消息都有自己的使用者组。但是，如果您通过使用Spring Integration批注（例如， <code>@Aggregator</code> ， <code>@Transformer</code> ， 要么<code>@ServiceActivator</code> ），则它们在竞争模型中消费。没有为每个订阅创建单独的消费者组。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="using-streamlistener-annotation"><a class="anchor" href="#using-streamlistener-annotation"></a> <a class="link" href="#using-streamlistener-annotation">使用@StreamListener注释</a></h5>
<div class="paragraph">
<p>作为对其Spring Integration支持的补充，Spring Cloud Stream提供了自己的<code>@StreamListener</code>注释，其模仿其他Spring Messaging注释（ <code>@MessageMapping</code> ， <code>@JmsListener</code> ， <code>@RabbitListener</code> ，以及其他），并提供便利，例如基于内容的路由等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Sink.class)
public class VoteHandler {

  @Autowired
  VotingService votingService;

  @StreamListener(Sink.INPUT)
  public void handle(Vote vote) {
    votingService.record(vote);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他Spring Messaging方法一样，方法参数可以用注释<code>@Payload</code> ， <code>@Headers</code>和<code>@Header</code> 。</p>
</div>
<div class="paragraph">
<p>对于返回数据的方法，必须使用<code>@SendTo</code>注释，用于指定方法返回的数据的输出绑定目标，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Processor.class)
public class TransformProcessor {

  @Autowired
  VotingService votingService;

  @StreamListener(Processor.INPUT)
  @SendTo(Processor.OUTPUT)
  public VoteResult handle(Vote vote) {
    return votingService.record(vote);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-streamlistener-for-content-based-routing"><a class="anchor" href="#using-streamlistener-for-content-based-routing"></a> <a class="link" href="#using-streamlistener-for-content-based-routing">使用@StreamListener进行基于内容的路由</a></h5>
<div class="paragraph">
<p>Spring Cloud Stream支持将消息调度到带有注释的多个处理程序方法<code>@StreamListener</code>根据条件。</p>
</div>
<div class="paragraph">
<p>为了有资格支持条件分派，一种方法必须满足以下条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它不能返回值。</p>
</li>
<li>
<p>它必须是单独的消息处理方法（不支持反应性API方法）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该条件由SpEL表达式在<code>condition</code>注释的参数，并为每条消息进行评估。所有与条件匹配的处理程序都在同一线程中调用，并且不必假设调用的顺序。</p>
</div>
<div class="paragraph">
<p>在以下示例中<code>@StreamListener</code>在具有分派条件的情况下，所有带有标头的消息<code>type</code>具有价值<code>bogey</code>派遣到<code>receiveBogey</code>方法，以及所有带有标头的消息<code>type</code>具有价值<code>bacall</code>派遣到<code>receiveBacall</code>方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class TestPojoWithAnnotatedArguments {

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='bogey'")
    public void receiveBogey(@Payload BogeyPojo bogeyPojo) {
       // handle the message
    }

    @StreamListener(target = Sink.INPUT, condition = "headers['type']=='bacall'")
    public void receiveBacall(@Payload BacallPojo bacallPojo) {
       // handle the message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>内容上下文中的内容类型协商<code>condition</code></strong></p>
</div>
<div class="paragraph">
<p>重要的是要了解使用基于内容的路由背后的一些机制<code>condition</code>的论点<code>@StreamListener</code> ，尤其是在整个消息类型的上下文中。如果您在继续之前熟悉<a href="#content-type-management">内容类型协商</a> ，也可能会有所帮助。</p>
</div>
<div class="paragraph">
<p>请考虑以下情形：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Sink.class)
@EnableAutoConfiguration
public static class CatsAndDogs {

    @StreamListener(target = Sink.INPUT, condition = "payload.class.simpleName=='Dog'")
    public void bark(Dog dog) {
       // handle the message
    }

    @StreamListener(target = Sink.INPUT, condition = "payload.class.simpleName=='Cat'")
    public void purr(Cat cat) {
       // handle the message
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码是完全有效的。它可以毫无问题地进行编译和部署，但是永远不会产生您期望的结果。</p>
</div>
<div class="paragraph">
<p>这是因为您正在测试的东西在您期望的状态下尚不存在。这是因为消息的有效负载尚未从有线格式转换为（ <code>byte[]</code> ）为所需的类型。换句话说，它还没有经过<a href="#content-type-management">Content Type Negotiation</a>中描述的类型转换过程。</p>
</div>
<div class="paragraph">
<p>因此，除非您使用SPeL表达式来评估原始数据（例如，字节数组中第一个字节的值），否则请使用基于消息标头的表达式（例如<code>condition = "headers['type']=='dog'"</code> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">目前，通过<code>@StreamListener</code>仅基于通道的绑定器（不支持反应式编程）支持条件。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="_spring_cloud_function"><a class="anchor" href="#_spring_cloud_function"></a> <a class="link" href="#_spring_cloud_function">Spring Cloud功能支持</a></h5>
<div class="paragraph">
<p>从Spring Cloud Stream v2.1开始，用于定义<em>流处理程序</em>和<em>源的</em>另一种选择是使用对<a href="https://cloud.spring.io/spring-cloud-function/">Spring Cloud Function的</a>内置支持，其中可以将它们表示为类型的Bean <code>java.util.function.[Supplier/Function/Consumer]</code> 。</p>
</div>
<div class="paragraph">
<p>要指定哪个功能bean绑定到绑定公开的外部目标，您必须提供<code>spring.cloud.stream.function.definition</code>属性。</p>
</div>
<div class="paragraph">
<p>这是Processor应用程序将消息处理程序公开为的示例<code>java.util.function.Function</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Processor.class)
public class MyFunctionBootApp {

    public static void main(String[] args) {
        SpringApplication.run(MyFunctionBootApp.class, "--spring.cloud.stream.function.definition=toUpperCase");
    }

    @Bean
    public Function<String, String> toUpperCase() {
        return s -> s.toUpperCase();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面，我们只定义了一个类型为的bean <code>java.util.function.Function</code>调用<em>toUpperCase</em>并将其标识为要用作消息处理程序的bean，其“输入”和“输出”必须绑定到Processor绑定公开的外部目标。</p>
</div>
<div class="paragraph">
<p>以下是支持源，处理器和接收器的简单功能应用程序的示例。</p>
</div>
<div class="paragraph">
<p>这是定义为<code>java.util.function.Supplier</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Source.class)
public static class SourceFromSupplier {
    public static void main(String[] args) {
        SpringApplication.run(SourceFromSupplier.class, "--spring.cloud.stream.function.definition=date");
    }
    @Bean
    public Supplier<Date> date() {
        return () -> new Date(12345L);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是定义为<code>java.util.function.Function</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Processor.class)
public static class ProcessorFromFunction {
    public static void main(String[] args) {
        SpringApplication.run(ProcessorFromFunction.class, "--spring.cloud.stream.function.definition=toUpperCase");
    }
    @Bean
    public Function<String, String> toUpperCase() {
        return s -> s.toUpperCase();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个定义为<code>java.util.function.Consumer</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableAutoConfiguration
@EnableBinding(Sink.class)
public static class SinkFromConsumer {
    public static void main(String[] args) {
        SpringApplication.run(SinkFromConsumer.class, "--spring.cloud.stream.function.definition=sink");
    }
    @Bean
    public Consumer<String> sink() {
        return System.out::println;
    }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="functional-composition"><a class="anchor" href="#functional-composition"></a> <a class="link" href="#functional-composition">功能组成</a></h6>
<div class="paragraph">
<p>使用此编程模型，您还可以从功能组合中受益，在该功能组合中，您可以从一组简单的函数动态组成复杂的处理程序。作为示例，让我们将以下函数bean添加到上面定义的应用程序中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public Function<String, String> wrapInQuotes() {
    return s -> "\"" + s + "\"";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并修改<code>spring.cloud.stream.function.definition</code>属性，以反映您打算从“ toUpperCase”和“ wrapInQuotes”组成新功能的意图。为此，Spring Cloud Function允许您使用<code>|</code> （管道）符号。因此，完成我们的示例，我们的属性现在将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">—spring.cloud.stream.function.definition=toUpperCase|wrapInQuotes</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-streams-overview-using-polled-consumers"><a class="anchor" href="#spring-cloud-streams-overview-using-polled-consumers"></a> <a class="link" href="#spring-cloud-streams-overview-using-polled-consumers">使用轮询的消费者</a></h5>
<div class="sect5">
<h6 id="overview-2"><a class="anchor" href="#overview-2"></a> <a class="link" href="#overview-2">总览</a></h6>
<div class="paragraph">
<p>使用受调查的消费者时，您可以对<code>PollableMessageSource</code>一经请求。考虑以下受调查消费者的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface PolledConsumer {

    @Input
    PollableMessageSource destIn();

    @Output
    MessageChannel destOut();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定上一个示例中的受调查消费者，您可以按以下方式使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ApplicationRunner poller(PollableMessageSource destIn, MessageChannel destOut) {
    return args -> {
        while (someCondition()) {
            try {
                if (!destIn.poll(m -> {
                    String newPayload = ((String) m.getPayload()).toUpperCase();
                    destOut.send(new GenericMessage<>(newPayload));
                })) {
                    Thread.sleep(1000);
                }
            }
            catch (Exception e) {
                // handle failure
            }
        }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>PollableMessageSource.poll()</code>方法需要<code>MessageHandler</code>参数（通常是lambda表达式，如此处所示）。它返回<code>true</code>如果消息已接收并成功处理。</p>
</div>
<div class="paragraph">
<p>与消息驱动的消费者一样，如果<code>MessageHandler</code>引发异常，消息将发布到错误通道，如“ <a href="#binder-error-channels">[binder-error-channels]</a> ”中所述。</p>
</div>
<div class="paragraph">
<p>通常， <code>poll()</code>当该方法确认消息时<code>MessageHandler</code>退出。如果该方法异常退出，则消息被拒绝（不重新排队），但请参阅<a href="#polled-errors">处理错误</a> 。您可以通过对确认负责来覆盖该行为，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public ApplicationRunner poller(PollableMessageSource dest1In, MessageChannel dest2Out) {
    return args -> {
        while (someCondition()) {
            if (!dest1In.poll(m -> {
                StaticMessageHeaderAccessor.getAcknowledgmentCallback(m).noAutoAck();
                // e.g. hand off to another thread which can perform the ack
                // or acknowledge(Status.REQUEUE)

            })) {
                Thread.sleep(1000);
            }
        }
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">你必须<code>ack</code> （要么<code>nack</code> ）消息，以避免资源泄漏。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">一些消息传递系统（例如Apache Kafka）在日志中维护简单的偏移量。如果交付失败并重新排队<code>StaticMessageHeaderAccessor.getAcknowledgmentCallback(m).acknowledge(Status.REQUEUE);</code> ，任何以后成功确认的消息都会重新发送。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>还有一个超载<code>poll</code>方法，其定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">poll(MessageHandler handler, ParameterizedTypeReference<?> type)</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>type</code>是一个转换提示，它允许转换传入的消息有效负载，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">boolean result = pollableSource.poll(received -> {
            Map<String, Foo> payload = (Map<String, Foo>) received.getPayload();
            ...

        }, new ParameterizedTypeReference<Map<String, Foo>>() {});</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="polled-errors"><a class="anchor" href="#polled-errors"></a> <a class="link" href="#polled-errors">处理错误</a></h6>
<div class="paragraph">
<p>默认情况下，为可轮询源配置了一个错误通道。如果回调引发异常，则<code>ErrorMessage</code>发送到错误通道（ <code><destination>.<group>.errors</code> ）;此错误通道也已桥接到全局Spring Integration <code>errorChannel</code> 。</p>
</div>
<div class="paragraph">
<p>您可以使用<code>@ServiceActivator</code>处理错误；如果没有订阅，则将仅记录错误并确认消息成功。如果错误通道服务激活器引发异常，则该消息将被拒绝（默认情况下），并且不会重新发送。如果服务激活器抛出一个<code>RequeueCurrentMessageException</code> ，该消息将在代理处重新排队，并在随后的轮询中再次检索。</p>
</div>
<div class="paragraph">
<p>如果听众抛出一个<code>RequeueCurrentMessageException</code>如上所述，直接将消息重新排队，并且不会将其发送到错误通道。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-error-handling"><a class="anchor" href="#spring-cloud-stream-overview-error-handling"></a> <a class="link" href="#spring-cloud-stream-overview-error-handling">21.6.4。错误处理</a></h4>
<div class="paragraph">
<p>错误会发生，Spring Cloud Stream提供了几种灵活的机制来处理它们。错误处理有两种形式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>应用程序：</strong>错误处理在应用程序（自定义错误处理程序）中完成。</p>
</li>
<li>
<p><strong>系统：</strong>将错误处理委托给联编程序（重新排队，DL和其他）。请注意，这些技术取决于绑定程序的实现和底层消息传递中间件的功能。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Stream使用<a href="https://github.com/spring-projects/spring-retry">Spring Retry</a>库来促进成功的消息处理。有关更多详细信息，请参见<a href="#retry-template">重试模板</a> 。但是，当所有方法均失败时，消息处理程序引发的异常将传播回绑定程序。那时，活页夹调用自定义错误处理程序或将错误传达回消息传递系统（重新排队，DLQ等）。</p>
</div>
<div class="sect5">
<h6 id="application-error-handling"><a class="anchor" href="#application-error-handling"></a> <a class="link" href="#application-error-handling">应用错误处理</a></h6>
<div class="paragraph">
<p>有两种类型的应用程序级错误处理。可以在每个绑定订阅中处理错误，或者全局处理程序可以处理所有绑定订阅错误。让我们查看详细信息。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/custom_vs_global_error_channels.png" alt="自定义与全局错误通道" width="800">
</div>
<div class="title">图12。具有自定义和全局错误处理程序的Spring Cloud Stream Sink应用程序</div>
</div>
<div class="paragraph">
<p>对于每个输入绑定，Spring Cloud Stream创建具有以下语义的专用错误通道<code><destinationName>.errors</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code><destinationName></code>由绑定的名称组成（例如<code>input</code> ）和组名（例如<code>myGroup</code> ）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑以下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">spring.cloud.stream.bindings.input.group=myGroup</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@StreamListener(Sink.INPUT) // destination name 'input.myGroup'
public void handle(Person value) {
    throw new RuntimeException("BOOM!");
}

@ServiceActivator(inputChannel = Processor.INPUT + ".myGroup.errors") //channel name 'input.myGroup.errors'
public void error(Message<?> message) {
    System.out.println("Handling ERROR: " + message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，目标名称为<code>input.myGroup</code>专用错误通道名称为<code>input.myGroup.errors</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">@StreamListener批注的使用专门用于定义桥接内部通道和外部目标的绑定。鉴于特定于目标的错误通道没有关联的外部目标，因此此类通道是Spring Integration（SI）的特权。这意味着必须使用SI处理程序注释之一（即@ ServiceActivator，@ Transformer等）定义用于此类目标的处理程序。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果<code>group</code>未指定使用匿名组（类似<code>input.anonymous.2K37rb06Q6m2r51-SPIDDQ</code> ），不适合用于错误处理方案，因为在创建目标之前，您不知道它将是什么。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>另外，如果您绑定到现有目的地，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">spring.cloud.stream.bindings.input.destination=myFooDestination
spring.cloud.stream.bindings.input.group=myGroup</code></pre>
</div>
</div>
<div class="paragraph">
<p>完整的目的地名称是<code>myFooDestination.myGroup</code>然后专用错误通道名称是<code>myFooDestination.myGroup.errors</code> 。</p>
</div>
<div class="paragraph">
<p>回到例子...</p>
</div>
<div class="paragraph">
<p>的<code>handle(..)</code>方法，该方法订阅名为<code>input</code> ，引发异常。给定错误通道的订阅者<code>input.myGroup.errors</code>所有错误消息均由该订户处理。</p>
</div>
<div class="paragraph">
<p>如果您有多个绑定，则可能需要一个错误处理程序。通过将每个单独的错误通道桥接到命名通道，Spring Cloud Stream自动为<em>全局错误通道</em>提供支持<code>errorChannel</code> ，允许单个订阅者处理所有错误，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@StreamListener("errorChannel")
public void error(Message<?> message) {
    System.out.println("Handling ERROR: " + message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果错误处理逻辑相同，则与哪个处理程序产生错误无关，这可能是一个方便的选择。</p>
</div>
</div>
<div class="sect5">
<h6 id="system-error-handling"><a class="anchor" href="#system-error-handling"></a> <a class="link" href="#system-error-handling">系统错误处理</a></h6>
<div class="paragraph">
<p>系统级错误处理意味着将错误传递回消息传递系统，并且鉴于并非每个消息传递系统都相同，因此各个粘合剂的功能可能有所不同。</p>
</div>
<div class="paragraph">
<p>也就是说，在本节中，我们解释了系统级错误处理背后的一般思想，并以Rabbit绑定程序为例。注意：尽管某些配置属性确实有所不同，但Kafka活页夹提供了类似的支持。另外，有关更多详细信息和配置选项，请参见各个活页夹的文档。</p>
</div>
<div class="paragraph">
<p>如果未配置内部错误处理程序，则错误将传播到绑定程序，而绑定程序随后会将这些错误传播回消息传递系统。根据消息传递系统的功能，这样的系统可能会<em>丢弃</em>该消息， <em>重新排队</em>该消息以进行重新处理或<em>将失败的消息发送给DLQ</em> 。 Rabbit和Kafka都支持这些概念。但是，其他联编程序可能没有，因此请参阅您单独的联编程序的文档，以获取有关受支持的系统级错误处理选项的详细信息。</p>
</div>
<div class="sect6">
<h7 id="drop-failed-messages"><a class="anchor" href="#drop-failed-messages"></a> <a class="link" href="#drop-failed-messages">删除失败的消息</a></h7>
<div class="paragraph">
<p>默认情况下，如果未提供其他系统级配置，则消息传递系统将丢弃失败的消息。尽管在某些情况下可以接受，但在大多数情况下是不可接受的，我们需要某种恢复机制来避免消息丢失。</p>
</div>
</div>
<div class="sect6">
<h7 id="dlq-dead-letter-queue"><a class="anchor" href="#dlq-dead-letter-queue"></a> <a class="link" href="#dlq-dead-letter-queue">DLQ-死信队列</a></h7>
<div class="paragraph">
<p>DLQ允许将失败的消息发送到特殊目标： <em>-Dead Letter Queue</em> 。</p>
</div>
<div class="paragraph">
<p>配置后，失败的消息将发送到此目标，以进行后续的重新处理或审核与对帐。</p>
</div>
<div class="paragraph">
<p>例如，继续前面的示例，并使用Rabbit活页夹设置DLQ，您需要设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，在上述属性中， <code>input</code>对应于输入目标绑定的名称。的<code>consumer</code>表示它是消费者财产，并且<code>auto-bind-dlq</code>指示绑定程序为以下内容配置DLQ <code>input</code>目标，这将导致一个名为Rabbit的附加Rabbit队列<code>input.myGroup.dlq</code> 。</p>
</div>
<div class="paragraph">
<p>配置完成后，所有失败的消息都会通过错误消息路由到此队列，类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">delivery_mode:  1
headers:
x-death:
count:  1
reason: rejected
queue:  input.hello
time:   1522328151
exchange:
routing-keys:   input.myGroup
Payload {"name”:"Bob"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面可以看到，原始消息会保留下来，以供进一步操作。</p>
</div>
<div class="paragraph">
<p>但是，您可能已经注意到的一件事是，有关消息处理的原始问题的信息有限。例如，您看不到与原始错误相对应的堆栈跟踪。要获取有关原始错误的更多相关信息，您必须设置一个附加属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">spring.cloud.stream.rabbit.bindings.input.consumer.republish-to-dlq=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做会强制内部错误处理程序拦截错误消息并向其添加其他信息，然后再将其发布到DLQ。配置完成后，您可以看到错误消息包含与原始错误有关的更多信息，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">delivery_mode:  2
headers:
x-original-exchange:
x-exception-message:    has an error
x-original-routingKey:  input.myGroup
x-exception-stacktrace: org.springframework.messaging.MessageHandlingException: nested exception is
      org.springframework.messaging.MessagingException: has an error, failedMessage=GenericMessage [payload=byte[15],
      headers={amqp_receivedDeliveryMode=NON_PERSISTENT, amqp_receivedRoutingKey=input.hello, amqp_deliveryTag=1,
      deliveryAttempt=3, amqp_consumerQueue=input.hello, amqp_redelivered=false, id=a15231e6-3f80-677b-5ad7-d4b1e61e486e,
      amqp_consumerTag=amq.ctag-skBFapilvtZhDsn0k3ZmQg, contentType=application/json, timestamp=1522327846136}]
      at org.spring...integ...han...MethodInvokingMessageProcessor.processMessage(MethodInvokingMessageProcessor.java:107)
      at. . . . .
Payload {"name”:"Bob"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有效地结合了应用程序级和系统级的错误处理，以进一步协助下游故障排除机制。</p>
</div>
</div>
<div class="sect6">
<h7 id="re-queue-failed-messages"><a class="anchor" href="#re-queue-failed-messages"></a> <a class="link" href="#re-queue-failed-messages">重新排队失败的消息</a></h7>
<div class="paragraph">
<p>如前所述，当前受支持的活页夹（Rabbit和Kafka）依赖<code>RetryTemplate</code>促进成功的消息处理。有关详细信息，请参见<a href="#retry-template">重试模板</a> 。但是，对于<code>max-attempts</code>属性设置为1，禁用消息的内部重新处理。此时，您可以通过指示消息传递系统重新排队失败的消息来促进消息的重新处理（重试）。重新排队后，失败的消息将被发送回原始处理程序，从而创建一个重试循环。</p>
</div>
<div class="paragraph">
<p>对于错误的性质与某些资源偶尔但短期不可用有关的情况，此选项可能是可行的。</p>
</div>
<div class="paragraph">
<p>为此，必须设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">spring.cloud.stream.bindings.input.consumer.max-attempts=1
spring.cloud.stream.rabbit.bindings.input.consumer.requeue-rejected=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>max-attempts</code>设置为1实质上禁用内部重试，并且<code>requeue-rejected</code> （ <em>重新排队拒绝消息的</em>缩写）设置为<code>true</code> 。设置后，失败的消息将重新提交给同一处理程序，并连续循环或直到处理程序抛出<code>AmqpRejectAndDontRequeueException</code>本质上允许您在处理程序本身内构建自己的重试逻辑。</p>
</div>
</div>
</div>
<div class="sect5">
<h6 id="retry-template"><a class="anchor" href="#retry-template"></a> <a class="link" href="#retry-template">重试模板</a></h6>
<div class="paragraph">
<p>的<code>RetryTemplate</code>是<a href="https://github.com/spring-projects/spring-retry">Spring Retry</a>库的一部分。尽管超出了本文档的范围，无法涵盖本文档的所有功能。 <code>RetryTemplate</code> ，我们将提及以下与<code>RetryTemplate</code> ：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">maxAttempts</dt>
<dd>
<p>处理消息的尝试次数。</p>
<div class="paragraph">
<p>默认值：3</p>
</div>
</dd>
<dt class="hdlist1">backOffInitialInterval</dt>
<dd>
<p>重试时的退避初始间隔。</p>
<div class="paragraph">
<p>默认值1000毫秒。</p>
</div>
</dd>
<dt class="hdlist1">backOffMaxInterval</dt>
<dd>
<p>最大退避间隔。</p>
<div class="paragraph">
<p>默认值10000毫秒。</p>
</div>
</dd>
<dt class="hdlist1">backOffMultiplier</dt>
<dd>
<p>退避乘数。</p>
<div class="paragraph">
<p>默认值2.0。</p>
</div>
</dd>
<dt class="hdlist1">defaultRetryable</dt>
<dd>
<p>侦听器是否抛出了未在列表中列出的异常<code>retryableExceptions</code>可重试。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">retryableExceptions</dt>
<dd>
<p>键中Throwable类名称的映射，值中布尔值的映射。指定将要重试的那些异常（和子类）。另见<code>defaultRetriable</code> 。例： <code>spring.cloud.stream.bindings.input.consumer.retryable-exceptions.java.lang.IllegalStateException=false</code> 。</p>
<div class="paragraph">
<p>默认值：空。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>尽管上述设置足以满足大多数自定义要求，但它们可能无法满足某些复杂的要求，此时您可能希望提供自己的实例。 <code>RetryTemplate</code> 。为此，将其配置为应用程序配置中的Bean。应用程序提供的实例将覆盖框架提供的实例。另外，为避免冲突，您必须限定<code>RetryTemplate</code>您想被活页夹用作<code>@StreamRetryTemplate</code> 。例如，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@StreamRetryTemplate
public RetryTemplate myRetryTemplate() {
    return new RetryTemplate();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从上面的示例中可以看到，您不需要使用<code>@Bean</code>以来<code>@StreamRetryTemplate</code>是合格的<code>@Bean</code> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-reactive-programming-support"><a class="anchor" href="#spring-cloud-stream-overview-reactive-programming-support"></a> <a class="link" href="#spring-cloud-stream-overview-reactive-programming-support">21.6.5。反应式编程支持</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream还支持使用反应式API，将传入和传出的数据作为连续的数据流进行处理。可通过以下方式获得对反应式API的支持： <code>spring-cloud-stream-reactive</code> ，需要将其显式添加到您的项目中。</p>
</div>
<div class="paragraph">
<p>具有反应式API的编程模型是声明性的。您可以使用描述从入站数据流到出站数据流的功能转换的运算符，而不是指定每个消息的处理方式。</p>
</div>
<div class="paragraph">
<p>目前，Spring Cloud Stream仅支持<a href="https://projectreactor.io/">Reactor API</a> 。将来，我们打算支持基于反应式流的更通用的模型。</p>
</div>
<div class="paragraph">
<p>反应式编程模型还使用<code>@StreamListener</code>用于设置反应性处理程序的注释。区别在于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>@StreamListener</code>批注不能指定输入或输出，因为它们作为参数提供并从方法返回值。</p>
</li>
<li>
<p>该方法的参数必须用注释<code>@Input</code>和<code>@Output</code> ，分别指示传入和传出数据流连接到哪个输入或输出。</p>
</li>
<li>
<p>方法的返回值（如果有）用注释<code>@Output</code> ，指示应该将数据发送到的输入。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">响应式编程支持需要Java 1.8。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">从Spring Cloud Stream 1.1.1和更高版本开始（从发布培训Brooklyn开始。SR2），反应式编程支持要求使用Reactor 3.0.4。发行及更高版本。较早的Reactor版本（包括3.0.1）。发布3.0.2。发布和3.0.3。不支持RELEASE）。
<code>spring-cloud-stream-reactive</code>可传递地检索正确的版本，但是项目结构可以管理版本的<code>io.projectreactor:reactor-core</code>到早期版本，尤其是在使用Maven时。对于使用Spring Initializr和Spring Boot 1.x生成的项目就是这种情况，该项目将Reactor版本覆盖为<code>2.0.8.RELEASE</code> 。在这种情况下，您必须确保发布了正确版本的工件。您可以通过添加直接依赖来实现<code>io.projectreactor:reactor-core</code>与版本<code>3.0.4.RELEASE</code>或更高版本的项目。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">目前，术语“反应式”的使用是指正在使用的反应式API，而不是指执行模型是反应式的（也就是说，绑定的端点仍使用“推”式而不是“拉式”模型）。尽管通过使用Reactor提供了一些反压支持，但我们确实打算在将来的版本中通过将本地反应式客户端用于连接的中间件来完全支持反应式管道。
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="reactor-based-handlers"><a class="anchor" href="#reactor-based-handlers"></a> <a class="link" href="#reactor-based-handlers">基于反应堆的处理程序</a></h6>
<div class="paragraph">
<p>基于Reactor的处理程序可以具有以下参数类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于带有注释的参数<code>@Input</code> ，它支持Reactor <code>Flux</code>类型。入站Flux的参数化遵循与处理单个消息相同的规则：它可以是整个<code>Message</code> ，一个POJO可以是<code>Message</code>有效负载或POJO，它是基于<code>Message</code>内容类型标头。提供了多个输入。</p>
</li>
<li>
<p>对于带有注释的参数<code>Output</code> ，它支持<code>FluxSender</code>类型，将一个<code>Flux</code>该方法产生的输出。一般而言，仅在该方法可以具有多个输出时才建议将输出指定为参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>基于Reactor的处理程序支持以下类型的返回类型： <code>Flux</code> 。在这种情况下，必须使用<code>@Output</code> 。我们建议在单个输出时使用该方法的返回值<code>Flux</code>可用。</p>
</div>
<div class="paragraph">
<p>以下示例显示了基于Reactor的<code>Processor</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  @Output(Processor.OUTPUT)
  public Flux<String> receive(@Input(Processor.INPUT) Flux<String> input) {
    return input.map(s -> s.toUpperCase());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用输出参数的同一处理器看起来像以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Processor.class)
@EnableAutoConfiguration
public static class UppercaseTransformer {

  @StreamListener
  public void receive(@Input(Processor.INPUT) Flux<String> input,
     @Output(Processor.OUTPUT) FluxSender output) {
     output.send(input.map(s -> s.toUpperCase()));
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="reactive-sources"><a class="anchor" href="#reactive-sources"></a> <a class="link" href="#reactive-sources">反应源</a></h6>
<div class="paragraph">
<p>Spring Cloud Stream反应性支持还提供了通过以下方式创建反应性源的功能： <code>@StreamEmitter</code>注解。通过使用<code>@StreamEmitter</code>注解，可以将常规源转换为被动源。
<code>@StreamEmitter</code>是方法级别注释，用于将方法标记为使用以下方法声明的输出的发射器： <code>@EnableBinding</code> 。您不能使用<code>@Input</code>注释以及<code>@StreamEmitter</code> ，因为带有此批注标记的方法不会监听任何输入。而是标有<code>@StreamEmitter</code>产生输出。遵循与<code>@StreamListener</code> ， <code>@StreamEmitter</code>还允许使用灵活的方式<code>@Output</code>注解，具体取决于方法是否具有任何参数，返回类型和其他注意事项。</p>
</div>
<div class="paragraph">
<p>本节的其余部分包含使用<code>@StreamEmitter</code>各种样式的注释。</p>
</div>
<div class="paragraph">
<p>以下示例发出了<code>Hello, World</code>每毫秒发送一次消息并发布到Reactor <code>Flux</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  public Flux<String> emit() {
    return Flux.intervalMillis(1)
            .map(l -> "Hello World");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中， <code>Flux</code>被发送到<code>Source</code> 。</p>
</div>
<div class="paragraph">
<p>下一个示例是<code>@StreamEmmitter</code>发送一个反应堆<code>Flux</code> 。而不是返回一个<code>Flux</code> ，以下方法使用<code>FluxSender</code>以编程方式发送<code>Flux</code>从来源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  public void emit(FluxSender output) {
    output.send(Flux.intervalMillis(1)
            .map(l -> "Hello World"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例在功能和样式上与上述代码段完全相同。但是，与其使用显式<code>@Output</code>方法上的注释，它使用方法参数上的注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  public void emit(@Output(Source.OUTPUT) FluxSender output) {
    output.send(Flux.intervalMillis(1)
            .map(l -> "Hello World"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>本节的最后一个示例是使用Reactive Streams Publisher API并利用<a href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">Spring Integration Java DSL</a>对它的支持来编写反应源的另一种方式。的<code>Publisher</code>在下面的示例中仍然使用Reactor <code>Flux</code>在幕后，但是，从应用程序的角度看，这对用户是透明的，并且只需要Reactive Streams和Java DSL即可进行Spring集成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Source.class)
@EnableAutoConfiguration
public static class HelloWorldEmitter {

  @StreamEmitter
  @Output(Source.OUTPUT)
  @Bean
  public Publisher<Message<String>> emit() {
    return IntegrationFlows.from(() ->
                new GenericMessage<>("Hello World"),
        e -> e.poller(p -> p.fixedDelay(1)))
        .toReactivePublisher();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-binders"><a class="anchor" href="#spring-cloud-stream-overview-binders"></a> <a class="link" href="#spring-cloud-stream-overview-binders">21.7。黏合剂</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream提供了一个Binder抽象，可用于连接到外部中间件上的物理目标。本节提供有关Binder SPI背后的主要概念，其主要组件以及特定于实现的详细信息。</p>
</div>
<div class="sect3">
<h4 id="producers-and-consumers"><a class="anchor" href="#producers-and-consumers"></a> <a class="link" href="#producers-and-consumers">21.7.1。生产者和消费者</a></h4>
<div class="paragraph">
<p>下图显示了生产者和消费者的一般关系：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/producers-consumers.png" alt="生产者消费者" width="800">
</div>
<div class="title">图13。生产者和消费者</div>
</div>
<div class="paragraph">
<p>生产者是将消息发送到通道的任何组件。该通道可以通过以下方式绑定到外部消息代理： <code>Binder</code>该经纪人的实施。调用时<code>bindProducer()</code>方法，第一个参数是代理内目标的名称，第二个参数是生产者向其发送消息的本地通道实例，第三个参数包含将在适配器内使用的属性（例如分区键表达式）为该频道创建的。</p>
</div>
<div class="paragraph">
<p>使用者是从通道接收消息的任何组件。与生产者一样，消费者的渠道可以绑定到外部消息代理。调用时<code>bindConsumer()</code>方法，第一个参数是目标名称，第二个参数提供逻辑上的使用者组名称。由给定目标的使用者绑定表示的每个组都接收生产者发送到该目标的每条消息的副本（也就是说，它遵循常规的发布-订阅语义）。如果有多个使用相同组名绑定的使用者实例，那么消息将在这些使用者实例之间进行负载平衡，从而使生产者发送的每条消息仅被每个组中的单个使用者实例使用（也就是说，遵循正常排队语义）。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-binder-api"><a class="anchor" href="#spring-cloud-stream-overview-binder-api"></a> <a class="link" href="#spring-cloud-stream-overview-binder-api">21.7.2。活页夹SPI</a></h4>
<div class="paragraph">
<p>Binder SPI由许多接口，现成的实用程序类和发现策略组成，这些策略提供了用于连接到外部中间件的可插拔机制。</p>
</div>
<div class="paragraph">
<p>SPI的关键是<code>Binder</code>接口，这是一种将输入和输出连接到外部中间件的策略。以下清单显示了<code>Binder</code>接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Binder<T, C extends ConsumerProperties, P extends ProducerProperties> {
    Binding<T> bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);

    Binding<T> bindProducer(String name, T outboundBindTarget, P producerProperties);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该接口已参数化，提供了许多扩展点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>输入和输出绑定目标。从1.0版开始<code>MessageChannel</code>支持，但将来打算用作扩展点。</p>
</li>
<li>
<p>扩展的使用者和生产者属性，允许特定的Binder实现添加可以以类型安全的方式支持的补充属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>典型的活页夹实现包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实现<code>Binder</code>接口;</p>
</li>
<li>
<p>春天<code>@Configuration</code>创建类型Bean的类<code>Binder</code>以及中间件连接基础结构。</p>
</li>
<li>
<p>一种<code>META-INF/spring.binders</code>在类路径上找到的包含一个或多个绑定程序定义的文件，如以下示例所示：</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>kafka:\
org.springframework.cloud.stream.binder.kafka.config.KafkaBinderConfiguration</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="binder-detection"><a class="anchor" href="#binder-detection"></a> <a class="link" href="#binder-detection">21.7.3。活页夹检测</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream依赖于Binder SPI的实现来执行将通道连接到消息代理的任务。每个Binder实现通常都连接到一种消息传递系统。</p>
</div>
<div class="sect4">
<h5 id="classpath-detection"><a class="anchor" href="#classpath-detection"></a> <a class="link" href="#classpath-detection">类路径检测</a></h5>
<div class="paragraph">
<p>默认情况下，Spring Cloud Stream依靠Spring Boot的自动配置来配置绑定过程。如果在类路径上找到单个Binder实现，Spring Cloud Stream将自动使用它。例如，旨在仅绑定到RabbitMQ的Spring Cloud Stream项目可以添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关其他活页夹依赖项的特定Maven坐标，请参阅该活页夹实现的文档。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multiple-binders"><a class="anchor" href="#multiple-binders"></a> <a class="link" href="#multiple-binders">21.7.4。类路径上的多个绑定器</a></h4>
<div class="paragraph">
<p>当类路径上存在多个绑定程序时，应用程序必须指示将哪个绑定程序用于每个通道绑定。每个活页夹配置都包含一个<code>META-INF/spring.binders</code>文件，这是一个简单的属性文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>rabbit:\
org.springframework.cloud.stream.binder.rabbit.config.RabbitServiceAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他提供的活页夹实现（例如Kafka）也存在类似的文件，并且自定义活页夹实现也有望提供它们。关键字表示活页夹实现的标识名，而该值是用逗号分隔的配置类列表，每个配置类都包含一个且仅一个类型的bean定义<code>org.springframework.cloud.stream.binder.Binder</code> 。</p>
</div>
<div class="paragraph">
<p>活页夹选择可以使用<code>spring.cloud.stream.defaultBinder</code>属性（例如， <code>spring.cloud.stream.defaultBinder=rabbit</code> ）或单独配置，方法是在每个频道绑定上配置绑定器。例如，一个处理器应用程序（具有名为<code>input</code>和<code>output</code>从Kafka读取并写入RabbitMQ的数据分别可以指定以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.input.binder=kafka
spring.cloud.stream.bindings.output.binder=rabbit</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multiple-systems"><a class="anchor" href="#multiple-systems"></a> <a class="link" href="#multiple-systems">21.7.5。连接到多个系统</a></h4>
<div class="paragraph">
<p>默认情况下，活页夹共享应用程序的Spring Boot自动配置，以便创建在类路径上找到的每个活页夹的一个实例。如果您的应用程序应连接到多个相同类型的代理，则可以指定多个绑定程序配置，每个配置具有不同的环境设置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">打开显式活页夹配置将完全禁用默认的活页夹配置过程。如果这样做，则必须在配置中包括所有正在使用的活页夹。打算透明地使用Spring Cloud Stream的框架可以创建可以按名称引用的绑定器配置，但它们不会影响默认的绑定器配置。为此，活页夹配置可能具有其<code>defaultCandidate</code>标记设置为false（例如， <code>spring.cloud.stream.binders.<configurationName>.defaultCandidate=false</code> ）。这表示独立于默认绑定程序配置过程而存在的配置。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例显示了连接到两个RabbitMQ代理实例的处理器应用程序的典型配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: thing1
          binder: rabbit1
        output:
          destination: thing2
          binder: rabbit2
      binders:
        rabbit1:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: <host1>
        rabbit2:
          type: rabbit
          environment:
            spring:
              rabbitmq:
                host: <host2></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="binding-visualization-and-control"><a class="anchor" href="#binding-visualization-and-control"></a> <a class="link" href="#binding-visualization-and-control">21.7.6。绑定可视化和控制</a></h4>
<div class="paragraph">
<p>从2.0版开始，Spring Cloud Stream支持通过Actuator端点进行绑定的可视化和控制。</p>
</div>
<div class="paragraph">
<p>从版本2.0执行器和Web开始是可选的，您必须首先添加Web依赖项之一，然后手动添加执行器依赖项。下面的示例显示如何为Web框架添加依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-web</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何为WebFlux框架添加依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-webflux</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以添加执行器依赖项，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">要在Cloud Foundry中运行Spring Cloud Stream 2.0应用程序，您必须添加<code>spring-boot-starter-web</code>和<code>spring-boot-starter-actuator</code>到类路径。否则，由于运行状况检查失败，该应用程序将无法启动。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还必须启用<code>bindings</code>通过设置以下属性来执行器端点： <code>--management.endpoints.web.exposure.include=bindings</code> 。</p>
</div>
<div class="paragraph">
<p>一旦满足这些先决条件。应用程序启动时，您应该在日志中看到以下内容：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>: Mapped "{[/actuator/bindings/{name}],methods=[POST]. . .
: Mapped "{[/actuator/bindings],methods=[GET]. . .
: Mapped "{[/actuator/bindings/{name}],methods=[GET]. . .</pre>
</div>
</div>
<div class="paragraph">
<p>要显示当前绑定，请访问以下URL：<code><a href="http://<host>:<port>/actuator/bindings" class="bare"><host>:<port>/actuator/bindings</a></code></p>
</div>
<div class="paragraph">
<p>或者，要查看单个绑定，请访问类似于以下内容的URL之一：<code><a href="http://<host>:<port>/actuator/bindings/myBindingName" class="bare"><host>:<port>/actuator/bindings/myBindingName</a></code></p>
</div>
<div class="paragraph">
<p>您还可以通过发布到同一URL来停止，开始，暂停和恢复单个绑定，同时提供一个<code>state</code>参数为JSON，如以下示例所示：</p>
</div>
<div class="paragraph">
<p>curl -d'{“ state”：“ STOPPED”}'-H“内容类型：应用程序/ json” -X POST <a href="javascript:void(0);" class="bare"><host>： <port>/ actuator / bindings / myBindingName</port></host></a> curl -d'{“ state”：“ STARTED”}'- H“内容类型：application / json” -X POST <a href="javascript:void(0);" class="bare"><host>： <port>/ actuator / bindings / myBindingName</port></host></a> curl -d'{“ state”：“ PAUSED”}'-H“内容类型：application / json” -X POST <a href="javascript:void(0);" class="bare"><host>： <port>/作动器/绑定/ myBindingName</port></host></a> curl -d'{“ state”：“ RESUMED”}'-H“内容类型：应用程序/ json” -X POST <a href="javascript:void(0);" class="bare"><host>： <port>/ actuator / bindings / myBindingName</port></host></a></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<code>PAUSED</code>和<code>RESUMED</code>仅当相应的活页夹及其底层技术支持它时，该文件才起作用。否则，您会在日志中看到警告消息。目前，只有Kafka活页夹支持<code>PAUSED</code>和<code>RESUMED</code>状态。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="binder-configuration-properties"><a class="anchor" href="#binder-configuration-properties"></a> <a class="link" href="#binder-configuration-properties">21.7.7。活页夹配置属性</a></h4>
<div class="paragraph">
<p>定制活页夹配置时，以下属性可用。这些属性通过<code>org.springframework.cloud.stream.config.BinderProperties</code></p>
</div>
<div class="paragraph">
<p>它们必须以<code>spring.cloud.stream.binders.<configurationName></code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">类型</dt>
<dd>
<p>资料夹类型。它通常引用在类路径上找到的绑定器之一-特别是<code>META-INF/spring.binders</code>文件。</p>
<div class="paragraph">
<p>默认情况下，它具有与配置名称相同的值。</p>
</div>
</dd>
<dt class="hdlist1">继承环境</dt>
<dd>
<p>配置是否继承应用程序本身的环境。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">环境</dt>
<dd>
<p>根可用于定制活页夹环境的一组属性。设置此属性后，在其中创建活页夹的上下文不是应用程序上下文的子级。该设置允许在粘合剂组分和应用组分之间完全分离。</p>
<div class="paragraph">
<p>默认： <code>empty</code> 。</p>
</div>
</dd>
<dt class="hdlist1">defaultCandidate</dt>
<dd>
<p>活页夹配置是被视为默认活页夹的候选者还是仅在明确引用时才可以使用。此设置允许添加活页夹配置，而不会干扰默认处理。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-options"><a class="anchor" href="#configuration-options"></a> <a class="link" href="#configuration-options">21.8。配置选项</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream支持常规配置选项以及绑定和活页夹的配置。一些活页夹使附加的绑定属性支持特定于中间件的功能。</p>
</div>
<div class="paragraph">
<p>可以通过Spring Boot支持的任何机制将配置选项提供给Spring Cloud Stream应用程序。这包括应用程序参数，环境变量以及YAML或.properties文件。</p>
</div>
<div class="sect3">
<h4 id="binding-service-properties"><a class="anchor" href="#binding-service-properties"></a> <a class="link" href="#binding-service-properties">21.8.1。绑定服务属性</a></h4>
<div class="paragraph">
<p>这些属性通过<code>org.springframework.cloud.stream.config.BindingServiceProperties</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.instanceCount</dt>
<dd>
<p>应用程序已部署实例的数量。必须在生产者端进行分区设置。如果使用RabbitMQ和Kafka，则必须在用户端设置<code>autoRebalanceEnabled=false</code> 。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.instanceIndex</dt>
<dd>
<p>应用程序的实例索引：来自的数字<code>0</code>至<code>instanceCount - 1</code> 。用于通过RabbitMQ和Kafka进行分区，如果<code>autoRebalanceEnabled=false</code> 。在Cloud Foundry中自动设置以匹配应用程序的实例索引。</p>
</dd>
<dt class="hdlist1">spring.cloud.stream.dynamic目的地</dt>
<dd>
<p>可以动态绑定的目的地列表（例如，在动态路由方案中）。如果设置，则只能绑定列出的目的地。</p>
<div class="paragraph">
<p>默认值：空（将任何目的地绑定）。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.defaultBinder</dt>
<dd>
<p>如果配置了多个联编程序，则使用的默认联编程序。请参见<a href="#multiple-binders">Classpath上的多个绑定器</a> 。</p>
<div class="paragraph">
<p>默认值：空。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.overrideCloudConnectors</dt>
<dd>
<p>仅当<code>cloud</code>配置文件处于活动状态，并且该应用程序提供了Spring Cloud Connector。如果属性是<code>false</code> （默认设置），绑定程序会检测合适的绑定服务（例如，在Cloud Foundry中为RabbitMQ绑定程序绑定的RabbitMQ服务）并将其用于创建连接（通常通过Spring Cloud Connectors）。设置为<code>true</code> ，此属性指示绑定程序完全忽略绑定的服务，并依赖于Spring Boot属性（例如，依赖于<code>spring.rabbitmq.*</code>环境中为RabbitMQ活页夹提供的属性）。<a href="#multiple-systems">连接到多个系统时</a> ，此属性的典型用法是嵌套在自定义环境<a href="#multiple-systems">中</a> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.bindingRetryInterval</dt>
<dd>
<p>例如，当绑定器不支持后期绑定并且代理（例如，Apache Kafka）关闭时，重试绑定创建之间的间隔（以秒为单位）。将其设置为零可将此类情况视为致命情况，从而阻止应用程序启动。</p>
<div class="paragraph">
<p>默认：<code>30</code></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="binding-properties"><a class="anchor" href="#binding-properties"></a> <a class="link" href="#binding-properties">21.8.2。绑定属性</a></h4>
<div class="paragraph">
<p>绑定属性通过以下格式提供<code>spring.cloud.stream.bindings.<channelName>.<property>=<value></code> 。的<code><channelName></code>代表正在配置的通道的名称（例如， <code>output</code>为一个<code>Source</code> ）。</p>
</div>
<div class="paragraph">
<p>为了避免重复，Spring Cloud Stream支持以以下格式设置所有通道的值： <code>spring.cloud.stream.default.<property>=<value></code> 。</p>
</div>
<div class="paragraph">
<p>在避免重复使用扩展绑定属性时，应使用以下格式- <code>spring.cloud.stream.<binder-type>.default.<producer|consumer>.<property>=<value></code> 。</p>
</div>
<div class="paragraph">
<p>在下面的内容中，我们指出了我们省略了<code>spring.cloud.stream.bindings.<channelName>.</code>前缀，并只关注属性名称，前提是在运行时会包含前缀。</p>
</div>
<div class="sect4">
<h5 id="common-binding-properties"><a class="anchor" href="#common-binding-properties"></a> <a class="link" href="#common-binding-properties">常用绑定属性</a></h5>
<div class="paragraph">
<p>这些属性通过<code>org.springframework.cloud.stream.config.BindingProperties</code></p>
</div>
<div class="paragraph">
<p>以下绑定属性可用于输入和输出绑定，并且必须使用前缀<code>spring.cloud.stream.bindings.<channelName>.</code> （例如， <code>spring.cloud.stream.bindings.input.destination=ticktock</code> ）。</p>
</div>
<div class="paragraph">
<p>可以使用<code>spring.cloud.stream.default</code>前缀（例如spring.cloud.stream.default.contentType = application / json`）。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">目的地</dt>
<dd>
<p>绑定的中间件上的通道的目标位置（例如，RabbitMQ交换或Kafka主题）。如果将通道绑定为使用者，则可以将其绑定到多个目标，并且目标名称可以指定为逗号分隔<code>String</code>价值观。如果未设置，则使用通道名称。此属性的默认值不能被覆盖。</p>
</dd>
<dt class="hdlist1">组</dt>
<dd>
<p>渠道的消费群体。仅适用于入站绑定。请参阅<a href="#consumer-groups">消费者组</a> 。</p>
<div class="paragraph">
<p>默认： <code>null</code> （表示匿名消费者）。</p>
</div>
</dd>
<dt class="hdlist1">内容类型</dt>
<dd>
<p>频道的内容类型。请参阅“ <a href="#content-type-management">内容类型协商</a> ”。</p>
<div class="paragraph">
<p>默认： <code>application/json</code> 。</p>
</div>
</dd>
<dt class="hdlist1">黏合剂</dt>
<dd>
<p>此绑定使用的粘合剂。有关详细信息，请参见“ <a href="#multiple-binders">类路径上的多个绑定器</a> ”。</p>
<div class="paragraph">
<p>默认： <code>null</code> （如果存在，则使用默认的活页夹）。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="consumer-properties"><a class="anchor" href="#consumer-properties"></a> <a class="link" href="#consumer-properties">消费者财产</a></h5>
<div class="paragraph">
<p>这些属性通过<code>org.springframework.cloud.stream.binder.ConsumerProperties</code></p>
</div>
<div class="paragraph">
<p>以下绑定属性仅可用于输入绑定，并且必须带有前缀<code>spring.cloud.stream.bindings.<channelName>.consumer.</code> （例如， <code>spring.cloud.stream.bindings.input.consumer.concurrency=3</code> ）。</p>
</div>
<div class="paragraph">
<p>可以使用<code>spring.cloud.stream.default.consumer</code>前缀（例如， <code>spring.cloud.stream.default.consumer.headerMode=none</code> ）。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">并发</dt>
<dd>
<p>入站使用者的并发。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">分区的</dt>
<dd>
<p>消费者是否从分区生产者那里接收数据。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">headerMode</dt>
<dd>
<p>设置为<code>none</code> ，禁用输入的标头解析。仅对本身不支持消息头且需要消息头嵌入的消息中间件有效。当不支持本机头时，使用非Spring Cloud Stream应用程序中的数据时，此选项很有用。设置为<code>headers</code> ，它使用中间件的本机头机制。设置为<code>embeddedHeaders</code> ，它将标头嵌入到消息有效负载中。</p>
<div class="paragraph">
<p>默认值：取决于活页夹的实现。</p>
</div>
</dd>
<dt class="hdlist1">maxAttempts</dt>
<dd>
<p>如果处理失败，则尝试处理消息的次数（包括第一个）。调成<code>1</code>禁用重试。</p>
<div class="paragraph">
<p>默认： <code>3</code> 。</p>
</div>
</dd>
<dt class="hdlist1">backOffInitialInterval</dt>
<dd>
<p>重试时的退避初始间隔。</p>
<div class="paragraph">
<p>默认： <code>1000</code> 。</p>
</div>
</dd>
<dt class="hdlist1">backOffMaxInterval</dt>
<dd>
<p>最大退避间隔。</p>
<div class="paragraph">
<p>默认： <code>10000</code> 。</p>
</div>
</dd>
<dt class="hdlist1">backOffMultiplier</dt>
<dd>
<p>退避乘数。</p>
<div class="paragraph">
<p>默认： <code>2.0</code> 。</p>
</div>
</dd>
<dt class="hdlist1">defaultRetryable</dt>
<dd>
<p>侦听器是否抛出了未在列表中列出的异常<code>retryableExceptions</code>可重试。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">instanceIndex</dt>
<dd>
<p>设置为大于零的值时，它允许自定义此使用者的实例索引（如果与<code>spring.cloud.stream.instanceIndex</code> ）。设置为负值时，默认为<code>spring.cloud.stream.instanceIndex</code> 。有关更多信息，请参见“ <a href="#spring-cloud-stream-overview-instance-index-instance-count">实例索引和实例计数</a> ”。</p>
<div class="paragraph">
<p>默认： <code>-1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">instanceCount</dt>
<dd>
<p>设置为大于零的值时，它允许自定义此使用者的实例计数（如果与<code>spring.cloud.stream.instanceCount</code> ）。设置为负值时，默认为<code>spring.cloud.stream.instanceCount</code> 。有关更多信息，请参见“ <a href="#spring-cloud-stream-overview-instance-index-instance-count">实例索引和实例计数</a> ”。</p>
<div class="paragraph">
<p>默认： <code>-1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">retryableExceptions</dt>
<dd>
<p>键中Throwable类名称的映射，值中布尔值的映射。指定将要重试的那些异常（和子类）。另见<code>defaultRetriable</code> 。例： <code>spring.cloud.stream.bindings.input.consumer.retryable-exceptions.java.lang.IllegalStateException=false</code> 。</p>
<div class="paragraph">
<p>默认值：空。</p>
</div>
</dd>
<dt class="hdlist1">useNativeDecoding</dt>
<dd>
<p>设置为<code>true</code> ，入站消息将直接由客户端库反序列化，该库必须进行相应配置（例如，设置适当的Kafka生产者值反序列化器）。使用此配置时，入站邮件解组不是基于<code>contentType</code>的绑定。使用本机解码时，生产者负责使用适当的编码器（例如，Kafka生产者值序列化程序）对出站消息进行序列化。此外，当使用本机编码和解码时， <code>headerMode=embeddedHeaders</code>属性将被忽略，并且标头未嵌入消息中。查看生产者财产<code>useNativeEncoding</code> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="producer-properties"><a class="anchor" href="#producer-properties"></a> <a class="link" href="#producer-properties">生产者属性</a></h5>
<div class="paragraph">
<p>这些属性通过<code>org.springframework.cloud.stream.binder.ProducerProperties</code></p>
</div>
<div class="paragraph">
<p>以下绑定属性仅可用于输出绑定，并且必须带有前缀<code>spring.cloud.stream.bindings.<channelName>.producer.</code> （例如， <code>spring.cloud.stream.bindings.input.producer.partitionKeyExpression=payload.id</code> ）。</p>
</div>
<div class="paragraph">
<p>可以使用前缀设置默认值<code>spring.cloud.stream.default.producer</code> （例如， <code>spring.cloud.stream.default.producer.partitionKeyExpression=payload.id</code> ）。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">partitionKeyExpression</dt>
<dd>
<p>一个SpEL表达式，该表达式确定如何对出站数据进行分区。如果设置，或者<code>partitionKeyExtractorClass</code>设置后，将对该通道上的出站数据进行分区。 <code>partitionCount</code>必须将其设置为大于1的值才能生效。与互斥<code>partitionKeyExtractorClass</code> 。请参阅“ <a href="#partitioning">分区支持</a> ”。</p>
<div class="paragraph">
<p>默认值：null。</p>
</div>
</dd>
<dt class="hdlist1">partitionKeyExtractorClass</dt>
<dd>
<p>一种<code>PartitionKeyExtractorStrategy</code>实施。如果设置，或者<code>partitionKeyExpression</code>设置后，将对该通道上的出站数据进行分区。 <code>partitionCount</code>必须将其设置为大于1的值才能生效。与互斥<code>partitionKeyExpression</code> 。请参阅“ <a href="#partitioning">分区支持</a> ”。</p>
<div class="paragraph">
<p>默认： <code>null</code> 。</p>
</div>
</dd>
<dt class="hdlist1">partitionSelectorClass</dt>
<dd>
<p>一种<code>PartitionSelectorStrategy</code>实施。与互斥<code>partitionSelectorExpression</code> 。如果两者均未设置，则选择该分区作为<code>hashCode(key) % partitionCount</code> ，在哪里<code>key</code>通过以下任一方式计算<code>partitionKeyExpression</code>要么<code>partitionKeyExtractorClass</code> 。</p>
<div class="paragraph">
<p>默认： <code>null</code> 。</p>
</div>
</dd>
<dt class="hdlist1">partitionSelectorExpression</dt>
<dd>
<p>用于自定义分区选择的SpEL表达式。与互斥<code>partitionSelectorClass</code> 。如果两者均未设置，则选择该分区作为<code>hashCode(key) % partitionCount</code> ，在哪里<code>key</code>通过以下任一方式计算<code>partitionKeyExpression</code>要么<code>partitionKeyExtractorClass</code> 。</p>
<div class="paragraph">
<p>默认： <code>null</code> 。</p>
</div>
</dd>
<dt class="hdlist1">partitionCount</dt>
<dd>
<p>数据的目标分区数（如果启用了分区）。如果生产者已分区，则必须将其设置为大于1的值。在Kafka上，它被解释为提示。取其较大者，并使用目标主题的分区数。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">requiredGroups</dt>
<dd>
<p>生产者必须确保将消息传递到的组的逗号分隔列表，即使它们是在创建消息之后开始的（例如，通过在RabbitMQ中预先创建持久队列）。</p>
</dd>
<dt class="hdlist1">headerMode</dt>
<dd>
<p>设置为<code>none</code> ，它会禁用在输出中嵌入标头。它仅对本身不支持消息头并且需要消息头嵌入的消息中间件有效。当不支持本机头时，在为非Spring Cloud Stream应用程序生成数据时，此选项很有用。设置为<code>headers</code> ，它使用中间件的本机头机制。设置为<code>embeddedHeaders</code> ，它将标头嵌入到消息有效负载中。</p>
<div class="paragraph">
<p>默认值：取决于活页夹的实现。</p>
</div>
</dd>
<dt class="hdlist1">useNativeEncoding</dt>
<dd>
<p>设置为<code>true</code> ，则出站消息将直接由客户端库进行序列化，该库必须进行相应配置（例如，设置适当的Kafka生产者值序列化程序）。使用此配置时，出站邮件编组不是基于<code>contentType</code>的绑定。使用本机编码时，使用方有责任使用适当的解码器（例如，Kafka使用方值反序列化器）对入站消息进行反序列化。此外，当使用本机编码和解码时， <code>headerMode=embeddedHeaders</code>属性将被忽略，并且标头未嵌入消息中。查看消费者财产<code>useNativeDecoding</code> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">errorChannelEnabled</dt>
<dd>
<p>设置为<code>true</code> ，如果活页夹支持异步发送结果，则发送失败将发送到目标的错误通道。有关更多信息，请参见“ <a href="#binder-error-channels">[binder-error-channels]</a> ”。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dynamicdestination"><a class="anchor" href="#dynamicdestination"></a> <a class="link" href="#dynamicdestination">21.8.3。使用动态绑定的目的地</a></h4>
<div class="paragraph">
<p>除了使用定义的渠道<code>@EnableBinding</code> ，Spring Cloud Stream使应用程序可以将消息发送到动态绑定的目标。例如，当需要在运行时确定目标目的地时，这很有用。应用程序可以通过使用<code>BinderAwareChannelResolver</code> Bean，由<code>@EnableBinding</code>注解。</p>
</div>
<div class="paragraph">
<p>“ spring.cloud.stream.dynamicDestinations”属性可用于将动态目标名称限制为已知集合（白名单）。如果未设置此属性，则可以动态绑定任何目标。</p>
</div>
<div class="paragraph">
<p>的<code>BinderAwareChannelResolver</code>可以直接使用，如以下使用路径变量确定目标通道的REST控制器示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

    @Autowired
    private BinderAwareChannelResolver resolver;

    @RequestMapping(path = "/{target}", method = POST, consumes = "*/*")
    @ResponseStatus(HttpStatus.ACCEPTED)
    public void handleRequest(@RequestBody String body, @PathVariable("target") target,
           @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
        sendMessage(body, target, contentType);
    }

    private void sendMessage(String body, String target, Object contentType) {
        resolver.resolveDestination(target).send(MessageBuilder.createMessage(body,
                new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在考虑当我们在默认端口（8080）上启动应用程序并使用CURL发出以下请求时会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>curl -H "Content-Type: application/json" -X POST -d "customer-1" http://localhost:8080/customers

curl -H "Content-Type: application/json" -X POST -d "order-1" http://localhost:8080/orders</pre>
</div>
</div>
<div class="paragraph">
<p>在代理中创建目的地“客户”和“订单”（在Rabbit的交换中或在Kafka的主题中），名称为“客户”和“订单”，并将数据发布到适当的目的地。</p>
</div>
<div class="paragraph">
<p>的<code>BinderAwareChannelResolver</code>是通用的Spring Integration <code>DestinationResolver</code>并可以注入到其他组件中，例如，在基于SpEL表达式的路由器中<code>target</code>传入JSON消息的字段。以下示例包含一个读取SpEL表达式的路由器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding
@Controller
public class SourceWithDynamicDestination {

    @Autowired
    private BinderAwareChannelResolver resolver;


    @RequestMapping(path = "/", method = POST, consumes = "application/json")
    @ResponseStatus(HttpStatus.ACCEPTED)
    public void handleRequest(@RequestBody String body, @RequestHeader(HttpHeaders.CONTENT_TYPE) Object contentType) {
        sendMessage(body, contentType);
    }

    private void sendMessage(Object body, Object contentType) {
        routerChannel().send(MessageBuilder.createMessage(body,
                new MessageHeaders(Collections.singletonMap(MessageHeaders.CONTENT_TYPE, contentType))));
    }

    @Bean(name = "routerChannel")
    public MessageChannel routerChannel() {
        return new DirectChannel();
    }

    @Bean
    @ServiceActivator(inputChannel = "routerChannel")
    public ExpressionEvaluatingRouter router() {
        ExpressionEvaluatingRouter router =
            new ExpressionEvaluatingRouter(new SpelExpressionParser().parseExpression("payload.target"));
        router.setDefaultOutputChannelName("default-output");
        router.setChannelResolver(resolver);
        return router;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-cloud-stream-app-starters/router">路由器接收器应用程序</a>使用此技术按需创建目的地。</p>
</div>
<div class="paragraph">
<p>如果预先知道通道名称，则可以像其他任何目的地一样配置生产者属性。或者，如果您注册一个<code>NewBindingCallback<></code> Bean，就在创建绑定之前调用它。回调采用绑定程序使用的扩展生产者属性的通用类型。它有一种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void configure(String channelName, MessageChannel channel, ProducerProperties producerProperties,
        T extendedProducerProperties);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何使用RabbitMQ绑定器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public NewBindingCallback<RabbitProducerProperties> dynamicConfigurer() {
    return (name, channel, props, extended) -> {
        props.setRequiredGroups("bindThisQueue");
        extended.setQueueNameGroupOnly(true);
        extended.setAutoBindDlq(true);
        extended.setDeadLetterQueueName("myDLQ");
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">如果您需要支持具有多种活页夹类型的动态目标，请使用<code>Object</code>泛型类型并强制转换<code>extended</code>根据需要争论。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="content-type-management"><a class="anchor" href="#content-type-management"></a> <a class="link" href="#content-type-management">21.9。内容类型协商</a></h3>
<div class="paragraph">
<p>数据转换是任何消息驱动的微服务体系结构的核心功能之一。鉴于此，在Spring Cloud Stream中，此类数据表示为Spring <code>Message</code> ，则可能必须先将邮件转换为所需的形状或大小，然后才能到达目的地。这样做有两个原因：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>转换传入消息的内容以匹配应用程序提供的处理程序的签名。</p>
</li>
<li>
<p>将外发邮件的内容转换为有线格式。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>有线格式通常是<code>byte[]</code> （对于Kafka和Rabbit活页夹而言，这是正确的），但它受活页夹实现的支配。</p>
</div>
<div class="paragraph">
<p>在Spring Cloud Stream中，消息转换是通过<code>org.springframework.messaging.converter.MessageConverter</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">作为后续细节的补充，您可能还需要阅读以下<a href="https://spring.io/blog/2018/02/26/spring-cloud-stream-2-0-content-type-negotiation-and-transformation">博客文章</a> 。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="mechanics"><a class="anchor" href="#mechanics"></a> <a class="link" href="#mechanics">21.9.1。机械学</a></h4>
<div class="paragraph">
<p>为了更好地理解内容类型协商的机制和必要性，我们以下面的消息处理程序为例，看一个非常简单的用例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@StreamListener(Processor.INPUT)
@SendTo(Processor.OUTPUT)
public String handle(Person person) {..}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">为简单起见，我们假设这是应用程序中唯一的处理程序（我们假设没有内部管道）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面示例中显示的处理程序期望一个<code>Person</code>对象作为参数并产生一个<code>String</code>输入作为输出。为了使框架成功传递传入的信息<code>Message</code>作为此处理程序的参数，它必须以某种方式转换<code>Message</code>从电汇格式输入到<code>Person</code>类型。换句话说，框架必须找到并应用适当的<code>MessageConverter</code> 。为此，框架需要用户的一些指示。这些指令之一已由处理程序方法本身的签名提供（ <code>Person</code>类型）。因此，从理论上讲，这应该是（并且在某些情况下是足够的）。但是，对于大多数用例来说，为了选择合适的<code>MessageConverter</code> ，框架需要其他信息。那块缺失的是<code>contentType</code> 。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream提供了三种机制来定义<code>contentType</code> （按优先顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>标题</strong> ： <code>contentType</code>可以通过消息本身进行通信。通过提供<code>contentType</code>标头，则声明要用于查找和应用适当内容的内容类型<code>MessageConverter</code> 。</p>
</li>
<li>
<p><strong>绑定</strong> ： <code>contentType</code>可以通过设置目标绑定来设置<code>spring.cloud.stream.bindings.input.content-type</code>属性。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>input</code>属性名称中的句段对应于目的地的实际名称（在我们的示例中为“输入”）。通过这种方法，您可以按绑定声明用于查找和应用适当内容的内容类型。 <code>MessageConverter</code> 。
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><strong>默认值</strong> ：如果<code>contentType</code>不存在于<code>Message</code>标头或绑定，默认<code>application/json</code>内容类型用于查找和应用适当的内容<code>MessageConverter</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如前所述，前面的列表还演示了平局时的优先顺序。例如，标头提供的内容类型优先于任何其他内容类型。对于按绑定设置的内容类型也是如此，这实际上使您可以覆盖默认内容类型。但是，它也提供了明智的默认设置（由社区反馈确定）。</p>
</div>
<div class="paragraph">
<p>制作的另一个原因<code>application/json</code>默认值来自分布式微服务架构所驱动的互操作性要求，在该架构中，生产者和使用者不仅可以在不同的JVM中运行，而且还可以在不同的非JVM平台上运行。</p>
</div>
<div class="paragraph">
<p>当非无效处理程序方法返回时，如果返回值已经是<code>Message</code> ， <code>Message</code>成为有效载荷。但是，当返回值不是<code>Message</code> ， 新的<code>Message</code>以返回值作为有效载荷构造，同时从输入继承标头<code>Message</code>减去定义或过滤的标头<code>SpringIntegrationProperties.messageHandlerNotPropagatedHeaders</code> 。默认情况下，仅设置一个标头： <code>contentType</code> 。这意味着新<code>Message</code>不具有<code>contentType</code>标头设置，从而确保<code>contentType</code>可以进化。您随时可以选择不返回<code>Message</code>从处理程序方法中，您可以在其中注入所需的任何标头。</p>
</div>
<div class="paragraph">
<p>如果有内部管道， <code>Message</code>通过相同的转换过程被发送到下一个处理程序。但是，如果没有内部管道或您已经到达内部管道的末端， <code>Message</code>被发送回输出目的地。</p>
</div>
<div class="sect4">
<h5 id="content-type-versus-argument-type"><a class="anchor" href="#content-type-versus-argument-type"></a> <a class="link" href="#content-type-versus-argument-type">内容类型与参数类型</a></h5>
<div class="paragraph">
<p>如前所述，为框架选择合适的<code>MessageConverter</code> ，它需要参数类型以及（可选）内容类型信息。选择合适的逻辑<code>MessageConverter</code>与参数解析器（ <code>HandlerMethodArgumentResolvers</code> ），它会在调用用户定义的处理程序方法之前触发（这是在框架知道实际参数类型时）。如果参数类型与当前有效负载的类型不匹配，则框架将委派给预先配置的堆栈<code>MessageConverters</code>看看其中任何一个都可以转换有效载荷。如您所见， <code>Object fromMessage(Message<?> message, Class<?> targetClass);</code> MessageConverter的操作需要<code>targetClass</code>作为其论点之一。该框架还确保提供的<code>Message</code>总是包含一个<code>contentType</code>标头。当没有contentType标头时，它将注入每个绑定<code>contentType</code>标头或默认<code>contentType</code>标头。的结合<code>contentType</code>参数类型是框架确定消息是否可以转换为目标类型的机制。如果不合适<code>MessageConverter</code>找到后，将引发异常，您可以通过添加自定义来处理<code>MessageConverter</code> （请参阅“ <a href="#spring-cloud-stream-overview-user-defined-message-converters">用户定义的消息转换器</a> ”）。</p>
</div>
<div class="paragraph">
<p>但是，如果有效负载类型与处理程序方法声明的目标类型匹配，该怎么办？在这种情况下，没有任何要转换的内容，并且有效载荷未经修改地传递。尽管这听起来很简单且合乎逻辑，但请记住使用一个<code>Message<?></code>要么<code>Object</code>作为争论。通过声明目标类型为<code>Object</code> （这是一个<code>instanceof</code> Java中的所有内容），您实际上就放弃了转换过程。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不要指望<code>Message</code>仅根据<code>contentType</code> 。请记住<code>contentType</code>与目标类型互补。如果您愿意，可以提供一个提示， <code>MessageConverter</code>可能会或可能不会考虑。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="message-converters"><a class="anchor" href="#message-converters"></a> <a class="link" href="#message-converters">讯息转换器</a></h5>
<div class="paragraph">
<p><code>MessageConverters</code>定义两种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object fromMessage(Message<?> message, Class<?> targetClass);

Message<?> toMessage(Object payload, @Nullable MessageHeaders headers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>了解这些方法的约定及其用法非常重要，尤其是在Spring Cloud Stream的上下文中。</p>
</div>
<div class="paragraph">
<p>的<code>fromMessage</code>方法转换传入的<code>Message</code>到参数类型。的有效载荷<code>Message</code>可以是任何类型，这取决于实际的实施<code>MessageConverter</code>支持多种类型。例如，某些JSON转换器可能支持有效负载类型为<code>byte[]</code> ， <code>String</code> ， 和别的。当应用程序包含内部管道（即，输入→handler1→handler2→..→→输出）并且上游处理程序的输出结果为<code>Message</code>可能不是初始电汇格式。</p>
</div>
<div class="paragraph">
<p>然而<code>toMessage</code>方法具有更严格的合同，必须始终转换<code>Message</code>转换为电汇格式： <code>byte[]</code> 。</p>
</div>
<div class="paragraph">
<p>因此，出于所有意图和目的（尤其是在实现自己的转换器时），您将这两种方法视为具有以下签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object fromMessage(Message<?> message, Class<?> targetClass);

Message<byte[]> toMessage(Object payload, @Nullable MessageHeaders headers);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="provided-messageconverters"><a class="anchor" href="#provided-messageconverters"></a> <a class="link" href="#provided-messageconverters">21.9.2。提供的MessageConverters</a></h4>
<div class="paragraph">
<p>如前所述，该框架已经提供了<code>MessageConverters</code>处理最常见的用例。以下列表描述了所提供的<code>MessageConverters</code> ，按优先顺序（第一个<code>MessageConverter</code>使用有效的）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>ApplicationJsonMessageMarshallingConverter</code> ：的变化<code>org.springframework.messaging.converter.MappingJackson2MessageConverter</code> 。支持转换有效载荷<code>Message</code>在以下情况下往返POJO <code>contentType</code>是<code>application/json</code> （默认）。</p>
</li>
<li>
<p><code>TupleJsonMessageConverter</code> ：已<strong>弃用</strong>支持转换有效负载<code>Message</code>往/返<code>org.springframework.tuple.Tuple</code> 。</p>
</li>
<li>
<p><code>ByteArrayMessageConverter</code> ：支持转换有效负载<code>Message</code>从<code>byte[]</code>至<code>byte[]</code>对于情况<code>contentType</code>是<code>application/octet-stream</code> 。它本质上是一个传递，主要是为了向后兼容而存在。</p>
</li>
<li>
<p><code>ObjectStringMessageConverter</code> ：支持将任何类型转换为<code>String</code>什么时候<code>contentType</code>是<code>text/plain</code> 。它调用对象的<code>toString()</code>方法，或者如果有效载荷是<code>byte[]</code> ，一个新的<code>String(byte[])</code> 。</p>
</li>
<li>
<p><code>JavaSerializationMessageConverter</code> ： <strong>DEPRECATED在以下情况下</strong>支持基于Java序列化的转换<code>contentType</code>是<code>application/x-java-serialized-object</code> 。</p>
</li>
<li>
<p><code>KryoMessageConverter</code> ： <strong>弃用时</strong>支持基于Kryo序列化的转换<code>contentType</code>是<code>application/x-java-object</code> 。</p>
</li>
<li>
<p><code>JsonUnmarshallingConverter</code> ：类似于<code>ApplicationJsonMessageMarshallingConverter</code> 。它支持任何类型的转换<code>contentType</code>是<code>application/x-java-object</code> 。它期望将实际类型信息嵌入到<code>contentType</code>作为属性（例如， <code>application/x-java-object;type=foo.bar.Cat</code> ）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当找不到合适的转换器时，框架将引发异常。发生这种情况时，您应该检查代码和配置，并确保您没有错过任何内容（即，确保您提供了<code>contentType</code>通过使用绑定或标头）。但是，很可能您发现了一些不常见的情况（例如自定义<code>contentType</code>可能）和当前提供的堆栈<code>MessageConverters</code>不知道如何转换。如果是这样，您可以添加自定义<code>MessageConverter</code> 。请参阅<a href="#spring-cloud-stream-overview-user-defined-message-converters">用户定义的消息转换器</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-user-defined-message-converters"><a class="anchor" href="#spring-cloud-stream-overview-user-defined-message-converters"></a> <a class="link" href="#spring-cloud-stream-overview-user-defined-message-converters">21.9.3。用户定义的消息转换器</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream公开了定义和注册其他机制<code>MessageConverters</code> 。要使用它，实现<code>org.springframework.messaging.converter.MessageConverter</code> ，将其配置为<code>@Bean</code> ，并用<code>@StreamMessageConverter</code> 。然后将其追加到MessageConverter的现有堆栈中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">重要的是要了解习惯<code>MessageConverter</code>实现被添加到现有堆栈的头部。因此，习惯<code>MessageConverter</code>实施优先于现有的实施，这使您可以覆盖以及添加到现有的转换器中。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下面的示例演示如何创建消息转换器Bean以支持称为<code>application/bar</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

    ...

    @Bean
    @StreamMessageConverter
    public MessageConverter customMessageConverter() {
        return new MyCustomMessageConverter();
    }
}

public class MyCustomMessageConverter extends AbstractMessageConverter {

    public MyCustomMessageConverter() {
        super(new MimeType("application", "bar"));
    }

    @Override
    protected boolean supports(Class<?> clazz) {
        return (Bar.class.equals(clazz));
    }

    @Override
    protected Object convertFromInternal(Message<?> message, Class<?> targetClass, Object conversionHint) {
        Object payload = message.getPayload();
        return (payload instanceof Bar ? payload : new Bar((byte[]) payload));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Stream还支持基于Avro的转换器和模式演变。有关详细信息，请参见“ <a href="#schema-evolution">模式演化支持</a> ”。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schema-evolution"><a class="anchor" href="#schema-evolution"></a> <a class="link" href="#schema-evolution">21.10。模式演进支持</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream提供了对模式演化的支持，因此数据可以随着时间的推移而演化，并且仍然可以与较新或较旧的生产者和消费者一起使用，反之亦然。大多数序列化模型，尤其是旨在跨不同平台和语言进行移植的模型，都依赖于一种描述如何在二进制有效负载中序列化数据的模式。为了序列化数据然后解释它，发送方和接收方都必须有权访问描述二进制格式的模式。在某些情况下，可以从序列化时的有效负载类型或反序列化时的目标类型推断模式。但是，许多应用程序都可以从访问描述二进制数据格式的显式架构中受益。使用模式注册表，您可以以文本格式（通常为JSON）存储模式信息，并使该信息可用于需要它以二进制格式接收和发送数据的各种应用程序。模式可引用为一个元组，该元组包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>主题，是架构的逻辑名称</p>
</li>
<li>
<p>模式版本</p>
</li>
<li>
<p>模式格式，描述数据的二进制格式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下各节详细介绍了架构演变过程中涉及的各种组件。</p>
</div>
<div class="sect3">
<h4 id="schema-registry-client"><a class="anchor" href="#schema-registry-client"></a> <a class="link" href="#schema-registry-client">21.10.1。架构注册表客户端</a></h4>
<div class="paragraph">
<p>与架构注册表服务器进行交互的客户端抽象是<code>SchemaRegistryClient</code>界面，其结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SchemaRegistryClient {

    SchemaRegistrationResponse register(String subject, String format, String schema);

    String fetch(SchemaReference schemaReference);

    String fetch(Integer id);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Stream提供了开箱即用的实现，可用于与其自己的模式服务器进行交互以及与Confluent Schema Registry进行交互。</p>
</div>
<div class="paragraph">
<p>可以使用以下命令配置Spring Cloud Stream模式注册表的客户端<code>@EnableSchemaRegistryClient</code> ， 如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">  @EnableBinding(Sink.class)
  @SpringBootApplication
  @EnableSchemaRegistryClient
  public static class AvroSinkApplication {
    ...
  }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">默认转换器经过优化，不仅可以缓存远程服务器的架构，还可以缓存远程服务器的架构。 <code>parse()</code>和<code>toString()</code>方法，这很昂贵。因此，它使用了<code>DefaultSchemaRegistryClient</code>不缓存响应。如果要更改默认行为，则可以直接在代码上使用客户端，并将其覆盖为所需的结果。为此，您必须添加属性<code>spring.cloud.stream.schemaRegistryClient.cached=true</code>您的应用程序属性。
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="schema-registry-client-properties"><a class="anchor" href="#schema-registry-client-properties"></a> <a class="link" href="#schema-registry-client-properties">架构注册表客户端属性</a></h5>
<div class="paragraph">
<p>架构注册表客户端支持以下属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>spring.cloud.stream.schemaRegistryClient.endpoint</code></dt>
<dd>
<p>模式服务器的位置。进行设置时，请使用完整的URL，包括协议（ <code>http</code>要么<code>https</code> ），端口和上下文路径。</p>
</dd>
<dt class="hdlist1">默认</dt>
<dd>
<p><code><a href="http://localhost:8990/" class="bare">localhost:8990/</a></code></p>
</dd>
<dt class="hdlist1"><code>spring.cloud.stream.schemaRegistryClient.cached</code></dt>
<dd>
<p>客户端是否应缓存架构服务器响应。通常设置为<code>false</code> ，因为缓存发生在消息转换器中。使用架构注册表客户端的客户端应将此设置为<code>true</code> 。</p>
</dd>
<dt class="hdlist1">默认</dt>
<dd>
<p><code>true</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="avro-schema-registry-client-message-converters"><a class="anchor" href="#avro-schema-registry-client-message-converters"></a> <a class="link" href="#avro-schema-registry-client-message-converters">21.10.2。Avro Schema Registry客户端消息转换器</a></h4>
<div class="paragraph">
<p>对于已向应用程序上下文注册了SchemaRegistryClient Bean的应用程序，Spring Cloud Stream会自动配置Apache Avro消息转换器以进行模式管理。由于接收消息的应用程序可以轻松访问可以与自己的读取器模式进行协调的写入器模式，因此这简化了模式的演变。</p>
</div>
<div class="paragraph">
<p>对于出站邮件，如果通道的内容类型设置为<code>application/*+avro</code> ， <code>MessageConverter</code>被激活，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">spring.cloud.stream.bindings.output.contentType=application/*+avro</code></pre>
</div>
</div>
<div class="paragraph">
<p>在出站转换期间，消息转换器将尝试推断每个出站消息的模式（基于其类型），并使用以下命令将其注册到主题（基于有效负载类型） <code>SchemaRegistryClient</code> 。如果已经找到相同的模式，则将检索对其的引用。如果不是，则注册架构，并提供新的版本号。邮件发送时带有<code>contentType</code>标头使用以下方案： <code>application/[prefix].[subject].v[version]+avro</code> ，在哪里<code>prefix</code>是可配置的<code>subject</code>从有效载荷类型推导得出。</p>
</div>
<div class="paragraph">
<p>例如，以下类型的消息<code>User</code>可能以内容类型为<code>application/vnd.user.v2+avro</code> ，在哪里<code>user</code>是主题， <code>2</code>是版本号。</p>
</div>
<div class="paragraph">
<p>接收消息时，转换器从传入消息的头中推断模式引用，并尝试检索它。该模式在反序列化过程中用作编写器模式。</p>
</div>
<div class="sect4">
<h5 id="avro-schema-registry-message-converter-properties"><a class="anchor" href="#avro-schema-registry-message-converter-properties"></a> <a class="link" href="#avro-schema-registry-message-converter-properties">Avro架构注册表消息转换器属性</a></h5>
<div class="paragraph">
<p>如果通过设置启用了基于Avro的架构注册表客户端<code>spring.cloud.stream.bindings.output.contentType=application/*+avro</code> ，您可以通过设置以下属性来自定义注册行为。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</dt>
<dd>
<p>如果希望转换器使用反射从POJO推断模式，则启用。</p>
<div class="paragraph">
<p>默认：<code>false</code></p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.schema.avro.readerSchema</dt>
<dd>
<p>Avro通过查看写入器模式（原始有效负载）和读取器模式（您的应用程序有效负载）来比较模式版本。有关更多信息，请参见<a href="https://avro.apache.org/docs/1.7.6/spec.html">Avro文档</a> 。如果设置，它将覆盖模式服务器上的所有查找，并将本地模式用作读取器模式。默认：<code>null</code></p>
</dd>
<dt class="hdlist1">spring.cloud.stream.schema.avro.schema位置</dt>
<dd>
<p>注册任何<code>.avsc</code>模式服务器中此属性中列出的文件。</p>
<div class="paragraph">
<p>默认：<code>empty</code></p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.schema.avro.prefix</dt>
<dd>
<p>Content-Type标头上要使用的前缀。</p>
<div class="paragraph">
<p>默认：<code>vnd</code></p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="apache-avro-message-converters"><a class="anchor" href="#apache-avro-message-converters"></a> <a class="link" href="#apache-avro-message-converters">21.10.3。Apache Avro消息转换器</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream通过其Spring Cloud Stream支持基于模式的消息转换器<code>spring-cloud-stream-schema</code>模块。当前，基于模式的消息转换器唯一支持的开箱即用的序列化格式是Apache Avro，将来的版本中将添加更多格式。</p>
</div>
<div class="paragraph">
<p>的<code>spring-cloud-stream-schema</code>模块包含可用于Apache Avro序列化的两种消息转换器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>转换器使用序列化或反序列化对象的类信息或在启动时具有已知位置的模式。</p>
</li>
<li>
<p>使用架构注册表的转换器。它们在运行时定位架构，并随着域对象的发展动态注册新架构。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="converters-with-schema-support"><a class="anchor" href="#converters-with-schema-support"></a> <a class="link" href="#converters-with-schema-support">21.10.4。具有模式支持的转换器</a></h4>
<div class="paragraph">
<p>的<code>AvroSchemaMessageConverter</code>通过使用预定义的架构或使用类中可用的架构信息（以反射方式或包含在<code>SpecificRecord</code> ）。如果提供自定义转换器，则不会创建默认的AvroSchemaMessageConverter bean。以下示例显示了一个自定义转换器：</p>
</div>
<div class="paragraph">
<p>要使用自定义转换器，只需将其添加到应用程序上下文中，可以选择指定一个或多个<code>MimeTypes</code>与之关联。默认值<code>MimeType</code>是<code>application/avro</code> 。</p>
</div>
<div class="paragraph">
<p>如果转化的目标类型是<code>GenericRecord</code> ，必须设置一个架构。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何通过注册Apache Avro在接收器应用程序中配置转换器<code>MessageConverter</code>没有预定义的架构。在此示例中，请注意，MIME类型值是<code>avro/bytes</code> ，而不是默认值<code>application/avro</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      return new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，以下应用程序使用预定义的架构（在类路径上找到）注册一个转换器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@EnableBinding(Sink.class)
@SpringBootApplication
public static class SinkApplication {

  ...

  @Bean
  public MessageConverter userMessageConverter() {
      AvroSchemaMessageConverter converter = new AvroSchemaMessageConverter(MimeType.valueOf("avro/bytes"));
      converter.setSchemaLocation(new ClassPathResource("schemas/User.avro"));
      return converter;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="schema-registry-server"><a class="anchor" href="#schema-registry-server"></a> <a class="link" href="#schema-registry-server">21.10.5。架构注册表服务器</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream提供了架构注册表服务器实现。要使用它，您可以添加<code>spring-cloud-stream-schema-server</code>项目的工件，并使用<code>@EnableSchemaRegistryServer</code>注释，它将架构注册表服务器REST控制器添加到您的应用程序。该注释旨在与Spring Boot Web应用程序一起使用，并且服务器的侦听端口由<code>server.port</code>属性。的<code>spring.cloud.stream.schema.server.path</code>属性可以用于控制模式服务器的根路径（尤其是当它嵌入在其他应用程序中时）。的<code>spring.cloud.stream.schema.server.allowSchemaDeletion</code>布尔属性允许删除架构。默认情况下，这是禁用的。</p>
</div>
<div class="paragraph">
<p>架构注册表服务器使用关系数据库来存储架构。默认情况下，它使用嵌入式数据库。您可以使用<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-sql">Spring Boot SQL数据库和JDBC配置选项</a>来自定义模式存储。</p>
</div>
<div class="paragraph">
<p>以下示例显示了启用架构注册表的Spring Boot应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableSchemaRegistryServer
public class SchemaRegistryServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(SchemaRegistryServerApplication.class, args);
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="schema-registry-server-api"><a class="anchor" href="#schema-registry-server-api"></a> <a class="link" href="#schema-registry-server-api">架构注册表服务器API</a></h5>
<div class="paragraph">
<p>Schema Registry Server API包含以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>POST /</code> —请参阅“ <a href="#spring-cloud-stream-overview-registering-new-schema">注册新模式</a> ”</p>
</li>
<li>
<p>'GET / {subject} / {format} / {version}'-请参阅“ <a href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version">按主题，格式和版本检索现有模式</a> ”</p>
</li>
<li>
<p><code>GET /{subject}/{format}</code> —请参阅“ <a href="#spring-cloud-stream-overview-retrieve-schema-subject-format">按主题和格式检索现有模式</a> ”</p>
</li>
<li>
<p><code>GET /schemas/{id}</code> —请参阅“ <a href="#spring-cloud-stream-overview-retrieve-schema-id">通过ID检索现有模式</a> ”</p>
</li>
<li>
<p><code>DELETE /{subject}/{format}/{version}</code> —请参阅“ <a href="#spring-cloud-stream-overview-deleting-schema-subject-format-version">按主题，格式和版本删除架构</a> ”</p>
</li>
<li>
<p><code>DELETE /schemas/{id}</code> —请参阅“ <a href="#spring-cloud-stream-overview-deleting-schema-id">按ID删除架构</a> ”</p>
</li>
<li>
<p><code>DELETE /{subject}</code> —请参阅“ <a href="#spring-cloud-stream-overview-deleting-schema-subject">按主题删除架构</a> ”</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-registering-new-schema"><a class="anchor" href="#spring-cloud-stream-overview-registering-new-schema"></a> <a class="link" href="#spring-cloud-stream-overview-registering-new-schema">注册新架构</a></h6>
<div class="paragraph">
<p>要注册新架构，请发送<code>POST</code>要求<code>/</code>端点。</p>
</div>
<div class="paragraph">
<p>的<code>/</code>接受具有以下字段的JSON有效负载：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject</code> ：架构主题</p>
</li>
<li>
<p><code>format</code> ：架构格式</p>
</li>
<li>
<p><code>definition</code> ：模式定义</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它的响应是JSON中的架构对象，具有以下字段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> ：模式ID</p>
</li>
<li>
<p><code>subject</code> ：架构主题</p>
</li>
<li>
<p><code>format</code> ：架构格式</p>
</li>
<li>
<p><code>version</code> ：模式版本</p>
</li>
<li>
<p><code>definition</code> ：模式定义</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-retrieve-schema-subject-format-version"><a class="anchor" href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version"></a> <a class="link" href="#spring-cloud-stream-overview-retrieve-schema-subject-format-version">通过主题，格式和版本检索现有架构</a></h6>
<div class="paragraph">
<p>要按主题，格式和版本检索现有模式，请发送<code>GET</code>要求<code>/{subject}/{format}/{version}</code>端点。</p>
</div>
<div class="paragraph">
<p>它的响应是JSON中的架构对象，具有以下字段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> ：模式ID</p>
</li>
<li>
<p><code>subject</code> ：架构主题</p>
</li>
<li>
<p><code>format</code> ：架构格式</p>
</li>
<li>
<p><code>version</code> ：模式版本</p>
</li>
<li>
<p><code>definition</code> ：模式定义</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-retrieve-schema-subject-format"><a class="anchor" href="#spring-cloud-stream-overview-retrieve-schema-subject-format"></a> <a class="link" href="#spring-cloud-stream-overview-retrieve-schema-subject-format">通过主题和格式检索现有模式</a></h6>
<div class="paragraph">
<p>要按主题和格式检索现有架构，请发送<code>GET</code>要求<code>/subject/format</code>端点。</p>
</div>
<div class="paragraph">
<p>它的响应是JSON中每个模式对象的模式列表，其中包含以下字段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> ：模式ID</p>
</li>
<li>
<p><code>subject</code> ：架构主题</p>
</li>
<li>
<p><code>format</code> ：架构格式</p>
</li>
<li>
<p><code>version</code> ：模式版本</p>
</li>
<li>
<p><code>definition</code> ：模式定义</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-retrieve-schema-id"><a class="anchor" href="#spring-cloud-stream-overview-retrieve-schema-id"></a> <a class="link" href="#spring-cloud-stream-overview-retrieve-schema-id">通过ID检索现有架构</a></h6>
<div class="paragraph">
<p>要通过其ID检索架构，请发送一个<code>GET</code>要求<code>/schemas/{id}</code>端点。</p>
</div>
<div class="paragraph">
<p>它的响应是JSON中的架构对象，具有以下字段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> ：模式ID</p>
</li>
<li>
<p><code>subject</code> ：架构主题</p>
</li>
<li>
<p><code>format</code> ：架构格式</p>
</li>
<li>
<p><code>version</code> ：模式版本</p>
</li>
<li>
<p><code>definition</code> ：模式定义</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-deleting-schema-subject-format-version"><a class="anchor" href="#spring-cloud-stream-overview-deleting-schema-subject-format-version"></a> <a class="link" href="#spring-cloud-stream-overview-deleting-schema-subject-format-version">按主题，格式和版本删除架构</a></h6>
<div class="paragraph">
<p>要删除由其主题，格式和版本标识的架构，请发送<code>DELETE</code>要求<code>/{subject}/{format}/{version}</code>端点。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-deleting-schema-id"><a class="anchor" href="#spring-cloud-stream-overview-deleting-schema-id"></a> <a class="link" href="#spring-cloud-stream-overview-deleting-schema-id">通过ID删除架构</a></h6>
<div class="paragraph">
<p>要通过其ID删除架构，请发送一个<code>DELETE</code>要求<code>/schemas/{id}</code>端点。</p>
</div>
</div>
<div class="sect5">
<h6 id="spring-cloud-stream-overview-deleting-schema-subject"><a class="anchor" href="#spring-cloud-stream-overview-deleting-schema-subject"></a> <a class="link" href="#spring-cloud-stream-overview-deleting-schema-subject">按主题删除架构</a></h6>
<div class="paragraph">
<p><code>DELETE /{subject}</code></p>
</div>
<div class="paragraph">
<p>按主题删除现有架构。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">本说明适用于Spring Cloud Stream 1.1.0的用户。仅发布。Spring Cloud Stream 1.1.0。使用表名RELEASE， <code>schema</code> ，用于存储<code>Schema</code>对象。 <code>Schema</code>是许多数据库实现中的关键字。为了避免将来发生任何冲突，从1.1.1开始。发布，我们选择了这个名字<code>SCHEMA_REPOSITORY</code>用于存储表。任何Spring Cloud Stream 1.1.0。升级的RELEASE用户应在升级之前将其现有模式迁移到新表。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-confluents-schema-registry"><a class="anchor" href="#using-confluents-schema-registry"></a> <a class="link" href="#using-confluents-schema-registry">使用Confluent的架构注册表</a></h5>
<div class="paragraph">
<p>默认配置会创建一个<code>DefaultSchemaRegistryClient</code>豆。如果要使用Confluent模式注册表，则需要创建一个类型为bean的bean。 <code>ConfluentSchemaRegistryClient</code> ，它取代了框架默认配置的框架。以下示例显示了如何创建这样的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Bean
public SchemaRegistryClient schemaRegistryClient(@Value("${spring.cloud.stream.schemaRegistryClient.endpoint}") String endpoint){
  ConfluentSchemaRegistryClient client = new ConfluentSchemaRegistryClient();
  client.setEndpoint(endpoint);
  return client;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">ConfluentSchemaRegistryClient已针对Confluent平台4.0.0版进行了测试。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="schema-registration-and-resolution"><a class="anchor" href="#schema-registration-and-resolution"></a> <a class="link" href="#schema-registration-and-resolution">21.10.6。模式注册和解析</a></h4>
<div class="paragraph">
<p>为了更好地了解Spring Cloud Stream如何注册和解析新模式及其对Avro模式比较功能的使用，我们提供了两个单独的小节：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“ <a href="#spring-cloud-stream-overview-schema-registration-process">模式注册过程（序列化）</a> ”</p>
</li>
<li>
<p>“ <a href="#spring-cloud-stream-overview-schema-resolution-process">模式解析过程（反序列化）</a> ”</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-schema-registration-process"><a class="anchor" href="#spring-cloud-stream-overview-schema-registration-process"></a> <a class="link" href="#spring-cloud-stream-overview-schema-registration-process">模式注册过程（序列化）</a></h5>
<div class="paragraph">
<p>注册过程的第一部分是从通过通道发送的有效负载中提取模式。Avro类型，例如<code>SpecificRecord</code>要么<code>GenericRecord</code>已经包含一个架构，可以从实例中立即检索该架构。对于POJO，如果<code>spring.cloud.stream.schema.avro.dynamicSchemaGenerationEnabled</code>属性设置为<code>true</code> （默认）。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/schema_resolution.png" alt="模式解析" width="800">
</div>
<div class="title">图14。模式编写器解析过程</div>
</div>
<div class="paragraph">
<p>获得一个模式，转换器从远程服务器加载其元数据（版本）。首先，它查询本地缓存。如果未找到结果，它将数据提交给服务器，服务器将提供版本信息。转换器始终缓存结果，以避免为每个需要序列化的新消息查询Schema Server的开销。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/registration.png" alt="注册" width="800">
</div>
<div class="title">图15。模式注册过程</div>
</div>
<div class="paragraph">
<p>利用架构版本信息，转换器将设置<code>contentType</code>消息的标题，以携带版本信息，例如： <code>application/vnd.user.v1+avro</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-schema-resolution-process"><a class="anchor" href="#spring-cloud-stream-overview-schema-resolution-process"></a> <a class="link" href="#spring-cloud-stream-overview-schema-resolution-process">模式解析过程（反序列化）</a></h5>
<div class="paragraph">
<p>阅读包含版本信息的消息时（即， <code>contentType</code>标头采用类似于“ <a href="#spring-cloud-stream-overview-schema-registration-process">模式注册过程（序列化）</a> ”中所述的方案），转换器将查询模式服务器以获取消息的编写者模式。一旦找到了传入消息的正确架构，它将检索阅读器架构，并使用Avro的架构解析支持将其读入阅读器定义（设置默认值和所有缺少的属性）。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/schema_reading.png" alt="模式阅读" width="800">
</div>
<div class="title">图16。模式阅读解析过程</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">您应该了解编写者架构（编写消息的应用程序）和阅读者架构（接收应用程序）之间的区别。我们建议<a href="https://avro.apache.org/docs/1.7.6/spec.html">花点时间</a>阅读<a href="https://avro.apache.org/docs/1.7.6/spec.html">Avro术语</a>并了解其过程。Spring Cloud Stream始终会获取编写者架构来确定如何读取消息。如果您想获得Avro的架构演进支持，则需要确保<code>readerSchema</code>已为您的应用正确设置。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inter-application-communication"><a class="anchor" href="#inter-application-communication"></a> <a class="link" href="#inter-application-communication">21.11。应用间通信</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream支持应用程序之间的通信。应用程序间通信是一个涉及多个问题的复杂问题，如以下主题所述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“ <a href="#spring-cloud-stream-overview-connecting-multiple-application-instances">连接多个应用程序实例</a> ”</p>
</li>
<li>
<p>“ <a href="#spring-cloud-stream-overview-instance-index-instance-count">实例索引和实例计数</a> ”</p>
</li>
<li>
<p>“ <a href="#spring-cloud-stream-overview-partitioning">分区</a> ”</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-connecting-multiple-application-instances"><a class="anchor" href="#spring-cloud-stream-overview-connecting-multiple-application-instances"></a> <a class="link" href="#spring-cloud-stream-overview-connecting-multiple-application-instances">21.11.1。连接多个应用程序实例</a></h4>
<div class="paragraph">
<p>虽然Spring Cloud Stream使单个Spring Boot应用程序易于连接到消息传递系统，但Spring Cloud Stream的典型方案是创建多应用程序管道，在该管道中，微服务应用程序会相互发送数据。您可以通过关联“相邻”应用程序的输入和输出目标来实现此方案。</p>
</div>
<div class="paragraph">
<p>假设设计要求Time Source应用程序将数据发送到Log Sink应用程序。您可以使用一个名为<code>ticktock</code>用于两个应用程序中的绑定。</p>
</div>
<div class="paragraph">
<p>时间来源（具有频道名称<code>output</code> ）将设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.output.destination=ticktock</pre>
</div>
</div>
<div class="paragraph">
<p>日志接收器（具有通道名称<code>input</code> ）将设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.input.destination=ticktock</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-instance-index-instance-count"><a class="anchor" href="#spring-cloud-stream-overview-instance-index-instance-count"></a> <a class="link" href="#spring-cloud-stream-overview-instance-index-instance-count">21.11.2。实例索引和实例计数</a></h4>
<div class="paragraph">
<p>在扩展Spring Cloud Stream应用程序时，每个实例都可以接收有关同一应用程序还存在多少其他实例以及它自己的实例索引是什么的信息。Spring Cloud Stream通过<code>spring.cloud.stream.instanceCount</code>和<code>spring.cloud.stream.instanceIndex</code>属性。例如，如果存在HDFS接收器应用程序的三个实例，则所有三个实例都具有<code>spring.cloud.stream.instanceCount</code>调成<code>3</code> ，并且各个应用程序都有<code>spring.cloud.stream.instanceIndex</code>调成<code>0</code> ， <code>1</code>和<code>2</code> ， 分别。</p>
</div>
<div class="paragraph">
<p>当通过Spring Cloud Data Flow部署Spring Cloud Stream应用程序时，这些属性会自动配置。当独立启动Spring Cloud Stream应用程序时，必须正确设置这些属性。默认， <code>spring.cloud.stream.instanceCount</code>是<code>1</code>和<code>spring.cloud.stream.instanceIndex</code>是<code>0</code> 。</p>
</div>
<div class="paragraph">
<p>在按比例放大的方案中，正确地配置这两个属性通常对于解决分区行为很重要（请参见下文），并且某些绑定程序（例如，Kafka绑定程序）始终需要这两个属性，以确保数据在多个使用者实例之间正确划分。</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-stream-overview-partitioning"><a class="anchor" href="#spring-cloud-stream-overview-partitioning"></a> <a class="link" href="#spring-cloud-stream-overview-partitioning">21.11.3。分区</a></h4>
<div class="paragraph">
<p>在Spring Cloud Stream中进行分区包括两个任务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“ <a href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning">配置输出绑定以进行分区</a> ”</p>
</li>
<li>
<p>“ <a href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning">配置用于分区的输入绑定</a> ”</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-configuring-output-bindings-partitioning"><a class="anchor" href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning"></a> <a class="link" href="#spring-cloud-stream-overview-configuring-output-bindings-partitioning">配置输出绑定以进行分区</a></h5>
<div class="paragraph">
<p>您可以通过设置输出绑定中的一个和仅一个来配置输出绑定以发送分区数据<code>partitionKeyExpression</code>要么<code>partitionKeyExtractorName</code>属性及其<code>partitionCount</code>属性。</p>
</div>
<div class="paragraph">
<p>例如，以下是有效的典型配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id
spring.cloud.stream.bindings.output.producer.partitionCount=5</pre>
</div>
</div>
<div class="paragraph">
<p>基于该示例配置，通过使用以下逻辑将数据发送到目标分区。</p>
</div>
<div class="paragraph">
<p>根据发送给分区输出通道的每条消息计算分区键的值<code>partitionKeyExpression</code> 。的<code>partitionKeyExpression</code>是一个SpEL表达式，该表达式根据出站消息进行评估以提取分区键。</p>
</div>
<div class="paragraph">
<p>如果SpEL表达式不足以满足您的需要，则可以通过提供以下实现来计算分区键值： <code>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>并将其配置为Bean（通过使用<code>@Bean</code>注解）。如果您有一个以上类型的bean <code>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>在“应用程序上下文”中可用，您可以通过使用<code>partitionKeyExtractorName</code>属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>--spring.cloud.stream.bindings.output.producer.partitionKeyExtractorName=customPartitionKeyExtractor
--spring.cloud.stream.bindings.output.producer.partitionCount=5
. . .
@Bean
public CustomPartitionKeyExtractorClass customPartitionKeyExtractor() {
    return new CustomPartitionKeyExtractorClass();
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在以前的Spring Cloud Stream版本中，您可以指定<code>org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy</code>通过设置<code>spring.cloud.stream.bindings.output.producer.partitionKeyExtractorClass</code>属性。从2.0版开始，不建议使用此属性，并且在将来的版本中将不再支持该属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>计算完消息密钥后，分区选择过程会将目标分区确定为<code>0</code>和<code>partitionCount - 1</code> 。适用于大多数情况的默认计算基于以下公式： <code>key.hashCode() % partitionCount</code> 。可以在绑定上自定义，方法是设置SpEL表达式以针对“键”进行评估（通过<code>partitionSelectorExpression</code>属性）或通过配置以下实现<code>org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code>作为bean（通过使用@Bean批注）。类似于<code>PartitionKeyExtractorStrategy</code> ，您可以使用<code>spring.cloud.stream.bindings.output.producer.partitionSelectorName</code>当应用程序上下文中有多个这种类型的bean可用时，此属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>--spring.cloud.stream.bindings.output.producer.partitionSelectorName=customPartitionSelector
. . .
@Bean
public CustomPartitionSelectorClass customPartitionSelector() {
    return new CustomPartitionSelectorClass();
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">在以前的Spring Cloud Stream版本中，您可以指定<code>org.springframework.cloud.stream.binder.PartitionSelectorStrategy</code>通过设置<code>spring.cloud.stream.bindings.output.producer.partitionSelectorClass</code>属性。从2.0版开始，不推荐使用此属性，并且在将来的版本中将不再支持该属性。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="spring-cloud-stream-overview-configuring-input-bindings-partitioning"><a class="anchor" href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning"></a> <a class="link" href="#spring-cloud-stream-overview-configuring-input-bindings-partitioning">配置输入绑定以进行分区</a></h5>
<div class="paragraph">
<p>输入绑定（带有频道名称<code>input</code> ）配置为通过设置分区数据来接收分区数据<code>partitioned</code>财产以及<code>instanceIndex</code>和<code>instanceCount</code>应用程序本身的属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.cloud.stream.bindings.input.consumer.partitioned=true
spring.cloud.stream.instanceIndex=3
spring.cloud.stream.instanceCount=5</pre>
</div>
</div>
<div class="paragraph">
<p>的<code>instanceCount</code> value表示应在其之间分区数据的应用程序实例的总数。的<code>instanceIndex</code>在多个实例中必须是唯一值，且介于<code>0</code>和<code>instanceCount - 1</code> 。实例索引可帮助每个应用程序实例识别从中接收数据的唯一分区。活页夹要求使用不支持本地分区的技术。例如，对于RabbitMQ，每个分区都有一个队列，该队列名称包含实例索引。如果使用Kafka， <code>autoRebalanceEnabled</code>是<code>true</code> （默认），Kafka负责在实例之间分配分区，并且不需要这些属性。如果<code>autoRebalanceEnabled</code>设置为false， <code>instanceCount</code>和<code>instanceIndex</code>绑定程序使用来确定实例预订的分区（您必须拥有至少与实例一样多的分区）。活页夹分配分区而不是Kafka。如果您希望特定分区的消息始终发送到同一实例，这可能会很有用。当活页夹配置需要它们时，重要的是正确设置两个值，以确保使用所有数据并确保应用程序实例接收互斥的数据集。</p>
</div>
<div class="paragraph">
<p>尽管在单独情况下使用多个实例进行分区数据处理可能会很复杂，但Spring Cloud Dataflow可以通过正确填充输入和输出值以及让您依赖运行时基础架构来显着简化流程。提供有关实例索引和实例计数的信息。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing"><a class="anchor" href="#testing"></a> <a class="link" href="#testing">21.12。测试中</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream支持在不连接消息传递系统的情况下测试您的微服务应用程序。您可以使用<code>TestSupportBinder</code>由...提供<code>spring-cloud-stream-test-support</code>库，可以作为测试依赖项添加到应用程序中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-stream-test-support</artifactId>
       <scope>test</scope>
   </dependency></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">的<code>TestSupportBinder</code>使用Spring Boot自动配置机制取代在类路径上找到的其他绑定器。因此，在添加活页夹作为依赖项时，必须确保<code>test</code>作用域正在被使用。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>的<code>TestSupportBinder</code>使您可以与绑定的通道进行交互，并检查应用程序发送和接收的所有消息。</p>
</div>
<div class="paragraph">
<p>对于出站邮件渠道， <code>TestSupportBinder</code>注册一个订户，并将应用程序发出的消息保留在<code>MessageCollector</code> 。在测试期间可以检索它们，并针对它们进行断言。</p>
</div>
<div class="paragraph">
<p>您还可以将消息发送到入站消息通道，以便使用者应用程序可以使用消息。以下示例显示了如何在处理器上测试输入和输出通道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment= SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ExampleTest {

  @Autowired
  private Processor processor;

  @Autowired
  private MessageCollector messageCollector;

  @Test
  @SuppressWarnings("unchecked")
  public void testWiring() {
    Message<String> message = new GenericMessage<>("hello");
    processor.input().send(message);
    Message<String> received = (Message<String>) messageCollector.forChannel(processor.output()).poll();
    assertThat(received.getPayload(), equalTo("hello world"));
  }


  @SpringBootApplication
  @EnableBinding(Processor.class)
  public static class MyProcessor {

    @Autowired
    private Processor channels;

    @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
    public String transform(String in) {
      return in + " world";
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，我们创建了一个具有输入通道和输出通道的应用程序，它们都通过<code>Processor</code>接口。绑定的接口被注入到测试中，以便我们可以访问两个通道。我们在输入通道上发送一条消息，然后使用<code>MessageCollector</code>由Spring Cloud Stream的测试支持提供，以捕获消息已作为结果发送到输出通道。收到消息后，我们可以验证组件是否正常运行。</p>
</div>
<div class="sect3">
<h4 id="disabling-the-test-binder-autoconfiguration"><a class="anchor" href="#disabling-the-test-binder-autoconfiguration"></a> <a class="link" href="#disabling-the-test-binder-autoconfiguration">21.12.1。禁用测试绑定程序自动配置</a></h4>
<div class="paragraph">
<p>测试绑定程序背后的目的是取代类路径上的所有其他绑定程序，以使其易于测试您的应用程序而无需更改生产依赖性。在某些情况下（例如，集成测试），可以使用实际的生产绑定程序来代替，这需要禁用测试绑定程序自动配置。为此，您可以排除<code>org.springframework.cloud.stream.test.binder.TestSupportBinderAutoConfiguration</code>通过使用Spring Boot自动配置排除机制之一来实现类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @SpringBootApplication(exclude = TestSupportBinderAutoConfiguration.class)
    @EnableBinding(Processor.class)
    public static class MyProcessor {

        @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
        public String transform(String in) {
            return in + " world";
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>禁用自动配置后，测试绑定程序可在类路径及其上使用<code>defaultCandidate</code>属性设置为<code>false</code>因此它不会干扰常规用户配置。可以在名称下引用它， <code>test</code> ，如以下示例所示：</p>
</div>
<div class="paragraph">
<p><code>spring.cloud.stream.defaultBinder=test</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="health-indicator-5"><a class="anchor" href="#health-indicator-5"></a> <a class="link" href="#health-indicator-5">21.13。健康指标</a></h3>
<div class="paragraph">
<p>Spring Cloud Stream为活页夹提供了健康指标。它以名称注册<code>binders</code>并可以通过设置<code>management.health.binders.enabled</code>属性。</p>
</div>
<div class="paragraph">
<p>默认<code>management.health.binders.enabled</code>被设定为<code>false</code> 。设置<code>management.health.binders.enabled</code>至<code>true</code>启用运行状况指示器，使您可以访问<code>/health</code>端点以获取活页夹健康指标。</p>
</div>
<div class="paragraph">
<p>健康指标是特定于活页夹的，某些活页夹实现不一定提供健康指标。</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-cloud-stream-overview-metrics-emitter"><a class="anchor" href="#spring-cloud-stream-overview-metrics-emitter"></a> <a class="link" href="#spring-cloud-stream-overview-metrics-emitter">21.14。公制发射器</a></h3>
<div class="paragraph">
<p>Spring Boot Actuator为<a href="https://micrometer.io/">Micrometer</a>提供了依赖项管理和自动配置， <a href="https://micrometer.io/">Micrometer</a>是一种支持众多<a href="https://docs.spring.io/spring-boot/docs/2.0.0.RELEASE/reference/htmlsingle/#production-ready-metrics">监视系统</a>的应用程序指标外观。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream提供了将任何可用的基于千分尺的度量标准发送到绑定目标的支持，从而允许从流应用程序中定期收集度量标准数据，而无需依赖于轮询各个端点。</p>
</div>
<div class="paragraph">
<p>通过定义<code>spring.cloud.stream.bindings.applicationMetrics.destination</code>属性，它指定当前绑定程序用于发布度量标准消息的绑定目标的名称。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">spring.cloud.stream.bindings.applicationMetrics.destination=myMetricDestination</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例指示活页夹绑定到<code>myMetricDestination</code> （即Rabbit交流，Kafka主题等）。</p>
</div>
<div class="paragraph">
<p>以下属性可用于自定义指标的发出：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.metrics.key</dt>
<dd>
<p>发出的度量标准的名称。每个应用程序应为唯一值。</p>
<div class="paragraph">
<p>默认：<code>${spring.application.name:${vcap.application.name:${spring.config.name:application}}}</code></p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.metrics.properties</dt>
<dd>
<p>允许白名单应用程序属性添加到度量有效负载</p>
<div class="paragraph">
<p>默认值：null。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.metrics.meter-filter</dt>
<dd>
<p>控制要捕获的“仪表”的模式。例如，指定<code>spring.integration.*</code>捕获名称以“。”开头的仪表的度量标准信息<code>spring.integration.</code></p>
<div class="paragraph">
<p>默认值：捕获所有“仪表”。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.metrics.schedule-interval</dt>
<dd>
<p>控制发布度量标准数据的速率的时间间隔。</p>
<div class="paragraph">
<p>默认值：1分钟</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>考虑以下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java -jar time-source.jar \
    --spring.cloud.stream.bindings.applicationMetrics.destination=someMetrics \
    --spring.cloud.stream.metrics.properties=spring.application** \
    --spring.cloud.stream.metrics.meter-filter=spring.integration.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示由于上述命令而发布到绑定目标的数据的有效负载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">{
    "name": "application",
    "createdTime": "2018-03-23T14:48:12.700Z",
    "properties": {
    },
    "metrics": [
        {
            "id": {
                "name": "spring.integration.send",
                "tags": [
                    {
                        "key": "exception",
                        "value": "none"
                    },
                    {
                        "key": "name",
                        "value": "input"
                    },
                    {
                        "key": "result",
                        "value": "success"
                    },
                    {
                        "key": "type",
                        "value": "channel"
                    }
                ],
                "type": "TIMER",
                "description": "Send processing time",
                "baseUnit": "milliseconds"
            },
            "timestamp": "2018-03-23T14:48:12.697Z",
            "sum": 130.340546,
            "count": 6,
            "mean": 21.72342433333333,
            "upper": 116.176299,
            "total": 130.340546
        }
    ]
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">鉴于在迁移到Micrometer后，“公制”消息的格式已略有更改，因此已发布的消息还将具有一个<code>STREAM_CLOUD_STREAM_VERSION</code>标头设置为<code>2.x</code>以帮助区分旧版Spring Cloud Stream中的Metric消息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="samples-2"><a class="anchor" href="#samples-2"></a> <a class="link" href="#samples-2">21.15。样品</a></h3>
<div class="paragraph">
<p>有关Spring Cloud Stream示例，请参阅GitHub上的<a href="https://github.com/spring-cloud/spring-cloud-stream-samples">spring-cloud-stream-samples</a>存储库。</p>
</div>
<div class="sect3">
<h4 id="deploying-stream-applications-on-cloudfoundry"><a class="anchor" href="#deploying-stream-applications-on-cloudfoundry"></a> <a class="link" href="#deploying-stream-applications-on-cloudfoundry">21.15.1。在CloudFoundry上部署流应用程序</a></h4>
<div class="paragraph">
<p>在CloudFoundry上，通常通过称为<a href="https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES">VCAP_SERVICES</a>的特殊环境变量来公开服务。</p>
</div>
<div class="paragraph">
<p>配置活页夹连接时，可以使用环境变量中的值，如<a href="http://docs.spring.io/spring-cloud-dataflow-server-cloudfoundry/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-ups">数据流Cloud Foundry Server</a>文档中所述。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="binder-implementations"><a class="anchor" href="#binder-implementations"></a> <a class="link" href="#binder-implementations">22活页夹实现</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="apache-kafka-binder"><a class="anchor" href="#apache-kafka-binder"></a> <a class="link" href="#apache-kafka-binder">22.1Apache Kafka活页夹</a></h3>

<div class="sect4">
<h5 id="usage"><a class="anchor" href="#usage"></a> <a class="link" href="#usage">用法</a></h5>
<div class="paragraph">
<p>要使用Apache Kafka活页夹，您需要添加<code>spring-cloud-stream-binder-kafka</code>作为对Spring Cloud Stream应用程序的依赖关系，如以下Maven示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-stream-binder-kafka</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，您也可以使用Spring Cloud Stream Kafka Starter，如以下针对Maven的示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-stream-kafka</artifactId>
</dependency></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="apache-kafka-binder-overview"><a class="anchor" href="#apache-kafka-binder-overview"></a> <a class="link" href="#apache-kafka-binder-overview">Apache Kafka Binder概述</a></h5>
<div class="paragraph">
<p>下图显示了Apache Kafka活页夹的工作方式的简化图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/images/kafka-binder.png" alt="卡夫卡粘合剂" width="300">
</div>
<div class="title">图17。卡夫卡·宾德</div>
</div>
<div class="paragraph">
<p>Apache Kafka Binder实现将每个目标映射到一个Apache Kafka主题。消费者组直接映射到相同的Apache Kafka概念。分区也直接映射到Apache Kafka分区。</p>
</div>
<div class="paragraph">
<p>资料夹目前使用Apache Kafka <code>kafka-clients</code> 1.0.0 jar，旨在与至少该版本的代理一起使用。该客户端可以与较旧的代理进行通信（请参阅Kafka文档），但是某些功能可能不可用。例如，对于低于0.11.xx的版本，不支持本机头。此外，0.11.xx不支持<code>autoAddPartitions</code>属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="configuration-options-2"><a class="anchor" href="#configuration-options-2"></a> <a class="link" href="#configuration-options-2">配置选项</a></h5>
<div class="paragraph">
<p>本节包含Apache Kafka活页夹使用的配置选项。</p>
</div>
<div class="paragraph">
<p>有关与活页夹有关的常见配置选项和属性，请参阅<a href="#binding-properties">核心文档</a> 。</p>
</div>
<div class="sect5">
<h6 id="kafka-binder-properties"><a class="anchor" href="#kafka-binder-properties"></a> <a class="link" href="#kafka-binder-properties">Kafka Binder属性</a></h6>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.brokers</dt>
<dd>
<p>Kafka活页夹连接到的经纪人列表。</p>
<div class="paragraph">
<p>默认： <code>localhost</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.defaultBrokerPort</dt>
<dd>
<p><code>brokers</code>允许指定带有或不带有端口信息的主机（例如， <code>host1,host2:port2</code> ）。当代理列表中未配置任何端口时，这将设置默认端口。</p>
<div class="paragraph">
<p>默认： <code>9092</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.configuration</dt>
<dd>
<p>客户端属性（生产者和消费者）的键/值映射传递给绑定程序创建的所有客户端。由于生产者和消费者都使用了这些属性，因此应将使用限制为通用属性，例如安全性设置。此处的属性取代引导中设置的所有属性。</p>
<div class="paragraph">
<p>默认值：空地图。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.consumerProperties</dt>
<dd>
<p>任意Kafka客户端使用者属性的键/值映射。此处的属性将取代引导和<code>configuration</code>上面的属性。</p>
<div class="paragraph">
<p>默认值：空地图。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.headers</dt>
<dd>
<p>活页夹传输的自定义标头列表。仅当与较旧的应用程序（⇐1.3.x）进行通讯时，才需要<code>kafka-clients</code>版本<0.11.0.0。较新的版本本机支持标头。</p>
<div class="paragraph">
<p>默认值：空。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.healthTimeout</dt>
<dd>
<p>等待获取分区信息的时间，以秒为单位。如果此计时器到期，运行状况将报告为已关闭。</p>
<div class="paragraph">
<p>默认值：10</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.requiredAcks</dt>
<dd>
<p>代理程序上所需的确认数。请参阅生产者的Kafka文档<code>acks</code>属性。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.minPartitionCount</dt>
<dd>
<p>仅在以下情况下有效<code>autoCreateTopics</code>要么<code>autoAddPartitions</code>被设置。活页夹在生成或使用数据的主题上配置的全局最小分区数。它可以被<code>partitionCount</code>生产者的设置或按<code>instanceCount * concurrency</code>生产者的设置（如果较大）。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.producer属性</dt>
<dd>
<p>任意Kafka客户端生产者属性的键/值映射。此处的属性将取代引导和<code>configuration</code>上面的属性。</p>
<div class="paragraph">
<p>默认值：空地图。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.replicationFactor</dt>
<dd>
<p>自动创建的主题的复制因子是否<code>autoCreateTopics</code>活跃。可以在每个绑定上覆盖。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.autoCreateTopics</dt>
<dd>
<p>如果设置为<code>true</code> ，活页夹将自动创建新主题。如果设置为<code>false</code> ，活页夹依赖于已经配置的主题。在后一种情况下，如果主题不存在，则活页夹无法启动。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">此设置独立于<code>auto.topic.create.enable</code>经纪人的设置，并且不影响它。如果服务器设置为自动创建主题，则可以使用默认代理设置将它们作为元数据检索请求的一部分进行创建。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.autoAddPartitions</dt>
<dd>
<p>如果设置为<code>true</code> ，活页夹会根据需要创建新的分区。如果设置为<code>false</code> ，活页夹依赖于已配置的主题的分区大小。如果目标主题的分区数小于期望值，则活页夹无法启动。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.transaction.transactionIdPrefix</dt>
<dd>
<p>在活页夹中启用事务。看到<code>transaction.id</code>在Kafka文档和<a href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#transactions">Transactions</a>中<code>spring-kafka</code>文档。启用交易后，个人<code>producer</code>属性会被忽略，所有生产者都会使用<code>spring.cloud.stream.kafka.binder.transaction.producer.*</code>属性。</p>
<div class="paragraph">
<p>默认<code>null</code> （无交易）</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.transaction.producer。*</dt>
<dd>
<p>交易绑定中生产者的全球生产者属性。看到<code>spring.cloud.stream.kafka.binder.transaction.transactionIdPrefix</code>和<a href="#kafka-producer-properties">Kafka生产者属性</a>以及所有活页夹支持的常规生产者属性。</p>
<div class="paragraph">
<p>默认值：请参见各个生产者属性。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.headerMapperBeanName</dt>
<dd>
<p>一个的bean名称<code>KafkaHeaderMapper</code>用于映射<code>spring-messaging</code>与Kafka标头之间的标头。例如，如果您希望在<code>DefaultKafkaHeaderMapper</code>使用JSON反序列化的标头。</p>
<div class="paragraph">
<p>默认值：无。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="kafka-consumer-properties"><a class="anchor" href="#kafka-consumer-properties"></a> <a class="link" href="#kafka-consumer-properties">卡夫卡消费物业</a></h6>
<div class="paragraph">
<p>以下属性仅适用于Kafka使用者，并且必须加上前缀<code>spring.cloud.stream.kafka.bindings.<channelName>.consumer.</code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">管理员配置</dt>
<dd>
<p>一种<code>Map</code>设置主题时使用的Kafka主题属性的集合-例如，<code>spring.cloud.stream.kafka.bindings.input.consumer.admin.configuration.message.format.version=0.9.0.0</code></p>
<div class="paragraph">
<p>默认值：无。</p>
</div>
</dd>
<dt class="hdlist1">管理员副本分配</dt>
<dd>
<p><integer, list<integer="">副本分配的 Map <integer, list<integer="">>，键为分区，值为分配。在配置新主题时使用。见<code>NewTopic</code>中的Javadocs <code>kafka-clients</code>罐。</integer,></integer,></p>
<div class="paragraph">
<p>默认值：无。</p>
</div>
</dd>
<dt class="hdlist1">管理员复制因子</dt>
<dd>
<p>设置主题时要使用的复制因子。覆盖活页夹范围的设置。忽略是否<code>replicas-assignments</code>存在。</p>
<div class="paragraph">
<p>默认值：无（使用资料夹范围的默认值1）。</p>
</div>
</dd>
<dt class="hdlist1">autoRebalanceEnabled</dt>
<dd>
<p>什么时候<code>true</code> ，主题分区会自动在使用者组的成员之间重新平衡。什么时候<code>false</code> ，则根据以下情况为每个使用者分配固定的分区集： <code>spring.cloud.stream.instanceCount</code>和<code>spring.cloud.stream.instanceIndex</code> 。这需要<code>spring.cloud.stream.instanceCount</code>和<code>spring.cloud.stream.instanceIndex</code>在每个启动的实例上适当设置的属性。的价值<code>spring.cloud.stream.instanceCount</code>在这种情况下，属性通常必须大于1。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">ackEachRecord</dt>
<dd>
<p>什么时候<code>autoCommitOffset</code>是<code>true</code> ，此设置指示在处理每个记录后是否提交偏移量。默认情况下，偏移量是在由返回的记录批次中的所有记录之后提交的<code>consumer.poll()</code>已处理。轮询返回的记录数可以用<code>max.poll.records</code>卡夫卡财产，由消费者设定<code>configuration</code>属性。设置为<code>true</code>可能会导致性能下降，但是这样做会降低发生故障时重新传送记录的可能性。另外，请参阅活页夹<code>requiredAcks</code>属性，这也会影响提交偏移量的性能。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">autoCommitOffset</dt>
<dd>
<p>处理消息后是否自动提交偏移量。如果设置为<code>false</code> ，带有键的标题<code>kafka_acknowledgment</code>类型的<code>org.springframework.kafka.support.Acknowledgment</code>标头出现在入站消息中。应用程序可以使用此标头来确认消息。有关详细信息，请参见示例部分。当此属性设置为<code>false</code> ，Kafka活页夹将ack模式设置为<code>org.springframework.kafka.listener.AbstractMessageListenerContainer.AckMode.MANUAL</code>该应用程序负责确认记录。另见<code>ackEachRecord</code> 。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">autoCommitOnError</dt>
<dd>
<p>仅在以下情况下有效<code>autoCommitOffset</code>被设定为<code>true</code> 。如果设置为<code>false</code> ，它会抑制导致错误的消息的自动提交，并且仅对成功的消息进行提交。如果持续出现故障，它允许流从上次成功处理的消息自动重播。如果设置为<code>true</code> ，它将始终自动提交（如果启用了自动提交）。如果未设置（默认值），则其有效值与<code>enableDlq</code> ，如果将错误消息发送到DLQ，则自动提交错误消息，否则不提交。</p>
<div class="paragraph">
<p>默认值：未设置。</p>
</div>
</dd>
<dt class="hdlist1">resetOffsets</dt>
<dd>
<p>是否将使用者的偏移量重置为startOffset提供的值。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">startOffset</dt>
<dd>
<p>新组的起始偏移量。允许值： <code>earliest</code>和<code>latest</code> 。如果为消费者“绑定”明确设置了消费者组（通过<code>spring.cloud.stream.bindings.<channelName>.group</code> ），“ startOffset”设置为<code>earliest</code> 。否则，它设置为<code>latest</code>为了<code>anonymous</code>消费群体。另见<code>resetOffsets</code> （在此列表的前面）。</p>
<div class="paragraph">
<p>默认值：null（等效于<code>earliest</code> ）。</p>
</div>
</dd>
<dt class="hdlist1">enableDlq</dt>
<dd>
<p>设置为true时，它将为使用者启用DLQ行为。默认情况下，导致错误的消息将转发到名为<code>error.<destination>.<group></code> 。DLQ主题名称可以通过设置<code>dlqName</code>属性。当错误数量相对较少并且重放整个原始主题可能太麻烦时，这为更常见的Kafka重播方案提供了一个替代选项。有关更多信息，请参见<a href="#kafka-dlq-processing">死信主题处理</a> 。从2.0版开始，发送到DLQ主题的消息通过以下标头得到增强： <code>x-original-topic</code> ， <code>x-exception-message</code>和<code>x-exception-stacktrace</code>如<code>byte[]</code> 。
<strong>何时不允许<code>destinationIsPattern</code>是<code>true</code> 。</strong></p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">组态</dt>
<dd>
<p>使用包含通用Kafka使用者属性的键/值对进行映射。</p>
<div class="paragraph">
<p>默认值：空地图。</p>
</div>
</dd>
<dt class="hdlist1">dlqName</dt>
<dd>
<p>接收错误消息的DLQ主题的名称。</p>
<div class="paragraph">
<p>默认值：null（如果未指定，则导致错误的消息将转发到名为<code>error.<destination>.<group></code> ）。</p>
</div>
</dd>
<dt class="hdlist1">dlqProducerProperties</dt>
<dd>
<p>使用此功能，可以设置特定于DLQ的生产者属性。通过kafka生产者属性可以使用的所有属性都可以通过该属性设置。</p>
<div class="paragraph">
<p>默认值：默认的Kafka生产者属性。</p>
</div>
</dd>
<dt class="hdlist1">标头</dt>
<dd>
<p>指示入站通道适配器填充哪些标准头。允许值： <code>none</code> ， <code>id</code> ， <code>timestamp</code> ， 要么<code>both</code> 。如果使用本机反序列化并且第一个组件接收消息需要<code>id</code> （例如配置为使用JDBC消息存储库的聚合器）。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">converterBeanName</dt>
<dd>
<p>实现的bean的名称<code>RecordMessageConverter</code> 。用于入站通道适配器以替换默认适配器<code>MessagingMessageConverter</code> 。</p>
<div class="paragraph">
<p>默认：<code>null</code></p>
</div>
</dd>
<dt class="hdlist1">idleEventInterval</dt>
<dd>
<p>事件之间的间隔（以毫秒为单位），指示最近未接收到任何消息。使用<code>ApplicationListener<ListenerContainerIdleEvent></code>接收这些事件。有关用法示例，请参见<a href="#pause-resume">示例：暂停和恢复使用者</a> 。</p>
<div class="paragraph">
<p>默认：<code>30000</code></p>
</div>
</dd>
<dt class="hdlist1">destinationIsPattern</dt>
<dd>
<p>如果为true，则将目的地视为正则表达式<code>Pattern</code>用于由代理匹配主题名称。如果为true，则不设置主题，并且<code>enableDlq</code>不允许，因为绑定者在供应阶段不知道主题名称。请注意，检测与模式匹配的新主题所花费的时间由消费者属性控制<code>metadata.max.age.ms</code> ，（在撰写本文时）默认为300,000ms（5分钟）。可以使用<code>configuration</code>上面的属性。</p>
<div class="paragraph">
<p>默认：<code>false</code></p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="kafka-producer-properties"><a class="anchor" href="#kafka-producer-properties"></a> <a class="link" href="#kafka-producer-properties">Kafka Producer属性</a></h6>
<div class="paragraph">
<p>以下属性仅适用于Kafka生产者，并且必须使用前缀<code>spring.cloud.stream.kafka.bindings.<channelName>.producer.</code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">管理员配置</dt>
<dd>
<p>一种<code>Map</code>设置新主题时使用的Kafka主题属性的集合-例如，<code>spring.cloud.stream.kafka.bindings.input.consumer.admin.configuration.message.format.version=0.9.0.0</code></p>
<div class="paragraph">
<p>默认值：无。</p>
</div>
</dd>
<dt class="hdlist1">管理员副本分配</dt>
<dd>
<p><integer, list<integer="">副本分配的 Map <integer, list<integer="">>，键为分区，值为分配。在配置新主题时使用。看到<code>NewTopic</code>中的javadocs <code>kafka-clients</code>罐。</integer,></integer,></p>
<div class="paragraph">
<p>默认值：无。</p>
</div>
</dd>
<dt class="hdlist1">管理员复制因子</dt>
<dd>
<p>设置新主题时要使用的复制因子。覆盖活页夹范围的设置。忽略是否<code>replicas-assignments</code>存在。</p>
<div class="paragraph">
<p>默认值：无（使用资料夹范围的默认值1）。</p>
</div>
</dd>
<dt class="hdlist1">缓冲区大小</dt>
<dd>
<p>Kafka生产者在发送前尝试分批处理的数据量的上限（以字节为单位）。</p>
<div class="paragraph">
<p>默认： <code>16384</code> 。</p>
</div>
</dd>
<dt class="hdlist1">同步</dt>
<dd>
<p>生产者是否同步。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">batchTimeout</dt>
<dd>
<p>生产者在发送消息之前等待允许更多消息在同一批中累积的时间。（通常，生产者根本不等待，仅发送在上一次发送过程中累积的所有消息。）非零值可能会增加吞吐量，但会增加延迟。</p>
<div class="paragraph">
<p>默认： <code>0</code> 。</p>
</div>
</dd>
<dt class="hdlist1">messageKeyExpression</dt>
<dd>
<p>根据用于填充产生的Kafka消息密钥的传出消息评估SpEL表达式-例如， <code>headers['myKey']</code> 。有效负载无法使用，因为在计算此表达式时，有效负载已经采用了<code>byte[]</code> 。</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">headerPatterns</dt>
<dd>
<p>以逗号分隔的简单模式列表，以匹配要映射到Kafka的Spring消息头。 <code>Headers</code>在里面<code>ProducerRecord</code> 。模式可以以通配符（星号）开头或结尾。可以使用前缀前缀来否定模式<code>!</code> 。比赛在第一个比赛（正数或负数）之后停止。例如<code>!ask,as*</code>将通过<code>ash</code>但不是<code>ask</code> 。
<code>id</code>和<code>timestamp</code>永远不会被映射。</p>
<div class="paragraph">
<p>默认： <code>*</code> （所有标头-除了<code>id</code>和<code>timestamp</code> ）</p>
</div>
</dd>
<dt class="hdlist1">组态</dt>
<dd>
<p>使用包含通用Kafka生产者属性的键/值对进行映射。</p>
<div class="paragraph">
<p>默认值：空地图。</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">Kafka活页夹使用<code>partitionCount</code>生产者的设置，以提示创建具有给定分区数的主题（与<code>minPartitionCount</code> ，两个中的最大值就是所使用的值）。同时配置两者时请小心<code>minPartitionCount</code>用于粘合剂和<code>partitionCount</code>对于应用程序，使用较大的值。如果一个主题已经存在且分区数较小，并且<code>autoAddPartitions</code>如果禁用（默认），则绑定器无法启动。如果一个主题已经存在且分区数较小，并且<code>autoAddPartitions</code>启用后，将添加新分区。如果已经存在一个主题，且其分区数量大于（ <code>minPartitionCount</code>要么<code>partitionCount</code> ），则使用现有分区计数。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="usage-examples"><a class="anchor" href="#usage-examples"></a> <a class="link" href="#usage-examples">用法示例</a></h6>
<div class="paragraph">
<p>在本节中，我们显示了针对特定场景使用前面的属性。</p>
</div>
<div class="sect6">
<h7 id="example-setting-autocommitoffset-to-false-and-relying-on-manual-acking"><a class="anchor" href="#example-setting-autocommitoffset-to-false-and-relying-on-manual-acking"></a> <a class="link" href="#example-setting-autocommitoffset-to-false-and-relying-on-manual-acking">示例：设置<code>autoCommitOffset</code>至<code>false</code>和依靠手工起搏</a></h7>
<div class="paragraph">
<p>此示例说明了如何在用户应用程序中手动确认偏移。</p>
</div>
<div class="paragraph">
<p>这个例子要求<code>spring.cloud.stream.kafka.bindings.input.consumer.autoCommitOffset</code>设置为<code>false</code> 。在您的示例中使用相应的输入通道名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@SpringBootApplication
@EnableBinding(Sink.class)
public class ManuallyAcknowdledgingConsumer {

 public static void main(String[] args) {
     SpringApplication.run(ManuallyAcknowdledgingConsumer.class, args);
 }

 @StreamListener(Sink.INPUT)
 public void process(Message<?> message) {
     Acknowledgment acknowledgment = message.getHeaders().get(KafkaHeaders.ACKNOWLEDGMENT, Acknowledgment.class);
     if (acknowledgment != null) {
         System.out.println("Acknowledgment provided");
         acknowledgment.acknowledge();
     }
 }
}</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="example-security-configuration"><a class="anchor" href="#example-security-configuration"></a> <a class="link" href="#example-security-configuration">示例：安全配置</a></h7>
<div class="paragraph">
<p>Apache Kafka 0.9支持客户端和代理之间的安全连接。要利用此功能，请遵循<a href="http://kafka.apache.org/090/documentation.html#security_configclients">Apache Kafka文档</a>中的<a href="http://docs.confluent.io/2.0.0/kafka/security.html">准则以及Confluent文档中</a>的Kafka 0.9 <a href="http://docs.confluent.io/2.0.0/kafka/security.html">安全准则</a> 。使用<code>spring.cloud.stream.kafka.binder.configuration</code>选项，为活页夹创建的所有客户端设置安全属性。</p>
</div>
<div class="paragraph">
<p>例如，设置<code>security.protocol</code>至<code>SASL_SSL</code> ，设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_SSL</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以以类似方式设置所有其他安全属性。</p>
</div>
<div class="paragraph">
<p>使用Kerberos时，请遵循<a href="http://kafka.apache.org/090/documentation.html#security_sasl_clientconfig">参考文档</a>中的<a href="http://kafka.apache.org/090/documentation.html#security_sasl_clientconfig">说明</a>来创建和引用JAAS配置。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream支持通过使用JAAS配置文件和Spring Boot属性将JAAS配置信息传递到应用程序。</p>
</div>
<div class="sect7">
<h8 id="using-jaas-configuration-files"><a class="anchor" href="#using-jaas-configuration-files"></a> <a class="link" href="#using-jaas-configuration-files">使用JAAS配置文件</a></h8>
<div class="paragraph">
<p>可以使用系统属性为Spring Cloud Stream应用程序设置JAAS和（可选）krb5文件位置。以下示例显示如何通过使用JAAS配置文件使用SASL和Kerberos启动Spring Cloud Stream应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"> java -Djava.security.auth.login.config=/path.to/kafka_client_jaas.conf -jar log.jar \
   --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT</code></pre>
</div>
</div>
</div>
<div class="sect7">
<h8 id="using-spring-boot-properties"><a class="anchor" href="#using-spring-boot-properties"></a> <a class="link" href="#using-spring-boot-properties">使用Spring Boot属性</a></h8>
<div class="paragraph">
<p>作为使用JAAS配置文件的替代方法，Spring Cloud Stream提供了一种使用Spring Boot属性为Spring Cloud Stream应用程序设置JAAS配置的机制。</p>
</div>
<div class="paragraph">
<p>以下属性可用于配置Kafka客户端的登录上下文：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.jaas.loginModule</dt>
<dd>
<p>登录模块名称。正常情况下无需设置。</p>
<div class="paragraph">
<p>默认： <code>com.sun.security.auth.module.Krb5LoginModule</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.jaas.controlFlag</dt>
<dd>
<p>登录模块的控制标志。</p>
<div class="paragraph">
<p>默认： <code>required</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.binder.jaas.options</dt>
<dd>
<p>使用包含登录模块选项的键/值对进行映射。</p>
<div class="paragraph">
<p>默认值：空地图。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下示例显示如何通过使用Spring Boot配置属性使用SASL和Kerberos启动Spring Cloud Stream应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"> java --spring.cloud.stream.kafka.binder.brokers=secure.server:9092 \
   --spring.cloud.stream.bindings.input.destination=stream.ticktock \
   --spring.cloud.stream.kafka.binder.autoCreateTopics=false \
   --spring.cloud.stream.kafka.binder.configuration.security.protocol=SASL_PLAINTEXT \
   --spring.cloud.stream.kafka.binder.jaas.options.useKeyTab=true \
   --spring.cloud.stream.kafka.binder.jaas.options.storeKey=true \
   --spring.cloud.stream.kafka.binder.jaas.options.keyTab=/etc/security/keytabs/kafka_client.keytab \
   --spring.cloud.stream.kafka.binder.jaas.options.principal=kafka-client-1@EXAMPLE.COM</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例表示以下JAAS文件的等效项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>KafkaClient {
    com.sun.security.auth.module.Krb5LoginModule required
    useKeyTab=true
    storeKey=true
    keyTab="/etc/security/keytabs/kafka_client.keytab"
    principal="kafka-client-1@EXAMPLE.COM";
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所需的主题已经存在于代理上或将由管理员创建，则可以关闭自动创建，仅需要发送客户端JAAS属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">不要在同一应用程序中混合使用JAAS配置文件和Spring Boot属性。如果<code>-Djava.security.auth.login.config</code>系统属性已经存在，Spring Cloud Stream会忽略Spring Boot属性。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">使用时要小心<code>autoCreateTopics</code>和<code>autoAddPartitions</code>使用Kerberos。通常，应用程序可能使用在Kafka和Zookeeper中没有管理权限的主体。因此，依靠Spring Cloud Stream创建/修改主题可能会失败。在安全的环境中，我们强烈建议您使用Kafka工具创建主题并以管理方式管理ACL。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect6">
<h7 id="pause-resume"><a class="anchor" href="#pause-resume"></a> <a class="link" href="#pause-resume">示例：暂停和恢复使用方</a></h7>
<div class="paragraph">
<p>如果希望暂停使用但不引起分区重新平衡，则可以暂停并恢复使用方。通过添加<code>Consumer</code>作为您的参数<code>@StreamListener</code> 。要恢复，您需要<code>ApplicationListener</code>对于<code>ListenerContainerIdleEvent</code>实例。事件的发布频率由<code>idleEventInterval</code>属性。由于使用者不是线程安全的，因此必须在调用线程上调用这些方法。</p>
</div>
<div class="paragraph">
<p>以下简单的应用程序显示了如何暂停和恢复：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void in(String in, @Header(KafkaHeaders.CONSUMER) Consumer<?, ?> consumer) {
        System.out.println(in);
        consumer.pause(Collections.singleton(new TopicPartition("myTopic", 0)));
    }

    @Bean
    public ApplicationListener<ListenerContainerIdleEvent> idleListener() {
        return event -> {
            System.out.println(event);
            if (event.getConsumer().paused().size() > 0) {
                event.getConsumer().resume(event.getConsumer().paused());
            }
        };
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kafka-error-channels"><a class="anchor" href="#kafka-error-channels"></a> <a class="link" href="#kafka-error-channels">错误通道</a></h5>
<div class="paragraph">
<p>从版本1.3开始，绑定程序无条件地将异常发送到每个使用者目标的错误通道，也可以将其配置为将异步生产者发送失败消息发送到错误通道。有关更多信息，请参见<a href="#spring-cloud-stream-overview-error-handling">错误处理</a> 。</p>
</div>
<div class="paragraph">
<p>的有效载荷<code>ErrorMessage</code>发送失败是<code>KafkaSendFailureException</code>具有属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>failedMessage</code> ：春季消息<code>Message<?></code>无法发送。</p>
</li>
<li>
<p><code>record</code> ：原始<code>ProducerRecord</code>从创建的<code>failedMessage</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有自动处理生产者异常（例如发送到<a href="#kafka-dlq-processing">Dead-Letter队列</a> ）。您可以使用自己的Spring Integration流使用这些异常。</p>
</div>
</div>
<div class="sect4">
<h5 id="kafka-metrics"><a class="anchor" href="#kafka-metrics"></a> <a class="link" href="#kafka-metrics">卡夫卡指标</a></h5>
<div class="paragraph">
<p>Kafka活页夹模块公开以下指标：</p>
</div>
<div class="paragraph">
<p><code>spring.cloud.stream.binder.kafka.offset</code> ：此指标指示给定的消费群体尚未从给定的活页夹主题中消费多少消息。提供的指标基于Mircometer指标库。度量标准包含消费者组信息，主题以及与主题上的最新偏移量有关的承诺偏移量的实际滞后时间。该指标对于向PaaS平台提供自动缩放反馈特别有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="kafka-dlq-processing"><a class="anchor" href="#kafka-dlq-processing"></a> <a class="link" href="#kafka-dlq-processing">死信主题处理</a></h5>
<div class="paragraph">
<p>因为您无法预期用户将如何处置死信，所以该框架没有提供任何标准机制来处理它们。如果死信的原因是短暂的，则您可能希望将消息路由回原始主题。但是，如果问题是永久性问题，则可能导致无限循环。本主题中的示例Spring Boot应用程序是如何将这些消息路由回原始主题的示例，但是在尝试了三遍之后，它将这些消息移至“停车场”主题。该应用程序是另一个从死信主题中读取的spring-cloud-stream应用程序。5秒钟未收到任何消息时，它将终止。</p>
</div>
<div class="paragraph">
<p>这些示例假定原始目的地是<code>so8400out</code>而消费群是<code>so8400</code> 。</p>
</div>
<div class="paragraph">
<p>有两种策略可供考虑：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>考虑仅在主应用程序未运行时才运行重新路由。否则，瞬态错误的重试会很快用完。</p>
</li>
<li>
<p>或者，使用两阶段方法：使用此应用程序将路由到第三个主题，将另一个应用程序路由到第三个主题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码清单显示了示例应用程序：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.input.group=so8400replay
spring.cloud.stream.bindings.input.destination=error.so8400out.so8400

spring.cloud.stream.bindings.output.destination=so8400out
spring.cloud.stream.bindings.output.producer.partitioned=true

spring.cloud.stream.bindings.parkingLot.destination=so8400in.parkingLot
spring.cloud.stream.bindings.parkingLot.producer.partitioned=true

spring.cloud.stream.kafka.binder.configuration.auto.offset.reset=earliest

spring.cloud.stream.kafka.binder.headers=x-retries</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">应用</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(TwoOutputProcessor.class)
public class ReRouteDlqKApplication implements CommandLineRunner {

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) {
        SpringApplication.run(ReRouteDlqKApplication.class, args).close();
    }

    private final AtomicInteger processed = new AtomicInteger();

    @Autowired
    private MessageChannel parkingLot;

    @StreamListener(Processor.INPUT)
    @SendTo(Processor.OUTPUT)
    public Message<?> reRoute(Message<?> failed) {
        processed.incrementAndGet();
        Integer retries = failed.getHeaders().get(X_RETRIES_HEADER, Integer.class);
        if (retries == null) {
            System.out.println("First retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else if (retries.intValue() < 3) {
            System.out.println("Another retry for " + failed);
            return MessageBuilder.fromMessage(failed)
                    .setHeader(X_RETRIES_HEADER, new Integer(retries.intValue() + 1))
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build();
        }
        else {
            System.out.println("Retries exhausted for " + failed);
            parkingLot.send(MessageBuilder.fromMessage(failed)
                    .setHeader(BinderHeaders.PARTITION_OVERRIDE,
                            failed.getHeaders().get(KafkaHeaders.RECEIVED_PARTITION_ID))
                    .build());
        }
        return null;
    }

    @Override
    public void run(String... args) throws Exception {
        while (true) {
            int count = this.processed.get();
            Thread.sleep(5000);
            if (count == this.processed.get()) {
                System.out.println("Idle, terminating");
                return;
            }
        }
    }

    public interface TwoOutputProcessor extends Processor {

        @Output("parkingLot")
        MessageChannel parkingLot();

    }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="partitioning-with-the-kafka-binder"><a class="anchor" href="#partitioning-with-the-kafka-binder"></a> <a class="link" href="#partitioning-with-the-kafka-binder">使用Kafka活页夹进行分区</a></h5>
<div class="paragraph">
<p>Apache Kafka本机支持主题分区。</p>
</div>
<div class="paragraph">
<p>有时，将数据发送到特定的分区是有好处的-例如，当您要严格订购消息处理时（特定客户的所有消息应转到同一分区）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何配置生产方和消费者方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Source.class)
public class KafkaPartitionProducerApplication {

    private static final Random RANDOM = new Random(System.currentTimeMillis());

    private static final String[] data = new String[] {
            "foo1", "bar1", "qux1",
            "foo2", "bar2", "qux2",
            "foo3", "bar3", "qux3",
            "foo4", "bar4", "qux4",
            };

    public static void main(String[] args) {
        new SpringApplicationBuilder(KafkaPartitionProducerApplication.class)
            .web(false)
            .run(args);
    }

    @InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))
    public Message<?> generate() {
        String value = data[RANDOM.nextInt(data.length)];
        System.out.println("Sending: " + value);
        return MessageBuilder.withPayload(value)
                .setHeader("partitionKey", value)
                .build();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    stream:
      bindings:
        output:
          destination: partitioned.topic
          producer:
            partitioned: true
            partition-key-expression: headers['partitionKey']
            partition-count: 12</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">必须为该主题提供足够的分区，以实现所有消费者组所需的并发性。上面的配置最多支持12个使用者实例（如果有6个使用者实例， <code>concurrency</code>如果它们的并发是3，则为2、4，依此类推）。通常最好“过度配置”分区，以使将来的使用者或并发性增加。
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">前面的配置使用默认分区（ <code>key.hashCode() % partitionCount</code> ）。根据键值，这可能会或可能不会提供适当的平衡算法。您可以使用<code>partitionSelectorExpression</code>要么<code>partitionSelectorClass</code>属性。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>由于分区是由Kafka本地处理的，因此在用户端不需要特殊配置。Kafka在实例之间分配分区。</p>
</div>
<div class="paragraph">
<p>以下Spring Boot应用程序侦听Kafka流并打印（到控制台）每条消息去往的分区ID：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class KafkaPartitionConsumerApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(KafkaPartitionConsumerApplication.class)
            .web(false)
            .run(args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(@Payload String in, @Header(KafkaHeaders.RECEIVED_PARTITION_ID) int partition) {
        System.out.println(in + " received from partition " + partition);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">spring:
  cloud:
    stream:
      bindings:
        input:
          destination: partitioned.topic
          group: myGroup</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以根据需要添加实例。Kafka重新平衡分区分配。如果实例计数（或<code>instance count * concurrency</code> ）超出了分区数量，一些使用者处于闲置状态。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="apache-kafka-streams-binder"><a class="anchor" href="#apache-kafka-streams-binder"></a> <a class="link" href="#apache-kafka-streams-binder">22.2。Apache Kafka Streams活页夹</a></h3>
<div class="sect3">
<h4 id="usage-2"><a class="anchor" href="#usage-2"></a> <a class="link" href="#usage-2">22.2.1。用法</a></h4>
<div class="paragraph">
<p>要使用Kafka Streams绑定程序，只需使用以下Maven坐标将其添加到Spring Cloud Stream应用程序中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-stream-binder-kafka-streams</artifactId>
</dependency></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kafka-streams-binder-overview"><a class="anchor" href="#kafka-streams-binder-overview"></a> <a class="link" href="#kafka-streams-binder-overview">22.2.2。Kafka Streams Binder概述</a></h4>
<div class="paragraph">
<p>Spring Cloud Stream的Apache Kafka支持还包括明确为Apache Kafka Streams绑定设计的绑定器实现。通过这种本机集成，Spring Cloud Stream“处理器”应用程序可以在核心业务逻辑中直接使用<a href="https://kafka.apache.org/documentation/streams/developer-guide">Apache Kafka Streams</a> API。</p>
</div>
<div class="paragraph">
<p>Kafka Streams活页夹实现基于<a href="http://docs.spring.io/spring-kafka/reference/html/_reference.html#kafka-streams">Spring Kafka</a>项目中<a href="http://docs.spring.io/spring-kafka/reference/html/_reference.html#kafka-streams">Kafka Streams</a>提供的基础。</p>
</div>
<div class="paragraph">
<p>Kafka Streams活页夹为Kafka Streams中的三种主要类型（KStream，KTable和GlobalKTable）提供了绑定功能。</p>
</div>
<div class="paragraph">
<p>作为此本机集成的一部分，Kafka Streams API提供的高级<a href="https://docs.confluent.io/current/streams/developer-guide/dsl-api.html">Streams DSL</a>可用于业务逻辑。</p>
</div>
<div class="paragraph">
<p>还提供了<a href="https://docs.confluent.io/current/streams/developer-guide/processor-api.html">处理器API</a>支持的早期版本。</p>
</div>
<div class="paragraph">
<p>如前所述，Spring Cloud Stream中的Kafka Streams支持仅在处理器模型中严格可用。可以应用一种模型，在该模型中，可以从入站主题读取消息，进行业务处理，然后可以将转换后的消息写入出站主题。它也可以在无出站目的地的处理器应用程序中使用。</p>
</div>
<div class="sect4">
<h5 id="streams-dsl"><a class="anchor" href="#streams-dsl"></a> <a class="link" href="#streams-dsl">流DSL</a></h5>
<div class="paragraph">
<p>此应用程序使用Kafka主题中的数据（例如， <code>words</code> ），在5秒的时间窗口内为每个唯一字计算字数，然后将计算结果发送到下游主题（例如， <code>counts</code> ）进行进一步处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@SpringBootApplication
@EnableBinding(KStreamProcessor.class)
public class WordCountProcessorApplication {

    @StreamListener("input")
    @SendTo("output")
    public KStream<?, WordCount> process(KStream<?, String> input) {
        return input
                .flatMapValues(value -> Arrays.asList(value.toLowerCase().split("\\W+")))
                .groupBy((key, value) -> value)
                .windowedBy(TimeWindows.of(5000))
                .count(Materialized.as("WordCounts-multi"))
                .toStream()
                .map((key, value) -> new KeyValue<>(null, new WordCount(key.key(), value, new Date(key.window().start()), new Date(key.window().end()))));
    }

    public static void main(String[] args) {
        SpringApplication.run(WordCountProcessorApplication.class, args);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦构建为超级jar（例如， <code>wordcount-processor.jar</code> ），则可以像下面一样运行上面的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>java -jar wordcount-processor.jar  --spring.cloud.stream.bindings.input.destination=words --spring.cloud.stream.bindings.output.destination=counts</code></pre>
</div>
</div>
<div class="paragraph">
<p>此应用程序将使用来自Kafka主题的消息<code>words</code>并将计算结果发布到输出主题<code>counts</code> 。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Stream将确保来自传入和传出主题的消息都自动绑定为KStream对象。作为开发人员，您可以专注于代码的业务方面，即编写处理器中所需的逻辑。框架自动处理设置Kafka Streams基础架构所需的Streams DSL特定配置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuration-options-3"><a class="anchor" href="#configuration-options-3"></a> <a class="link" href="#configuration-options-3">22.2.3。配置选项</a></h4>
<div class="paragraph">
<p>本节包含Kafka Streams绑定程序使用的配置选项。</p>
</div>
<div class="paragraph">
<p>有关与活页夹有关的常见配置选项和属性，请参阅<a href="#binding-properties">核心文档</a> 。</p>
</div>
<div class="sect4">
<h5 id="kafka-streams-properties"><a class="anchor" href="#kafka-streams-properties"></a> <a class="link" href="#kafka-streams-properties">Kafka Streams属性</a></h5>
<div class="paragraph">
<p>以下属性在活页夹级别可用，并且必须带有前缀<code>spring.cloud.stream.kafka.streams.binder.</code>文字。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">组态</dt>
<dd>
<p>使用包含与Apache Kafka Streams API有关的属性的键/值对进行映射。此属性必须以开头<code>spring.cloud.stream.kafka.streams.binder.</code> 。以下是使用此属性的一些示例。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde=org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.kafka.streams.binder.configuration.commit.interval.ms=1000</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关可能用于流配置的所有属性的更多信息，请参阅Apache Kafka Streams文档中的StreamsConfig JavaDocs。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">经纪人</dt>
<dd>
<p>经纪人网址</p>
<div class="paragraph">
<p>默认：<code>localhost</code></p>
</div>
</dd>
<dt class="hdlist1">zkNodes</dt>
<dd>
<p>Zookeeper URL</p>
<div class="paragraph">
<p>默认：<code>localhost</code></p>
</div>
</dd>
<dt class="hdlist1">serdeError</dt>
<dd>
<p>反序列化错误处理程序类型。可能的值为- <code>logAndContinue</code> ， <code>logAndFail</code>要么<code>sendToDlq</code></p>
<div class="paragraph">
<p>默认：<code>logAndFail</code></p>
</div>
</dd>
<dt class="hdlist1">applicationId</dt>
<dd>
<p>在绑定程序级别全局设置Kafka Streams应用程序的application.id的简便方法。如果应用程序包含多个<code>StreamListener</code>方法，然后应在每个输入绑定的绑定级别上设置application.id。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下属性<em>仅</em>适用于Kafka Streams生产者，并且必须使用前缀<code>spring.cloud.stream.kafka.streams.bindings.<binding name>.producer.</code>文字。为了方便起见，如果存在多个输出绑定并且它们都需要一个公共值，则可以使用前缀进行配置<code>spring.cloud.stream.kafka.streams.default.producer.</code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">钥匙串</dt>
<dd>
<p>要使用的密钥序列</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">valueSerde</dt>
<dd>
<p>使用价值服务</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">useNativeEncoding</dt>
<dd>
<p>标志以启用本机编码</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下属性<em>仅</em>适用于Kafka Streams使用者，并且必须使用前缀<code>spring.cloud.stream.kafka.streams.bindings.<binding name>.consumer.`literal. For convenience, if there multiple input bindings and they all require a common value, that can be configured by using the prefix `spring.cloud.stream.kafka.streams.default.consumer.</code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">applicationId</dt>
<dd>
<p>设置每个输入绑定的application.id。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">钥匙串</dt>
<dd>
<p>要使用的密钥序列</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">valueSerde</dt>
<dd>
<p>使用价值服务</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">物化</dt>
<dd>
<p>状态存储在使用传入的KTable类型时实现</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">useNativeDecoding</dt>
<dd>
<p>标志以启用本机解码</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">dlqName</dt>
<dd>
<p>DLQ主题名称。</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="timewindow-properties"><a class="anchor" href="#timewindow-properties"></a> <a class="link" href="#timewindow-properties">TimeWindow属性：</a></h5>
<div class="paragraph">
<p>窗口化是流处理应用程序中的重要概念。以下属性可用于配置时间窗口计算。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.kafka.streams.timeWindow.length</dt>
<dd>
<p>赋予此属性后，您可以自动连接<code>TimeWindows</code> bean进入应用程序。该值以毫秒为单位。</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.kafka.streams.timeWindow.advanceBy</dt>
<dd>
<p>值以毫秒为单位。</p>
<div class="paragraph">
<p>默认： <code>none</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multiple-input-bindings"><a class="anchor" href="#multiple-input-bindings"></a> <a class="link" href="#multiple-input-bindings">22.2.4。多个输入绑定</a></h4>
<div class="paragraph">
<p>对于需要多个传入KStream对象或KStream和KTable对象的组合的用例，Kafka Streams绑定程序提供了多个绑定支持。</p>
</div>
<div class="paragraph">
<p>让我们来看看它的作用。</p>
</div>
<div class="sect4">
<h5 id="multiple-input-bindings-as-a-sink"><a class="anchor" href="#multiple-input-bindings-as-a-sink"></a> <a class="link" href="#multiple-input-bindings-as-a-sink">多个输入绑定作为接收器</a></h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@EnableBinding(KStreamKTableBinding.class)
.....
.....
@StreamListener
public void process(@Input("inputStream") KStream<String, PlayEvent> playEvents,
                    @Input("inputTable") KTable<Long, Song> songTable) {
                    ....
                    ....
}

interface KStreamKTableBinding {

    @Input("inputStream")
    KStream<?, ?> inputStream();

    @Input("inputTable")
    KTable<?, ?> inputTable();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，应用程序被编写为接收器，即没有输出绑定，并且应用程序必须决定有关下游处理的内容。当您以这种方式编写应用程序时，您可能需要向下游发送信息或将其存储在状态存储中（有关可查询状态存储，请参见下文）。</p>
</div>
<div class="paragraph">
<p>对于传入的KTable，如果要将计算具体化为状态存储，则必须通过以下属性将其表示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.inputTable.consumer.materializedAs: all-songs</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例显示了使用KTable作为输入绑定。绑定器还支持GlobalKTable的输入绑定。当您必须确保应用程序的所有实例都可以访问主题中的数据更新时，GlobalKTable绑定非常有用。KTable和GlobalKTable绑定仅在输入上可用。活页夹支持KStream的输入和输出绑定。</p>
</div>
</div>
<div class="sect4">
<h5 id="multiple-input-bindings-as-a-processor"><a class="anchor" href="#multiple-input-bindings-as-a-processor"></a> <a class="link" href="#multiple-input-bindings-as-a-processor">多个输入绑定作为处理器</a></h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@EnableBinding(KStreamKTableBinding.class)
....
....

@StreamListener
@SendTo("output")
public KStream<String, Long> process(@Input("input") KStream<String, Long> userClicksStream,
                                     @Input("inputTable") KTable<String, String> userRegionsTable) {
....
....
}

interface KStreamKTableBinding extends KafkaStreamsProcessor {

    @Input("inputX")
    KTable<?, ?> inputTable();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="multiple-output-bindings-aka-branching"><a class="anchor" href="#multiple-output-bindings-aka-branching"></a> <a class="link" href="#multiple-output-bindings-aka-branching">22.2.5。多个输出绑定（又名分支）</a></h4>
<div class="paragraph">
<p>Kafka Streams允许根据某些谓词将出站数据分为多个主题。Kafka Streams绑定程序提供对此功能的支持，而不会损害通过以下方式公开的编程模型<code>StreamListener</code>在最终用户应用程序中。</p>
</div>
<div class="paragraph">
<p>您可以按照上面在字数示例中展示的常用方法编写应用程序。但是，使用分支功能时，您需要做一些事情。首先，您需要确保您的返回类型为<code>KStream[]</code>而不是常规<code>KStream</code> 。其次，您需要使用<code>SendTo</code>按顺序包含输出绑定的注释（请参见下面的示例）。对于这些输出绑定中的每一个，您都需要配置目标，内容类型等，并符合标准Spring Cloud Stream期望。</p>
</div>
<div class="paragraph">
<p>这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@EnableBinding(KStreamProcessorWithBranches.class)
@EnableAutoConfiguration
public static class WordCountProcessorApplication {

    @Autowired
    private TimeWindows timeWindows;

    @StreamListener("input")
    @SendTo({"output1","output2","output3})
    public KStream<?, WordCount>[] process(KStream<Object, String> input) {

            Predicate<Object, WordCount> isEnglish = (k, v) -> v.word.equals("english");
            Predicate<Object, WordCount> isFrench =  (k, v) -> v.word.equals("french");
            Predicate<Object, WordCount> isSpanish = (k, v) -> v.word.equals("spanish");

            return input
                    .flatMapValues(value -> Arrays.asList(value.toLowerCase().split("\\W+")))
                    .groupBy((key, value) -> value)
                    .windowedBy(timeWindows)
                    .count(Materialized.as("WordCounts-1"))
                    .toStream()
                    .map((key, value) -> new KeyValue<>(null, new WordCount(key.key(), value, new Date(key.window().start()), new Date(key.window().end()))))
                    .branch(isEnglish, isFrench, isSpanish);
    }

    interface KStreamProcessorWithBranches {

            @Input("input")
            KStream<?, ?> input();

            @Output("output1")
            KStream<?, ?> output1();

            @Output("output2")
            KStream<?, ?> output2();

            @Output("output3")
            KStream<?, ?> output3();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>特性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.output1.contentType: application/json
spring.cloud.stream.bindings.output2.contentType: application/json
spring.cloud.stream.bindings.output3.contentType: application/json
spring.cloud.stream.kafka.streams.binder.configuration.commit.interval.ms: 1000
spring.cloud.stream.kafka.streams.binder.configuration:
  default.key.serde: org.apache.kafka.common.serialization.Serdes$StringSerde
  default.value.serde: org.apache.kafka.common.serialization.Serdes$StringSerde
spring.cloud.stream.bindings.output1:
  destination: foo
  producer:
    headerMode: raw
spring.cloud.stream.bindings.output2:
  destination: bar
  producer:
    headerMode: raw
spring.cloud.stream.bindings.output3:
  destination: fox
  producer:
    headerMode: raw
spring.cloud.stream.bindings.input:
  destination: words
  consumer:
    headerMode: raw</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="message-conversion"><a class="anchor" href="#message-conversion"></a> <a class="link" href="#message-conversion">22.2.6。讯息转换</a></h4>
<div class="paragraph">
<p>类似于基于消息通道的活页夹应用程序一样，Kafka Streams活页夹可适应现成的内容类型转换，而不会做出任何妥协。</p>
</div>
<div class="paragraph">
<p>对于Kafka Streams操作而言，通常要知道用于正确转换键和值的SerDe类型。因此，在入站和出站转换时依靠Apache Kafka Streams库本身提供的SerDe工具可能比使用框架提供的内容类型转换更为自然。另一方面，您可能已经熟悉框架提供的内容类型转换模式，并且您希望继续用于入站和出站转换。</p>
</div>
<div class="paragraph">
<p>Kafka Streams联编程序实现支持这两个选项。</p>
</div>
<div class="sect5">
<h6 id="outbound-serialization"><a class="anchor" href="#outbound-serialization"></a> <a class="link" href="#outbound-serialization">出站序列化</a></h6>
<div class="paragraph">
<p>如果禁用本机编码（这是默认设置），则框架将使用用户设置的contentType转换消息（否则，默认<code>application/json</code>将被应用）。在这种情况下，它将忽略出站上设置的任何SerDe，以进行出站序列化。</p>
</div>
<div class="paragraph">
<p>这是在出站上设置contentType的属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.output.contentType: application/json</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是启用本地编码的属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.output.nativeEncoding: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在输出绑定上启用了本地编码（用户必须如上所述明确地启用它），则框架将在出站上跳过任何形式的自动消息转换。在这种情况下，它将切换到用户设置的Serde。的<code>valueSerde</code>将使用在实际输出绑定上设置的属性。这是一个例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.output.producer.valueSerde: org.apache.kafka.common.serialization.Serdes$StringSerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未设置此属性，则它将使用“默认” SerDe： <code>spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde</code> 。</p>
</div>
<div class="paragraph">
<p>值得一提的是，Kafka Streams活页夹不会在出站上序列化密钥-它仅依赖于Kafka本身。因此，您必须指定<code>keySerde</code>绑定上的属性，否则它将默认为应用程序范围的通用<code>keySerde</code> 。</p>
</div>
<div class="paragraph">
<p>绑定级别键序列号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.output.producer.keySerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>公用密钥序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用分支，则需要使用多个输出绑定。例如，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>interface KStreamProcessorWithBranches {

            @Input("input")
            KStream<?, ?> input();

            @Output("output1")
            KStream<?, ?> output1();

            @Output("output2")
            KStream<?, ?> output2();

            @Output("output3")
            KStream<?, ?> output3();
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>nativeEncoding</code>设置，然后您可以在各个输出绑定上设置不同的SerDe，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.output1.producer.valueSerde=IntegerSerde
spring.cloud.stream.kafka.streams.bindings.output2.producer.valueSerde=StringSerde
spring.cloud.stream.kafka.streams.bindings.output3.producer.valueSerde=JsonSerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>那如果你有<code>SendTo</code>像这样@SendTo（{“ output1”，“ output2”，“ output3”}）， <code>KStream[]</code>上面定义的适当的SerDe对象将应用分支中的。如果您不启用<code>nativeEncoding</code> ，则可以如下在输出绑定上设置不同的contentType值。在这种情况下，框架将使用适当的消息转换器来转换消息，然后再发送给Kafka。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.output1.contentType: application/json
spring.cloud.stream.bindings.output2.contentType: application/java-serialzied-object
spring.cloud.stream.bindings.output3.contentType: application/octet-stream</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="inbound-deserialization"><a class="anchor" href="#inbound-deserialization"></a> <a class="link" href="#inbound-deserialization">入站反序列化</a></h6>
<div class="paragraph">
<p>类似的规则适用于入站数据反序列化。</p>
</div>
<div class="paragraph">
<p>如果禁用本机解码（默认设置），则框架将使用用户设置的contentType转换消息（否则，默认设置为<code>application/json</code>将被应用）。在这种情况下，它将针对入站反序列化而忽略入站上设置的任何SerDe。</p>
</div>
<div class="paragraph">
<p>这是在入站上设置contentType的属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.input.contentType: application/json</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是启用本机解码的属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.bindings.input.nativeDecoding: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在输入绑定上启用了本机解码（用户必须如上所述明确启用它），则框架将跳过对入站进行的任何消息转换。在这种情况下，它将切换到用户设置的SerDe。的<code>valueSerde</code>将使用在实际输出绑定上设置的属性。这是一个例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.input.consumer.valueSerde: org.apache.kafka.common.serialization.Serdes$StringSerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未设置此属性，它将使用默认的SerDe： <code>spring.cloud.stream.kafka.streams.binder.configuration.default.value.serde</code> 。</p>
</div>
<div class="paragraph">
<p>值得一提的是，Kafka Streams联编程序不会反序列化入站密钥-它仅依赖于Kafka本身。因此，您必须指定<code>keySerde</code>绑定上的属性，否则它将默认为应用程序范围的通用<code>keySerde</code> 。</p>
</div>
<div class="paragraph">
<p>绑定级别键序列号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.input.consumer.keySerde</code></pre>
</div>
</div>
<div class="paragraph">
<p>公用密钥序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.default.key.serde</code></pre>
</div>
</div>
<div class="paragraph">
<p>与在出站上进行KStream分支的情况一样，为每个绑定设置值SerDe的好处是，如果您有多个输入绑定（多个KStreams对象），并且它们都需要单独的值SerDe，则可以分别配置它们。如果使用通用配置方法，则此功能将不适用。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="error-handling"><a class="anchor" href="#error-handling"></a> <a class="link" href="#error-handling">22.2.7。错误处理</a></h4>
<div class="paragraph">
<p>Apache Kafka Streams提供了本机处理反序列化错误引起的异常的功能。有关该支持的详细信息，请参阅<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-161%3A+streams+deserialization+exception+handlers">本</a>开箱，Apache的卡夫卡流提供2种反序列化异常处理的- <code>logAndContinue</code>和<code>logAndFail</code> 。顾名思义，前者将记录错误并继续处理下一条记录，而后者将记录错误并失败。 <code>LogAndFail</code>是默认的反序列化异常处理程序。</p>
</div>
<div class="sect4">
<h5 id="handling-deserialization-exceptions"><a class="anchor" href="#handling-deserialization-exceptions"></a> <a class="link" href="#handling-deserialization-exceptions">处理反序列化异常</a></h5>
<div class="paragraph">
<p>Kafka Streams活页夹通过以下属性支持选择异常处理程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.binder.serdeError: logAndContinue</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了上述两个反序列化异常处理程序之外，绑定程序还提供了第三个用于将错误记录（毒丸）发送到DLQ主题的代理。这是启用此DLQ异常处理程序的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.binder.serdeError: sendToDlq</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置以上属性后，所有反序列化错误记录都会自动发送到DLQ主题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.bindings.input.consumer.dlqName: foo-dlq</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果已设置，则错误记录将发送到主题<code>foo-dlq</code> 。如果未设置，它将创建一个名称为DLQ的主题<code>error.<input-topic-name>.<group-name></code> 。</p>
</div>
<div class="paragraph">
<p>在Kafka Streams活页夹中使用异常处理功能时，需要记住两件事。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>物业<code>spring.cloud.stream.kafka.streams.binder.serdeError</code>适用于整个应用程序。这意味着如果有多个<code>StreamListener</code>在同一应用程序中的方法，此属性将应用于所有方法。</p>
</li>
<li>
<p>反序列化的异常处理与本机反序列化和框架提供的消息转换一致。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="handling-non-deserialization-exceptions"><a class="anchor" href="#handling-non-deserialization-exceptions"></a> <a class="link" href="#handling-non-deserialization-exceptions">处理非反序列化异常</a></h5>
<div class="paragraph">
<p>对于Kafka Streams联编程序中的常规错误处理，最终用户应用程序可以处理应用程序级错误。作为为反序列化异常处理程序提供DLQ的副作用，Kafka Streams绑定程序提供了一种直接从您的应用程序访问DLQ发送bean的方法。一旦访问了该bean，就可以以编程方式将任何异常记录从应用程序发送到DLQ。</p>
</div>
<div class="paragraph">
<p>使用高级DSL仍然难以进行强大的错误处理。 Kafka Streams本身还不支持错误处理。</p>
</div>
<div class="paragraph">
<p>但是，当您在应用程序中使用低级处理器API时，有一些选项可以控制此行为。见下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@Autowired
private SendToDlqAndContinue dlqHandler;

@StreamListener("input")
@SendTo("output")
public KStream<?, WordCount> process(KStream<Object, String> input) {

    input.process(() -> new Processor() {
                ProcessorContext context;

                @Override
                public void init(ProcessorContext context) {
                    this.context = context;
                }

                @Override
                public void process(Object o, Object o2) {

                    try {
                        .....
                        .....
                    }
                    catch(Exception e) {
                        //explicitly provide the kafka topic corresponding to the input binding as the first argument.
                        //DLQ handler will correctly map to the dlq topic from the actual incoming destination.
                        dlqHandler.sendToDlq("topic-name", (byte[]) o1, (byte[]) o2, context.partition());
                    }
                }

                .....
                .....
    });
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="state-store"><a class="anchor" href="#state-store"></a> <a class="link" href="#state-store">22.2.8。国营商店</a></h4>
<div class="paragraph">
<p>使用DSL时，Kafka Streams会自动创建状态存储。使用处理器API时，您需要手动注册状态存储。为此，您可以使用<code>KafkaStreamsStateStore</code>注解。您可以指定存储的名称和类型，用于控制日志和禁用高速缓存的标志等。一旦在引导阶段由绑定程序创建了存储，就可以通过处理器API访问此状态存储。以下是一些执行此操作的原语。</p>
</div>
<div class="paragraph">
<p>创建状态存储：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@KafkaStreamsStateStore(name="mystate", type= KafkaStreamsStateStoreProperties.StoreType.WINDOW, lengthMs=300000)
public void process(KStream<Object, Product> input) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>访问状态存储：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Processor<Object, Product>() {

    WindowStore<Object, String> state;

    @Override
    public void init(ProcessorContext processorContext) {
        state = (WindowStore)processorContext.getStateStore("mystate");
    }
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="interactive-queries"><a class="anchor" href="#interactive-queries"></a> <a class="link" href="#interactive-queries">22.2.9。互动查询</a></h4>
<div class="paragraph">
<p>作为公开的Kafka Streams绑定程序API的一部分，我们公开了一个名为<code>InteractiveQueryService</code> 。您可以在应用程序中将其作为Spring bean访问。从您的应用程序访问该bean的一种简单方法是“自动装配”该bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>@Autowired
private InteractiveQueryService interactiveQueryService;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦获得对该bean的访问权限，就可以查询您感兴趣的特定状态存储。见下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>ReadOnlyKeyValueStore<Object, Object> keyValueStore =
                        interactiveQueryService.getQueryableStoreType("my-store", QueryableStoreTypes.keyValueStore());</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有多个Kafka Streams应用程序实例正在运行，则在以交互方式查询它们之前，您需要确定哪个应用程序实例承载密钥。
<code>InteractiveQueryService</code> API提供了识别主机信息的方法。</p>
</div>
<div class="paragraph">
<p>为了使其正常工作，您必须配置属性<code>application.server</code>如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.stream.kafka.streams.binder.configuration.application.server: <server>:<port></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是一些代码段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.apache.kafka.streams.state.HostInfo hostInfo = interactiveQueryService.getHostInfo("store-name",
                        key, keySerializer);

if (interactiveQueryService.getCurrentHostInfo().equals(hostInfo)) {

    //query from the store that is locally available
}
else {
    //query from the remote host
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="accessing-the-underlying-kafkastreams-object"><a class="anchor" href="#accessing-the-underlying-kafkastreams-object"></a> <a class="link" href="#accessing-the-underlying-kafkastreams-object">22.2.10。访问基础的KafkaStreams对象</a></h4>
<div class="paragraph">
<p><code>StreamBuilderFactoryBean</code>来自spring-kafka，负责构建<code>KafkaStreams</code>可以通过编程方式访问对象。每<code>StreamBuilderFactoryBean</code>注册为<code>stream-builder</code>并附加<code>StreamListener</code>方法名称。如果你的<code>StreamListener</code>方法命名为<code>process</code>例如，流构建器bean的名称为<code>stream-builder-process</code> 。由于这是工厂bean，因此应在前面加上一个＆符号（ <code>&</code> ）以编程方式访问它。以下是一个示例，并假设<code>StreamListener</code>方法命名为<code>process</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>StreamsBuilderFactoryBean streamsBuilderFactoryBean = context.getBean("&stream-builder-process", StreamsBuilderFactoryBean.class);
            KafkaStreams kafkaStreams = streamsBuilderFactoryBean.getKafkaStreams();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="state-cleanup"><a class="anchor" href="#state-cleanup"></a> <a class="link" href="#state-cleanup">22.2.11。状态清理</a></h4>
<div class="paragraph">
<p>默认情况下， <code>Kafkastreams.cleanup()</code>绑定停止时调用方法。请参阅<a href="https://docs.spring.io/spring-kafka/reference/html/_reference.html#_configuration">Spring Kafka文档</a> 。要修改此行为，只需添加一个<code>CleanupConfig</code><code>@Bean</code> （配置为在启动，停止或不启动时清除）到应用程序上下文；该bean将被检测到并连接到工厂bean中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rabbitmq-binder"><a class="anchor" href="#rabbitmq-binder"></a> <a class="link" href="#rabbitmq-binder">22.3。RabbitMQ活页夹</a></h3>

<div class="sect4">
<h5 id="usage-3"><a class="anchor" href="#usage-3"></a> <a class="link" href="#usage-3">用法</a></h5>
<div class="paragraph">
<p>要使用RabbitMQ绑定器，可以通过使用以下Maven坐标将其添加到Spring Cloud Stream应用程序中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，您可以使用Spring Cloud Stream RabbitMQ Starter，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml"><dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rabbitmq-binder-overview"><a class="anchor" href="#rabbitmq-binder-overview"></a> <a class="link" href="#rabbitmq-binder-overview">RabbitMQ活页夹概述</a></h5>
<div class="paragraph">
<p>以下简化图显示了RabbitMQ绑定程序的工作方式：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/rabbit-binder.png" alt="兔子粘合剂" width="300">
</div>
<div class="title">图18。RabbitMQ活页夹</div>
</div>
<div class="paragraph">
<p>默认情况下，RabbitMQ Binder实现将每个目标映射到一个<code>TopicExchange</code> 。对于每个消费群体， <code>Queue</code>必然会<code>TopicExchange</code> 。每个使用者实例都有一个对应的RabbitMQ <code>Consumer</code>其组的实例<code>Queue</code> 。对于分区的生产者和使用者，队列带有分区索引后缀，并将分区索引用作路由键。对于匿名消费者（没有<code>group</code>属性），则使用自动删除队列（具有随机的唯一名称）。</p>
</div>
<div class="paragraph">
<p>通过使用可选<code>autoBindDlq</code>选项，您可以配置活页夹以创建和配置死信队列（DLQ）（以及死信交换<code>DLX</code> ，以及路由基础结构）。默认情况下，死信队列具有目标名称，后跟<code>.dlq</code> 。如果启用了重试（ <code>maxAttempts > 1</code> ），则在重试用尽后，失败的消息将传递到DLQ。如果重试被禁用（ <code>maxAttempts = 1</code> ），您应该设置<code>requeueRejected</code>至<code>false</code> （默认设置），以便将失败的消息路由到DLQ，而不是重新排队。此外， <code>republishToDlq</code>使绑定程序将失败的消息发布到DLQ（而不是拒绝它）。此功能可让其他信息（例如<code>x-exception-stacktrace</code>标头）添加到标头中的邮件中。此选项不需要启用重试。只需尝试一次，您就可以重新发布失败的消息。从1.2版开始，您可以配置重新发布邮件的传递模式。见<a href="#spring-cloud-stream-rabbit-republish-delivery-mode"><code>republishDeliveryMode</code>财产</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">设置<code>requeueRejected</code>至<code>true</code> （与<code>republishToDlq=false</code> ）导致消息被重新排队并连续重新发送，除非失败的原因是短暂的，否则这可能不是您想要的。通常，您应该通过设置<code>maxAttempts</code>大于一或通过设置<code>republishToDlq</code>至<code>true</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关这些属性的更多信息，请参见<a href="#rabbit-binder-properties">RabbitMQ活页夹属性</a> 。</p>
</div>
<div class="paragraph">
<p>该框架没有提供任何标准机制来使用死信消息（或将其重新路由回主队列）。<a href="#rabbit-dlq-processing">死信队列处理</a>中描述了一些选项。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">当在Spring Cloud Stream应用程序中使用多个RabbitMQ绑定器时，重要的是禁用“ RabbitAutoConfiguration”，以避免来自<code>RabbitAutoConfiguration</code>应用于两种粘合剂。您可以使用<code>@SpringBootApplication</code>注解。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从2.0版开始， <code>RabbitMessageChannelBinder</code>设置<code>RabbitTemplate.userPublisherConnection</code>财产<code>true</code>这样，非事务生产方就可以避免对使用者造成死锁，如果由于代理上的<a href="https://www.rabbitmq.com/memory.html">内存警报</a>而阻止了缓存的连接，则可能发生死锁。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">目前， <code>multiplex</code>消费者（单个消费者正在收听多个队列）仅受消息驱动的消费者支持；被轮询的使用者只能从单个队列中检索消息。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="configuration-options-4"><a class="anchor" href="#configuration-options-4"></a> <a class="link" href="#configuration-options-4">配置选项</a></h5>
<div class="paragraph">
<p>本节包含特定于RabbitMQ活页夹和绑定通道的设置。</p>
</div>
<div class="paragraph">
<p>有关常规绑定配置选项和属性，请参阅<a href="https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-core-docs/src/main/asciidoc/spring-cloud-stream-overview.adoc#configuration-options">Spring Cloud Stream核心文档</a> 。</p>
</div>
<div class="sect5">
<h6 id="rabbit-binder-properties"><a class="anchor" href="#rabbit-binder-properties"></a> <a class="link" href="#rabbit-binder-properties">RabbitMQ活页夹属性</a></h6>
<div class="paragraph">
<p>默认情况下，RabbitMQ绑定程序使用Spring Boot的<code>ConnectionFactory</code> 。一致地，它支持RabbitMQ的所有Spring Boot配置选项。 （有关参考，请参阅<a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties">Spring Boot文档</a> ）。RabbitMQ配置选项使用<code>spring.rabbitmq</code>字首。</p>
</div>
<div class="paragraph">
<p>除了Spring Boot选项之外，RabbitMQ绑定器还支持以下属性：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">spring.cloud.stream.rabbit.binder.adminAddresses</dt>
<dd>
<p>以逗号分隔的RabbitMQ管理插件URL列表。仅在以下情况下使用<code>nodes</code>包含多个条目。此列表中的每个条目都必须在<code>spring.rabbitmq.addresses</code> 。仅当您使用RabbitMQ集群并希望从托管队列的节点使用时才需要。有关更多信息，请参见<a href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#queue-affinity">队列亲和力和LocalizedQueueConnectionFactory</a> 。</p>
<div class="paragraph">
<p>默认值：空。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.rabbit.binder.nodes</dt>
<dd>
<p>以逗号分隔的RabbitMQ节点名称列表。多个条目时，用于定位队列所在的服务器地址。此列表中的每个条目都必须在<code>spring.rabbitmq.addresses</code> 。仅当您使用RabbitMQ集群并希望从托管队列的节点使用时才需要。有关更多信息，请参见<a href="https://docs.spring.io/spring-amqp/reference/html/_reference.html#queue-affinity">队列亲和力和LocalizedQueueConnectionFactory</a> 。</p>
<div class="paragraph">
<p>默认值：空。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.rabbit.binder.compressionLevel</dt>
<dd>
<p>压缩绑定的压缩级别。看到<code>java.util.zip.Deflater</code> 。</p>
<div class="paragraph">
<p>默认： <code>1</code> （BEST_LEVEL）。</p>
</div>
</dd>
<dt class="hdlist1">spring.cloud.stream.binder.connection-name-prefix</dt>
<dd>
<p>连接名称前缀，用于命名此绑定程序创建的连接。名称是此前缀，后跟<code>#n</code> ，在哪里<code>n</code>每次打开新连接时递增。</p>
<div class="paragraph">
<p>默认值：无（Spring AMQP默认值）。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="rabbitmq-consumer-properties"><a class="anchor" href="#rabbitmq-consumer-properties"></a> <a class="link" href="#rabbitmq-consumer-properties">RabbitMQ消费者属性</a></h6>
<div class="paragraph">
<p>以下属性仅适用于Rabbit消费者，并且必须加上前缀<code>spring.cloud.stream.rabbit.bindings.<channelName>.consumer.</code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">确认模式</dt>
<dd>
<p>确认模式。</p>
<div class="paragraph">
<p>默认： <code>AUTO</code> 。</p>
</div>
</dd>
<dt class="hdlist1">autoBindDlq</dt>
<dd>
<p>是否自动声明DLQ并将其绑定到绑定器DLX。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">bindingRoutingKey</dt>
<dd>
<p>用于将队列绑定到交换的路由密钥（如果<code>bindQueue</code>是<code>true</code> ）。对于分区的目的地， <code>-<instanceIndex></code>附加。</p>
<div class="paragraph">
<p>默认： <code>#</code> 。</p>
</div>
</dd>
<dt class="hdlist1">bindQueue</dt>
<dd>
<p>是否将队列绑定到目标交换机。设置为<code>false</code>如果您已经建立了自己的基础架构，并且先前已经创建并绑定了队列。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">ConsumerTagPrefix</dt>
<dd>
<p>用于创建消费者标签；将被附加<code>#n</code>哪里<code>n</code>创建的每个消费者的增量。例： <code>${spring.application.name}-${spring.cloud.stream.bindings.input.group}-${spring.cloud.stream.instance-index}</code> 。</p>
<div class="paragraph">
<p>默认值：无-经纪人将生成随机的消费者标签。</p>
</div>
</dd>
<dt class="hdlist1">deadLetterQueueName</dt>
<dd>
<p>DLQ的名称</p>
<div class="paragraph">
<p>默认：<code>prefix+destination.dlq</code></p>
</div>
</dd>
<dt class="hdlist1">deadLetterExchange</dt>
<dd>
<p>分配给队列的DLX。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。</p>
<div class="paragraph">
<p>默认值：“ prefix + DLX”</p>
</div>
</dd>
<dt class="hdlist1">deadLetterExchangeType</dt>
<dd>
<p>分配给队列的DLX的类型。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。</p>
<div class="paragraph">
<p>默认值：“直接”</p>
</div>
</dd>
<dt class="hdlist1">deadLetterRoutingKey</dt>
<dd>
<p>分配给队列的死信路由键。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。</p>
<div class="paragraph">
<p>默认：<code>destination</code></p>
</div>
</dd>
<dt class="hdlist1">声明Dlx</dt>
<dd>
<p>是否声明目的地交换死信。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。调成<code>false</code>如果您有预配置的DLX。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">声明交换</dt>
<dd>
<p>是否声明目的地交换。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">延迟交易</dt>
<dd>
<p>是否将交易所声明为<code>Delayed Message Exchange</code> 。在代理上需要延迟的消息交换插件。的<code>x-delayed-type</code>参数设置为<code>exchangeType</code> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterExchange</dt>
<dd>
<p>如果声明了DLQ，则分配给该队列的DLX。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterRoutingKey</dt>
<dd>
<p>如果声明了DLQ，则分配给该队列的死信路由密钥。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqExpires</dt>
<dd>
<p>删除未使用的死信队列的时间（以毫秒为单位）。</p>
<div class="paragraph">
<p>默认：<code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">dlqLazy</dt>
<dd>
<p>用声明死信队列<code>x-queue-mode=lazy</code>论点。请参阅<a href="https://www.rabbitmq.com/lazy-queues.html">“延迟队列”</a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">dlqMaxLength</dt>
<dd>
<p>死信队列中的最大消息数。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxLengthBytes</dt>
<dd>
<p>所有消息中的死信队列中的最大总字节数。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxPriority</dt>
<dd>
<p>死信队列中邮件的最大优先级（0-255）。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqOverflow行为</dt>
<dd>
<p>何时采取行动<code>dlqMaxLength</code>要么<code>dlqMaxLengthBytes</code>被超过;目前<code>drop-head</code>要么<code>reject-publish</code>但请参阅RabbitMQ文档。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqTtl</dt>
<dd>
<p>声明时应用于死信队列的默认生存时间（以毫秒为单位）。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">持久订阅</dt>
<dd>
<p>订阅是否应持久。仅在以下情况下有效<code>group</code>也设置。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">exchangeAutoDelete</dt>
<dd>
<p>如果<code>declareExchange</code>是否为真，即是否应自动删除交换（即在删除最后一个队列之后将其删除）。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">耐用</dt>
<dd>
<p>如果<code>declareExchange</code>确实如此，交换是否应该持久（即，在代理重新启动后仍然存在）。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">exchangeType</dt>
<dd>
<p>交换类型： <code>direct</code> ， <code>fanout</code>要么<code>topic</code>适用于非分区目的地<code>direct</code>要么<code>topic</code>用于分区的目的地。</p>
<div class="paragraph">
<p>默认： <code>topic</code> 。</p>
</div>
</dd>
<dt class="hdlist1">独家</dt>
<dd>
<p>是否创建独家消费者。并发应为1 <code>true</code> 。通常在需要严格订购但使热备用实例在发生故障后接管时使用。看到<code>recoveryInterval</code> ，它控制备用实例尝试使用的频率。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">过期</dt>
<dd>
<p>删除未使用的队列的时间（以毫秒为单位）。</p>
<div class="paragraph">
<p>默认：<code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">failedDeclarationRetryInterval</dt>
<dd>
<p>丢失队列时尝试消耗队列之间的时间间隔（以毫秒为单位）。</p>
<div class="paragraph">
<p>默认值：5000</p>
</div>
</dd>
<dt class="hdlist1">headerPatterns</dt>
<dd>
<p>从入站邮件映射标头的模式。</p>
<div class="paragraph">
<p>默认： <code>['*']</code> （所有标头）。</p>
</div>
</dd>
<dt class="hdlist1">懒</dt>
<dd>
<p>用声明队列<code>x-queue-mode=lazy</code>论点。请参阅<a href="https://www.rabbitmq.com/lazy-queues.html">“延迟队列”</a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">maxConcurrency</dt>
<dd>
<p>最大消费者数。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">最长长度</dt>
<dd>
<p>队列中的最大消息数。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxLengthBytes</dt>
<dd>
<p>来自所有消息的队列中的最大总字节数。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxPriority</dt>
<dd>
<p>队列中消息的最大优先级（0-255）。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">missingQueuesFatal</dt>
<dd>
<p>当找不到队列时，是否将条件视为致命并停止侦听器容器。默认为<code>false</code>这样容器就可以继续尝试从队列中使用数据，例如，在使用群集且承载非HA队列的节点关闭时。</p>
<div class="paragraph">
<p>默认：<code>false</code></p>
</div>
</dd>
<dt class="hdlist1">溢出行为</dt>
<dd>
<p>何时采取行动<code>maxLength</code>要么<code>maxLengthBytes</code>被超过;目前<code>drop-head</code>要么<code>reject-publish</code>但请参阅RabbitMQ文档。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">预取</dt>
<dd>
<p>预取计数。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
<dt class="hdlist1">字首</dt>
<dd>
<p>要添加到名称的前缀<code>destination</code>和队列。</p>
<div class="paragraph">
<p>默认值：“”。</p>
</div>
</dd>
<dt class="hdlist1">queueDeclarationRetries</dt>
<dd>
<p>缺少队列时重试消耗的次数。仅在以下情况下相关<code>missingQueuesFatal</code>是<code>true</code> 。否则，容器将无限期地重试。</p>
<div class="paragraph">
<p>默认：<code>3</code></p>
</div>
</dd>
<dt class="hdlist1">queueNameGroupOnly</dt>
<dd>
<p>如果为true，请从名称等于<code>group</code> 。否则，队列名称为<code>destination.group</code> 。例如，在使用Spring Cloud Stream从现有RabbitMQ队列中使用时，这很有用。</p>
<div class="paragraph">
<p>默认值：false。</p>
</div>
</dd>
<dt class="hdlist1">recoveryInterval</dt>
<dd>
<p>连接恢复尝试之间的时间间隔（以毫秒为单位）。</p>
<div class="paragraph">
<p>默认： <code>5000</code> 。</p>
</div>
</dd>
<dt class="hdlist1">重新排队</dt>
<dd>
<p>禁用重试时，是否应重新排定传送失败的队列，或者<code>republishToDlq</code>是<code>false</code> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
</dl>
</div>
<div id="spring-cloud-stream-rabbit-republish-delivery-mode" class="dlist">
<dl>
<dt class="hdlist1">republishDeliveryMode</dt>
<dd>
<p>什么时候<code>republishToDlq</code>是<code>true</code> ，指定重新发布的邮件的传递方式。</p>
<div class="paragraph">
<p>默认：<code>DeliveryMode.PERSISTENT</code></p>
</div>
</dd>
<dt class="hdlist1">republishToDlq</dt>
<dd>
<p>默认情况下，拒绝重试后失败的消息将被拒绝。如果配置了死信队列（DLQ），RabbitMQ会将失败的消息（未更改）路由到DLQ。如果设置为<code>true</code> ，活页夹将带有其他标头的失败消息重新发布到DLQ，包括异常消息和来自最终失败原因的堆栈跟踪。</p>
<div class="paragraph">
<p>默认值：false</p>
</div>
</dd>
<dt class="hdlist1">交易的</dt>
<dd>
<p>是否使用交易渠道。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">ttl</dt>
<dd>
<p>声明时应用于队列的默认生存时间（以毫秒为单位）。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">txSize</dt>
<dd>
<p>两次之间的分娩次数。</p>
<div class="paragraph">
<p>默认： <code>1</code> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="advanced-listener-container-configuration"><a class="anchor" href="#advanced-listener-container-configuration"></a> <a class="link" href="#advanced-listener-container-configuration">高级侦听器容器配置</a></h6>
<div class="paragraph">
<p>要设置未公开为活页夹或绑定属性的侦听器容器属性，请添加单个类型的bean <code>ListenerContainerCustomizer</code>到应用程序上下文。将设置活页夹和绑定属性，然后将调用定制程序。定制器（ <code>configure()</code>方法）提供了队列名称以及使用者组作为参数。</p>
</div>
</div>
<div class="sect5">
<h6 id="rabbit-producer-properties"><a class="anchor" href="#rabbit-producer-properties"></a> <a class="link" href="#rabbit-producer-properties">兔子生产者属性</a></h6>
<div class="paragraph">
<p>以下属性仅适用于Rabbit生产者，并且必须加上前缀<code>spring.cloud.stream.rabbit.bindings.<channelName>.producer.</code> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">autoBindDlq</dt>
<dd>
<p>是否自动声明DLQ并将其绑定到绑定器DLX。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">batchingEnabled</dt>
<dd>
<p>是否启用生产者的邮件批处理。根据以下属性（在此列表的后三个条目中进行了描述），将消息批量处理为一条消息：'batchSize'， <code>batchBufferLimit</code>和<code>batchTimeout</code> 。有关更多信息，请参见<a href="https://docs.spring.io/spring-amqp//reference/html/_reference.html#template-batching">批处理</a> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">batchSize</dt>
<dd>
<p>启用批处理时要缓冲的消息数。</p>
<div class="paragraph">
<p>默认： <code>100</code> 。</p>
</div>
</dd>
<dt class="hdlist1">batchBufferLimit</dt>
<dd>
<p>启用批处理时的最大缓冲区大小。</p>
<div class="paragraph">
<p>默认： <code>10000</code> 。</p>
</div>
</dd>
<dt class="hdlist1">batchTimeout</dt>
<dd>
<p>启用批处理时的批处理超时。</p>
<div class="paragraph">
<p>默认： <code>5000</code> 。</p>
</div>
</dd>
<dt class="hdlist1">bindingRoutingKey</dt>
<dd>
<p>用于将队列绑定到交换的路由密钥（如果<code>bindQueue</code>是<code>true</code> ）。仅适用于未分区的目的地。仅适用于<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认： <code>#</code> 。</p>
</div>
</dd>
<dt class="hdlist1">bindQueue</dt>
<dd>
<p>是否将队列绑定到目标交换机。设置为<code>false</code>如果您已经建立了自己的基础架构，并且先前已经创建并绑定了队列。仅适用于<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">压缩</dt>
<dd>
<p>发送时是否应压缩数据。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">deadLetterQueueName</dt>
<dd>
<p>DLQ的名称仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>prefix+destination.dlq</code></p>
</div>
</dd>
<dt class="hdlist1">deadLetterExchange</dt>
<dd>
<p>分配给队列的DLX。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认值：“ prefix + DLX”</p>
</div>
</dd>
<dt class="hdlist1">deadLetterExchangeType</dt>
<dd>
<p>分配给队列的DLX的类型。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认值：“直接”</p>
</div>
</dd>
<dt class="hdlist1">deadLetterRoutingKey</dt>
<dd>
<p>分配给队列的死信路由键。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>destination</code></p>
</div>
</dd>
<dt class="hdlist1">声明Dlx</dt>
<dd>
<p>是否声明目的地交换死信。仅在以下情况下相关<code>autoBindDlq</code>是<code>true</code> 。调成<code>false</code>如果您有预配置的DLX。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">声明交换</dt>
<dd>
<p>是否声明目的地交换。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">delayExpression</dt>
<dd>
<p>SpEL表达式，用于评估应用于消息的延迟（ <code>x-delay</code>标头）。如果交换不是延迟的消息交换，则无效。</p>
<div class="paragraph">
<p>默认值：否<code>x-delay</code>标头已设置。</p>
</div>
</dd>
<dt class="hdlist1">延迟交易</dt>
<dd>
<p>是否将交易所声明为<code>Delayed Message Exchange</code> 。在代理上需要延迟的消息交换插件。的<code>x-delayed-type</code>参数设置为<code>exchangeType</code> 。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">deliveryMode</dt>
<dd>
<p>交付方式。</p>
<div class="paragraph">
<p>默认： <code>PERSISTENT</code> 。</p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterExchange</dt>
<dd>
<p>声明DLQ后，将分配给该队列的DLX。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqDeadLetterRoutingKey</dt>
<dd>
<p>声明DLQ后，分配给该队列的死信路由密钥。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqExpires</dt>
<dd>
<p>删除未使用的死信队列之前的时间（以毫秒为单位）。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">dlqLazy</dt>
<dd>
<p>用声明死信队列<code>x-queue-mode=lazy</code>论点。请参阅<a href="https://www.rabbitmq.com/lazy-queues.html">“延迟队列”</a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
</dd>
<dt class="hdlist1">dlqMaxLength</dt>
<dd>
<p>死信队列中的最大消息数。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxLengthBytes</dt>
<dd>
<p>所有消息中的死信队列中的最大总字节数。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">dlqMaxPriority</dt>
<dd>
<p>死信队列中邮件的最大优先级（0-255）仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">dlqTtl</dt>
<dd>
<p>声明时应用于死信队列的默认生存时间（以毫秒为单位）。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">exchangeAutoDelete</dt>
<dd>
<p>如果<code>declareExchange</code>是<code>true</code> ，是否应该自动删除交换（在删除最后一个队列后将其删除）。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">耐用</dt>
<dd>
<p>如果<code>declareExchange</code>是<code>true</code> ，该交换是否应该持久（在代理重新启动后生存）。</p>
<div class="paragraph">
<p>默认： <code>true</code> 。</p>
</div>
</dd>
<dt class="hdlist1">exchangeType</dt>
<dd>
<p>交换类型： <code>direct</code> ， <code>fanout</code>要么<code>topic</code>适用于非分区目的地<code>direct</code>要么<code>topic</code>用于分区的目的地。</p>
<div class="paragraph">
<p>默认： <code>topic</code> 。</p>
</div>
</dd>
<dt class="hdlist1">过期</dt>
<dd>
<p>删除未使用的队列之前的时间（以毫秒为单位）。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no expiration</code></p>
</div>
</dd>
<dt class="hdlist1">headerPatterns</dt>
<dd>
<p>标头要映射到出站邮件的模式。</p>
<div class="paragraph">
<p>默认： <code>['*']</code> （所有标头）。</p>
</div>
</dd>
<dt class="hdlist1">懒</dt>
<dd>
<p>用声明队列<code>x-queue-mode=lazy</code>论点。请参阅<a href="https://www.rabbitmq.com/lazy-queues.html">“延迟队列”</a> 。考虑使用策略而不是此设置，因为使用策略允许更改设置而不删除队列。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">最长长度</dt>
<dd>
<p>队列中的最大消息数。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxLengthBytes</dt>
<dd>
<p>来自所有消息的队列中的最大总字节数。仅适用于<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
<dt class="hdlist1">maxPriority</dt>
<dd>
<p>队列中消息的最大优先级（0-255）。仅适用于<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>none</code></p>
</div>
</dd>
<dt class="hdlist1">字首</dt>
<dd>
<p>要添加到名称的前缀<code>destination</code>交换。</p>
<div class="paragraph">
<p>默认值：“”。</p>
</div>
</dd>
<dt class="hdlist1">queueNameGroupOnly</dt>
<dd>
<p>什么时候<code>true</code> ，从名称等于<code>group</code> 。否则，队列名称为<code>destination.group</code> 。例如，在使用Spring Cloud Stream从现有RabbitMQ队列中使用时，这很有用。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认值：false。</p>
</div>
</dd>
<dt class="hdlist1">routingKeyExpression</dt>
<dd>
<p>一个SpEL表达式，用于确定发布消息时要使用的路由密钥。对于固定的路由键，请使用文字表达式，例如<code>routingKeyExpression='my.routingKey'</code>在属性文件中或<code>routingKeyExpression: '''my.routingKey'''</code>在YAML文件中。</p>
<div class="paragraph">
<p>默认： <code>destination</code>要么<code>destination-<partition></code>用于分区的目的地。</p>
</div>
</dd>
<dt class="hdlist1">交易的</dt>
<dd>
<p>是否使用交易渠道。</p>
<div class="paragraph">
<p>默认： <code>false</code> 。</p>
</div>
</dd>
<dt class="hdlist1">ttl</dt>
<dd>
<p>声明时适用于队列的默认生存时间（以毫秒为单位）。仅在以下情况下适用<code>requiredGroups</code>提供，然后仅提供给这些组。</p>
<div class="paragraph">
<p>默认：<code>no limit</code></p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">对于RabbitMQ，可以由外部应用程序设置内容类型标头。Spring Cloud Stream支持它们作为扩展内部协议的一部分，该协议用于任何类型的传输，包括Kafka（0.11之前的版本）之类的传输，其本身并不支持标头。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="retry-with-the-rabbitmq-binder"><a class="anchor" href="#retry-with-the-rabbitmq-binder"></a> <a class="link" href="#retry-with-the-rabbitmq-binder">使用RabbitMQ粘合剂重试</a></h5>
<div class="paragraph">
<p>当在活页夹中启用重试后，侦听器容器线程将在配置的任何退避期间暂停。当需要单个消费者进行严格订购时，这可能很重要。但是，对于其他用例，它阻止在该线程上处理其他消息。使用活页夹重试的另一种方法是设置带有时间的无效字母，以保留在无效字母队列（DLQ）上，以及在DLQ本身上进行无效字母配置。有关此处讨论的属性的更多信息，请参见“ <a href="#rabbit-binder-properties">RabbitMQ活页夹属性</a> ”。您可以使用以下示例配置来启用此功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>组<code>autoBindDlq</code>至<code>true</code> 。活页夹创建一个DLQ。 （可选）您可以在中指定名称<code>deadLetterQueueName</code> 。</p>
</li>
<li>
<p>组<code>dlqTtl</code>您想要在重新交付之间等待的退避时间。</p>
</li>
<li>
<p>设置<code>dlqDeadLetterExchange</code>到默认交换。来自DLQ的过期消息被路由到原始队列，因为默认<code>deadLetterRoutingKey</code>是队列名称（ <code>destination.group</code> ）。设置为默认交换是通过将属性设置为无值来实现的，如下例所示。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要强制对消息进行死信处理，请抛出一个<code>AmqpRejectAndDontRequeueException</code>或设置<code>requeueRejected</code>至<code>true</code> （默认）并抛出任何异常。</p>
</div>
<div class="paragraph">
<p>循环无休止地继续进行，这对于瞬态问题很好，但是您可能需要在尝试几次后放弃。幸运的是，RabbitMQ提供了<code>x-death</code>标头，可让您确定发生了多少个周期。</p>
</div>
<div class="paragraph">
<p>要在放弃后确认消息，请抛出<code>ImmediateAcknowledgeAmqpException</code> 。</p>
</div>
<div class="sect5">
<h6 id="putting-it-all-together"><a class="anchor" href="#putting-it-all-together"></a> <a class="link" href="#putting-it-all-together">放在一起</a></h6>
<div class="paragraph">
<p>以下配置创建了一个交换<code>myDestination</code>有队列<code>myDestination.consumerGroup</code>用通配符路由键绑定到主题交换<code>#</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>---
spring.cloud.stream.bindings.input.destination=myDestination
spring.cloud.stream.bindings.input.group=consumerGroup
#disable binder retries
spring.cloud.stream.bindings.input.consumer.max-attempts=1
#dlx/dlq setup
spring.cloud.stream.rabbit.bindings.input.consumer.auto-bind-dlq=true
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-ttl=5000
spring.cloud.stream.rabbit.bindings.input.consumer.dlq-dead-letter-exchange=
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>此配置创建绑定到直接交换的DLQ（ <code>DLX</code> ）的路由键为<code>myDestination.consumerGroup</code> 。当邮件被拒绝时，它们将被路由到DLQ。 5秒后，该消息到期，并通过使用队列名称作为路由键将其路由到原始队列，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="title">Spring Boot应用程序</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class XDeathApplication {

    public static void main(String[] args) {
        SpringApplication.run(XDeathApplication.class, args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(String in, @Header(name = "x-death", required = false) Map<?,?> death) {
        if (death != null && death.get("count").equals(3L)) {
            // giving up - don't send to DLX
            throw new ImmediateAcknowledgeAmqpException("Failed after 4 attempts");
        }
        throw new AmqpRejectAndDontRequeueException("failed");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意， <code>x-death</code>标头是一个<code>Long</code> 。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rabbit-error-channels"><a class="anchor" href="#rabbit-error-channels"></a> <a class="link" href="#rabbit-error-channels">错误通道</a></h5>
<div class="paragraph">
<p>从版本1.3开始，绑定程序无条件地将异常发送到每个使用者目标的错误通道，也可以将其配置为将异步生产者发送失败消息发送到错误通道。有关更多信息，请参见“ <a href="#binder-error-channels">[binder-error-channels]</a> ”。</p>
</div>
<div class="paragraph">
<p>RabbitMQ有两种类型的发送失败：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>返回的消息，</p>
</li>
<li>
<p>负面认可的<a href="https://www.rabbitmq.com/confirms.html">出版商确认</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>后者很少见。根据RabbitMQ文档，“ [仅在负责队列的Erlang进程中发生内部错误时，才会传递[nack]”。</p>
</div>
<div class="paragraph">
<p>除了启用生产者错误通道（如“ <a href="#binder-error-channels">[binder-error-channels]</a> ”中所述）外，RabbitMQ绑定器仅在正确配置连接工厂的情况下，才将消息发送到通道，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ccf.setPublisherConfirms(true);</code></p>
</li>
<li>
<p><code>ccf.setPublisherReturns(true);</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将Spring Boot配置用于连接工厂时，请设置以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring.rabbitmq.publisher-confirms</code></p>
</li>
<li>
<p><code>spring.rabbitmq.publisher-returns</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>的有效载荷<code>ErrorMessage</code>对于返回的消息是<code>ReturnedAmqpMessageException</code>具有以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>failedMessage</code> ：春季信息<code>Message<?></code>无法发送。</p>
</li>
<li>
<p><code>amqpMessage</code> ：原始的spring-amqp <code>Message</code> 。</p>
</li>
<li>
<p><code>replyCode</code> ：表示失败原因的整数值（例如312-无路由）。</p>
</li>
<li>
<p><code>replyText</code> ：指示失败原因的文本值（例如， <code>NO_ROUTE</code> ）。</p>
</li>
<li>
<p><code>exchange</code> ：发布消息的交易所。</p>
</li>
<li>
<p><code>routingKey</code> ：发布消息时使用的路由密钥。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于否定确认的确认，有效载荷为<code>NackedAmqpMessageException</code>具有以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>failedMessage</code> ：春季信息<code>Message<?></code>无法发送。</p>
</li>
<li>
<p><code>nackReason</code> ：原因（如果有），您可能需要检查代理日志以获取更多信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有对这些异常的自动处理（例如发送到<a href="#rabbit-dlq-processing">死信队列</a> ）。您可以使用自己的Spring Integration流使用这些异常。</p>
</div>
</div>
<div class="sect4">
<h5 id="rabbit-dlq-processing"><a class="anchor" href="#rabbit-dlq-processing"></a> <a class="link" href="#rabbit-dlq-processing">死信队列处理</a></h5>
<div class="paragraph">
<p>因为您无法预期用户将如何处置死信，所以该框架没有提供任何标准机制来处理它们。如果死信的原因是短暂的，则您可能希望将消息路由回原始队列。但是，如果问题是永久性问题，则可能导致无限循环。以下Spring Boot应用程序显示了一个示例，该示例说明了如何将这些消息路由回原始队列，但在尝试三次后将其移至第三个“停车场”队列。第二个示例使用<a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/">RabbitMQ延迟消息交换</a>为重新排队的消息引入延迟。在此示例中，每次尝试的延迟都会增加。这些示例使用<code>@RabbitListener</code>接收来自DLQ的消息。您也可以使用<code>RabbitTemplate.receive()</code>分批处理。</p>
</div>
<div class="paragraph">
<p>这些示例假定原始目的地是<code>so8400in</code>而消费群是<code>so8400</code> 。</p>
</div>
<div class="sect5">
<h6 id="non-partitioned-destinations"><a class="anchor" href="#non-partitioned-destinations"></a> <a class="link" href="#non-partitioned-destinations">非分区目的地</a></h6>
<div class="paragraph">
<p>前两个示例适用于目标<strong>未</strong>分区的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Integer retriesHeader = (Integer) failedMessage.getMessageProperties().getHeaders().get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader < 3) {
            failedMessage.getMessageProperties().getHeaders().put(X_RETRIES_HEADER, retriesHeader + 1);
            this.rabbitTemplate.send(ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    private static final String DELAY_EXCHANGE = "dlqReRouter";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Map<String, Object> headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader < 3) {
            headers.put(X_RETRIES_HEADER, retriesHeader + 1);
            headers.put("x-delay", 5000 * retriesHeader);
            this.rabbitTemplate.send(DELAY_EXCHANGE, ORIGINAL_QUEUE, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public DirectExchange delayExchange() {
        DirectExchange exchange = new DirectExchange(DELAY_EXCHANGE);
        exchange.setDelayed(true);
        return exchange;
    }

    @Bean
    public Binding bindOriginalToDelay() {
        return BindingBuilder.bind(new Queue(ORIGINAL_QUEUE)).to(delayExchange()).with(ORIGINAL_QUEUE);
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="partitioned-destinations"><a class="anchor" href="#partitioned-destinations"></a> <a class="link" href="#partitioned-destinations">分区目的地</a></h6>
<div class="paragraph">
<p>对于分区目标，所有分区都有一个DLQ。我们根据标题确定原始队列。</p>
</div>
<div class="sect6">
<h7 id="republishtodlqfalse"><a class="anchor" href="#republishtodlqfalse"></a><a class="link" href="#republishtodlqfalse"><code>republishToDlq=false</code></a></h7>
<div class="paragraph">
<p>什么时候<code>republishToDlq</code>是<code>false</code> ，RabbitMQ使用以下命令将消息发布到DLX / DLQ： <code>x-death</code>标头，其中包含有关原始目的地的信息，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_DEATH_HEADER = "x-death";

    private static final String X_RETRIES_HEADER = "x-retries";

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @SuppressWarnings("unchecked")
    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Map<String, Object> headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader < 3) {
            headers.put(X_RETRIES_HEADER, retriesHeader + 1);
            List<Map<String, ?>> xDeath = (List<Map<String, ?>>) headers.get(X_DEATH_HEADER);
            String exchange = (String) xDeath.get(0).get("exchange");
            List<String> routingKeys = (List<String>) xDeath.get(0).get("routing-keys");
            this.rabbitTemplate.send(exchange, routingKeys.get(0), failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect6">
<h7 id="republishtodlqtrue"><a class="anchor" href="#republishtodlqtrue"></a><a class="link" href="#republishtodlqtrue"><code>republishToDlq=true</code></a></h7>
<div class="paragraph">
<p>什么时候<code>republishToDlq</code>是<code>true</code> ，重新发布的恢复程序会将原始交换和路由密钥添加到标头中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class ReRouteDlqApplication {

    private static final String ORIGINAL_QUEUE = "so8400in.so8400";

    private static final String DLQ = ORIGINAL_QUEUE + ".dlq";

    private static final String PARKING_LOT = ORIGINAL_QUEUE + ".parkingLot";

    private static final String X_RETRIES_HEADER = "x-retries";

    private static final String X_ORIGINAL_EXCHANGE_HEADER = RepublishMessageRecoverer.X_ORIGINAL_EXCHANGE;

    private static final String X_ORIGINAL_ROUTING_KEY_HEADER = RepublishMessageRecoverer.X_ORIGINAL_ROUTING_KEY;

    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext context = SpringApplication.run(ReRouteDlqApplication.class, args);
        System.out.println("Hit enter to terminate");
        System.in.read();
        context.close();
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @RabbitListener(queues = DLQ)
    public void rePublish(Message failedMessage) {
        Map<String, Object> headers = failedMessage.getMessageProperties().getHeaders();
        Integer retriesHeader = (Integer) headers.get(X_RETRIES_HEADER);
        if (retriesHeader == null) {
            retriesHeader = Integer.valueOf(0);
        }
        if (retriesHeader < 3) {
            headers.put(X_RETRIES_HEADER, retriesHeader + 1);
            String exchange = (String) headers.get(X_ORIGINAL_EXCHANGE_HEADER);
            String originalRoutingKey = (String) headers.get(X_ORIGINAL_ROUTING_KEY_HEADER);
            this.rabbitTemplate.send(exchange, originalRoutingKey, failedMessage);
        }
        else {
            this.rabbitTemplate.send(PARKING_LOT, failedMessage);
        }
    }

    @Bean
    public Queue parkingLot() {
        return new Queue(PARKING_LOT);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="partitioning-with-the-rabbitmq-binder"><a class="anchor" href="#partitioning-with-the-rabbitmq-binder"></a> <a class="link" href="#partitioning-with-the-rabbitmq-binder">使用RabbitMQ活页夹进行分区</a></h5>
<div class="paragraph">
<p>RabbitMQ不支持本地分区。</p>
</div>
<div class="paragraph">
<p>有时，将数据发送到特定分区是有利的-例如，当您要严格订购消息处理时，特定客户的所有消息都应转到同一分区。</p>
</div>
<div class="paragraph">
<p>的<code>RabbitMessageChannelBinder</code>通过将每个分区的队列绑定到目标交换机来提供分区。</p>
</div>
<div class="paragraph">
<p>以下Java和YAML示例显示了如何配置生产者：</p>
</div>
<div class="listingblock">
<div class="title">制片人</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Source.class)
public class RabbitPartitionProducerApplication {

    private static final Random RANDOM = new Random(System.currentTimeMillis());

    private static final String[] data = new String[] {
            "abc1", "def1", "qux1",
            "abc2", "def2", "qux2",
            "abc3", "def3", "qux3",
            "abc4", "def4", "qux4",
            };

    public static void main(String[] args) {
        new SpringApplicationBuilder(RabbitPartitionProducerApplication.class)
            .web(false)
            .run(args);
    }

    @InboundChannelAdapter(channel = Source.OUTPUT, poller = @Poller(fixedRate = "5000"))
    public Message<?> generate() {
        String value = data[RANDOM.nextInt(data.length)];
        System.out.println("Sending: " + value);
        return MessageBuilder.withPayload(value)
                .setHeader("partitionKey", value)
                .build();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">    spring:
      cloud:
        stream:
          bindings:
            output:
              destination: partitioned.destination
              producer:
                partitioned: true
                partition-key-expression: headers['partitionKey']
                partition-count: 2
                required-groups:
                - myGroup</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">
<div class="paragraph">
<p>先前示例中的配置使用默认分区（ <code>key.hashCode() % partitionCount</code> ）。根据键值，这可能会或可能不会提供适当的平衡算法。您可以使用<code>partitionSelectorExpression</code>要么<code>partitionSelectorClass</code>属性。</p>
</div>
<div class="paragraph">
<p>的<code>required-groups</code>仅当在部署生产者时需要供应使用者队列时，才需要该属性。否则，发送到分区的所有消息都将丢失，直到部署了相应的使用者为止。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下配置提供了主题交换：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/part-exchange.png" alt="零件交换">
</div>
</div>
<div class="paragraph">
<p>该交换绑定了以下队列：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/part-queues.png" alt="部分队列">
</div>
</div>
<div class="paragraph">
<p>以下绑定将队列与交换关联：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/part-bindings.png" alt="零件绑定">
</div>
</div>
<div class="paragraph">
<p>以下Java和YAML示例是前面示例的继续，并显示了如何配置使用者：</p>
</div>
<div class="listingblock">
<div class="title">消费者</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
@EnableBinding(Sink.class)
public class RabbitPartitionConsumerApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(RabbitPartitionConsumerApplication.class)
            .web(false)
            .run(args);
    }

    @StreamListener(Sink.INPUT)
    public void listen(@Payload String in, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {
        System.out.println(in + " received from queue " + queue);
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">    spring:
      cloud:
        stream:
          bindings:
            input:
              destination: partitioned.destination
              group: myGroup
              consumer:
                partitioned: true
                instance-index: 0</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="重要"></i>
</td>
<td class="content">的<code>RabbitMessageChannelBinder</code>不支持动态缩放。每个分区至少必须有一个使用方。消费者的<code>instanceIndex</code>用于指示使用哪个分区。诸如Cloud Foundry之类的平台只能具有一个实例<code>instanceIndex</code> 。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<h1 id="appendix-compendium-of-configuration-properties" class="sect0"><a class="anchor" href="#appendix-compendium-of-configuration-properties"></a> <a class="link" href="#appendix-compendium-of-configuration-properties">附录：配置属性概述</a></h1>
<div class="openblock partintro">
<div class="content">
<table class="tableblock frame-topbot grid-all stretch">
<colgroup>
<col style="width:33.3333%">
<col style="width:33.3333%">
<col style="width:33.3334%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">默认</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws.paramstore.default-context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws.paramstore.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用了AWS Parameter Store支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws.paramstore.fail-fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则在配置查找期间引发异常，否则，记录警告。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws.paramstore.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.application.name的替代品，用于在AWS Parameter Store中查找值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws.paramstore.prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/配置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">前缀，指示每个属性的第一级。值必须以正斜杠开头，后跟有效路径段或为空。默认为“ / config”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws.paramstore.profile-分隔符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">_</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.access-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与静态提供程序一起使用的访问密钥。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.instance-profile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置实例配置文件凭据提供程序，而无需进一步配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.profile-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AWS配置文件名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.profile-path</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AWS配置文件路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.secret-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与静态提供程序一起使用的密钥。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.use-default-aws-credentials-chain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用DefaultAWSCredentials链而不是配置自定义证书链。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.loader.core-pool-size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于并行S3交互的Task Executor的核心池大小。 @see org.springframework.scheduling.concurrent。ThreadPoolTaskExecutor＃setCorePoolSize（int）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.loader.max-pool-size</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于并行S3交互的Task Executor的最大池大小。 @see org.springframework.scheduling.concurrent。ThreadPoolTaskExecutor＃setMaxPoolSize（int）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.loader.queue-capacity</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">备份的S3请求的最大队列容量。 @see org.springframework.scheduling.concurrent。ThreadPoolTaskExecutor＃setQueueCapacity（int）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.region.auto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用基于EC2元数据服务的自动区域检测。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.region.static</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.stack.auto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为应用程序启用自动堆栈名称检测。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.stack.name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">myStackName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">手动配置的堆栈名称的名称，该名称将用于检索资源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误加密</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记为如果存在加密或解密错误，则进程应失败。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密密钥</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对称密钥。作为更强大的选择，请考虑使用密钥库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">crypto.key-store.alias</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">商店中密钥的别名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">crypto.key-store.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">密钥库文件的位置，例如classpath：/keystore.jks。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密密钥存储密码</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">锁定密钥库的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">crypto.key-store.secret</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秘密保护密钥（默认与密码相同）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">crypto.key-store.type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">KeyStore类型。默认为jks。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密算法</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的RSA算法（DEFAULT或OEAP）。设置后，请勿更改（否则现有密码将不可解密）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">crypto.rsa.salt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">死牛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">盐，用于加密密文的随机秘密。设置后，请勿更改（否则现有密码将不可解密）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">crypto.rsa.strong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示在内部使用“强” AES加密的标志。如果为true，则将GCM算法应用于AES加密字节。默认值为false（在这种情况下，将使用“标准” CBC代替）。设置后，请勿更改（否则现有密码将不可解密）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密盐</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">死牛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对称密钥的盐，以十六进制编码的字节数组的形式。作为更强大的选择，请考虑使用密钥库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">endpoints.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用/ zookeeper端点以检查Zookeeper的状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">eureka.client.healthcheck.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Eureka健康检查处理程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">health.config.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示应安装配置服务器运行状况指示器的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">health.config。生存时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缓存结果的生存时间（以毫秒为单位）。默认值300000（5分钟）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hystrix.metrics.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Hystrix指标轮询。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hystrix.metrics.polling-interval-ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">后续的指标轮询之间的间隔。默认为2000毫秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hystrix.shareSecurityContext</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Hystrix并发策略插件挂钩的自动配置功能，该挂钩将转移<code>SecurityContext</code>从您的主线程到Hystrix命令使用的线程。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.bindings.cache。生存时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以缓存响应的最长时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.bindings.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用绑定端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.bus-env.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用bus-env端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.bus-refresh.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用总线刷新端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.channels.cache。生存时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以缓存响应的最长时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.channels.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用通道端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.consul.cache。生存时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以缓存响应的最长时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">管理端点咨询启用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用领事端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.env.post.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用可写环境端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.features.cache。生存时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以缓存响应的最长时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.features.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用功能端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.gateway.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用网关端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.hystrix.config</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hystrix设置。传统上，这些是使用servlet参数设置的。有关更多详细信息，请参考Hystrix的文档。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.hystrix.stream.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用hystrix.stream端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.pause.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用/ pause端点（发送Lifecycle.stop（））。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.refresh.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用/ refresh端点以刷新配置并重新初始化刷新作用域的bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.restart.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用/ restart端点以重新启动应用程序上下文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.resume.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用/ resume端点（发送Lifecycle.start（））。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.service-registry.cache。生存时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以缓存响应的最长时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.endpoint.service-registry.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用服务注册端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.health.binders.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许启用/禁用活页夹的健康指标。如果要完全禁用运行状况指示器，则将其设置为<code>false</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">管理健康刷新</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为刷新范围启用运行状况终结点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.health.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为Zookeeper启用健康端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.binders.hystrix.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用OK Http Client工厂bean的创建。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.batch-size</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.connect-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用云监视指标。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.namespace</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">云监视名称空间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.num-threads</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.read-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">management.metrics.export.cloudwatch.step</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.checksum-policy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.connect-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.enable-repository-listener</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.local存储库</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maven.offline</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maven代理</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.remote存储库</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.request-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.resolve-pom</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">maven.update-policy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">proxy.auth。负载均衡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">proxy.auth.routes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个路由的身份验证策略。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ribbon.eager-load.clients</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ribbon.eager-load.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能区.http.client.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不推荐使用的属性，以启用Ribbon RestClient。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ribbon.okhttp.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用将OK HTTP Client与功能区一起使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ribbon.restclient.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用不推荐使用的Ribbon RestClient的使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能区。安全端口</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.bus.ack.destination-service</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">想要听音乐的服务。默认情况下为null（表示所有服务）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.bus.ack.ack</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以关闭acks（默认打开）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.bus.estination</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">springCloudBus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">消息的Spring Cloud Stream目标名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.bus.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示启用总线的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.bus.env。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以关闭环境更改事件（默认为打开）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.bus.id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该应用程序实例的标识符。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.bus.refresh。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以关闭刷新事件（默认为打开）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.bus.trace.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以打开跟踪（默认关闭）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.circuitbreaker.hystrix.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Hystrix Spring Cloud CircuitBreaker API实现的自动配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery.default-server-port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能区未定义任何端口时使用的端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示启用发现的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery。心跳频率</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">心跳的轮询频率（以毫秒为单位）。客户端将以此频率进行轮询并广播服务ID列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery.internal-domain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">apps.internal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置为使用本机DNS服务发现时的默认内部域。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所使用的发现客户端的顺序<code>CompositeDiscoveryClient</code>用于排序可用的客户端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery.use-container-ip</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用BOSH DNS时是否解析主机名。为了使用此功能，spring.cloud.cloudfoundry.discovery.use-dns必须为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.discovery.use-dns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否使用BOSH DNS进行发现。为了使用此功能，您的Cloud Foundry安装必须支持服务发现。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.org</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最初定位的组织名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户进行身份验证和获取令牌的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.skip-ssl-validation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.space</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最初定位的空间名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud Foundry API（Cloud Controller）的URL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.cloudfoundry.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要进行身份验证的用户名（通常是电子邮件地址）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.compatibility-verifier.compatible-boot-versions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.1.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Boot依赖项的默认接受版本。如果您不想指定具体的值，则可以为补丁程序版本设置{@code x}。示例：{@ code 3.4.x}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.compatibility-verifier.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用创建Spring Cloud兼容性验证的功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.allow-override</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示可以使用{@link #isOverrideSystemProperties（）systemPropertiesOverride}的标志。设置为false可以防止用户意外更改默认值。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示已启用配置服务器发现的标志（将通过发现来查找配置服务器URL）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.discovery.service-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置服务器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于找到配置服务器的服务ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示已启用远程配置的标志。默认为true;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.fail-fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示连接服务器失败的致命标志（默认为false）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于创建客户端请求的其他标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.label</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于拉取远程配置属性的标签名称。默认设置是在服务器上设置的（通常是基于git的服务器的“ master”）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于获取远程属性的应用程序的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.override-none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标志，指示当{@link #setAllowOverride（boolean）allowOverride}为true时，外部属性应具有最低优先级，并且不应覆盖任何现有的属性源（包括本地配置文件）。默认为false。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.override-system-properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示外部属性应覆盖系统属性的标志。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与远程服务器联系时使用的密码（HTTP基本）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.profile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取远程配置时使用的默认配置文件（以逗号分隔）。默认为“默认”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.request-connect-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等待连接到配置服务器时超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.request-read-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等待从配置服务器读取数据时超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.retry.initial-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">初始重试间隔（以毫秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.retry.max-尝试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大尝试次数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.retry.max-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">退避的最大间隔。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.retry.multiplier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下一个间隔的乘数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.send状态</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示是否发送状态的标志。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.accept-empty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示未找到应用程序是否需要发送HTTP 404的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.awss3.bucket</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含配置的S3存储桶的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.awss3.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.awss3.region</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含配置的AWS区域。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.bootstrap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示配置服务器应使用远程存储库中的属性初始化其自己的环境的标志。默认情况下处于关闭状态，因为它会延迟启动，但是在将服务器嵌入另一个应用程序时很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.credhub.ca-cert-files</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.credhub.connection-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.credhub.oauth2.registration-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.credhub.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.credhub.read-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.credhub.url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.default-application-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入请求没有特定请求时的默认应用程序名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.default标签</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入请求没有特定标签时的默认存储库标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.default-profile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入请求没有特定请求时的默认应用程序配置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.encrypt.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在发送到客户端之前，启用环境属性的解密。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.encrypt.plain-text-encrypt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用对由纯文本终结点{@link org.springframework.cloud.config.server.resource提供服务的环境属性的解密。ResourceController}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.basedir</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库本地工作副本的基本目录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.clone-on-start</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示应在启动时（而不是按需）克隆存储库的标志。通常会导致启动速度较慢，但首次查询速度更快。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.default-label</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与远程存储库一起使用的默认标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.delete-untracked分支</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于指示如果删除了其原始跟踪的分支，则应在本地删除该分支的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.force-pull</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示存储库应强制拉动的标志。如果为true，则放弃任何本地更改并从远程存储库获取。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.host-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有效的SSH主机密钥。如果还设置了hostKeyAlgorithm，则必须设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.host-key-algorithm</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ssh-dss，ssh-rsa，ecdsa-sha2-nistp256，ecdsa-sha2-nistp384或ecdsa-sha2-nistp521中的一种。如果还设置了hostKey，则必须设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.ignore-local-ssh-settings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，请使用基于属性的SSH而非基于文件的SSH配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.known-hosts文件</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自定义.known_hosts文件的位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境存储库的顺序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.passphrase</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于解锁ssh私钥的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">远程存储库认证密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.preferred-authentications</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖服务器身份验证方法顺序。如果服务器在publickey方法之前具有键盘交互身份验证，则这应该可以避免登录提示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.private-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有效的SSH私钥。如果ignoreLocalSshSettings为true并且Git URI为SSH格式，则必须设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.proxy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP代理配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git。刷新率</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">刷新git存储库之间的时间（以秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.repos</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库标识符到位置和其他属性的映射。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.search-paths</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">搜索要在本地工作副本中使用的路径。默认情况下，仅搜索根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.skip-ssl-validation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与通过HTTPS连接提供服务的存储库进行通信时，指示应绕过SSL证书验证的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.strict-主机密钥检查</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为false，请忽略主机密钥错误。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取HTTP或SSH连接的超时（以秒为单位）（如果适用），默认为5秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git.uri</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">远程存储库的URI。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.git。用户名</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用远程存储库进行身份验证的用户名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.health.repositories</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.jdbc.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.jdbc.sql</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从属性中选择键，值，其中APPLICATION =？和PROFILE =？和LABEL =？</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于查询数据库的键和值的SQL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.native.add-label-locations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以确定是否应添加标签位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.native.default-label</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.native。错误失败</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于确定解密期间如何处理异常的标志（默认为false）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.native.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.native.search-locations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">搜索配置文件的位置。默认与Spring Boot应用程序相同，因此[classpath：/，classpath：/ config /，file：./，file：./ config /]。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.native.version</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将为本机存储库报告的版本字符串。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.overrides</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性源的额外映射将无条件发送给所有客户端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.prefix</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置资源路径的前缀（默认为空）。当您不想更改上下文路径或servlet路径时，在嵌入另一个应用程序时很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.redis.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.strip-document-from-yaml</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示应以“本机”形式返回作为文本或集合（不是地图）的YAML文档的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.basedir</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库本地工作副本的基本目录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.default-label</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与远程存储库一起使用的默认标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境存储库的顺序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.passphrase</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于解锁ssh私钥的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">远程存储库认证密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.search-paths</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">搜索要在本地工作副本中使用的路径。默认情况下，仅搜索根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.strict主机密钥检查</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从不在已知主机列表中的远程服务器拒绝传入的SSH主机密钥。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn.uri</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">远程存储库的URI。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.svn。用户名</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用远程存储库进行身份验证的用户名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秘密</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管箱后端。默认为秘密。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.default-key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有应用程序共享的保管库密钥。默认为应用程序。设置为空禁用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管箱主机。默认为127.0.0.1。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.kv版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示使用哪个版本的Vault kv后端的值。默认为1。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.namespace</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vault X-Vault-Namespace标头的值。默认为空。这仅是Vault Enterprise功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管库端口。默认为8200</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.profile分隔符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">，</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管库配置文件分隔符。默认为逗号。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.proxy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP代理配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.scheme</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">http</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保险柜方案。默认为http。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.skip-ssl-validation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与通过HTTPS连接提供服务的存储库进行通信时，指示应绕过SSL证书验证的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.server.vault.timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取HTTP连接的超时时间（以秒为单位），默认为5秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.token</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">安全令牌通过传递到基础环境存储库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config.uri</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ <a href="http://localhost:8888" class="bare">本地主机：8888</a> ]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">远程服务器的URI（默认为<a href="http://localhost:8888" class="bare">localhost：8888</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.config。用户名</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与远程服务器联系时要使用的用户名（HTTP基本）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.acl令牌</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.data-key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果format为Format。属性或格式。YAML，然后将以下字段用作查找领事以进行配置的关键字。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.default-context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.consul.config。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.fail-fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则在配置查找期间引发异常，否则，记录警告。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.format</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.application.name的替代品，用于在领事KV中查找值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.profile-分隔符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">，</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.watch.delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">手表的固定延迟值，以毫秒为单位。预设为1000。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.watch.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了手表。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.config.watch.wait-time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">55</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等待（或阻止）观看查询的秒数，默认为55。需要小于默认的ConsulClient（默认为60）。要增加ConsulClient超时，请使用自定义ConsulRawClient和自定义HttpClient创建ConsulClient bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.acl令牌</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.catalog-services-watch-delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">观看领事目录的呼叫之间的延迟（以毫秒为单位），默认为1000。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.catalog-services-watch-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">观看领事目录时阻止的秒数，默认为2。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.consistency-mode</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">健康服务请求的一致性模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.datacenters</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在服务器列表中查询的serviceId→数据中心的映射。这允许在另一个数据中心中查找服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.default-query-tag</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果serverListQueryTags中未列出服务列表中要查询的标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.default-zone-metadata-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">区</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务实例区域来自元数据。这允许更改元数据标签名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.deregister</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在领事中禁用自动注销服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用服务发现？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.fail-fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则在服务注册期间引发异常，否则，记录警告（默认为true）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-critical-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注销超时的关键时间超过超时（例如30m）的关键时间。需要领事版本7.x或更高版本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用于健康检查呼叫的标题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行状况检查的频率（例如10s），默认为10s。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/执行器/健康</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">调用以进行健康检查的备用服务器路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">健康检查超时（例如10秒）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-tls-skip-verify</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果服务检查为true，则跳过证书验证，否则运行证书验证。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.health-check-url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自定义运行状况检查网址会覆盖默认值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.consul.discovery.heartbeat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.interval-ratio</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.ttl-unit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.heartbeat.ttl值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.hostname</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问服务器时要使用的主机名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.include-hostname-in-instance-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注册服务时，主机名是否包括在默认实例ID中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.instance-group</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务实例组。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.instance-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">唯一的服务实例ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.instance-zone</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务实例区域。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.ip地址</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问服务时要使用的IP地址（还必须设置preferredIpAddress才能使用）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.consul.discovery.lifecycle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.management-port</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于注册管理服务的端口（默认为管理端口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.management-后缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">管理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注册管理服务时要使用的后缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.management-tags</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注册管理服务时要使用的标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所使用的发现客户端的顺序<code>CompositeDiscoveryClient</code>用于排序可用的客户端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.port</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于注册服务的端口（默认为监听端口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.prefer-agent-address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">我们将如何确定要使用的地址的来源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.prefer-ip-address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注册时使用IP地址而不是主机名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.query-passing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将“传递”参数添加到/ v1 / health / service / serviceName。这会将运行状况检查传递到服务器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.register</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在领事中注册为服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.register-health-check</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在领事中注册健康检查。在服务开发期间很有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring.Cloud.Consul.Discovery.Scheme</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">http</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否注册http或https服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.server-list-query-tags</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在服务器列表中查询的serviceId的→标记的映射。这允许通过单个标签过滤服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.service-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.discovery.tags</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注册服务时要使用的标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.consul。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用了spring-cloud-consul。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地主机</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">领事代理主机名。默认为'localhost'。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">领事代理端口。默认为'8500'。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.retry.initial-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">初始重试间隔（以毫秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.retry.max-尝试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大尝试次数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.retry.max-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">退避的最大间隔。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.retry.multiplier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下一个间隔的乘数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.scheme</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">领事代理方案（HTTP / HTTPS）。如果地址中没有方案-客户端将使用HTTP。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.tls.certificate-password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">打开证书的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.tls.certificate-path</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">证书的文件路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.tls.key-store-instance-type</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的关键框架的类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.tls.key-store-password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">外部密钥库的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.tls.key-store-path</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">外部密钥库的路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.cloudfoundry.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.discovery.client.composite-indicator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用发现客户端复合运行状况指示器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.discovery.client.health-indicator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.health-indicator.include-description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.simple.instances</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.simple.local.instance-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务实例的唯一标识符或名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.simple.local.metadata</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务实例的元数据。发现客户端可将其用于按实例修改其行为，例如在负载平衡时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.simple.local.service-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务的标识符或名称。多个实例可能共享相同的服务ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.simple.local.uri</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务实例的URI。将被解析以提取方案，主机和端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.client.simple.order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用发现客户端运行状况指示器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.features.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用功能端点。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.compile</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能主体的配置，将进行编译。映射中的键是函数名称，值是包含键“ lambda”（要编译的主体）和可选的“类型”（默认为“ function”）的映射。如果模棱两可，还可以包含“ inputType”和“ outputType”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.definition</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义要使用的功能。这可以是函数名称（例如“ myFunction”）或函数组成定义（例如“ myFunction | yourFunction”）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.imports</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一组包含功能主体的文件的配置，这些文件将被导入和编译。映射中的键是函数名称，值是另一个映射，包含要编译的文件的“位置”和（可选）“类型”（默认为“功能”）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.routing-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SpEL表达式应导致函数定义（例如，函数名称或组合指令）。注意：SpEL评估上下文的根对象是输入参数（例如，Message）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.task.consumer</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.task.function</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.task.supplier</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.auto-startup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示供应商在启动时自动发出HTTP请求的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.debug</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示供应商需要额外日志记录的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以启用供应商的出口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.sink.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要附加到传出HTTP请求的其他标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.sink.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要从功能目录中导出的特定现有供应商的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.sink.url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传出HTTP请求的URL模板。供应商的每个项目都过帐到此目标。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.source.include-headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在即将离任的供应商中包括传入的标头。如果为true，则供应商的通用消息类型T将等于源类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.source.type</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置了原始URL，则为预期的内容类型（例如POJO类）。默认为字符串。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.export.source.url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于通过HTTP GET创建虚拟供应商的URL模板。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.path</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能的Web资源路径（如果不为空，则应以/开头）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.supplier.auto-startup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.supplier.debug</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.supplier.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.supplier.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.supplier.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.function.web.supplier.template-url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.default-filters</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用于每个路由的过滤器定义列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用DiscoveryClient网关集成的标志。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.filters</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.include-expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将评估是否在网关集成中包括服务的SpEL表达式，默认为：true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.lower-case-service-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">谓词和过滤器中的小写serviceId选项，默认为false。当eureka自动将serviceId大写时，此方法很有用。因此MYSERIVCE将与/ myservice / **匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.predicates</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.route-id前缀</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">routeId的前缀，默认为DiscoveryClient.getClass（）。getSimpleName（）+“ _”。服务ID将被添加以创建routeId。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.discovery.locator.url-expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'lb：//'+ serviceId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为每个路线创建uri的SpEL表达式，默认为：'lb：//'+ serviceId。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用网关功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.remove-hop-by-hop.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter。逐跳删除顺序</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果密钥解析器返回空密钥，则切换为拒绝请求，默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">denyEmptyKey为true时返回的HttpStatus，默认为FORBIDDEN。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.content-security-policy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">default-src'self'https :; font-src'self'https：数据：; img-src'self'https：数据：; object-src'none'; script-src https :; style-src'self'https：'unsafe-inline'</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.content-type-options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nosniff</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.disable</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.download-options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不开放</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.frame-options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">拒绝</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.permitted-cross-domain-policies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.referrer-policy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无推荐人</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.strict-transport-security</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大年龄= 631138519</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.filter.secure-headers.xss-protection-header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个模式=阻止</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gateway.forwarded。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用ForwardedHeadersFilter。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.globalcors.cors-配置</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.connect-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接超时（以毫秒为单位），默认值为45s。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.pool.acquire-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅对于FIXED类型，等待等待的最长时间（以毫秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.pool.max-connections</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅对于FIXED类型，是在现有连接上开始挂起获取之前的最大连接数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.pool.name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通道池映射名称，默认为代理。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.pool.type</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">供HttpClient使用的池类型，默认为ELASTIC。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.proxy.host</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient代理配置的主机名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.proxy.non-proxy-hosts-pattern</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置的主机列表的正则表达式（Java）。应该直接到达，绕过代理</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.proxy.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient代理配置的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.proxy.port</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient代理配置的端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.proxy.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient代理配置的用户名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.response-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.close-notify-flush-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3000毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSL close_notify刷新超时。默认为3000毫秒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.close-notify-flush-timeout-millis</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.close-notify-read-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSL close_notify读取超时。默认为0毫秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.close-notify-read-timeout-millis</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.default-configuration-type</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">缺省的ssl配置类型。默认为TCP。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.handshake-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSL握手超时。默认为10000毫秒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.handshake-timeout-millis</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.key-password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">密钥密码，默认与keyStorePassword相同。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.key-store</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient的密钥库路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.key-store-password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">密钥库密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.key-store-provider</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient的密钥库提供程序，可选字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.key-store-type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JKS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty HttpClient的密钥库类型，默认为JKS。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.trusted-x509-certificates</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于验证远程端点的证书的受信任证书。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.ssl.use-insecure-trust-manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">安装netty InsecureTrustManagerFactory。这是不安全的，不适合生产。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.websocket.max-frame-payload-length</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大帧有效负载长度。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpclient.wiretap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为Netty HttpClient启用窃听调试。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.httpserver.wiretap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为Netty HttpServer启用窃听调试。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.loadbalancer.use404</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.metrics.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用指标数据收集。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.metrics.tags</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标签映射添加到指标。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.proxy.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">固定的标头值，将添加到所有下游请求中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.proxy.sensitive</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一组敏感的标头名称，默认情况下不会发送到下游。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.redis-rate-limiter.burst-capacity-header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-RateLimit突发容量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回突发容量配置的标头名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.redis-rate-limiter.config</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.redis-rate-limiter.include-headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否包括包含速率限制器信息的标头，默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.redis-rate-limiter.remaining-header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-RateLimit-剩余</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标头名称，它返回当前秒内剩余请求数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.redis-rate-limiter.replenish-rate-header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-RateLimit-补充率</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回补充费率配置的标头名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.routes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路线清单。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.set-status.original-status-header-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标头名称，其中包含代理请求的http代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.streaming-media-types</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果XForwardedHeadersFilter已启用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.append</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了将X-Forwarded-For作为列表附加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gateway.x-forwarded</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了X-Forwarded-For。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.host-append</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了将X-Forwarded-Host作为列表追加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gateway.x-forwarded.host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了X-Forwarded-Host。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">XForwardedHeadersFilter的顺序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.port-append</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了将X-Forwarded-Port作为列表追加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gateway.x-forwarded.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了X-Forwarded-Port。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.prefix-append</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用将X-Forwarded-Prefix作为列表追加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gateway.x-forwarded.prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了X-Forwarded-Prefix。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gateway.x-forwarded.proto-append</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用将X-Forwarded-Proto作为列表附加。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gateway.x-forwarded.proto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了X-Forwarded-Proto。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.bigquery.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.bigquery.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.bigquery.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.bigquery.dataset-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的BigQuery数据集的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.bigquery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud BigQuery组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.bigquery.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖Core模块中指定用于BigQuery的GCP项目ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Spring Cloud GCP Config。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.profile</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序在其下运行的配置文件的逗号分隔字符串。从{@code spring.profiles.active}属性获取其默认值，回退到{@code spring.profiles.default}属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖Core模块中指定的GCP项目ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.config.timeout-millis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Google Runtime Configuration API调用超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.emulator-host</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@不建议使用<code>spring.cloud.gcp.datastore.host</code>代替。 @见＃主持人</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.emulator.consistency</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用创建数据存储服务器实例的一致性。默认值：{@ code 0.9}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.emulator.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用，则数据存储区客户端将连接到本地数据存储区模拟器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.emulator.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8081</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是数据存储模拟器端口。默认值：{@ code 8081}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Datastore组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.host</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据存储区模拟器的主机和端口，如下例所示：localhost：8081。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.namespace</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.datastore.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.firestore.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.firestore.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.firestore.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.firestore.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Firestore组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.firestore.host端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firestore.googleapis.com:443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Firestore模拟器服务的主机和端口；可以重写以指定仿真器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.firestore.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.logging.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为Spring MVC自动配置Google Cloud Stackdriver日志记录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正在运行服务的GCP项目ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.emulator-host</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地正在运行的仿真器的主机和端口。如果提供的话，这将设置客户端以与正在运行的发布/订阅模拟器连接。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Pub / Sub组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.keep-alive-interval-minutes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对服务器执行ping操作的频率，以使通道保持活动状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖Core模块中指定的GCP项目ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.delay-threshold-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于批处理的延迟阈值。经过这段时间后（从添加的第一个元素开始计数），这些元素将被分批包装并发送。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.element-count-threshold</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于批处理的元素计数阈值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.enabled</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则启用批处理。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.flow-control.limit超出行为</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">超过指定限制时的行为。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.flow-control.max-outstanding-element-count</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行流控制之前要保留在内存中的未完成元素的最大数量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.flow-control.max-outstanding-request-bytes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制执行流控制之前要保留在内存中的最大未完成字节数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.batching.request-byte-threshold</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于批处理的请求字节阈值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.executor-threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个发布者使用的线程数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.initial-retry-delay-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InitialRetryDelay控制第一次重试之前的延迟。随后的重试将使用根据RetryDelayMultiplier调整的该值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.initial-rpc-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InitialRpcTimeout控制初始RPC的超时。后续调用将使用根据RpcTimeoutMultiplier调整的该值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.jittered</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">抖动确定是否应将延迟时间随机化。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.max-尝试</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaxAttempts定义执行的最大尝试次数。如果此值大于0，并且尝试次数达到此限制，则即使总重试时间仍小于TotalTimeout，逻辑也会放弃重试。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.max-retry-delay-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaxRetryDelay设置了重试延迟的值的限制，以便RetryDelayMultiplier不能将重试延迟增加到大于此数量的值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.max-rpc-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaxRpcTimeout对RPC超时值设置了限制，因此RpcTimeoutMultiplier不能将RPC超时增加到高于此值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.retry-delay-multiplier</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RetryDelayMultiplier控制重试延迟的更改。将前一个呼叫的重试延迟与RetryDelayMultiplier相乘，以计算下一个呼叫的重试延迟。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.rpc-timeout-multiplier</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RpcTimeoutMultiplier控制RPC超时的更改。上一个呼叫的超时时间乘以RpcTimeoutMultiplier，以计算下一个呼叫的超时时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.publisher.retry.total-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TotalTimeout具有最终控制权，该逻辑应继续尝试远程调用直到完全放弃之前应保持多长时间。总超时时间越高，可以尝试的重试次数越多。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.reactive.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Pub / Sub反应性组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.executor-threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个订户使用的线程数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.flow-control.limit超出行为</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">超过指定限制时的行为。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.flow-control.max-outstanding-element-count</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在执行流控制之前要保留在内存中的未完成元素的最大数量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.flow-control.max-outstanding-request-bytes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制执行流控制之前要保留在内存中的最大未完成字节数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.max-ack-extension-period</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户工厂的可选最大ack扩展周期（以秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.max-acknowledgement-threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于批处理确认的线程数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.parallel-pull-count</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">订户工厂的可选并行拉计数设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.pull端点</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">订户工厂的可选提取端点设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.initial-retry-delay-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InitialRetryDelay控制第一次重试之前的延迟。随后的重试将使用根据RetryDelayMultiplier调整的该值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.initial-rpc-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">InitialRpcTimeout控制初始RPC的超时。后续调用将使用根据RpcTimeoutMultiplier调整的该值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.jittered</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">抖动确定是否应将延迟时间随机化。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.max-尝试</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaxAttempts定义执行的最大尝试次数。如果此值大于0，并且尝试次数达到此限制，则即使总重试时间仍小于TotalTimeout，逻辑也会放弃重试。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.max-retry-delay-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaxRetryDelay设置了重试延迟的值的限制，以便RetryDelayMultiplier不能将重试延迟增加到大于此数量的值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.max-rpc-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MaxRpcTimeout对RPC超时值设置了限制，因此RpcTimeoutMultiplier不能将RPC超时增加到高于此值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.retry-delay-multiplier</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RetryDelayMultiplier控制重试延迟的更改。将前一个呼叫的重试延迟与RetryDelayMultiplier相乘，以计算下一个呼叫的重试延迟。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.rpc-timeout-multiplier</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RpcTimeoutMultiplier控制RPC超时的更改。上一个呼叫的超时时间乘以RpcTimeoutMultiplier，以计算下一个呼叫的超时时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.pubsub.subscriber.retry.total-timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TotalTimeout具有最终控制权，该逻辑应继续尝试远程调用直到完全放弃之前应保持多长时间。总超时时间越高，可以尝试的重试次数越多。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.security.iap.algorithm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ES256</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于签署JWK令牌的加密算法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.security.iap.audience</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非动态受众群体字符串进行验证。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gcp.security.iap。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud IAP身份提取组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.security.iap.header</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x-goog-iap-jwt断言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从中提取JWK密钥的标头。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.security.iap.issuer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://cloud.google.com/iap" class="bare">cloud.google.com/iap</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JWK发行人进行验证。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.security.iap.registry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.gstatic.com/iap/verify/public_key-jwk" class="bare">www.gstatic.com/iap/verify/public_key-jwk</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接到JWK公钥注册表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.create-interleaved-table-ddl-on-delete-cascade</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.database</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Spanner组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果池耗尽，spring.cloud.gcp.spanner。失败</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.instance-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.keep-alive-interval-minutes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.max-idle-sessions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.max-sessions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.min-sessions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.num-rpc-channels</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.prefetch-chunks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.spanner.write-sessions-fraction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.sql.credentials</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖核心模块中指定的GCP OAuth2凭据。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.sql.database-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud SQL实例中的数据库名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.sql.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud SQL支持组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.sql.instance-connection-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud SQL实例连接名称。[GCP_PROJECT_ID]：[INSTANCE_REGION]：[INSTANCE_NAME]。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.storage.auto-create-files</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.storage.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.storage.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.storage.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.storage.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Storage组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.authority</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通道声称要连接的HTTP / 2权限。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.compression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于呼叫的压缩。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.deadline-ms</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通话截止时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Stackdriver跟踪组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.max入站大小</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">入站邮件的最大大小。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.max-outbound-size</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">出站邮件的最大大小。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.message-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将待处理的跨度批量发送到GCP Stackdriver Trace之前的超时时间（以秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.num-executor-threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">跟踪执行程序使用的线程数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖Core模块中指定的GCP项目ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.trace.wait-for-ready</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果出现瞬态故障，请等待通道准备就绪。在这种情况下，默认为快速失败。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.vision.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.vision.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.vision.credentials.scopes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.gcp.vision。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动配置Google Cloud Vision组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.vision.executor-threads-count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于轮询文档OCR操作完成的线程数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.gcp.vision.json-输出批量大小</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个JSON输出文件中要包含的文档页面数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.httpclientfactories.apache.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用创建Apache Http Client工厂bean的功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.httpclientfactories.ok.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用OK Http Client工厂bean的创建。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.hypermedia.refresh.fixed-delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.hypermedia.refresh.initial-delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.inetutils.default-主机名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地主机</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认主机名。发生错误时使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.inetutils.default-ip-address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认IP地址。发生错误时使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.inetutils.ignored-interfaces</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络接口的Java正则表达式列表，将被忽略。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.inetutils.preferred-networks</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">首选网络地址的Java正则表达式列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.inetutils.timeout-seconds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">超时（以秒为单位），用于计算主机名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.inetutils。仅使用站点本地接口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否仅使用具有站点本地地址的接口。有关更多详细信息，请参见{@link InetAddress＃isSiteLocalAddress（）}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.api-version</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.apiVersion</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API版本</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.ca-cert-data</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.ca-cert-file</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.caCertData</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API CACertData</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.caCertFile</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API CACertFile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.client-cert-data</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.client-cert-file</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.client-key-algo</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.client-key-data</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.client-key-file</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.client-key-passphrase</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.clientCertData</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API ClientCertData</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.clientCertFile</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API ClientCertFile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.clientKeyAlgo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RSA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API ClientKeyAlgo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.clientKeyData</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API ClientKeyData</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.clientKeyFile</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API ClientKeyFile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.clientKeyPassphrase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">更改</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API ClientKeyPassphrase</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.connection-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.connectionTimeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接超时</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.http-proxy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.https-代理</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.logging-interval</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.loggingInterval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20多岁</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录间隔</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.master-url</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.masterUrl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://kubernetes.default.svc" class="bare">kubernetes.default.svc</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API主节点URL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.namespace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes命名空间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.no-proxy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API密码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.proxy密码</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.proxy用户名</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.request-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.requestTimeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求超时</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.rolling-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.rollingTimeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">900年代</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">滚动超时</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.trust-certs</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.trustCerts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API信任证书</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API用户名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.watch-reconnect-interval</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.watch-reconnect-limit</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.watchReconnectInterval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重新连接间隔</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.client.watchReconnectLimit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重新连接间隔限制重试</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.config.enable-api</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.config.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用ConfigMap属性源定位器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.config.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.config.namespace</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.config.paths</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.config.sources</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.all命名空间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果发现所有名称空间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果启用了Kubernetes Discovery。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.filter</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从服务从Kubernetes API服务器检索到服务后，使用SpEL表达式过滤服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.known-secure-ports</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置被认为是安全的端口号并使用HTTPS。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.metadata.add批注</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置后，服务的Kubernetes批注将作为返回的ServiceInstance的元数据包括在内。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.metadata.add-labels</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置后，服务的Kubernetes标签将作为返回的ServiceInstance的元数据包括在内。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.metadata.add-ports</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置后，任何命名的Kubernetes服务端口都将作为返回的ServiceInstance的元数据包括在内。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.metadata.annotations-prefix</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置addAnnotations时，它将用作元数据映射中键名的前缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.metadata.labels-prefix</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置addLabels后，它将用作元数据映射中键名的前缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.metadata.ports前缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">港口。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置addPorts时，它将用作元数据映射中键名的前缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.primary-port-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置，则在为服务定义多个端口时，具有给定名称的端口将用作主要端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.service-labels</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置，则仅会从Kubernetes API服务器中获取与这些标签匹配的服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.discovery.service-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未知</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地实例的服务名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在更改时启用Kubernetes配置重新加载。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.max等待重启</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果使用重启或关闭策略，Spring Cloud Kubernetes将在重启之前等待随机的时间。这样做是为了避免同一应用程序的所有实例同时重新启动。此属性配置从接收到需要重启的信号到实际触发重启为止的最大等待时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.mode</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置Kubernetes配置重新加载的检测模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.monitoring-config-maps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用对配置映射的监视以检测更改。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.monitoring-secrets</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用对机密的监视以检测更改。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.period</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15000毫秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置检测模式为“轮询”时使用的轮询周期。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.reload.strategy</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置Kubernetes更改时重新加载配置的重新加载策略。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.ribbon.cluster-domain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cluster.local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">群集域。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.ribbon.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能区已启用，默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.ribbon.mode</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{@link KubernetesRibbonMode}使用Pod或服务名称的IP设置功能区服务器列表。默认值为POD。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.enable-api</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Secrets属性源定位器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.labels</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.namespace</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.paths</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.kubernetes.secrets.sources</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.loadbalancer.cache.caffeine.spec</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于创建缓存的规范。有关规范格式的更多详细信息，请参见CaffeineSpec。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.loadbalancer.cache.ttl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30秒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生存时间-从记录写入开始算起的时间，之后缓存条目到期，表示为{@link Duration}。属性{@link String}必须符合Spring Boot <code>StringToDurationConverter</code>指定的适当语法。 @see <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/convert/StringToDurationConverter.java">StringToDurationConverter.java</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.loadbalancer.retry.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.loadbalancer.ribbon.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原因<code>RibbonLoadBalancerClient</code>默认使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.refresh.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为刷新范围和相关功能启用自动配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.refresh.extra-refreshable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean的其他类名称，用于将进程发布到刷新范围中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.service-registry.auto-registration。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用服务自动注册。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.service-registry.auto-registration.fail-fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果没有AutoServiceRegistration，启动是否失败。默认为false。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.service-registry.auto-registration.register-management</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否将管理注册为服务。默认为true。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.binders</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果使用了多个相同类型的绑定器（即，连接到RabbitMq的多个实例），则附加的每个绑定器属性（请参阅{@link BinderProperties}）。您可以在此处指定多个活页夹配置，每个配置具有不同的环境设置。例如; spring.cloud.stream.binders.rabbit1.environment。 。 。 ，spring.cloud.stream.binders.rabbit2.environment。 。 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.binding-retry-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于计划绑定尝试的重试间隔（以秒为单位）。默认值：30秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.bindings</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个绑定名称（例如，“输入”）的其他绑定属性（请参见{@link BinderProperties}）。例如;这将设置Sink应用程序的“输入”绑定的内容类型：“ spring.cloud.stream.bindings.input.contentType = text / plain”</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.consul.binder.event-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.default-binder</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在有多个可用绑定程序（例如“兔子”）的情况下，所有绑定将使用的绑定程序的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.dynamic-目的地</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以动态绑定的目的地列表。如果设置，则只能绑定列出的目的地。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.function.batch-mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.function.bindings</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.function.definition</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绑定功能的定义。如果需要将多个函数组合为一个，请使用管道（例如'fooFunc | barFunc'）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.instance-count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序已部署实例的数量。默认值：1。注意：也可以按每个单独的绑定“ spring.cloud.stream.bindings.foo.consumer.instance-count”进行管理，其中“ foo”是绑定的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.instance-index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序的实例ID：从0到instanceCount-1的数字。用于分区和Kafka。注意：也可以按每个单独的绑定“ spring.cloud.stream.bindings.foo.consumer.instance-index”进行管理，其中“ foo”是绑定的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.instance-index-list</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实例ID从0到instanceCount-1的列表。用于分区和Kafka。注意：也可以按每个单独的绑定“ spring.cloud.stream.bindings.foo.consumer.instance-index-list”进行管理，其中“ foo”是绑定的名称。此设置将覆盖“ spring.cloud.stream.instance-index”中的一个设置</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.integration.message-handler-non-propagated标头</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不会从入站邮件复制的邮件标题名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.auto-add-partitions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.auto-create-topics</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.brokers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[本地主机]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.configuration</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">适用于生产者和消费者的任意kafka属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.consumer-properties</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意的kafka消费者属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.header-mapper-bean-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要使用的自定义标头映射器的bean名称，而不是{@link org.springframework.kafka.support。DefaultKafkaHeaderMapper}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.health-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等待获取分区信息的时间（以秒为单位）；默认值60。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.jaas</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.min-partition-count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.producer属性</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意的Kafka生产者属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.replication-factor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.required-acks</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.batch-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.buffer-size</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.compression-type</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.configuration</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.stream.kafka.binder.transaction.producer.error-channel</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.header-mode</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.header-patterns</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.message-key-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.partition-count</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.partition-key-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.partition-key-extractor-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.partition-selector-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.partition-selector-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.required-groups</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.sync</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.topic</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.producer.use-native-encoding</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.binder.transaction.transaction-id前缀</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.bindings</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.application-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.auto-add-partitions</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.auto-create-topics</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.brokers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.configuration</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.consumer-properties</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.deserialization-exception-handler</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{@link org.apache.kafka.streams.errors。在存在反序列化异常时使用。除非在使用者绑定上被覆盖，否则此处理程序将应用于所有输入绑定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.functions</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.header-mapper-bean-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.health-timeout</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.jaas</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.min-partition-count</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.producer属性</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.replication-factor</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.required-acks</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.serde错误</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.state-store-retry.backoff-period</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.binder.state-store-retry.max尝试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.kafka.streams.bindings</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.metrics.export-properties</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将附加到每条消息的属性列表。上下文刷新后，将由onApplicationEvent填充，以避免按消息进行操作的开销。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.metrics.key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发出的度量标准的名称。应为每个应用程序的唯一值。默认为：$ {spring.application.name：$ {vcap.application.name:${spring.config.name:application}}}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.metrics.meter-filter</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制要捕获的“仪表”的模式。默认情况下，将捕获所有“仪表”。例如，“ spring.integration。*”将仅捕获名称以“ spring.integration”开头的仪表的度量信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.metrics.properties</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应添加到度量有效负载的应用程序属性，例如： <code>spring.application**</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.metrics.schedule-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60年代</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间间隔，表示为计划指标快照发布的持续时间。默认为60秒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.override-cloud-connectors</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅当云配置文件处于活动状态并且该应用程序提供了Spring Cloud Connector时，此属性才适用。如果该属性为false（默认值），则绑定器检测到合适的绑定服务（例如，在Cloud Foundry中为RabbitMQ绑定器绑定的RabbitMQ服务）并将其用于创建连接（通常通过Spring Cloud Connectors）。设置为true时，此属性指示绑定程序完全忽略绑定的服务，并依赖于Spring Boot属性（例如，依赖于RabbitMQ绑定程序环境中提供的spring.rabbitmq。*属性）。连接到多个系统时，此属性的典型用法是嵌套在自定义环境中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.poller.fixed-delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修复了默认轮询器的延迟。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.poller.max-messages-per-poll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认轮询器每次轮询的最大邮件数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.rabbit.binder.admin地址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要求管理插件；只需要队列亲缘关系。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.rabbit.binder.admin地址</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.rabbit.binder。压缩级别</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">压缩绑定的压缩级别；参见“ java.util.zip”。平减器”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.rabbit.binder.connection-name-prefix</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此活页夹中连接名称的前缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.rabbit.binder.nodes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">集群成员节点名称；只需要队列亲缘关系。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.rabbit.bindings</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.stream.sendto.destination</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标头名称，用于确定输出目标的名称</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.command-line-runner-order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{@code spring.cloud.task.batch.fail-on-job-failure = true}时，用于运行批处理作业的{@code CommandLineRunner}的顺序。默认为0（与{@link org.springframework.boot.autoconfigure.batch相同。JobLauncherCommandLineRunner}）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.chunk-order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。ChunkListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.chunk.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理块事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.item-process-order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。ItemProcessListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.item-process.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理项目的事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.item-read-order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。ItemReadListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.item-read.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理项目读取事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.item-write-order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。ItemWriteListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.item-write.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理项目写入事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.job执行顺序</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。JobExecutionListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.task.batch.events.job-execution。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理作业执行事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events。跳过顺序</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。SkipListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.task.batch.events.skip。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理跳过事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.events.step-execution-order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.batch.core建立默认的{@link Ordered}优先级。StepExecutionListener}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.task.batch.events.step-execution。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务是否应侦听批处理步骤执行事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.fail-on-failure失败</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定如果批处理作业失败，任务应用程序是否应返回非零退出代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.fail-on-failure-poll-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修复了Spring Cloud Task在检查{@link org.springframework.batch.core。将spring.cloud.task.batch.failOnJobFailure设置为true时，JobExecution}已完成。默认为5000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.job-names</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以逗号分隔的作业名称列表，用于在启动时执行（例如， <code>job1,job2</code> ）。默认情况下，将执行在上下文中找到的所有作业。 @不建议使用spring.batch.job.names而不是spring.cloud.task.batch.jobNames。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.batch.listener.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定是否将任务链接到正在运行的批处理作业。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.task.closecontext</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置为true时，上下文在任务结束时关闭。否则上下文仍然是开放的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.events.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定任务应用程序是否应发出任务事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.executionid</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新任务执行时任务将使用的ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.external-execution-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与任务相关联的ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.task.initialize</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置为true，则表被初始化。如果设置为false，则表不会初始化。默认为空。将其默认设置为null的要求是，我们可以支持<code>spring.cloud.task.initialize.enable</code>直到将其删除。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.parent-execution-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启动此任务执行的父任务执行ID的ID。如果任务执行没有父级，则默认为null。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.single-instance-enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此属性用于确定如果正在运行具有相同应用程序名称的另一个任务，则该任务是否将执行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.single-instance-lock-check-interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明任务执行将在两次检查之间等待的时间（以毫秒为单位）。默认时间是：500毫秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.single-instance-lock-ttl</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明当启用单实例的设置为true时，任务执行可以保持锁定以防止另一个任务使用特定任务名称执行的最长时间（以毫秒为单位）。默认时间是：整数。MAX_VALUE。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.task.table-prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任务_</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">附加到由Spring Cloud Task创建的表名称的前缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.util.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用创建Spring Cloud实用程序bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-id.app-id-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程式编号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AppId身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-id.network-interface</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">“ MAC_ADDRESS” UserId机制的网络接口提示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-id.user-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MAC地址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UserId机制。可以是“ MAC_ADDRESS”，“ IP_ADDRESS”，字符串或类名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-role.app-role-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AppRole身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-role.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">角色名称，可选，用于拉模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-role.role-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RoleId。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.app-role.secret-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SecretId。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.application-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AppId身份验证的应用程序名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.authentication</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-ec2.aws-ec2-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AWS 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AWS-EC2身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-ec2.identity-document</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://169.254.169.254/latest/dynamic/instance-identity/pkcs7" class="bare">169.254.169.254/最新/动态/实例身份/ pkcs7</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AWS-EC2 PKCS7身份文档的URL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-ec2.nonce</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">立即用于AWS-EC2身份验证。空随机数默认为随机数生成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-ec2.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">角色名称，可选。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-iam.aws-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AWS身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-iam.endpoint-uri</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">STS服务器URI。 @自2.2起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-iam.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">角色名称，可选。如果未设置，则默认为友好的IAM名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws-iam.server-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于在登录请求的标头中设置{@code X-Vault-AWS-IAM-Server-ID}标头的服务器的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws.access-key-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.accessKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的访问密钥的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ws</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">aws后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用AWS后端使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.aws.secret-key-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cloud.aws.credentials.secretKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的密钥的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.azure-msi.azure-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">天蓝色</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Azure MSI身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.azure-msi.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.cassandra.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">卡桑德拉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cassandra后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.cassandra.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用cassandra后端使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.cassandra.password-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.data.cassandra.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的密码的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.cassandra.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.cassandra.static-role</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用静态角色使用。 @自2.2起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.cassandra.username-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.data.cassandra。用户名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.config.lifecycle.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用生命周期管理。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.config.lifecycle.expiry-threshold</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">到期阈值。 {@link Lease}会在给定的{@link Duration}到期之前进行更新。 @自2.2起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.config.lifecycle.lease端点</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置{@link LeaseEndpoints}以将续订/吊销调用委派给。 {@link LeaseEndpoints}封装了保险柜版本之间的差异，这些差异会影响续订/吊销端点的位置。对于Vault 0.8或更高版本，可以为{@link LeaseEndpoints＃SysLeases}，对于较旧的版本则可以为{@link LeaseEndpoints＃Legacy}（默认）。 @自2.2起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.config.lifecycle.min更新</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">续约之前至少需要的时间段。 @自2.2起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.config.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于设置{@link org.springframework.core.env.PropertySource}优先级。将Vault用作其他属性源的替代时，这很有用。 @see org.springframework.core。优先顺序</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.connection-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.consul.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">领事</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">领事后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.vault.consul。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用领事后端使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.consul.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.consul.token-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.consul.token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的令牌的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.database.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据库后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.database.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用数据库后端使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.database.password-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.datasource.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的密码的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.database.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.database.static-role</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用静态角色使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.database.username-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.datasource.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.vault.discovery。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示已启用Vault服务器发现的标志（将通过发现查找Vault服务器URL）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.discovery.service-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">跳马</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用来找到保管箱的服务ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用保管库配置服务器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.fail-fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果无法从保管库获取数据，则快速失败。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-gce.gcp路径</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gcp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-gce.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尝试登录的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-gce.service-account</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可选服务帐户ID。如果未配置，则使用默认ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.credentials.encoded-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OAuth2帐户私钥的base64编码内容（采用JSON格式）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.credentials.location</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OAuth2凭证私钥的位置。</p><p>由于这是资源，因此私钥可以位于多个位置，例如本地文件系统，类路径，URL等。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.gcp-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gcp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.jwt-validity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15m</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JWT令牌的有效性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.project-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖GCP项目ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尝试登录的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.gcp-iam.service-account-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">覆盖GCP服务帐户ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.generic.application-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于上下文的应用程序名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.generic.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秘密</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认后端的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.generic.default-context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认上下文的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.generic.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用通用后端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.generic.profile-分隔符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置文件分隔符以组合应用程序名称和配置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地主机</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管库服务器主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kubernetes.kubernetes-路径</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kubernetes.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尝试登录的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kubernetes.service-account-token-file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/var/run/secrets/kubernetes.io/serviceaccount/token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务帐户令牌文件的路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kv。应用程序名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于上下文的应用程序名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kv。后端</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秘密</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认后端的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kv.backend-version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">键值后端版本。当前支持的版本是：</p><ul> <li>版本1（未转换的键值后端）。</li> <li>版本2（版本化键值后端）。</li> </ul><p></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kv.default上下文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认上下文的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.cloud.vault.kv</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用kev-value后端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.kv.profile分隔符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">配置文件分隔符以组合应用程序名称和配置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mongodb.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mongodb</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cassandra后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mongodb.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用mongodb后端使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mongodb.password-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.data.mongodb.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的密码的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mongodb.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mongodb.static-role</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用静态角色使用。 @自2.2起</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mongodb.username-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.data.mongodb.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mysql.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MySQL的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mysql后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mysql.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用mysql后端用法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mysql.password-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.datasource.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mysql.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.mysql.username-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.datasource.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.namespace</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管箱名称空间（需要Vault Enterprise）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.pcf.instance-certificate</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实例证书（PEM）的路径。默认为{@code CF_INSTANCE_CERT} env变量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.pcf.instance-key</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实例密钥（PEM）的路径。默认为{@code CF_INSTANCE_KEY} env变量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.pcf.pcf-路径</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pcf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes身份验证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.pcf.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尝试登录的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管库服务器端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.postgresql.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PostgreSQL后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.postgresql.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用postgresql后端用法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.postgresql.password-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.datasource.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.postgresql.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.postgresql.username-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.datasource.username</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.rabbitmq.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rabbitmq</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rabbitmq后端路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.rabbitmq.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用rabbitmq后端使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.rabbitmq.password-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.rabbitmq.password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的密码的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.rabbitmq.role</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">凭证的角色名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.rabbitmq.username-property</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.rabbitmq。用户名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获得的用户名的目标属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.read-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读取超时。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.scheme</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">https</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">协议方案。可以是“ http”或“ https”。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.ssl.cert-auth-path</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">证书</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLS证书认证后端的安装路径。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.ssl.key-store</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">拥有证书和私钥的信任库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.ssl.key-store-password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问密钥库的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.ssl.trust-store</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">拥有SSL证书的信任库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.ssl.trust-store-password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问信任库的密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.token</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">静态保管库令牌。如果{@link #authentication}是{@code TOKEN}，则为必填项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.vault.uri</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保管箱URI。可以设置方案，主机和端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.base-sleep-time-ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重试之间等待的初始时间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.block-直到连接单元</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与阻止与Zookeeper的连接有关的时间单位。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.block-直到连接等待</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">等待时间阻止与Zookeeper的连接。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.connect-string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地主机：2181</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zookeeper集群的连接字符串。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.default-health-endpoint</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将检查默认健康状况终结点以验证依赖项是否仍然存在。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.dependencies</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">别名到ZookeeperDependency的映射。从Ribbon的角度来看，别名实际上是serviceID，因为Ribbon无法接受serviceID中的嵌套结构。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.dependency配置</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.dependency名称</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.initial状态</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此实例的初始状态（默认为{@link StatusConstants＃STATUS_UP}）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.instance-host</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务可以在Zookeeper中注册的预定义主机。对应于URI规范中的{code address}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.instance-id</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于向Zookeeper注册的ID。默认为随机UUID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.instance-port</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于注册服务的端口（默认为监听端口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.instance-ssl-port</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注册服务的SSL端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.metadata</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取与此实例关联的元数据名称/值对。此信息将发送给Zookeeper，并可由其他实例使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.order</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所使用的发现客户端的顺序<code>CompositeDiscoveryClient</code>用于排序可用的客户端。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.register</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Zookeeper中注册为服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.root</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/服务</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在其中注册了所有实例的Root Zookeeper文件夹。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.discovery.uri规范</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{scheme}：// {address}：{port}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在Zookeeper中注册服务时要解析的URI规范。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用了Zookeeper。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.max-retries</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重试的最大次数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.max-sleep-ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">500</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每次重试的最长时间（以毫秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.cloud.zookeeper.prefix</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将应用于所有Zookeeper依赖项路径的通用前缀。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.annotation.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.async.configurer.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用默认的AsyncConfigurer。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.async.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用检测与异步相关的组件，以便在线程之间传递跟踪信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.async.ignored-beans</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{@link java.util.concurrent。的列表。应当忽略且不包含在跟踪表示中的Executor} bean名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.baggage键</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应当在过程外传播的行李密钥名称列表。这些键将带有前缀<code>baggage</code>在实际密钥之前。设置此属性是为了与以前的Sleuth版本向后兼容。 @请参阅brave.propagation。ExtraFieldPropagation。FactoryBuilder＃addPrefixedFields（String，java.util。采集）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.feign.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Feign时启用跨度信息传播。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.feign.processor.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用将Feign Context包装在其跟踪表示中的后处理器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.grpc.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用GRPC时启用跨度信息传播。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.http.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.http.legacy.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.sleuth.hystrix.strategy。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用将所有Callable实例包装到其Sleuth代表-TraceCallable中的自定义HystrixConcurrencyStrategy。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring.Sleuth.Hystrix.Strategy.Passthrough</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用后，跟踪信息将传递到Hystrix执行线程，但不会为每个执行创建跨度。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.integration.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Spring Integration sleuth工具。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.integration.patterns</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[！hystrixStreamOutput *，*]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通道名称将与之匹配的模式数组。 @see org.springframework.integration.config。GlobalChannelInterceptor＃patterns（）默认为与Hystrix Stream通道名称不匹配的任何通道名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.integration.websockets.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用对WebSocket的跟踪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.keys.http.headers</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果存在其他应作为标签添加的标头。如果标头值是多值的，则标记值将是一个逗号分隔的单引号列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.keys.http.prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">http。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标头名称的前缀（如果它们作为标记添加）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.local-keys</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与{@link #propagationKeys}相同，除了此字段不会传播到远程服务。 @请参阅brave.propagation。ExtraFieldPropagation。FactoryBuilder＃addRedactedField（String）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.log.slf4j.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用{@link Slf4jScopeDecorator}，以在日志中打印跟踪信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.log.slf4j.whitelisted-mdc-keys</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从行李到MDC的钥匙清单。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该打开消息传递。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.jms.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用对JMS的跟踪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.jms.remote-service-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">简讯</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.kafka.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用Kafka跟踪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.kafka.mapper.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为Kafka启用DefaultKafkaHeaderMapper跟踪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.kafka.remote-service-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">卡夫卡</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.rabbit.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用RabbitMQ的跟踪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.messaging.rabbit.remote-service-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rabbitmq</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.opentracing.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.propagation-keys</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">引用与在线过程相同的字段的列表。例如，名称“ x-vcap-request-id”将按原样设置（包括前缀）。</p><p>注意：{@code fieldName}将隐式小写。 @请参阅brave.propagation。ExtraFieldPropagation。FactoryBuilder＃addField（String）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.propagation.tag.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用{@link TagPropagationFinishedSpanHandler}，以添加额外的传播字段来扩展标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.propagation.tag.whitelisted-keys</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从额外的传播字段到跨度标签的键列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">弹簧探测反应器在每个面上装饰</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当在每个运算符上使用true装饰时，性能会下降，但是日志记录将始终包含每个运算符中的跟踪条目。如果在最后一个运算符上使用false修饰符，将会有更好的表现，但是日志记录可能并不总是包含跟踪条目。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.reactor.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则启用对反应堆的检测。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.redis.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Redis时启用跨度信息传播。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.redis.remote服务名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">远程Redis端点的服务名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.rxjava.schedulers.hook.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过RxJavaSchedulersHook启用对RxJava的支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.rxjava.schedulers.ignoredthreads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[HystrixMetricPoller，^ RxComputation。* $]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不会采样其跨度的线程名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.sampler。概率</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该采样的请求的概率。例如1.0-应该抽样100％的请求。精度仅是整数（即不支持0.1％的迹线）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.sampler.rate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对于低流量的端点，每秒速率可能是一个不错的选择，因为它可以提供电涌保护。例如，您可能永远不会期望端点每秒收到50个以上的请求。如果流量突然激增，达到每秒5000个请求，那么每秒仍然会有50条痕迹。相反，如果您有一个百分比（例如10％），则同一浪涌最终将导致每秒500条痕迹，这可能会使您的存储设备超负荷。为此，Amazon X-Ray包括一个限速采样器（名为Reservoir）。Brave通过{@link brave.sampler使用了相同的方法。RateLimitingSampler}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.scheduled.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为{@link org.springframework.scheduling.annotation启用跟踪。已排定}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">春季侦查计划的跳过模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.springframework.cloud.netflix.hystrix.stream。HystrixStreamTask</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该跳过的类的完全限定名称的模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.supports-join</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True表示跟踪系统支持在客户端和服务器之间共享范围ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.trace-id128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为true时，生成128位跟踪ID，而不是64位跟踪ID。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.additional-skip-pattern</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">跟踪中应跳过的URL的其他模式。这将附加到{@link SleuthWebProperties＃skipPattern}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.client.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用拦截器注入{@link org.springframework.web.client。RestTemplate}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.client.skip-pattern</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在客户端跟踪中应跳过的URL的模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果为true，则为Web应用程序启用检测。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.sleuth.web.exception-logging-filter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以切换是否存在记录引发的异常的过滤器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.sleuth.web.exception-throwing-filter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记以切换是否存在记录引发的异常的过滤器。 @不建议使用{@link #exceptionLoggingFilterEnabled}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.filter-order</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">跟踪过滤器应注册的顺序。默认为{@link TraceHttpAutoConfiguration＃TRACING_FILTER_ORDER}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.ignore-自动配置的跳过模式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置为true，将忽略自动配置的跳过模式。 @请参阅TraceWebAutoConfiguration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.web.skip-pattern</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ api-docs。 <strong>| /摇摇欲坠。</strong>|。<strong>\ .png |。</strong>\ .css |。<strong>\ .js |。</strong>\ .html | /favicon.ico | /hystrix.stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">跟踪中应跳过的URL的模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.sleuth.zuul.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Zuul时启用跨度信息传播。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.activemq.message-max-bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过ActiveMQ发送给Zipkin的跨度给定消息的最大字节数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.activemq.queue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">邮编</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ActiveMQ队列的名称，应将跨度发送到Zipkin。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.base-url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://localhost:9411/" class="bare">本地主机：9411 /</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zipkin查询服务器实例的URL。如果在服务发现中注册了Zipkin，您还可以提供Zipkin服务器的服务ID（例如<a href="https://zipkinserver/" class="bare">zipkinserver /</a> ）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.compression.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用spring.zipkin.discovery-client</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置为{@code false}，则始终将{@link ZipkinProperties＃baseUrl}视为URL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用将范围发送到Zipkin。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.encoder</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发送到Zipkin的跨度的编码类型。如果您的服务器不是最新服务器，请设置为{@link SpanBytesEncoder＃JSON_V1}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.kafka.topic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">邮编</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kafka主题的名称，应将跨度发送到Zipkin。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.locator.discovery.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">能够通过服务发现来定位主机名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.message-timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1个</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将待处理的跨度批量发送到Zipkin之前的超时（以秒为单位）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.rabbitmq.addresses</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于发送跨度到Zipkin的RabbitMQ代理地址</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.rabbitmq.queue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">邮编</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该将跨度发送到Zipkin的RabbitMQ队列的名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.sender.type</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将跨度发送到Zipkin的方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring.zipkin.service.name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过HTTP从中发送Span的服务名称，应显示在Zipkin中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.amqp.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用对Stub Runner和AMQP的支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.amqp.mock连接</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用对Stub Runner和AMQP模拟连接工厂的支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.classifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下，在常春藤坐标中用于存根的分类器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用stubrunner.cloud.consul。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在领事中启用存根注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.delegate.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用DiscoveryClient的Stub Runner实现。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否为Stub Runner启用Spring Cloud支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.eureka.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在尤里卡启用存根注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.ribbon.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner的Ribbon功能区集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用了stubrunner.cloud.stubbed.discovery。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否对Stub Runner存根Service Discovery。如果设置为false，则将在实时服务发现中注册存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.cloud.zookeeper.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在Zookeeper中启用存根注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.consumer-name</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您可以通过为此参数设置一个值来覆盖此字段的默认{@code spring.application.name}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.delete测试后存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果设置为{@code false}，则在运行测试后不会从临时文件夹中删除存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.failing-on-stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用后，如果未找到存根/合同，此标志将告诉存根运行器引发异常。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.generate-stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用后，此标志将告诉存根运行程序不加载生成的存根，而是在运行时将找到的合同转换为存根格式并运行这些存根。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.http-server-stub-configurer</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP服务器存根的配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.ids</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根的ID以“ ivy”表示法（[groupId]：artifactId：[version]：[classifier] [：port]）运行。 {@code groupId}，{@ code classifier}，{@ code version}和{@code port}是可选的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.ids到服务ID</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将基于常春藤表示法的ID映射到应用程序内的serviceId。示例“ a：b”→“ myService”“ artifactId”→“ myOtherService”</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.integration.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner与Spring Integration集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.jms.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner与Spring JMS集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.kafka.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用与Spring Kafka的Stub Runner集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.kafka.initializer.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否允许Stub Runner负责轮询消息而不是KafkaStubMessages组件。后者应仅在生产方使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.mappings-输出文件夹</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将每个HTTP服务器的映射转储到所选文件夹。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.max端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动启动的WireMock服务器的端口最大值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.min端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动启动的WireMock服务器的端口的最小值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.password</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">储存库密码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.properties</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以传递给自定义{@link org.springframework.cloud.contract.stubrunner的属性的地图。StubDownloaderBuilder}。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.proxy主机</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库代理主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.proxy端口</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储库代理端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.stream.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否启用Stub Runner与Spring Cloud Stream集成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">存根模式</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">选择存根应该来自哪里。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个消费者的存根</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅应将此特定使用者的存根在HTTP服务器存根中注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stubrunner.username</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">储存库用户名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.placeholders.enabled</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">真正</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指示应过滤生成的Wiremock存根中的http URL的标记，以添加或解析动态端口的占位符。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">已启用wiremock.rest-template-ssl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.files</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.https端口</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-1</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.https-port-dynamic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8080</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.port-dynamic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">假</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wiremock.server.stubs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</i></i></div><i>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>

</i></body></html>