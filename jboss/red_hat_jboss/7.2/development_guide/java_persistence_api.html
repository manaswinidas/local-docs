<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 12. Java Persistence API (JPA)</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="java_persistence_api"/>Chapter 12. Java Persistence API (JPA)</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_jpa"/>About Java Persistence API (JPA)</h1></div></div></div><p>
				The Java Persistence API (JPA) is a Java specification for accessing, persisting, and managing data between Java objects or classes and a relational database. The JPA specification recognizes the interest and the success of the transparent object or relational mapping paradigm. It standardizes the basic APIs and the metadata needed for any object or relational persistence mechanism.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					JPA itself is just a specification, not a product; it cannot perform persistence or anything else by itself. JPA is just a set of interfaces, and requires an implementation.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="create_a_simple_jpa_application"/>Create a Simple JPA Application</h1></div></div></div><p>
				Follow the procedure below to create a simple JPA application in Red Hat Developer Studio.
			</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
						Create a JPA project in Red Hat Developer Studio.
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								In Red Hat Developer Studio, click <span class="strong"><strong>File</strong></span> → <span class="strong"><strong>New</strong></span> → <span class="strong"><strong>Project</strong></span>. Find <span class="strong"><strong>JPA</strong></span> in the list, expand it, and select <span class="strong"><strong>JPA Project</strong></span>. You are presented with the following dialog.
							</p><div class="figure"><a id="idm139905035300704"/><p class="title"><strong>Figure 12.1. New JPA Project Dialog</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/topics/images/6586.png" alt="This is the new JPA Project dialog."/></div></div></div></li><li class="listitem">
								Enter a <span class="strong"><strong>Project name</strong></span>.
							</li><li class="listitem">
								Select a <span class="strong"><strong>Target runtime</strong></span>. If no target runtime is available, follow these instructions to define a new server and runtime: <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_developer_studio/12.9/html-single/getting_started_with_developer_studio_tools/#proc_downloading-installing-and-setting-up-eap-from-within-the-ide">Downloading, Installing, and Setting Up JBoss EAP from within the IDE</a> in the <span class="emphasis"><em>Getting Started with Developer Studio Tools</em></span> guide.
							</li><li class="listitem">
								Under <span class="strong"><strong>JPA version</strong></span>, ensure <span class="strong"><strong>2.1</strong></span> is selected.
							</li><li class="listitem">
								Under <span class="strong"><strong>Configuration</strong></span>, choose <span class="strong"><strong>Basic JPA Configuration</strong></span>.
							</li><li class="listitem">
								Click <span class="strong"><strong>Finish</strong></span>.
							</li><li class="listitem">
								If prompted, choose whether you wish to associate this type of project with the JPA perspective window.
							</li></ol></div></li><li class="listitem"><p class="simpara">
						Create and configure a new persistence settings file.
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
								Open an EJB 3.x project in Red Hat Developer Studio.
							</li><li class="listitem">
								Right click the project root directory in the <span class="strong"><strong>Project Explorer</strong></span> panel.
							</li><li class="listitem">
								Select <span class="strong"><strong>New</strong></span> → <span class="strong"><strong>Other…​.</strong></span>
							</li><li class="listitem">
								Select <span class="strong"><strong>XML File</strong></span> from the XML folder and click <span class="strong"><strong>Next</strong></span>.
							</li><li class="listitem">
								Select the <code class="literal">ejbModule/META-INF/</code> folder as the parent directory.
							</li><li class="listitem">
								Name the file <code class="literal">persistence.xml</code> and click <span class="strong"><strong>Next</strong></span>.
							</li><li class="listitem">
								Select <span class="strong"><strong>Create XML file from an XML schema file</strong></span> and click <span class="strong"><strong>Next</strong></span>.
							</li><li class="listitem"><p class="simpara">
								Select <code class="literal">http://java.sun.com/xml/ns/persistence/persistence_2.0.xsd</code> from the <span class="strong"><strong>Select XML Catalog entry</strong></span> list and click <span class="strong"><strong>Next</strong></span>.
							</p><div class="figure"><a id="idm139905035264928"/><p class="title"><strong>Figure 12.2. Persistence XML Schema</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/topics/images/32.png" alt="Persistence XML Schema"/></div></div></div></li><li class="listitem"><p class="simpara">
								Click <span class="strong"><strong>Finish</strong></span> to create the file. The <code class="literal">persistence.xml</code> has been created in the <code class="literal">META-INF/</code> folder and is ready to be configured.
							</p><div class="title"><strong>Example: Persistence Settings File</strong></div><p>
									
</p><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_2.xsd"
   version="2.2"&gt;
   &lt;persistence-unit name="example" transaction-type="JTA"&gt;
      &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
      &lt;jta-data-source&gt;java:jboss/datasources/ExampleDS&lt;/jta-data-source&gt;
      &lt;mapping-file&gt;ormap.xml&lt;/mapping-file&gt;
      &lt;jar-file&gt;TestApp.jar&lt;/jar-file&gt;
      &lt;class&gt;org.test.Test&lt;/class&gt;
      &lt;shared-cache-mode&gt;NONE&lt;/shared-cache-mode&gt;
      &lt;validation-mode&gt;CALLBACK&lt;/validation-mode&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><p>

								</p></li></ol></div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jpa-entities"/>JPA Entities</h1></div></div></div><p>
				Once you have established the connection from your application to the database, you can start mapping the data in the database to Java objects. Java objects that are used to map against database tables are called entity objects.
			</p><p>
				Entities have relationships with other entities, which are expressed through object-relational metadata. The object-relational metadata can be specified either directly in the entity class file by using annotations, or in an XML descriptor file called <code class="literal">persistence.xml</code> included with the application.
			</p><p>
				The high-level mapping of Java objects to the database is as follows:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Java classes map to the database tables.
					</li><li class="listitem">
						Java instances map to the database rows.
					</li><li class="listitem">
						Java fields map to the database columns.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="persistence-context"/>Persistence Context</h1></div></div></div><p>
				The JPA persistence context contains the entities managed by the persistence provider. The persistence context acts like a first level transactional cache for interacting with the datasource. It manages the entity instances and their lifecycle. Loaded entities are placed into the persistence context before being returned to the application. Entity changes are also placed into the persistence context to be saved in the database when the transaction commits.
			</p><p>
				The lifetime of a container-managed persistence context can either be scoped to a transaction, which is referred to as a transaction-scoped persistence context, or have a lifetime scope that extends beyond that of a single transaction, which is referred to as an extended persistence context. The <code class="literal">PersistenceContextType</code> property, which has the <code class="literal">enum</code> datatype, is used to define the persistence context lifetime scope for container-managed entity managers. The persistence context lifetime scope is defined when the <code class="literal">EntityManager</code> instance is created.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transaction_scoped_persistence_context"/>Transaction-Scoped Persistence Context</h2></div></div></div><p>
					The transaction-scoped persistence context works with the active JTA transaction. When the transaction commits, the persistence context is flushed to the datasource; the entity objects are detached but might still be referenced by the application code. All the entity changes that are expected to be saved to the datasource must be made during a transaction. Entities that are read outside the transaction are detached when the <code class="literal">EntityManager</code> invocation completes.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="extended_persistence_context"/>Extended Persistence Context</h2></div></div></div><p>
					The extended persistence context spans multiple transactions and allows data modifications to be queued without an active JTA transaction. The container-managed extended persistence context can only be injected into a stateful session bean.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jpa-entity-manager"/>JPA EntityManager</h1></div></div></div><p>
				JPA entity manager represents a connection to the persistence context. You can read from and write to the database defined by the persistence context using the entity manager.
			</p><p>
				Persistence context is provided through the Java annotation <code class="literal">@PersistenceContext</code> in the <code class="literal">javax.persistence</code> package. The entity manager is provided through the Java class <code class="literal">javax.persistence.EntityManager</code>. In any managed bean, the <code class="literal">EntityManager</code> instance can be injected as shown below:
			</p><div class="title"><strong>Example: Entity Manager Injection</strong></div><p>
					
</p><pre class="programlisting">@Stateless
public class UserBean {
    @PersistenceContext
    EntityManager entitymanager;
    ...
}</pre><p>

				</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="application_managed_entitymanager"/>Application-Managed EntityManager</h2></div></div></div><p>
					Application-managed entity managers provide direct access to the underlying persistence provider, <code class="literal">org.hibernate.jpa.HibernatePersistenceProvider</code>. The scope of the application-managed entity manager is from when the application creates it and lasts until the application closes it. You can use the <code class="literal">@PersistenceUnit</code> annotation to inject a persistence unit into the <code class="literal">javax.persistence.EntityManagerFactory</code> interface, which returns an application-managed entity manager.
				</p><p>
					Application-managed entity managers can be used when your application needs to access a persistence context that is not propagated with the JTA transaction across <code class="literal">EntityManager</code> instances in a particular persistence unit. In this case, each <code class="literal">EntityManager</code> instance creates a new, isolated persistence context. The <code class="literal">EntityManager</code> instance and its associated <code class="literal">PersistenceContext</code> is created and destroyed explicitly by your application. Application-managed entity managers can also be used when you cannot inject <code class="literal">EntityManager</code> instances directly, because the <code class="literal">EntityManager</code> instances are not thread-safe. <code class="literal">EntityManagerFactory</code> instances are thread-safe.
				</p><div class="title"><strong>Example: Application-Managed Entity Manager</strong></div><p>
						
</p><pre class="programlisting">@PersistenceUnit
EntityManagerFactory emf;
EntityManager em;
@Resource
UserTransaction utx;
...
em = emf.createEntityManager();
try {
    utx.begin();
    em.persist(SomeEntity);
    em.merge(AnotherEntity);
    em.remove(ThirdEntity);
    utx.commit();
}
catch (Exception e) {
    utx.rollback();
}</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="container_managed_entitymanager"/>Container-Managed EntityManager</h2></div></div></div><p>
					Container-managed entity managers manage the underlying persistence provider for the application. They can use the transaction-scoped persistence contexts or the extended persistence contexts. The container-managed entity manager creates instances of the underlying persistence provider as needed. Every time a new underlying persistence provider <code class="literal">org.hibernate.jpa.HibernatePersistenceProvider</code> instance is created, a new persistence context is also created.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="working-with-entity-manager"/>Working with the EntityManager</h1></div></div></div><p>
				When you have the <code class="literal">persistence.xml</code> file located in the <code class="literal">/META-INF</code> directory, the entity manager is loaded and has an active connection to the database. The <code class="literal">EntityManager</code> property can be used to bind the entity manager to JNDI and to add, update, remove and query entities.
			</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					If you plan to use a security manager with Hibernate, be aware that Hibernate supports it only when <code class="literal">EntityManagerFactory</code> is bootstrapped by the JBoss EAP server. It is not supported when the <code class="literal">EntityManagerFactory</code> or <code class="literal">SessionFactory</code> is bootstrapped by the application. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/how_to_configure_server_security/#java_security_manager">Java Security Manager</a> in <span class="emphasis"><em>How to Configure Server Security</em></span> for more information about security managers.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="binding_the_entitymanager_to_jndi"/>Binding the EntityManager to JNDI</h2></div></div></div><p>
					By default, JBoss EAP does not bind the <code class="literal">EntityManagerFactory</code> to JNDI. You can explicitly configure this in the <code class="literal">persistence.xml</code> file of your application by setting the <code class="literal">jboss.entity.manager.factory.jndi.name</code> property. The value of this property should be the JNDI name to which you want to bind the <code class="literal">EntityManagerFactory</code>.
				</p><p>
					You can also bind a container-managed transaction-scoped entity manager to JNDI by using the <code class="literal">jboss.entity.manager.jndi.name</code> property.
				</p><div class="title"><strong>Example: Binding the <code class="literal">EntityManager</code> and the <code class="literal">EntityManagerFactory</code> to JNDI</strong></div><p>
						
</p><pre class="programlisting">&lt;property name="jboss.entity.manager.jndi.name" value="java:/MyEntityManager"/&gt;
&lt;property name="jboss.entity.manager.factory.jndi.name" value="java:/MyEntityManagerFactory"/&gt;</pre><p>

					</p><div class="title"><strong>Example: Storing an Entity using the <code class="literal">EntityManager</code></strong></div><p>
						
</p><pre class="programlisting">public User createUser(User user) {
    entityManager.persist(user);
    return user;
}</pre><p>

					</p><div class="title"><strong>Example: Updating an Entity using the <code class="literal">EntityManager</code></strong></div><p>
						
</p><pre class="programlisting">public void updateUser(User user) {
    entityManager.merge(user);
}</pre><p>

					</p><div class="title"><strong>Example: Removing an Entity using the <code class="literal">EntityManager</code></strong></div><p>
						
</p><pre class="programlisting">public void deleteUser(String user) {
    User user = findUser(username);
    if (user != null)
        entityManager.remove(user);
}</pre><p>

					</p><div class="title"><strong>Example: Querying an Entity using the <code class="literal">EntityManager</code></strong></div><p>
						
</p><pre class="programlisting">public User findUser(String username) {
    CriteriaBuilder builder = entityManager.getCriteriaBuilder();
    CriteriaQuery&lt;User&gt; criteria = builder.createQuery(User.class);
    Root&lt;User&gt; root = criteria.from(User.class);
    TypedQuery&lt;User&gt; query = entityManager
        .createQuery(criteria.select(root).where(
            builder.equal(root.&lt;String&gt; get("username"), username)));
    try {
        return query.getSingleResult();
    }
    catch (NoResultException e) {
        return null;
    }
}</pre><p>

					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="deploying_persistence_unit"/>Deploying the Persistence Unit</h1></div></div></div><p>
				A persistence unit is a logical grouping that includes:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Configuration information for an entity manager factory and its entity managers.
					</li><li class="listitem">
						Classes managed by the entity managers.
					</li><li class="listitem">
						Mapping metadata specifying the mapping of the classes to the database.
					</li></ul></div><p>
				The <code class="literal">persistence.xml</code> file contains persistence unit configuration, including the datasource name. The JAR file or the directory whose <code class="literal">/META-INF/</code> directory contains the <code class="literal">persistence.xml</code> file is termed as the root of the persistence unit.
			</p><p>
				In Java EE environments, the root of the persistence unit must be one of the following:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						An EJB-JAR file
					</li><li class="listitem">
						The <code class="literal">/WEB-INF/classes/</code> directory of a WAR file
					</li><li class="listitem">
						A JAR file in the <code class="literal">/WEB-INF/lib/</code> directory of a WAR file
					</li><li class="listitem">
						A JAR file in the EAR library directory
					</li><li class="listitem">
						An application client JAR file
					</li></ul></div><div class="title"><strong>Example: Persistence Settings File</strong></div><p>
					
</p><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_2.xsd"
   version="2.2"&gt;
   &lt;persistence-unit name="example" transaction-type="JTA"&gt;
      &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
      &lt;jta-data-source&gt;java:jboss/datasources/ExampleDS&lt;/jta-data-source&gt;
      &lt;mapping-file&gt;ormap.xml&lt;/mapping-file&gt;
      &lt;jar-file&gt;TestApp.jar&lt;/jar-file&gt;
      &lt;class&gt;org.test.Test&lt;/class&gt;
      &lt;shared-cache-mode&gt;NONE&lt;/shared-cache-mode&gt;
      &lt;validation-mode&gt;CALLBACK&lt;/validation-mode&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><p>

				</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="second_level_caches"/>Second-level Caches</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_second_level_caches"/>About Second-level Caches</h2></div></div></div><p>
					A second-level cache is a local data store that holds information persisted outside the application session. The cache is managed by the persistence provider, improving runtime by keeping the data separate from the application.
				</p><p>
					JBoss EAP supports caching for the following purposes:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Web Session Clustering
						</li><li class="listitem">
							Stateful Session Bean Clustering
						</li><li class="listitem">
							SSO Clustering
						</li><li class="listitem">
							Hibernate/JPA Second-level Cache
						</li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Each cache container defines a <code class="literal">repl</code> and a <code class="literal">dist</code> cache. These caches should not be used directly by user applications.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="default_second_level_cache_provider_infinispan"/>Default Second-level Cache Provider</h3></div></div></div><p>
						Infinispan is the default second-level cache provider for JBoss EAP. Infinispan is a distributed in-memory key/value data store with optional schema, available under the Apache License 2.0.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="configure_second_level_cache_persistence_unit"/>Configuring a Second-level Cache in the Persistence Unit</h4></div></div></div><p>
							You can use the <code class="literal">shared-cache-mode</code> element of the persistence unit to configure the second-level cache.
						</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
									See <a class="link" href="java_persistence_api.html#create_a_simple_jpa_application" title="Create a Simple JPA Application">Create a Simple JPA Application</a> to create the <code class="literal">persistence.xml</code> file in Red Hat Developer Studio.
								</li><li class="listitem"><p class="simpara">
									Add the following to the <code class="literal">persistence.xml</code> file:
								</p><pre class="programlisting">&lt;persistence-unit name="..."&gt;
  (...) &lt;!-- other configuration --&gt;
  &lt;shared-cache-mode&gt;<span class="emphasis"><em>SHARED_CACHE_MODE</em></span>&lt;/shared-cache-mode&gt;
  &lt;properties&gt;
    &lt;property name="hibernate.cache.use_second_level_cache" value="true" /&gt;
    &lt;property name="hibernate.cache.use_query_cache" value="true" /&gt;
  &lt;/properties&gt;
&lt;/persistence-unit&gt;</pre><p class="simpara">
									The <code class="literal"><span class="emphasis"><em>SHARED_CACHE_MODE</em></span></code> element can take the following values:
								</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
											<code class="literal">ALL</code>: All entities should be considered cacheable.
										</li><li class="listitem">
											<code class="literal">NONE</code>: No entities should be considered cacheable.
										</li><li class="listitem">
											<code class="literal">ENABLE_SELECTIVE</code>: Only entities marked as cacheable should be considered cacheable.
										</li><li class="listitem">
											<code class="literal">DISABLE_SELECTIVE</code>: All entities except the ones explicitly marked as not cacheable should be considered cacheable.
										</li><li class="listitem">
											<code class="literal">UNSPECIFIED</code>: Behavior is not defined. Provider-specific defaults are applicable.
										</li></ul></div></li></ol></div></div></div></div></div></div></body></html>