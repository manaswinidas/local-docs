<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 11. Java Transaction API (JTA)</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="java_transaction_api"/>Chapter 11. Java Transaction API (JTA)</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="overview"/>Overview</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_java_transactions_api_jta"/>Overview of Java Transaction API (JTA)</h2></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Introduction</span></dt><dd><p class="simpara">
								This section provides a foundational understanding of the Java Transaction API (JTA).
							</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										<a class="link" href="java_transaction_api.html#about_java_transactions_api_jta" title="About Java Transaction API (JTA)">About Java Transaction API (JTA)</a>
									</li><li class="listitem">
										<a class="link" href="java_transaction_api.html#transaction_lifecycle" title="Transaction Lifecycle">Transaction Lifecycle</a>
									</li><li class="listitem">
										<a class="link" href="java_transaction_api.html#jta_transaction_example" title="JTA Transaction Example">JTA Transaction Example</a>
									</li></ul></div></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transaction_concepts"/>Transaction Concepts</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_transactions"/>About Transactions</h2></div></div></div><p>
					A transaction consists of two or more actions, which must either all succeed or all fail. A successful outcome is a commit, and a failed outcome is a rollback. In a rollback, each member’s state is reverted to its state before the transaction attempted to commit.
				</p><p>
					The typical standard for a well-designed transaction is that it is Atomic, Consistent, Isolated, and Durable (ACID).
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_acid_properties_for_transactions"/>About ACID Properties for Transactions</h2></div></div></div><p>
					ACID is an acronym which stands for <code class="literal">Atomicity</code>, <code class="literal">Consistency</code>, <code class="literal">Isolation</code>, and <code class="literal">Durability</code>. This terminology is usually used in the context of databases or transactional operations.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Atomicity</span></dt><dd>
								For a transaction to be atomic, all transaction members must make the same decision. Either they all commit, or they all roll back. If atomicity is broken, what results is termed a heuristic outcome.
							</dd><dt><span class="term">Consistency</span></dt><dd>
								Consistency means that data written to the database is guaranteed to be valid data, in terms of the database schema. The database or other data source must always be in a consistent state. One example of an inconsistent state would be a field in which half of the data is written before an operation aborts. A consistent state would be if all the data were written, or the write were rolled back when it could not be completed.
							</dd><dt><span class="term">Isolation</span></dt><dd>
								Isolation means that data being operated on by a transaction must be locked before modification, to prevent processes outside the scope of the transaction from modifying the data.
							</dd><dt><span class="term">Durability</span></dt><dd>
								Durability means that in the event of an external failure after transaction members have been instructed to commit, all members will be able to continue committing the transaction when the failure is resolved. This failure can be related to hardware, software, network, or any other involved system.
							</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_transaction_coordinator_or_transaction_manager"/>About the Transaction Coordinator or Transaction Manager</h2></div></div></div><p>
					The terms Transaction Coordinator and Transaction Manager (TM) are mostly interchangeable in terms of transactions with JBoss EAP. The term Transaction Coordinator is usually used in the context of distributed JTS transactions.
				</p><p>
					In JTA transactions, the TM runs within JBoss EAP and communicates with transaction participants during the two-phase commit protocol.
				</p><p>
					The TM tells transaction participants whether to commit or roll back their data, depending on the outcome of other transaction participants. In this way, it ensures that transactions adhere to the ACID standard.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_transaction_participants" title="About Transaction Participants">About Transaction Participants</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_acid_properties_for_transactions" title="About ACID Properties for Transactions">About ACID Properties for Transactions</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_the_2_phase_commit_protocol" title="About the 2-Phase Commit Protocol">About the 2-Phase Commit Protocol</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_transaction_participants"/>About Transaction Participants</h2></div></div></div><p>
					A transaction participant is any resource within a transaction that has the ability to commit or to roll back state. It is generally a database or a JMS broker, but by implementing the transaction interface, application code could also act as a transaction participant. Each participant of a transaction independently decides whether it is able to commit or roll back its state, and only if all participants can commit does the transaction as a whole succeed. Otherwise, each participant rolls back its state, and the transaction as a whole fails. The TM coordinates the commit or rollback operations and determines the outcome of the transaction.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_java_transactions_api_jta"/>About Java Transaction API (JTA)</h2></div></div></div><p>
					Java Transaction API (JTA) is part of Java Enterprise Edition specification. It is defined in <a class="link" href="https://jcp.org/en/jsr/detail?id=907">JSR 907: Java™ Transaction API (JTA)</a>.
				</p><p>
					Implementation of JTA is done using the TM, which is covered by project Narayana for JBoss EAP application server. The TM allows applications to assign various resources, for example, database or JMS brokers, through a single global transaction. The global transaction is referred as an XA transaction. Generally resources with XA capabilities are included in such transactions, but non-XA resources could also be part of global transactions. There are several optimizations which help non-XA resources to behave as XA capable resources. For more information, see <a class="link" href="java_transaction_api.html#about_the_lrco_optimization_for_single_phase_commit_1pc" title="About the LRCO Optimization for Single-phase Commit (1PC)">LRCO Optimization for Single-phase Commit</a>.
				</p><p>
					In this document, the term JTA refers to two things:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							The Java Transaction API, which is defined by Java EE specification.
						</li><li class="listitem">
							It indicates how the TM processes the transactions.
						</li></ol></div><p>
					The TM works in JTA transactions mode, the data is shared in memory, and the transaction context is transferred by remote EJB calls. In JTS mode, the data is shared by sending Common Object Request Broker Architecture (CORBA) messages and the transaction context is transferred by IIOP calls. Both modes support distribution of transactions over multiple JBoss EAP servers.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_distributed_transactions" title="About Distributed Transactions">About Distributed Transactions</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_xa_datasources_and_xa_transactions" title="About XA Resources and XA Transactions">About XA Datasources and XA Transactions</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_java_transaction_service_jts"/>About Java Transaction Service (JTS)</h2></div></div></div><p>
					Java Transaction Service (JTS) is a mapping of the Object Transaction Service (OTS) to Java. Java EE applications use the JTA API to manage transactions. JTA API then interacts with a JTS transaction implementation when the transaction manager is switched to JTS mode. JTS works over the IIOP protocol. Transaction managers that use JTS communicate with each other using a process called an Object Request Broker (ORB), using a communication standard called Common Object Request Broker Architecture (CORBA). For more information, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/configuration_guide/#orb_configuration">ORB Configuration</a> in the JBoss EAP <span class="emphasis"><em>Configuration Guide</em></span>.
				</p><p>
					Using the JTA API from an application standpoint, a JTS transaction behaves in the same way as a JTA transaction.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The implementation of JTS included in JBoss EAP supports distributed transactions. The difference from fully-compliant JTS transactions is interoperability with external third-party ORBs. This feature is unsupported with JBoss EAP. Supported configurations distribute transactions across multiple JBoss EAP containers only.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_xml_transaction_service"/>About XML Transaction Service</h2></div></div></div><p>
					The XML Transaction Service (XTS) component supports the coordination of private and public web services in a business transaction. Using XTS, you can coordinate complex business transactions in a controlled and reliable manner. The XTS API supports a transactional coordination model based on the WS-Coordination, WS-Atomic Transaction, and WS-Business Activity protocols.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="overview_protocols_used_by_xts"/>Overview of Protocols Used by XTS</h3></div></div></div><p>
						The WS-Coordination (WS-C) specification defines a framework that allows different coordination protocols to be plugged in to coordinate work between clients, services, and participants.
					</p><p>
						The WS-Transaction (WS-T) protocol comprises the pair of transaction coordination protocols, WS-Atomic Transaction (WS-AT) and WS-Business Activity (WS-BA), which utilize the coordination framework provided by WS-C. WS-T is developed to unify existing traditional transaction processing systems, allowing them to communicate reliably with one another.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="web_services_atomic_transaction_process"/>Web Services-Atomic Transaction Process</h3></div></div></div><p>
						An atomic transaction (AT) is designed to support short duration interactions where ACID semantics are appropriate. Within the scope of an AT, web services typically employ bridging to access XA resources, such as databases and message queues, under the control of the WS-T. When the transaction terminates, the participant propagates the outcome decision of the AT to the XA resources, and the appropriate commit or rollback actions are taken by each participant.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="atomic_transaction_process"/>Atomic Transaction Process</h4></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
									To initiate an AT, the client application first locates a WS-C Activation Coordinator web service that supports WS-T.
								</li><li class="listitem">
									The client sends a WS-C <code class="literal">CreateCoordinationContext</code> message to the service, specifying <a class="link" href="http://schemas.xmlsoap.org/ws/2004/10/wsat">http://schemas.xmlsoap.org/ws/2004/10/wsat</a> as its coordination type.
								</li><li class="listitem">
									The client receives an appropriate WS-T context from the activation service.
								</li><li class="listitem">
									The response to the <code class="literal">CreateCoordinationContext</code> message, the transaction context, has its <code class="literal">CoordinationType</code> element set to the WS-AT namespace, <a class="link" href="http://schemas.xmlsoap.org/ws/2004/10/wsat">http://schemas.xmlsoap.org/ws/2004/10/wsat</a>. It also contains a reference to the atomic transaction coordinator endpoint, the WS-C Registration Service, where participants can be enlisted.
								</li><li class="listitem">
									The client normally proceeds to invoke web services and complete the transaction, either committing all the changes made by the web services, or rolling them back. In order to be able to drive this completion, the client must register itself as a participant for the completion protocol, by sending a register message to the registration service whose endpoint was returned in the coordination context.
								</li><li class="listitem">
									Once registered for completion, the client application then interacts with web services to accomplish its business-level work. With each invocation of a business web service, the client inserts the transaction context into a SOAP header block, such that each invocation is implicitly scoped by the transaction. The toolkits that support WS-AT aware web services provide facilities to correlate contexts found in SOAP header blocks with back-end operations. This ensures that modifications made by the web service are done within the scope of the same transaction as the client and subject to commit or rollback by the Transaction Coordinator.
								</li><li class="listitem">
									Once all the necessary application work is complete, the client can terminate the transaction, with the intent of making any changes to the service state permanent. The completion participant instructs the coordinator to try to commit or roll back the transaction. When the commit or rollback operation completes, a status is returned to the participant to indicate the outcome of the transaction.
								</li></ol></div><p>
							For more details, see <a class="link" href="http://narayana.io//docs/project/index.html#d0e14935">WS-Coordination</a> in the Naryana Project Documentation.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="wsat_dotnet_clients"/>WS-AT Interoperability with Microsoft .NET Clients</h4></div></div></div><p>
							The <code class="literal">xts</code> subsystem can have issues communicating with Microsoft .NET clients because of differences in the .NET implementation of the WS-AT specification. The .NET implementation of the WS-AT specification forces any call to be asynchronous.
						</p><p>
							To enable interoperability with .NET clients, an asynchronous registration option is available in the JBoss EAP <code class="literal">xts</code> subsystem. XTS asynchronous registration is disabled by default, and you should only enable it if necessary.
						</p><p>
							To enable asynchronous registration for WS-AT interoperability with .NET clients, use the following management CLI command:
						</p><pre class="screen">/subsystem=xts:write-attribute(name=async-registration, value=true)</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="web_services_business_activity_process"/>Web Services-Business Activity Process</h3></div></div></div><p>
						Web Services-Business Activity (WS-BA) defines a protocol for web service applications to enable existing business processing and workflow systems to wrap their proprietary mechanisms and interoperate across implementations and business boundaries.
					</p><p>
						Unlike the WS-AT protocol model, where participants inform the transaction coordinator of their state only when asked, a child activity within a WS-BA can specify its outcome to the coordinator directly, without waiting for a request. A participant can choose to exit the activity or notify the coordinator of a failure at any point. This feature is useful when tasks fail because the notification can be used to modify the goals and drive processing forward, without waiting until the end of the transaction to identify failures.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="ws_ba_process"/>WS-BA Process</h4></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
									Services are requested to do work.
								</li><li class="listitem">
									Wherever these services have the ability to undo any work, they inform the WS-BA, in case the WS-BA later decides the cancel the work. If the WS-BA suffers a failure. it can instruct the service to execute its <code class="literal">undo</code> behavior.
								</li></ol></div><p>
							The WS-BA protocols employ a compensation-based transaction model. When a participant in a business activity completes its work, it can choose to exit the activity. This choice does not allow any subsequent rollback. Alternatively, the participant can complete its activity, signaling to the coordinator that the work it has done can be compensated if, at some later point, another participant notifies a failure to the coordinator. In this latter case, the coordinator asks each non-exited participant to compensate for the failure, giving them the opportunity to execute whatever compensating action they consider appropriate. If all participants exit or complete without failure, the coordinator notifies each completed participant that the activity has been closed.
						</p><p>
							For more details, see <a class="link" href="http://narayana.io//docs/project/index.html#d0e14935">WS-Coordination</a> in the Naryana Project Documentation.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="transaction_bridging_overview"/>Transaction Bridging Overview</h3></div></div></div><p>
						Transaction Bridging describes the process of linking the Java EE and WS-T domains. The transaction bridge component, <code class="literal">txbridge</code>, provides bi-directional linkage, such that either type of transaction can encompass business logic designed for use with the other type. The technique used by the bridge is a combination of interposition and protocol mapping.
					</p><p>
						In the transaction bridge, an interposed coordinator is registered into the existing transaction and performs the additional task of protocol mapping; that is, it appears to its parent coordinator to be a resource of its native transaction type, while appearing to its children to be a coordinator of their native transaction type, even though these transaction types differ.
					</p><p>
						The transaction bridge resides in the package <code class="literal">org.jboss.jbossts.txbridge</code> and its subpackages. It consists of two distinct sets of classes, one for bridging in each direction.
					</p><p>
						For more details, see <a class="link" href="http://narayana.io//docs/project/index.html#d0e14935">TXBridge Guide</a> in the Naryana Project Documentation.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_xa_datasources_and_xa_transactions"/>About XA Resources and XA Transactions</h2></div></div></div><p>
					XA stands for eXtended Architecture, which was developed by the X/Open Group to define a transaction that uses more than one back-end data store. The XA standard describes the interface between a global TM and a local resource manager. XA allows multiple resources, such as application servers, databases, caches, and message queues, to participate in the same transaction, while preserving all four ACID properties. One of the four ACID properties is atomicity, which means that if one of the participants fails to commit its changes, the other participants abort the transaction, and restore their state to the same status as before the transaction occurred. An XA resource is a resource that can participate in an XA global transaction.
				</p><p>
					An XA transaction is a transaction that can span multiple resources. It involves a coordinating TM, with one or more databases or other transactional resources, all involved in a single global XA transaction.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_xa_recovery"/>About XA Recovery</h2></div></div></div><p>
					TM implements X/Open XA specification and supports XA transactions across multiple XA resources.
				</p><p>
					XA Recovery is the process of ensuring that all resources affected by a transaction are updated or rolled back, even if any of the resources that are transaction participants crash or become unavailable. Within the scope of JBoss EAP, the <code class="literal">transactions</code> subsystem provides the mechanisms for XA Recovery to any XA resources or subsystems that use them, such as XA datasources, JMS message queues, and JCA resource adapters.
				</p><p>
					XA Recovery happens without user intervention. In the event of an XA Recovery failure, errors are recorded in the log output. Contact Red Hat Global Support Services if you need assistance. The XA recovery process is driven by a periodic recovery thread which is launched by default every two minutes. The periodic recovery thread processes all unfinished transactions.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						It can take four to eight minutes to complete the recovery for an in-doubt transaction because it might require multiple runs of the recovery process.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="limitations_of_the_xa_recovery_process"/>Limitations of the XA Recovery Process</h2></div></div></div><p>
					XA recovery has the following limitations:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							The transaction log might not be cleared from a successfully committed transaction.
						</p><p class="simpara">
							If the JBoss EAP server crashes after an <code class="literal">XAResource</code> commit method successfully completes and commits the transaction, but before the coordinator can update the log, you might see the following warning message in the log when you restart the server:
						</p><pre class="screen">ARJUNA016037: Could not find new XAResource to use for recovering non-serializable XAResource XAResourceRecord</pre><p class="simpara">
							This is because upon recovery, the JBoss Transaction Manager (TM) sees the transaction participants in the log and attempts to retry the commit. Eventually the JBoss TM assumes the resources are committed and no longer retries the commit. In this situation, you can safely ignore this warning as the transaction is committed and there is no loss of data.
						</p><p class="simpara">
							To prevent the warning, set the <code class="literal">com.arjuna.ats.jta.xaAssumeRecoveryComplete</code> property value to <code class="literal">true</code> . This property is checked whenever a new <code class="literal">XAResource</code> instance cannot be located from any registered <code class="literal">XAResourceRecovery</code> instance. When set to <code class="literal">true</code>, the recovery assumes that a previous commit attempt succeeded and the instance can be removed from the log with no further recovery attempts. This property must be used with care because it is global and when used incorrectly could result in <code class="literal">XAResource</code> instances remaining in an uncommitted state.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								JBoss EAP 7.2 has an implemented enhancement to clear transaction logs after a successfully committed transaction and the above situation should not occur frequently.
							</p></div></li><li class="listitem"><p class="simpara">
							Rollback is not called for JTS transaction when a server crashes at the end of <code class="literal">XAResource.prepare()</code>.
						</p><p class="simpara">
							If the JBoss EAP server crashes after the completion of an <code class="literal">XAResource.prepare()</code> method call, all of the participating <code class="literal">XAResource</code> instances are locked in the prepared state and remain that way upon server restart. The transaction is not rolled back and the resources remain locked until the transaction times out or a database administrator manually rolls back the resources and clears the transaction log. For more information, see <a class="link" href="https://issues.jboss.org/browse/JBTM-2124">https://issues.jboss.org/browse/JBTM-2124</a>
						</p></li><li class="listitem"><p class="simpara">
							Periodic recovery can occur on committed transactions.
						</p><p class="simpara">
							When the server is under excessive load, the server log might contain the following warning message, followed by a stacktrace:
						</p><pre class="screen">ARJUNA016027: Local XARecoveryModule.xaRecovery got XA exception XAException.XAER_NOTA: javax.transaction.xa.XAException</pre><p class="simpara">
							Under heavy load, the processing time taken by a transaction can overlap with the timing of the periodic recovery process’s activity. The periodic recovery process detects the transaction still in progress and attempts to initiate a rollback but in fact the transaction continues to completion. At the time the periodic recovery attempts but fails the rollback, it records the rollback failure in the server log. The underlying cause of this issue will be addressed in a future release, but in the meantime a workaround is available.
						</p><p class="simpara">
							Increase the interval between the two phases of the recovery process by setting the <code class="literal">com.arjuna.ats.jta.orphanSafetyInterval</code> property to a value higher than the default value of <code class="literal">10000</code> milliseconds. A value of <code class="literal">40000</code> milliseconds is recommended. Note that this does not solve the issue. Instead it decreases the probability that it will occur and that the warning message will be shown in the log. For more information, see <a class="link" href="https://developer.jboss.org/thread/266729">https://developer.jboss.org/thread/266729</a>
						</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_2_phase_commit_protocol"/>About the 2-Phase Commit Protocol</h2></div></div></div><p>
					The two-phase commit (2PC) protocol refers to an algorithm to determine the outcome of a transaction. 2PC is driven by the Transaction Manager (TM) as a process of finishing XA transactions.
				</p><h4><a id="phase_1_prepare"/>Phase 1: Prepare</h4><p>
					In the first phase, the transaction participants notify the transaction coordinator whether they are able to commit the transaction or must roll back.
				</p><h4><a id="phase_2_commit"/>Phase 2: Commit</h4><p>
					In the second phase, the transaction coordinator makes the decision about whether the overall transaction should commit or roll back. If any one of the participants cannot commit, the transaction must roll back. Otherwise, the transaction can commit. The coordinator directs the resources about what to do, and they notify the coordinator when they have done it. At that point, the transaction is finished.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_transaction_timeouts"/>About Transaction Timeouts</h2></div></div></div><p>
					In order to preserve atomicity and adhere to the ACID standard for transactions, some parts of a transaction can be long-running. Transaction participants need to lock an XA resource that is part of database table or message in a queue when they commit. The TM needs to wait to hear back from each transaction participant before it can direct them all whether to commit or roll back. Hardware or network failures can cause resources to be locked indefinitely.
				</p><p>
					Transaction timeouts can be associated with transactions in order to control their lifecycle. If a timeout threshold passes before the transaction commits or rolls back, the timeout causes the transaction to be rolled back automatically.
				</p><p>
					You can configure default timeout values for the entire transaction subsystem, or you can disable default timeout values and specify timeouts on a per-transaction basis.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_distributed_transactions"/>About Distributed Transactions</h2></div></div></div><p>
					A distributed transaction is a transaction with participants on multiple JBoss EAP servers. The Java Transaction Service (JTS) specification mandates that JTS transactions be able to be distributed across application servers from different vendors. The Java Transaction API (JTA) does not define that but JBoss EAP supports distributed JTA transactions among JBoss EAP servers.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Transaction distribution among servers from different vendors is not supported.
					</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						In other application server vendor documentation, you might find that the term distributed transaction means XA transaction. In the context of JBoss EAP documentation, the distributed transaction refers to transactions distributed among several JBoss EAP application servers. Transactions that consist of different resources, for example, database resources and JMS resources, are referred as XA transactions in this document. For more information, see <a class="link" href="java_transaction_api.html#about_java_transaction_service_jts" title="About Java Transaction Service (JTS)">About Java Transaction Service (JTS)</a> and <a class="link" href="java_transaction_api.html#about_xa_datasources_and_xa_transactions" title="About XA Resources and XA Transactions">About XA Datasources and XA Transactions</a>.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_orb_portability_api"/>About the ORB Portability API</h2></div></div></div><p>
					The Object Request Broker (ORB) is a process that sends and receives messages to transaction participants, coordinators, resources, and other services distributed across multiple application servers. An ORB uses a standardized Interface Description Language (IDL) to communicate and interpret messages. Common Object Request Broker Architecture (CORBA) is the IDL used by the ORB in JBoss EAP.
				</p><p>
					The main type of service that uses an ORB is a system of distributed Java Transactions, using the Java Transaction Service (JTS) specification. Other systems, especially legacy systems, can choose to use an ORB for communication rather than other mechanisms such as remote Enterprise JavaBeans or JAX-WS or JAX-RS web services.
				</p><p>
					The ORB Portability API provides mechanisms to interact with an ORB. This API provides methods for obtaining a reference to the ORB, as well as placing an application into a mode where it listens for incoming connections from an ORB. Some of the methods in the API are not supported by all ORBs. In those cases, an exception is thrown.
				</p><p>
					The API consists of two different classes:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">com.arjuna.orbportability.orb</code>
						</li><li class="listitem">
							<code class="literal">com.arjuna.orbportability.oa</code>
						</li></ul></div><p>
					See the JBoss EAP Javadocs bundle available on the <a class="link" href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</a> for specific details about the methods and properties included in the ORB Portability API.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transaction_optimizations"/>Transaction Optimizations</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="overview_of_transaction_optimizations"/>Overview of Transaction Optimizations</h2></div></div></div><p>
					The Transaction Manager (TM) of JBoss EAP includes several optimizations that your application can take advantage of.
				</p><p>
					Optimizations serve to enhance the 2-phase commit protocol in particular cases. Generally, the TM starts a global transaction, which passes through the 2-phase commit. But when you optimize these transactions, in certain cases, the TM does not need to proceed with full 2-phased commits and thus the process gets faster.
				</p><p>
					Different optimizations used by the TM are described in detail below.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_the_lrco_optimization_for_single_phase_commit_1pc" title="About the LRCO Optimization for Single-phase Commit (1PC)">About the LRCO Optimization for Single-phase Commit (1PC)</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_the_presumed_abort_optimization" title="About the Presumed-Abort Optimization">About the Presumed-Abort Optimization</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_the_read_only_optimization" title="About the Read-Only Optimization">About the Read-Only Optimization</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_lrco_optimization_for_single_phase_commit_1pc"/>About the LRCO Optimization for Single-phase Commit (1PC)</h2></div></div></div><h4><a id="single_phase_commit_1pc"/>Single-phase Commit (1PC)</h4><p>
					Although the 2-phase commit protocol (2PC) is more commonly encountered with transactions, some situations do not require, or cannot accommodate, both phases. In these cases, you can use the single phase commit (1PC) protocol. The single phase commnit protocol is used when only one XA or non-XA resource is a part of the global transaction.
				</p><p>
					The prepare phase generally locks the resource until the second phase is processed. Single-phase commit means that the prepare phase is skipped and only the commit is processed on the resource. If not specified, the single-phase commit optimization is used automatically when the global transaction contains only one participant.
				</p><h4><a id="last_resource_commit_optimization_lrco"/>Last Resource Commit Optimization (LRCO)</h4><p>
					In situations where non-XA datasource participate in XA transaction, an optimization known as the Last Resource Commit Optimization (LRCO) is employed. While this protocol allows for most transactions to complete normally, certain types of error can cause an inconsistent transaction outcome. Therefore, use this approach only as a last resort.
				</p><p>
					The non-XA resource is processed at the end of the prepare phase, and an attempt is made to commit it. If the commit succeeds, the transaction log is written and the remaining resources go through the commit phase. If the last resource fails to commit, the transaction is rolled back.
				</p><p>
					Where a single local TX datasource is used in a transaction, the LRCO is automatically applied to it.
				</p><p>
					Previously, adding non-XA resources to an XA transaction was achieved via the LRCO method. However, there is a window of failure in LRCO. The procedure for adding non-XA resources to an XA transaction using the LRCO method is as follows:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							Prepare the XA transaction.
						</li><li class="listitem">
							Commit LRCO.
						</li><li class="listitem">
							Write the transaction log.
						</li><li class="listitem">
							Commit the XA transaction.
						</li></ol></div><p>
					If the procedure crashes between step 2 and step 3, this could lead to data inconsistency and you cannot commit the XA transaction. The data inconsistency is because the LRCO non-XA resource is committed but information about preparation of XA resource was not recorded. The recovery manager will rollback the resource after the server is up. Commit Markable Resource (CMR) eliminates this restriction and allows a non-XA resource to be reliably enlisted in an XA transaction.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						CMR is a special case of LRCO optimization that should only be used for datasources. It is not suitable for all non-XA resources.
					</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_the_2_phase_commit_protocol" title="About the 2-Phase Commit Protocol">About the 2-Phase Commit Protocol</a>
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="commit_markable_resource"/>Commit Markable Resource</h3></div></div></div><h5><a id="summary"/>Summary</h5><p>
						Configuring access to a resource manager using the Commit Markable Resource (CMR) interface ensures that a non-XA datasource can be reliably enlisted in an XA (2PC) transaction. It is an implementation of the LRCO algorithm, which makes non-XA resource fully recoverable.
					</p><p>
						To configure the CMR, you must:
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
								Create tables in a database.
							</li><li class="listitem">
								Enable the datasource to be connectable.
							</li><li class="listitem">
								Add a reference to <code class="literal">transactions</code> subsystem.
							</li></ol></div><h5><a id="create_tables_in_database"/>Create Tables in Database</h5><p>
						A transaction can contain only one CMR resource. You can create a table using SQL similar to the following example.
					</p><pre class="screen">SELECT xid,actionuid FROM _tableName_ WHERE transactionManagerID IN (String[])
DELETE FROM _tableName_ WHERE xid IN (byte[[]])
INSERT INTO _tableName_ (xid, transactionManagerID, actionuid) VALUES (byte[],String,byte[])</pre><p>
						The following are examples of the SQL syntax to create tables for various database management systems.
					</p><div class="title"><strong>Example: Sybase Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid varbinary(144), transactionManagerID varchar(64), actionuid varbinary(28))</pre><p>

						</p><div class="title"><strong>Example: Oracle Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid RAW(144), transactionManagerID varchar(64), actionuid RAW(28))
CREATE UNIQUE INDEX index_xid ON xids (xid)</pre><p>

						</p><div class="title"><strong>Example: IBM Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid VARCHAR(255) for bit data not null, transactionManagerID
varchar(64), actionuid VARCHAR(255) for bit data not null)
CREATE UNIQUE INDEX index_xid ON xids (xid)</pre><p>

						</p><div class="title"><strong>Example: SQL Server Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid varbinary(144), transactionManagerID varchar(64), actionuid varbinary(28))
CREATE UNIQUE INDEX index_xid ON xids (xid)</pre><p>

						</p><div class="title"><strong>Example: PostgreSQL Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid bytea, transactionManagerID varchar(64), actionuid bytea)
CREATE UNIQUE INDEX index_xid ON xids (xid)</pre><p>

						</p><div class="title"><strong>Example: MariaDB Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid BINARY(144), transactionManagerID varchar(64), actionuid BINARY(28))
CREATE UNIQUE INDEX index_xid ON xids (xid)</pre><p>

						</p><div class="title"><strong>Example: MySQL Create Table Syntax</strong></div><p>
							
</p><pre class="screen">CREATE TABLE xids (xid VARCHAR(255), transactionManagerID varchar(64), actionuid VARCHAR(255))
CREATE UNIQUE INDEX index_xid ON xids (xid)</pre><p>

						</p><h5><a id="enabling_datasource_to_be_connectable"/>Enabling Datasource to be Connectable</h5><p>
						By default, the CMR feature is disabled for datasources. To enable it, you must create or modify the datasource configuration and ensure that the <code class="literal">connectable</code> attribute is set to <code class="literal">true</code>. The following is an example of the datasources section of a server XML configuration file:
					</p><pre class="screen">&lt;datasource enabled="true" jndi-name="java:jboss/datasources/ConnectableDS" pool-name="ConnectableDS" jta="true" use-java-context="true" connectable="true"/&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							This feature is not applicable to XA datasources.
						</p></div><p>
						You can also enable a resource manager as a CMR, using the management CLI, as follows:
					</p><pre class="screen">/subsystem=datasources/data-source=ConnectableDS:add(enabled="true", jndi-name="java:jboss/datasources/ConnectableDS", jta="true", use-java-context="true", connectable="true", connection-url="validConnectionURL", exception-sorter-class-name="org.jboss.jca.adapters.jdbc.extensions.mssql.MSSQLExceptionSorter", driver-name="mssql")</pre><p>
						This command generates the following XML in the <code class="literal">datasources</code> section of the server configuration file.
					</p><pre class="programlisting">&lt;datasource jta="true" jndi-name="java:jboss/datasources/ConnectableDS" pool-name="ConnectableDS" enabled="true" use-java-context="true" connectable="true"&gt;
  &lt;connection-url&gt;validConnectionURL&lt;/connection-url&gt;
  &lt;driver&gt;mssql&lt;/driver&gt;
  &lt;validation&gt;
    &lt;exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.mssql.MSSQLExceptionSorter"/&gt;
  &lt;/validation&gt;
&lt;/datasource&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The datasource must have a valid driver defined. The example above uses <code class="literal">mssql</code> as the <code class="literal">driver-name</code>; however the <code class="literal">mssql</code> driver does not exist. For details, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/configuration_guide/#example_mysql_datasource">Example MySQL Datasource</a> in the JBoss EAP <span class="emphasis"><em>Configuration Guide</em></span>.
						</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Use the <code class="literal">exception-sorter-class-name</code> parameter in the datasource configuration. For details, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/configuration_guide/#example_datasource_configurations">Example Datasource Configurations</a> in the JBoss EAP <span class="emphasis"><em>Configuration Guide</em></span>.
						</p></div><h5><a id="updating_an_existing_resource_to_use_the_new_cmr_feature"/>Updating an Existing Resource to Use the New CMR Feature</h5><p>
						If you only need to update an existing datasource to use the CMR feature, then simply modify the <code class="literal">connectable</code> attribute:
					</p><pre class="screen">/subsystem=datasources/data-source=ConnectableDS:write-attribute(name=connectable,value=true)</pre><h5><a id="add_a_reference_to_the_transactions_subsystem"/>Add a Reference to the Transactions Subsystem</h5><p>
						The <code class="literal">transactions</code> subsystem identifies the datasources that are CMR capable through an entry to the <code class="literal">transactions</code> subsystem configuration section as shown below:
					</p><pre class="programlisting">&lt;subsystem xmlns="urn:jboss:domain:transactions:5.0"&gt;
    ...
    &lt;commit-markable-resources&gt;
        &lt;commit-markable-resource jndi-name="java:jboss/datasources/ConnectableDS"&gt;
            &lt;xid-location name="xids" batch-size="100" immediate-cleanup="false"/&gt;
        &lt;/commit-markable-resource&gt;
        ...
    &lt;/commit-markable-resources&gt;
&lt;/subsystem&gt;</pre><p>
						The same result can be achieved using the management CLI:
					</p><pre class="screen">/subsystem=transactions/commit-markable-resource=java\:jboss\/datasources\/ConnectableDS/:add(batch-size=100,immediate-cleanup=false,name=xids)</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							You must restart the server after adding the CMR reference under the <code class="literal">transactions</code> subsystem.
						</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_presumed_abort_optimization"/>About the Presumed-Abort Optimization</h2></div></div></div><p>
					If a transaction is going to roll back, it can record this information locally and notify all enlisted participants. This notification is only a courtesy, and has no effect on the transaction outcome. After all participants have been contacted, the information about the transaction can be removed.
				</p><p>
					If a subsequent request for the status of the transaction occurs there will be no information available. In this case, the requester assumes that the transaction has aborted and rolled back. This presumed-abort optimization means that no information about participants needs to be made persistent until the transaction has decided to commit, since any failure prior to this point will be assumed to be an abort of the transaction.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_read_only_optimization"/>About the Read-Only Optimization</h2></div></div></div><p>
					When a participant is asked to prepare, it can indicate to the coordinator that it has not modified any data during the transaction. Such a participant does not need to be informed about the outcome of the transaction, since the fate of the participant has no affect on the transaction. This read-only participant can be omitted from the second phase of the commit protocol.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transaction_outcomes"/>Transaction Outcomes</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_transaction_outcomes"/>About Transaction Outcomes</h2></div></div></div><p>
					There are three possible outcomes for a transaction.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Commit</span></dt><dd>
								If every transaction participant can commit, the transaction coordinator directs them to do so. See <a class="link" href="java_transaction_api.html#about_transaction_commit" title="About Transaction Commit">About Transaction Commit</a> for more information.
							</dd><dt><span class="term">Rollback</span></dt><dd>
								If any transaction participant cannot commit, or if the transaction coordinator cannot direct participants to commit, the transaction is rolled back. See <a class="link" href="java_transaction_api.html#about_transaction_roll_back" title="About Transaction Rollback">About Transaction Rollback</a> for more information.
							</dd><dt><span class="term">Heuristic outcome</span></dt><dd>
								If some transaction participants commit and others roll back, it is termed a heuristic outcome. Heuristic outcomes require human intervention. See <a class="link" href="java_transaction_api.html#about_heuristic_outcomes" title="About Heuristic Outcomes">About Heuristic Outcomes</a> for more information.
							</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_transaction_commit"/>About Transaction Commit</h2></div></div></div><p>
					When a transaction participant commits, it makes its new state durable. The new state is created by the participant doing the work involved in the transaction. The most common example is when a transaction member writes records to a database.
				</p><p>
					After a commit, information about the transaction is removed from the transaction coordinator, and the newly-written state is now the durable state.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_transaction_roll_back"/>About Transaction Rollback</h2></div></div></div><p>
					A transaction participant rolls back by restoring its state to reflect the state before the transaction began. After a rollback, the state is the same as if the transaction had never been started.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_heuristic_outcomes"/>About Heuristic Outcomes</h2></div></div></div><p>
					A heuristic outcome, or non-atomic outcome, is a situation where the decisions of the participants in a transaction differ from that of the transaction manager. Heuristic outcomes can cause loss of integrity to the system, and usually require human intervention to resolve them. Do not write code which relies on them.
				</p><p>
					Heuristic outcomes typically occur during the second phase of the 2-phase commit (2PC) protocol. In rare cases, this outcome might occur in a 1PC. They are often caused by failures to the underlying hardware or communications subsystems of the underlying servers.
				</p><p>
					Heuristic outcomes are possible due to timeouts in various subsystems or resources even with transaction manager and full crash recovery. In any system that requires some form of distributed agreement, situations can arise where some parts of the system diverge in terms of the global outcome.
				</p><p>
					There are four different types of heuristic outcomes:
				</p><h4><a id="heuristic_rollback"/>Heuristic rollback</h4><p>
					The commit operation was not able to commit the resources but all of the participants were able to be rolled back and so an atomic outcome was still achieved.
				</p><h4><a id="heuristic_commit"/>Heuristic commit</h4><p>
					An attempted rollback operation failed because all of the participants unilaterally committed. This can happen if, for example, the coordinator is able to successfully prepare the transaction but then decides to roll it back because of a failure on its side, such as a failure to update its log. In the interim, the participants might decide to commit.
				</p><h4><a id="heuristic_mixed"/>Heuristic mixed</h4><p>
					Some participants committed and others rolled back.
				</p><h4><a id="heuristic_hazard"/>Heuristic hazard</h4><p>
					The disposition of some of the updates is unknown. For those that are known, they have either all been committed or all rolled back.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="java_transaction_api.html#about_the_2_phase_commit_protocol" title="About the 2-Phase Commit Protocol">About the 2-Phase Commit Protocol</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jboss_transactions_errors_and_exceptions"/>JBoss Transactions Errors and Exceptions</h2></div></div></div><p>
					For details about exceptions thrown by methods of the <code class="literal">UserTransaction</code> class, see the <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/transaction/UserTransaction.html"><code class="literal">UserTransaction</code></a> API Javadoc.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="overview_of_the_transaction_lifecycle"/>Overview of the Transaction Lifecycle</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transaction_lifecycle"/>Transaction Lifecycle</h2></div></div></div><p>
					See <a class="link" href="java_transaction_api.html#about_java_transactions_api_jta" title="About Java Transaction API (JTA)">About Java Transaction API (JTA)</a> for more information on Java Transaction API (JTA).
				</p><p>
					When a resource asks to participate in a transaction, a chain of events is set in motion. The Transaction Manager (TM) is a process that lives within the application server and manages transactions. Transaction participants are objects which participate in a transaction. Resources are datasources, JMS connection factories, or other JCA connections.
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							The application starts a new transaction.
						</p><p class="simpara">
							To begin a transaction, the application obtains an instance of class <code class="literal">UserTransaction</code> from JNDI or, if it is an EJB, from an annotation. The <code class="literal">UserTransaction</code> interface includes methods for beginning, committing, and rolling back top-level transactions. Newly created transactions are automatically associated with their invoking thread. Nested transactions are not supported in JTA, so all transactions are top-level transactions.
						</p><p class="simpara">
							An EJB starts a transaction when the <code class="literal">UserTransaction.begin()</code> method is called. The default behavior of this transaction could be affected by use of the <code class="literal">TransactionAttribute</code> annotation or the <code class="literal">ejb.xml</code> descriptor. Any resource that is used after that point is associated with the transaction. If more than one resource is enlisted, the transaction becomes an XA transaction, and participates in the two-phase commit protocol at commit time.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								By default, transactions are driven by application containers in EJBs. This is called <span class="emphasis"><em>Container Managed Transaction (CMT)</em></span>. To make the transaction user driven, change the <code class="literal">Transaction Management</code> to <span class="emphasis"><em>Bean Managed Transaction (BMT)</em></span>. In BMT, the <code class="literal">UserTransaction</code> object is available for the user to manage the transaction.
							</p></div></li><li class="listitem"><p class="simpara">
							The application modifies its state.
						</p><p class="simpara">
							In the next step, the application performs its work and makes changes to its state, only on enlisted resources.
						</p></li><li class="listitem"><p class="simpara">
							The application decides to commit or roll back.
						</p><p class="simpara">
							When the application has finished changing its state, it decides whether to commit or roll back. It calls the appropriate method, either <code class="literal">UserTransaction.commit()</code> or <code class="literal">UserTransaction.rollback()</code>. For a CMT, this process is driven automatically, whereas for a BMT, a method commit or rollback of the <code class="literal">UserTransaction</code> has to be explicitly called.
						</p></li><li class="listitem"><p class="simpara">
							The TM removes the transaction from its records.
						</p><p class="simpara">
							After the commit or rollback completes, the TM cleans up its records and removes information about the transaction from the transaction log.
						</p></li></ol></div><div class="title"><strong>Failure Recovery</strong></div><p>
						If a resource, transaction participant, or the application server crashes or become unavailable, the <code class="literal">Transaction Manager</code> handles recovery when the underlying failure is resolved and the resource is available again. This process happens automatically. For more information, see <a class="link" href="java_transaction_api.html#about_xa_recovery" title="About XA Recovery">XA Recovery</a>.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transactions_configuration_overview"/>Transaction Subsystem Configuration</h1></div></div></div><p>
				The <code class="literal">transactions</code> subsystem allows you to configure transaction manager options such as statistics, timeout values, and transaction logging. You can also manage transactions and view transaction statistics.
			</p><p>
				For more information, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/configuration_guide/#configuring_transactions">Configuring Transactions</a> in the JBoss EAP <span class="emphasis"><em>Configuration Guide</em></span>.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transactions_usage_in_practice"/>Transactions Usage In Practice</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactions_usage_overview"/>Transactions Usage Overview</h2></div></div></div><p>
					The following procedures are useful when you need to use transactions in your application.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							<a class="link" href="java_transaction_api.html#control_transactions" title="Control Transactions">Control Transactions</a>
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<a class="link" href="java_transaction_api.html#begin_a_transaction" title="Begin a Transaction">Begin a Transaction</a>
								</li><li class="listitem">
									<a class="link" href="java_transaction_api.html#commit_a_transaction" title="Commit a Transaction">Commit a Transaction</a>
								</li><li class="listitem">
									<a class="link" href="java_transaction_api.html#roll_back_a_transaction" title="Roll Back a Transaction">Roll Back a Transaction</a>
								</li></ul></div></li><li class="listitem">
							<a class="link" href="java_transaction_api.html#handle_a_heuristic_outcome_in_a_transaction" title="Handle a Heuristic Outcome in a Transaction">Handle a Heuristic Outcome in a Transaction</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#handle_transaction_errors" title="Handle Transaction Errors">Handle Transaction Errors</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#transaction_references" title="Transaction References">Transaction References</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="control_transactions"/>Control Transactions</h2></div></div></div><div class="title"><strong>Introduction</strong></div><p>
						This list of procedures outlines the different ways to control transactions in your applications which use JTA APIs.
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="java_transaction_api.html#begin_a_transaction" title="Begin a Transaction">Begin a Transaction</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#commit_a_transaction" title="Commit a Transaction">Commit a Transaction</a>
						</li><li class="listitem">
							<a class="link" href="java_transaction_api.html#roll_back_a_transaction" title="Roll Back a Transaction">Roll Back a Transaction</a>
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="begin_a_transaction"/>Begin a Transaction</h3></div></div></div><p>
						This procedure shows how to begin a new transaction. The API is the same whether you run the Transaction Manager (TM) configured with JTA or JTS.
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								Get an instance of <code class="literal">UserTransaction</code>.
							</p><p class="simpara">
								You can get the instance using JNDI, injection, or an EJB’s context if the EJB uses bean-managed transactions by means of a <code class="literal">@TransactionManagement(TransactionManagementType.BEAN)</code> annotation.
							</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
										Get the instance using JNDI.
									</p><pre class="programlisting">new InitialContext().lookup("java:comp/UserTransaction")</pre></li><li class="listitem"><p class="simpara">
										Get the instance using injection.
									</p><pre class="programlisting">@Resource UserTransaction userTransaction;</pre></li><li class="listitem"><p class="simpara">
										Get the instance using the EJB context.
									</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
												In a stateless/stateful bean:
											</p><pre class="programlisting">@Resource SessionContext ctx;
ctx.getUserTransaction();</pre></li><li class="listitem"><p class="simpara">
												In a message-driven bean:
											</p><pre class="programlisting">@Resource MessageDrivenContext ctx;
ctx.getUserTransaction()</pre></li></ul></div></li></ul></div></li><li class="listitem"><p class="simpara">
								Call <code class="literal">UserTransaction.begin()</code> after you connect to your datasource.
							</p><pre class="programlisting">try {
    System.out.println("\nCreating connection to database: "+url);
    stmt = conn.createStatement();  // non-tx statement
    try {
        System.out.println("Starting top-level transaction.");
        userTransaction.begin();
        stmtx = conn.createStatement(); // will be a tx-statement
        ...
    }
}</pre></li></ol></div><div class="title"><strong>Result</strong></div><p>
							The transaction begins. All uses of your datasource are transactional until you commit or roll back the transaction.
						</p><p>
						For a full example, see <a class="link" href="java_transaction_api.html#jta_transaction_example" title="JTA Transaction Example">JTA Transaction Example</a>.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							One of the benefits of EJBs (either used with CMT or BMT) is that the container manages all the internals of the transactional processing, that is, you are free from taking care of transaction being part of XA transaction or transaction distribution amongst JBoss EAP containers.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="nested_transactions"/>Nested Transactions</h4></div></div></div><p>
							Nested transactions allow an application to create a transaction that is embedded in an existing transaction. In this model, multiple subtransactions can be embedded recursively in a transaction. Subtransactions can be committed or rolled back without committing or rolling back the parent transaction. However, the results of a commit operation are contingent upon the commitment of all the transaction’s ancestors.
						</p><p>
							For implementation specific information, see the <a class="link" href="http://narayana.io//docs/project/index.html">Narayana Project Documentation</a>.
						</p><p>
							Nested transactions are available only when used with the JTS specification. Nested transactions are not a supported feature of JBoss EAP application server. In addition, many database vendors do not support nested transactions, so consult your database vendor before you add nested transactions to your application.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="commit_a_transaction"/>Commit a Transaction</h3></div></div></div><p>
						This procedure shows how to commit a transaction using the Java Transaction API (JTA).
					</p><div class="title"><strong>Prerequisites</strong></div><p>
							You must begin a transaction before you can commit it. For information on how to begin a transaction, see <a class="link" href="java_transaction_api.html#begin_a_transaction" title="Begin a Transaction">Begin a Transaction</a>.
						</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								Call the <code class="literal">commit()</code> method on the <code class="literal">UserTransaction</code>.
							</p><p class="simpara">
								When you call the commit() method on the <code class="literal">UserTransaction</code>, the TM attempts to commit the transaction.
							</p><pre class="programlisting">@Inject
private UserTransaction userTransaction;

public void updateTable(String key, String value) {
    EntityManager entityManager = entityManagerFactory.createEntityManager();
    try {
        userTransaction.begin();
        &lt;!-- Perform some data manipulation using entityManager --&gt;
        ...
        // Commit the transaction
        userTransaction.commit();
    } catch (Exception ex) {
        &lt;!-- Log message or notify Web page --&gt;
        ...
        try {
            userTransaction.rollback();
        } catch (SystemException se) {
            throw new RuntimeException(se);
        }
        throw new RuntimeException(ex);
    } finally {
        entityManager.close();
    }
}</pre></li><li class="listitem"><p class="simpara">
								If you use Container Managed Transactions (CMT), you do not need to manually commit.
							</p><p class="simpara">
								If you configure your bean to use Container Managed Transactions, the container will manage the transaction lifecycle for you based on annotations you configure in the code.
							</p><pre class="programlisting">@PersistenceContext
private EntityManager em;

@TransactionAttribute(TransactionAttributeType.REQUIRED)
public void updateTable(String key, String value)
  &lt;!-- Perform some data manipulation using entityManager --&gt;
  ...
}</pre></li></ol></div><div class="title"><strong>Result</strong></div><p>
							Your datasource commits and your transaction ends, or an exception is thrown.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							For a full example, see <a class="link" href="java_transaction_api.html#jta_transaction_example" title="JTA Transaction Example">JTA Transaction Example</a>.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="roll_back_a_transaction"/>Roll Back a Transaction</h3></div></div></div><p>
						This procedure shows how to roll back a transaction using the Java Transaction API (JTA).
					</p><div class="title"><strong>Prerequisites</strong></div><p>
							You must begin a transaction before you can roll it back. For information on how to begin a transaction, see <a class="link" href="java_transaction_api.html#begin_a_transaction" title="Begin a Transaction">Begin a Transaction</a>.
						</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
								Call the <code class="literal">rollback()</code> method on the <code class="literal">UserTransaction</code>.
							</p><p class="simpara">
								When you call the <code class="literal">rollback()</code> method on the <code class="literal">UserTransaction</code>, the TM attempts to roll back the transaction and return the data to its previous state.
							</p><pre class="programlisting">@Inject
private UserTransaction userTransaction;

public void updateTable(String key, String value)
    EntityManager entityManager = entityManagerFactory.createEntityManager();
    try {
        userTransaction.begin():
        &lt;!-- Perform some data manipulation using entityManager --&gt;
          ...
          // Commit the transaction
        userTransaction.commit();
    } catch (Exception ex) {
        &lt;!-- Log message or notify Web page --&gt;
        ...
        try {
            userTransaction.rollback();
        } catch (SystemException se) {
            throw new RuntimeException(se);
        }
        throw new RuntimeException(e);
    } finally {
        entityManager.close();
    }
}</pre></li><li class="listitem"><p class="simpara">
								If you use Container Managed Transactions (CMT), you do not need to manually roll back the transaction.
							</p><p class="simpara">
								If you configure your bean to use Container Managed Transactions, the container will manage the transaction lifecycle for you based on annotations you configure in the code.
							</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Rollback for CMT occurs if RuntimeException is thrown. You can also explicitly call the setRollbackOnly method to gain the rollback. Or, use the @ApplicationException(rollback=true) for application exception to rollback.
						</p></div><div class="title"><strong>Result</strong></div><p>
							Your transaction is rolled back by the TM.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							For a full example, see <a class="link" href="java_transaction_api.html#jta_transaction_example" title="JTA Transaction Example">JTA Transaction Example</a>.
						</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="handle_a_heuristic_outcome_in_a_transaction"/>Handle a Heuristic Outcome in a Transaction</h2></div></div></div><p>
					Heuristic transaction outcomes are uncommon and usually have exceptional causes. The word heuristic means "by hand", and that is the way that these outcomes usually have to be handled. See <a class="link" href="java_transaction_api.html#about_heuristic_outcomes" title="About Heuristic Outcomes">About Heuristic Outcomes</a> for more information about heuristic transaction outcomes.
				</p><p>
					This procedure shows how to handle a heuristic outcome of a transaction using the Java Transaction API (JTA).
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							The cause of a heuristic outcome in a transaction is that a resource manager promised it could commit or rollback, and then failed to fulfill the promise. This could be due to a problem with a third-party component, the integration layer between the third-party component and JBoss EAP, or JBoss EAP itself.
						</p><p class="simpara">
							By far, the most common two causes of heuristic errors are transient failures in the environment and coding errors dealing with resource managers.
						</p></li><li class="listitem"><p class="simpara">
							Usually, if there is a transient failure in your environment, you will know about it before you find out about the heuristic error. This could be due to a network outage, hardware failure, database failure, power outage, or a host of other things.
						</p><p class="simpara">
							If you come across a heuristic outcome in a test environment during stress testing, it implies weaknesses in your test environment.
						</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
								JBoss EAP automatically recovers transactions that were in a non-heuristic state at the time of failure, but it does not attempt to recover the heuristic transactions.
							</p></div></li><li class="listitem"><p class="simpara">
							If you have no obvious failure in your environment, or if the heuristic outcome is easily reproducible, it is probably due to a coding error. You must contact the third-party vendors to find out if a solution is available.
						</p><p class="simpara">
							If you suspect the problem is in the transaction manager of JBoss EAP itself, you must raise a support ticket.
						</p></li><li class="listitem">
							You can attempt to recover the transaction manually using the management CLI. For more information, see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/managing_transactions_on_jboss_eap/#recover_a_transaction">Recovering a Transaction Participant</a> section of <span class="emphasis"><em>Managing Transactions on JBoss EAP</em></span>.
						</li><li class="listitem"><p class="simpara">
							The process of resolving the transaction outcome manually is dependent on the exact circumstance of the failure. Perform the following steps, as applicable to your environment:
						</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
									Identify which resource managers were involved.
								</li><li class="listitem">
									Examine the state of the transaction manager and the resource managers.
								</li><li class="listitem">
									Manually force log cleanup and data reconciliation in one or more of the involved components.
								</li></ol></div></li><li class="listitem"><p class="simpara">
							In a test environment, or if you do not care about the integrity of the data, deleting the transaction logs and restarting JBoss EAP gets rid of the heuristic outcome. By default, the transaction logs are located in the <code class="literal"><span class="emphasis"><em>EAP_HOME</em></span>/standalone/data/tx-object-store/</code> directory for a standalone server, or the <code class="literal"><span class="emphasis"><em>EAP_HOME</em></span>/domain/servers/<span class="emphasis"><em>SERVER_NAME</em></span>/data/tx-object-store/</code> directory in a managed domain. In the case of a managed domain, <span class="emphasis"><em>SERVER_NAME</em></span> refers to the name of the individual server participating in a server group.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The location of the transaction log also depends on the object store in use and the values set for the <code class="literal">object-store-relative-to</code> and <code class="literal">object-store-path</code> parameters. For file system logs, such as a standard shadow and Apache ActiveMQ Artemis logs, the default directory location is used, but when using a JDBC object store, the transaction logs are stored in a database.
							</p></div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jta_transaction_error_handling"/>JTA Transaction Error Handling</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="handle_transaction_errors"/>Handle Transaction Errors</h3></div></div></div><p>
						Transaction errors are challenging to solve because they are often dependent on timing. Here are some common errors and ideas for troubleshooting them.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							These guidelines do not apply to heuristic errors. If you experience heuristic errors, refer to <a class="link" href="java_transaction_api.html#handle_a_heuristic_outcome_in_a_transaction" title="Handle a Heuristic Outcome in a Transaction">Handle a Heuristic Outcome in a Transaction</a> and contact Red Hat Global Support Services for assistance.
						</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">The transaction timed out but the business logic thread did not notice</span></dt><dd><p class="simpara">
									This type of error often manifests itself when Hibernate is unable to obtain a database connection for lazy loading. If it happens frequently, you can lengthen the timeout value. See the JBoss EAP <span class="emphasis"><em>Configuration Guide</em></span> for information on <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/configuration_guide/#configuring_the_transaction_manager">configuring the transaction manager</a>.
								</p><p class="simpara">
									If that is not feasible, you might be able to tune your external environment to perform more quickly, or restructure your code to be more efficient. Contact Red Hat Global Support Services if you still have trouble with timeouts.
								</p></dd><dt><span class="term">The transaction is already running on a thread, or you receive a <code class="literal">NotSupportedException</code> exception</span></dt><dd><p class="simpara">
									The <code class="literal">NotSupportedException</code> exception usually indicates that you attempted to nest a JTA transaction, and this is not supported. If you were not attempting to nest a transaction, it is likely that another transaction was started in a thread pool task, but finished the task without suspending or ending the transaction.
								</p><p class="simpara">
									Applications typically use <code class="literal">UserTransaction</code>, which handles this automatically. If so, there might be a problem with a framework.
								</p><p class="simpara">
									If your code does use <code class="literal">TransactionManager</code> or <code class="literal">Transaction</code> methods directly, be aware of the following behavior when committing or rolling back a transaction. If your code uses <code class="literal">TransactionManager</code> methods to control your transactions, committing or rolling back a transaction disassociates the transaction from the current thread. However, if your code uses <code class="literal">Transaction</code> methods, the transaction might not be associated with the running thread, and you need to disassociate it from its threads manually, before returning it to the thread pool.
								</p></dd><dt><span class="term">You are unable to enlist a second local resource</span></dt><dd>
									This error happens if you try to enlist a second non-XA resource into a transaction. If you need multiple resources in a transaction, they must be XA.
								</dd></dl></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="transaction_references"/>Transaction References</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jta_transaction_example"/>JTA Transaction Example</h2></div></div></div><p>
					This example illustrates how to begin, commit, and roll back a JTA transaction. You need to adjust the connection and datasource parameters to suit your environment, and set up two test tables in your database.
				</p><pre class="programlisting">public class JDBCExample {
    public static void main (String[] args) {
        Context ctx = new InitialContext();
        // Change these two lines to suit your environment.
        DataSource ds = (DataSource)ctx.lookup("jdbc/ExampleDS");
        Connection conn = ds.getConnection("testuser", "testpwd");
        Statement stmt = null; // Non-transactional statement
        Statement stmtx = null; // Transactional statement
        Properties dbProperties = new Properties();

        // Get a UserTransaction
        UserTransaction txn = new InitialContext().lookup("java:comp/UserTransaction");

        try {
            stmt = conn.createStatement();  // non-tx statement

            // Check the database connection.
            try {
                stmt.executeUpdate("DROP TABLE test_table");
                stmt.executeUpdate("DROP TABLE test_table2");
            }
            catch (Exception e) {
                throw new RuntimeException(e);
                // assume not in database.
            }

            try {
                stmt.executeUpdate("CREATE TABLE test_table (a INTEGER,b INTEGER)");
                stmt.executeUpdate("CREATE TABLE test_table2 (a INTEGER,b INTEGER)");
            }
            catch (Exception e) {
                throw new RuntimeException(e);
            }

            try {
                System.out.println("Starting top-level transaction.");

                txn.begin();

                stmtx = conn.createStatement(); // will be a tx-statement

                // First, we try to roll back changes

                System.out.println("\nAdding entries to table 1.");

                stmtx.executeUpdate("INSERT INTO test_table (a, b) VALUES (1,2)");

                ResultSet res1 = null;

                System.out.println("\nInspecting table 1.");

                res1 = stmtx.executeQuery("SELECT * FROM test_table");

                while (res1.next()) {
                    System.out.println("Column 1: "+res1.getInt(1));
                    System.out.println("Column 2: "+res1.getInt(2));
                }
                System.out.println("\nAdding entries to table 2.");

                stmtx.executeUpdate("INSERT INTO test_table2 (a, b) VALUES (3,4)");
                res1 = stmtx.executeQuery("SELECT * FROM test_table2");

                System.out.println("\nInspecting table 2.");

                while (res1.next()) {
                    System.out.println("Column 1: "+res1.getInt(1));
                    System.out.println("Column 2: "+res1.getInt(2));
                }

                System.out.print("\nNow attempting to rollback changes.");

                txn.rollback();

                // Next, we try to commit changes
                txn.begin();
                stmtx = conn.createStatement();
                System.out.println("\nAdding entries to table 1.");
                stmtx.executeUpdate("INSERT INTO test_table (a, b) VALUES (1,2)");
                ResultSet res2 = null;

                System.out.println("\nNow checking state of table 1.");

                res2 = stmtx.executeQuery("SELECT * FROM test_table");

                while (res2.next()) {
                    System.out.println("Column 1: "+res2.getInt(1));
                    System.out.println("Column 2: "+res2.getInt(2));
                }

                System.out.println("\nNow checking state of table 2.");

                stmtx = conn.createStatement();

                res2 = stmtx.executeQuery("SELECT * FROM test_table2");

                while (res2.next()) {
                    System.out.println("Column 1: "+res2.getInt(1));
                    System.out.println("Column 2: "+res2.getInt(2));
                }

                txn.commit();
            }
            catch (Exception ex) {
                throw new RuntimeException(ex);

            }
        }
        catch (Exception sysEx) {
            sysEx.printStackTrace();
            System.exit(0);
        }
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="api_documentation_for_jboss_transactions_jta"/>Transaction API Documentation</h2></div></div></div><p>
					The transaction JTA API documentation is available as Javadoc at the following location:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							UserTransaction - <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/transaction/UserTransaction.html">http://docs.oracle.com/javaee/7/api/javax/transaction/UserTransaction.html</a>
						</li></ul></div><p>
					If you use Red Hat Developer Studio to develop your applications, the API documentation is included in the <span class="strong"><strong>Help</strong></span> menu.
				</p></div></div></div></body></html>