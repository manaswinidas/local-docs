<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. Contexts and Dependency Injection (CDI)</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="contexts_and_dependency_injection"/>Chapter 7. Contexts and Dependency Injection (CDI)</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_cdi"/>Introduction to CDI</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_contexts_and_dependency_injection_cdi"/>About Contexts and Dependency Injection (CDI)</h2></div></div></div><p>
					Contexts and Dependency Injection (CDI) 2.0 is a specification designed to enable Enterprise Java Beans (EJB) 3 components to be used as Java Server Faces (JSF) managed beans. CDI unifies the two component models and enables a considerable simplification to the programming model for web-based applications in Java. Details about CDI 2.0 can be found in <a class="link" href="http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html">JSR 365: Contexts and Dependency Injection for Java 2.0</a>.
				</p><p>
					JBoss EAP includes Weld, which is the reference implementation of JSR-365.
				</p><h4><a id="benefits_of_cdi"/>Benefits of CDI</h4><p>
					The benefits of CDI include:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Simplifying and shrinking your code base by replacing big chunks of code with annotations.
						</li><li class="listitem">
							Flexibility, allowing you to disable and enable injections and events, use alternative beans, and inject non-CDI objects easily.
						</li><li class="listitem">
							Optionally, allowing you to include a <code class="literal">beans.xml</code> file in your <code class="literal">META-INF/</code> or <code class="literal">WEB-INF/</code> directory if you need to customize the configuration to differ from the default. The file can be empty.
						</li><li class="listitem">
							Simplifying packaging and deployments and reducing the amount of XML you need to add to your deployments.
						</li><li class="listitem">
							Providing lifecycle management via contexts. You can tie injections to requests, sessions, conversations, or custom contexts.
						</li><li class="listitem">
							Providing type-safe dependency injection, which is safer and easier to debug than string-based injection.
						</li><li class="listitem">
							Decoupling interceptors from beans.
						</li><li class="listitem">
							Providing complex event notification.
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="Relationship_between_weld_seam_2_and_javaserver_faces"/>Relationship Between Weld, Seam 2, and JavaServer Faces</h2></div></div></div><p>
					Weld is the reference implementation of CDI, which is defined in <a class="link" href="https://www.jcp.org/en/jsr/detail?id=346">JSR 346: Contexts and Dependency Injection for Java™ EE 1.1</a>. Weld was inspired by Seam 2 and other dependency injection frameworks, and is included in JBoss EAP.
				</p><p>
					The goal of Seam 2 was to unify Enterprise Java Beans and JavaServer Faces managed beans.
				</p><p>
					JavaServer Faces 2.2 implements <a class="link" href="https://www.jcp.org/en/jsr/detail?id=344">JSR-344: JavaServer™ Faces 2.2</a>. It is an API for building server-side user interfaces.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="use_cdi_to_develop_application"/>Use CDI to Develop an Application</h1></div></div></div><p>
				Contexts and Dependency Injection (CDI) gives you tremendous flexibility in developing applications, reusing code, adapting your code at deployment or runtime, and unit testing. JBoss EAP includes Weld, the reference implementation of CDI. These tasks show you how to use CDI in your enterprise applications.
			</p><p>
				Weld comes with a special mode for application development. When enabled, certain built-in tools, which facilitate the development of CDI applications, are available.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					The development mode should not be used in production as it can have a negative impact on the performance of the application. Make sure to disable the development mode before deploying to production.
				</p></div><div class="title"><strong>Enabling the Development Mode for a Web Application:</strong></div><p>
					For a web application, set the servlet initialization parameter <code class="literal">org.jboss.weld.development</code> to <code class="literal">true</code>:
				</p><pre class="programlisting">&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;org.jboss.weld.development&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;</pre><div class="title"><strong>Enabling Development Mode for JBoss EAP Using the Management CLI:</strong></div><p>
					It is possible to enable the Weld development mode globally for all the applications deployed by setting <code class="literal">development-mode</code> attribute to <code class="literal">true</code>:
				</p><pre class="screen">/subsystem=weld:write-attribute(name=development-mode,value=true)</pre><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="default_bean_discovery_mode"/>Default Bean Discovery Mode</h2></div></div></div><p>
					The default bean discovery mode for a bean archive is <code class="literal">annotated</code>. Such a bean archive is said to be an <code class="literal">implicit bean archive</code>.
				</p><p>
					If the bean discovery mode is <code class="literal">annotated</code>, then:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Bean classes that do not have <code class="literal">bean defining annotation</code> and are not bean classes of sessions beans are not discovered.
						</li><li class="listitem">
							Producer methods that are not on a session bean and whose bean class does not have a bean defining annotation are not discovered.
						</li><li class="listitem">
							Producer fields that are not on a session bean and whose bean class does not have a bean defining annotation are not discovered.
						</li><li class="listitem">
							Disposer methods that are not on a session bean and whose bean class does not have a bean defining annotation are not discovered.
						</li><li class="listitem">
							Observer methods that are not on a session bean and whose bean class does not have a bean defining annotation are not discovered.
						</li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
						All examples in the CDI section are valid only when you have a discovery mode set to <code class="literal">all</code>.
					</p></div><h4><a id="bean_defining_annotations"/>Bean Defining Annotations</h4><p>
					A bean class can have a <code class="literal">bean defining annotation</code>, allowing it to be placed anywhere in an application, as defined in bean archives. A bean class with a bean defining annotation is said to be an implicit bean.
				</p><p>
					The set of bean defining annotations contains:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">@ApplicationScoped</code>, <code class="literal">@SessionScoped</code>, <code class="literal">@ConversationScoped</code> and <code class="literal">@RequestScoped</code> annotations.
						</li><li class="listitem">
							All other normal scope types.
						</li><li class="listitem">
							<code class="literal">@Interceptor</code> and <code class="literal">@Decorator</code> annotations.
						</li><li class="listitem">
							All stereotype annotations, i.e. annotations annotated with <code class="literal">@Stereotype</code>.
						</li><li class="listitem">
							The <code class="literal">@Dependent</code> scope annotation.
						</li></ul></div><p>
					If one of these annotations is declared on a bean class, then the bean class is said to have a bean defining annotation.
				</p><div class="title"><strong>Example: Bean Defining Annotation</strong></div><p>
						
</p><pre class="programlisting">@Dependent
public class BookShop
        extends Business
        implements Shop&lt;Book&gt; {
    ...
}</pre><p>

					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						To ensure compatibility with other <a class="link" href="https://jcp.org/en/jsr/detail?id=330">JSR-330</a> implementations, all pseudo-scope annotations, except <code class="literal">@Dependent</code>, are not bean defining annotations. However, a stereotype annotation, including a pseudo-scope annotation, is a bean defining annotation.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="exclude_beans_from_the_scanning_proces"/>Exclude Beans From the Scanning Process</h2></div></div></div><p>
					Exclude filters are defined by <code class="literal">&lt;exclude&gt;</code> elements in the <code class="literal">beans.xml</code> file for the bean archive as children of the <code class="literal">&lt;scan&gt;</code> element. By default an exclude filter is active. The exclude filter becomes inactive, if its definition contains:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							A child element named <code class="literal">&lt;if-class-available&gt;</code> with a <code class="literal">name</code> attribute, and the class loader for the bean archive can not load a class for that name, or
						</li><li class="listitem">
							A child element named <code class="literal">&lt;if-class-not-available&gt;</code> with a <code class="literal">name</code> attribute, and the class loader for the bean archive can load a class for that name, or
						</li><li class="listitem">
							A child element named <code class="literal">&lt;if-system-property&gt;</code> with a <code class="literal">name</code> attribute, and there is no system property defined for that name, or
						</li><li class="listitem">
							A child element named <code class="literal">&lt;if-system-property&gt;</code> with a <code class="literal">name</code> attribute and a value attribute, and there is no system property defined for that name with that value.
						</li></ul></div><p>
					The type is excluded from discovery, if the filter is active, and:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The fully qualified name of the type being discovered matches the value of the name attribute of the exclude filter, or
						</li><li class="listitem">
							The package name of the type being discovered matches the value of the name attribute with a suffix ".*" of the exclude filter, or
						</li><li class="listitem">
							The package name of the type being discovered starts with the value of the name attribute with a suffix ".**" of the exclude filter
						</li></ul></div><div class="example"><a id="idm139905036471456"/><p class="title"><strong>Example 7.1. Example: <code class="literal">beans.xml</code> File</strong></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://xmlns.jcp.org/xml/ns/javaee"&gt;

    &lt;scan&gt;
        &lt;exclude name="com.acme.rest.*" /&gt; <a id="CO1-1"/><span><img src="images/callouts/1.png" alt="1"/></span>

        &lt;exclude name="com.acme.faces.**"&gt; <a id="CO1-2"/><span><img src="images/callouts/2.png" alt="2"/></span>
            &lt;if-class-not-available name="javax.faces.context.FacesContext"/&gt;
        &lt;/exclude&gt;

        &lt;exclude name="com.acme.verbose.*"&gt; <a id="CO1-3"/><span><img src="images/callouts/3.png" alt="3"/></span>
            &lt;if-system-property name="verbosity" value="low"/&gt;
        &lt;/exclude&gt;

        &lt;exclude name="com.acme.ejb.**"&gt; <a id="CO1-4"/><span><img src="images/callouts/4.png" alt="4"/></span>
            &lt;if-class-available name="javax.enterprise.inject.Model"/&gt;
            &lt;if-system-property name="exclude-ejbs"/&gt;
        &lt;/exclude&gt;
    &lt;/scan&gt;

&lt;/beans&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td valign="top" align="left"><p><a href="#CO1-1"><span><img src="images/callouts/1.png" alt="1"/></span></a> </p></td><td valign="top" align="left"><p>
								The first exclude filter will exclude all classes in <code class="literal">com.acme.rest</code> package.
							</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-2"><span><img src="images/callouts/2.png" alt="2"/></span></a> </p></td><td valign="top" align="left"><p>
								The second exclude filter will exclude all classes in the <code class="literal">com.acme.faces</code> package, and any subpackages, but only if JSF is not available.
							</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-3"><span><img src="images/callouts/3.png" alt="3"/></span></a> </p></td><td valign="top" align="left"><p>
								The third exclude filter will exclude all classes in the <code class="literal">com.acme.verbose</code> package if the system property <code class="literal">verbosity</code> has the value <code class="literal">low</code>.
							</p></td></tr><tr><td valign="top" align="left"><p><a href="#CO1-4"><span><img src="images/callouts/4.png" alt="4"/></span></a> </p></td><td valign="top" align="left"><p>
								The fourth exclude filter will exclude all classes in the <code class="literal">com.acme.ejb</code> package, and any subpackages, if the system property <code class="literal">exclude-ejbs</code> is set with any value and if at the same time, the <code class="literal">javax.enterprise.inject.Model</code> class is also available to the classloader.
							</p></td></tr></table></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						It is safe to annotate Java EE components with <code class="literal">@Vetoed</code> to prevent them being considered beans. An event is not fired for any type annotated with <code class="literal">@Vetoed</code>, or in a package annotated with <code class="literal">@Vetoed</code>. For more information, see <a class="link" href="contexts_and_dependency_injection.html#vetoed" title="@Vetoed"><code class="literal">@Vetoed</code></a>.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="use_an_injection_to_extend_an_implementation"/>Use an Injection to Extend an Implementation</h2></div></div></div><p>
					You can use an injection to add or change a feature of your existing code.
				</p><p>
					The following example adds a translation ability to an existing class, and assumes you already have a <code class="literal">Welcome</code> class, which has a method <code class="literal">buildPhrase</code>. The <code class="literal">buildPhrase</code> method takes as an argument the name of a city, and outputs a phrase like "Welcome to Boston!".
				</p><p>
					This example injects a hypothetical <code class="literal">Translator</code> object into the <code class="literal">Welcome</code> class. The <code class="literal">Translator</code> object can be an EJB stateless bean or another type of bean, which can translate sentences from one language to another. In this instance, the <code class="literal">Translator</code> is used to translate the entire greeting, without modifying the original <code class="literal">Welcome</code> class. The <code class="literal">Translator</code> is injected before the <code class="literal">buildPhrase</code> method is called.
				</p><div class="title"><strong>Example: Inject a Translator Bean into the <code class="literal">Welcome</code> Class</strong></div><p>
						
</p><pre class="programlisting">public class TranslatingWelcome extends Welcome {

    @Inject Translator translator;

    public String buildPhrase(String city) {
        return translator.translate("Welcome to " + city + "!");
    }
    ...
}</pre><p>

					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ambiguous_or_unsatisfied_dependencies"/>Ambiguous or Unsatisfied Dependencies</h1></div></div></div><p>
				Ambiguous dependencies exist when the container is unable to resolve an injection to exactly one bean.
			</p><p>
				Unsatisfied dependencies exist when the container is unable to resolve an injection to any bean at all.
			</p><p>
				The container takes the following steps to try to resolve dependencies:
			</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
						It resolves the qualifier annotations on all beans that implement the bean type of an injection point.
					</li><li class="listitem">
						It filters out disabled beans. Disabled beans are <code class="literal">@Alternative</code> beans which are not explicitly enabled.
					</li></ol></div><p>
				In the event of an ambiguous or unsatisfied dependency, the container aborts deployment and throws an exception.
			</p><p>
				To fix an ambiguous dependency, see <a class="link" href="contexts_and_dependency_injection.html#use_a_qualifier_to_resolve_an_ambiguous_injection" title="Use a Qualifier to Resolve an Ambiguous Injection">Use a Qualifier to Resolve an Ambiguous Injection</a>.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_qualifiers"/>Qualifiers</h2></div></div></div><p>
					Qualifiers are annotations used to avoid ambiguous dependencies when the container can resolve multiple beans, which fit into an injection point. A qualifier declared at an injection point provides the set of eligible beans, which declare the same qualifier.
				</p><p>
					Qualifiers must be declared with a retention and target as shown in the example below.
				</p><div class="title"><strong>Example: Define the <code class="literal">@Synchronous</code> and <code class="literal">@Asynchronous</code> Qualifiers</strong></div><p>
						
</p><pre class="programlisting">@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Synchronous {}</pre><p>

					</p><pre class="programlisting">@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Asynchronous {}</pre><div class="title"><strong>Example: Use the <code class="literal">@Synchronous</code> and <code class="literal">@Asynchronous</code> Qualifiers</strong></div><p>
						
</p><pre class="programlisting">@Synchronous
public class SynchronousPaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}</pre><p>

					</p><pre class="programlisting">@Asynchronous
public class AsynchronousPaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}</pre><h4><a id="any_qualifier"/>'@Any'</h4><p>
					Whenever a bean or injection point does not explicitly declare a qualifier, the container assumes the qualifier <code class="literal">@Default</code>. From time to time, you will need to declare an injection point without specifying a qualifier. There is a qualifier for that too. All beans have the qualifier <code class="literal">@Any</code>. Therefore, by explicitly specifying <code class="literal">@Any</code> at an injection point, you suppress the default qualifier, without otherwise restricting the beans that are eligible for injection.
				</p><p>
					This is especially useful if you want to iterate over all beans of a certain bean type.
				</p><pre class="programlisting">import javax.enterprise.inject.Instance;
...

@Inject

void initServices(@Any Instance&lt;Service&gt; services) {

   for (Service service: services) {

      service.init();

   }

}</pre><p>
					Every bean has the qualifier <code class="literal">@Any</code>, even if it does not explicitly declare this qualifier.
				</p><p>
					Every event also has the qualifier <code class="literal">@Any</code>, even if it was raised without explicit declaration of this qualifier.
				</p><pre class="programlisting">@Inject @Any Event&lt;User&gt; anyUserEvent;</pre><p>
					The <code class="literal">@Any</code> qualifier allows an injection point to refer to all beans or all events of a certain bean type.
				</p><pre class="programlisting">@Inject @Delegate @Any Logger logger;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="use_a_qualifier_to_resolve_an_ambiguous_injection"/>Use a Qualifier to Resolve an Ambiguous Injection</h2></div></div></div><p>
					You can resolve an ambiguous injection using a qualifier. Read more about ambiguous injections at <a class="link" href="contexts_and_dependency_injection.html#ambiguous_or_unsatisfied_dependencies" title="Ambiguous or Unsatisfied Dependencies">Ambiguous or Unsatisfied Dependencies</a>.
				</p><p>
					The following example is ambiguous and features two implementations of <code class="literal">Welcome</code>, one which translates and one which does not. The injection needs to be specified to use the translating <code class="literal">Welcome</code>.
				</p><div class="title"><strong>Example: Ambiguous Injection</strong></div><p>
						
</p><pre class="programlisting">public class Greeter {
  private Welcome welcome;

  @Inject
  void init(Welcome welcome) {
    this.welcome = welcome;
  }
  ...
}</pre><p>

					</p><h4><a id="resolve_an_ambiguous_injection_with_a_qualifier"/>Resolve an Ambiguous Injection with a Qualifier</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							To resolve the ambiguous injection, create a qualifier annotation called <code class="literal">@Translating</code>:
						</p><pre class="programlisting">@Qualifier
@Retention(RUNTIME)
@Target({TYPE,METHOD,FIELD,PARAMETERS})
public @interface Translating{}</pre></li><li class="listitem"><p class="simpara">
							Annotate your translating <code class="literal">Welcome</code> with the <code class="literal">@Translating</code> annotation:
						</p><pre class="programlisting">@Translating
public class TranslatingWelcome extends Welcome {
    @Inject Translator translator;
    public String buildPhrase(String city) {
        return translator.translate("Welcome to " + city + "!");
    }
    ...
}</pre></li><li class="listitem"><p class="simpara">
							Request the translating <code class="literal">Welcome</code> in your injection. You must request a qualified implementation explicitly, similar to the factory method pattern. The ambiguity is resolved at the injection point.
						</p><pre class="programlisting">public class Greeter {
  private Welcome welcome;
  @Inject
  void init(@Translating Welcome welcome) {
    this.welcome = welcome;
  }
  public void welcomeVisitors() {
    System.out.println(welcome.buildPhrase("San Francisco"));
  }
}</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="managed_beans"/>Managed Beans</h1></div></div></div><p>
				Java EE establishes a common definition in the Managed Beans specification. Managed beans are defined as container-managed objects with minimal programming restrictions, otherwise known by the acronym POJO (Plain Old Java Object). They support a small set of basic services, such as resource injection, lifecycle callbacks, and interceptors. Companion specifications, such as EJB and CDI, build on this basic model.
			</p><p>
				With very few exceptions, almost every concrete Java class that has a constructor with no parameters, or a constructor designated with the annotation <code class="literal">@Inject</code>, is a bean. This includes every JavaBean and every EJB session bean.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="types_of_classes_that_are_beans"/>Types of Classes That are Beans</h2></div></div></div><p>
					A managed bean is a Java class. The basic lifecycle and semantics of a managed bean are defined by the Managed Beans specification. You can explicitly declare a managed bean by annotating the bean class <code class="literal">@ManagedBean</code>, but in CDI you do not need to. According to the specification, the CDI container treats any class that satisfies the following conditions as a managed bean:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							It is not a non-static inner class.
						</li><li class="listitem">
							It is a concrete class or is annotated with <code class="literal">@Decorator</code>.
						</li><li class="listitem">
							It is not annotated with an EJB component-defining annotation or declared as an EJB bean class in the <code class="literal">ejb-jar.xml</code> file.
						</li><li class="listitem">
							It does not implement the interface <code class="literal">javax.enterprise.inject.spi.Extension</code>.
						</li><li class="listitem">
							It has either a constructor with no parameters, or a constructor annotated with <code class="literal">@Inject</code>.
						</li><li class="listitem">
							It is not annotated with <code class="literal">@Vetoed</code> or in a package annotated with <code class="literal">@Vetoed</code> .
						</li></ul></div><p>
					The unrestricted set of bean types for a managed bean contains the bean class, every superclass, and all interfaces it implements directly or indirectly.
				</p><p>
					If a managed bean has a public field, it must have the default scope <code class="literal">@Dependent</code>.
				</p><h4><a id="vetoed"/>@Vetoed</h4><p>
					The <code class="literal">@Vetoed</code> annotation was introduced in CDI 1.1. You can prevent a bean from injection by adding this annotation:
				</p><pre class="programlisting">@Vetoed
public class SimpleGreeting implements Greeting {
    ...
}</pre><p>
					In this code, the <code class="literal">SimpleGreeting</code> bean is not considered for injection.
				</p><p>
					All beans in a package can be prevented from injection:
				</p><pre class="programlisting">@Vetoed
package org.sample.beans;

import javax.enterprise.inject.Vetoed;</pre><p>
					This code in <code class="literal">package-info.java</code> in the <code class="literal">org.sample.beans</code> package will prevent all beans inside this package from injection.
				</p><p>
					Java EE components, such as stateless EJBs or JAX-RS resource endpoints, can be marked with <code class="literal">@Vetoed</code> to prevent them from being considered beans. Adding the <code class="literal">@Vetoed</code> annotation to all persistent entities prevents the <code class="literal">BeanManager</code> from managing an entity as a CDI Bean. When an entity is annotated with <code class="literal">@Vetoed</code>, no injections take place. The reasoning behind this is to prevent the <code class="literal">BeanManager</code> from performing the operations that might cause the JPA provider to break.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="use_cdi_to_inject_an_object_into_a_bean"/>Use CDI to Inject an Object Into a Bean</h2></div></div></div><p>
					CDI is activated automatically if CDI components are detected in an application. If you want to customize your configuration to differ from the default, you can include a <code class="literal">META-INF/beans.xml</code> file or a <code class="literal">WEB-INF/beans.xml</code> file in your deployment archive.
				</p><h4><a id="inject_objects_into_other_objects"/>Inject Objects into Other Objects</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							To obtain an instance of a class, annotate the field with <code class="literal">@Inject</code> within your bean:
						</p><pre class="programlisting">public class TranslateController {
   @Inject TextTranslator textTranslator;
   ...</pre></li><li class="listitem"><p class="simpara">
							Use your injected object’s methods directly. Assume that <code class="literal">TextTranslator</code> has a method <code class="literal">translate</code>:
						</p><pre class="programlisting">// in TranslateController class

public void translate() {
   translation = textTranslator.translate(inputText);
}</pre></li><li class="listitem"><p class="simpara">
							Use an injection in the constructor of a bean. You can inject objects into the constructor of a bean as an alternative to using a factory or service locator to create them:
						</p><pre class="programlisting">public class TextTranslator {

   private SentenceParser sentenceParser;
   private Translator sentenceTranslator;

   @Inject
   TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {
      this.sentenceParser = sentenceParser;
      this.sentenceTranslator = sentenceTranslator;
   }

   // Methods of the TextTranslator class
   ...
}</pre></li><li class="listitem"><p class="simpara">
							Use the <code class="literal">Instance(&lt;T&gt;)</code> interface to get instances programmatically. The <code class="literal">Instance</code> interface can return an instance of <code class="literal">TextTranslator</code> when parameterized with the bean type.
						</p><pre class="programlisting">@Inject Instance&lt;TextTranslator&gt; textTranslatorInstance;
...
public void translate() {
   textTranslatorInstance.get().translate(inputText);
}</pre></li></ol></div><p>
					When you inject an object into a bean, all of the object’s methods and properties are available to your bean. If you inject into your bean’s constructor, instances of the injected objects are created when your bean’s constructor is called, unless the injection refers to an instance that already exists. For instance, a new instance would not be created if you inject a session-scoped bean during the lifetime of the session.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="contexts_and_scopes"/>Contexts and Scopes</h1></div></div></div><p>
				A context, in terms of CDI, is a storage area that holds instances of beans associated with a specific scope.
			</p><p>
				A scope is the link between a bean and a context. A scope/context combination can have a specific lifecycle. Several predefined scopes exist, and you can create your own. Examples of predefined scopes are <code class="literal">@RequestScoped</code>, <code class="literal">@SessionScoped</code>, and <code class="literal">@ConversationScope</code>.
			</p><div class="table"><a id="idm139905036337488"/><p class="title"><strong>Table 7.1. Available Scopes</strong></p><div class="table-contents"><table summary="Available Scopes" border="1" width="100%"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Scope</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">@Dependent</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The bean is bound to the lifecycle of the bean holding the reference. The default scope for an injected bean is <code class="literal">@Dependent</code>.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">@ApplicationScoped</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The bean is bound to the lifecycle of the application.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">@RequestScoped</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The bean is bound to the lifecycle of the request.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">@SessionScoped</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The bean is bound to the lifecycle of the session.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">@ConversationScoped</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The bean is bound to the lifecycle of the conversation. The conversation scope is between the lengths of the request and the session, and is controlled by the application.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								Custom scopes
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								If the above contexts do not meet your needs, you can define custom scopes.
							</p>
							 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_named_beans"/>Named Beans</h1></div></div></div><p>
				You can name a bean by using the <code class="literal">@Named</code> annotation. Naming a bean allows you to use it directly in Java Server Faces (JSF) and Expression Language (EL).
			</p><p>
				The <code class="literal">@Named</code> annotation takes an optional parameter, which is the bean name. If this parameter is omitted, the bean name defaults to the class name of the bean with its first letter converted to lowercase.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="use_named_beans"/>Use Named Beans</h2></div></div></div><h4><a id="configure_bean_names_using_the_named_annotation"/>Configure Bean Names Using the @Named Annotation</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Use the <code class="literal">@Named</code> annotation to assign a name to a bean.
						</p><pre class="programlisting">@Named("greeter")
public class GreeterBean {
  private Welcome welcome;

  @Inject
  void init (Welcome welcome) {
    this.welcome = welcome;
  }

  public void welcomeVisitors() {
    System.out.println(welcome.buildPhrase("San Francisco"));
  }
}</pre><p class="simpara">
							In the example above, the default name would be <code class="literal">greeterBean</code> if no name had been specified.
						</p></li><li class="listitem"><p class="simpara">
							Use the named bean in a JSF view.
						</p><pre class="screen">&lt;h:form&gt;
  &lt;h:commandButton value="Welcome visitors" action="#{greeter.welcomeVisitors}"/&gt;
&lt;/h:form&gt;</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="bean_lifecycle"/>Bean Lifecycle</h1></div></div></div><p>
				This task shows you how to save a bean for the life of a request.
			</p><p>
				The default scope for an injected bean is <code class="literal">@Dependent</code>. This means that the bean’s lifecycle is dependent upon the lifecycle of the bean that holds the reference. Several other scopes exist, and you can define your own scopes. For more information, see <a class="link" href="contexts_and_dependency_injection.html#contexts_and_scopes" title="Contexts and Scopes">Contexts and Scopes</a>.
			</p><h3><a id="manage_bean_lifecycles"/>Manage Bean Lifecycles</h3><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
						Annotate the bean with the desired scope.
					</p><pre class="programlisting">@RequestScoped
@Named("greeter")
public class GreeterBean {
  private Welcome welcome;
  private String city; // getter &amp; setter not shown
  @Inject   void init(Welcome welcome) {
    this.welcome = welcome;
  }
  public void welcomeVisitors() {
    System.out.println(welcome.buildPhrase(city));
  }
}</pre></li><li class="listitem"><p class="simpara">
						When your bean is used in the JSF view, it holds state.
					</p><pre class="programlisting">&lt;h:form&gt;
  &lt;h:inputText value="#{greeter.city}"/&gt;
  &lt;h:commandButton value="Welcome visitors" action="#{greeter.welcomeVisitors}"/&gt;
&lt;/h:form&gt;</pre></li></ol></div><p>
				Your bean is saved in the context relating to the scope that you specify, and lasts as long as the scope applies.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="user_a_producer_method"/>Use a Producer Method</h2></div></div></div><p>
					A <span class="emphasis"><em>producer method</em></span> is a method that acts as a source of bean instances. When no instance exists in the specified context, the method declaration itself describes the bean, and the container invokes the method to obtain an instance of the bean. A producer method lets the application take full control of the bean instantiation process.
				</p><p>
					This section shows how to use producer methods to produce a variety of different objects that are not beans for injection.
				</p><div class="title"><strong>Example: Use a Producer Method</strong></div><p>
						By using a producer method instead of an alternative, polymorphism after deployment is allowed.
					</p><p>
					The <code class="literal">@Preferred</code> annotation in the example is a qualifier annotation. For more information about qualifiers, see <a class="link" href="contexts_and_dependency_injection.html#about_qualifiers" title="Qualifiers">Qualifiers</a>.
				</p><pre class="programlisting">@SessionScoped
public class Preferences implements Serializable {
   private PaymentStrategyType paymentStrategy;
   ...
   @Produces @Preferred
   public PaymentStrategy getPaymentStrategy() {
       switch (paymentStrategy) {
           case CREDIT_CARD: return new CreditCardPaymentStrategy();
           case CHECK: return new CheckPaymentStrategy();
           default: return null;
       }
   }
}</pre><p>
					The following injection point has the same type and qualifier annotations as the producer method, so it resolves to the producer method using the usual CDI injection rules. The producer method is called by the container to obtain an instance to service this injection point.
				</p><pre class="programlisting">@Inject @Preferred PaymentStrategy paymentStrategy;</pre><div class="title"><strong>Example: Assign a Scope to a Producer Method</strong></div><p>
						The default scope of a producer method is <code class="literal">@Dependent</code>. If you assign a scope to a bean, it is bound to the appropriate context. The producer method in this example is only called once per session.
					</p><pre class="programlisting">@Produces @Preferred @SessionScoped
public PaymentStrategy getPaymentStrategy() {
   ...
}</pre><div class="title"><strong>Example: Use an Injection Inside a Producer Method</strong></div><p>
						Objects instantiated directly by an application cannot take advantage of dependency injection and do not have interceptors. However, you can use dependency injection into the producer method to obtain bean instances.
					</p><pre class="programlisting">@Produces @Preferred @SessionScoped
public PaymentStrategy getPaymentStrategy(CreditCardPaymentStrategy ccps,
                                          CheckPaymentStrategy cps ) {
   switch (paymentStrategy) {
      case CREDIT_CARD: return ccps;
      case CHEQUE: return cps;
      default: return null;
   }
}</pre><p>
					If you inject a request-scoped bean into a session-scoped producer, the producer method promotes the current request-scoped instance into session scope. This is almost certainly not the desired behavior, so use caution when you use a producer method in this way.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The scope of the producer method is not inherited from the bean that declares the producer method.
					</p></div><p>
					Producer methods allow you to inject non-bean objects and change your code dynamically.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="alternative_beans"/>Alternative Beans</h1></div></div></div><p>
				Alternatives are beans whose implementation is specific to a particular client module or deployment scenario.
			</p><p>
				By default, <code class="literal">@Alternative</code> beans are disabled. They are enabled for a specific bean archive by editing its <code class="literal">beans.xml</code> file. However, this activation only applies to the beans in that archive. From CDI 1.1 onwards, the alternative can be enabled for the entire application using the <code class="literal">@Priority</code> annotation.
			</p><div class="title"><strong>Example: Defining Alternatives</strong></div><p>
					This alternative defines an implementation of the <code class="literal">PaymentProcessor</code> class using both <code class="literal">@Synchronous</code> and <code class="literal">@Asynchronous</code> alternatives:
				</p><pre class="programlisting">@Alternative @Synchronous @Asynchronous

public class MockPaymentProcessor implements PaymentProcessor {

   public void process(Payment payment) { ... }

}</pre><div class="title"><strong>Example: Enabling <code class="literal">@Alternative</code> Using <code class="literal">beans.xml</code></strong></div><p>
					
</p><pre class="programlisting">&lt;beans
   xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
      http://xmlns.jcp.org/xml/ns/javaee
      http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd"&gt;
   &lt;alternatives&gt;
         &lt;class&gt;org.mycompany.mock.MockPaymentProcessor&lt;/class&gt;
   &lt;/alternatives&gt;
&lt;/beans&gt;</pre><p>

				</p><h3><a id="declaring_selected_alternatives"/>Declaring Selected Alternatives</h3><p>
				The <code class="literal">@Priority</code> annotation allows an alternative to be enabled for an entire application. An alternative can be given a priority for the application:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						by placing the <code class="literal">@Priority</code> annotation on the bean class of a managed bean or session bean, or
					</li><li class="listitem">
						by placing the <code class="literal">@Priority</code> annotation on the bean class that declares the producer method, field or resource.
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="override_injection_with_alternative"/>Override an Injection with an Alternative</h2></div></div></div><p>
					You can use alternative beans to override existing beans. They can be thought of as a way to plug in a class which fills the same role, but functions differently. They are disabled by default.
				</p><p>
					This task shows you how to specify and enable an alternative.
				</p><h4><a id="override_an_injection"/>Override an Injection</h4><p>
					This task assumes that you already have a <code class="literal">TranslatingWelcome</code> class in your project, but you want to override it with a "mock" <code class="literal">TranslatingWelcome</code> class. This would be the case for a test deployment, where the true <code class="literal">Translator</code> bean cannot be used.
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Define the alternative.
						</p><pre class="programlisting">@Alternative
@Translating
public class MockTranslatingWelcome extends Welcome {
  public String buildPhrase(string city) {
    return "Bienvenue Ã  " + city + "!");
  }
}</pre></li><li class="listitem"><p class="simpara">
							Activate the substitute implementation by adding the fully-qualified class name to your <code class="literal">META-INF/beans.xml</code> or <code class="literal">WEB-INF/beans.xml</code> file.
						</p><pre class="programlisting">&lt;beans&gt;
  &lt;alternatives&gt;
    &lt;class&gt;com.acme.MockTranslatingWelcome&lt;/class&gt;
  &lt;/alternatives&gt;
&lt;/beans&gt;</pre></li></ol></div><p>
					The alternative implementation is now used instead of the original one.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="stereotypes"/>Stereotypes</h1></div></div></div><p>
				In many systems, use of architectural patterns produces a set of recurring bean roles. A stereotype allows you to identify such a role and declare some common metadata for beans with that role in a central place.
			</p><p>
				A stereotype encapsulates any combination of:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						A default scope.
					</li><li class="listitem">
						A set of interceptor bindings.
					</li></ul></div><p>
				A stereotype can also specify either:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						All beans where the stereotypes are defaulted bean EL names.
					</li><li class="listitem">
						All beans where the stereotypes are alternatives.
					</li></ul></div><p>
				A bean can declare zero, one, or multiple stereotypes. A stereotype is an <code class="literal">@Stereotype</code> annotation that packages several other annotations. Stereotype annotations can be applied to a bean class, producer method, or field.
			</p><p>
				A class that inherits a scope from a stereotype can override that stereotype and specify a scope directly on the bean.
			</p><p>
				In addition, if a stereotype has a <code class="literal">@Named</code> annotation, any bean it is placed on has a default bean name. The bean can override this name if the <code class="literal">@Named</code> annotation is specified directly on the bean. For more information about named beans, see <a class="link" href="contexts_and_dependency_injection.html#about_named_beans" title="Named Beans">Named Beans</a>.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="use_stereotypes"/>Use Stereotypes</h2></div></div></div><p>
					Without stereotypes, annotations can become cluttered. This task shows you how to use stereotypes to reduce the clutter and streamline your code.
				</p><div class="title"><strong>Example: Annotation Clutter</strong></div><p>
						
</p><pre class="programlisting">@Secure
@Transactional
@RequestScoped
@Named
public class AccountManager {
  public boolean transfer(Account a, Account b) {
    ...
  }
}</pre><p>

					</p><h4><a id="define_and_use_stereotypes"/>Define and Use Stereotypes</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Define the stereotype.
						</p><pre class="programlisting">@Secure
@Transactional
@RequestScoped
@Named
@Stereotype
@Retention(RUNTIME)
@Target(TYPE)
public @interface BusinessComponent {
 ...
}</pre></li><li class="listitem"><p class="simpara">
							Use the stereotype.
						</p><pre class="programlisting">@BusinessComponent
public class AccountManager {
  public boolean transfer(Account a, Account b) {
    ...
  }
}</pre></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="observer_methods"/>Observer Methods</h1></div></div></div><p>
				Observer methods receive notifications when events occur.
			</p><p>
				CDI also provides transactional observer methods, which receive event notifications during the before completion or after completion phase of the transaction in which the event was fired.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="fire_and_observe_events"/>Fire and Observe Events</h2></div></div></div><div class="title"><strong>Example: Fire an Event</strong></div><p>
						The following code shows an event being injected and used in a method.
					</p><pre class="programlisting">public class AccountManager {
  @Inject Event&lt;Withdrawal&gt; event;

  public boolean transfer(Account a, Account b) {
    ...
    event.fire(new Withdrawal(a));
  }
}</pre><div class="title"><strong>Example: Fire an Event with a Qualifier</strong></div><p>
						You can annotate your event injection with a qualifier, to make it more specific. For more information about qualifiers, see <a class="link" href="contexts_and_dependency_injection.html#about_qualifiers" title="Qualifiers">Qualifiers</a>.
					</p><pre class="programlisting">public class AccountManager {
  @Inject @Suspicious Event &lt;Withdrawal&gt; event;

  public boolean transfer(Account a, Account b) {
    ...
    event.fire(new Withdrawal(a));
  }
}</pre><div class="title"><strong>Example: Observe an Event</strong></div><p>
						To observe an event, use the <code class="literal">@Observes</code> annotation.
					</p><pre class="programlisting">public class AccountObserver {
  void checkTran(@Observes Withdrawal w) {
    ...
  }
}</pre><p>
					You can use qualifiers to observe only specific types of events.
				</p><pre class="programlisting">public class AccountObserver {
  void checkTran(@Observes @Suspicious Withdrawal w) {
    ...
  }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="transactional_observers"/>Transactional Observers</h2></div></div></div><p>
					Transactional observers receive the event notifications before or after the completion phase of the transaction in which the event was raised. Transactional observers are important in a stateful object model because state is often held for longer than a single atomic transaction.
				</p><p>
					There are five kinds of transactional observers:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">IN_PROGRESS</code>: By default, observers are invoked immediately.
						</li><li class="listitem">
							<code class="literal">AFTER_SUCCESS</code>: Observers are invoked after the completion phase of the transaction, but only if the transaction completes successfully.
						</li><li class="listitem">
							<code class="literal">AFTER_FAILURE</code>: Observers are invoked after the completion phase of the transaction, but only if the transaction fails to complete successfully.
						</li><li class="listitem">
							<code class="literal">AFTER_COMPLETION</code>: Observers are invoked after the completion phase of the transaction.
						</li><li class="listitem">
							<code class="literal">BEFORE_COMPLETION</code>: Observers are invoked before the completion phase of the transaction.
						</li></ul></div><p>
					The following observer method refreshes a query result set cached in the application context, but only when transactions that update the Category tree are successful:
				</p><pre class="programlisting">public void refreshCategoryTree(@Observes(during = AFTER_SUCCESS) CategoryUpdateEvent event) { ... }</pre><p>
					Assume you have cached a JPA query result set in the application scope as shown in the following example:
				</p><pre class="programlisting">import javax.ejb.Singleton;
import javax.enterprise.inject.Produces;

@ApplicationScoped @Singleton

public class Catalog {
   @PersistenceContext EntityManager em;
   List&lt;Product&gt; products;
   @Produces @Catalog
   List&lt;Product&gt; getCatalog() {
      if (products==null) {
         products = em.createQuery("select p from Product p where p.deleted = false")
            .getResultList();
      }
      return products;
   }
}</pre><p>
					Occasionally a <code class="literal">Product</code> is created or deleted. When this occurs, you need to refresh the <code class="literal">Product</code> catalog. But you must wait for the transaction to complete successfully before performing this refresh.
				</p><p>
					The following is an example of a bean that creates and deletes <code class="literal">Products</code> triggers events:
				</p><pre class="programlisting">import javax.enterprise.event.Event;

@Stateless

public class ProductManager {
   @PersistenceContext EntityManager em;
   @Inject @Any Event&lt;Product&gt; productEvent;
   public void delete(Product product) {
      em.delete(product);
      productEvent.select(new AnnotationLiteral&lt;Deleted&gt;(){}).fire(product);
   }

   public void persist(Product product) {
      em.persist(product);
      productEvent.select(new AnnotationLiteral&lt;Created&gt;(){}).fire(product);
   }
   ...
}</pre><p>
					The <code class="literal">Catalog</code> can now observe the events after successful completion of the transaction:
				</p><pre class="programlisting">import javax.ejb.Singleton;

@ApplicationScoped @Singleton
public class Catalog {
   ...
   void addProduct(@Observes(during = AFTER_SUCCESS) @Created Product product) {
      products.add(product);
   }

   void removeProduct(@Observes(during = AFTER_SUCCESS) @Deleted Product product) {
      products.remove(product);
   }

}</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="interceptors"/>Interceptors</h1></div></div></div><p>
				Interceptors allow you to add functionality to the business methods of a bean without modifying the bean’s method directly. The interceptor is executed before any of the business methods of the bean. Interceptors are defined as part of the <a class="link" href="https://jcp.org/en/jsr/detail?id=345">JSR 345: Enterprise JavaBeans™ 3.2</a> specification.
			</p><p>
				CDI enhances this functionality by allowing you to use annotations to bind interceptors to beans.
			</p><p>
				<span class="strong"><strong>Interception points</strong></span>
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Business method interception: A business method interceptor applies to invocations of methods of the bean by clients of the bean.
					</li><li class="listitem">
						Lifecycle callback interception: A lifecycle callback interceptor applies to invocations of lifecycle callbacks by the container.
					</li><li class="listitem">
						Timeout method interception: A timeout method interceptor applies to invocations of the EJB timeout methods by the container.
					</li></ul></div><h3><a id="enabling_interceptors"/>Enabling Interceptors</h3><p>
				By default, all interceptors are disabled. You can enable the interceptor by using the <code class="literal">beans.xml</code> descriptor of a bean archive. However, this activation only applies to the beans in that archive. From CDI 1.1 onwards the interceptor can be enabled for the whole application using the <code class="literal">@Priority</code> annotation.
			</p><div class="title"><strong>Example: Enabling Interceptors in <code class="literal">beans.xml</code></strong></div><p>
					
</p><pre class="programlisting">&lt;beans
   xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
      http://xmlns.jcp.org/xml/ns/javaee
      http://xmlns.jcp.org/xml/ns/javaee/beans_2.0.xsd"&gt;
   &lt;interceptors&gt;
      &lt;class&gt;org.mycompany.myapp.TransactionInterceptor&lt;/class&gt;
   &lt;/interceptors&gt;
&lt;/beans&gt;</pre><p>

				</p><p>
				Having the XML declaration solves two problems:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						It enables you to specify an ordering for the interceptors in your system, ensuring deterministic behavior.
					</li><li class="listitem">
						It lets you enable or disable interceptor classes at deployment time.
					</li></ul></div><p>
				Interceptors enabled using <code class="literal">@Priority</code> are called before interceptors enabled using the <code class="literal">beans.xml</code> file.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					Having an interceptor enabled by <code class="literal">@Priority</code> and at the same time invoked by the <code class="literal">beans.xml</code> file leads to a nonportable behavior. This combination of enablement should therefore be avoided in order to maintain consistent behavior across different CDI implementations.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="use_interceptors_with_cdi"/>Use Interceptors with CDI</h2></div></div></div><p>
					CDI can simplify your interceptor code and make it easier to apply to your business code.
				</p><p>
					Without CDI, interceptors have two problems:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The bean must specify the interceptor implementation directly.
						</li><li class="listitem">
							Every bean in the application must specify the full set of interceptors in the correct order. This makes adding or removing interceptors on an application-wide basis time-consuming and error-prone.
						</li></ul></div><h4><a id="using_interceptors_with_cdi"/>Using Interceptors with CDI</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Define the interceptor binding type.
						</p><pre class="programlisting">@InterceptorBinding
@Retention(RUNTIME)
@Target({TYPE, METHOD})
public @interface Secure {}</pre></li><li class="listitem"><p class="simpara">
							Mark the interceptor implementation.
						</p><pre class="programlisting">@Secure
@Interceptor
public class SecurityInterceptor {
  @AroundInvoke
  public Object aroundInvoke(InvocationContext ctx) throws Exception {
    // enforce security ...
    return ctx.proceed();
    }
}</pre></li><li class="listitem"><p class="simpara">
							Use the interceptor in your development environment.
						</p><pre class="programlisting">@Secure
public class AccountManager {
  public boolean transfer(Account a, Account b) {
    ...
  }
}</pre></li><li class="listitem"><p class="simpara">
							Enable the interceptor in your deployment, by adding it to the <code class="literal">META-INF/beans.xml</code> or <code class="literal">WEB-INF/beans.xml</code> file.
						</p><pre class="programlisting">&lt;beans&gt;
  &lt;interceptors&gt;
    &lt;class&gt;com.acme.SecurityInterceptor&lt;/class&gt;
    &lt;class&gt;com.acme.TransactionInterceptor&lt;/class&gt;
  &lt;/interceptors&gt;
&lt;/beans&gt;</pre></li></ol></div><p>
					The interceptors are applied in the order listed.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="decorators"/>Decorators</h1></div></div></div><p>
				A decorator intercepts invocations from a specific Java interface, and is aware of all the semantics attached to that interface. Decorators are useful for modeling some kinds of business concerns, but do not have the generality of interceptors. A decorator is a bean, or even an abstract class, that implements the type it decorates, and is annotated with <code class="literal">@Decorator</code>. To invoke a decorator in a CDI application, it must be specified in the <code class="literal">beans.xml</code> file.
			</p><div class="title"><strong>Example: Invoke a Decorator Through <code class="literal">beans.xml</code></strong></div><p>
					
</p><pre class="programlisting">&lt;beans
   xmlns="http://xmlns.jcp.org/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
      http://xmlns.jcp.org/xml/ns/javaee
      http://xmlns.jcp.org/xml/ns/javaee/beans_2_0.xsd"&gt;
   &lt;decorators&gt;
         &lt;class&gt;org.mycompany.myapp.LargeTransactionDecorator&lt;/class&gt;
   &lt;/decorators&gt;
&lt;/beans&gt;</pre><p>

				</p><p>
				This declaration serves two main purposes:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						It enables you to specify an ordering for decorators in your system, ensuring deterministic behavior.
					</li><li class="listitem">
						It lets you enable or disable decorator classes at deployment time.
					</li></ul></div><p>
				A decorator must have exactly one <code class="literal">@Delegate</code> injection point to obtain a reference to the decorated object.
			</p><div class="title"><strong>Example: Decorator Class</strong></div><p>
					
</p><pre class="programlisting">@Decorator
public abstract class LargeTransactionDecorator implements Account {

   @Inject @Delegate @Any Account account;
   @PersistenceContext EntityManager em;

   public void withdraw(BigDecimal amount) {
      ...
   }

   public void deposit(BigDecimal amount);
      ...
   }
}</pre><p>

				</p><p>
				From CDI 1.1 onwards, the decorator can be enabled for the whole application using <code class="literal">@Priority</code> annotation.
			</p><p>
				Decorators enabled using <code class="literal">@Priority</code> are called before decorators enabled using the <code class="literal">beans.xml</code> file. The lower priority values are called first.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					Having a decorator enabled by <code class="literal">@Priority</code> and at the same time invoked by <code class="literal">beans.xml</code>, leads to a nonportable behavior. This combination of enablement should therefore be avoided in order to maintain consistent behavior across different CDI implementations.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="portable_extensions"/>Portable Extensions</h1></div></div></div><p>
				CDI is intended to be a foundation for frameworks, extensions, and for integration with other technologies. Therefore, CDI exposes a set of SPIs for the use of developers of portable extensions to CDI.
			</p><p>
				Extensions can provide the following types of functionality:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Integration with Business Process Management engines.
					</li><li class="listitem">
						Integration with third-party frameworks, such as Spring, Seam, GWT, or Wicket.
					</li><li class="listitem">
						New technology based upon the CDI programming model.
					</li></ul></div><p>
				According to the <a class="link" href="https://jcp.org/en/jsr/detail?id=346">JSR-346</a> specification, a portable extension can integrate with the container in the following ways:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Providing its own beans, interceptors, and decorators to the container.
					</li><li class="listitem">
						Injecting dependencies into its own objects using the dependency. injection service.
					</li><li class="listitem">
						Providing a context implementation for a custom scope.
					</li><li class="listitem">
						Augmenting or overriding the annotation-based metadata with metadata from another source.
					</li></ul></div><p>
				For more information, see <a class="link" href="http://docs.jboss.org/weld/reference/3.0.5.Final/en-US/html_single/#extend">Portable extensions</a> in the Weld documentation.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="bean_proxies"/>Bean Proxies</h1></div></div></div><p>
				Clients of an injected bean do not usually hold a direct reference to a bean instance. Unless the bean is a dependent object, scope <code class="literal">@Dependent</code>, the container must redirect all injected references to the bean using a proxy object.
			</p><p>
				A bean proxy, which can be referred to as client proxy, is responsible for ensuring the bean instance that receives a method invocation is the instance associated with the current context. The client proxy also allows beans bound to contexts, such as the session context, to be serialized to disk without recursively serializing other injected beans.
			</p><p>
				Due to Java limitations, some Java types cannot be proxied by the container. If an injection point declared with one of these types resolves to a bean with a scope other than <code class="literal">@Dependent</code>, the container aborts the deployment.
			</p><p>
				Certain Java types cannot be proxied by the container. These include:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Classes that do not have a non-private constructor with no parameters.
					</li><li class="listitem">
						Classes that are declared <code class="literal">final</code> or have a <code class="literal">final</code> method.
					</li><li class="listitem">
						Arrays and primitive types.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="use_a_proxy_in_an_injection"/>Use a Proxy in an Injection</h1></div></div></div><p>
				A proxy is used for injection when the lifecycles of the beans are different from each other. The proxy is a subclass of the bean that is created at runtime, and overrides all the non-private methods of the bean class. The proxy forwards the invocation onto the actual bean instance.
			</p><p>
				In this example, the <code class="literal">PaymentProcessor</code> instance is not injected directly into <code class="literal">Shop</code>. Instead, a proxy is injected, and when the <code class="literal">processPayment()</code> method is called, the proxy looks up the current <code class="literal">PaymentProcessor</code> bean instance and calls the <code class="literal">processPayment()</code> method on it.
			</p><div class="title"><strong>Example: Proxy Injection</strong></div><p>
					
</p><pre class="programlisting">@ConversationScoped
class PaymentProcessor
{
  public void processPayment(int amount)
  {
    System.out.println("I'm taking $" + amount);
  }
}

@ApplicationScoped
public class Shop
{

  @Inject
  PaymentProcessor paymentProcessor;

  public void buyStuff()
  {
    paymentProcessor.processPayment(100);
  }
}</pre><p>

				</p></div></div></body></html>