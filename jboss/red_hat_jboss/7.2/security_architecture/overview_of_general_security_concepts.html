<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 1. Overview of General Security Concepts</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="overview_of_general_security_concepts"/>Chapter 1. Overview of General Security Concepts</h1></div></div></div><p>
			Before digging into how JBoss EAP handles security, it is important to understand a few basic security concepts.
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="authentication"/>Authentication</h1></div></div></div><p>
				Authentication refers to identifying a subject and verifying the authenticity of the identification. The most common authentication mechanism is a username and password combination, but other mechanisms, such as shared keys, smart cards or fingerprints, are also used for authentication. When in the context of Java Enterprise Edition declarative security, the result of a successful authentication is called a principal.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="authorization"/>Authorization</h1></div></div></div><p>
				Authorization refers to a way of specifying access rights or defining access policies. A system can then implement a mechanism to use those policies to permit or deny access to resources for the requester. In many cases, this is implemented by matching a principal with a set of actions or places they are allowed to access, sometimes referred to as a role.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="authentication_and_authorization_in_practice"/>Authentication and Authorization in Practice</h1></div></div></div><p>
				Although authentication and authorization are distinct concepts, they are often linked. Many modules written to handle authentication also handle authorization and vice versa.
			</p><div class="title"><strong>Example</strong></div><p>
					The application <code class="literal">MyPersonalSoapbox</code> provides the ability to post and view messages. Principals with the <code class="literal">Talk</code> role can post messages and view other posted messages. Users who have not logged in have the <code class="literal">Listen</code> role and can view posted messages. Suzy, Adam, and Bob use the application. Suzy and Bob can authenticate with their username and password, but Adam does not have a username and password yet. Suzy has the <code class="literal">Talk</code> role, but Bob does not have any roles, neither <code class="literal">Talk</code> nor <code class="literal">Listen</code>. When Suzy authenticates, she may post and view messages. When Adam uses <code class="literal">MyPersonalSoapbox</code>, he cannot log in, but he can see posted messages. When Bob logs in, he cannot post any messages, nor can he view any other posted messages.
				</p><p>
				Suzy is both authenticated and authorized. Adam has not authenticated, but he is authorized, with the <code class="literal">Listen</code> role, to view messages. Bob is authenticated but has no authorization and no roles.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="encryption"/>Encryption</h1></div></div></div><p>
				Encryption refers to encoding sensitive information by applying mathematical algorithms to it. Data is secured by converting, or encrypting, it to an encoded format. To read the data again, the encoded format must be converted, or decrypted, to the original format. Encryption can be applied to simple string data in files or databases or even on data sent across communications streams.
			</p><p>
				Examples of encryption include the following scenarios.
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						LUKS can be used to encrypt Linux file system disks.
					</li><li class="listitem">
						The blowfish or AES algorithms can be used to encrypt data stored in Postgres databases.
					</li><li class="listitem">
						The HTTPS protocol encrypts all data via Secure Sockets Layer/Transport Layer Security, SSL/TLS, before transferring it from one party to another.
					</li><li class="listitem">
						When a user connects from one server to another using the Secure Shell, SSH protocol, all of the communication is sent in an encrypted tunnel.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ssl_tls_and_certificates"/>SSL/TLS and Certificates</h1></div></div></div><p>
				SSL/TLS encrypts network traffic between two systems by using a symmetric key that is exchanged between and only known by those two systems. To ensure a secure exchange of the symmetric key, SSL/TLS uses Public Key Infrastructure (PKI), a method of encryption that uses a key pair. A key pair consists of two separate but matching cryptographic keys: a public key and a private key. The public key is shared with any party and is used to encrypt data; the private key is kept secret and is used to decrypt data that has been encrypted using the public key.
			</p><p>
				When a client requests a secure connection to exchange symmetric keys, a handshake phase occurs before secure communication can begin. During the SSL/TLS handshake, the server passes its public key to the client in the form of a certificate. The certificate contains the identity of the server, its URL, the public key of the server, and a digital signature that validates the certificate. The client validates the certificate and decides whether the certificate is trusted. If the certificate is trusted, the client generates the symmetric key for the SSL/TLS connection, encrypts it using the public key of the server, and sends it back to the server. The server uses its private key to decrypt the symmetric key. Further communication between the two machines over this connection is encrypted using the symmetric key.
			</p><p>
				There are two kinds of certificates: self-signed certificates and authority-signed certificates. A self-signed certificate uses its private key to sign itself; that signature is unverified because it is not connected to a chain of trust. An authority-signed certificate is a certificate that is issued to a party by a certificate authority, CA, and is signed by that CA, for example, VeriSign, CAcert, or RSA. The CA verifies the authenticity of the certificate holder.
			</p><p>
				Self-signed certificates can be faster and easier to generate and require less infrastructure to manage, but they can be difficult for clients to verify their authenticity because a third party has not confirmed their authenticity. This inherently makes the self-signed certificate less secure. Authority-signed certificates can take more effort to set up, but they are easier for clients to verify their authenticity. A chain of trust has been created because a third party has confirmed the authenticity of the certificate holder.
			</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
					Red Hat recommends that SSLv2, SSLv3, and TLSv1.0 be explicitly disabled in favor of TLSv1.1 or TLSv1.2 in all affected packages.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="single_sign_on_sso"/>Single Sign-On</h1></div></div></div><p>
				Single sign-on (SSO) allows principals authenticated to one resource to implicitly authorize access to other resources. If a set of distinct resources is secured by SSO, a user is only required to authenticate the first time they access any of the secured resources. Upon successful authentication, the roles associated with the user are stored and used for authorization of all other associated resources. This allows the user to access any additional authorized resources without reauthenticating.
			</p><p>
				If the user logs out of a resource or a resource invalidates the session programmatically, all persisted authorization data is removed and the process starts over. In the case of a resource session timeout, the SSO session is not invalidated if there are other valid resource sessions associated with that user. SSO may be used for authentication and authorization on web applications and desktop applications. In some cases, an SSO implementation can integrate with both.
			</p><p>
				Within SSO, there are a few common terms used to describe different concepts and parts of the system.
			</p><div class="title"><strong>Identity Management</strong></div><p>
					Identity management (IDM) refers to the idea of managing principals and their associated authentication, authorization, and privileges across one or more systems or domains. The term identity and access management (IAM) is sometimes used to describe this same concept.
				</p><div class="title"><strong>Identity Provider</strong></div><p>
					An identity provider (IDP) is the authoritative entity responsible for authenticating an end user and asserting the identity for that user in a trusted fashion to trusted partners.
				</p><div class="title"><strong>Identity Store</strong></div><p>
					An identity provider needs an identity store to retrieve users' information to use during the authentication and authorization process. Identity stores can be any type of repository: a database, Lightweight Directory Access Protocol (LDAP), properties file, and so on.
				</p><div class="title"><strong>Service Provider</strong></div><p>
					A service provider (SP) relies on an identity provider to assert information about a user via an electronic user credential, leaving the service provider to manage access control and dissemination based on a trusted set of user credential assertions.
				</p><div class="title"><strong>Clustered and Non-Clustered SSO</strong></div><p>
					Non-clustered SSO limits the sharing of authorization information to applications on the same virtual host. There is also no resiliency in the event of a host failure. In a clustered SSO scenario, data can be shared between applications on multiple virtual hosts, which makes it resilient to failures. In addition, a clustered SSO is able to receive requests from a load balancer.
				</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="third_party_sso"/>Third-Party SSO Implementations</h2></div></div></div><div class="title"><strong>Kerberos</strong></div><p>
						Kerberos is a network authentication protocol for client-server applications. It uses secret-key symmetric cryptography to allow secure authentication across a non-secure network.
					</p><p>
					Kerberos uses security tokens called tickets. To use a secured service, users need to obtain a ticket from the ticket granting service (TGS) which is a service that runs on a server in their network. After obtaining the ticket, users request a Service Ticket (ST) from an authentication service (AS) which is another service running in the same network. Users then use the ST to authenticate to the desired service. The TGS and the AS run inside an enclosing service called the key distribution center (KDC).
				</p><p>
					Kerberos is designed to be used in a client-server desktop environment and is not usually used in web applications or thin client environments. However, many organizations use a Kerberos system for desktop authentication and prefer to reuse their existing system rather than create a second one for their web applications. Kerberos is an integral part of Microsoft’s Active Directory and is used in many Red Hat Enterprise Linux environments.
				</p><div class="title"><strong>SPNEGO</strong></div><p>
						Simple and protected GSS_API negotiation mechanism (SPNEGO) provides a mechanism for extending a Kerberos-based SSO environment for use in web applications.
					</p><p>
					When an application on a client computer, such as a web browser, attempts to access a protected page on a web server, the server responds that authorization is required. The application then requests an ST from the KDC. The application wraps the ticket in a request formatted for SPNEGO and sends it back to the web application via the browser. The web container running the deployed web application unpacks the request and authenticates the ticket. Access is granted upon successful authentication.
				</p><p>
					SPNEGO works with all types of Kerberos providers, including the Kerberos service within Red Hat Enterprise Linux and the Kerberos server, which is an integral part of Microsoft’s Active Directory.
				</p><div class="title"><strong>Microsoft’s Active Directory</strong></div><p>
						Active Directory (AD) is a directory service developed by Microsoft to authenticate users and computers in a Microsoft Windows domain. It comes as part of Windows Server. The computer running Windows Server controlling the domain is referred to as the domain controller. Red Hat Enterprise Linux can integrate with Active Directory domains as can Red Hat Identity Management, Red Hat JBoss Enterprise Application Platform, and other Red Hat products.
					</p><p>
					Active Directory relies on three core technologies that work together:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							LDAP to store information about users, computers, passwords, and other resources
						</li><li class="listitem">
							Kerberos to provide secure authentication over the network
						</li><li class="listitem">
							Domain name service (DNS) to provide mappings between IP addresses and host names of computers and other devices in the network
						</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="claims_based_identity"/>Claims-Based Identity</h2></div></div></div><p>
					One way to implement SSO is to use a claims-based identity system. A claims-based identity system allows systems to pass identity information but abstracts that information into two components: a claim and an issuer or authority. A claim is statement that one subject, such as a user, group, application, or organization, makes about another. That claim or set of claims is packaged into a token or set of tokens and issued by a provider. Claims-based identity allows individual secured resources to implement SSO without having to know everything about a user.
				</p><div class="title"><strong>Security Token Service</strong></div><p>
						A security token service (STS) is an authentication service that issues security tokens to clients for use when authenticating and authorizing users for secured applications, web services or EJBs. A client attempting to authenticate against an application secured with STS, known as a service provider, will be redirected to a centralized STS authenticator and issued a token. If successful, that client will reattempt to access the service provider, providing their token along with the original request. That service provider will validate the token from the client with the STS and proceed accordingly. This same token may be reused by the client against other web services or EJBs that are connected to the STS. The concept of a centralized STS that can issue, cancel, renew, and validate security tokens and specifies the format of security token request and response messages is known as <code class="literal">WS-Trust</code>.
					</p><div class="title"><strong>Browser-Based SSO</strong></div><p>
						In browser-based SSO, one or more web applications, known as service providers, connect to a centralized identity provider in a hub and spoke architecture. The IDP acts as the central source, or hub, for identity and role information by issuing claim statements in SAML tokens to service providers, or spokes. Requests may be issued when a user attempts to access a service provider or if a user attempts to authenticate directly with the identity provider. These are known as SP-initiated and IDP-initiated flows, respectively, and will both issue the same claim statements.
					</p><div class="title"><strong>SAML</strong></div><p>
						Security Assertion Markup Language (SAML) is a data format that allows two parties, usually an identity provider and a service provider, to exchange authentication and authorization information. A SAML token is a type of token issued by an STS or IDP; it can be used to enable SSO. A resource secured by SAML, SAML service provider, redirects users to the SAML identity provider, a type of STS or IDP, to obtain a valid SAML token before authenticating and authorizing that user.
					</p><div class="title"><strong>Desktop-Based SSO</strong></div><p>
						Desktop-based SSO enables service providers and desktop domains, for example Active Directory or Kerberos, to share a principal. In practice, this allows users to log in on their computer using their domain credentials and then have service providers reuse that principal during authentication, without having to reauthenticate, thus providing SSO.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ldap"/>LDAP</h1></div></div></div><p>
				Lightweight Directory Access Protocol (LDAP) is a protocol for storing and distributing directory information across a network. This directory information includes information about users, hardware devices, access roles and restrictions, and other information.
			</p><p>
				In LDAP, the distinguished name (DN), uniquely identifies an object in a directory. Each distinguished name must have a unique name and location from all other objects, which is achieved using a number of attribute-value pairs (AVPs). The AVPs define information such as common names and organization unit. The combination of these values results in a unique string required by the LDAP.
			</p><p>
				Some common implementations of LDAP include Red Hat Directory Server, OpenLDAP, Active Directory, IBM Tivoli Directory Server, Oracle Internet Directory, and 389 Directory Server.
			</p></div></div></body></html>