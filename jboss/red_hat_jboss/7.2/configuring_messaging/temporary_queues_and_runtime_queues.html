<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 14. Temporary Queues and Runtime Queues</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="temporary_queues_and_runtime_queues"/>Chapter 14. Temporary Queues and Runtime Queues</h1></div></div></div><p>
				When designing a request-reply pattern where a client sends a request and waits for a reply, you must consider whether each runtime instance of the client requires a dedicated queue for its replies, or whether the runtime instances can access a shared queue, selecting their specific reply messages based on an appropriate attribute.
			</p><p>
				If multiple queues are required, then clients need the ability to create a queue dynamically. JMS provides this facility using the concept of temporary queues. A <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/jms/TemporaryQueue.html"><code class="literal">TemporaryQueue</code></a> is created on request by the <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/jms/Session.html"><code class="literal">Session</code></a>. It exists for the life of the <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/jms/Connection.html"><code class="literal">Connection</code></a>, for example until the connection is closed, or until the temporary queue is deleted. This means that although the temporary queue is created by a specific session, it can be reused by any other sessions created from the same connection.
			</p><p>
				The trade-off between using a shared queue and individual temporary queues for replies is influenced by the potential number of active client instances. With a shared-queue approach, at some provider-specific threshold, contention for access to the queue can become a concern. This has to be contrasted against the additional overhead associated with the provider creating queue storage at runtime and the impact on machine memory of hosting a potentially large number of temporary queues.
			</p><p>
				The following example creates a temporary queue and consumer for each client on startup. It sets the <code class="literal">JMSReplyTo</code> property on each message to the temporary queue, and then sets a correlation ID on each message to correlate request messages to response messages. This avoids the overhead of creating and closing a consumer for each request, which is expensive. The same producer and consumer can be shared or pooled across many threads. Any messages that have been received, but not yet acknowledged when the session terminates, are retained and redelivered when a consumer next accesses the queue.
			</p><div class="title"><strong>Example: Temporary Queue Code</strong></div><p>
					
</p><pre class="programlisting">...
// Create a temporary queue, one per client
Destination temporaryQueue = session.createTemporaryQueue();
MessageConsumer responseConsumer = session.createConsumer(temporaryQueue);

// This class handles messages to the temporary queue
responseConsumer.setMessageListener(this);

// Create the message to send
TextMessage textMessage = session.createTextMessage();
textMessage.setText("My new message!");

// Set the reply to field and correlation ID
textMessage.setJMSReplyTo(temporaryQueue);
textMessage.setJMSCorrelationID(myCorrelationID);

producer.send(textMessage);
...</pre><p>

				</p><p>
				In a similar manner, temporary topics are created using the <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/jms/Session.html#createTemporaryTopic--"><code class="literal">Session.createTemporaryTopic()</code></a> method.
			</p></div></body></html>