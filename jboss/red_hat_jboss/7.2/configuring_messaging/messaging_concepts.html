<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 1. Messaging Concepts</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="messaging_concepts"/>Chapter 1. Messaging Concepts</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_messaging_systems"/>Messaging Systems</h1></div></div></div><p>
					Messaging systems allow you to loosely couple heterogeneous systems together with added reliability. Unlike systems based on a Remote Procedure Call (RPC) pattern, messaging systems primarily use an asynchronous message passing pattern with no tight relationship between requests and responses. Most messaging systems are flexible enough to also support a request-response mode if needed, but this is not a primary feature of messaging systems.
				</p><p>
					Messaging systems decouple a message’s sender of messages from its consumers. In fact, the senders and consumers of messages are completely independent and know nothing of each other, which allows you to create flexible, loosely coupled systems. Large enterprises often use a messaging system to implement a message bus which loosely couples heterogeneous systems together. Message buses can form the core of an Enterprise Service Bus (ESB). Using a message bus to decouple disparate systems allows the system to grow and adapt more easily. It also allows more flexibility to add new systems or retire old ones since they do not have brittle dependencies on each other.
				</p><p>
					Messaging systems can also incorporate concepts such as delivery guarantees to ensure reliable messaging, transactions to aggregate the sending or consuming of multiple message as a single unit of work, and durability to allow messages to survive server failure or restart.
				</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="messaging_styles"/>Messaging Styles</h1></div></div></div><p>
					There are two kinds of messaging styles that most messaging systems support: the <span class="emphasis"><em>point-to-point</em></span> pattern and the <span class="emphasis"><em>publish-subscribe</em></span> pattern.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							Point-to-Point Pattern
						</p><p class="simpara">
							The point-to-point pattern involves sending a message to a single consumer listening on a queue. Once in the queue, the message is usually made persistent to guarantee delivery. Once the message has moved through the queue, the messaging system delivers it to a consumer. The consumer acknowledges the delivery of the message once it is processed. There can be multiple consumers listening on the same queue for the same message, but only one consumer will receive each message.
						</p></li><li class="listitem"><p class="simpara">
							Publish-Subscribe Pattern
						</p><p class="simpara">
							The publish-subscribe pattern allow senders to send messages to multiple consumers using a single destination. This destination is often known as a <span class="emphasis"><em>topic</em></span>. Each topic can have multiple consumers, or subscribers, and unlike point-to-point messaging, every subscriber receives any message published to the topic.
						</p><p class="simpara">
							Another interesting distinction is that subscribers can be durable. Durable subscriptions pass the server a unique identifier when connecting, which allows the server to identify and send any messages published to the topic since the last time the subscriber made a connection. Such messages are typically retained by the server even after a restart.
						</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about-jms"/>Java Messaging Service (JMS)</h1></div></div></div><p>
					The Java Messaging Service (JMS) 2.0 is defined in <a class="link" href="https://jcp.org/en/jsr/detail?id=343">JSR 343</a> and is a part of the Java EE specification. JMS is a Java API that provides both point-to-point and publish-subscriber messaging styles. JMS also incorporates the use of transactions. JMS does not define a standard wire format so while vendors of JMS providers may all use the standard APIs, they may use different internal wire protocols to communicate between their clients and servers.
				</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about-jms-destinations"/>JMS Destinations</h1></div></div></div><p>
					JMS destinations, along with JMS connection factories, are JMS administrative objects. Destinations are used by JMS clients for both producing and consuming messages. The destination allows the JMS client to specify the target when it produces messages and the source of messages when consuming messages. When using a publish-subscribe pattern, destinations are referred to as topics. When using a point-to-point pattern, destinations are referred to as queues.
				</p><p>
					Applications may use many different JMS destinations which are configured on the server side and usually accessed via JNDI.
				</p></div></div></body></html>