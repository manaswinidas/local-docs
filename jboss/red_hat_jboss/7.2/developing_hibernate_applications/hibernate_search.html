<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. Hibernate Search</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="hibernate_search"/>Chapter 7. Hibernate Search</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="getting_started_with_hibernate_search"/>Getting Started with Hibernate Search</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_hibernate_search"/>About Hibernate Search</h2></div></div></div><p>
					Hibernate Search provides full-text search capability to Hibernate applications. It is especially suited to search applications for which SQL-based solutions are not suited, including: full-text, fuzzy and geolocation searches. Hibernate Search uses Apache Lucene as its full-text search engine, but is designed to minimize the maintenance overhead. Once it is configured, indexing, clustering and data synchronization is maintained transparently, allowing you to focus on meeting your business requirements.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The prior release of JBoss EAP included Hibernate 4.2 and Hibernate Search 4.6. JBoss EAP 7 includes Hibernate 5 and Hibernate Search 5.5.
					</p><p>
						Hibernate Search 5.5 works with Java 7 and now builds upon Lucene 5.3.x. If you are using any native Lucene APIs make sure to align with this version.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="overview"/>Overview</h2></div></div></div><p>
					Hibernate Search consists of an indexing component as well as an index search component, both are backed by Apache Lucene. Each time an entity is inserted, updated or removed from the database, Hibernate Search keeps track of this event through the Hibernate event system and schedules an index update. All these updates are handled without having to interact with the Apache Lucene APIs directly. Instead, interaction with the underlying Lucene indexes is handled via an <code class="literal">IndexManager</code>. By default there is a one-to-one relationship between IndexManager and Lucene index. The IndexManager abstracts the specific index configuration, including the selected <span class="emphasis"><em>back end</em></span>, <span class="emphasis"><em>reader strategy</em></span> and the <span class="emphasis"><em>DirectoryProvider</em></span>.
				</p><p>
					Once the index is created, you can search for entities and return lists of managed entities instead of dealing with the underlying Lucene infrastructure. The same persistence context is shared between Hibernate and Hibernate Search. The <code class="literal">FullTextSession</code> class is built on top of the Hibernate <code class="literal">Session</code> class so that the application code can use the unified <code class="literal">org.hibernate.Query</code> or <code class="literal">javax.persistence.Query</code> APIs exactly the same way an HQL, JPA-QL, or native query would.
				</p><p>
					Transactional batching mode is recommended for all operations, whether or not they are JDBC-based.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						It is recommended, for both your database and Hibernate Search, to execute your operations in a transaction, whether it is JDBC or JTA.
					</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Hibernate Search works perfectly fine in the Hibernate or EntityManager long conversation pattern, known as atomic conversation.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_directory_provider"/>About the Directory Provider</h2></div></div></div><p>
					Apache Lucene, which is part of the Hibernate Search infrastructure, has the concept of a Directory for storage of indexes. Hibernate Search handles the initialization and configuration of a Lucene Directory instance via a <span class="emphasis"><em>Directory Provider</em></span>.
				</p><p>
					The <code class="literal">directory_provider</code> property specifies the directory provider to be used to store the indexes. The default file system directory provider is <code class="literal">filesystem</code>, which uses the local file system to store indexes.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_worker"/>About the Worker</h2></div></div></div><p>
					Updates to Lucene indexes are handled by the Hibernate Search <span class="emphasis"><em>Worker</em></span>, which receives all entity changes, queues them by context and applies them once a context ends. The most common context is the transaction, but may be dependent on the number of entity changes or some other application events.
				</p><p>
					For better efficiency, interactions are batched and generally applied once the context ends. Outside a transaction, the index update operation is executed right after the actual database operation. In the case of an ongoing transaction, the index update operation is scheduled for the transaction commit phase and discarded in case of transaction rollback. A worker may be configured with a specific batch size limit, after which indexing occurs regardless of the context.
				</p><p>
					There are two immediate benefits to this method of handling index updates:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Performance: Lucene indexing works better when operation are executed in batch.
						</li><li class="listitem">
							ACIDity: The work executed has the same scoping as the one executed by the database transaction and is executed if and only if the transaction is committed. This is not ACID in the strict sense, but ACID behavior is rarely useful for full text search indexes since they can be rebuilt from the source at any time.
						</li></ul></div><p>
					The two batch modes, no scope vs transactional, are the equivalent of autocommit versus transactional behavior. From a performance perspective, the <span class="emphasis"><em>transactional</em></span> mode is recommended. The scoping choice is made transparently. Hibernate Search detects the presence of a transaction and adjust the scoping.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="back_end_setup_and_operations"/>Back End Setup and Operations</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="back_end"/>Back End</h3></div></div></div><p>
						Hibernate Search uses various back ends to process batches of work. The back end is not limited to the configuration option <code class="literal">default.worker.backend</code>. This property specifies a implementation of the <code class="literal">BackendQueueProcessor</code> interface which is a part of a back-end configuration. Additional settings are required to set up a back-end, for example the JMS back-end.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="lucene"/>Lucene</h3></div></div></div><p>
						In the Lucene mode, all index updates for a node are executed by the same node to the Lucene directories using the directory providers. Use this mode in a non-clustered environment or in clustered environments with a shared directory store.
					</p><div class="figure"><a id="idm140403889873232"/><p class="title"><strong>Figure 7.1. Lucene Back-end Configuration</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/topics/images/1603.png" alt="Lucene Back-end Configuration"/></div></div></div><p>
						Lucene mode targets non-clustered or clustered applications where the directory manages the locking strategy. The primary advantage of Lucene mode is simplicity and immediate visibility of changes in Lucene queries. The Near Real Time (NRT) back end is an alternative back end for non-clustered and non-shared index configurations.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jms"/>JMS</h3></div></div></div><p>
						Index updates for a node are sent to the JMS queue. A unique reader processes the queue and updates the master index. The master index is subsequently replicated regularly to slave copies, to establish the master and slave pattern. The master is responsible for Lucene index updates. The slaves accept read and write operations but process read operations on local index copies. The master is solely responsible for updating the Lucene index. Only the master applies the local changes in an update operation.
					</p><div class="figure"><a id="idm140403889866128"/><p class="title"><strong>Figure 7.2. JMS Back-end Configuration</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/topics/images/1602.png" alt="JMS Back-end Configuration"/></div></div></div><p>
						This mode targets clustered environment where throughput is critical and index update delays are affordable. The JMS provider ensures reliability and uses the slaves to change the local index copies.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="reader_strategies"/>Reader Strategies</h2></div></div></div><p>
					When executing a query, Hibernate Search uses a reader strategy to interact with the Apache Lucene indexes. Choose a reader strategy based on the profile of the application like frequent updates, read mostly, asynchronous index update.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="the_shared_strategy"/>The Shared Strategy</h3></div></div></div><p>
						Using the <code class="literal">shared</code> strategy, Hibernate Search shares the same <code class="literal">IndexReader</code> for a given Lucene index across multiple queries and threads provided that the <code class="literal">IndexReader</code> remains updated. If the <code class="literal">IndexReader</code> is not updated, a new one is opened and provided. Each <code class="literal">IndexReader</code> is made of several <code class="literal">SegmentReaders</code>. The shared strategy reopens segments that have been modified or created after the last opening and shares the already loaded segments from the previous instance. This is the default strategy.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="the_not_shared_strategy"/>The Not-shared Strategy</h3></div></div></div><p>
						Using the <code class="literal">not-shared</code> strategy, a Lucene <code class="literal">IndexReader</code> opens every time a query executes. Opening and starting up a <code class="literal">IndexReader</code> is an expensive operation. As a result, opening an <code class="literal">IndexReader</code> for each query execution is not an efficient strategy.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="custom_reader_strategies"/>Custom Reader Strategies</h3></div></div></div><p>
						You can write a custom reader strategy using an implementation of <code class="literal">org.hibernate.search.reader.ReaderProvider</code>. The implementation must be thread safe.
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configuration_2"/>Configuration</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="minimum_configuration"/>Minimum Configuration</h2></div></div></div><p>
					Hibernate Search has been designed to provide flexibility in its configuration and operation, with default values carefully chosen to suit the majority of use cases. At a minimum a Directory Provider must be configured, along with its properties. The default Directory Provider is <code class="literal">filesystem</code>, which uses the local file system for index storage. For details of available Directory Providers and their configuration, see <a class="link" href="hibernate_search.html#directory_provider_configuration" title="DirectoryProvider Configuration">DirectoryProvider Configuration</a>.
				</p><p>
					If you are using Hibernate directly, settings such as the DirectoryProvider must be set in the configuration file, either <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. If you are using Hibernate via JPA, the configuration file is <code class="literal">persistence.xml</code>.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="configuring_indexmanager"/>Configuring the IndexManager</h2></div></div></div><p>
					Hibernate Search offers several implementations for this interface:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">directory-based</code>: the default implementation which uses the Lucene <code class="literal">Directory</code> abstraction to manage index files.
						</li><li class="listitem">
							<code class="literal">near-real-time</code>: avoids flushing writes to disk at each commit. This index manager is also <code class="literal">Directory</code> based, but uses Lucene’s near real-time, NRT, functionality.
						</li></ul></div><p>
					To specify an IndexManager other than the default, specify the following property:
				</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="directory_based"/>Directory-based</h3></div></div></div><p>
						The <code class="literal">Directory-based</code> implementation is the default <code class="literal">IndexManager</code> implementation. It is highly configurable and allows separate configurations for the reader strategy, back ends, and directory providers.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="near_real_time"/>Near Real Time</h3></div></div></div><p>
						The <code class="literal">NRTIndexManager</code> is an extension of the default <code class="literal">IndexManager</code> and leverages the Lucene NRT, Near Real Time, feature for low latency index writes. However, it ignores configuration settings for alternative back ends other than <code class="literal">lucene</code> and acquires exclusive write locks on the <code class="literal">Directory</code>.
					</p><p>
						The <code class="literal">IndexWriter</code> does not flush every change to the disk to provide low latency. Queries can read the updated states from the unflushed index writer buffers. However, this means that if the <code class="literal">IndexWriter</code> is killed or the application crashes, updates can be lost so the indexes must be rebuilt.
					</p><p>
						The Near Real Time configuration is recommended for non-clustered websites with limited data due to the mentioned disadvantages and because a master node can be individually configured for improved performance as well.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="custom"/>Custom</h3></div></div></div><p>
						Specify a fully qualified class name for the custom implementation to set up a customized <code class="literal">IndexManager</code>. Set up a no-argument constructor for the implementation as follows:
					</p><pre class="screen">[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre><p>
						The custom index manager implementation does not require the same components as the default implementations. For example, delegate to a remote indexing service which does not expose a <code class="literal">Directory</code> interface.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="directory_provider_configuration"/>DirectoryProvider Configuration</h2></div></div></div><p>
					A <code class="literal">DirectoryProvider</code> is the Hibernate Search abstraction around a Lucene <code class="literal">Directory</code> and handles the configuration and the initialization of the underlying Lucene resources. <a class="link" href="hibernate_search.html#directory_providers_and_properties" title="Directory Providers and Their Properties">Directory Providers and Their Properties</a> shows the list of the directory providers available in Hibernate Search together with their corresponding options.
				</p><p>
					Each indexed entity is associated with a Lucene index (except of the case where multiple entities share the same index). The name of the index is given by the <code class="literal">index</code> property of the <code class="literal">@Indexed</code> annotation. If the <code class="literal">index</code> property is not specified the fully qualified name of the indexed class will be used as name (recommended).
				</p><p>
					The DirectoryProvider and any additional options can be configured by using the prefix <code class="literal">hibernate.search.<span class="emphasis"><em>&lt;indexname&gt;</em></span></code>. The name <code class="literal">default</code> (<code class="literal">hibernate.search.default</code>) is reserved and can be used to define properties which apply to all indexes. <a class="link" href="hibernate_search.html#configuring_directory_providers" title="Configuring Directory Providers">Configuring Directory Providers</a> shows how <code class="literal">hibernate.search.default.directory_provider</code> is used to set the default directory provider to be the filesystem one. <code class="literal">hibernate.search.default.indexBase</code> sets then the default base directory for the indexes. As a result the index for the entity <code class="literal">Status</code> is created in <code class="literal">/usr/lucene/indexes/org.hibernate.example.Status</code>.
				</p><p>
					The index for the <code class="literal">Rule</code> entity, however, is using an in-memory directory, because the default directory provider for this entity is overridden by the property <code class="literal">hibernate.search.Rules.directory_provider</code>.
				</p><p>
					Finally the <code class="literal">Action</code> entity uses a custom directory provider <code class="literal">CustomDirectoryProvider</code> specified via <code class="literal">hibernate.search.Actions.directory_provider</code>.
				</p><p><a id="specifying_index_name"/></p><div class="title"><strong>Specifying the Index Name</strong></div><p>
						
</p><pre class="programlisting">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</pre><p>

					</p><p><a id="configuring_directory_providers"/></p><div class="title"><strong>Configuring Directory Providers</strong></div><p>
						
</p><pre class="screen">hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider = ram
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre><p>

					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Using the described configuration scheme you can easily define common rules like the directory provider and base directory, and override those defaults later on a per index basis.
					</p></div><h4><a id="directory_providers_and_properties"/>Directory Providers and Their Properties</h4><div class="variablelist"><dl class="variablelist"><dt><span class="term">ram </span></dt><dd>
								None
							</dd><dt><span class="term">filesystem </span></dt><dd><p class="simpara">
								File system based directory. The directory used will be &lt;indexBase&gt;/&lt; indexName &gt;
							</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										<span class="strong"><strong>indexBase</strong></span> : base directory
									</li><li class="listitem">
										<span class="strong"><strong>indexName</strong></span>: override @Indexed.index (useful for sharded indexes)
									</li><li class="listitem">
										<span class="strong"><strong>locking_strategy</strong></span> : optional, see <a class="link" href="hibernate_search.html#lockfactory_configuration" title="LockFactory Configuration">LockFactory Configuration</a>
									</li><li class="listitem">
										<span class="strong"><strong>filesystem_access_type</strong></span>: allows to determine the exact type of <code class="literal">FSDirectory</code> implementation used by this <code class="literal">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="literal">NIOFSDirectory</code> on non Windows systems, <code class="literal">SimpleFSDirectory</code> on Windows), <code class="literal">simple (SimpleFSDirectory)</code>, <code class="literal">nio (NIOFSDirectory)</code>, <code class="literal">mmap (MMapDirectory)</code>. See the Javadocs for these Directory implementations before changing this setting. Even though <code class="literal">NIOFSDirectory</code> or <code class="literal">MMapDirectory</code> can bring substantial performance boosts they also have their issues.
									</li></ul></div></dd><dt><span class="term"><code class="literal">filesystem-master</code></span></dt><dd><p class="simpara">
								File system based directory. Like <code class="literal">filesystem</code>. It also copies the index to a source directory (aka copy directory) on a regular basis.
							</p><p class="simpara">
								The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes).
							</p><p class="simpara">
								Note that the copy is based on an incremental copy mechanism reducing the average copy time.
							</p><p class="simpara">
								DirectoryProvider typically used on the master node in a JMS back end cluster.
							</p><p class="simpara">
								The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
							</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										<span class="strong"><strong>indexBase</strong></span>: base directory
									</li><li class="listitem">
										<span class="strong"><strong>indexName</strong></span>: override @Indexed.index (useful for sharded indexes)
									</li><li class="listitem">
										<span class="strong"><strong>sourceBase</strong></span>: source (copy) base directory.
									</li><li class="listitem">
										<span class="strong"><strong>source</strong></span>: source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="literal">&lt;sourceBase&gt;/&lt;source&gt;</code>
									</li><li class="listitem">
										<span class="strong"><strong>refresh</strong></span>: refresh period in seconds (the copy will take place every <span class="strong"><strong>refresh</strong></span> seconds). If a copy is still in progress when the following <span class="strong"><strong>refresh</strong></span> period elapses, the second copy operation will be skipped.
									</li><li class="listitem">
										<span class="strong"><strong>buffer_size_on_copy</strong></span>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
									</li><li class="listitem">
										<span class="strong"><strong>locking_strategy</strong></span> : optional, see <a class="link" href="hibernate_search.html#lockfactory_configuration" title="LockFactory Configuration">LockFactory Configuration</a>
									</li><li class="listitem">
										<span class="strong"><strong>filesystem_access_type</strong></span>: allows to determine the exact type of <code class="literal">FSDirectory</code> implementation used by this <code class="literal">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="literal">NIOFSDirectory</code> on non Windows systems, <code class="literal">SimpleFSDirectory</code> on Windows), <code class="literal">simple (SimpleFSDirectory)</code>, <code class="literal">nio (NIOFSDirectory)</code>, <code class="literal">mmap (MMapDirectory)</code>. See the Javadocs for these Directory implementations before changing this setting. Even though <code class="literal">NIOFSDirectory</code> or <code class="literal">MMapDirectory</code> can bring substantial performance boosts, there are also issues of which you need to be aware.
									</li></ul></div></dd><dt><span class="term"><code class="literal">filesystem-slave</code></span></dt><dd><p class="simpara">
								File system based directory. Like <code class="literal">filesystem</code>, but retrieves a master version (source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
							</p><p class="simpara">
								The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes).
							</p><p class="simpara">
								Note that the copy is based on an incremental copy mechanism reducing the average copy time. If a copy is still in progress when <span class="strong"><strong>refresh</strong></span> period elapses, the second copy operation will be skipped.
							</p><p class="simpara">
								DirectoryProvider typically used on slave nodes using a JMS back end.
							</p><p class="simpara">
								The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
							</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										<span class="strong"><strong>indexBase</strong></span>: Base directory
									</li><li class="listitem">
										<span class="strong"><strong>indexName</strong></span>: override @Indexed.index (useful for sharded indexes)
									</li><li class="listitem">
										<span class="strong"><strong>sourceBase</strong></span>: Source (copy) base directory.
									</li><li class="listitem">
										<span class="strong"><strong>source</strong></span>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="literal">&lt;sourceBase&gt;/&lt;source&gt;</code>
									</li><li class="listitem">
										<span class="strong"><strong>refresh</strong></span>: refresh period in second (the copy will take place every refresh seconds).
									</li><li class="listitem">
										<span class="strong"><strong>buffer_size_on_copy</strong></span>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
									</li><li class="listitem">
										<span class="strong"><strong>locking_strategy</strong></span> : optional, see <a class="link" href="hibernate_search.html#lockfactory_configuration" title="LockFactory Configuration">LockFactory Configuration</a>
									</li><li class="listitem">
										<span class="strong"><strong>retry_marker_lookup</strong></span> : optional, default to 0. Defines how many times Hibernate Search checks for the marker files in the source directory before failing. Waiting 5 seconds between each try.
									</li><li class="listitem">
										<span class="strong"><strong>retry_initialize_period</strong></span> : optional, set an integer value in seconds to enable the retry initialize feature: if the slave cannot find the master index it will try again until it is found in background, without preventing the application to start: fullText queries performed before the index is initialized are not blocked but will return empty results. When not enabling the option or explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer. To prevent the application from starting without an invalid index but still control an initialization timeout, see <code class="literal">retry_marker_lookup</code> instead.
									</li><li class="listitem">
										<span class="strong"><strong>filesystem_access_type</strong></span>: allows to determine the exact type of <code class="literal">FSDirectory</code> implementation used by this <code class="literal">DirectoryProvider</code>. Allowed values are auto (the default value, selects <code class="literal">NIOFSDirectory</code> on non Windows systems, <code class="literal">SimpleFSDirectory</code> on Windows), <code class="literal">simple (SimpleFSDirectory)</code>, <code class="literal">nio (NIOFSDirectory)</code>, <code class="literal">mmap (MMapDirectory)</code>. See the Javadocs for these Directory implementations before changing this setting. Even though <code class="literal">NIOFSDirectory</code> or <code class="literal">MMapDirectory</code> can bring substantial performance boosts you need also to be aware of the issues.
									</li></ul></div></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						If the built-in directory providers do not fit your needs, you can write your own directory provider by implementing the <code class="literal">org.hibernate.store.DirectoryProvider</code> interface. In this case, pass the fully qualified class name of your provider into the <code class="literal">directory_provider</code> property. You can pass any additional properties using the prefix <code class="literal">hibernate.search.<span class="emphasis"><em>&lt;indexname&gt;</em></span></code>.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="worker_configuration"/>Worker Configuration</h2></div></div></div><p>
					It is possible to refine how Hibernate Search interacts with Lucene through the worker configuration. There exist several architectural components and possible extension points. Let’s have a closer look.
				</p><p>
					Use the worker configuration to refine how Infinispan Query interacts with Lucene. Several architectural components and possible extension points are available for this configuration.
				</p><p>
					First there is a <code class="literal">Worker</code>. An implementation of the <code class="literal">Worker</code> interface is responsible for receiving all entity changes, queuing them by context and applying them once a context ends. The most intuitive context, especially in connection with ORM, is the transaction. For this reason Hibernate Search will per default use the <code class="literal">TransactionalWorker</code> to scope all changes per transaction. One can, however, imagine a scenario where the context depends for example on the number of entity changes or some other application lifecycle events.
				</p><div class="table"><a id="table_scope_configuration"/><p class="title"><strong>Table 7.1. Scope Configuration</strong></p><div class="table-contents"><table summary="Scope Configuration" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top"><span class="strong"><strong>Property</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.worker.scope</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The fully qualified class name of the <code class="literal">Worker</code> implementation to use. If this property is not set, empty or <code class="literal">transaction</code> the default <code class="literal">TransactionalWorker</code> is used.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.worker.*</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									All configuration properties prefixed with <code class="literal">hibernate.search.worker</code> are passed to the Worker during initialization. This allows adding custom, worker specific parameters.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.worker.batch_size</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Defines the maximum number of indexing operation batched per context. Once the limit is reached indexing will be triggered even though the context has not ended yet. This property only works if the <code class="literal">Worker</code> implementation delegates the queued work to BatchedQueueingProcessor, which is what the <code class="literal">TransactionalWorker</code> does.
								</p>
								 </td></tr></tbody></table></div></div><p>
					Once a context ends it is time to prepare and apply the index changes. This can be done synchronously or asynchronously from within a new thread. Synchronous updates have the advantage that the index is at all times in sync with the databases. Asynchronous updates, on the other hand, can help to minimize the user response time. The drawback is potential discrepancies between database and index states.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The following options can be different on each index; in fact they need the indexName prefix or use <code class="literal">default</code> to set the default value for all indexes.
					</p></div><div class="table"><a id="table_execution_configuration"/><p class="title"><strong>Table 7.2. Execution Configuration</strong></p><div class="table-contents"><table summary="Execution Configuration" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top"><span class="strong"><strong>Property</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.execution</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									<code class="literal">sync</code>: synchronous execution (default)
								</p>
								 <p>
									<code class="literal">async</code>: asynchronous execution
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.thread_pool.size</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The back end can apply updates from the same transaction context (or batch) in parallel, using a thread pool. The default value is 1. You can experiment with larger values if you have many operations per transaction.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.buffer_queue.max</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Defines the maximal number of work queue if the thread pool is starved. Useful only for asynchronous execution. Default to infinite. If the limit is reached, the work is done by the main thread.
								</p>
								 </td></tr></tbody></table></div></div><p>
					So far all work is done within the same virtual machine (VM), no matter which execution mode. The total amount of work has not changed for the single VM. Luckily there is a better approach, namely delegation. It is possible to send the indexing work to a different server by configuring <code class="literal">hibernate.search.default.worker.backend</code>. Again this option can be configured differently for each index.
				</p><div class="table"><a id="table_backend_configuration"/><p class="title"><strong>Table 7.3. Back-end Configuration</strong></p><div class="table-contents"><table summary="Back-end Configuration" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top"><span class="strong"><strong>Property</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.backend</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									<code class="literal">lucene</code>: The default back end which runs index updates in the same VM. Also used when the property is undefined or empty.
								</p>
								 <p>
									<code class="literal">jms</code>: JMS back end. Index updates are send to a JMS queue to be processed by an indexing master. See <a class="link" href="hibernate_search.html#table_jms_backend_configuration" title="Table 7.4. JMS Back-end Configuration">JMS Back-end Configuration</a> for additional configuration options and for a more detailed description of this setup.
								</p>
								 <p>
									<code class="literal">blackhole</code>: Mainly a test/developer setting which ignores all indexing work
								</p>
								 <p>
									You can also specify the fully qualified name of a class implementing <code class="literal">BackendQueueProcessor</code>. This way you can implement your own communication layer. The implementation is responsible for returning a <code class="literal">Runnable</code> instance which on execution will process the index work.
								</p>
								 </td></tr></tbody></table></div></div><div class="table"><a id="table_jms_backend_configuration"/><p class="title"><strong>Table 7.4. JMS Back-end Configuration</strong></p><div class="table-contents"><table summary="JMS Back-end Configuration" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Property</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.jndi.*</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Defines the JNDI properties to initiate the InitialContext, if necessary. JNDI is only used by the JMS back end.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.jms.connection_factory</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS connection factory from (<code class="literal">/ConnectionFactory</code> by default in Red Hat JBoss Enterprise Application Platform)
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.jms.queue</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS queue from. The queue will be used to post work messages.
								</p>
								 </td></tr></tbody></table></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						As you probably noticed, some of the shown properties are correlated which means that not all combinations of property values make sense. In fact you can end up with a non-functional configuration. This is especially true for the case that you provide your own implementations of some of the shown interfaces. Make sure to study the existing code before you write your own <code class="literal">Worker</code> or <code class="literal">BackendQueueProcessor</code> implementation.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jms_master_slave_back_end"/>JMS Master/Slave Back End</h3></div></div></div><p>
						This section describes in greater detail how to configure the master/slave Hibernate Search architecture.
					</p><div class="figure"><a id="idm140404004991360"/><p class="title"><strong>Figure 7.3. JMS Backend Configuration</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/topics/images/1602.png" alt="JMS Backend Configuration"/></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="slave_nodes"/>Slave Nodes</h3></div></div></div><p>
						Every index update operation is sent to a JMS queue. Index querying operations are executed on a local index copy.
					</p><div class="title"><strong>JMS Slave Configuration</strong></div><p>
							
</p><pre class="screen">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Back-end configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.default.worker.execution = async
# hibernate.search.default.worker.thread_pool.size = 2
# hibernate.search.default.worker.buffer_queue.max = 50</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							A file system local copy is recommended for faster search results.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="master_node"/>Master Node</h3></div></div></div><p>
						Every index update operation is taken from a JMS queue and executed. The master index is copied on a regular basis.
					</p><p>
						Index update operations in the JMS queue are executed and the master index is copied regularly.
					</p><div class="title"><strong>JMS Master Configuration</strong></div><p>
							
</p><pre class="screen">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Back-end configuration
#Back-end is the default for Lucene</pre><p>

						</p><p>
						In addition to the Hibernate Search framework configuration, a message-driven bean has to be written and set up to process the index works queue through JMS.
					</p><div class="title"><strong>Message-driven Bean Processing the Indexing Queue</strong></div><p>
							
</p><pre class="programlisting">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType",
                                propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination",
                                propertyValue="queue/hibernatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController
                                 implements MessageListener {
    @PersistenceContext EntityManager em;

    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session)
    }
}</pre><p>

						</p><p>
						This example inherits from the abstract JMS controller class available in the Hibernate Search source code and implements a Java EE MDB. This implementation is given as an example and can be adjusted to make use of non Java EE message-driven beans.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="tuning_lucene_indexing"/>Tuning Lucene Indexing</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="tuning_lucene_indexing_performance"/>Tuning Lucene Indexing Performance</h3></div></div></div><p>
						Hibernate Search is used to tune the Lucene indexing performance by specifying a set of parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code>, and <code class="literal">maxBufferedDocs</code>. Specify these parameters either as default values applying for all indexes, on a per index basis, or even per shard.
					</p><p>
						There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases. These parameters are grouped by the <code class="literal">indexwriter</code> keyword:
					</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre><p>
						If no value is set for an <code class="literal">indexwriter</code> value in a specific shard configuration, Hibernate Search checks the index section, then at the default section.
					</p><p>
						The configuration in the following table will result in these settings applied on the second shard of the <code class="literal">Animal</code> index:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">max_merge_docs</code> = 10
							</li><li class="listitem">
								<code class="literal">merge_factor</code> = 20
							</li><li class="listitem">
								<code class="literal">ram_buffer_size</code> = 64MB
							</li><li class="listitem">
								<code class="literal">term_index_interval</code> = Lucene default
							</li></ul></div><p>
						All other values will use the defaults defined in Lucene.
					</p><p>
						The default for all values is to leave them at Lucene’s own default. The values listed in <a class="link" href="hibernate_search.html#table_performance_parameters" title="Table 7.5. Indexing Performance and Behavior Properties">Indexing Performance and Behavior Properties</a> depend for this reason on the version of Lucene you are using. The values shown are relative to version <code class="literal">2.4</code>.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Previous versions of Hibernate Search had the notion of <code class="literal">batch</code> and <code class="literal">transaction</code> properties. This is no longer the case as the back end will always perform work using the same settings.
						</p></div><div class="table"><a id="table_performance_parameters"/><p class="title"><strong>Table 7.5. Indexing Performance and Behavior Properties</strong></p><div class="table-contents"><table summary="Indexing Performance and Behavior Properties" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top"><span class="strong"><strong>Property</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Description</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].​exclusive_index_use</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Set to <code class="literal">true</code> when no other process will need to write to the same index. This enables Hibernate Search to work in exclusive mode on the index and improve performance when writing changes to the index.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">true</code> (improved performance, releases locks only at shutdown)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].max_queue_length</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Each index has a separate "pipeline" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting does not make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">1000</code>
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_delete_terms</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Unlimited (Integer.MAX_VALUE)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										10
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size. Segments smaller than this size (in MB) are always considered for the next segment merge operation. Setting this too large might result in expensive merge operations, even though they are less frequent. See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										0 MB (actually ~1K)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_max_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are never merged in bigger segments.
									</p>
									 <p>
										This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored.
									</p>
									 <p>
										See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Set to <code class="literal">false</code> to not consider deleted documents when estimating the merge policy.
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">true</code>
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
									</p>
									 <p>
										Generally for faster indexing performance it is best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										16 MB
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Set the interval between indexed terms.
									</p>
									 <p>
										Large values cause less memory to be used by IndexReader, but slow random-access to terms.Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										128
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.use_compound_file</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										true
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">hibernate.search.​enable_dirty_check</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Not all entity changes require a Lucene index update. If all of the updated entity properties (dirty properties) are not indexed, Hibernate Search skips the re-indexing process.
									</p>
									 <p>
										Disable this option if you use custom <code class="literal">FieldBridges</code> which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed).
									</p>
									 <p>
										This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										true
									</p>
									 </td></tr></tbody></table></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							The <code class="literal">blackhole</code> back end is not meant to be used in production, only as a tool to identify indexing bottlenecks.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="the_lucene_indexwriter"/>The Lucene IndexWriter</h3></div></div></div><p>
						There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases. These parameters are grouped by the <code class="literal">indexwriter</code> keyword:
					</p><pre class="screen">default.&lt;indexname&gt;.indexwriter.&lt;parameter_name&gt;</pre><p>
						If no value is set for <code class="literal">indexwriter</code> in a shard configuration, Hibernate Search looks at the index section and then at the default section.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="performance_option_configuration"/>Performance Option Configuration</h3></div></div></div><p>
						The following configuration will result in these settings being applied on the second shard of the <code class="literal">Animal</code> index:
					</p><div class="title"><strong>Example performance option configuration</strong></div><p>
							
</p><pre class="screen">default.Animals.2.indexwriter.max_merge_docs = 10
default.Animals.2.indexwriter.merge_factor = 20
default.Animals.2.indexwriter.term_index_interval = default
default.indexwriter.max_merge_docs = 100
default.indexwriter.ram_buffer_size = 64</pre><p>

						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">max_merge_docs</code> = 10
							</li><li class="listitem">
								<code class="literal">merge_factor</code> = 20
							</li><li class="listitem">
								<code class="literal">ram_buffer_size</code> = 64MB
							</li><li class="listitem">
								<code class="literal">term_index_interval</code> = Lucene default
							</li></ul></div><p>
						All other values will use the defaults defined in Lucene.
					</p><p>
						The Lucene default values are the default setting for Hibernate Search. Therefore, the values listed in the following table depend on the version of Lucene being used. The values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performance, see the Lucene documentation.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The back end will always perform work using the same settings.
						</p></div><div class="table"><a id="idm140403995067088"/><p class="title"><strong>Table 7.6. Indexing Performance and Behavior Properties</strong></p><div class="table-contents"><table summary="Indexing Performance and Behavior Properties" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top"><span class="strong"><strong>Property</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Description</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.exclusive_index_use</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Set to <code class="literal">true</code> when no other process will need to write to the same index. This enables Hibernate Search to work in exclusive mode on the index and improve performance when writing changes to the index.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">true</code> (improved performance, releases locks only at shutdown)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.max_queue_length</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Each index has a separate "pipeline" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting does not make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">1000</code>
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.max_buffered_delete_terms</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.max_buffered_docs</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.max_merge_docs</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Unlimited (Integer.MAX_VALUE)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_factor</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										10
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_min_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments smaller than this size (in MB) are always considered for the next segment merge operation.
									</p>
									 <p>
										Setting this too large might result in expensive merge operations, even though they are less frequent.
									</p>
									 <p>
										See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										0 MB (actually ~1K)
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_max_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are never merged in bigger segments.
									</p>
									 <p>
										This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored.
									</p>
									 <p>
										See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_max_optimize_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_calibrate_by_deletes</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Set to <code class="literal">false</code> to not consider deleted documents when estimating the merge policy.
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">true</code>
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.ram_buffer_size</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
									</p>
									 <p>
										Generally for faster indexing performance it is best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										16 MB
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.term_index_interval</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Set the interval between indexed terms.
									</p>
									 <p>
										Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										128
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.use_compound_file</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										true
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										<code class="literal">default.enable_dirty_check</code>
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Not all entity changes require a Lucene index update. If all of the updated entity properties (dirty properties) are not indexed, Hibernate Search skips the re-indexing process.
									</p>
									 <p>
										Disable this option if you use custom <code class="literal">FieldBridges</code> which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed).
									</p>
									 <p>
										This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										true
									</p>
									 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="tuning_the_indexing_speed"/>Tuning the Indexing Speed</h3></div></div></div><p>
						When the architecture permits it, keep <code class="literal">default.exclusive_index_use=true</code> for improved index writing efficiency.
					</p><p>
						When tuning indexing speed the recommended approach is to focus first on optimizing the object loading, and then use the timings you achieve as a baseline to tune the indexing process. Set the <code class="literal">blackhole</code> as worker back end and start your indexing routines. This back end does not disable Hibernate Search. It generates the required change sets to the index, but discards them instead of flushing them to the index. In contrast to setting the <code class="literal">hibernate.search.indexing_strategy</code> to <code class="literal">manual</code>, using <code class="literal">blackhole</code> will possibly load more data from the database because associated entities are re-indexed as well.
					</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							The <code class="literal">blackhole</code> back end is not to be used in production, only as a diagnostic tool to identify indexing bottlenecks.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="control_segment_size"/>Control Segment Size</h3></div></div></div><p>
						The following options configure the maximum size of segments created:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">merge_max_size</code>
							</li><li class="listitem">
								<code class="literal">merge_max_optimize_size</code>
							</li><li class="listitem">
								<code class="literal">merge_calibrate_by_deletes</code>
							</li></ul></div><div class="title"><strong>Control Segment Size</strong></div><p>
							
</p><pre class="screen">//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre><p>

						</p><p>
						Set the <code class="literal">max_size</code> for merge operations to less than half of the hard limit segment size, as merging segments combines two segments into one larger segment.
					</p><p>
						A new segment may initially be a larger size than expected, however a segment is never created significantly larger than the <code class="literal">ram_buffer_size</code>. This threshold is checked as an estimate.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="lockfactory_configuration"/>LockFactory Configuration</h2></div></div></div><p>
					The Lucene Directory can be configured with a custom locking strategy via <code class="literal">LockingFactory</code> for each index managed by Hibernate Search.
				</p><p>
					Some locking strategies require a filesystem level lock, and may be used on RAM-based indexes. When using this strategy the <code class="literal">IndexBase</code> configuration option must be specified to point to a filesystem location in which to store the lock marker files.
				</p><p>
					To select a locking factory, set the <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option to one the following options:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<span class="emphasis"><em>simple</em></span>
						</li><li class="listitem">
							<span class="emphasis"><em>native</em></span>
						</li><li class="listitem">
							<span class="emphasis"><em>single</em></span>
						</li><li class="listitem">
							<span class="emphasis"><em>none</em></span>
						</li></ul></div><div class="table"><a id="idm140404011367904"/><p class="title"><strong>Table 7.7. List of Available LockFactory Implementations</strong></p><div class="table-contents"><table summary="List of Available LockFactory Implementations" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top"><span class="strong"><strong>Name</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Class</strong></span></th><th style="text-align: left" valign="top"><span class="strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									LockFactory Configuration <code class="literal">simple</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									org.apache.lucene.store.​SimpleFSLockFactory
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Safe implementation based on Java’s File API, it marks the usage of the index by creating a marker file.
								</p>
								 <p>
									If for some reason you had to kill your application, you will need to remove this file before restarting it.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">native</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									org.apache.lucene.store.​NativeFSLockFactory
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if the JVM is terminated the locks will be cleaned up.
								</p>
								 <p>
									This implementation has known problems on NFS, avoid it on network shares.
								</p>
								 <p>
									<code class="literal">native</code> is the default implementation for the <code class="literal">filesystem</code>, <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code> directory providers.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">single</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									org.apache.lucene.store.​SingleInstanceLockFactory
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This LockFactory does not use a file marker but is a Java object lock held in memory; therefore it is possible to use it only when you are sure the index is not going to be shared by any other process.
								</p>
								 <p>
									This is the default implementation for the <code class="literal">ram</code> directory provider.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">none</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									org.apache.lucene.store.​NoLockFactory
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Changes to this index are not coordinated by a lock.
								</p>
								 </td></tr></tbody></table></div></div><p>
					The following is an example of locking strategy configuration:
				</p><pre class="screen">hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="index_format_compatibility"/>Index Format Compatibility</h2></div></div></div><p>
					Hibernate Search does not currently offer a backwards compatible API or tool to facilitate porting applications to newer versions. The API uses Apache Lucene for index writing and searching. Occasionally an update to the index format may be required. In this case, there is a possibility that data will need to be re-indexed if Lucene is unable to read the old format.
				</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Back up indexes before attempting to update the index format.
					</p></div><p>
					Hibernate Search exposes the <code class="literal">hibernate.search.lucene_version</code> configuration property. This property instructs Analyzers and other Lucene classes to conform to their behavior as defined in an older version of Lucene. See also <code class="literal">org.apache.lucene.util.Version</code> contained in the <code class="literal">lucene-core.jar</code>. If the option is not specified, Hibernate Search instructs Lucene to use the version default. It is recommended that the version used is explicitly defined in the configuration to prevent automatic changes when an upgrade occurs. After an upgrade, the configuration values can be updated explicitly if required.
				</p><div class="title"><strong>Force Analyzers to Be Compatible with a Lucene 3.0 Created Index</strong></div><p>
						
</p><pre class="screen">hibernate.search.lucene_version = LUCENE_30</pre><p>

					</p><p>
					The configured <code class="literal">SearchFactory</code> is global and affects all Lucene APIs that contain the relevant parameter. If Lucene is used and Hibernate Search is bypassed, apply the same value to it for consistent results.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="hibernate_search_for_your_application"/>Hibernate Search for Your Application</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="first_steps_with_hibernate_search"/>First Steps with Hibernate Search</h2></div></div></div><p>
					To get started with Hibernate Search for your application, follow these topics.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="hibernate_search.html#enable_hibernate_search_using_maven" title="Enable Hibernate Search Using Maven">Enable Hibernate Search Using Maven</a>
						</li><li class="listitem">
							<a class="link" href="hibernate_search.html#indexing" title="Indexing">Indexing</a>
						</li><li class="listitem">
							<a class="link" href="hibernate_search.html#searching" title="Searching">Searching</a>
						</li><li class="listitem">
							<a class="link" href="hibernate_search.html#analyzer" title="Analyzer">Analyzer</a>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="enable_hibernate_search_using_maven"/>Enable Hibernate Search Using Maven</h2></div></div></div><p>
					Use the following configuration in your Maven project to add <code class="literal">hibernate-search-orm</code> dependencies:
				</p><pre class="programlisting">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
      &lt;version&gt;5.5.1.Final-redhat-1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="add_annotations"/>Add Annotations</h2></div></div></div><p>
					For this section, consider the example in which you have a database containing details of books. Your application contains the Hibernate managed classes <code class="literal">example.Book</code> and <code class="literal">example.Author</code> and you want to add free text search capabilities to your application to enable searching for books.
				</p><div class="title"><strong>Example: Entities Book and Author Before Adding Hibernate Search Specific Annotations</strong></div><p>
						
</p><pre class="programlisting">package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;

  public Book() {}

  // standard getters/setters follow here
  ...
}</pre><p>

					</p><pre class="programlisting">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {}

  // standard getters/setters follow here
  ...
}</pre><p>
					To achieve this you have to add a few annotations to the Book and Author class. The first annotation <code class="literal">@Indexed</code> marks Book as indexable. By design Hibernate Search stores an untokenized ID in the index to ensure index unicity for a given entity. <code class="literal">@DocumentId</code> marks the property to use for this purpose and is in most cases the same as the database primary key. The <code class="literal">@DocumentId</code> annotation is optional in the case where an <code class="literal">@Id</code> annotation exists.
				</p><p>
					Next the fields you want to make searchable must be marked as such. In this example, start with <code class="literal">title</code> and <code class="literal">subtitle</code> and annotate both with <code class="literal">@Field</code>. The parameter <code class="literal">index=Index.YES</code> will ensure that the text will be indexed, while <code class="literal">analyze=Analyze.YES</code> ensures that the text will be analyzed using the default Lucene analyzer. Usually, analyzing means chunking a sentence into individual words and potentially excluding common words like <code class="literal">'a'</code> or ‘the’. We will talk more about analyzers a little later on. The third parameter we specify within <code class="literal">@Field</code>, <code class="literal">store=Store.NO</code>, ensures that the actual data will not be stored in the index. Whether this data is stored in the index or not has nothing to do with the ability to search for it. From Lucene’s perspective it is not necessary to keep the data once the index is created. The benefit of storing it is the ability to retrieve it via <a class="link" href="hibernate_search.html#projection" title="Projection">projections</a>.
				</p><p>
					Without projections, Hibernate Search will per default execute a Lucene query in order to find the database identifiers of the entities matching the query criteria and use these identifiers to retrieve managed objects from the database. The decision for or against projection has to be made on a case to case basis. The default behavior is recommended since it returns managed objects whereas projections only return object arrays. Note that <code class="literal">index=Index.YES</code>, <code class="literal">analyze=Analyze.YES</code> and <code class="literal">store=Store.NO</code> are the default values for these parameters and could be omitted.
				</p><p>
					Another annotation not yet discussed is <code class="literal">@DateBridge</code>. This annotation is one of the built-in field bridges in Hibernate Search. The Lucene index is purely string based. For this reason Hibernate Search must convert the data types of the indexed fields to strings and vice-versa. A range of predefined bridges are provided, including the DateBridge which will convert a java.util.Date into a String with the specified resolution. For more details see <a class="link" href="hibernate_search.html#bridges" title="Bridges">Bridges</a>.
				</p><p>
					This leaves us with <code class="literal">@IndexedEmbedded</code>. This annotation is used to index associated entities (<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code>, <code class="literal">@Embedded</code> and <code class="literal">@ElementCollection</code>) as part of the owning entity. This is needed since a Lucene index document is a flat data structure which does not know anything about object relations. To ensure that the authors' name will be searchable you have to ensure that the names are indexed as part of the book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also have to mark all fields of the associated entity you want to have included in the index with <code class="literal">@Indexed</code>. For more details see <a class="link" href="hibernate_search.html#embedded_and_associated_objects" title="Embedded and Associated Objects">Embedded and Associated Objects</a>.
				</p><p>
					These settings should be sufficient for now. For more details on entity mapping see <a class="link" href="hibernate_search.html#mapping_an_entity" title="Mapping an Entity">Mapping an Entity</a>.
				</p><div class="title"><strong>Example: Entities After Adding Hibernate Search Annotations</strong></div><p>
						
</p><pre class="programlisting">package example;
...
@Entity

public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @Field(index = Index.YES, analyze=Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</pre><p>

					</p><pre class="programlisting">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {
  }

  // standard getters/setters follow here
  ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="indexing"/>Indexing</h2></div></div></div><p>
					Hibernate Search will transparently index every entity persisted, updated or removed through Hibernate Core. However, you have to create an initial Lucene index for the data already present in your database. Once you have added the above properties and annotations it is time to trigger an initial batch index of your books. You can achieve this by using one of the following code snippets (see also ):
				</p><div class="title"><strong>Example: Using the Hibernate Session to Index Data</strong></div><p>
						
</p><pre class="programlisting">FullTextSession fullTextSession = org.hibernate.search.Search.getFullTextSession(session);
fullTextSession.createIndexer().startAndWait();</pre><p>

					</p><div class="title"><strong>Example: Using JPA to Index Data</strong></div><p>
						
</p><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
fullTextEntityManager.createIndexer().startAndWait();</pre><p>

					</p><p>
					After executing the above code, you should be able to see a Lucene index under <code class="literal">/var/lucene/indexes/example.Book</code>. Inspect this index with <a class="link" href="http://code.google.com/p/luke/">Luke</a> to help you to understand how Hibernate Search works.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="searching"/>Searching</h2></div></div></div><p>
					To execute a search, create a Lucene query using either the <a class="link" href="hibernate_search.html#building_a_lucene_query_using_the_lucene_api" title="Building a Lucene Query Using the Lucene API">Lucene API</a> or the <a class="link" href="hibernate_search.html#building_a_lucene_query" title="Building a Lucene Query">Hibernate Search query DSL</a>. Wrap the query in a org.hibernate.Query to get the required functionality from the Hibernate API. The following code prepares a query against the indexed fields. Executing the code returns a list of Books.
				</p><div class="title"><strong>Example: Using a Hibernate Search Session to Create and Execute a Search</strong></div><p>
						
</p><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity( Book.class ).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name", "publicationDate")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery =
    fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();

tx.commit();
session.close();</pre><p>

					</p><div class="title"><strong>Example: Using JPA to Create and Execute a Search</strong></div><p>
						
</p><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Book.class ).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name", "publicationDate")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery =
    fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="analyzer"/>Analyzer</h2></div></div></div><p>
					Assuming that the title of an indexed book entity is <code class="literal">Refactoring: Improving the Design of Existing Code</code> and that hits are required for the following queries: <code class="literal">refactor</code>, <code class="literal">refactors</code>, <code class="literal">refactored</code>, and <code class="literal">refactoring</code>. Select an analyzer class in Lucene that applies word stemming when indexing and searching. Hibernate Search offers several ways to configure the analyzer (see <a class="link" href="hibernate_search.html#default_analyzer_and_analyzer_by_class" title="Default Analyzer and Analyzer by Class">Default Analyzer and Analyzer by Class</a> for more information):
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Set the <code class="literal">analyzer</code> property in the configuration file. The specified class becomes the default analyzer.
						</li><li class="listitem">
							Set the <code class="literal">@Analyzer</code> annotation at the entity level.
						</li><li class="listitem">
							Set the <code class="literal">@Analyzer</code> annotation at the field level.
						</li></ul></div><p>
					Specify the fully qualified class name or the analyzer to use, or see an analyzer defined by the <code class="literal">@AnalyzerDef</code> annotation with the <code class="literal">@Analyzer</code> annotation. The Solr analyzer framework with its factories are utilized for the latter option. For more information about factory classes, see the Solr JavaDoc or read the corresponding section on the <a class="link" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">Solr Wiki</a>.
				</p><p>
					In the example, a StandardTokenizerFactory is used by two filter factories: LowerCaseFilterFactory and SnowballPorterFilterFactory. The tokenizer splits words at punctuation characters and hyphens but keeping email addresses and internet hostnames intact. The standard tokenizer is ideal for this and other general operations. The lowercase filter converts all letters in the token into lowercase and the snowball filter applies language specific stemming.
				</p><p>
					If using the Solr framework, use the tokenizer with an arbitrary number of filters.
				</p><div class="title"><strong>Example: Using @AnalyzerDef and the Solr Framework to Define and Use an Analyzer</strong></div><p>
						
</p><pre class="programlisting">@Indexed
@AnalyzerDef(
   name = "customanalyzer",
   tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
   filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = SnowballPorterFilterFactory.class,
         params = { @Parameter(name = "language", value = "English") })
 })
public class Book implements Serializable {

  @Field
  @Analyzer(definition = "customanalyzer")
  private String title;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String subtitle;

  @IndexedEmbedded
  private Set authors = new HashSet();

  @Field(index = Index.YES, analyze = Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</pre><p>

					</p><p>
					Use @AnalyzerDef to define an analyzer, then apply it to entities and properties using @Analyzer. In the example, the <code class="literal">customanalyzer</code> is defined but not applied on the entity. The analyzer is only applied to the <code class="literal">title</code> and <code class="literal">subtitle</code> properties. An analyzer definition is global. Define the analyzer for an entity and reuse the definition for other entities as required.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="mapping_entities_to_the_index_structure"/>Mapping Entities to the Index Structure</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="mapping_an_entity"/>Mapping an Entity</h2></div></div></div><p>
					All the metadata information required to index entities is described through annotations, so there is no need for XML mapping files. You can still use Hibernate mapping files for the basic Hibernate configuration, but the Hibernate Search specific configuration has to be expressed via annotations.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="basic_mapping"/>Basic Mapping</h3></div></div></div><p>
						Let us start with the most commonly used annotations for mapping an entity.
					</p><p>
						The Lucene-based Query API uses the following common annotations to map entities:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								@Indexed
							</li><li class="listitem">
								@Field
							</li><li class="listitem">
								@NumericField
							</li><li class="listitem">
								@Id
							</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="indexed"/>@Indexed</h3></div></div></div><p>
						Foremost we must declare a persistent class as indexable. This is done by annotating the class with <code class="literal">@Indexed</code> (all entities not annotated with <code class="literal">@Indexed</code> will be ignored by the indexing process):
					</p><pre class="programlisting">@Entity
@Indexed
public class Essay {
...
}</pre><p>
						You can optionally specify the <code class="literal">index</code> attribute of the @Indexed annotation to change the default name of the index.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="field"/>@Field</h3></div></div></div><p>
						For each property (or attribute) of your entity, you have the ability to describe how it will be indexed. The default (no annotation present) means that the property is ignored by the indexing process.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Prior to Hibernate Search 5, numeric field encoding was only chosen if explicitly requested via <code class="literal">@NumericField</code>. As of Hibernate Search 5 this encoding is automatically chosen for numeric types. To avoid numeric encoding you can explicitly specify a non numeric field bridge via <code class="literal">@Field.bridge</code> or <code class="literal">@FieldBridge</code>. The package <code class="literal">org.hibernate.search.bridge.builtin</code> contains a set of bridges which encode numbers as strings, for example <code class="literal">org.hibernate.search.bridge.builtin.IntegerBridge</code>.
						</p></div><p>
						<code class="literal">@Field</code> does declare a property as indexed and allows to configure several aspects of the indexing process by setting one or more of the following attributes:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">name</code> : describe under which name, the property should be stored in the Lucene Document. The default value is the property name (following the JavaBeans convention)
							</li><li class="listitem">
								<code class="literal">store</code> : describe whether or not the property is stored in the Lucene index. You can store the value <code class="literal">Store.YES</code> (consuming more space in the index but allowing <a class="link" href="hibernate_search.html#projection" title="Projection">projection</a>, store it in a compressed way <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or avoid any storage <code class="literal">Store.NO</code> (this is the default value). When a property is stored, you can retrieve its original value from the Lucene Document. This is not related to whether the element is indexed or not.
							</li><li class="listitem"><p class="simpara">
								<code class="literal">index</code>: describe whether the property is indexed or not. The different values are <code class="literal">Index.NO</code>, meaning that it is not indexed and cannot be found by a query and <code class="literal">Index.YES</code>, meaning that the element gets indexed and is searchable. The default value is <code class="literal">Index.YES</code>. <code class="literal">Index.NO</code> can be useful for cases where a property is not required to be searchable, but should be available for projection.
							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
									<code class="literal">Index.NO</code> in combination with <code class="literal">Analyze.YES</code> or <code class="literal">Norms.YES</code> is not useful, since <code class="literal">analyze</code> and <code class="literal">norms</code> require the property to be indexed
								</p></div></li><li class="listitem"><p class="simpara">
								<code class="literal">analyze</code>: determines whether the property is analyzed (<code class="literal">Analyze.YES</code>) or not (<code class="literal">Analyze.NO</code>). The default value is <code class="literal">Analyze.YES</code>.
							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
									Whether or not you want to analyze a property depends on whether you wish to search the element as is, or by the words it contains. It make sense to analyze a text field, but probably not a date field.
								</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
									Fields used for sorting <span class="emphasis"><em>must not</em></span> be analyzed.
								</p></div></li><li class="listitem">
								<code class="literal">norms</code>: describes whether index time boosting information should be stored (<code class="literal">Norms.YES</code>) or not (<code class="literal">Norms.NO</code>). Not storing it can save a considerable amount of memory, but there will not be any index time boosting information available. The default value is <code class="literal">Norms.YES</code>.
							</li><li class="listitem"><p class="simpara">
								<code class="literal">termVector</code>: describes collections of term-frequency pairs. This attribute enables the storing of the term vectors within the documents during indexing. The default value is <code class="literal">TermVector.NO</code>.
							</p><p class="simpara">
								The different values of this attribute are:
							</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Value</th><th style="text-align: left" valign="top">Definition</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
												TermVector.YES
											</p>
											 </td><td style="text-align: left" valign="top"> <p>
												Store the term vectors of each document. This produces two synchronized arrays, one contains document terms and the other contains the term’s frequency.
											</p>
											 </td></tr><tr><td style="text-align: left" valign="top"> <p>
												TermVector.NO
											</p>
											 </td><td style="text-align: left" valign="top"> <p>
												Do not store term vectors.
											</p>
											 </td></tr><tr><td style="text-align: left" valign="top"> <p>
												TermVector.WITH_OFFSETS
											</p>
											 </td><td style="text-align: left" valign="top"> <p>
												Store the term vector and token offset information. This is the same as TermVector.YES plus it contains the starting and ending offset position information for the terms.
											</p>
											 </td></tr><tr><td style="text-align: left" valign="top"> <p>
												TermVector.WITH_POSITIONS
											</p>
											 </td><td style="text-align: left" valign="top"> <p>
												Store the term vector and token position information. This is the same as TermVector.YES plus it contains the ordinal positions of each occurrence of a term in a document.
											</p>
											 </td></tr><tr><td style="text-align: left" valign="top"> <p>
												TermVector.WITH_POSITION_OFFSETS
											</p>
											 </td><td style="text-align: left" valign="top"> <p>
												Store the term vector, token position and offset information. This is a combination of the YES, WITH_OFFSETS and WITH_POSITIONS.
											</p>
											 </td></tr></tbody></table></div></li><li class="listitem"><p class="simpara">
								<code class="literal">indexNullAs</code> : Per default null values are ignored and not indexed. However, using <code class="literal">indexNullAs</code> you can specify a string which will be inserted as token for the <code class="literal">null</code> value. Per default this value is set to <code class="literal">Field.DO_NOT_INDEX_NULL</code> indicating that <code class="literal">null</code> values should not be indexed. You can set this value to <code class="literal">Field.DEFAULT_NULL_TOKEN</code> to indicate that a default <code class="literal">null</code> token should be used. This default <code class="literal">null</code> token can be specified in the configuration using <code class="literal">hibernate.search.default_null_token</code>. If this property is not set and you specify <code class="literal">Field.DEFAULT_NULL_TOKEN</code> the string "<span class="emphasis"><em>null</em></span>" will be used as default.
							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
									When the <code class="literal">indexNullAs</code> parameter is used it is important to use the same token in the search query to search for <code class="literal">null</code> values. It is also advisable to use this feature only with un-analyzed fields (<code class="literal">Analyze.NO</code>).
								</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
									When implementing a custom FieldBridge or TwoWayFieldBridge it is up to the developer to handle the indexing of null values (see JavaDocs of LuceneOptions.indexNullAs()).
								</p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="numericfield"/>@NumericField</h3></div></div></div><p>
						There is a companion annotation to @Field called @NumericField that can be specified in the same scope as @Field or @DocumentId. It can be specified for Integer, Long, Float, and Double properties. At index time the value will be indexed using a Trie structure. When a property is indexed as numeric field, it enables efficient range query and sorting, orders of magnitude faster than doing the same query on standard @Field properties. The @NumericField annotation accept the following parameters:
					</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Value</th><th style="text-align: left" valign="top">Definition</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										forField
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										(Optional) Specify the name of the related @Field that will be indexed as numeric. It is only mandatory when the property contains more than a @Field declaration
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										precisionStep
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										(Optional) Change the way that the Trie structure is stored in the index. Smaller precisionSteps lead to more disk space usage and faster range and sort queries. Larger values lead to less space used and range query performance more close to the range query in normal @Fields. Default value is 4.
									</p>
									 </td></tr></tbody></table></div><p>
						@NumericField supports only Double, Long, Integer and Float. It is not possible to take any advantage from similar functionality in Lucene for the other numeric types, so remaining types should use the string encoding via the default or custom TwoWayFieldBridge.
					</p><p>
						It is possible to use a custom NumericFieldBridge assuming you can deal with the approximation during type transformation:
					</p><div class="title"><strong>Example: Defining a Custom NumericFieldBridge</strong></div><p>
							
</p><pre class="programlisting">public class BigDecimalNumericFieldBridge extends NumericFieldBridge {
   private static final BigDecimal storeFactor = BigDecimal.valueOf(100);

   @Override
   public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
      if ( value != null ) {
         BigDecimal decimalValue = (BigDecimal) value;
         Long indexedValue = Long.valueOf( decimalValue.multiply( storeFactor ).longValue() );
         luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
      }
   }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }

}</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="id"/>@Id</h3></div></div></div><p>
						Finally, the <code class="literal">id</code> (identifier) property of an entity is a special property used by Hibernate Search to ensure index uniqueness of a given entity. By design, an <code class="literal">id</code> must be stored and must not be tokenized. To mark a property as an index identifier, use the <code class="literal">@DocumentId</code> annotation. If you are using JPA and you have specified @Id you can omit @DocumentId. The chosen entity identifier will also be used as the document identifier.
					</p><p>
						Infinispan Query uses the entity’s <code class="literal">id</code> property to ensure the index is uniquely identified. By design, an ID is stored and must not be converted into a token. To mark a property as index ID, use the <code class="literal">@DocumentId</code> annotation.
					</p><div class="title"><strong>Example: Specifying Indexed Properties</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
public class Essay {
    ...
    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES)
    public String getSummary() { return summary; }

    @Lob
    @Field
    public String getText() { return text; }

    @Field @NumericField( precisionStep = 6)
    public float getGrade() { return grade; }
}</pre><p>

						</p><p>
						The example above defines an index with four fields: <code class="literal">id</code> , <code class="literal">Abstract</code>, <code class="literal">text</code> and <code class="literal">grade</code> . Note that by default the field name is not capitalized, following the JavaBean specification. The <code class="literal">grade</code> field is annotated as numeric with a slightly larger precision step than the default.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="mapping_properties_multiple_times"/>Mapping Properties Multiple Times</h3></div></div></div><p>
						Sometimes you need to map a property multiple times per index, with slightly different indexing strategies. For example, sorting a query by field requires the field to be un-analyzed. To search by words on this property and still sort it, it needs to be indexed - once analyzed and once un-analyzed. @Fields allows you to achieve this goal.
					</p><div class="title"><strong>Example: Using @Fields to Map a Property Multiple Times</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed(index = "Book" )
public class Book {
    @Fields( {
            @Field,
            @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
            } )
    public String getSummary() {
        return summary;
    }
    ...
}</pre><p>

						</p><p>
						In this example the field <code class="literal">summary</code> is indexed twice, once as <code class="literal">summary</code> in a tokenized way, and once as <code class="literal">summary_forSort</code> in an untokenized way.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="embedded_and_associated_objects"/>Embedded and Associated Objects</h3></div></div></div><p>
						Associated objects as well as embedded objects can be indexed as part of the root entity index. This is useful if you expect to search a given entity based on properties of associated objects. The aim is to return places where the associated city is Atlanta (In the Lucene query parser language, it would translate into <code class="literal">address.city:Atlanta</code>). The place fields will be indexed in the <code class="literal">Place</code> index. The <code class="literal">Place</code> index documents will also contain the fields <code class="literal">address.id</code>, <code class="literal">address.street</code>, and <code class="literal">address.city</code> which you will be able to query.
					</p><div class="title"><strong>Example: Indexing Associations</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    @IndexedEmbedded
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</pre><p>

						</p><p>
						Because the data is denormalized in the Lucene index when using the <code class="literal">@IndexedEmbedded</code> technique, Hibernate Search must be aware of any change in the Place object and any change in the Address object to keep the index up to date. To ensure the Lucene document is updated when it is Address changes, mark the other side of the bidirectional relationship with <code class="literal">@ContainedIn</code>.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							<code class="literal">@ContainedIn</code> is useful on both associations pointing to entities and on embedded (collection of) objects.
						</p></div><p>
						To expand upon this, the following example demonstrates nesting <code class="literal">@IndexedEmbedded</code>.
					</p><div class="title"><strong>Example: Nested Usage of @IndexedEmbedded and @ContainedIn</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    @IndexedEmbedded
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_")
    private Owner ownedBy;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field
    private String name;
   ...
}</pre><p>

						</p><p>
						Any <code class="literal">@*ToMany</code>, <code class="literal">@*ToOne</code> and <code class="literal">@Embedded</code> attribute can be annotated with <code class="literal">@IndexedEmbedded</code>. The attributes of the associated class will then be added to the main entity index. The index will contain the following fields:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								id
							</li><li class="listitem">
								name
							</li><li class="listitem">
								address.street
							</li><li class="listitem">
								address.city
							</li><li class="listitem">
								address.ownedBy_name
							</li></ul></div><p>
						The default prefix is <code class="literal">propertyName.</code>, following the traditional object navigation convention. You can override it using the <code class="literal">prefix</code> attribute as it is shown on the <code class="literal">ownedBy</code> property.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The prefix cannot be set to an empty string.
						</p></div><p>
						The <code class="literal">depth</code> property is necessary when the object graph contains a cyclic dependency of classes (not instances). For example, if Owner points to Place. Hibernate Search will stop including Indexed embedded attributes after reaching the expected depth (or the object graph boundaries are reached). A class having a self reference is an example of cyclic dependency. In our example, because <code class="literal">depth</code> is set to 1, any <code class="literal">@IndexedEmbedded</code> attribute in Owner will be ignored.
					</p><p>
						Using <code class="literal">@IndexedEmbedded</code> for object associations allows you to express queries (using Lucene’s query syntax) such as:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
								Return places where the name contains JBoss and where the address city is Atlanta. In Lucene query this would be:
							</p><pre class="screen">+name:jboss +address.city:atlanta</pre></li><li class="listitem"><p class="simpara">
								Return places where the name contains JBoss and where the owner’s name contains Joe. In Lucene query this would be
							</p><pre class="screen">+name:jboss +address.ownedBy_name:joe</pre></li></ul></div><p>
						This behavior mimics the relational join operation in a more efficient way (at the cost of data duplication). Remember that, out of the box, Lucene indexes have no notion of association, the join operation does not exist. It might help to keep the relational model normalized while benefiting from the full text index speed and feature richness.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							An associated object can itself (but does not have to) be <code class="literal">@Indexed</code>
						</p></div><p>
						When <code class="literal">@IndexedEmbedded</code> points to an entity, the association has to be directional and the other side has to be annotated <code class="literal">@ContainedIn</code> (as seen in the previous example). If not, Hibernate Search has no way to update the root index when the associated entity is updated (in our example, a <code class="literal">Place</code> index document has to be updated when the associated Address instance is updated).
					</p><p>
						Sometimes, the object type annotated by <code class="literal">@IndexedEmbedded</code> is not the object type targeted by Hibernate and Hibernate Search. This is especially the case when interfaces are used in lieu of their implementation. For this reason you can override the object type targeted by Hibernate Search using the <code class="literal">targetElement</code> parameter.
					</p><div class="title"><strong>Example: Using the targetElement Property of @IndexedEmbedded</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", )
    @Target(Owner.class)
    private Person ownedBy;
    ...
}

@Embeddable
public class Owner implements Person { ... }</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="limiting_object_embedding_to_specific_paths"/>Limiting Object Embedding to Specific Paths</h3></div></div></div><p>
						The @IndexedEmbedded annotation provides also an attribute includePaths which can be used as an alternative to depth, or be combined with it.
					</p><p>
						When using only depth all indexed fields of the embedded type will be added recursively at the same depth. This makes it harder to select only a specific path without adding all other fields as well, which might not be needed.
					</p><p>
						To avoid unnecessarily loading and indexing entities you can specify exactly which paths are needed. A typical application might need different depths for different paths, or in other words it might need to specify paths explicitly, as shown in the example below:
					</p><div class="title"><strong>Example: Using the includePaths Property of @IndexedEmbedded</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
public class Person {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(includePaths = { "name" })
   public Set&lt;Person&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    ...//other fields omitted</pre><p>

						</p><p>
						Using a mapping as in the example above, you would be able to search on a Person by <code class="literal">name</code> and/or <code class="literal">surname</code>, and/or the <code class="literal">name</code> of the parent. It will not index the <code class="literal">surname</code> of the parent, so searching on parent’s surnames will not be possible but speeds up indexing, saves space and improve overall performance.
					</p><p>
						The @IndexedEmbeddedincludePaths will include the specified paths <span class="emphasis"><em>in addition to</em></span> what you would index normally specifying a limited value for depth. When using includePaths, and leaving depth undefined, behavior is equivalent to setting depth=0: only the included paths are indexed.
					</p><div class="title"><strong>Example: Using the includePaths Property of @IndexedEmbedded</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
public class Human {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(depth = 2, includePaths = { "parents.parents.name" })
   public Set&lt;Human&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    ...//other fields omitted</pre><p>

						</p><p>
						In the example above, every human will have its name and surname attributes indexed. The name and surname of parents will also be indexed, recursively up to second line because of the depth attribute. It will be possible to search by name or surname, of the person directly, his parents or of his grand parents. Beyond the second level, we will in addition index one more level but only the name, not the surname.
					</p><p>
						This results in the following fields in the index:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">id</code>: as primary key
							</li><li class="listitem">
								<code class="literal">_hibernate_class</code>: stores entity type
							</li><li class="listitem">
								<code class="literal">name</code>: as direct field
							</li><li class="listitem">
								<code class="literal">surname</code>: as direct field
							</li><li class="listitem">
								<code class="literal">parents.name</code>: as embedded field at depth 1
							</li><li class="listitem">
								<code class="literal">parents.surname</code>: as embedded field at depth 1
							</li><li class="listitem">
								<code class="literal">parents.parents.name</code>: as embedded field at depth 2
							</li><li class="listitem">
								<code class="literal">parents.parents.surname</code>: as embedded field at depth 2
							</li><li class="listitem">
								<code class="literal">parents.parents.parents.name</code>: as additional path as specified by includePaths. The first <code class="literal">parents.</code> is inferred from the field name, the remaining path is the attribute of includePaths
							</li></ul></div><p>
						Having explicit control of the indexed paths might be easier if you are designing your application by defining the needed queries first, as at that point you might know exactly which fields you need, and which other fields are unnecessary to implement your use case.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="boosting"/>Boosting</h2></div></div></div><p>
					Lucene has the notion of <span class="emphasis"><em>boosting</em></span> which allows you to give certain documents or fields more or less importance than others. Lucene differentiates between index and search time boosting. The following sections show you how you can achieve index time boosting using Hibernate Search.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="static_index_time_boosting"/>Static Index Time Boosting</h3></div></div></div><p>
						To define a static boost value for an indexed class or property you can use the <code class="literal">@Boost</code> annotation. You can use this annotation within <code class="literal">@Field</code> or specify it directly on method or class level.
					</p><div class="title"><strong>Example: Different Ways of Using @Boost</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed

public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=@Boost(2f))
    @Boost(1.5f)
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=@Boost(1.2f))
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }
}</pre><p>

						</p><p>
						In the example above, Essay’s probability to reach the top of the search list will be multiplied by 1.7. The summary field will be 3.0 (2 * 1.5, because @Field.boost and @Boost on a property are cumulative) more important than the isbn field. The text field will be 1.2 times more important than the isbn field. Note that this explanation is wrong in strictest terms, but it is simple and close enough to reality for all practical purposes.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="dynamic_index_time_boosting"/>Dynamic Index Time Boosting</h3></div></div></div><p>
						The <code class="literal">@Boost</code> annotation used in <a class="link" href="hibernate_search.html#static_index_time_boosting" title="Static Index Time Boosting">Static Index Time Boosting</a> defines a static boost factor which is independent of the state of the indexed entity at runtime. However, there are use cases in which the boost factor may depend on the actual state of the entity. In this case you can use the <code class="literal">@DynamicBoost</code> annotation together with an accompanying custom BoostStrategy.
					</p><div class="title"><strong>Example: Dynamic Boost</strong></div><p>
							
</p><pre class="programlisting">public enum PersonType {
    NORMAL,
    VIP
}

@Entity
@Indexed
@DynamicBoost(impl = VIPBoostStrategy.class)
public class Person {
    private PersonType type;

    // ....
}

public class VIPBoostStrategy implements BoostStrategy {
    public float defineBoost(Object value) {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</pre><p>

						</p><p>
						In the example above, a dynamic boost is defined on class level specifying VIPBoostStrategy as implementation of the BoostStrategy interface to be used at indexing time. You can place the <code class="literal">@DynamicBoost</code> either at class or field level. Depending on the placement of the annotation either the whole entity is passed to the defineBoost method or just the annotated field/property value. It is up to you to cast the passed object to the correct type. In the example all indexed values of a VIP person would be double as important as the values of a normal person.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The specified BoostStrategy implementation must define a public no-arg constructor.
						</p></div><p>
						Of course you can mix and match <code class="literal">@Boost</code> and <code class="literal">@DynamicBoost</code> annotations in your entity. All defined boost factors are cumulative.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="analysis"/>Analysis</h2></div></div></div><p>
					<code class="literal">Analysis</code> is the process of converting text into single terms (words) and can be considered as one of the key features of a full-text search engine. Lucene uses the concept of Analyzers to control this process. In the following section we cover the multiple ways Hibernate Search offers to configure the analyzers.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="default_analyzer_and_analyzer_by_class"/>Default Analyzer and Analyzer by Class</h3></div></div></div><p>
						The default analyzer class used to index tokenized fields is configurable through the <code class="literal">hibernate.search.analyzer</code> property. The default value for this property is <code class="literal">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.
					</p><p>
						You can also define the analyzer class per entity, property and even per @Field (useful when multiple fields are indexed from a single property).
					</p><div class="title"><strong>Example: Different Ways of Using @Analyzer</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
@Analyzer(impl = EntityAnalyzer.class)
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    @Analyzer(impl = PropertyAnalyzer.class)
    private String summary;

    @Field(analyzer = @Analyzer(impl = FieldAnalyzer.class)
    private String body;
    ...
}</pre><p>

						</p><p>
						In this example, EntityAnalyzer is used to index tokenized property (<code class="literal">name</code>), except <code class="literal">summary</code> and <code class="literal">body</code> which are indexed with PropertyAnalyzer and FieldAnalyzer respectively.
					</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							Mixing different analyzers in the same entity is most of the time a bad practice. It makes query building more complex and results less predictable (for the novice), especially if you are using a QueryParser (which uses the same analyzer for the whole query). As a rule of thumb, for any given field the same analyzer should be used for indexing and querying.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="named_analyzers"/>Named Analyzers</h3></div></div></div><p>
						Analyzers can become quite complex to deal with. For this reason introduces Hibernate Search the notion of analyzer definitions. An analyzer definition can be reused by many @Analyzer declarations and is composed of:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<span class="strong"><strong>a name:</strong></span> the unique string used to refer to the definition
							</li><li class="listitem">
								<span class="strong"><strong>a list of char filters:</strong></span> each char filter is responsible to pre-process input characters before the tokenization. Char filters can add, change, or remove characters; one common usage is for characters normalization
							</li><li class="listitem">
								<span class="strong"><strong>a tokenizer:</strong></span> responsible for tokenizing the input stream into individual words
							</li><li class="listitem">
								<span class="strong"><strong>a list of filters:</strong></span> each filter is responsible to remove, modify, or sometimes even add words into the stream provided by the tokenizer
							</li></ul></div><p>
						This separation of tasks - a list of char filters, and a tokenizer followed by a list of filters - allows for easy reuse of each individual component and lets you build your customized analyzer in a very flexible way (like Lego). Generally speaking the char filters do some pre-processing in the character input, then the Tokenizer starts the tokenizing process by turning the character input into tokens which are then further processed by the TokenFilters. Hibernate Search supports this infrastructure by utilizing the Solr analyzer framework.
					</p><p>
						Let us review a concrete example stated below. First a char filter is defined by its factory. In our example, a mapping char filter is used, and will replace characters in the input based on the rules specified in the mapping file. Next a tokenizer is defined. This example uses the standard tokenizer. Last but not least, a list of filters is defined by their factories. In our example, the StopFilter filter is built reading the dedicated words property file. The filter is also expected to ignore case.
					</p><div class="title"><strong>Example: @AnalyzerDef and the Solr Framework</strong></div><p>
							
</p><pre class="programlisting">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    ...
}</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Filters and char filters are applied in the order they are defined in the @AnalyzerDef annotation. Order matters!
						</p></div><p>
						Some tokenizers, token filters or char filters load resources like a configuration or metadata file. This is the case for the stop filter and the synonym filter. If the resource charset is not using the VM default, you can explicitly specify it by adding a <code class="literal">resource_charset</code> parameter.
					</p><div class="title"><strong>Example: Use a Specific Charset to Load the Property File</strong></div><p>
							
</p><pre class="programlisting">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="resource_charset", value = "UTF-16BE"),
      @Parameter(name="ignoreCase", value="true")
  })
})
public class Team {
    ...
}</pre><p>

						</p><p>
						Once defined, an analyzer definition can be reused by an @Analyzer declaration as seen in the following example.
					</p><div class="title"><strong>Example: Referencing an Analyzer by Name</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field
    @Analyzer(definition = "customanalyzer")
    private String description;
}</pre><p>

						</p><p>
						Analyzer instances declared by @AnalyzerDef are also available by their name in the SearchFactory which is quite useful when building queries.
					</p><pre class="programlisting">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</pre><p>
						Fields in queries must be analyzed with the same analyzer used to index the field so that they speak a common "language": the same tokens are reused between the query and the indexing process. This rule has some exceptions but is true most of the time. Respect it unless you know what you are doing.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="available_analyzers"/>Available Analyzers</h3></div></div></div><p>
						Solr and Lucene come with many useful default char filters, tokenizers, and filters. You can find a complete list of char filter factories, tokenizer factories and filter factories at <a class="link" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>. Let us check a few of them.
					</p><div class="table"><a id="idm140404004623216"/><p class="title"><strong>Table 7.8. Available Char Filters</strong></p><div class="table-contents"><table summary="Available Char Filters" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top">Factory</th><th style="text-align: left" valign="top">Description</th><th style="text-align: left" valign="top">Parameters</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										MappingCharFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Replaces one or more characters with one or more characters, based on mappings specified in the resource file
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">mapping</code>: points to a resource file containing the mappings using the format: "á" ⇒ "a"; "ñ" ⇒ "n"; "ø" ⇒ "o"
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										HTMLStripCharFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Remove HTML standard tags, keeping the text
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										none
									</p>
									 </td></tr></tbody></table></div></div><div class="table"><a id="idm140403994617184"/><p class="title"><strong>Table 7.9. Available Tokenizers</strong></p><div class="table-contents"><table summary="Available Tokenizers" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top">Factory</th><th style="text-align: left" valign="top">Description</th><th style="text-align: left" valign="top">Parameters</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										StandardTokenizerFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Use the Lucene StandardTokenizer
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										none
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										HTMLStripCharFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Remove HTML tags, keep the text and pass it to a StandardTokenizer.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										none
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										PatternTokenizerFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Breaks text at the specified regular expression pattern.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<span class="strong"><strong>pattern</strong></span>: the regular expression to use for tokenizing
									</p>
									 <p>
										<span class="strong"><strong>group</strong></span>: says which pattern group to extract into tokens
									</p>
									 </td></tr></tbody></table></div></div><div class="table"><a id="idm140403900203440"/><p class="title"><strong>Table 7.10. Available Filters</strong></p><div class="table-contents"><table summary="Available Filters" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top">Factory</th><th style="text-align: left" valign="top">Description</th><th style="text-align: left" valign="top">Parameters</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										StandardFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Remove dots from acronyms and 's from words
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										none
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										LowerCaseFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Lowercases all words
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										none
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										StopFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Remove words (tokens) matching a list of stop words
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<span class="strong"><strong>words</strong></span>: points to a resource file containing the stop words
									</p>
									 <p>
										<span class="strong"><strong>ignoreCase</strong></span>: true if case should be ignored when comparing stop words, false otherwise
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										SnowballPorterFilterFactory
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Reduces a word to its root in a given language. (example: protect, protects, protection share the same root). Using such a filter allows searches matching related words.
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										<code class="literal">language</code>: Danish, Dutch, English, Finnish, French, German, Italian, Norwegian, Portuguese, Russian, Spanish, Swedish and a few more
									</p>
									 </td></tr></tbody></table></div></div><p>
						We recommend to check all the implementations of <code class="literal">org.apache.lucene.analysis.TokenizerFactory</code> and <code class="literal">org.apache.lucene.analysis.TokenFilterFactory</code> in your IDE to see the implementations available.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="dynamic_analyzer_selection"/>Dynamic Analyzer Selection</h3></div></div></div><p>
						So far all the introduced ways to specify an analyzer were static. However, there are use cases where it is useful to select an analyzer depending on the current state of the entity to be indexed, for example in a multilingual applications. For an BlogEntry class for example the analyzer could depend on the language property of the entry. Depending on this property the correct language specific stemmer should be chosen to index the actual text.
					</p><p>
						To enable this dynamic analyzer selection Hibernate Search introduces the AnalyzerDiscriminator annotation. Following example demonstrates the usage of this annotation.
					</p><div class="title"><strong>Example: Usage of @AnalyzerDiscriminator</strong></div><p>
							
</p><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;

    @Field
    private String text;

    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</pre><p>

						</p><pre class="programlisting">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof BlogEntry ) ) {
            return null;
        }
        return (String) value;

    }
}</pre><p>
						The prerequisite for using <code class="literal">@AnalyzerDiscriminator</code> is that all analyzers which are going to be used dynamically are predefined via <code class="literal">@AnalyzerDef</code> definitions. If this is the case, one can place the <code class="literal">@AnalyzerDiscriminator</code> annotation either on the class or on a specific property of the entity for which to dynamically select an analyzer. Via the <code class="literal">impl</code> parameter of the <code class="literal">AnalyzerDiscriminator</code> you specify a concrete implementation of the Discriminator interface. It is up to you to provide an implementation for this interface. The only method you have to implement is <code class="literal">getAnalyzerDefinitionName()</code> which gets called for each field added to the Lucene document. The entity which is getting indexed is also passed to the interface method. The <code class="literal">value</code> parameter is only set if the <code class="literal">AnalyzerDiscriminator</code> is placed on property level instead of class level. In this case the value represents the current value of this property.
					</p><p>
						An implementation of the Discriminator interface has to return the name of an existing analyzer definition or null if the default analyzer should not be overridden. The example above assumes that the language parameter is either 'de' or 'en' which matches the specified names in the <code class="literal">@AnalyzerDefs</code>.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="retrieving_an_analyzer"/>Retrieving an Analyzer</h3></div></div></div><p>
						Retrieving an analyzer can be used when multiple analyzers have been used in a domain model, in order to benefit from stemming or phonetic approximation, etc. In this case, use the same analyzers to building a query. Alternatively, use the Hibernate Search query DSL, which selects the correct analyzer automatically. See
					</p><p>
						Whether you are using the Lucene programmatic API or the Lucene query parser, you can retrieve the scoped analyzer for a given entity. A scoped analyzer is an analyzer which applies the right analyzers depending on the field indexed. Remember, multiple analyzers can be defined on a given entity each one working on an individual field. A scoped analyzer unifies all these analyzers into a context-aware analyzer. While the theory seems a bit complex, using the right analyzer in a query is very easy.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							When you use programmatic mapping for a child entity, you can only see the fields defined by the child entity. Fields or methods inherited from a parent entity (annotated with @MappedSuperclass) are not configurable. To configure properties inherited from a parent entity, either override the property in the child entity or create a programmatic mapping for the parent entity. This mimics the usage of annotations where you cannot annotate a field or method of a parent entity unless it is redefined in the child entity.
						</p></div><div class="title"><strong>Example: Using the Scoped Analyzer When Building a Full-text Query</strong></div><p>
							
</p><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title",
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery =
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects</pre><p>

						</p><p>
						In the example above, the song title is indexed in two fields: the standard analyzer is used in the field <code class="literal">title</code> and a stemming analyzer is used in the field <code class="literal">title_stemmed</code>. By using the analyzer provided by the search factory, the query uses the appropriate analyzer depending on the field targeted.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							You can also retrieve analyzers defined via @AnalyzerDef by their definition name using <code class="literal">searchFactory.getAnalyzer(String)</code>.
						</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="bridges"/>Bridges</h2></div></div></div><p>
					When discussing the basic mapping for an entity one important fact was so far disregarded. In Lucene all index fields have to be represented as strings. All entity properties annotated with <code class="literal">@Field</code> have to be converted to strings to be indexed. The reason we have not mentioned it so far is, that for most of your properties Hibernate Search does the translation job for you thanks to set of built-in bridges. However, in some cases you need a more fine grained control over the translation process.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="built_in_bridges"/>Built-in Bridges</h3></div></div></div><p>
						Hibernate Search comes bundled with a set of built-in bridges between a Java property type and its full text representation.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">null</span></dt><dd>
									Per default <code class="literal">null</code> elements are not indexed. Lucene does not support null elements. However, in some situation it can be useful to insert a custom token representing the <code class="literal">null</code> value. See for more information.
								</dd><dt><span class="term">java.lang.String</span></dt><dd>
									Strings are indexed as are short, Short, integer, Integer, long, Long, float, Float, double,
								</dd><dt><span class="term">Double, BigInteger, BigDecimal</span></dt><dd><p class="simpara">
									Numbers are converted into their string representation. Note that numbers cannot be compared by Lucene (that is, used in ranged queries) out of the box: they have to be padded.
								</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
										Using a Range query has drawbacks, an alternative approach is to use a Filter query which will filter the result query to the appropriate range. Hibernate Search also supports the use of a custom StringBridge as described in <a class="link" href="hibernate_search.html#custom_bridges" title="Custom Bridges">Custom Bridges</a>.
									</p></div></dd><dt><span class="term">java.util.Date</span></dt><dd><p class="simpara">
									Dates are stored as yyyyMMddHHmmssSSS in GMT time (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You should not really bother with the internal format. What is important is that when using a TermRangeQuery, you should know that the dates have to be expressed in GMT time.
								</p><p class="simpara">
									Usually, storing the date up to the millisecond is not necessary. <code class="literal">@DateBridge</code> defines the appropriate resolution you are willing to store in the index (<code class="literal">@DateBridge(resolution=Resolution.DAY)</code>). The date pattern will then be truncated accordingly.
								</p></dd></dl></div><pre class="programlisting">@Entity
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)

    private Date date;
    ...</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							A Date whose resolution is lower than <code class="literal">MILLISECOND</code> cannot be a <code class="literal">@DocumentId</code>.
						</p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
							The default Date bridge uses Lucene’s DateTools to convert from and to String. This means that all dates are expressed in GMT time. If your requirements are to store dates in a fixed time zone you have to implement a custom date bridge. Make sure you understand the requirements of your applications regarding to date indexing and searching.
						</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">java.net.URI, java.net.URL</span></dt><dd>
									URI and URL are converted to their string representation.
								</dd><dt><span class="term">java.lang.Class</span></dt><dd>
									Class are converted to their fully qualified class name. The thread context class loader is used when the class is rehydrated.
								</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="custom_bridges"/>Custom Bridges</h3></div></div></div><p>
						Sometimes, the built-in bridges of Hibernate Search do not cover some of your property types, or the String representation used by the bridge does not meet your requirements. The following paragraphs describe several solutions to this problem.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="stringbridge"/>StringBridge</h4></div></div></div><p>
							The simplest custom solution is to give Hibernate Search an implementation of your expected Object to String bridge. To do so you need to implement the <code class="literal">org.hibernate.search.bridge.StringBridge</code> interface. All implementations have to be thread-safe as they are used concurrently.
						</p><div class="title"><strong>Example: Custom StringBridge Implementation</strong></div><p>
								
</p><pre class="programlisting">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements StringBridge {

    private int PADDING = 5;

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; PADDING)
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}</pre><p>

							</p><p>
							Given the string bridge defined in the previous example, any property or field can use this bridge thanks to the <code class="literal">@FieldBridge</code> annotation:
						</p><pre class="programlisting">@FieldBridge(impl = PaddedIntegerBridge.class)
private Integer length;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="parameterized_bridge"/>Parameterized Bridge</h4></div></div></div><p>
							Parameters can also be passed to the bridge implementation making it more flexible. Following example implements a ParameterizedBridge interface and parameters are passed through the <code class="literal">@FieldBridge</code> annotation.
						</p><div class="title"><strong>Example: Passing Parameters to Your Bridge Implementation</strong></div><p>
								
</p><pre class="programlisting">public class PaddedIntegerBridge implements StringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map&lt;String,String&gt; parameters) {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}


//property
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
            )
private Integer length;</pre><p>

							</p><p>
							The <code class="literal">ParameterizedBridge</code> interface can be implemented by <code class="literal">StringBridge</code>, <code class="literal">TwoWayStringBridge</code>, <code class="literal">FieldBridge</code> implementations.
						</p><p>
							All implementations have to be thread-safe, but the parameters are set during initialization and no special care is required at this stage.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="type_away_bridge"/>Type Aware Bridge</h4></div></div></div><p>
							It is sometimes useful to get the type the bridge is applied on:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									the return type of the property for field/getter-level bridges.
								</li><li class="listitem">
									the class type for class-level bridges.
								</li></ul></div><p>
							An example is a bridge that deals with enums in a custom fashion but needs to access the actual enum type. Any bridge implementing AppliedOnTypeAwareBridge will get the type the bridge is applied on injected. Like parameters, the type injected needs no particular care with regard to thread-safety.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="two_way_bridge"/>Two-Way Bridge</h4></div></div></div><p>
							If you expect to use your bridge implementation on an id property (that is, annotated with <code class="literal">@DocumentId</code> ), you need to use a slightly extended version of <code class="literal">StringBridge</code> named TwoWayStringBridge. Hibernate Search needs to read the string representation of the identifier and generate the object out of it. There is no difference in the way the <code class="literal">@FieldBridge</code> annotation is used.
						</p><div class="title"><strong>Example: Implementing a TwoWayStringBridge Usable for id Properties</strong></div><p>
								
</p><pre class="programlisting">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }

    public Object stringToObject(String stringValue) {
        return new Integer(stringValue);
    }
}

//id property
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
private Integer id;</pre><p>

							</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
								It is important for the two-way process to be idempotent (i.e., object = stringToObject( objectToString( object ) ) ).
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="fieldbridge"/>FieldBridge</h4></div></div></div><p>
							Some use cases require more than a simple object to string translation when mapping a property to a Lucene index. To give you the greatest possible flexibility you can also implement a bridge as a FieldBridge. This interface gives you a property value and let you map it the way you want in your Lucene Document. You can for example store a property in two different document fields. The interface is very similar in its concept to the Hibernate UserTypes.
						</p><div class="title"><strong>Example: Implementing the FieldBridge Interface</strong></div><p>
								
</p><pre class="programlisting">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);

        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );

        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );

        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}

//property
@FieldBridge(impl = DateSplitBridge.class)
private Date date;</pre><p>

							</p><p>
							In the example above, the fields are not added directly to Document. Instead the addition is delegated to the LuceneOptions helper; this helper will apply the options you have selected on <code class="literal">@Field</code>, like <code class="literal">Store</code> or <code class="literal">TermVector</code>, or apply the chosen @Boost value. It is especially useful to encapsulate the complexity of <code class="literal">COMPRESS</code> implementations. Even though it is recommended to delegate to LuceneOptions to add fields to the Document, nothing stops you from editing the Document directly and ignore the LuceneOptions in case you need to.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								Classes like LuceneOptions are created to shield your application from changes in Lucene API and simplify your code. Use them if you can, but if you need more flexibility you are not required to.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="classbridge"/>ClassBridge</h4></div></div></div><p>
							It is sometimes useful to combine more than one property of a given entity and index this combination in a specific way into the Lucene index. The <code class="literal">@ClassBridge</code> and <code class="literal">@ClassBridges</code> annotations can be defined at the class level, as opposed to the property level. In this case the custom field bridge implementation receives the entity instance as the value parameter instead of a particular property. Though not shown in following example, <code class="literal">@ClassBridge</code> supports the <code class="literal">termVector</code> attribute discussed in the <a class="link" href="hibernate_search.html#basic_mapping" title="Basic Mapping">Basic Mapping</a> section.
						</p><div class="title"><strong>Example: Implementing a Class Bridge</strong></div><p>
								
</p><pre class="programlisting">@Entity
@Indexed
(name="branchnetwork",
             store=Store.YES,
             impl = CatFieldsClassBridge.class,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    ...
}

public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    public void set( String name, Object value, Document document, LuceneOptions luceneOptions) {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</pre><p>

							</p><p>
							In this example, the particular <code class="literal">CatFieldsClassBridge</code> is applied to the <code class="literal">department</code> instance, the field bridge then concatenate both branch and network and index the concatenation.
						</p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="querying"/>Querying</h1></div></div></div><p>
				Hibernate Search can execute Lucene queries and retrieve domain objects managed by an InfinispanHibernate session. The search provides the power of Lucene without leaving the Hibernate paradigm, giving another dimension to the Hibernate classic search mechanisms (HQL, Criteria query, native SQL query).
			</p><p>
				Preparing and executing a query consists of following four steps:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Creating a FullTextSession
					</li><li class="listitem">
						Creating a Lucene query using either Hibernate QueryHibernate Search query DSL (recommended) or using the Lucene Query API
					</li><li class="listitem">
						Wrapping the Lucene query using an org.hibernate.Query
					</li><li class="listitem">
						Executing the search by calling for example list() or scroll()
					</li></ul></div><p>
				To access the querying facilities, use a FullTextSession. This Search-specific session wraps a regular org.hibernate.Session in order to provide query and indexing capabilities.
			</p><div class="title"><strong>Example: Creating a FullTextSession</strong></div><p>
					
</p><pre class="programlisting">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);</pre><p>

				</p><p>
				Use the FullTextSession to build a full-text query using either the Hibernate Search query DSL or the native Lucene query.
			</p><p>
				Use the following code when using the Hibernate Search query DSL:
			</p><pre class="programlisting">final QueryBuilder b = fullTextSession.getSearchFactory().buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );
List result = fullTextQuery.list(); //return a list of managed objects</pre><p>
				As an alternative, write the Lucene query using either the Lucene query parser or the Lucene programmatic API.
			</p><div class="title"><strong>Example: Creating a Lucene Query Using the QueryParser</strong></div><p>
					
</p><pre class="programlisting">SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryParser.QueryParser parser =
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class) );
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse( "history:storm^3" );
}
catch (ParseException e) {
    //handle parsing failure
}

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</pre><p>

				</p><p>
				A Hibernate query built on the Lucene query is a org.hibernate.Query. This query remains in the same paradigm as other Hibernate query facilities, such as HQL (Hibernate Query Language), Native, and Criteria. Use methods such as list(), uniqueResult(), iterate() and scroll() with the query.
			</p><p>
				The same extensions are available with the Hibernate Java Persistence APIs:
			</p><div class="title"><strong>Example: Creating a Search Query Using the JPA API</strong></div><p>
					
</p><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
final QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

javax.persistence.Query fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery );

List result = fullTextQuery.getResultList(); //return a list of managed objects</pre><p>

				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					In these examples, the Hibernate API has been used. The same examples can also be written with the Java Persistence API by adjusting the way the <code class="literal">FullTextQuery</code> is retrieved.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="building_queries"/>Building Queries</h2></div></div></div><p>
					Hibernate Search queries are built on Lucene queries, allowing users to use any Lucene query type. When the query is built, Hibernate Search uses org.hibernate.Query as the query manipulation API for further query processing.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="building_a_lucene_query_using_the_lucene_api"/>Building a Lucene Query Using the Lucene API</h3></div></div></div><p>
						With the Lucene API, use either the query parser (simple queries) or the Lucene programmatic API (complex queries). Building a Lucene query is out of scope for the Hibernate Search documentation. For details, see the online Lucene documentation or a copy of <span class="emphasis"><em>Lucene in Action</em></span> or <span class="emphasis"><em>Hibernate Search in Action</em></span>.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="building_a_lucene_query"/>Building a Lucene Query</h3></div></div></div><p>
						The Lucene programmatic API enables full-text queries. However, when using the Lucene programmatic API, the parameters must be converted to their string equivalent and must also apply the correct analyzer to the right field. A ngram analyzer for example uses several ngrams as the tokens for a given word and should be searched as such. It is recommended to use the QueryBuilder for this task.
					</p><p>
						The Hibernate Search query API is fluent, with the following key characteristics:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Method names are in English. As a result, API operations can be read and understood as a series of English phrases and instructions.
							</li><li class="listitem">
								It uses IDE autocompletion which helps possible completions for the current input prefix and allows the user to choose the right option.
							</li><li class="listitem">
								It often uses the chaining method pattern.
							</li><li class="listitem">
								It is easy to use and read the API operations.
							</li></ul></div><p>
						To use the API, first create a query builder that is attached to a given <code class="literal">indexedentitytype</code>. This QueryBuilder knows what analyzer to use and what field bridge to apply. Several QueryBuilders (one for each entity type involved in the root of your query) can be created. The QueryBuilder is derived from the SearchFactory.
					</p><pre class="programlisting">QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();</pre><p>
						The analyzer used for a given field or fields can also be overridden.
					</p><pre class="programlisting">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</pre><p>
						The query builder is now used to build Lucene queries. Customized queries generated using Lucene’s query parser or Query objects assembled using the Lucene programmatic API are used with the Hibernate Search DSL.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="keyword_queries"/>Keyword Queries</h3></div></div></div><p>
						The following example shows how to search for a specific word:
					</p><pre class="programlisting">Query luceneQuery = mythQB.keyword().onField("history").matching("storm").createQuery();</pre><div class="table"><a id="idm140403901705280"/><p class="title"><strong>Table 7.11. Keyword Query Parameters</strong></p><div class="table-contents"><table summary="Keyword Query Parameters" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Parameter</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										keyword()
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Use this parameter to find a specific word.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										onField()
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Use this parameter to specify in which lucene field to search the word.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										matching()
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Use this parameter to specify the match for search string
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										createQuery()
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Creates the Lucene query object.
									</p>
									 </td></tr></tbody></table></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								The value "storm" is passed through the <code class="literal">history</code> FieldBridge. This is useful when numbers or dates are involved.
							</li><li class="listitem">
								The field bridge value is then passed to the analyzer used to index the field <code class="literal">history</code>. This ensures that the query uses the same term transformation than the indexing (lower case, ngram, stemming and so on). If the analyzing process generates several terms for a given word, a boolean query is used with the <code class="literal">SHOULD</code> logic (roughly an <code class="literal">OR</code> logic).
							</li></ul></div><p>
						To search a property that is not of type string.
					</p><pre class="programlisting">@Indexed
public class Myth {
  @Field(analyze = Analyze.NO)
  @DateBridge(resolution = Resolution.YEAR)
  public Date getCreationDate() { return creationDate; }
  public Date setCreationDate(Date creationDate) { this.creationDate = creationDate; }
  private Date creationDate;

  ...
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("creationDate").matching(birthdate).createQuery();</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							In plain Lucene, the Date object had to be converted to its string representation, which in this case is the year.
						</p></div><p>
						This conversion works for any object, provided that the FieldBridge has an objectToString method (and all built-in FieldBridge implementations do).
					</p><p>
						The next example searches a field that uses ngram analyzers. The ngram analyzers index succession of ngrams of words, which helps to avoid user typos. For example, the 3-grams of the word hibernate are hib, ibe, ber, ern, rna, nat, ate.
					</p><pre class="programlisting">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)

public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram")
  public String getName() { return name; }
  public String setName(String name) { this.name = name; }
  private String name;

  ...
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus")
   .createQuery();</pre><p>
						The matching word "Sisiphus" will be lower-cased and then split into 3-grams: sis, isi, sip, iph, phu, hus. Each of these ngram will be part of the query. The user is then able to find the Sysiphus myth (with a <code class="literal">y</code>). All that is transparently done for the user.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							If the user does not want a specific field to use the field bridge or the analyzer then the ignoreAnalyzer() or ignoreFieldBridge() functions can be called.
						</p></div><p>
						To search for multiple possible words in the same field, add them all in the matching clause.
					</p><pre class="programlisting">//search document with storm or lightning in their history
Query luceneQuery =
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</pre><p>
						To search the same word on multiple fields, use the onFields method.
					</p><pre class="programlisting">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</pre><p>
						Sometimes, one field should be treated differently from another field even if searching the same term, use the andField() method for that.
					</p><pre class="programlisting">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
      .boostedTo(5)
    .andField("description")
    .matching("storm")
    .createQuery();</pre><p>
						In the previous example, only field name is boosted to 5.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="fuzzy_queries"/>Fuzzy Queries</h3></div></div></div><p>
						To execute a fuzzy query (based on the Levenshtein distance algorithm), start with a <code class="literal">keyword</code> query and add the <code class="literal">fuzzy</code> flag.
					</p><pre class="programlisting">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold( .8f )
        .withPrefixLength( 1 )
    .onField("history")
    .matching("starm")
    .createQuery();</pre><p>
						The <code class="literal">threshold</code> is the limit above which two terms are considering matching. It is a decimal between 0 and 1 and the default value is 0.5. The <code class="literal">prefixLength</code> is the length of the prefix ignored by the "fuzzyness". While the default value is 0, a nonzero value is recommended for indexes containing a huge number of distinct terms.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="wildcard_queries"/>Wildcard Queries</h3></div></div></div><p>
						Wildcard queries are useful in circumstances where only part of the word is known. The <code class="literal">?</code> represents a single character and * represents multiple characters. Note that for performance purposes, it is recommended that the query does not start with either <code class="literal">?</code> or <code class="literal">*</code>.
					</p><pre class="programlisting">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Wildcard queries do not apply the analyzer on the matching terms. The risk of <code class="literal">*</code> or <code class="literal">?</code> being mangled is too high.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="phase_queries"/>Phrase Queries</h3></div></div></div><p>
						So far we have been looking for words or sets of words, the user can also search exact or approximate sentences. Use phrase() to do so.
					</p><pre class="programlisting">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .sentence("Thou shalt not kill")
    .createQuery();</pre><p>
						Approximate sentences can be searched by adding a slop factor. The slop factor represents the number of other words permitted in the sentence: this works like a within or near operator.
					</p><pre class="programlisting">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .sentence("Thou kill")
    .createQuery();</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="range_queries"/>Range Queries</h3></div></div></div><p>
						A range query searches for a value in between given boundaries (included or not) or for a value below or above a given boundary.
					</p><pre class="programlisting">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="combining_queries"/>Combining Queries</h3></div></div></div><p>
						Queries can be combined to create more complex queries. The following aggregation operators are available:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">SHOULD</code>: the query should contain the matching elements of the subquery.
							</li><li class="listitem">
								<code class="literal">MUST</code>: the query must contain the matching elements of the subquery.
							</li><li class="listitem">
								<code class="literal">MUST NOT</code>: the query must not contain the matching elements of the subquery.
							</li></ul></div><p>
						The subqueries can be any Lucene query including a boolean query itself.
					</p><div class="title"><strong>Example: SHOULD Query</strong></div><p>
							
</p><pre class="programlisting">//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();</pre><p>

						</p><div class="title"><strong>Example: MUST Query</strong></div><p>
							
</p><pre class="programlisting">//look for popular urban myths
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();</pre><p>

						</p><div class="title"><strong>Example: MUST NOT Query</strong></div><p>
							
</p><pre class="programlisting">//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="query_options"/>Query Options</h3></div></div></div><p>
						The Hibernate Search query DSL is an easy-to-use and easy-to-read query API. In accepting and producing Lucene queries, you can incorporate query types not yet supported by the DSL.
					</p><p>
						The following is a summary of query options for query types and fields:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<span class="strong"><strong>boostedTo</strong></span> (on query type and on field) boosts the whole query or the specific field to a given factor.
							</li><li class="listitem">
								<span class="strong"><strong>withConstantScore</strong></span> (on query) returns all results that match the query have a constant score equals to the boost.
							</li><li class="listitem">
								<span class="strong"><strong>filteredBy(Filter)</strong></span> (on query) filters query results using the Filter instance.
							</li><li class="listitem">
								<span class="strong"><strong>ignoreAnalyzer</strong></span> (on field) ignores the analyzer when processing this field.
							</li><li class="listitem">
								<span class="strong"><strong>ignoreFieldBridge</strong></span> (on field) ignores field bridge when processing this field.
							</li></ul></div><div class="title"><strong>Example: Combination of Query Options</strong></div><p>
							
</p><pre class="programlisting">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="build_a_hibernate_search_query"/>Build a Hibernate Search Query</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="generality"/>Generality</h4></div></div></div><p>
							After building the Lucene query, wrap it within a Hibernate query. The query searches all indexed entities and returns all types of indexed classes unless explicitly configured not to do so.
						</p><div class="title"><strong>Example: Wrapping a Lucene Query in a Hibernate Query</strong></div><p>
								
</p><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</pre><p>

							</p><p>
							For improved performance, restrict the returned types as follows:
						</p><div class="title"><strong>Example: Filtering the Search Result by Entity Type</strong></div><p>
								
</p><pre class="programlisting">fullTextQuery = fullTextSession
    .createFullTextQuery( luceneQuery, Customer.class );

// or

fullTextQuery = fullTextSession
    .createFullTextQuery( luceneQuery, Item.class, Actor.class );</pre><p>

							</p><p>
							The first part of the second example only returns the matching Customers. The second part of the same example returns matching Actors and Items. The type restriction is polymorphic. As a result, if the two subclasses Salesman and Customer of the base class Person return, specify Person.class to filter based on result types.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="pagination"/>Pagination</h4></div></div></div><p>
							To avoid performance degradation, it is recommended to restrict the number of returned objects per query. A user navigating from one page to another page is a very common use case. The way to define pagination is similar to defining pagination in a plain HQL or Criteria query.
						</p><div class="title"><strong>Example: Defining Pagination for a Search Query</strong></div><p>
								
</p><pre class="programlisting">org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								It is still possible to get the total number of matching elements regardless of the pagination via <code class="literal">fulltextQuery.getResultSize()</code>.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sorting"/>Sorting</h4></div></div></div><p>
							Apache Lucene contains a flexible and powerful result sorting mechanism. The default sorting is by relevance and is appropriate for a large variety of use cases. The sorting mechanism can be changed to sort by other properties using the Lucene Sort object to apply a Lucene sorting strategy.
						</p><div class="title"><strong>Example: Specifying a Lucene Sort</strong></div><p>
								
</p><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(
    new SortField("title", SortField.STRING));

List results = query.list();</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								Fields used for sorting must not be tokenized. For more information about tokenizing, see <a class="link" href="hibernate_search.html#field" title="@Field">@Field</a>.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="fetching_strategy"/>Fetching Strategy</h4></div></div></div><p>
							Hibernate Search loads objects using a single query if the return types are restricted to one class. Hibernate Search is restricted by the static fetching strategy defined in the domain model. It is useful to refine the fetching strategy for a specific use case as follows:
						</p><div class="title"><strong>Example: Specifying FetchMode on a Query</strong></div><p>
								
</p><pre class="programlisting">Criteria criteria =
    s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</pre><p>

							</p><p>
							In this example, the query will return all Books matching the LuceneQuery. The authors collection will be loaded from the same query using an SQL outer join.
						</p><p>
							In a criteria query definition, the type is guessed based on the provided criteria query. As a result, it is not necessary to restrict the return entity types.
						</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
								The fetch mode is the only adjustable property. Do not use a restriction (a where clause) on the Criteria query because the getResultSize() throws a SearchException if used in conjunction with a Criteria with restriction.
							</p></div><p>
							If more than one entity is expected, do not use <code class="literal">setCriteriaQuery</code>.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="projection"/>Projection</h4></div></div></div><p>
							In some cases, only a small subset of the properties is required. Use Hibernate Search to return a subset of properties as follows:
						</p><p>
							Hibernate Search extracts properties from the Lucene index and converts them to their object representation and returns a list of Object[]. Projections prevent a time consuming database round-trip. However, they have following constraints:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									The properties projected must be stored in the index (<code class="literal">@Field(store=Store.YES)</code>), which increases the index size.
								</li><li class="listitem"><p class="simpara">
									The properties projected must use a <code class="literal">FieldBridge</code> implementing org.hibernate.search.bridge.TwoWayFieldBridge or <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>, the latter being the simpler version.
								</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
										All Hibernate Search built-in types are two-way.
									</p></div></li><li class="listitem">
									Only the simple properties of the indexed entity or its embedded associations can be projected. Therefore a whole embedded entity cannot be projected.
								</li><li class="listitem">
									Projection does not work on collections or maps which are indexed via @IndexedEmbedded.
								</li></ul></div><p>
							Lucene provides metadata information about query results. Use projection constants to retrieve the metadata.
						</p><div class="title"><strong>Example: Using Projection to Retrieve Metadata</strong></div><p>
								
</p><pre class="programlisting">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
query.;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</pre><p>

							</p><p>
							Fields can be mixed with the following projection constants:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<span class="strong"><strong>FullTextQuery.THIS:</strong></span> returns the initialized and managed entity (as a non projected query would have done).
								</li><li class="listitem">
									<span class="strong"><strong>FullTextQuery.DOCUMENT:</strong></span> returns the Lucene Document related to the object projected.
								</li><li class="listitem">
									<span class="strong"><strong>FullTextQuery.OBJECT_CLASS:</strong></span> returns the class of the indexed entity.
								</li><li class="listitem">
									<span class="strong"><strong>FullTextQuery.SCORE:</strong></span> returns the document score in the query. Scores are handy to compare one result against an other for a given query but are useless when comparing the result of different queries.
								</li><li class="listitem">
									<span class="strong"><strong>FullTextQuery.ID:</strong></span> the ID property value of the projected object.
								</li><li class="listitem">
									<span class="strong"><strong>FullTextQuery.DOCUMENT_ID:</strong></span> the Lucene document ID. Be careful in using this value as a Lucene document ID can change over time between two different IndexReader opening.
								</li><li class="listitem">
									<span class="strong"><strong>FullTextQuery.EXPLANATION:</strong></span> returns the Lucene Explanation object for the matching object/document in the given query. This is not suitable for retrieving large amounts of data. Running explanation typically is as costly as running the whole Lucene query per matching element. As a result, projection is recommended.
								</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="customizing_object_initialization_strategies"/>Customizing Object Initialization Strategies</h4></div></div></div><p>
							By default, Hibernate Search uses the most appropriate strategy to initialize entities matching the full text query. It executes one or more queries to retrieve the required entities. This approach minimizes database trips where few of the retrieved entities are present in the persistence context (the session) or the second level cache.
						</p><p>
							If entities are present in the second-level cache, force Hibernate Search to look into the cache before retrieving a database object.
						</p><div class="title"><strong>Example: Check the Second-level Cache Before Using a Query</strong></div><p>
								
</p><pre class="programlisting">FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);
query.initializeObjectWith(
    ObjectLookupMethod.SECOND_LEVEL_CACHE,
    DatabaseRetrievalMethod.QUERY
);</pre><p>

							</p><p>
							<code class="literal">ObjectLookupMethod</code> defines the strategy to check if an object is easily accessible (without fetching it from the database). Other options are:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<code class="literal">ObjectLookupMethod.PERSISTENCE_CONTEXT</code> is used if many matching entities are already loaded into the persistence context (loaded in the Session or EntityManager).
								</li><li class="listitem">
									<code class="literal">ObjectLookupMethod.SECOND_LEVEL_CACHE</code> checks the persistence context and then the second-level cache.
								</li></ul></div><p>
							Set the following to search in the second-level cache:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									Correctly configure and activate the second-level cache.
								</li><li class="listitem">
									Enable the second-level cache for the relevant entity. This is done using annotations such as @Cacheable.
								</li><li class="listitem">
									Enable second-level cache read access for either Session, EntityManager or Query. Use <code class="literal">CacheMode.NORMAL</code> in Hibernate native APIs or <code class="literal">CacheRetrieveMode.USE</code> in Java Persistence APIs.
								</li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
								Unless the second-level cache implementation is Infinispan, do not use ObjectLookupMethod.SECOND_LEVEL_CACHE. Other second-level cache providers do not implement this operation efficiently.
							</p></div><p>
							Customize how objects are loaded from the database using <code class="literal">DatabaseRetrievalMethod</code> as follows:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<span class="strong"><strong>QUERY</strong></span> (default) uses a set of queries to load several objects in each batch. This approach is recommended.
								</li><li class="listitem">
									<span class="strong"><strong>FIND_BY_ID</strong></span> loads one object at a time using the <code class="literal">Session.get</code> or <code class="literal">EntityManager.find</code> semantic. This is recommended if the batch size is set for the entity, which allows Hibernate Core to load entities in batches.
								</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="limiting_the_time_of_a_query"/>Limiting the Time of a Query</h4></div></div></div><p>
							Limit the time a query takes in Hibernate Guide as follows:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									Raise an exception when arriving at the limit.
								</li><li class="listitem">
									Limit to the number of results retrieved when the time limit is raised.
								</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="raise_an_exception_on_time_limit"/>Raise an Exception on Time Limit</h4></div></div></div><p>
							If a query uses more than the defined amount of time, a QueryTimeoutException is raised (org.hibernate.QueryTimeoutException or javax.persistence.QueryTimeoutException depending on the programmatic API).
						</p><p>
							To define the limit when using the native Hibernate APIs, use one of the following approaches:
						</p><div class="title"><strong>Example: Defining a Timeout in Query Execution</strong></div><p>
								
</p><pre class="programlisting">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</pre><p>

							</p><p>
							The getResultSize(), iterate() and scroll() honor the timeout until the end of the method call. As a result, Iterable or the ScrollableResults ignore the timeout. Additionally, explain() does not honor this timeout period. This method is used for debugging and to check the reasons for slow performance of a query.
						</p><p>
							The following is the standard way to limit execution time using the Java Persistence API (JPA):
						</p><div class="title"><strong>Example: Defining a Timeout in Query Execution</strong></div><p>
								
</p><pre class="programlisting">Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</pre><p>

							</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
								The example code does not guarantee that the query stops at the specified results amount.
							</p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="retrieving_the_results"/>Retrieving the Results</h2></div></div></div><p>
					After building the Hibernate query, it is executed the same way as an HQL or Criteria query. The same paradigm and object semantic apply to a Lucene Query query and the common operations like <code class="literal">list()</code>, <code class="literal">uniqueResult()</code>, <code class="literal">iterate()</code>, and <code class="literal">scroll()</code> are available.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="performance_considerations"/>Performance Considerations</h3></div></div></div><p>
						If you expect a reasonable number of results (for example using pagination) and expect to work on all of them, <code class="literal">list()</code> or <code class="literal">uniqueResult()</code> are recommended. <code class="literal">list()</code> work best if the entity <code class="literal">batch-size</code> is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the pagination) when using <code class="literal">list()</code> , <code class="literal">uniqueResult()</code> and <code class="literal">iterate()</code>.
					</p><p>
						If you wish to minimize Lucene document loading, <code class="literal">scroll()</code> is more appropriate. Do not forget to close the ScrollableResults object when you are done, since it keeps Lucene resources. If you expect to use scroll, but wish to load objects in batch, you can use query.<code class="literal">setFetchSize()</code>. When an object is accessed, and if not already loaded, Hibernate Search will load the next <code class="literal">fetchSize</code> objects in one pass.
					</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
							Pagination is preferred over scrolling.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="result_size"/>Result Size</h3></div></div></div><p>
						It is sometimes useful to know the total number of matching documents:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								to provide a total search results feature, as provided by Google searches. For example, "1-10 of about 888,000,000 results"
							</li><li class="listitem">
								to implement a fast pagination navigation
							</li><li class="listitem">
								to implement a multi-step search engine that adds approximation if the restricted query returns zero or not enough results
							</li></ul></div><p>
						Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you to retrieve the total number of matching documents regardless of the pagination parameters. Even more interesting, you can retrieve the number of matching elements without triggering a single object load.
					</p><div class="title"><strong>Example: Determining the Result Size of a Query</strong></div><p>
							
</p><pre class="programlisting">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
//return the number of matching books without loading a single one
assert 3245 == ;

org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == ;</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Like Google, the number of results is approximation if the index is not fully up-to-date with the database (asynchronous cluster for example).
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resulttransformer"/>ResultTransformer</h3></div></div></div><p>
						Projection results are returned as Object arrays. If the data structure used for the object does not match the requirements of the application, apply a ResultTransformer. The ResultTransformer builds the required data structure after the query execution.
					</p><div class="title"><strong>Example: Using ResultTransformer with Projections</strong></div><p>
							
</p><pre class="programlisting">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

query.setResultTransformer( new StaticAliasToBeanResultTransformer( BookView.class, "title", "author" ) );
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</pre><p>

						</p><p>
						Examples of <code class="literal">ResultTransformer</code> implementations can be found in the Hibernate Core codebase.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="understanding_results"/>Understanding Results</h3></div></div></div><p>
						If the results of a query are not what you expected, the <code class="literal">Luke</code> tool is useful in understanding the outcome. However, Hibernate Search also gives you access to the Lucene Explanation object for a given result (in a given query). This class is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of an object. You have two ways to access the Explanation object for a given result:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Use the <code class="literal">fullTextQuery.explain(int)</code> method
							</li><li class="listitem">
								Use projection
							</li></ul></div><p>
						The first approach takes a document ID as a parameter and return the Explanation object. The document ID can be retrieved using projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code> constant.
					</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							The Document ID is unrelated to the entity ID. Be careful not to confuse these concepts.
						</p></div><p>
						In the second approach you project the Explanation object using the <code class="literal">FullTextQuery.EXPLANATION</code> constant.
					</p><div class="title"><strong>Example: Retrieving the Lucene Explanation Object Using Projection</strong></div><p>
							
</p><pre class="programlisting">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection(
             FullTextQuery.DOCUMENT_ID,
             ,
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</pre><p>

						</p><p>
						Use the Explanation object only when required as it is roughly as expensive as running the Lucene query again.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="filters"/>Filters</h3></div></div></div><p>
						Apache Lucene has a powerful feature that allows you to filter query results according to a custom filtering process. This is a very powerful way to apply additional data restrictions, especially since filters can be cached and reused. Use cases include:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								security
							</li><li class="listitem">
								temporal data (example, view only last month’s data)
							</li><li class="listitem">
								population filter (example, search limited to a given category)
							</li></ul></div><p>
						Hibernate Search pushes the concept further by introducing the notion of parameterizable named filters which are transparently cached. For people familiar with the notion of Hibernate Core filters, the API is very similar:
					</p><div class="title"><strong>Example: Enabling Fulltext Filters for a Query</strong></div><p>
							
</p><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</pre><p>

						</p><p>
						In this example we enabled two filters on top of the query. You can enable or disable as many filters as you like.
					</p><p>
						Declaring filters is done through the @FullTextFilterDef annotation. This annotation can be on any <code class="literal">@Indexed</code> entity regardless of the query the filter is later applied to. This implies that filter definitions are global and their names must be unique. A SearchException is thrown in case two different @FullTextFilterDef annotations with the same name are defined. Each named filter has to specify its actual filter implementation.
					</p><div class="title"><strong>Example: Defining and Implementing a Filter</strong></div><p>
							
</p><pre class="programlisting">@FullTextFilterDefs( {
    @FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class),
    @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)
})
public class Driver { ... }</pre><p>

						</p><pre class="programlisting">public class BestDriversFilter extends org.apache.lucene.search.Filter {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</pre><p>
						BestDriversFilter is an example of a simple Lucene filter which reduces the result set to drivers whose score is 5. In this example the specified filter implements the <code class="literal">org.apache.lucene.search.Filter</code> directly and contains a no-arg constructor.
					</p><p>
						If your Filter creation requires additional steps or if the filter you want to use does not have a no-arg constructor, you can use the factory pattern:
					</p><div class="title"><strong>Example: Creating a Filter Using the Factory Pattern</strong></div><p>
							
</p><pre class="programlisting">@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

@Factory
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</pre><p>

						</p><p>
						Hibernate Search will look for a <code class="literal">@Factory</code> annotated method and use it to build the filter instance. The factory must have a no-arg constructor.
					</p><p>
						Infinispan Query uses a @Factory annotated method to build the filter instance. The factory must have a no argument constructor.
					</p><p>
						Named filters come in handy where parameters have to be passed to the filter. For example a security filter might want to know which security level you want to apply:
					</p><div class="title"><strong>Example: Passing Parameters to a Defined Filter</strong></div><p>
							
</p><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security").setParameter( "level", 5 );</pre><p>

						</p><p>
						Each parameter name should have an associated setter on either the filter or filter factory of the targeted named filter definition.
					</p><div class="title"><strong>Example: Using Parameters in the Actual Filter Implementation</strong></div><p>
							
</p><pre class="programlisting">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    public void setLevel(Integer level) {
        this.level = level;
    }

    @Key public FilterKey getKey() {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</pre><p>

						</p><p>
						Note the method annotated @Key returns a FilterKey object. The returned object has a special contract: the key object must implement equals() / hashCode() so that two keys are equal if and only if the given Filter types are the same and the set of parameters are the same. In other words, two filter keys are equal if and only if the filters from which the keys are generated can be interchanged. The key object is used as a key in the cache mechanism.
					</p><p>
						@Key methods are needed only if:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								the filter caching system is enabled (enabled by default)
							</li><li class="listitem">
								the filter has parameters
							</li></ul></div><p>
						In most cases, using the <code class="literal">StandardFilterKey</code> implementation will be good enough. It delegates the equals() / hashCode() implementation to each of the parameters equals and hashcode methods.
					</p><p>
						As mentioned before the defined filters are per default cached and the cache uses a combination of hard and soft references to allow disposal of memory when needed. The hard reference cache keeps track of the most recently used filters and transforms the ones least used to SoftReferences when needed. Once the limit of the hard reference cache is reached additional filters are cached as SoftReferences. To adjust the size of the hard reference cache, use <code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults to 128). For advanced use of filter caching, implement your own FilterCachingStrategy. The classname is defined by <code class="literal">hibernate.search.filter.cache_strategy</code>.
					</p><p>
						This filter caching mechanism should not be confused with caching the actual filter results. In Lucene it is common practice to wrap filters using the IndexReader around a CachingWrapperFilter. The wrapper will cache the DocIdSet returned from the <code class="literal">getDocIdSet(IndexReader reader)</code> method to avoid expensive recomputation. It is important to mention that the computed DocIdSet is only cachable for the same IndexReader instance, because the reader effectively represents the state of the index at the moment it was opened. The document list cannot change within an opened IndexReader. A different/new IndexReader instance, however, works potentially on a different set of Documents (either from a different index or simply because the index has changed), hence the cached DocIdSet has to be recomputed.
					</p><p>
						Hibernate Search also helps with this aspect of caching. Per default the <code class="literal">cache</code> flag of @FullTextFilterDef is set to <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which will automatically cache the filter instance as well as wrap the specified filter around a Hibernate specific implementation of CachingWrapperFilter. In contrast to Lucene’s version of this class SoftReferences are used together with a hard reference count (see discussion about filter cache). The hard reference count can be adjusted using <code class="literal">hibernate.search.filter.cache_docidresults.size</code> (defaults to 5). The wrapping behaviour can be controlled using the <code class="literal">@FullTextFilterDef.cache</code> parameter. There are three different values for this parameter:
					</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Value</th><th style="text-align: left" valign="top">Definition</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										FilterCacheModeType.NONE
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										No filter instance and no result is cached by Hibernate Search. For every filter call, a new filter instance is created. This setting might be useful for rapidly changing data sets or heavily memory constrained environments.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										FilterCacheModeType.INSTANCE_ONLY
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The filter instance is cached and reused across concurrent Filter.getDocIdSet() calls. DocIdSet results are not cached. This setting is useful when a filter uses its own specific caching mechanism or the filter results change dynamically due to application specific events making DocIdSet caching in both cases unnecessary.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Both the filter instance and the DocIdSet results are cached. This is the default value.
									</p>
									 </td></tr></tbody></table></div><p>
						Filters should be cached in the following situations:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								the system does not update the targeted entity index often (in other words, the IndexReader is reused a lot)
							</li><li class="listitem">
								the Filter’s DocIdSet is expensive to compute (compared to the time spent to execute the query)
							</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using_filters_in_a_sharded_environment"/>Using Filters in a Sharded Environment</h3></div></div></div><p>
						In a sharded environment it is possible to execute queries on a subset of the available shards. This can be done in two steps:
					</p><div class="orderedlist"><p class="title"><strong>Query a Subset of Index Shards</strong></p><ol class="orderedlist"><li class="listitem">
								Create a sharding strategy that does select a subset of IndexManagers depending on a filter configuration.
							</li><li class="listitem">
								Activate the filter at query time.
							</li></ol></div><div class="title"><strong>Example: Query a Subset of Index Shards</strong></div><p>
							In this example the query is run against a specific customer shard if the <code class="literal">customer</code> filter is activated.
						</p><pre class="programlisting">public class CustomerShardingStrategy implements IndexShardingStrategy {

     // stored IndexManagers in an array indexed by customerID
     private IndexManager[] indexManagers;

     public void initialize(Properties properties, IndexManager[] indexManagers) {
       this.indexManagers = indexManagers;
     }

     public IndexManager[] getIndexManagersForAllShards() {
       return indexManagers;
     }

     public IndexManager getIndexManagerForAddition(
         Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
       Integer customerID = Integer.parseInt(document.getFieldable("customerID").stringValue());
       return indexManagers[customerID];
     }

     public IndexManager[] getIndexManagersForDeletion(
         Class&lt;?&gt; entity, Serializable id, String idInString) {
       return getIndexManagersForAllShards();
     }

      /**
      * Optimization; don't search ALL shards and union the results; in this case, we
      * can be certain that all the data for a particular customer Filter is in a single
      * shard; simply return that shard by customerID.
      */
     public IndexManager[] getIndexManagersForQuery(
         FullTextFilterImplementor[] filters) {
       FullTextFilter filter = getCustomerFilter(filters, "customer");
       if (filter == null) {
         return getIndexManagersForAllShards();
       }
       else {
         return new IndexManager[] { indexManagers[Integer.parseInt(
           filter.getParameter("customerID").toString())] };
       }
     }

     private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {
       for (FullTextFilterImplementor filter: filters) {
         if (filter.getName().equals(name)) return filter;
       }
       return null;
     }
    }</pre><p>
						In this example, if the filter named <code class="literal">customer</code> is present, only the shard dedicated to this customer is queried, otherwise, all shards are returned. A given sharding strategy can react to one or more filters and depends on their parameters.
					</p><p>
						The second step is to activate the filter at query time. While the filter can be a regular filter (as defined in ) which also filters Lucene results after the query, you can make use of a special filter that will only be passed to the sharding strategy (and is otherwise ignored).
					</p><p>
						To use this feature, specify the ShardSensitiveOnlyFilter class when declaring your filter.
					</p><pre class="programlisting">@Indexed
@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)
public class Customer {
   ...
}

FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
query.enableFulltextFilter("customer").setParameter("CustomerID", 5);
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</pre><p>
						Note that by using the ShardSensitiveOnlyFilter, you do not have to implement any Lucene filter. Using filters and sharding strategy reacting to these filters is recommended to speed up queries in a sharded environment.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="faceting"/>Faceting</h2></div></div></div><p>
					Faceted search is a technique which allows the results of a query to be divided into multiple categories. This categorization includes the calculation of hit counts for each category and the ability to further restrict search results based on these facets (categories). The example below shows a faceting example. The search results in fifteen hits which are displayed on the main part of the page. The navigation bar on the left, however, shows the category <span class="emphasis"><em>Computers &amp; Internet</em></span> with its subcategories <span class="emphasis"><em>Programming</em></span>, <span class="emphasis"><em>Computer Science</em></span>, <span class="emphasis"><em>Databases</em></span>, <span class="emphasis"><em>Software</em></span>, <span class="emphasis"><em>Web Development,</em></span> <span class="emphasis"><em>Networking</em></span> and <span class="emphasis"><em>Home Computing</em></span>. For each of these subcategories the number of books is shown matching the main search criteria and belonging to the respective subcategory. This division of the category <span class="emphasis"><em>Computers &amp; Internet</em></span> is one concrete search facet. Another one is for example the average customer review.
				</p><p>
					Faceted search divides the results of a query into categories. The categorization includes the calculation of hit counts for each category and the further restricts search results based on these facets (categories). The following example displays a faceting search results in fifteen hits displayed on the main page.
				</p><p>
					The left side navigation bar displays the categories and subcategories. For each of these subcategories the number of books matches the main search criteria and belongs to the respective subcategory. This division of the category Computers &amp; Internet is one concrete search facet. Another example is the average customer review.
				</p><div class="title"><strong>Example: Search for Hibernate Search on Amazon</strong></div><p>
						In Hibernate Search, the classes QueryBuilder and FullTextQuery are the entry point into the faceting API. The former creates faceting requests and the latter accesses the FacetManager. The FacetManager applies faceting requests on a query and selects facets that are added to an existing query to refine search results. The examples use the entity Cd as shown in the example below:
					</p><p>
					<span class="inlinemediaobject"><img src="images/topics/images/1605.png" alt="Search for Hibernate Search on Amazon"/></span>

				</p><div class="title"><strong>Example: Entity Cd</strong></div><p>
						
</p><pre class="programlisting">@Indexed
public class Cd {

    private int id;

    @Fields( {
        @Field,
        @Field(name = "name_un_analyzed", analyze = Analyze.NO)
    })
    private String name;

    @Field(analyze = Analyze.NO)
    @NumericField
    private int price;

    Field(analyze = Analyze.NO)
    @DateBridge(resolution = Resolution.YEAR)
    private Date releaseYear;

    @Field(analyze = Analyze.NO)
    private String label;


// setter/getter
...</pre><p>

					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Prior to Hibernate Search 5.2, there was no need to explicitly use a @Facet annotation. In Hibernate Search 5.2 it became necessary in order to use Lucene’s native faceting API.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="creating_a_faceting_request"/>Creating a Faceting Request</h3></div></div></div><p>
						The first step towards a faceted search is to create the FacetingRequest. Currently two types of faceting requests are supported. The first type is called <span class="emphasis"><em>discrete faceting</em></span> and the second type <span class="emphasis"><em>range faceting</em></span> request. In the case of a discrete faceting request you specify on which index field you want to facet (categorize) and which faceting options to apply. An example for a discrete faceting request can be seen in the following example:
					</p><div class="title"><strong>Example: Creating a Discrete Faceting Request</strong></div><p>
							
</p><pre class="programlisting">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity( Cd.class )
            .get();
FacetingRequest labelFacetingRequest = builder.facet()
    .name( "labelFaceting" )
    .onField( "label")
    .discrete()
    .orderedBy( FacetSortOrder.COUNT_DESC )
    .includeZeroCounts( false )
    .maxFacetCount( 1 )
    .createFacetingRequest();</pre><p>

						</p><p>
						When executing this faceting request a Facet instance will be created for each discrete value for the indexed field <code class="literal">label</code>. The Facet instance will record the actual field value including how often this particular field value occurs within the original query results. orderedBy, includeZeroCounts and maxFacetCount are optional parameters which can be applied on any faceting request. orderedBy allows to specify in which order the created facets will be returned. The default is <code class="literal">FacetSortOrder.COUNT_DESC</code>, but you can also sort on the field value or the order in which ranges were specified. includeZeroCount determines whether facets with a count of 0 will be included in the result (by default they are) and maxFacetCount allows to limit the maximum amount of facets returned.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							At the moment there are several preconditions an indexed field has to meet in order to apply faceting on it. The indexed property must be of type String, Date or a subtype of Number and <code class="literal">null</code> values should be avoided. Furthermore the property has to be indexed with <code class="literal">Analyze.NO</code> and in case of a numeric property @NumericField needs to be specified.
						</p></div><p>
						The creation of a range faceting request is quite similar except that we have to specify ranges for the field values we are faceting on. A range faceting request can be seen below where three different price ranges are specified. The <code class="literal">below</code> and <code class="literal">above</code> can only be specified once, but you can specify as many <code class="literal">from</code> - <code class="literal">to</code> ranges as you want. For each range boundary you can also specify via excludeLimit whether it is included into the range or not.
					</p><div class="title"><strong>Example: Creating a Range Faceting Request</strong></div><p>
							
</p><pre class="programlisting">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity( Cd.class )
            .get();
FacetingRequest priceFacetingRequest = builder.facet()
    .name( "priceFaceting" )
    .onField( "price" )
    .range()
    .below( 1000 )
    .from( 1001 ).to( 1500 )
    .above( 1500 ).excludeLimit()
    .createFacetingRequest();</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="applying_a_faceting_request"/>Applying a Faceting Request</h3></div></div></div><p>
						A faceting request is applied to a query via the FacetManager class which can be retrieved via the FullTextQuery class.
					</p><p>
						You can enable as many faceting requests as you like and retrieve them afterwards via getFacets() specifying the faceting request name. There is also a disableFaceting() method which allows you to disable a faceting request by specifying its name.
					</p><p>
						A faceting request can be applied on a query using the FacetManager, which can be retrieved via the FullTextQuery.
					</p><div class="title"><strong>Example: Applying a Faceting Request</strong></div><p>
							
</p><pre class="programlisting">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Cd.class );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cds
List&lt;Cd&gt; cds = fullTextQuery.list();
...

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
...</pre><p>

						</p><p>
						Multiple faceting requests can be retrieved using <code class="literal">getFacets()</code> and specifying the faceting request name.
					</p><p>
						The <code class="literal">disableFaceting()</code> method disables a faceting request by specifying its name.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="restricting_query_results"/>Restricting Query Results</h3></div></div></div><p>
						Last but not least, you can apply any of the returned Facets as additional criteria on your original query in order to implement a "drill-down" functionality. For this purpose FacetSelection can be utilized. FacetSelections are available via the FacetManager and allow you to select a facet as query criteria (selectFacets), remove a facet restriction (deselectFacets), remove all facet restrictions (clearSelectedFacets) and retrieve all currently selected facets (getSelectedFacets). The following snippet shows an example.
					</p><pre class="programlisting">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cd
List&lt;Cd&gt; cds = fullTextQuery.list();
assertTrue(cds.size() == 10);

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
assertTrue(facets.get(0).getCount() == 2)

// apply first facet as additional search criteria
facetManager.getFacetGroup( "priceFaceting" ).selectFacets( facets.get( 0 ) );

// re-execute the query
cds = fullTextQuery.list();
assertTrue(cds.size() == 2);</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_the_query_process"/>Optimizing the Query Process</h2></div></div></div><p>
					Query performance depends on several criteria:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The Lucene query.
						</li><li class="listitem">
							The number of objects loaded: use pagination (always) or index projection (if needed).
						</li><li class="listitem">
							The way Hibernate Search interacts with the Lucene readers: defines the appropriate reader strategy.
						</li><li class="listitem">
							Caching frequently extracted values from the index. See <a class="link" href="hibernate_search.html#caching_index_values_fieldcache" title="Caching Index Values: FieldCache">Caching Index Values: FieldCache</a> for more information.
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="caching_index_values_fieldcache"/>Caching Index Values: FieldCache</h3></div></div></div><p>
						The primary function of a Lucene index is to identify matches to your queries. After the query is performed the results must be analyzed to extract useful information. Hibernate Search would typically need to extract the class type and the primary key.
					</p><p>
						Extracting the needed values from the index has a performance cost, which in some cases might be very low and not noticeable, but in some other cases might be a good candidate for caching.
					</p><p>
						The requirements depend on the kind of <a class="link" href="hibernate_search.html#projection" title="Projection">Projections</a> being used, as in some cases the class type is not needed as it can be inferred from the query context or other means.
					</p><p>
						Using the @CacheFromIndex annotation you can experiment with different kinds of caching of the main metadata fields required by Hibernate Search:
					</p><pre class="programlisting">import static org.hibernate.search.annotations.FieldCacheType.CLASS;
import static org.hibernate.search.annotations.FieldCacheType.ID;

@Indexed
@CacheFromIndex( { CLASS, ID } )
public class Essay {
    ...</pre><p>
						It is possible to cache class types and IDs using this annotation:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
								<code class="literal">CLASS</code>: Hibernate Search will use a Lucene FieldCache to improve performance of the class type extraction from the index.
							</p><p class="simpara">
								This value is enabled by default, and is what Hibernate Search will apply if you do not specify the @CacheFromIndex annotation.
							</p></li><li class="listitem">
								<code class="literal">ID</code>: Extracting the primary identifier will use a cache. This is likely providing the best performing queries, but will consume much more memory which in turn might reduce performance.
							</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Measure the performance and memory consumption impact after warmup (executing some queries). Performance may improve by enabling Field Caches but this is not always the case.
						</p></div><p>
						Using a FieldCache has two downsides to consider:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Memory usage: these caches can be quite memory hungry. Typically the CLASS cache has lower requirements than the ID cache.
							</li><li class="listitem">
								Index warmup: when using field caches, the first query on a new index or segment will be slower than when you do not have caching enabled.
							</li></ul></div><p>
						With some queries, the class type will not be needed at all, in that case even if you enabled the <code class="literal">CLASS</code> field cache, this might not be used; for example if you are targeting a single class, obviously all returned values will be of that type (this is evaluated at each query execution).
					</p><p>
						For the ID FieldCache to be used, the IDs of targeted entities must be using a TwoWayFieldBridge (as all builting bridges), and all types being loaded in a specific query must use the fieldname for the id, and have IDs of the same type (this is evaluated at each query execution).
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="manual_index_changes"/>Manual Index Changes</h1></div></div></div><p>
				As Hibernate Core applies changes to the database, Hibernate Search detects these changes and will update the index automatically (unless the EventListeners are disabled). Sometimes changes are made to the database without using Hibernate, as when backup is restored or your data is otherwise affected. In these cases Hibernate Search exposes the Manual Index APIs to explicitly update or remove a single entity from the index, rebuild the index for the whole database, or remove all references to a specific type.
			</p><p>
				All these methods affect the Lucene Index only, no changes are applied to the database.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="adding_instances_to_the_index"/>Adding Instances to the Index</h2></div></div></div><p>
					Using <code class="literal">FullTextSession.index(T entity)</code> you can directly add or update a specific object instance to the index. If this entity was already indexed, then the index will be updated. Changes to the index are only applied at transaction commit.
				</p><p>
					Directly add an object or instance to the index using <code class="literal">FullTextSession.index(T entity)</code>. The index is updated when the entity is indexed. Infinispan Query applies changes to the index during the transaction commit.
				</p><div class="title"><strong>Example: Indexing an Entity Using FullTextSession.index(T entity)</strong></div><p>
						
</p><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
Object customer = fullTextSession.load( Customer.class, 8 );
fullTextSession.index(customer);
tx.commit(); //index only updated at commit time</pre><p>

					</p><p>
					In case you want to add all instances for a type, or for all indexed types, the recommended approach is to use a MassIndexer: see for more details.
				</p><p>
					Use a MassIndexer to add all instances for a type (or for all indexed types). See <a class="link" href="hibernate_search.html#using_a_massindexer" title="Using a MassIndexer">Using a MassIndexer</a> for more information.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="deleting_instances_from_the_index"/>Deleting Instances from the Index</h2></div></div></div><p>
					It is possible to remove an entity or all entities of a given type from a Lucene index without the need to physically remove them from the database. This operation is named purging and is also done through the <code class="literal">FullTextSession</code>.
				</p><p>
					The purging operation permits the removal of a single entity or all entities of a given type from a Lucene index without physically removing them from the database. This operation is performed using the FullTextSession.
				</p><div class="title"><strong>Example: Purging a Specific Instance of an Entity from the Index</strong></div><p>
						
</p><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
fullTextSession.purgeAll( Customer.class );
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index is updated at commit time</pre><p>

					</p><p>
					It is recommended to optimize the index after such an operation.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Methods index, purge, and purgeAll are available on FullTextEntityManager as well.
					</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						All manual indexing methods (index, purge, and purgeAll) only affect the index, not the database, nevertheless they are transactional and as such they will not be applied until the transaction is successfully committed, or you make use of flushToIndexes.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="rebuilding_the_index"/>Rebuilding the Index</h2></div></div></div><p>
					If you change the entity mapping to the index, chances are that the whole Index needs to be updated; For example if you decide to index an existing field using a different analyzer you’ll need to rebuild the index for affected types. Also if the Database is replaced (like restored from a backup, imported from a legacy system) you’ll want to be able to rebuild the index from existing data. Hibernate Search provides two main strategies to choose from:
				</p><p>
					Changing the entity mapping in the indexer may require the entire index to be updated. For example, if an existing field is to be indexed using a different analyzer, the index will need to be rebuilt for affected types.
				</p><p>
					Additionally, if the database is replaced by restoring from a backup or being imported from a legacy system, the index will need to be rebuilt from existing data. Infinispan Query provides two main strategies:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Using <code class="literal">FullTextSession.flushToIndexes()</code> periodically, while using <code class="literal">FullTextSession.index()</code> on all entities.
						</li><li class="listitem">
							Use a <code class="literal">MassIndexer</code>.
						</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using_flushtoindexes"/>Using flushToIndexes()</h3></div></div></div><p>
						This strategy consists of removing the existing index and then adding all entities back to the index using <code class="literal">FullTextSession.purgeAll()</code> and <code class="literal">FullTextSession.index()</code>, however there are some memory and efficiency constraints. For maximum efficiency Hibernate Search batches index operations and executes them at commit time. If you expect to index a lot of data you need to be careful about memory consumption since all documents are kept in a queue until the transaction commit. You can potentially face an <code class="literal">OutOfMemoryException</code> if you do not empty the queue periodically; to do this use <code class="literal">fullTextSession.flushToIndexes()</code>. Every time <code class="literal">fullTextSession.flushToIndexes()</code> is called (or if the transaction is committed), the batch queue is processed, applying all index changes. Be aware that, once flushed, the changes cannot be rolled back.
					</p><div class="title"><strong>Example: Index Rebuilding Using index() and flushToIndexes()</strong></div><p>
							
</p><pre class="programlisting">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //free memory since the queue is processed
    }
}
transaction.commit();</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							<code class="literal">hibernate.search.default.worker.batch_size</code> has been deprecated in favor of this explicit API which provides better control
						</p></div><p>
						Try to use a batch size that guarantees that your application will not be out of memory: with a bigger batch size objects are fetched faster from database but more memory is needed.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using_a_massindexer"/>Using a MassIndexer</h3></div></div></div><p>
						Hibernate Search’s MassIndexer uses several parallel threads to rebuild the index. You can optionally select which entities need to be reloaded or have it reindex all entities. This approach is optimized for best performance but requires to set the application in maintenance mode. Querying the index is not recommended when a MassIndexer is busy.
					</p><div class="title"><strong>Example: Rebuild the Index Using a MassIndexer</strong></div><p>
							
</p><pre class="programlisting">fullTextSession.createIndexer().startAndWait();</pre><p>

						</p><p>
						This will rebuild the index, deleting it and then reloading all entities from the database. Although it is simple to use, some tweaking is recommended to speed up the process.
					</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							During the progress of a MassIndexer the content of the index is undefined. If a query is performed while the MassIndexer is working most likely some results will be missing.
						</p></div><div class="title"><strong>Example: Using a Tuned MassIndexer</strong></div><p>
							
</p><pre class="programlisting">fullTextSession
 .createIndexer( User.class )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 12 )
 .idFetchSize( 150 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</pre><p>

						</p><p>
						This will rebuild the index of all User instances (and subtypes), and will create 12 parallel threads to load the User instances using batches of 25 objects per query. These same 12 threads will also need to process indexed embedded relations and custom <code class="literal">FieldBridges</code> or <code class="literal">ClassBridges</code> to output a Lucene document. The threads trigger lazy loading of additional attributes during the conversion process. Because of this, a high number of threads working in parallel is required. The number of threads working on actual index writing is defined by the back-end configuration of each index.
					</p><p>
						It is recommended to leave cacheMode to <code class="literal">CacheMode.IGNORE</code> (the default), as in most reindexing situations the cache will be a useless additional overhead. It might be useful to enable some other <code class="literal">CacheMode</code> depending on your data as it could increase performance if the main entity is relating to enum-like data included in the index.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The ideal of number of threads to achieve best performance is highly dependent on your overall architecture, database design and data values. All internal thread groups have meaningful names so they should be easily identified with most diagnostic tools, including thread dumps.
						</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The MassIndexer is unaware of transactions, therefore there is no need to begin one or commit afterward. Because it is not transactional it is not recommended to let users use the system during its processing, as it is unlikely people will be able to find results and the system load might be too high anyway.
						</p></div><p>
						Other parameters that affect indexing time and memory consumption are:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code>
							</li></ul></div><p>
						Previous versions also had a <code class="literal">max_field_length</code> but this was removed from Lucene. It is possible to obtain a similar effect by using a <code class="literal">LimitTokenCountAnalyzer</code>.
					</p><p>
						All <code class="literal">.indexwriter</code> parameters are Lucene specific and Hibernate Search passes these parameters through.
					</p><p>
						The MassIndexer uses a forward only scrollable result to iterate on the primary keys to be loaded, but MySQL’s JDBC driver will load all values in memory. To avoid this "optimization" set <code class="literal">idFetchSize</code> to <code class="literal">Integer.MIN_VALUE</code>.
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="index_optimization"/>Index Optimization</h1></div></div></div><p>
				From time to time, the Lucene index needs to be optimized. The process is essentially a defragmentation. Until an optimization is triggered Lucene only marks deleted documents as such, no physical are applied. During the optimization process the deletions will be applied which also affects the number of files in the Lucene Directory.
			</p><p>
				Optimizing the Lucene index speeds up searches but has no effect on the indexation (update) performance. During an optimization, searches can be performed, but will most likely be slowed down. All index updates will be stopped. It is recommended to schedule optimization:
			</p><p>
				Optimizing the Lucene index speeds up searches, but has no effect on the index update performance. Searches can be performed during an optimization process, however they will be slower than expected. All index updates are on hold during the optimization. It is therefore recommended to schedule optimization:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						On an idle system or when searches are least frequent.
					</li><li class="listitem">
						After a large number of index modifications are applied.
					</li></ul></div><p>
				MassIndexer optimizes indexes by default at the start and at the end of processing. Use <code class="literal">MassIndexer.optimizeAfterPurge</code> and <code class="literal">MassIndexer.optimizeOnFinish</code> to change this default behavior. See <a class="link" href="hibernate_search.html#using_a_massindexer" title="Using a MassIndexer">Using a MassIndexer</a> for more information.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="automatic_optimization"/>Automatic Optimization</h2></div></div></div><p>
					Hibernate Search can automatically optimize an index after either:
				</p><p>
					Infinispan Query automatically optimizes the index after:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							a certain amount of operations (insertion or deletion).
						</li><li class="listitem">
							a certain amount of transactions.
						</li></ul></div><p>
					The configuration for automatic index optimization can be defined either globally or per index:
				</p><div class="title"><strong>Example: Defining Automatic Optimization Parameters</strong></div><p>
						
</p><pre class="programlisting">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre><p>

					</p><p>
					An optimization will be triggered to the <code class="literal">Animal</code> index as soon as either:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							the number of additions and deletions reaches <code class="literal">1000</code>.
						</li><li class="listitem">
							the number of transactions reaches <code class="literal">50</code> (<code class="literal">hibernate.search.Animal.optimizer.transaction_limit.max</code> has priority over <code class="literal">hibernate.search.default.optimizer.transaction_limit.max</code>).
						</li></ul></div><p>
					If none of these parameters are defined, no optimization is processed automatically.
				</p><p>
					The default implementation of OptimizerStrategy can be overridden by implementing <code class="literal">org.hibernate.search.store.optimization.OptimizerStrategy</code> and setting the <code class="literal">optimizer.implementation</code> property to the fully qualified name of your implementation. This implementation must implement the interface, be a public class and have a public constructor taking no arguments.
				</p><div class="title"><strong>Example: Loading a Custom OptimizerStrategy</strong></div><p>
						
</p><pre class="programlisting">hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre><p>

					</p><p>
					The keyword <code class="literal">default</code> can be used to select the Hibernate Search default implementation; all properties after the <code class="literal">.optimizer</code> key separator will be passed to the implementation’s initialize method at start.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="manual_optimization"/>Manual Optimization</h2></div></div></div><p>
					You can programmatically optimize (defragment) a Lucene index from Hibernate Search through the SearchFactory:
				</p><div class="title"><strong>Example: Programmatic Index Optimization</strong></div><p>
						
</p><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</pre><p>

					</p><p>
					The first example optimizes the Lucene index holding Orders and the second optimizes all indexes.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						<code class="literal">searchFactory.optimize()</code> has no effect on a JMS back end. You must apply the optimize operation on the Master node.
					</p></div><p>
					<code class="literal">searchFactory.optimize()</code> is applied to the master node because it does not affect the JMC back end.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="adjusting_optimization"/>Adjusting Optimization</h2></div></div></div><p>
					Apache Lucene has a few parameters to influence how optimization is performed. Hibernate Search exposes those parameters.
				</p><p>
					Further index optimization parameters include:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code>
						</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="advanced_features"/>Advanced Features</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="accessing_the_searchfactory"/>Accessing the SearchFactory</h2></div></div></div><p>
					The SearchFactory object keeps track of the underlying Lucene resources for Hibernate Search. It is a convenient way to access Lucene natively. The <code class="literal">SearchFactory</code> can be accessed from a FullTextSession:
				</p><div class="title"><strong>Example: Accessing the SearchFactory</strong></div><p>
						
</p><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using_an_indexreader"/>Using an IndexReader</h2></div></div></div><p>
					Queries in Lucene are executed on an IndexReader. Hibernate Search might cache index readers to maximize performance, or provide other efficient strategies to retrieve an updated IndexReader minimizing I/O operations. Your code can access these cached resources, but there are several requirements.
				</p><div class="title"><strong>Example: Accessing an IndexReader</strong></div><p>
						
</p><pre class="programlisting">IndexReader reader = searchFactory.getIndexReaderAccessor().open(Order.class);
try {
   //perform read-only operations on the reader
}
finally {
   searchFactory.getIndexReaderAccessor().close(reader);
}</pre><p>

					</p><p>
					In this example the SearchFactory determines which indexes are needed to query this entity (considering a sharding strategy). Using the configured ReaderProvider on each index, it returns a compound <code class="literal">IndexReader</code> on top of all involved indexes. Because this IndexReader is shared amongst several clients, you must adhere to the following rules:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Never call indexReader.close(), instead use readerProvider.closeReader(reader) when necessary, preferably in a finally block.
						</li><li class="listitem">
							Don not use this IndexReader for modification operations (it is a readonly IndexReader, and any such attempt will result in an exception).
						</li></ul></div><p>
					Aside from those rules, you can use the IndexReader freely, especially to do native Lucene queries. Using the shared IndexReaders will make most queries more efficient than by opening one directly from, for example, the file system.
				</p><p>
					As an alternative to the method open(Class…​ types) you can use open(String…​ indexNames), allowing you to pass in one or more index names. Using this strategy you can also select a subset of the indexes for any indexed type if sharding is used.
				</p><div class="title"><strong>Example: Accessing an IndexReader by Index Names</strong></div><p>
						
</p><pre class="programlisting">IndexReader reader = searchFactory.getIndexReaderAccessor().open("Products.1", "Products.3");</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="accessing_a_lucene_directory"/>Accessing a Lucene Directory</h2></div></div></div><p>
					A Directory is the most common abstraction used by Lucene to represent the index storage; Hibernate Search does not interact directly with a Lucene Directory but abstracts these interactions via an IndexManager: an index does not necessarily need to be implemented by a Directory.
				</p><p>
					If you know your index is represented as a Directory and need to access it, you can get a reference to the Directory via the IndexManager. Cast the IndexManager to a DirectoryBasedIndexManager and then use <code class="literal">getDirectoryProvider().getDirectory()</code> to get a reference to the underlying Directory. This is not recommended, we would encourage to use the IndexReader instead.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="sharding_indexes"/>Sharding Indexes</h2></div></div></div><p>
					In some cases it can be useful to split (shard) the indexed data of a given entity into several Lucene indexes.
				</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Sharding should only be implemented if the advantages outweigh the disadvantages. Searching sharded indexes will typically be slower as all shards have to be opened for a single search.
					</p></div><p>
					Possible use cases for sharding are:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							A single index is so large that index update times are slowing the application down.
						</li><li class="listitem">
							A typical search will only hit a subset of the index, such as when data is naturally segmented by customer, region or application.
						</li></ul></div><p>
					By default sharding is not enabled unless the number of shards is configured. To do this use the <code class="literal">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards</code> property.
				</p><div class="title"><strong>Example: Enabling Index Sharding</strong></div><p>
						In this example, five shards are enabled.
					</p><pre class="screen">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards = 5</pre><p>
					Responsible for splitting the data into sub-indexes is the IndexShardingStrategy. The default sharding strategy splits the data according to the hash value of the ID string representation (generated by the FieldBridge). This ensures a fairly balanced sharding. You can replace the default strategy by implementing a custom IndexShardingStrategy. To use your custom strategy you have to set the <code class="literal">hibernate.search.&lt;indexName&gt;.sharding_strategy</code> property.
				</p><div class="title"><strong>Example: Specifying a Custom Sharding Strategy</strong></div><p>
						
</p><pre class="screen">hibernate.search.&lt;indexName&gt;.sharding_strategy = my.shardingstrategy.Implementation</pre><p>

					</p><p>
					The IndexShardingStrategy property also allows for optimizing searches by selecting which shard to run the query against. By activating a filter a sharding strategy can select a subset of the shards used to answer a query (IndexShardingStrategy.getIndexManagersForQuery) and thus speed up the query execution.
				</p><p>
					Each shard has an independent IndexManager and so can be configured to use a different directory provider and back-end configuration. The IndexManager index names for the Animal entity in the example below are <code class="literal">Animal.0</code> to <code class="literal">Animal.4</code>. In other words, each shard has the name of its owning index followed by <code class="literal">.</code> (dot) and its index number.
				</p><div class="title"><strong>Example: Sharding Configuration for Entity Animal</strong></div><p>
						
</p><pre class="screen">hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Animal.sharding_strategy.nbr_of_shards = 5
hibernate.search.Animal.directory_provider = filesystem
hibernate.search.Animal.0.indexName = Animal00
hibernate.search.Animal.3.indexBase = /usr/lucene/sharded
hibernate.search.Animal.3.indexName = Animal03</pre><p>

					</p><p>
					In the example above, the configuration uses the default id string hashing strategy and shards the Animal index into 5 sub-indexes. All sub-indexes are filesystem instances and the directory where each sub-index is stored is as followed:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							for sub-index 0: <code class="literal">/usr/lucene/indexes/Animal00</code> (shared indexBase but overridden indexName)
						</li><li class="listitem">
							for sub-index 1: <code class="literal">/usr/lucene/indexes/Animal.1</code> (shared indexBase, default indexName)
						</li><li class="listitem">
							for sub-index 2: <code class="literal">/usr/lucene/indexes/Animal.2</code> (shared indexBase, default indexName)
						</li><li class="listitem">
							for sub-index 3: <code class="literal">/usr/lucene/shared/Animal03</code> (overridden indexBase, overridden indexName)
						</li><li class="listitem">
							for sub-index 4: <code class="literal">/usr/lucene/indexes/Animal.4</code> (shared indexBase, default indexName)
						</li></ul></div><p>
					When implementing a IndexShardingStrategy any field can be used to determine the sharding selection. Consider that to handle deletions, <code class="literal">purge</code> and <code class="literal">purgeAll</code> operations, the implementation might need to return one or more indexes without being able to read all the field values or the primary identifier. In that case the information is not enough to pick a single index, all indexes should be returned, so that the delete operation will be propagated to all indexes potentially containing the documents to be deleted.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="customizing_lucenes_scoring_formula"/>Customizing Lucene’s Scoring Formula</h2></div></div></div><p>
					Lucene allows the user to customize its scoring formula by extending org.apache.lucene.search.Similarity. The abstract methods defined in this class match the factors of the following formula calculating the score of query q for document d:
				</p><p>
					Extend org.apache.lucene.search.Similarity to customize Lucene’s scoring formula. The abstract methods match the formula used to calculate the score of query <code class="literal">q</code> for document <code class="literal">d</code> as follows:
				</p><pre class="screen">*score(q,d) = coord(q,d) · queryNorm(q) · ∑ ~t in q~ ( tf(t in d) ·
idf(t) ^2^ · t.getBoost() · norm(t,d) )*</pre><div class="informaltable"><table border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Factor</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									tf(t ind)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Term frequency factor for the term (t) in the document (d).
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									idf(t)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Inverse document frequency of the term.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									coord(q,d)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Score factor based on how many of the query terms are found in the specified document.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									queryNorm(q)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Normalizing factor used to make scores between queries comparable.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									t.getBoost()
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Field boost.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									norm(t,d)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Encapsulates a few (indexing time) boost and length factors.
								</p>
								 </td></tr></tbody></table></div><p>
					It is beyond the scope of this manual to explain this formula in more detail. See Similarity’s Javadocs for more information.
				</p><p>
					Hibernate Search provides three ways to modify Lucene’s similarity calculation.
				</p><p>
					First you can set the default similarity by specifying the fully specified class name of your Similarity implementation using the property <code class="literal">hibernate.search.similarity</code>. The default value is org.apache.lucene.search.DefaultSimilarity.
				</p><p>
					You can also override the similarity used for a specific index by setting the <code class="literal">similarity</code> property
				</p><pre class="screen">hibernate.search.default.similarity = my.custom.Similarity</pre><p>
					Finally you can override the default similarity on class level using the <code class="literal">@Similarity</code> annotation.
				</p><pre class="programlisting">@Entity
@Indexed
@Similarity(impl = DummySimilarity.class)
public class Book {
...
}</pre><p>
					As an example, let us assume it is not important how often a term appears in a document. Documents with a single occurrence of the term should be scored the same as documents with multiple occurrences. In this case your custom implementation of the method tf(float freq) should return 1.0.
				</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						When two entities share the same index they must declare the same Similarity implementation. Classes in the same class hierarchy always share the index, so it is not allowed to override the Similarity implementation in a subtype.
					</p><p>
						Likewise, it does not make sense to define the similarity via the index setting and the class-level setting as they would conflict. Such a configuration will be rejected.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="exception_handling_configuration"/>Exception Handling Configuration</h2></div></div></div><p>
					Hibernate Search allows you to configure how exceptions are handled during the indexing process. If no configuration is provided then exceptions are logged to the log output by default. It is possible to explicitly declare the exception logging mechanism as follows:
				</p><pre class="programlisting">hibernate.search.error_handler = log</pre><p>
					The default exception handling occurs for both synchronous and asynchronous indexing. Hibernate Search provides an easy mechanism to override the default error handling implementation.
				</p><p>
					In order to provide your own implementation you must implement the ErrorHandler interface, which provides the <code class="literal">handle(ErrorContext context)</code> method. <code class="literal">ErrorContext</code> provides a reference to the primary <code class="literal">LuceneWork</code> instance, the underlying exception and any subsequent <code class="literal">LuceneWork</code> instances that could not be processed due to the primary exception.
				</p><pre class="programlisting">public interface ErrorContext  {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</pre><p>
					To register this error handler with Hibernate Search you must declare the fully qualified classname of your ErrorHandler implementation in the configuration properties:
				</p><pre class="programlisting">hibernate.search.error_handler = CustomerErrorHandler</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="disable_hibernate_search"/>Disable Hibernate Search</h2></div></div></div><p>
					Hibernate Search can be partially or completely disabled as required. Hibernate Search’s indexing can be disabled, for example, if the index is read-only, or you prefer to perform indexing manually, rather than automatically. It is also possible to completely disable Hibernate Search, preventing indexing and searching.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Disable Indexing</span></dt><dd><p class="simpara">
								To disable Hibernate Search indexing, change the <code class="literal">indexing_strategy</code> configuration option to <code class="literal">manual</code>, then restart JBoss EAP.
							</p><pre class="screen">hibernate.search.indexing_strategy = manual</pre></dd><dt><span class="term">Disable Hibernate Search Completely</span></dt><dd><p class="simpara">
								To disable Hibernate Search completely, disable all listeners by changing the <code class="literal">autoregister_listeners</code> configuration option to <code class="literal">false</code>, then restart JBoss EAP.
							</p><pre class="screen">hibernate.search.autoregister_listeners = false</pre></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="monitoring"/>Monitoring</h1></div></div></div><p>
				Hibernate Search offers access to a <code class="literal">Statistics</code> object via <code class="literal">SearchFactory.getStatistics()</code>. It allows you, for example, to determine which classes are indexed and how many entities are in the index. This information is always available. However, by specifying the <code class="literal">hibernate.search.generate_statistics</code> property in your configuration you can also collect total and average Lucene query and object loading timings.
			</p><h3><a id="access_to_statistics_via_jmx"/>Access to Statistics via JMX</h3><p>
				To enable access to statistics via JMX, set the property <code class="literal">hibernate.search.jmx_enabled</code> to <code class="literal">true</code>. This will automatically register the <code class="literal">StatisticsInfoMBean</code> bean, providing access to statistics using the <code class="literal">Statistics</code> object. Depending on your configuration the <code class="literal">IndexingProgressMonitorMBean</code> bean may also be registered.
			</p><h3><a id="monitoring_indexing"/>Monitoring Indexing</h3><p>
				If the mass indexer API is used, you can monitor indexing progress using the <code class="literal">IndexingProgressMonitorMBean</code> bean. The bean is only bound to JMX while indexing is in progress.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					JMX beans can be accessed remotely using JConsole by setting the system property <code class="literal">com.sun.management.jmxremote</code> to <code class="literal">true</code>.
				</p></div></div></div></body></html>