<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 4. Hibernate Query Language</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="hibernate_query_language"/>Chapter 4. Hibernate Query Language</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_hibernate_query_language"/>About Hibernate Query Language</h1></div></div></div><h3><a id="introduction_to_jpql"/>Introduction to JPQL</h3><p>
				The Java Persistence Query Language (JPQL) is a platform-independent object-oriented query language defined as part of the Java Persistence API (JPA) specification. JPQL is used to make queries against entities stored in a relational database. It is heavily inspired by SQL, and its queries resemble SQL queries in syntax, but operate against JPA entity objects rather than directly with database tables.
			</p><h3><a id="introduction_to_hql"/>Introduction to HQL</h3><p>
				The Hibernate Query Language (HQL) is a powerful query language, similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association.
			</p><p>
				HQL is a superset of JPQL. An HQL query is not always a valid JPQL query, but a JPQL query is always a valid HQL query.
			</p><p>
				Both HQL and JPQL are non-type-safe ways to perform query operations. Criteria queries offer a type-safe approach to querying.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="HQL_statements"/>About HQL Statements</h1></div></div></div><p>
				Both HQL and JPQL allow <code class="literal">SELECT</code>, <code class="literal">UPDATE</code>, and <code class="literal">DELETE</code> statements. HQL additionally allows <code class="literal">INSERT</code> statements, in a form similar to a <code class="literal">SQL INSERT-SELECT</code>.
			</p><p>
				The following table shows the syntax in Backus-Naur Form (BNF) notation for the various HQL statements.
			</p><div class="table"><a id="idm140403999904080"/><p class="title"><strong>Table 4.1. HQL Statements</strong></p><div class="table-contents"><table summary="HQL Statements" border="1" width="100%"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Statement</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">SELECT</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The BNF for <code class="literal">SELECT</code> statements in HQL is:
							</p>
							 
<pre class="screen">select_statement :: =
        [select_clause]
        from_clause
        [where_clause]
        [groupby_clause]
        [having_clause]
        [orderby_clause]</pre>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">UPDATE</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The BNF for <code class="literal">UPDATE</code> statement in HQL is the same as it is in JPQL.
							</p>
							 
<pre class="screen">update_statement ::= update_clause [where_clause]

update_clause ::= UPDATE entity_name [[AS] identification_variable]
        SET update_item {, update_item}*

update_item ::= [identification_variable.]{state_field | single_valued_object_field}
        = new_value

new_value ::= scalar_expression |
                simple_entity_expression |
                NULL</pre>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">DELETE</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The BNF for <code class="literal">DELETE</code> statements in HQL is the same as it is in JPQL.
							</p>
							 
<pre class="screen">delete_statement ::= delete_clause [where_clause]

delete_clause ::= DELETE FROM entity_name [[AS] identification_variable]</pre>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">INSERT</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								The BNF for <code class="literal">INSERT</code> statement in HQL is:
							</p>
							 
<pre class="screen">insert_statement ::= insert_clause select_statement

insert_clause ::= INSERT INTO entity_name (attribute_list)

attribute_list ::= state_field[, state_field ]*</pre>
							 <p>
								There is no JPQL equivalent to this.
							</p>
							 </td></tr></tbody></table></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="about_bulk_updtae_insert_delete"/>Warning</h3><p>
					Hibernate allows the use of Data Manipulation Language (DML) to bulk insert, update and delete data directly in the mapped database through the Hibernate Query Language (HQL).
				</p><p>
					Using DML may violate the object/relational mapping and may affect object state. Object state stays in memory and by using DML, the state of an in-memory object is not affected, depending on the operation that is performed on the underlying database. In-memory data must be used with care if DML is used.
				</p></div><h3><a id="about_the_update_delete_statement"/>About the UPDATE and DELETE Statements</h3><p>
				The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is:
			</p><p>
				<code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					The <code class="literal">FROM</code> keyword and the <code class="literal">WHERE</code> Clause are optional. The <code class="literal">FROM</code> clause is responsible for defining the scope of object model types available to the rest of the query. It also is responsible for defining all the identification variables available to the rest of the query. The <code class="literal">WHERE</code> clause allows you to refine the list of instances returned.
				</p><p>
					The result of execution of a <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statement is the number of rows that are actually affected (updated or deleted).
				</p></div><div class="title"><strong>Example: Bulk Update Statement</strong></div><p>
					
</p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Company set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>

				</p><div class="title"><strong>Example: Bulk Delete Statement</strong></div><p>
					
</p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Company where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre><p>

				</p><p>
				The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicates the number of entities within the database that were affected by the operation.
			</p><p>
				Internally, the database might use multiple SQL statements to execute the operation in response to a DML <code class="literal">Update</code> or <code class="literal">Delete</code> request. This might be because of relationships that exist between tables and the join tables that need to be updated or deleted.
			</p><p>
				For example, issuing a delete statement, as in the example above, may actually result in deletes being executed against not just the <code class="literal">Company</code> table for companies that are named with <code class="literal">oldName</code>, but also against joined tables. Therefore a <code class="literal">Company</code> table in a bidirectional, many-to-many relationship with an <code class="literal">Employee</code> table would also lose rows from the corresponding join table, <code class="literal">Company_Employee</code>, as a result of the successful execution of the previous example.
			</p><p>
				The <code class="literal">deletedEntries</code> value above will contain a count of all the rows affected due to this operation, including the rows in the join tables.
			</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					Care should be taken when executing bulk update or delete operations because they may result in inconsistencies between the database and the entities in the active persistence context. In general, bulk update and delete operations should only be performed within a transaction in a new persistence context or before fetching or accessing entities whose state might be affected by such operations.
				</p></div><h3><a id="about_the_insert_statement"/>About the INSERT Statement</h3><p>
				HQL adds the ability to define <code class="literal">INSERT</code> statements. There is no JPQL equivalent to this. The Backus-Naur Form (BNF) for an HQL <code class="literal">INSERT</code> statement is:
			</p><pre class="screen">insert_statement ::= insert_clause select_statement

insert_clause ::= INSERT INTO entity_name (attribute_list)

attribute_list ::= state_field[, state_field ]*</pre><p>
				The <code class="literal">attribute_list</code> is analogous to the column specification in the SQL <code class="literal">INSERT</code> statement. For entities involved in mapped inheritance, only attributes directly defined on the named entity can be used in the <code class="literal">attribute_list</code>. Superclass properties are not allowed and subclass properties do not make sense. In other words, <code class="literal">INSERT</code> statements are inherently non-polymorphic.
			</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
					The <code class="literal">select_statement</code> can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. This can cause problems with Hibernate Types that are <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>. For example, this might cause mismatch issues between an attribute mapped as an <code class="literal">org.hibernate.type.DateType</code> and an attribute defined as a <code class="literal">org.hibernate.type.TimestampType</code>, even though the database might not make a distinction or might be able to handle the conversion.
				</p></div><p>
				For the <code class="literal">id</code> attribute, the insert statement gives you two options. You can either explicitly specify the <code class="literal">id</code> property in the <code class="literal">attribute_list</code>, in which case its value is taken from the corresponding select expression, or omit it from the <code class="literal">attribute_list</code> in which case a generated value is used. This latter option is only available when using <code class="literal">id</code> generators that operate "in the database"; attempting to use this option with any "in memory" type generators will cause an exception during parsing.
			</p><p>
				For optimistic locking attributes, the insert statement again gives you two options. You can either specify the attribute in the <code class="literal">attribute_list</code> in which case its value is taken from the corresponding select expressions, or omit it from the <code class="literal">attribute_list</code> in which case the <code class="literal">seed value</code> defined by the corresponding <code class="literal">org.hibernate.type.VersionType</code> is used.
			</p><div class="title"><strong>Example: INSERT Query Statements</strong></div><p>
					
</p><pre class="programlisting">String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery(hqlInsert).executeUpdate();</pre><p>

				</p><p><a id="bulk_insert"/></p><div class="title"><strong>Example: Bulk Insert Statement</strong></div><p>
					
</p><pre class="programlisting">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into Account (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre><p>

				</p><p>
				If you do not supply the value for the <code class="literal">id</code> attribute using the <code class="literal">SELECT</code> statement, an identifier is generated for you, as long as the underlying database supports auto-generated keys. The return value of this bulk insert operation is the number of entries actually created in the database.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_hql_ordering"/>About HQL Ordering</h1></div></div></div><p>
				The results of the query can also be ordered. The <code class="literal">ORDER BY</code> clause is used to specify the selected values to be used to order the result. The types of expressions considered valid as part of the order-by clause include:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						state fields
					</li><li class="listitem">
						component/embeddable attributes
					</li><li class="listitem">
						scalar expressions such as arithmetic operations, functions, etc.
					</li><li class="listitem">
						identification variable declared in the select clause for any of the previous expression types
					</li></ul></div><p>
				HQL does not mandate that all values referenced in the order-by clause must be named in the select clause, but it is required by JPQL. Applications desiring database portability should be aware that not all databases support referencing values in the order-by clause that are not referenced in the select clause.
			</p><p>
				Individual expressions in the order-by can be qualified with either <code class="literal">ASC</code> (ascending) or <code class="literal">DESC</code> (descending) to indicate the desired ordering direction.
			</p><div class="title"><strong>Example: Order By</strong></div><p>
					
</p><pre class="screen">// legal because p.name is implicitly part of p
select p
from Person p
order by p.name

select c.id, sum( o.total ) as t
from Order o
    inner join o.customer c
group by c.id
order by t</pre><p>

				</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_collection_memeber_references"/>About Collection Member References</h1></div></div></div><p>
				References to collection-valued associations actually refer to the <span class="emphasis"><em>values</em></span> of that collection.
			</p><div class="title"><strong>Example: Collection References</strong></div><p>
					
</p><pre class="screen">select c
from Customer c
    join c.orders o
    join o.lineItems l
    join l.product p
where o.status = 'pending'
  and p.status = 'backorder'

// alternate syntax
select c
from Customer c,
    in(c.orders) o,
    in(o.lineItems) l
    join l.product p
where o.status = 'pending'
  and p.status = 'backorder'</pre><p>

				</p><p>
				In the example, the identification variable <code class="literal">o</code> actually refers to the object model type Order which is the type of the elements of the Customer#orders association.
			</p><p>
				The example also shows the alternate syntax for specifying collection association joins using the <code class="literal">IN</code> syntax. Both forms are equivalent. Which form an application chooses to use is simply a matter of taste.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_qualified_path_expressions"/>About Qualified Path Expressions</h1></div></div></div><p>
				It was previously stated that collection-valued associations actually refer to the <span class="emphasis"><em>values</em></span> of that collection. Based on the type of collection, there are also available a set of explicit qualification expressions.
			</p><div class="table"><a id="idm140403994281440"/><p class="title"><strong>Table 4.2. Qualified Path Expressions</strong></p><div class="table-contents"><table summary="Qualified Path Expressions" border="1" width="100%"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Expression</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">VALUE</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Refers to the collection value. Same as not specifying a qualifier. Useful to explicitly show intent. Valid for any type of collection-valued reference.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">INDEX</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								According to HQL rules, this is valid for both Maps and Lists which specify a javax.persistence.OrderColumn annotation to refer to the Map key or the List position (aka the OrderColumn value). JPQL however, reserves this for use in the List case and adds <code class="literal">KEY</code> for the MAP case. Applications interested in JPA provider portability should be aware of this distinction.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">KEY</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Valid only for Maps. Refers to the map’s key. If the key is itself an entity, can be further navigated.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<code class="literal">ENTRY</code>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Only valid only for Maps. Refers to the Map’s logical java.util.Map.Entry tuple (the combination of its key and value). <code class="literal">ENTRY</code> is only valid as a terminal path and only valid in the select clause.
							</p>
							 </td></tr></tbody></table></div></div><div class="title"><strong>Example: Qualified Collection References</strong></div><p>
					
</p><pre class="screen">// Product.images is a Map&lt;String,String&gt; : key = a name, value = file path

// select all the image file paths (the map value) for Product#123
select i
from Product p
    join p.images i
where p.id = 123

// same as above
select value(i)
from Product p
    join p.images i
where p.id = 123

// select all the image names (the map key) for Product#123
select key(i)
from Product p
    join p.images i
where p.id = 123

// select all the image names and file paths (the 'Map.Entry') for Product#123
select entry(i)
from Product p
    join p.images i
where p.id = 123

// total the value of the initial line items for all orders for a customer
select sum( li.amount )
from Customer c
        join c.orders o
        join o.lineItems li
where c.id = 123
  and index(li) = 1</pre><p>

				</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_hql_functions"/>About HQL Functions</h1></div></div></div><p>
				HQL defines some standard functions that are available regardless of the underlying database in use. HQL can also understand additional functions defined by the dialect and the application.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="hql_standardized_functions"/>About HQL Standardized Functions</h2></div></div></div><p>
					The following functions are available in HQL regardless of the underlying database in use.
				</p><div class="table"><a id="idm140403990178560"/><p class="title"><strong>Table 4.3. HQL Standardized Functions</strong></p><div class="table-contents"><table summary="HQL Standardized Functions" border="1" width="100%"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Function</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">BIT_LENGTH</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Returns the length of binary data.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">CAST</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Performs an SQL cast. The cast target should name the Hibernate mapping type to use.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">EXTRACT</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Performs an SQL extraction on datetime values. An extraction returns a part of the date/time value, for example, the year. See the abbreviated forms below.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">SECOND</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated extract form for extracting the second.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">MINUTE</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated extract form for extracting the minute.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">HOUR</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated extract form for extracting the hour.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">DAY</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated extract form for extracting the day.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">MONTH</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated extract form for extracting the month.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">YEAR</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated extract form for extracting the year.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">STR</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Abbreviated form for casting a value as character data.
								</p>
								 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_hql_non_standardized_functions"/>About HQL Non-Standardized Functions</h2></div></div></div><p>
					Hibernate dialects can register additional functions known to be available for that particular database product. They would only be available when using that database or dialect. Applications that aim for database portability should avoid using functions in this category.
				</p><p>
					Application developers can also supply their own set of functions. This would usually represent either custom SQL functions or aliases for snippets of SQL. Such function declarations are made by using the <code class="literal">addSqlFunction</code> method of <code class="literal">org.hibernate.cfg.Configuration</code>.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_concatenation_operation"/>About the Concatenation Operation</h2></div></div></div><p>
					HQL defines a concatenation operator in addition to supporting the concatenation (<code class="literal">CONCAT</code>) function. This is not defined by JPQL, so portable applications should avoid using it. The concatenation operator is taken from the SQL concatenation operator (<code class="literal">||</code>).
				</p><div class="title"><strong>Example: Concatenation Operation Example</strong></div><p>
						
</p><pre class="screen">select 'Mr. ' || c.name.first || ' ' || c.name.last
from Customer c
where c.gender = Gender.MALE</pre><p>

					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_dynamic_instantiation"/>About Dynamic Instantiation</h1></div></div></div><p>
				There is a particular expression type that is only valid in the select clause. Hibernate calls this "dynamic instantiation". JPQL supports some of this feature and calls it a "constructor expression".
			</p><div class="title"><strong>Example: Dynamic Instantiation Example - Constructor</strong></div><p>
					
</p><pre class="screen">select new Family( mother, mate, offspr )
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><p>

				</p><p>
				So rather than dealing with the Object[] here we are wrapping the values in a type-safe java object that will be returned as the results of the query. The class reference must be fully qualified and it must have a matching constructor.
			</p><p>
				The class here does not need to be mapped. If it does represent an entity, the resulting instances are returned in the NEW state (not managed!).
			</p><p>
				This is the part JPQL supports as well. HQL supports additional "dynamic instantiation" features. First, the query can specify to return a List rather than an Object[] for scalar results:
			</p><div class="title"><strong>Example: Dynamic Instantiation Example - List</strong></div><p>
					
</p><pre class="screen">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><p>

				</p><p>
				The results from this query will be a List&lt;List&gt; as opposed to a List&lt;Object[]&gt;.
			</p><p>
				HQL also supports wrapping the scalar results in a Map.
			</p><div class="title"><strong>Example: Dynamic Instantiation Example - Map</strong></div><p>
					
</p><pre class="screen">select new map( mother as mother, offspr as offspr, mate as mate )
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr

select new map( max(c.bodyWeight) as max, min(c.bodyWeight) as min, count(*) as n )
from Cat cxt</pre><p>

				</p><p>
				The results from this query will be a List&lt;Map&lt;String,Object&gt;&gt; as opposed to a List&lt;Object[]&gt;. The keys of the map are defined by the aliases given to the select expressions.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_hql_predicates"/>About HQL Predicates</h1></div></div></div><p>
				Predicates form the basis of the <code class="literal">where</code> clause, the <code class="literal">having</code> clause and searched case expressions. They are expressions which resolve to a truth value, generally <code class="literal">TRUE</code> or <code class="literal">FALSE</code>, although boolean comparisons involving NULL values generally resolve to <code class="literal">UNKNOWN</code>.
			</p><h3><a id="hql_predicates"/>HQL Predicates</h3><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
						Null Predicate
					</p><p class="simpara">
						Check a value for null. Can be applied to basic attribute references, entity references and parameters. HQL additionally allows it to be applied to component/embeddable types.
					</p><div class="title"><strong>Example: NULL Check</strong></div><p>
							
</p><pre class="screen">// select everyone with an associated address
select p
from Person p
where p.address is not null

// select everyone without an associated address
select p
from Person p
  where p.address is null</pre><p>

						</p></li><li class="listitem"><p class="simpara">
						Like Predicate
					</p><p class="simpara">
						Performs a like comparison on string values. The syntax is:
					</p><pre class="screen">like_expression ::=
       string_expression
       [NOT] LIKE pattern_value
       [ESCAPE escape_character]</pre><p class="simpara">
						The semantics follow that of the SQL like expression. The <code class="literal">pattern_value</code> is the pattern to attempt to match in the <code class="literal">string_expression</code>. Just like SQL, <code class="literal">pattern_value</code> can use <code class="literal">_</code> (underscore) and <code class="literal">%</code> (percent) as wildcards. The meanings are the same. The <code class="literal">_</code> matches any single character. The <code class="literal">%</code> matches any number of characters.
					</p><p class="simpara">
						The optional <code class="literal">escape_character</code> is used to specify an escape character used to escape the special meaning of <code class="literal">_</code> and <code class="literal">%</code> in the <code class="literal">pattern_value</code>. This is useful when needing to search on patterns including either <code class="literal">_</code> or <code class="literal">%</code>.
					</p><div class="title"><strong>Example: LIKE Predicate</strong></div><p>
							
</p><pre class="screen">select p
from Person p
where p.name like '%Schmidt'

select p
from Person p
where p.name not like 'Jingleheimmer%'

// find any with name starting with "sp_"
select sp
from StoredProcedureMetadata sp
where sp.name like 'sp|_%' escape '|'</pre><p>

						</p></li><li class="listitem"><p class="simpara">
						Between Predicate
					</p><p class="simpara">
						Analogous to the SQL <code class="literal">BETWEEN</code> expression. Perform an evaluation that a value is within the range of 2 other values. All the operands should have comparable types.
					</p><div class="title"><strong>Example: BETWEEN Predicate</strong></div><p>
							
</p><pre class="screen">select p
from Customer c
    join c.paymentHistory p
where c.id = 123
  and index(p) between 0 and 9

select c
from Customer c
where c.president.dateOfBirth
        between {d '1945-01-01'}
            and {d '1965-01-01'}

select o
from Order o
where o.total between 500 and 5000

select p
from Person p
where p.name between 'A' and 'E'</pre><p>

						</p></li><li class="listitem"><p class="simpara">
						IN Predicate
					</p><p class="simpara">
						The <code class="literal">IN</code> predicate performs a check that a particular value is in a list of values. Its syntax is:
					</p><pre class="screen">in_expression ::= single_valued_expression
            [NOT] IN single_valued_list

single_valued_list ::= constructor_expression |
            (subquery) |
            collection_valued_input_parameter

constructor_expression ::= (expression[, expression]*)</pre><p class="simpara">
						The types of the <code class="literal">single_valued_expression</code> and the individual values in the <code class="literal">single_valued_list</code> must be consistent. JPQL limits the valid types here to string, numeric, date, time, timestamp, and enum types. In JPQL, <code class="literal">single_valued_expression</code> can only refer to:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								"state fields", which is its term for simple attributes. Specifically this excludes association and component/embedded attributes.
							</li><li class="listitem"><p class="simpara">
								entity type expressions.
							</p><p class="simpara">
								In HQL, <code class="literal">single_valued_expression</code> can refer to a far more broad set of expression types. Single-valued association are allowed. So are component/embedded attributes, although that feature depends on the level of support for tuple or "row value constructor syntax" in the underlying database. Additionally, HQL does not limit the value type in any way, though application developers should be aware that different types may incur limited support based on the underlying database vendor. This is largely the reason for the JPQL limitations.
							</p><p class="simpara">
								The list of values can come from a number of different sources. In the <code class="literal">constructor_expression</code> and <code class="literal">collection_valued_input_parameter</code>, the list of values must not be empty; it must contain at least one value.
							</p><div class="title"><strong>Example: IN Predicate</strong></div><p>
									
</p><pre class="screen">select p
from Payment p
where type(p) in (CreditCardPayment, WireTransferPayment)

select c
from Customer c
where c.hqAddress.state in ('TX', 'OK', 'LA', 'NM')

select c
from Customer c
where c.hqAddress.state in ?

select c
from Customer c
where c.hqAddress.state in (
    select dm.state
    from DeliveryMetadata dm
    where dm.salesTax is not null
)

// Not JPQL compliant!
select c
from Customer c
where c.name in (
    ('John','Doe'),
    ('Jane','Doe')
)

// Not JPQL compliant!
select c
from Customer c
where c.chiefExecutive in (
    select p
    from Person p
    where ...
)</pre><p>

								</p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_relational_comparisons"/>About Relational Comparisons</h1></div></div></div><p>
				Comparisons involve one of the comparison operators - =, &gt;, &gt;=, &lt;, ⇐, &lt;&gt;. HQL also defines != as a comparison operator synonymous with &lt;&gt;. The operands should be of the same type.
			</p><div class="title"><strong>Example: Relational Comparison Examples</strong></div><p>
					
</p><pre class="screen">// numeric comparison
select c
from Customer c
where c.chiefExecutive.age &lt; 30

// string comparison
select c
from Customer c
where c.name = 'Acme'

// datetime comparison
select c
from Customer c
where c.inceptionDate &lt; {d '2000-01-01'}

// enum comparison
select c
from Customer c
where c.chiefExecutive.gender = com.acme.Gender.MALE

// boolean comparison
select c
from Customer c
where c.sendEmail = true

// entity type comparison
select p
from Payment p
where type(p) = WireTransferPayment

// entity value comparison
select c
from Customer c
where c.chiefExecutive = c.chiefTechnologist</pre><p>

				</p><p>
				Comparisons can also involve subquery qualifiers - <code class="literal">ALL</code>, <code class="literal">ANY</code>, <code class="literal">SOME</code>. <code class="literal">SOME</code> and <code class="literal">ANY</code> are synonymous.
			</p><p>
				The <code class="literal">ALL</code> qualifier resolves to true if the comparison is true for all of the values in the result of the subquery. It resolves to false if the subquery result is empty.
			</p><div class="title"><strong>Example: ALL Subquery Comparison Qualifier Example</strong></div><p>
					
</p><pre class="screen">// select all players that scored at least 3 points
// in every game.
select p
from Player p
where 3 &gt; all (
   select spg.points
   from StatsPerGame spg
   where spg.player = p
)</pre><p>

				</p><p>
				The <code class="literal">ANY</code>/<code class="literal">SOME</code> qualifier resolves to true if the comparison is true for at least one of the values in the result of the subquery. It resolves to false if the subquery result is empty.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="bytecode_enhancement"/>Bytecode Enhancement</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="lazy_attribute_loading"/>Lazy Attribute Loading</h2></div></div></div><p>
					Lazy attribute loading is a bytecode enhancement which allows you to tell Hibernate that only certain parts of an entity should be loaded upon fetching from the database, and when the other remaining parts should be loaded as well. This is different from proxy-based idea of lazy loading which is entity-centric where the entity’s state is loaded at once as needed. With bytecode enhancement, individual attributes or groups of attributes are loaded as needed.
				</p><p>
					Lazy attributes can be designated to be loaded together and this is called a <span class="emphasis"><em>lazy group</em></span>. By default, all singular attributes are part of a single group. When one lazy singular attribute is accessed, all lazy singular attributes are loaded. Contrary to lazy singular group, lazy plural attributes are each a discrete lazy group. This behavior is explicitly controllable through the <code class="literal">@org.hibernate.annotations.LazyGroup</code> annotation.
				</p><pre class="programlisting">@Entity
public class Customer {

    @Id
    private Integer id;

    private String name;

    @Basic( fetch = FetchType.LAZY )
    private UUID accountsPayableXrefId;

    @Lob
    @Basic( fetch = FetchType.LAZY )
    @LazyGroup( "lobs" )
    private Blob image;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public UUID getAccountsPayableXrefId() {
        return accountsPayableXrefId;
    }

    public void setAccountsPayableXrefId(UUID accountsPayableXrefId) {
        this.accountsPayableXrefId = accountsPayableXrefId;
    }

    public Blob getImage() {
        return image;
    }

    public void setImage(Blob image) {
        this.image = image;
    }
}</pre><p>
					In the example above, there are two lazy attributes: <code class="literal">accountsPayableXrefId</code> and <code class="literal">image</code>. Each of these attributes is part of a different fetch group. The <code class="literal">accountsPayableXrefId</code> attribute is a part of the default fetch group, which means that accessing <code class="literal">accountsPayableXrefId</code> will not force the loading of the <code class="literal">image</code> attribute, and vice versa.
				</p></div></div></div></body></html>