<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 6. Hibernate Envers</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="hibernate_envers"/>Chapter 6. Hibernate Envers</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_hibernate_envers"/>About Hibernate Envers</h1></div></div></div><p>
				Hibernate Envers is an auditing and versioning system, providing JBoss EAP with a means to track historical changes to persistent classes. Audit tables are created for entities annotated with <code class="literal">@Audited</code>, which store the history of changes made to the entity. The data can then be retrieved and queried.
			</p><p>
				Envers allows developers to:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						audit all mappings defined by the JPA specification
					</li><li class="listitem">
						audit all hibernate mappings that extend the JPA specification
					</li><li class="listitem">
						audit entities mapped by or using the native Hibernate API
					</li><li class="listitem">
						log data for each revision using a revision entity
					</li><li class="listitem">
						query historical data
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="about_auditing_persistent_classes"/>About Auditing Persistent Classes</h1></div></div></div><p>
				Auditing of persistent classes is done in JBoss EAP through Hibernate Envers and the <code class="literal">@Audited</code> annotation. When the annotation is applied to a class, a table is created, which stores the revision history of the entity.
			</p><p>
				Each time a change is made to the class, an entry is added to the audit table. The entry contains the changes to the class, and is given a revision number. This means that changes can be rolled back, or previous revisions can be viewed.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="auditing_strategies"/>Auditing Strategies</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_auditing_strategies"/>About Auditing Strategies</h2></div></div></div><p>
					Auditing strategies define how audit information is persisted, queried and stored. There are currently two audit strategies available with Hibernate Envers:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Default Audit Strategy</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										This strategy persists the audit data together with a start revision. For each row that is inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables, along with the start revision of its validity.
									</li><li class="listitem">
										Rows in the audit tables are never updated after insertion. Queries of audit information use subqueries to select the applicable rows in the audit tables, which are slow and difficult to index.
									</li></ul></div></dd><dt><span class="term">Validity Audit Strategy</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
										This strategy stores the start revision, as well as the end revision of the audit information. For each row that is inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables, along with the start revision of its validity.
									</li><li class="listitem">
										At the same time, the end revision field of the previous audit rows (if available) is set to this revision. Queries on the audit information can then use <span class="emphasis"><em>between start and end revision</em></span>, instead of subqueries. This means that persisting audit information is a little slower because of the extra updates, but retrieving audit information is a lot faster.
									</li><li class="listitem">
										This can also be improved by adding extra indexes.
									</li></ul></div></dd></dl></div><p>
					For more information on auditing, see <a class="link" href="hibernate_envers.html#about_auditing_persistent_classes" title="About Auditing Persistent Classes">About Auditing Persistent Classes</a>. To set the auditing strategy for the application, see <a class="link" href="hibernate_envers.html#set_the_auditing_strategy" title="Set the Auditing Strategy">Set the Auditing Strategy</a>.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="set_the_auditing_strategy"/>Set the Auditing Strategy</h2></div></div></div><p>
					There are two audit strategies supported by JBoss EAP:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The default audit strategy
						</li><li class="listitem">
							The validity audit strategy
						</li></ul></div><h4><a id="define_an_auditing_strategy"/>Define an Auditing Strategy</h4><p>
					Configure the <code class="literal">org.hibernate.envers.audit_strategy</code> property in the <code class="literal">persistence.xml</code> file of the application. If the property is not set in the <code class="literal">persistence.xml</code> file, then the default audit strategy is used.
				</p><div class="title"><strong>Set the <span class="strong"><strong>Default</strong></span> Audit Strategy</strong></div><p>
						
</p><pre class="programlisting">&lt;property name="org.hibernate.envers.audit_strategy" value="org.hibernate.envers.strategy.DefaultAuditStrategy"/&gt;</pre><p>

					</p><div class="title"><strong>Set the <span class="strong"><strong>Validity</strong></span> Audit Strategy</strong></div><p>
						
</p><pre class="programlisting">&lt;property name="org.hibernate.envers.audit_strategy" value="org.hibernate.envers.strategy.ValidityAuditStrategy"/&gt;</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="add_auditing_suppprt_to_a_jpa_entity"/>Adding Auditing Support to a JPA Entity</h2></div></div></div><p>
					JBoss EAP uses entity auditing, through <a class="link" href="hibernate_envers.html#about_hibernate_envers" title="About Hibernate Envers">About Hibernate Envers</a>, to track the historical changes of a persistent class. This section covers adding auditing support for a JPA entity.
				</p><div class="orderedlist"><p class="title"><strong>Add Auditing Support to a JPA Entity</strong></p><ol class="orderedlist"><li class="listitem">
							Configure the available auditing parameters to suit the deployment. See <a class="link" href="hibernate_envers.html#configure_envres_parameters" title="Configure Envers Parameters">Configure Envers Parameters</a> for details.
						</li><li class="listitem">
							Open the JPA entity to be audited.
						</li><li class="listitem">
							Import the <code class="literal">org.hibernate.envers.Audited</code> interface.
						</li><li class="listitem"><p class="simpara">
							Apply the <code class="literal">@Audited</code> annotation to each field or property to be audited, or apply it once to the whole class.
						</p><div class="title"><strong>Example: Audit Two Fields</strong></div><p>
								
</p><pre class="programlisting">import org.hibernate.envers.Audited;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Column;

@Entity
public class Person {
    @Id
    @GeneratedValue
    private int id;

    @Audited
    private String name;

    private String surname;

    @ManyToOne
    @Audited
    private Address address;

    // add getters, setters, constructors, equals and hashCode here
}</pre><p>

							</p><div class="title"><strong>Example: Audit an Entire Class</strong></div><p>
								
</p><pre class="programlisting">import org.hibernate.envers.Audited;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Column;

@Entity
@Audited
public class Person {
    @Id
    @GeneratedValue
    private int id;

    private String name;

    private String surname;

    @ManyToOne
    private Address address;

    // add getters, setters, constructors, equals and hashCode here
}</pre><p>

							</p></li></ol></div><p>
					Once the JPA entity has been configured for auditing, a table called <code class="literal">_AUD</code> will be created to store the historical changes.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configuration-1"/>Configuration</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="configure_envres_parameters"/>Configure Envers Parameters</h2></div></div></div><p>
					JBoss EAP uses entity auditing, through Hibernate Envers, to track the historical changes of a persistent class.
				</p><div class="orderedlist"><p class="title"><strong>Configuring the Available Envers Parameters</strong></p><ol class="orderedlist"><li class="listitem">
							Open the <code class="literal">persistence.xml</code> file for the application.
						</li><li class="listitem"><p class="simpara">
							Add, remove or configure Envers properties as required. For a list of available properties, see <a class="link" href="hibernate_envers.html#envers_configuration_properties" title="Envers Configuration Properties">Envers Configuration Properties</a>.
						</p><div class="title"><strong>Example: Envers Parameters</strong></div><p>
								
</p><pre class="programlisting">&lt;persistence-unit name="mypc"&gt;
  &lt;description&gt;Persistence Unit.&lt;/description&gt;
  &lt;jta-data-source&gt;java:jboss/datasources/ExampleDS&lt;/jta-data-source&gt;
  &lt;shared-cache-mode&gt;ENABLE_SELECTIVE&lt;/shared-cache-mode&gt;
  &lt;properties&gt;
    &lt;property name="hibernate.hbm2ddl.auto" value="create-drop" /&gt;
    &lt;property name="hibernate.show_sql" value="true" /&gt;
    &lt;property name="hibernate.cache.use_second_level_cache" value="true" /&gt;
    &lt;property name="hibernate.cache.use_query_cache" value="true" /&gt;
    &lt;property name="hibernate.generate_statistics" value="true" /&gt;
    &lt;property name="org.hibernate.envers.versionsTableSuffix" value="_V" /&gt;
    &lt;property name="org.hibernate.envers.revisionFieldName" value="ver_rev" /&gt;
  &lt;/properties&gt;
&lt;/persistence-unit&gt;</pre><p>

							</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="enable_or_disable_auditing_at_runtime"/>Enable or Disable Auditing at Runtime</h2></div></div></div><div class="orderedlist"><p class="title"><strong>Enable or Disable Entity Version Auditing at Runtime</strong></p><ol class="orderedlist"><li class="listitem">
							Subclass the <code class="literal">AuditEventListener</code> class.
						</li><li class="listitem"><p class="simpara">
							Override the following methods that are called on Hibernate events:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									<code class="literal">onPostInsert</code>
								</li><li class="listitem">
									<code class="literal">onPostUpdate</code>
								</li><li class="listitem">
									<code class="literal">onPostDelete</code>
								</li><li class="listitem">
									<code class="literal">onPreUpdateCollection</code>
								</li><li class="listitem">
									<code class="literal">onPreRemoveCollection</code>
								</li><li class="listitem">
									<code class="literal">onPostRecreateCollection</code>
								</li></ul></div></li><li class="listitem">
							Specify the subclass as the listener for the events.
						</li><li class="listitem">
							Determine if the change should be audited.
						</li><li class="listitem">
							Pass the call to the superclass if the change should be audited.
						</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="configure_conditional_auditing"/>Configure Conditional Auditing</h2></div></div></div><p>
					Hibernate Envers persists audit data in reaction to various Hibernate events, using a series of event listeners. These listeners are registered automatically if the Envers JAR is in the class path.
				</p><div class="orderedlist"><p class="title"><strong>Implement Conditional Auditing</strong></p><ol class="orderedlist"><li class="listitem">
							Set the <code class="literal">hibernate.listeners.envers.autoRegister</code> Hibernate property to false in the <code class="literal">persistence.xml</code> file.
						</li><li class="listitem">
							Subclass each event listener to be overridden. Place the conditional auditing logic in the subclass, and call the super method if auditing should be performed.
						</li><li class="listitem">
							Create a custom implementation of <code class="literal">org.hibernate.integrator.spi.Integrator</code>, similar to <code class="literal">org.hibernate.envers.event.EnversIntegrator</code>. Use the event listener subclasses created in step two, rather than the default classes.
						</li><li class="listitem">
							Add a <code class="literal">META-INF/services/org.hibernate.integrator.spi.Integrator</code> file to the JAR. This file should contain the fully qualified name of the class implementing the interface.
						</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="envers_configuration_properties"/>Envers Configuration Properties</h2></div></div></div><div class="table"><a id="idm140404014400672"/><p class="title"><strong>Table 6.1. Entity Data Versioning Configuration Parameters</strong></p><div class="table-contents"><table summary="Entity Data Versioning Configuration Parameters" border="1" width="100%"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top">Property Name</th><th style="text-align: left" valign="top">Default Value</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.audit_table_prefix</code>
								</p>
								 </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>
									A string that is prepended to the name of an audited entity, to create the name of the entity that will hold the audit information.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.audit_table_suffix</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									_AUD
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									A string that is appended to the name of an audited entity to create the name of the entity that will hold the audit information. For example, if an entity with a table name of <code class="literal">Person</code> is audited, Envers will generate a table called <code class="literal">Person_AUD</code> to store the historical data.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.revision_field_name</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									REV
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The name of the field in the audit entity that holds the revision number.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.revision_type_field_name</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									REVTYPE
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The name of the field in the audit entity that holds the type of revision. The current types of revisions possible are: <code class="literal">add</code>, <code class="literal">mod</code> and <code class="literal">del</code> for inserting, modifying or deleting respectively.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.revision_on_collection_change</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									true
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This property determines if a revision should be generated if a relation field that is not owned changes. This can either be a collection in a one-to-many relation, or the field using the <code class="literal">mappedBy</code> attribute in a one-to-one relation.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.do_not_audit_optimistic_locking_field</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									true
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									When true, properties used for optimistic locking (annotated with <code class="literal">@Version</code>) will automatically be excluded from auditing.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.store_data_at_delete</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									false
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This property defines whether or not entity data should be stored in the revision when the entity is deleted, instead of only the ID, with all other properties marked as null. This is not usually necessary, as the data is present in the last-but-one revision. Sometimes, however, it is easier and more efficient to access it in the last revision. However, this means the data the entity contained before deletion is stored twice.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.default_schema</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									null (same as normal tables)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The default schema name used for audit tables. Can be overridden using the <code class="literal">@AuditTable(schema="…​")</code> annotation. If not present, the schema will be the same as the schema of the normal tables.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.default_catalog</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									null (same as normal tables)
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The default catalog name that should be used for audit tables. Can be overridden using the <code class="literal">@AuditTable(catalog="…​")</code> annotation. If not present, the catalog will be the same as the catalog of the normal tables.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.strategy.DefaultAuditStrategy</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This property defines the audit strategy that should be used when persisting audit data. By default, only the revision where an entity was modified is stored. Alternatively, <code class="literal">org.hibernate.envers.strategy.ValidityAuditStrategy</code> stores both the start revision and the end revision. Together, these define when an audit row was valid.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy_validity_end_rev_field_name</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									REVEND
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The column name that will hold the end revision number in audit entities. This property is only valid if the validity audit strategy is used.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									false
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This property defines whether the timestamp of the end revision, where the data was last valid, should be stored in addition to the end revision itself. This is useful to be able to purge old audit records out of a relational database by using table partitioning. Partitioning requires a column that exists within the table. This property is only evaluated if the <code class="literal">ValidityAuditStrategy</code> is used.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									REVEND_TSTMP
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Column name of the timestamp of the end revision at which point the data was still valid. Only used if the <code class="literal">ValidityAuditStrategy</code> is used, and <code class="literal">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> evaluates to true.
								</p>
								 </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="querying_audit_information"/>Querying Audit Information</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="retrieve_auditing_information"/>Retrieve Auditing Information Through Queries</h2></div></div></div><p>
					Hibernate Envers provides the functionality to retrieve audit information through queries.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Queries on the audited data will be, in many cases, much slower than corresponding queries on <code class="literal">live</code> data, as they involve correlated subselects.
					</p></div><div class="title"><strong>Querying for Entities of a Class at a Given Revision</strong></div><p>
						The entry point for this type of query is:
					</p><pre class="programlisting">AuditQuery query = getAuditReader()
    .createQuery()
    .forEntitiesAtRevision(MyEntity.class, revisionNumber);</pre><p>
					Constraints can then be specified, using the <code class="literal">AuditEntity</code> factory class. The query below only selects entities where the <code class="literal">name</code> property is equal to <code class="literal">John</code>:
				</p><pre class="programlisting">query.add(AuditEntity.property("name").eq("John"));</pre><p>
					The queries below only select entities that are related to a given entity:
				</p><pre class="programlisting">query.add(AuditEntity.property("address").eq(relatedEntityInstance));
// or
query.add(AuditEntity.relatedId("address").eq(relatedEntityId));</pre><p>
					The results can then be ordered, limited, and have aggregations and projections (except grouping) set. The example below is a full query.
				</p><pre class="programlisting">List personsAtAddress = getAuditReader().createQuery()
    .forEntitiesAtRevision(Person.class, 12)
    .addOrder(AuditEntity.property("surname").desc())
    .add(AuditEntity.relatedId("address").eq(addressId))
    .setFirstResult(4)
    .setMaxResults(2)
    .getResultList();</pre><div class="title"><strong>Query Revisions where Entities of a Given Class Changed</strong></div><p>
						The entry point for this type of query is:
					</p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true);</pre><p>
					Constraints can be added to this query in the same way as the previous example. There are additional possibilities for this query:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">AuditEntity.revisionNumber()</code></span></dt><dd>
								Specify constraints, projections and order on the revision number in which the audited entity was modified.
							</dd><dt><span class="term"><code class="literal">AuditEntity.revisionProperty(propertyName)</code></span></dt><dd>
								Specify constraints, projections and order on a property of the revision entity, corresponding to the revision in which the audited entity was modified.
							</dd><dt><span class="term"><code class="literal">AuditEntity.revisionType()</code></span></dt><dd>
								Provides accesses to the type of the revision (ADD, MOD, DEL).
							</dd></dl></div><p>
					The query results can then be adjusted as necessary. The query below selects the smallest revision number at which the entity of the <code class="literal">MyEntity</code> class, with the <code class="literal">entityId</code> ID has changed, after revision number 42:
				</p><pre class="programlisting">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.id().eq(entityId))
    .add(AuditEntity.revisionNumber().gt(42))
    .getSingleResult();</pre><p>
					Queries for revisions can also minimize/maximize a property. The query below selects the revision at which the value of the <code class="literal">actualDate</code> for a given entity was larger than a given value, but as small as possible:
				</p><pre class="programlisting">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    // We are only interested in the first revision
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.property("actualDate").minimize()
        .add(AuditEntity.property("actualDate").ge(givenDate))
        .add(AuditEntity.id().eq(givenEntityId)))
    .getSingleResult();</pre><p>
					The <code class="literal">minimize()</code> and <code class="literal">maximize()</code> methods return a criteria, to which constraints can be added, which must be met by the entities with the maximized/minimized properties.
				</p><p>
					There are two boolean parameters passed when creating the query.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">selectEntitiesOnly</code></span></dt><dd>
								<br/> This parameter is only valid when an explicit projection is not set. <br/> If <code class="literal">true</code>, the result of the query will be a list of entities that changed at revisions satisfying the specified constraints. <br/> If <code class="literal">false</code>, the result will be a list of three element arrays. The first element will be the changed entity instance. The second will be an entity containing revision data. If no custom entity is used, this will be an instance of <code class="literal">DefaultRevisionEntity</code>. The third element array will be the type of the revision (ADD, MOD, DEL).
							</dd><dt><span class="term"><code class="literal">selectDeletedEntities</code></span></dt><dd>
								This parameter specifies if revisions in which the entity was deleted must be included in the results. If true, the entities will have the revision type <code class="literal">DEL</code>, and all fields, except id, will have the value <code class="literal">null</code>.
							</dd></dl></div><div class="title"><strong>Query Revisions of an Entity that Modified a Given Property</strong></div><p>
						The query below will return all revisions of <code class="literal">MyEntity</code> with a given id, where the <code class="literal">actualDate</code> property has been changed.
					</p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery()
  .forRevisionsOfEntity(MyEntity.class, false, true)
  .add(AuditEntity.id().eq(id));
  .add(AuditEntity.property("actualDate").hasChanged())</pre><p>
					The <code class="literal">hasChanged</code> condition can be combined with additional criteria. The query below will return a horizontal slice for <code class="literal">MyEntity</code> at the time the revisionNumber was generated. It will be limited to the revisions that modified <code class="literal">prop1</code>, but not <code class="literal">prop2</code>.
				</p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery()
  .forEntitiesAtRevision(MyEntity.class, revisionNumber)
  .add(AuditEntity.property("prop1").hasChanged())
  .add(AuditEntity.property("prop2").hasNotChanged());</pre><p>
					The result set will also contain revisions with numbers lower than the revisionNumber. This means that this query cannot be read as "Return all <code class="literal">MyEntities</code> changed in revisionNumber with <code class="literal">prop1</code> modified and <code class="literal">prop2</code> untouched."
				</p><p>
					The query below shows how this result can be returned, using the <code class="literal">forEntitiesModifiedAtRevision</code> query:
				</p><pre class="programlisting">AuditQuery query = getAuditReader().createQuery()
  .forEntitiesModifiedAtRevision(MyEntity.class, revisionNumber)
  .add(AuditEntity.property("prop1").hasChanged())
  .add(AuditEntity.property("prop2").hasNotChanged());</pre><div class="title"><strong>Query Entities Modified in a Given Revision</strong></div><p>
						The example below shows the basic query for entities modified in a given revision. It allows entity names and corresponding Java classes changed in a specified revision to be retrieved:
					</p><pre class="programlisting">Set&lt;Pair&lt;String, Class&gt;&gt; modifiedEntityTypes = getAuditReader()
    .getCrossTypeRevisionChangesReader().findEntityTypes(revisionNumber);</pre><p>
					There are a number of other queries that are also accessible from org.hibernate.envers.CrossTypeRevisionChangesReader:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">List&lt;Object&gt; findEntities(Number)</code></span></dt><dd>
								Returns snapshots of all audited entities changed (added, updated and removed) in a given revision. Executes <code class="literal">n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity classes modified within the specified revision.
							</dd><dt><span class="term"><code class="literal">List&lt;Object&gt; findEntities(Number, RevisionType)</code></span></dt><dd>
								Returns snapshots of all audited entities changed (added, updated or removed) in a given revision filtered by modification type. Executes <code class="literal">n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity classes modified within specified revision. Map&lt;RevisionType, List&lt;Object&gt;&gt;
							</dd><dt><span class="term"><code class="literal">findEntitiesGroupByRevisionType(Number)</code></span></dt><dd>
								Returns a map containing lists of entity snapshots grouped by modification operation, for example, addition, update or removal. Executes <code class="literal">3n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity classes modified within specified revision.
							</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="hibernate_envers_traversing_entities_using_properties"/>Traversing Entity Associations Using Properties of Referenced Entities</h2></div></div></div><p>
					You can use the properties of a referenced entity to traverse entities in a query. This enables you to query for one-to-one and many-to-one associations.
				</p><p>
					The examples below demonstrate some of the ways you can traverse entities in a query.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							In revision number 1, find cars where the owner is age 20 or lives at address number 30, then order the result set by car make.
						</p><pre class="programlisting">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.INNER, "p" )
                .traverseRelation( "address", JoinType.INNER, "a" )
                .up().up().add( AuditEntity.disjunction().add(AuditEntity.property( "p", "age" )
                       .eq( 20 ) ).add( AuditEntity.property( "a", "number" ).eq( 30 ) ) )
                .addOrder( AuditEntity.property( "make" ).asc() ).getResultList();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find the car where the owner age is equal to the owner address number.
						</p><pre class="programlisting">Car result = (Car) auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.INNER, "p" )
                .traverseRelation( "address", JoinType.INNER, "a" )
                .up().up().add(AuditEntity.property( "p", "age" )
                        .eqProperty( "a", "number" ) ).getSingleResult();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find all cars where the owner is age 20 or where there is no owner.
						</p><pre class="programlisting">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.LEFT, "p" )
                .up().add( AuditEntity.or( AuditEntity.property( "p", "age").eq( 20 ),
                        AuditEntity.relatedId( "owner" ).eq( null ) ) )
                .addOrder( AuditEntity.property( "make" ).asc() ).getResultList();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find all cars where the make equals "car3", and where the owner is age 30 or there is no no owner.
						</p><pre class="programlisting">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.LEFT, "p" )
                .up().add( AuditEntity.and( AuditEntity.property( "make" ).eq( "car3" ), AuditEntity.property( "p", "age" ).eq( 30 ) ) )
                .getResultList();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find all cars where the make equals "car3" or where or the owner is age 10 or where there is no owner.
						</p><pre class="programlisting">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.LEFT, "p" )
                .up().add( AuditEntity.or( AuditEntity.property( "make" ).eq( "car3" ), AuditEntity.property( "p", "age" ).eq( 10 ) ) )
                .getResultList();</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="performance_tuning"/>Performance Tuning</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="alternative_batch_loading_algorithms"/>Alternative Batch Loading Algorithms</h2></div></div></div><p>
					Hibernate allows you to load data for associations using one of four fetching strategies: join, select, subselect and batch. Out of these four strategies, batch loading allows for the biggest performance gains as it is an optimization strategy for select fetching. In this strategy, Hibernate retrieves a batch of entity instances or collections in a single SELECT statement by specifying a list of primary or foreign keys. Batch fetching is an optimization of the lazy select fetching strategy.
				</p><p>
					There are two ways to configure batch fetching: per-class level or per-collection level.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							Per-class Level
						</p><p class="simpara">
							When Hibernate loads data on a per-class level, it requires the batch size of the association to pre-load when queried. For example, consider that at runtime you have 30 instances of a <code class="literal">car</code> object loaded in session. Each <code class="literal">car</code> object belongs to an <code class="literal">owner</code> object. If you were to iterate through all the <code class="literal">car</code> objects and request their owners, with <code class="literal">lazy</code> loading, Hibernate will issue 30 select statements - one for each owner. This is a performance bottleneck.
						</p><p class="simpara">
							You can instead, tell Hibernate to pre-load the data for the next batch of owners before they have been sought via a query. When an <code class="literal">owner</code> object has been queried, Hibernate will query many more of these objects in the same SELECT statement.
						</p><p class="simpara">
							The number of <code class="literal">owner</code> objects to query in advance depends upon the <code class="literal">batch-size</code> parameter specified at configuration time:
						</p><pre class="programlisting">&lt;class name="owner" batch-size="10"&gt;&lt;/class&gt;</pre><p class="simpara">
							This tells Hibernate to query at least 10 more <code class="literal">owner</code> objects in expectation of them being needed in the near future. When a user queries the <code class="literal">owner</code> of <code class="literal">car A</code>, the <code class="literal">owner</code> of <code class="literal">car B</code> may already have been loaded as part of batch loading. When the user actually needs the <code class="literal">owner</code> of <code class="literal">car B</code>, instead of going to the database (and issuing a SELECT statement), the value can be retrieved from the current session.
						</p><p class="simpara">
							In addition to the <code class="literal">batch-size</code> parameter, Hibernate 4.2.0 has introduced a new configuration item to improve in batch loading performance. The configuration item is called <code class="literal">Batch Fetch Style</code> configuration and specified by the <code class="literal">hibernate.batch_fetch_style</code> parameter.
						</p><p class="simpara">
							Three different batch fetch styles are supported: LEGACY, PADDED and DYNAMIC. To specify which style to use, use <code class="literal">org.hibernate.cfg.AvailableSettings#BATCH_FETCH_STYLE</code>.
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
									LEGACY: In the legacy style of loading, a set of pre-built batch sizes based on <code class="literal">ArrayHelper.getBatchSizes(int)</code> are utilized. Batches are loaded using the next-smaller pre-built batch size from the number of existing batchable identifiers.
								</p><p class="simpara">
									Continuing with the above example, with a <code class="literal">batch-size</code> setting of 30, the pre-built batch sizes would be [30, 15, 10, 9, 8, 7, .., 1]. An attempt to batch load 29 identifiers would result in batches of 15, 10, and 4. There will be 3 corresponding SQL queries, each loading 15, 10 and 4 owners from the database.
								</p></li><li class="listitem"><p class="simpara">
									PADDED - Padded is similar to LEGACY style of batch loading. It still utilizes pre-built batch sizes, but uses the next-bigger batch size and pads the extra identifier placeholders.
								</p><p class="simpara">
									As with the example above, if 30 owner objects are to be initialized, there will only be one query executed against the database.
								</p><p class="simpara">
									However, if 29 owner objects are to be initialized, Hibernate will still execute only one SQL select statement of batch size 30, with the extra space padded with a repeated identifier.
								</p></li><li class="listitem"><p class="simpara">
									Dynamic - While still conforming to batch-size restrictions, this style of batch loading dynamically builds its SQL SELECT statement using the actual number of objects to be loaded.
								</p><p class="simpara">
									For example, for 30 owner objects, and a maximum batch size of 30, a call to retrieve 30 owner objects will result in one SQL SELECT statement. A call to retrieve 35 will result in two SQL statements, of batch sizes 30 and 5 respectively. Hibernate will dynamically alter the second SQL statement to keep at 5, the required number, while still remaining under the restriction of 30 as the batch-size. This is different to the PADDED version, as the second SQL will not get PADDED, and unlike the LEGACY style, there is no fixed size for the second SQL statement - the second SQL is created dynamically.
								</p><p class="simpara">
									For a query of less than 30 identifiers, this style will dynamically only load the number of identifiers requested.
								</p></li></ul></div></li><li class="listitem"><p class="simpara">
							Per-collection Level
						</p><p class="simpara">
							Hibernate can also batch load collections honoring the batch fetch size and styles as listed in the per-class section above.
						</p><p class="simpara">
							To reverse the example used in the previous section, consider that you need to load all the <code class="literal">car</code> objects owned by each <code class="literal">owner</code> object. If 10 <code class="literal">owner</code> objects are loaded in the current session iterating through all owners will generate 10 SELECT statements, one for every call to <code class="literal">getCars()</code> method. If you enable batch fetching for the cars collection in the mapping of Owner, Hibernate can pre-fetch these collections, as shown below.
						</p><pre class="programlisting">&lt;class name="Owner"&gt;&lt;set name="cars" batch-size="5"&gt;&lt;/set&gt;&lt;/class&gt;</pre><p class="simpara">
							Thus, with a batch size of five and using legacy batch style to load 10 collections, Hibernate will execute two SELECT statements, each retrieving five collections.
						</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="second_level_caching_of_object_references_for_non-mutable_data"/>Second Level Caching of Object References for Non-mutable Data</h2></div></div></div><p>
					Hibernate automatically caches data within memory for improved performance. This is accomplished by an in-memory cache which reduces the number of times that database lookups are required, especially for data that rarely changes.
				</p><p>
					Hibernate maintains two types of caches. The primary cache, also called the first-level cache, is mandatory. This cache is associated with the current session and all requests must pass through it. The secondary cache, also called the second-level cache, is optional, and is only consulted after the primary cache has been consulted.
				</p><p>
					Data is stored in the second-level cache by first disassembling it into a state array. This array is deep copied, and that deep copy is put into the cache. The reverse is done for reading from the cache. This works well for data that changes (mutable data), but is inefficient for immutable data.
				</p><p>
					Deep copying data is an expensive operation in terms of memory usage and processing speed. For large data sets, memory and processing speed become a performance-limiting factor. Hibernate allows you to specify that immutable data be referenced rather than copied. Instead of copying entire data sets, Hibernate can now store the reference to the data in the cache.
				</p><p>
					This can be done by changing the value of the configuration setting <code class="literal">hibernate.cache.use_reference_entries</code> to <code class="literal">true</code>. By default, <code class="literal">hibernate.cache.use_reference_entries</code> is set to <code class="literal">false</code>.
				</p><p>
					When <code class="literal">hibernate.cache.use_reference_entries</code> is set to <code class="literal">true</code>, an immutable data object that does not have any associations is not copied into the second-level cache, and only a reference to it is stored.
				</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						When <code class="literal">hibernate.cache.use_reference_entries</code> is set to <code class="literal">true</code>, immutable data objects with associations are still deep copied into the second-level cache.
					</p></div></div></div></div></body></html>