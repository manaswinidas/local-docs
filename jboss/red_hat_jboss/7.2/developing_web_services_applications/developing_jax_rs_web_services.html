<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 2. Developing JAX-RS Web Services</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="developing_jax_rs_web_services"/>Chapter 2. Developing JAX-RS Web Services</h1></div></div></div><p>
			JAX-RS is the Java API for RESTful web services. It provides support for building web services using REST, through the use of annotations. These annotations simplify the process of mapping Java objects to web resources.
		</p><p>
			RESTEasy is the Red Hat JBoss Enterprise Application Platform 7 implementation of JAX-RS and is fully compliant with the <a class="link" href="http://www.jcp.org/en/jsr/detail?id=311">JSR-000339 Java API for RESTful Web Services 2.0</a> specification. It also provides additional features to the specification.
		</p><p>
			To get started with JAX-RS, see the <code class="literal">helloworld-rs</code>, <code class="literal">jaxrs-client</code>, and <code class="literal">kitchensink</code> quickstarts that ship with Red Hat JBoss Enterprise Application Platform 7.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
				JBoss EAP does not support the <code class="literal">resteasy-crypto</code>, <code class="literal">resteasy-yaml-provider</code>, and <code class="literal">jose-jwt</code> modules.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="JAX-RS_application"/>JAX-RS Application</h1></div></div></div><p>
				When creating providers and web resources, you have the following options for declaring them:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Simple subclassing of <code class="literal">javax.ws.rs.core.Application</code> without a <code class="literal">web.xml</code> file.
					</li><li class="listitem">
						Using a <code class="literal">web.xml</code> file.
					</li><li class="listitem">
						Subclassing <code class="literal">javax.ws.rs.core.Application</code> and providing a custom implementation.
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="simple_subclassing_literal_javax_ws_rs_core_application_literal"/>Simple Subclassing <code class="literal">javax.ws.rs.core.Application</code></h2></div></div></div><p>
					You can use the <a class="link" href="https://access.redhat.com/webassets/avalon/d/red_hat_jboss_enterprise_application_platform/7.2/javadocs/javax/ws/rs/core/Application.html"><code class="literal">javax.ws.rs.core.Application</code></a> class to create a subclass that declares those providers and web resources. This class is provided by the RESTEasy libraries included with JBoss EAP.
				</p><p>
					To configure a resource or provider using <code class="literal">javax.ws.rs.core.Application</code>, simply create a class that extends it and add an <code class="literal">@ApplicationPath</code> annotation.
				</p><div class="title"><strong>Example: Application Class</strong></div><p>
						
</p><pre class="programlisting">import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/root-path")
public class MyApplication extends Application
{
}</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using_literal_web_xml_literal"/>Using <code class="literal">web.xml</code></h2></div></div></div><p>
					Alternatively, if you do not want to create a class that extends <code class="literal">javax.ws.rs.core.Application</code>, you can add the following to your <code class="literal">web.xml</code> file.
				</p><div class="title"><strong>Example: web.xml</strong></div><p>
						
</p><pre class="programlisting">&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
  &lt;servlet&gt;
      &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;javax.ws.rs.core.Application&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/root-path/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  ...
&lt;/web-app&gt;</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="subclassing_literal_javax_ws_rs_core_application_literal_with_a_custom_implementation"/>Subclassing <code class="literal">javax.ws.rs.core.Application</code> with a Custom Implementation</h2></div></div></div><p>
					When subclassing <a class="link" href="https://access.redhat.com/webassets/avalon/d/red_hat_jboss_enterprise_application_platform/7.2/javadocs/javax/ws/rs/core/Application.html"><code class="literal">javax.ws.rs.core.Application</code></a> you can choose to provide a custom implementation for any of the existing methods. The <code class="literal">getClasses</code> and <code class="literal">getSingletons</code> methods return a collection of classes or singletons that must be included in the published JAX-RS application.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							If either <code class="literal">getClasses</code> and <code class="literal">getSingletons</code> returns a non-empty collection, <span class="emphasis"><em>only</em></span> those classes and singletons are published in the JAX-RS application.
						</li><li class="listitem">
							If <span class="emphasis"><em>both</em></span> <code class="literal">getClasses</code> and <code class="literal">getSingletons</code> return an empty collection, then <span class="emphasis"><em>all</em></span> root resource classes and providers that are packaged in the web application are included in the JAX-RS application. RESTEasy will then automatically discover those resources.
						</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jax_rs_client"/>JAX-RS Client</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="JAX-RS_client_api"/>JAX-RS Client API</h2></div></div></div><p>
					JAX-RS 2.0 introduced a new client API to send HTTP requests to remote RESTful web services. It is a <span class="emphasis"><em>fluent</em></span> request-building API with 3 main classes:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">Client</code>
						</li><li class="listitem">
							<code class="literal">WebTarget</code>
						</li><li class="listitem">
							<code class="literal">Response</code>
						</li></ul></div><p>
					The <code class="literal">Client</code> interface is a builder of WebTarget instances. The <code class="literal">WebTarget</code> represents a distinct URL or URL template to build subresource WebTargets or invoke requests on.
				</p><p>
					There are two ways to create a client: the standard way, or using the <code class="literal">ResteasyClientBuilder</code> class. The advantage of using the <code class="literal">ResteasyClientBuilder</code> class is that it provides a few more helper methods to configure your client.
				</p><h4><a id="using_the_standard_way_to_create_a_client"/>Using the Standard Way to Create a Client</h4><p>
					The following example shows one of the standard ways to create a client:
				</p><pre class="programlisting">Client client = ClientBuilder.newClient();</pre><p>
					Alternatively, you can use another standard way to create a client as shown in the example below:
				</p><pre class="programlisting">Client client = ClientBuilder.newBuilder().build();
WebTarget target = client.target("http://foo.com/resource");
Response response = target.request().get();
String value = response.readEntity(String.class);
response.close();  // You should close connections!</pre><h4><a id="using_the_resteasyclientbuilder_class_to_create_a_client"/>Using the ResteasyClientBuilder Class to Create a Client</h4><pre class="programlisting">ResteasyClient client = new ResteasyClientBuilder().build();
ResteasyWebTarget target = client.target("http://foo.com/resource");</pre><p>
					RESTEasy automatically loads a set of default providers that includes all classes listed in the <code class="literal">META-INF/services/javax.ws.rs.ext.Providers</code> file. Additionally, you can manually register other providers, filters, and interceptors through the configuration object provided by the method call <code class="literal">Client.configuration()</code>. Configuration also lets you set configuration properties that might be needed.
				</p><p>
					Each <code class="literal">WebTarget</code> has a configuration instance that inherits the components and properties registered with the parent instance. This lets you set specific configuration options for each target resource, for example, the username and password.
				</p><h4><a id="using_resteasy_client_classes"/>Using RESTEasy Client Classes</h4><p>
					You must add the following dependency for RESTEasy client to your Maven <code class="literal">pom.xml</code> file:
				</p><pre class="programlisting">&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
	&lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
	&lt;version&gt;<span class="emphasis"><em>VERSION_IN_EAP</em></span>&lt;/version&gt;
 &lt;/dependency&gt;</pre><p>
					See the <code class="literal">jaxrs-client</code> and <code class="literal">resteasy-jaxrs-client</code> quickstarts that ship with JBoss EAP for working examples that use the RESTEasy client classes.
				</p><h4><a id="client_side_filters"/>Client-side Filters</h4><p>
					The client side has two types of filters:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ClientRequestFilter</code></span></dt><dd>
								A <code class="literal">ClientRequestFilter</code> runs before an HTTP request is sent over the wire to the server. The <code class="literal">ClientRequestFilter</code> is also allowed to abort the request execution and provide a canned response without going over the wire to the server.
							</dd><dt><span class="term"><code class="literal">ClientResponseFilter</code></span></dt><dd>
								A <code class="literal">ClientResponseFilter</code> runs after a response is received from the server, but before the response body is unmarshalled. The <code class="literal">ClientResponseFilter</code> can modify the response object before it is handed to the application code. The following example illustrates these concepts:
							</dd></dl></div><pre class="programlisting">// execute request filters
for (ClientRequestFilter filter : requestFilters) {
	filter.filter(requestContext);
	if (isAborted(requestContext)) {
    return requestContext.getAbortedResponseObject();
  }
}

// send request over the wire
response = sendRequest(request);

// execute response filters
for (ClientResponseFilter filter : responseFilters) {
	filter.filter(requestContext, responseContext);
}</pre><h4><a id="register_client_side_filters_to_the_client_request"/>Register Client-side Filters to the Client Request</h4><p>
					The following example shows how to register the client-side filters to the client request:
				</p><pre class="programlisting">client = ClientBuilder.newClient();
WebTarget base = client.target(generateURL("/") + "get");
base.register(ClientExceptionsCustomClientResponseFilter.class).request("text/plain").get();</pre><h4><a id="client_side_cache"/>Client-side Cache</h4><p>
					RESTEasy has the ability to set up a client-side cache. This cache looks for cache-control headers sent back with a server response. If the cache-control headers specify that the client is allowed to cache the response, RESTEasy caches it within the local memory.
				</p><pre class="programlisting">ResteasyWebTarget target = client.target(generateBaseUrl());
target.register(BrowserCacheFeature.class);</pre><h4><a id="chunked_encoding_support"/>Chunked Encoding Support</h4><p>
					RESTEasy provides the client API the ability to specify that requests should be sent in a <span class="emphasis"><em>chunked</em></span> transfer mode. There are two ways of specifying the <span class="emphasis"><em>chunked</em></span> transfer mode, as shown below.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							You can configure the <code class="literal">org.jboss.resteasy.client.jaxrs.ResteasyWebTarget</code> to send all the requests in chunked mode:
						</p><pre class="programlisting">ResteasyClient client = new ResteasyClientBuilder().build();
ResteasyWebTarget target = client.target("http://localhost:8081/test");
target.setChunked(b.booleanValue());
Invocation.Builder request = target.request();</pre></li><li class="listitem"><p class="simpara">
							Alternatively, you can configure a particular request to be sent in chunked mode:
						</p><pre class="programlisting">ResteasyClient client = new ResteasyClientBuilder().build();
ResteasyWebTarget target = client.target("http://localhost:8081/test");
ClientInvocationBuilder request = (ClientInvocationBuilder) target.request();
request.setChunked(b);</pre><p class="simpara">
							Unlike the <code class="literal">javax.ws.rs.client.Invocation.Builder</code> class, <code class="literal">org.jboss.resteasy.client.jaxrs.internal.ClientInvocationBuilder</code> is a RESTEasy class.
						</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The ability to send the requests in chunked mode depends on the underlying transport layer. In particular, it depends on the implementation of the <code class="literal">org.jboss.resteasy.client.jaxrs.ClientHttpEngine</code> class being used. Currently, only the default implementation <code class="literal">ApacheHttpClient43Engine</code> and the previous implementation <code class="literal">ApacheHttpClient4Engine</code> support the chunked mode. Both these are available in the <code class="literal">org.jboss.resteasy.client.jaxrs.engines</code> package. See section <a class="link" href="developing_jax_rs_web_services.html#how_to_use_resteasy_with_closeable_apache_http_client" title="Implementing RESTEasy with HTTP Client">Implementing RESTEasy with HTTP Client</a> for more information.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="how_to_use_resteasy_with_closeable_apache_http_client"/>Implementing RESTEasy with HTTP Client</h2></div></div></div><p>
					Network communication between the client and server is handled by default in RESTEasy. It uses the <code class="literal">HttpClient</code> from the Apache <code class="literal">HttpComponents</code> project. The interface between the RESTEasy client framework and the network is defined by the <code class="literal">ClientHttpEngine</code> interface.
				</p><p>
					RESTEasy ships with four implementations of this interface. The default implementation is <code class="literal">ApacheHttpClient43Engine</code>. This implementation uses Apache 4.3.
				</p><p>
					<code class="literal">ApacheHttpClient4Engine</code> is an implementation that uses the versions earlier than Apache 4.3. This class provides backward compatibility. RESTEasy automatically selects one of these two <code class="literal">ClientHttpEngine</code> implementations based on the detection of the Apache version. <code class="literal">InMemoryClientEngine</code> is an implementation that dispatches requests to a server in the same JVM, and <code class="literal">URLConnectionEngine</code> is an implementation that uses <code class="literal">java.net.HttpURLConnection</code>.
				</p><p>
					A client executor can be passed to a specific <code class="literal">ClientRequest</code>:
				</p><pre class="programlisting">ResteasyClient client = new
ResteasyClientBuilder().httpEngine(engine).build();</pre><p>
					RESTEasy and <code class="literal">HttpClient</code> make the default decisions to use the client framework without referencing <code class="literal">HttpClient</code>. However, for some applications it might be necessary to drill down into the <code class="literal">HttpClient</code> details. <code class="literal">ApacheHttpClient43Engine</code> and <code class="literal">ApacheHttpClient4Engine</code> can be supplied with an instance of <code class="literal">org.apache.http.client.HttpClient</code> and <code class="literal">org.apache.http.protocol.HttpContext</code>, which can carry additional configuration details into the <code class="literal">HttpClient</code> layer. For example, authentication can be configured as follows:
				</p><pre class="programlisting">// Configure HttpClient to authenticate preemptively
// by prepopulating the authentication data cache.

// 1. Create AuthCache instance
AuthCache authCache = new BasicAuthCache();

// 2. Generate BASIC scheme object and add it to the local auth cache
AuthScheme basicAuth = new BasicScheme();
authCache.put(new HttpHost("sippycups.bluemonkeydiamond.com"), basicAuth);

// 3. Add AuthCache to the execution context
BasicHttpContext localContext = new BasicHttpContext();
localContext.setAttribute(ClientContext.AUTH_CACHE, authCache);

// 4. Create client executor and proxy
HttpClient httpClient = HttpClientBuilder.create().build();
ApacheHttpClient4Engine engine = new ApacheHttpClient4Engine(httpClient, localContext);
ResteasyClient client = new ResteasyClientBuilder().httpEngine(engine).build();</pre><p>
					<code class="literal">HttpContextProvider</code> is an interface provided by RESTEasy, using which you can supply a custom <code class="literal">HttpContext</code> to the <code class="literal">ApacheHttpClient43Engine</code> and <code class="literal">ApacheHttpClient4Engine</code> implementations.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						It is important to understand the difference between <span class="emphasis"><em>releasing</em></span> a connection and <span class="emphasis"><em>closing</em></span> a connection. Releasing a connection makes it available for reuse. Closing a connection frees its resources and makes it unusable.
					</p></div><p>
					RESTEasy releases the connection without notification. The only counter example is the case in which the response is an instance of <code class="literal">InputStream</code>, which must be closed explicitly.
				</p><p>
					On the other hand, if the result of an invocation is an instance of <code class="literal">Response</code>, the <code class="literal">Response.close()</code> method must be used to release the connection.
				</p><pre class="programlisting">WebTarget target = client.target("http://localhost:8081/customer/123");
Response response = target.request().get();
System.out.println(response.getStatus());
response.close();</pre><p>
					You may execute this in a <code class="literal">try-finally</code> block. Releasing a connection makes it available for another use. It does not normally close the socket.
				</p><p>
					<code class="literal">ApacheHttpClient4Engine.finalize()</code> closes any open sockets, if it created the <code class="literal">HttpClient</code> that it has been using. It is not safe to rely on JDK to call <code class="literal">finalize()</code>. If an <code class="literal">HttpClient</code> is passed to the <code class="literal">ApacheHttpClient4Executor</code>, the user must close the connections, as shown below:
				</p><pre class="programlisting">HttpClient httpClient = new HttpClientBuilder.create().build();
ApacheHttpClient4Engine executor = new ApacheHttpClient4Engine(httpClient);
...
httpClient.getConnectionManager().shutdown();</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						If <code class="literal">ApacheHttpClient4Engine</code> has created its own instance of <code class="literal">HttpClient</code>, it is not necessary to wait for <code class="literal">finalize()</code> to close open sockets. The <code class="literal">ClientHttpEngine</code> interface has a <code class="literal">close()</code> method for this purpose.
					</p></div><p>
					Finally, if the <code class="literal">javax.ws.rs.client.Client</code> class has created the engine automatically, call <code class="literal">Client.close()</code>. This call cleans up any socket connections.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="http_redirect"/>HTTP Redirect</h3></div></div></div><p>
						The <code class="literal">ClientHttpEngine</code> implementations based on the Apache HttpClient support HTTP redirection. This feaure is disabled by default. You can enable this by setting the <code class="literal">setFollowRedirects</code> method to <code class="literal">true</code>, as shown below:
					</p><pre class="programlisting">ApacheHttpClient43Engine engine = new ApacheHttpClient43Engine();
engine.setFollowRedirects(true);
Client client = new ResteasyClientBuilder().httpEngine(engine).build();</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jax_rs_request_processing"/>JAX-RS Request Processing</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxrs_async_processing"/>Asynchronous HTTP Request Processing</h2></div></div></div><p>
					Asynchronous request processing allows you to process a single HTTP request using non-blocking input and output and, if required, in separate threads.
				</p><p>
					Consider an AJAX chat client in which you want to push and pull from both the client and the server. This scenario has the client blocking for a long time on the server’s socket, waiting for a new message. In case of synchronous HTTP processing, where the server is blocking on incoming and outgoing input and output, you have one separate thread consumed per client connection. This model of request processing consumes a lot of memory and valuable thread resources.
				</p><p>
					Asynchronous processing separates the connection accepting and the request processing operations. It allocates two different threads: one to accept the client connection; the other to handle heavy, time-consuming operations. In this model, the container works as follows:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							It dispatches a thread to accept a client connection, which is the acceptor.
						</li><li class="listitem">
							Then it hands over the request to the processing thread, which is the worker.
						</li><li class="listitem">
							Finally, it releases the acceptor thread.
						</li></ol></div><p>
					The result is sent back to the client by the worker thread. Hence, the client’s connection remains open, thereby improving the server’s throughput and scalability.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy_async_nio_request_processing"/>Asynchronous NIO Request Processing</h3></div></div></div><p>
						RESTEasy’s default asynchronous engine implementation class is <code class="literal">ApacheHttpAsyncClient4Engine</code>. It is built on <code class="literal">HttpAsyncClient</code> from the Apache <code class="literal">HttpComponents</code>, which internally dispatches requests using a non-blocking IO model.
					</p><p>
						You can set the asynchronous engine as the active engine by calling the <code class="literal">useAsyncHttpEngine</code> method in the <code class="literal">ResteasyClientBuilder</code> class:
					</p><pre class="programlisting">Client asyncClient = new ResteasyClientBuilder().useAsyncHttpEngine()
                     .build();
Future&lt;Response&gt; future = asyncClient
                          .target("http://locahost:8080/test").request()
                          .async().get();
Response res = future.get();
Assert.assertEquals(HttpResponseCodes.SC_OK, res.getStatus());
String entity = res.readEntity(String.class);</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="server-async-response-processing"/>Server Asynchronous Response Processing</h3></div></div></div><p>
						On the server side, asynchronous processing involves suspending the original request thread and initiating the request processing on a different thread, which releases the original server-side thread to accept other incoming requests.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="asyncresponse_api"/>AsyncResponse API</h4></div></div></div><p>
							The JAX-RS 2.0 specification added asynchronous HTTP support using two classes: the <code class="literal">@Suspended</code> annotation and the <code class="literal">AsyncResponse</code> interface.
						</p><p>
							Injecting an <code class="literal">AsyncResponse</code> as a parameter to your JAX-RS method prompts RESTEasy to detach the HTTP request and response from the thread being executed currently. This ensures that the current thread does not try to automatically process the response.
						</p><p>
							The <code class="literal">AsyncResponse</code> is the callback object. The act of calling one of the <code class="literal">resume()</code> methods causes a response to be sent back to the client and also terminates the HTTP request. The following is an example of asynchronous processing:
						</p><pre class="programlisting">import javax.ws.rs.container.Suspended;
import javax.ws.rs.container.AsyncResponse;

@Path("/")
public class SimpleResource {
   @GET
   @Path("basic")
   @Produces("text/plain")
   public void getBasic(@Suspended final AsyncResponse response) throws Exception {
      Thread t = new Thread() {
         @Override
         public void run() {
            try {
               Response jaxrs = Response.ok("basic").type(MediaType.TEXT_PLAIN).build();
               response.resume(jaxrs);
            }
            catch (Exception e) {
               e.printStackTrace();
            }
         }
      };
      t.start();
   }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="async_invoker_client_api"/>AsyncInvoker Client API</h3></div></div></div><p>
						Similarly, on the client side, asynchronous processing prevents blocking the request thread since no time is spent waiting for a response from the server. For instance, a thread that issued a request may also update a user interface component. If that thread is blocked waiting for a response, the user’s perceived performance of the application will suffer.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="using_future"/>Using Future</h4></div></div></div><p>
							In the code snippet below, the <code class="literal">get()</code> method is called on the <code class="literal">async()</code> method rather than the request. This changes the call mechanism from synchronous to asynchronous. Instead of responding synchronously, the <code class="literal">async()</code> method returns a <code class="literal">future</code> object. When you call the <code class="literal">get()</code> method, the call is blocked until the response is ready. The <code class="literal">future.get()</code> method will be returned whenever the response is ready.
						</p><pre class="programlisting">import java.util.concurrent.Future;
import javax.ws.rs.client.Client;
...

@Test
public void AsyncGetTest() throws Exception {
    Client client = ClientBuilder.newClient();
    Future&lt;String&gt; future = client.target(generateURL("/test")).request().async().get(String.class);
    String entity = future.get();
    Assert.assertEquals("get", entity);
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="using_invocationcallback"/>Using InvocationCallback</h4></div></div></div><p>
							The <code class="literal">AsyncInvoker</code> interface allows you to register an object that will be called back when the asynchronous invocation is ready for processing. The <code class="literal">InvocationCallback</code> interface provides two methods: <code class="literal">completed()</code> and <code class="literal">failed()</code>. The <code class="literal">completed()</code> method is called whenever the processing is finished successfully and the response is received. Conversely, the <code class="literal">failed()</code> method is called whenever the request processing is not successful.
						</p><pre class="programlisting">import javax.ws.rs.client.InvocationCallback;
...

@Test
public void AsyncCallbackGetTest() throws Exception {
    Client client = ClientBuilder.newClient();
	final CountDownLatch latch = new CountDownLatch(1);
        Future&lt;Response&gt; future = client.target(generateURL("/test")).request().async().get(new InvocationCallback&lt;Response&gt;() {
         	@Override
                public void completed(Response response) {
                    String entity = response.readEntity(String.class);
                    Assert.assertEquals("get", entity);
                    latch.countDown();
                }

                @Override
                public void failed(Throwable error) {
                }
            });
            Response res = future.get();
            Assert.assertEquals(HttpResponseCodes.SC_OK, res.getStatus());
            Assert.assertTrue("Asynchronous invocation didn't use custom implemented Invocation callback", latch.await(5, imeUnit.SECONDS));
}</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="custom_resteasy_annotations"/>Custom RESTEasy Annotations</h2></div></div></div><p>
					With the addition of parameter names in the bytecode, you are no longer required to specify the parameter names in the following annotations: <code class="literal">@PathParam</code>, <code class="literal">@QueryParam</code>, <code class="literal">@FormParam</code>, <code class="literal">@CookieParam</code>, <code class="literal">@HeaderParam</code> and <code class="literal">@MatrixParam</code>. To do so, you must switch to the new annotations with the same name, in a different package, which have an optional value parameter. You can achieve this by following the steps below:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							Import the <code class="literal">org.jboss.resteasy.annotations.jaxrs</code> package to replace annotations from the JAX-RS specifications.
						</li><li class="listitem"><p class="simpara">
							Configure your build system to record the method parameter names in the bytecode.
						</p><p class="simpara">
							Maven users can enable recording method parameter names in the bytecode by setting the <code class="literal">maven.compiler.parameters</code> to <code class="literal">true</code>:
						</p><pre class="programlisting">&lt;properties&gt;
    &lt;maven.compiler.parameters&gt;true&lt;/maven.compiler.parameters&gt;
&lt;/properties&gt;</pre></li><li class="listitem"><p class="simpara">
							Remove the annotation value if the name matches the name of the annotated variable.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								You can omit the annotation name for annotated method parameters as well as annotated fields or the JavaBean properties.
							</p></div></li></ol></div><p>
					Consider the following usage for an example:
				</p><pre class="programlisting">import org.jboss.resteasy.annotations.jaxrs.*;

@Path("/library")
public class Library {

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam String isbn) {
      // search my database and get a string representation and return it
   }
}</pre><p>
					If your annotated variable does not have the same name as the path parameter, you can specify the name as shown below:
				</p><pre class="programlisting">import org.jboss.resteasy.annotations.jaxrs.*;

@Path("/library")
public class Library {

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") String id) {
      // search my database and get a string representation and return it
   }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="viewing_resteasy_endpoints"/>Viewing RESTEasy Endpoints</h1></div></div></div><p>
				You can use the <code class="literal">read-resource</code> operation of the <code class="literal">jaxrs</code> subsystem to view structured output of each RESTEasy endpoint. An example of the management CLI command and the expected outcome is provided below.
			</p><pre class="screen">/deployment=<span class="emphasis"><em>DEPLOYMENT_NAME</em></span>/subsystem=jaxrs/rest-resource=org.jboss.as.quickstarts.rshelloworld.HelloWorld:read-resource(include-runtime=true)
{
    "outcome" =&gt; "success",
    "result" =&gt; {
        "resource-class" =&gt; "org.jboss.as.quickstarts.rshelloworld.HelloWorld",
        "rest-resource-paths" =&gt; [
            {
                "resource-path" =&gt; "/hello/json",
                "consumes" =&gt; undefined,
                "produces" =&gt; [
                    "application/json",
                    "text/plain"
                ],
                "java-method" =&gt; "java.lang.String org.jboss.as.quickstarts.rshelloworld.HelloWorld.getHelloWorldJSON()",
                "resource-methods" =&gt; [
                    "POST /wildfly-helloworld-rs/rest/hello/json",
                    "GET /wildfly-helloworld-rs/rest/hello/json"
                ]
            },
            {
                "resource-path" =&gt; "/hello/xml",
                "consumes" =&gt; undefined,
                "produces" =&gt; ["application/xml"],
                "java-method" =&gt; "java.lang.String org.jboss.as.quickstarts.rshelloworld.HelloWorld.getHelloWorldXML(@QueryParam java.lang.String name = 'LGAO')",
                "resource-methods" =&gt; ["GET /wildfly-helloworld-rs/rest/hello/xml"]
            }
        ],
        "sub-resource-locators" =&gt; [{
            "resource-class" =&gt; "org.jboss.as.quickstarts.rshelloworld.SubHelloWorld",
            "rest-resource-paths" =&gt; [
                {
                    "resource-path" =&gt; "/hello/subMessage/",
                    "consumes" =&gt; undefined,
                    "produces" =&gt; undefined,
                    "java-method" =&gt; "java.lang.String org.jboss.as.quickstarts.rshelloworld.SubHelloWorld.helloInSub()",
                    "resource-methods" =&gt; ["GET /wildfly-helloworld-rs/rest/hello/subMessage/"]
                },
                {
                    "resource-path" =&gt; "/hello/subMessage/subPath",
                    "consumes" =&gt; undefined,
                    "produces" =&gt; undefined,
                    "java-method" =&gt; "java.lang.String org.jboss.as.quickstarts.rshelloworld.SubHelloWorld.subPath()",
                    "resource-methods" =&gt; ["GET /wildfly-helloworld-rs/rest/hello/subMessage/subPath"]
                }
            ],
            "sub-resource-locators" =&gt; undefined
        }]
    }
}</pre><p>
				In the example above, the output information is grouped by the <code class="literal">resource-class</code> and ordered as per the <code class="literal">resource-path</code>:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<code class="literal">resource-path</code> is the address to access the endpoint.
					</li><li class="listitem">
						<code class="literal">resource-class</code> defines the class, where the endpoint is defined.
					</li><li class="listitem">
						<code class="literal">rest-resource-paths</code> includes the Java methods that define the resource path, HTTP method, consumes and produces of the endpoint.
					</li><li class="listitem">
						<code class="literal">java-method</code> specifies the name of the Java method and its parameters. It also contains information about the following JAX-RS annotations, if defined: <code class="literal">@PathParam</code>, <code class="literal">@QueryParam</code>, <code class="literal">@HeaderParam</code>, <code class="literal">@MatrixParam</code>, <code class="literal">@CookieParam</code>, <code class="literal">@FormParam</code> and <code class="literal">@DefaultValue</code>.
					</li></ul></div><p>
				Alternatively, you can use the <code class="literal">read-resource</code> operation without the <code class="literal">rest-resource</code> parameter defined and get the information about all the endpoints, as shown in the example below:
			</p><pre class="screen">/deployment=<span class="emphasis"><em>DEPLOYMENT_NAME</em></span>/subsystem=jaxrs:read-resource(include-runtime=true,recursive=true)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="url_based_negotiation"/>URL-Based Negotiation</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="mapping_extensions_to_media_types"/>Mapping Extensions to Media Types</h2></div></div></div><p>
					Some clients, such as browsers, cannot use the <code class="literal">Accept</code> and <code class="literal">Accept-Language</code> headers to negotiate the representation media type or language. RESTEasy can map file name suffixes to media types and languages to deal with this issue.
				</p><p>
					To map media types to file extensions using the <code class="literal">web.xml</code> file, you need to add a <code class="literal">resteasy.media.type.mappings</code> context param and the list of mappings as the <code class="literal">param-value</code>. The list is comma separated and uses colons (<code class="literal">:</code>) to delimit the file extension and media type.
				</p><div class="title"><strong>Example <code class="literal">web.xml</code> Mapping File Extensions to Media Types</strong></div><p>
						
</p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;resteasy.media.type.mappings&lt;/param-name&gt;
    &lt;param-value&gt;html : text/html, json : application/json, xml : application/xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>

					</p><p>
					In this example, the following URL variants for <code class="literal">http://localhost:8080/my-application/test</code> would be mapped:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">http://localhost:8080/my-application/test.html</code>
						</li><li class="listitem">
							<code class="literal">http://localhost:8080/my-application/test.json</code>
						</li><li class="listitem">
							<code class="literal">http://localhost:8080/my-application/test.xml</code>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="mapping_extensions_to_languages"/>Mapping Extensions to Languages</h2></div></div></div><p>
					Some clients, such as browsers, cannot use the <code class="literal">Accept</code> and <code class="literal">Accept-Language</code> headers to negotiate the representation media type or language. RESTEasy can map file name suffixes to media types and languages to deal with this issue. Follow these steps to map languages to file extensions, in the <code class="literal">web.xml</code> file.
				</p><p>
					To map media types to file extensions using the <code class="literal">web.xml</code> file, you need to add a <code class="literal">resteasy.language.mappings</code> context param and the list of mappings as the <code class="literal">param-value</code>. The list is comma separated and uses colons (<code class="literal">:</code>) to delimit the file extension and language type.
				</p><div class="title"><strong>Example <code class="literal">web.xml</code> Mapping File Extensions to Language Types</strong></div><p>
						
</p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;resteasy.language.mappings&lt;/param-name&gt;
    &lt;param-value&gt; en : en-US, es : es, fr : fr&lt;/param-name&gt;
&lt;/context-param&gt;</pre><p>

					</p><p>
					In this example, the following URL variants for <code class="literal">http://localhost:8080/my-application/test</code> would be mapped:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">http://localhost:8080/my-application/test.en</code>
						</li><li class="listitem">
							<code class="literal">http://localhost:8080/my-application/test.es</code>
						</li><li class="listitem">
							<code class="literal">http://localhost:8080/my-application/test.fr</code>
						</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="content_marshalling_and_providers"/>Content Marshalling and Providers</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="default_providers_and_default_jax_rs_content_marshalling"/>Default Providers and Default JAX-RS Content Marshalling</h2></div></div></div><p>
					RESTEasy can automatically marshal and unmarshal a few different message bodies.
				</p><div class="table"><a id="idm140182264219360"/><p class="title"><strong>Table 2.1. Supported Media Types and Java Types</strong></p><div class="table-contents"><table summary="Supported Media Types and Java Types" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Media Types</th><th style="text-align: left" valign="top">Java Types</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">application/* +xml</code>, <code class="literal">text/* +xml</code>, <code class="literal">application/* +json</code>, <code class="literal">application/* +fastinfoset</code>, <code class="literal">application/ atom+*</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									JAXB annotated classes
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">application/* +xml</code>, <code class="literal">text/* +xml</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									org.w3c.dom.Document
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									* / *
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									java.lang.String
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									* / *
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									java.io.InputStream
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">text/plain</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									primitives, java.lang.String, or any type that has a String constructor, or static valueOf(String) method for input, toString() for output
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									* / *
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									javax.activation.DataSource
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									* / *
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									java.io.File
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									* / *
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									byte
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">application/x-www-form-urlencoded</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									javax.ws.rs.core.MultivaluedMap
								</p>
								 </td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="text_media_types_charsets"/>Text Media Types and Character Sets</h3></div></div></div><p>
						According to the JAX-RS specification, implementations must adhere to application-supplied character set metadata when writing responses. If a character set is not specified by the application or if the application specifies a character set that is not supported, then the implementations must use UTF-8 character set.
					</p><p>
						On the contrary, according to the HTTP specification, when no explicit charset parameter is provided by the sender, media subtypes of the <code class="literal">text</code> type are defined to have a default charset value of <code class="literal">ISO-8859-1</code> when received via HTTP. Data in character sets other than <code class="literal">ISO-8859-1</code> or its subsets must be labeled with an appropriate charset value.
					</p><p>
						In the absence of a character set specified by a resource or resource method, RESTEasy uses UTF-8 as the character set for text media types. In order to do so, RESTEasy adds an explicit charset parameter to the content-type response header.
					</p><p>
						To specify the original behavior, in which UTF-8 is used for text media types but the explicit charset parameter is not appended, set the context parameter <code class="literal">resteasy.add.charset</code> to <code class="literal">false</code>. The default value of this parameter is <code class="literal">true</code>.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							Text media types include:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									Media types with type <code class="literal">text</code> and any subtype.
								</li><li class="listitem">
									Media types with type <code class="literal">application</code> and subtype beginning with <code class="literal">xml</code>. This includes <code class="literal">application/xml-external-parsed-entity</code> and <code class="literal">application/xml-dtd</code>.
								</li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxrs_content_marshalling_provider_classes"/>Content Marshalling with @Provider classes</h2></div></div></div><p>
					The JAX-RS specification allows you to plug in your own request/response body readers and writers. To do this, you annotate a class with <code class="literal">@Provider</code> and specify the <code class="literal">@Produces</code> types for a writer and <code class="literal">@Consumes</code> types for a reader. You must also implement a <code class="literal">MessageBodyReader/Writer</code> interface.
				</p><p>
					The RESTEasy <code class="literal">ServletContextLoader</code> automatically scans the <code class="literal">WEB-INF/lib</code> and classes directories for classes annotated with <code class="literal">@Provider</code>, or you can manually configure them in the <code class="literal">web.xml</code> file.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxrs_provider_utility_class"/>Providers Utility Class</h2></div></div></div><p>
					<code class="literal">javax.ws.rs.ext.Providers</code> is a simple injectable interface that allows you to look up <code class="literal">MessageBodyReaders</code>, <code class="literal">Writers</code>, <code class="literal">ContextResolvers</code>, and <code class="literal">ExceptionMappers</code>. It is very useful for implementing multipart providers and content types that embed other random content types.
				</p><pre class="programlisting">public interface Providers {
  &lt;T&gt; MessageBodyReader&lt;T&gt; getMessageBodyReader(Class&lt;T&gt; type, Type genericType, Annotation annotations[], MediaType mediaType);
  &lt;T&gt; MessageBodyWriter&lt;T&gt; getMessageBodyWriter(Class&lt;T&gt; type, Type genericType, Annotation annotations[], MediaType mediaType);
  &lt;T extends="" throwable=""&gt; ExceptionMapper&lt;T&gt; getExceptionMapper(Class&lt;T&gt; type);
  &lt;T&gt; ContextResolver&lt;T&gt; getContextResolver(Class&lt;T&gt; contextType, MediaType mediaType);
}</pre><p>
					A <code class="literal">Providers</code> instance is injectable into <code class="literal">MessageBodyReader</code> or <code class="literal">Writers</code>:
				</p><pre class="programlisting">@Provider
@Consumes("multipart/fixed")
public class MultipartProvider implements MessageBodyReader {

  private @Context Providers providers;
  ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxrs_configure_doc_marshalling"/>Configuring Document Marshalling</h2></div></div></div><p>
					XML document parsers are subject to a form of attack known as the XXE (XML eXternal Entity) attack, in which expanding an external entity causes an unsafe file to be loaded. For example, the following document could cause the <code class="literal">/etc/passwd</code> file to be loaded.
				</p><pre class="programlisting">&lt;!--?xml version="1.0"?--&gt;
&lt;!DOCTYPE foo
[&lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt;]&gt;
&lt;search&gt;
 &lt;user&gt;bill&lt;/user&gt;
 &lt;file&gt;&amp;xxe;&lt;file&gt;
&lt;/search&gt;</pre><p>
					By default, the RESTEasy built-in unmarshaller for <code class="literal">org.w3c.dom.Document</code> documents does not expand external entities. It replaces them with an empty string. You can configure it to replace external entities with values defined in the DTD. This is done by setting the <code class="literal">resteasy.document.expand.entity.references</code> context parameter to <code class="literal">true</code> in the <code class="literal">web.xml</code> file.
				</p><div class="title"><strong>Example: Setting the <code class="literal">resteasy.document.expand.entity.references</code> Context Parameter</strong></div><p>
						
</p><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;resteasy.document.expand.entity.references&lt;/param-name&gt;
 &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>

					</p><p>
					Another way of dealing with the problem is by prohibiting DTDs, which RESTEasy does by default. This behavior can be changed by setting the <code class="literal">resteasy.document.secure.disableDTDs</code> context parameter to <code class="literal">false</code>.
				</p><div class="title"><strong>Example: Setting the <code class="literal">resteasy.document.secure.disableDTDs</code> Context Parameter</strong></div><p>
						
</p><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;resteasy.document.secure.disableDTDs&lt;/param-name&gt;
 &lt;param-value&gt;false&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>

					</p><p>
					Documents are also subject to <span class="emphasis"><em>Denial of Service Attacks</em></span> when buffers are overrun by large entities or too many attributes. For example, if a DTD defined the following entities, the expansion of <code class="literal">&amp;foo6;</code> would result in 1,000,000 foos.
				</p><pre class="programlisting">&lt;!--ENTITY foo 'foo'--&gt;
&lt;!--ENTITY foo1 '&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;&amp;foo;'--&gt;
&lt;!--ENTITY foo2 '&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;&amp;foo1;'--&gt;
&lt;!--ENTITY foo3 '&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;&amp;foo2;'--&gt;
&lt;!--ENTITY foo4 '&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;&amp;foo3;'--&gt;
&lt;!--ENTITY foo5 '&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;&amp;foo4;'--&gt;
&lt;!--ENTITY foo6 '&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;&amp;foo5;'--&gt;</pre><p>
					By default, RESTEasy limits the number of expansions and the number of attributes per entity. The exact behavior depends on the underlying parser. The limit can be turned off by setting the <code class="literal">resteasy.document.secure.processing.feature</code> context parameter to <code class="literal">false</code>.
				</p><div class="title"><strong>Example: Setting the <code class="literal">resteasy.document.secure.processing.feature</code> Context Parameter</strong></div><p>
						
</p><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;resteasy.document.secure.processing.feature&lt;/param-name&gt;
 &lt;param-value&gt;false&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using_mapprovider"/>Using MapProvider</h2></div></div></div><p>
					You can use <code class="literal">MapProvider</code> to accept and return a map with JAX-RS resources.
				</p><div class="title"><strong>Example: Resource Accepting and Returning a Map</strong></div><p>
						
</p><pre class="programlisting">@Path("manipulateMap")
@POST
@Consumes("application/x-www-form-urlencoded")
@Produces("application/x-www-form-urlencoded")
public MultivaluedMap&lt;String, String&gt; manipulateMap(MultivaluedMap&lt;String, String&gt; map) {
  //do something
  return map;
}</pre><p>

					</p><p>
					You can also send and receive maps to JAX-RS resources using the client.
				</p><div class="title"><strong>Example: Client</strong></div><p>
						
</p><pre class="programlisting">MultivaluedMap&lt;String, String&gt; map = new MultivaluedHashMap&lt;String, String&gt;();

//add values to the map...

Response response = client.target(generateURL("/manipulateMap"))
                          .request(MediaType.APPLICATION_FORM_URLENCODED_TYPE)
                          .post(Entity.entity(map, MediaType.APPLICATION_FORM_URLENCODED_TYPE));

String data = response.readEntity(String.class);

//handle data...</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="converting_string_based_annotations_to_objects"/>Converting String Based Annotations to Objects</h2></div></div></div><p>
					JAX-RS <code class="literal">@*Param</code> annotations, including <code class="literal">@QueryParam</code>, <code class="literal">@MatrixParam</code>, <code class="literal">@HeaderParam</code>, <code class="literal">@PathParam</code>, and <code class="literal">@FormParam</code>, are represented as strings in a raw HTTP request. These types of injected parameters can be converted to objects if these objects have a <code class="literal">valueOf(String)</code> static method or a constructor that takes one <code class="literal">String</code> parameter.
				</p><p>
					If you have a class where the <code class="literal">valueOf()</code> method or the string constructor does not exist or is inappropriate for an HTTP request, JAX-RS provides the <code class="literal">javax.ws.rs.ext.ParamConverterProvider</code> and <code class="literal">javax.ws.rs.ext.ParamConverter</code> to help convert the message parameter value to the corresponding custom Java type. <code class="literal">ParamConverterProvider</code> must be either programmatically registered in a JAX-RS runtime or must be annotated with <code class="literal">@Provider</code> annotation to be automatically discovered by the JAX-RS runtime during a provider scanning phase.
				</p><p>
					For example: The steps below demonstrate how to create a custom POJO object. The conversion from message parameter value such as <code class="literal">@QueryParam</code>, <code class="literal">@PathParam</code>, <code class="literal">@MatrixParam</code>, <code class="literal">@HeaderParam</code> into POJO object is done by implementation of <code class="literal">ParamConverter</code> and <code class="literal">ParamConverterProvider</code> interfaces.
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Create the custom POJO class.
						</p><pre class="programlisting">public class POJO {
  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}</pre></li><li class="listitem"><p class="simpara">
							Create the custom POJO Converter class.
						</p><pre class="programlisting">public class POJOConverter implements ParamConverter&lt;POJO&gt; {
  public POJO fromString(String str) {
    System.out.println("FROM STRNG: " + str);
    POJO pojo = new POJO();
    pojo.setName(str);
    return pojo;
  }

  public String toString(POJO value) {
    return value.getName();
  }
}</pre></li><li class="listitem"><p class="simpara">
							Create the custom POJO Converter Provider class.
						</p><pre class="programlisting">public class POJOConverterProvider implements ParamConverterProvider {
  @Override
  public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation[] annotations) {
    if (!POJO.class.equals(rawType)) return null;
    return (ParamConverter&lt;T&gt;)new POJOConverter();
  }
}</pre></li><li class="listitem"><p class="simpara">
							Create the custom MyResource class.
						</p><pre class="programlisting">@Path("/")
public class MyResource {
  @Path("{pojo}")
  @PUT
  public void put(@QueryParam("pojo") POJO q, @PathParam("pojo") POJO pp, @MatrixParam("pojo") POJO mp,
    @HeaderParam("pojo") POJO hp) {
    ...
  }
}</pre></li></ol></div><h4><a id="extending_paramconverter_functionality"/>Extending the Functionality of the ParamConverter</h4><p>
					In the JAX-RS semantics, a <code class="literal">ParamConverter</code> converts a single string that represents an individual object. RESTEasy extends the semantics to allow a <code class="literal">ParamConverter</code> to parse the string representation of multiple objects and generate a <code class="literal">List&lt;T&gt;</code>, <code class="literal">Set&lt;T&gt;</code>, <code class="literal">SortedSet&lt;T&gt;</code>, <code class="literal">array</code>, or any other multi-valued data structure.
				</p><p>
					For an example, consider the resource:
				</p><pre class="programlisting">@Path("queryParam")
public static class TestResource {
   @GET
   @Path("")
   public Response conversion(@QueryParam("q") List&lt;String&gt; list) {
      return Response.ok(stringify(list)).build();
   }
}

private static &lt;T&gt; String stringify(List&lt;T&gt; list) {
   StringBuffer sb = new StringBuffer();
   for (T s : list) {
      sb.append(s).append(',');
   }
   return sb.toString();
}</pre><p>
					Calling <code class="literal">TestResource</code> as follows, using the standard notation:
				</p><pre class="programlisting">@Test
public void testQueryParamStandard() throws Exception {
   ResteasyClient client = new ResteasyClientBuilder().build();
   Invocation.Builder request = client.target("http://localhost:8081/queryParam?q=20161217&amp;q=20161218&amp;q=20161219").request();
   Response response = request.get();
   System.out.println("response: " + response.readEntity(String.class));
}</pre><p>
					results in <code class="literal">response: 20161217,20161218,20161219,</code>.
				</p><p>
					If you want to use a comma-separated notation instead, you can add:
				</p><pre class="programlisting">public static class MultiValuedParamConverterProvider implements ParamConverterProvider
   @SuppressWarnings("unchecked")
   @Override
   public &lt;T&gt; ParamConverter&lt;T&gt; getConverter(Class&lt;T&gt; rawType, Type genericType, Annotation[] annotations) {
      if (List.class.isAssignableFrom(rawType)) {
         return (ParamConverter&lt;T&gt;) new MultiValuedParamConverter();
      }
      return null;
   }
}

public static class MultiValuedParamConverter implements ParamConverter&lt;List&lt;?&gt;&gt; {
   @Override
   public List&lt;?&gt; fromString(String param) {
      if (param == null || param.trim().isEmpty()) {
         return null;
      }
      return parse(param.split(","));
   }

   @Override
   public String toString(List&lt;?&gt; list) {
      if (list == null || list.isEmpty()) {
         return null;
      }
      return stringify(list);
   }

   private static List&lt;String&gt; parse(String[] params) {
      List&lt;String&gt; list = new ArrayList&lt;String&gt;();
      for (String param : params) {
         list.add(param);
      }
      return list;
   }
}</pre><p>
					Now you can call <code class="literal">TestResource</code> as follows:
				</p><pre class="programlisting">@Test
public void testQueryParamCustom() throws Exception {
   ResteasyClient client = new ResteasyClientBuilder().build();
   Invocation.Builder request = client.target("http://localhost:8081/queryParam?q=20161217,20161218,20161219").request();
   Response response = request.get();
   System.out.println("response: " + response.readEntity(String.class));
}</pre><p>
					and get <code class="literal">response: 20161217,20161218,20161219,</code>.
				</p><p>
					In this case, the <code class="literal">MultiValuedParamConverter.fromString()</code> function creates and returns an <code class="literal">ArrayList</code>, so that the <code class="literal">TestResource.conversion()</code> function can be rewritten:
				</p><pre class="programlisting">@Path("queryParam")
public static class TestResource {

   @GET
   @Path("")
   public Response conversion(@QueryParam("q") ArrayList&lt;String&gt; list) {
      return Response.ok(stringify(list)).build();
   }
}</pre><p>
					Alternatively, <code class="literal">MultiValuedParamConverter</code> can be rewritten to return a <code class="literal">LinkList</code> and the parameter list in <code class="literal">TestResource.conversion()</code> can be either a <code class="literal">List</code> or a <code class="literal">LinkedList</code>.
				</p><p>
					Finally, note that this extension works for arrays as well. For example,
				</p><pre class="programlisting">public static class Foo {
    private String foo;
    public Foo(String foo) {
        this.foo = foo;
    }
    public String getFoo() {
        return foo;
    }
}

public static class FooArrayParamConverter implements ParamConverter &lt; Foo[] &gt; {
    @Override
    public Foo[] fromString(String value) {
        String[] ss = value.split(",");
        Foo[] fs = new Foo[ss.length];
        int i = 0;
        for (String s: ss) {
            fs[i++] = new Foo(s);
        }
        return fs;
    }

    @Override
    public String toString(Foo[] values) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; values.length; i++) {
            sb.append(values[i].getFoo()).append(",");
        }
        if (sb.length() &gt; 0) {
            sb.deleteCharAt(sb.length() - 1);
        }
        return sb.toString();
    }
}

@Provider
public static class FooArrayParamConverterProvider implements ParamConverterProvider {
    @SuppressWarnings("unchecked")
    @Override
    public &lt; T &gt; ParamConverter &lt; T &gt; getConverter(Class &lt; T &gt; rawType, Type genericType, Annotation[] annotations) {
        if (rawType.equals(Foo[].class));
        return (ParamConverter &lt; T &gt; ) new FooArrayParamConverter();
    }
}

@Path("")
public static class ParamConverterResource {

    @GET
    @Path("test")
    public Response test(@QueryParam("foos") Foo[] foos) {
        return Response.ok(new FooArrayParamConverter().toString(foos)).build();
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="serializable_provider"/>Serializable Provider</h2></div></div></div><p>
					Deserializing Java objects from untrusted sources is not safe. Therefore, <code class="literal">org.jboss.resteasy.plugins.providers.SerializableProvider</code> is disabled by default. It is not recommended to use this provider.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="json_provider"/>JSON Provider</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy_jackson2_json_filter_support"/>JsonFilter Support in RESTEasy Jackson2</h3></div></div></div><p>
						<code class="literal">JsonFilter</code> facilitates dynamic filtering by allowing you to annotate a class with <code class="literal">@JsonFilter</code>. The following example defines mapping from the <code class="literal">nameFilter</code> class to the filter instances, and then filtering out bean properties when serializing the instances to JSON format.
					</p><pre class="programlisting">@JsonFilter(value="nameFilter")
public class Jackson2Product {
    protected String name;
    protected int id;
    public Jackson2Product() {
    }
    public Jackson2Product(final int id, final String name) {
        this.id = id;
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
}</pre><p>
						<code class="literal">@JsonFilter</code> annotates the resource class to filter out the property that should not be serialized in the JSON response. To map the filter ID and instance, you must create another Jackson class and add the ID and filter instance map to it, as shown in the example below.
					</p><pre class="programlisting">public class ObjectFilterModifier extends ObjectWriterModifier {
	public ObjectFilterModifier() {
	}
	@Override
	public ObjectWriter modify(EndpointConfigBase&lt;?&gt; endpoint,
		MultivaluedMap&lt;String, Object&gt; httpHeaders, Object valueToWrite,
		ObjectWriter w, JsonGenerator jg) throws IOException {

		FilterProvider filterProvider = new SimpleFilterProvider().addFilter(
			"nameFilter",
			SimpleBeanPropertyFilter.filterOutAllExcept("name"));
		return w.with(filterProvider);
	}
}</pre><p>
						In the example above, the method <code class="literal">modify()</code> takes care of filtering all properties except the <code class="literal">name</code> property before writing the response. For this to work, RESTEasy must know about this mapping information. You can set the mapping information either in a <code class="literal">WriterInterceptor</code> or a servlet filter, as shown in the examples below.
					</p><div class="title"><strong>Example: Setting ObjectFilterModifier Using WriterInterceptor</strong></div><p>
							
</p><pre class="programlisting">@Provider
public class JsonFilterWriteInterceptor implements WriterInterceptor{

	private ObjectFilterModifier modifier = new ObjectFilterModifier();
	@Override
	public void aroundWriteTo(WriterInterceptorContext context)
		throws IOException, WebApplicationException {
	    	//set a threadlocal modifier
            ObjectWriterInjector.set(modifier);
                context.proceed();
	}

}</pre><p>

						</p><div class="title"><strong>Example: Setting ObjectFilterModifier Using Servlet Filter</strong></div><p>
							
</p><pre class="programlisting">public class ObjectWriterModifierFilter implements Filter {
	private static ObjectFilterModifier modifier = new ObjectFilterModifier();

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response,
		FilterChain chain) throws IOException, ServletException {
		    ObjectWriterInjector.set(modifier);
		    chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
	}

}</pre><p>

						</p><p>
						Now, RESTEasy can get the <code class="literal">ObjectFilterModifier</code> from the <code class="literal">ThreadLocal</code> variable and configure it to modify <code class="literal">ObjectWriter</code> before writing the response.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy_java_api_for_json_binding"/>Java API for JSON Binding</h3></div></div></div><p>
						RESTEasy supports both JSON-B and JSON-P. In accordance with the specification, entity providers for JSON-B take precedence over the ones for JSON-P for all types of entities except <code class="literal">JsonValue</code> and its sub-types.
					</p><p>
						The <code class="literal">JsonBindingProvider</code> property from <code class="literal">resteasy-json-binding-provider</code> module provides support for JSON-B. To satisfy JAX-RS 2.1 requirements, the <code class="literal">JsonBindingProvider</code> provider takes precedence over the other providers for dealing with JSON payloads, in particular the Jackson payload.
					</p><p>
						For the same input, the JSON outputs from Jackson and JSON-B reference implementation can vary. Consequently, in order to retain backward compatibility, you can set the <code class="literal">resteasy.preferJacksonOverJsonB</code> context property to <code class="literal">true</code> and disable the <code class="literal">JsonBindingProvider</code> configuration for the current deployment.
					</p><p>
						JBoss EAP supports specifying the default value for the <code class="literal">resteasy.preferJacksonOverJsonB</code> context property by setting a system property with the same name. If no value is set for the context and system properties, it scans JAX-RS deployments for Jackson annotations and sets the property to <code class="literal">true</code> if any of these annotations is found.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxb_providers"/>JAXB Providers</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="jaxb_and_xml_provider"/>JAXB and XML Provider</h3></div></div></div><p>
						RESTEasy provides JAXB provider support for XML.
					</p><h5><a id="xmlheader_and_stylesheet"/>@XmlHeader and @Stylesheet</h5><p>
						RESTEasy provides setting an XML header using the <code class="literal">@org.jboss.resteasy.annotations.providers.jaxb.XmlHeader</code> annotation.
					</p><div class="title"><strong>Example: Using the <code class="literal">@XmlHeader</code> Annotation</strong></div><p>
							
</p><pre class="programlisting">@XmlRootElement
public static class Thing {
   private String name;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }
}

@Path("/test")
public static class TestService {

   @GET
   @Path("/header")
   @Produces("application/xml")
   @XmlHeader("&lt;?xml-stylesheet type='text/xsl' href='${baseuri}foo.xsl' ?&gt;")
   public Thing get() {
      Thing thing = new Thing();
      thing.setName("bill");
      return thing;
   }
}</pre><p>

						</p><p>
						The <code class="literal">@XmlHeader</code> ensures that the XML output has an XML-stylesheet header.
					</p><p>
						RESTEasy has a convenient annotation for stylesheet headers.
					</p><div class="title"><strong>Example: Using the <code class="literal">@Stylesheet</code> Annotation</strong></div><p>
							
</p><pre class="programlisting">@XmlRootElement
public static class Thing {
   private String name;

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }
}

@Path("/test")
public static class TestService {

   @GET
   @Path("/stylesheet")
   @Produces("application/xml")
   @Stylesheet(type="text/css", href="${basepath}foo.xsl")
   @Junk
   public Thing getStyle() {
      Thing thing = new Thing();
      thing.setName("bill");
      return thing;
   }
}</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-jaxb-json"/>JAXB and JSON Provider</h3></div></div></div><p>
						RESTEasy allows you to marshal JAXB annotated POJOs to and from JSON using the JSON provider. This provider wraps the Jackson JSON library to accomplish this task. It has a Java Beans based model and APIs similar to JAXB.
					</p><p>
						While Jackson already includes JAX-RS integration, it was expanded by RESTEasy. To include it in your project, you need to update the Maven dependencies.
					</p><div class="title"><strong>Maven Dependencies for Jackson</strong></div><p>
							
</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-jackson2-provider&lt;/artifactId&gt;
    &lt;version&gt;${version.org.jboss.resteasy}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The default JSON provider for RESTEasy is Jackson2. Previous versions of JBoss EAP included the Jackson1 JSON provider. For more details on migrating your existing applications from the Jackson1 provider, see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/migration_guide/#migrate_jackson_provider_changes">JBoss EAP <span class="emphasis"><em>Migration Guide</em></span></a>. If you still want to use the Jackson1 provider, you have to <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/development_guide/#add_an_explicit_module_dependency_to_a_deployment">explicitly update the Maven dependencies to obtain it</a>.
						</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The default JSON provider for RESTEasy in previous versions of JBoss EAP was Jettison, but is now deprecated in JBoss EAP 7. For more details, see the JBoss EAP <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/migration_guide/#migrate_resteasy_jettison_json_provider"><span class="emphasis"><em>Migration Guide</em></span></a>.
						</p></div><div class="title"><strong>Example JSON Provider</strong></div><p>
							
</p><pre class="programlisting">@XmlRootElement
public static class Thing {
  private String name;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}

@Path("/test")
public static class TestService {
  @GET
  @Path("/thing")
  @Produces("application/json")
  public Thing get() {
    Thing thing = new Thing();
    thing.setName("the thing");
    return thing;
  }
}</pre><p>

						</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="jackson_module_support"/>Jackson Module Support for Java 8</h4></div></div></div><p>
							This section provides the Maven dependencies and shows how to register the Jackson modules needed to support Java 8 features, when the core Jackson modules do not require Java 8 runtime environment. These Jackson modules include:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									Java 8 data types
								</li><li class="listitem">
									Java 8 date/time
								</li></ul></div><p>
							Add the following Maven dependencies:
						</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>
							You can find and register all the modules using <code class="literal">findAndRegisterModules()</code> or <code class="literal">ObjectMapper.registerModule()</code>, as shown in the examples below:
						</p><pre class="programlisting">ObjectMapper mapper = new ObjectMapper();
mapper.findAndRegisterModules();</pre><pre class="programlisting">ObjectMapper mapper = new ObjectMapper()
   .registerModule(new ParameterNamesModule())
   .registerModule(new Jdk8Module())
   .registerModule(new JavaTimeModule());</pre><div class="title"><strong>Example: Duration Data Type</strong></div><p>
								
</p><pre class="programlisting">@GET
@Path("/duration")
@Produces(MediaType.APPLICATION_JSON)
public Duration getDuration() {
    return Duration.ofSeconds(5, 6);
}</pre><p>

							</p><div class="title"><strong>Example: Optional Data Type</strong></div><p>
								
</p><pre class="programlisting">@GET
@Path("/optional/{nullParam}")
@Produces(MediaType.APPLICATION_JSON)
public Optional&lt;String&gt; getOptional(@PathParam("nullParam") boolean nullParameter) {
    return nullParameter ? Optional.&lt;String&gt;empty() : Optional.of("info@example.com");
}</pre><p>

							</p><p>
							You must use the custom implementation of the <code class="literal">ContextResolver</code> in order to use these Jackson modules in RESTEasy.
						</p><pre class="programlisting">@Provider
@Produces(MediaType.APPLICATION_JSON)
public class JacksonDatatypeJacksonProducer implements ContextResolver&lt;ObjectMapper&gt; {
    private final ObjectMapper json;
    public JacksonDatatypeJacksonProducer() throws Exception {
        this.json = new ObjectMapper()
                .findAndRegisterModules()
                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
    @Override
    public ObjectMapper getContext(Class&lt;?&gt; objectType) {
        return json;
    }
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="switching_the_default_jackson_provider"/>Switching the Default Jackson Provider</h4></div></div></div><p>
							JBoss EAP 7 includes Jackson 2.6.x or greater and <code class="literal">resteasy-jackson2-provider</code> is now the default Jackson provider.
						</p><p>
							To switch to the default <code class="literal">resteasy-jackson-provider</code> that was included in the previous release of JBoss EAP, exclude the new provider and add a dependency for the previous provider in the <code class="literal">jboss-deployment-structure.xml</code> application deployment descriptor file.
						</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jboss-deployment-structure&gt;
   &lt;deployment&gt;
       &lt;exclusions&gt;
           &lt;module name="org.jboss.resteasy.resteasy-jackson2-provider"/&gt;
       &lt;/exclusions&gt;
       &lt;dependencies&gt;
           &lt;module name="org.jboss.resteasy.resteasy-jackson-provider" services="import"/&gt;
       &lt;/dependencies&gt;
   &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxb_decorators"/>Creating JAXB Decorators</h2></div></div></div><p>
					RESTEasy’s JAXB providers have a pluggable way to decorate Marshaller and Unmarshaller instances. You can create an annotation that can trigger either a Marshaller or Unmarshaller instance, which can be used to decorate methods.
				</p><h4><a id="create_a_jaxb_decorator_with_resteasy"/>Create a JAXB Decorator with RESTEasy</h4><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
							Create the Processor class.
						</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
									Create a class that implements <code class="literal">DecoratorProcessor&lt;Target, Annotation&gt;</code>. The target is either the JAXB Marshaller or Unmarshaller class. The annotation is created in step two.
								</li><li class="listitem">
									Annotate the class with <code class="literal">@DecorateTypes</code>, and declare the MIME types the decorator should decorate.
								</li><li class="listitem"><p class="simpara">
									Set properties or values within the decorate function.
								</p><div class="title"><strong>Example: Processor Class</strong></div><p>
										
</p><pre class="programlisting">import org.jboss.resteasy.core.interception.DecoratorProcessor;
import org.jboss.resteasy.annotations.DecorateTypes;
import javax.xml.bind.Marshaller;
import javax.xml.bind.PropertyException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.Produces;
import java.lang.annotation.Annotation;

@DecorateTypes({"text/*+xml", "application/*+xml"})
public class PrettyProcessor implements DecoratorProcessor&lt;Marshaller, Pretty&gt; {
    public Marshaller decorate(Marshaller target, Pretty annotation,
      Class type, Annotation[] annotations, MediaType mediaType) {
    target.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
    }
}</pre><p>

									</p></li></ol></div></li><li class="listitem"><p class="simpara">
							Create the annotation.
						</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
									Create a custom interface that is annotated with the <code class="literal">@Decorator</code> annotation.
								</li><li class="listitem"><p class="simpara">
									Declare the processor and target for the <code class="literal">@Decorator</code> annotation. The processor is created in step one. The target is either the JAXB <code class="literal">Marshaller</code> or <code class="literal">Unmarshaller</code> class.
								</p><div class="title"><strong>Example: Custom Interface with <code class="literal">@Decorator</code> Annotation</strong></div><p>
										
</p><pre class="programlisting">import org.jboss.resteasy.annotations.Decorator;

@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Decorator(processor = PrettyProcessor.class, target = Marshaller.class)
public @interface Pretty {}</pre><p>

									</p></li></ol></div></li><li class="listitem">
							Add the annotation created in step two to a function so that either the input or output is decorated when it is marshaled.
						</li></ol></div><p>
					You have now created a JAXB decorator, which can be applied within a JAX-RS web service.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy-multipart-providers"/>Multipart Providers in JAX-RS</h2></div></div></div><p>
					The multipart MIME format is used to pass lists of content bodies embedded in one message. One example of a multipart MIME format is the <code class="literal">multipart/form-data</code> MIME type. This is often found in web application HTML form documents and is generally used to upload files. The <code class="literal">form-data</code> format in this MIME type is the same as other multipart formats, except that each inlined piece of content has a name associated with it.
				</p><p>
					RESTEasy allows for the <code class="literal">multipart/form-data</code> and <code class="literal">multipart/*</code> MIME types. RESTEasy also provides a custom API for reading and writing multipart types as well as marshalling arbitrary <code class="literal">List</code> (for any multipart type) and <code class="literal">Map</code> (multipart/form-data only) objects.
				</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
						There are a lot of frameworks doing multipart parsing automatically with the help of filters and interceptors, such as <code class="literal">org.jboss.seam.web.MultipartFilter</code> in Seam or <code class="literal">org.springframework.web.multipart.MultipartResolver</code> in Spring. However, the incoming multipart request stream can be parsed only once. RESTEasy users working with multipart should make sure that nothing parses the stream before RESTEasy gets it.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-input"/>Input with Multipart Data</h3></div></div></div><p>
						When writing a JAX-RS service, RESTEasy provides the <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartInput</code> interface to allow you to read in any multipart MIME type.
					</p><pre class="programlisting">package org.jboss.resteasy.plugins.providers.multipart;

public interface MultipartInput {

   List&lt;InputPart&gt; getParts();
   String getPreamble();

   // You must call close to delete any temporary files created
   // Otherwise they will be deleted on garbage collection or on JVM exit
   void close();
}

public interface InputPart {

   MultivaluedMap&lt;String, String&gt; getHeaders();
   String getBodyAsString();
   &lt;T&gt; T getBody(Class&lt;T&gt; type, Type genericType) throws IOException;
   &lt;T&gt; T getBody(org.jboss.resteasy.util.GenericType&lt;T&gt; type) throws IOException;
   MediaType getMediaType();
   boolean isContentTypeFromMessage();
}</pre><p>
						<code class="literal">MultipartInput</code> is a simple interface that allows you to get access to each part of the multipart message. Each part is represented by an <code class="literal">InputPart</code> interface, and each part has a set of headers associated with it. You can unmarshal the part by calling one of the <code class="literal">getBody()</code> methods. The <code class="literal">genericType</code> parameter can be <code class="literal">null</code>, but the <code class="literal">type</code> parameter must be set. RESTEasy will find a <code class="literal">MessageBodyReader</code> based on the media type of the part as well as the type information you pass in.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="input_with_literal_multipart_mixed_literal"/>Input with <code class="literal">multipart/mixed</code></h4></div></div></div><div class="title"><strong>Example: Unmarshalling Parts</strong></div><p>
								
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @PUT
    @Consumes("multipart/mixed")
    public void put(MultipartInput input) {
        List&lt;Customer&gt; customers = new ArrayList...;
        for (InputPart part : input.getParts()) {
            Customer cust = part.getBody(Customer.class, null);
            customers.add(cust);
        }
        input.close();
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div><p>
							Sometimes you may want to unmarshal a body part that is sensitive to generic type metadata. In this case you can use the <code class="literal">org.jboss.resteasy.util.GenericType</code> class.
						</p><div class="title"><strong>Example: Unmarshalling a Type Sensitive to Generic Type Metadata</strong></div><p>
								
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @PUT
    @Consumes("multipart/mixed")
    public void put(MultipartInput input) {
        for (InputPart part : input.getParts()) {
            List&lt;Customer&gt; cust = part.getBody(new GenericType&lt;List&lt;Customer&gt;&gt;() {});
        }
        input.close();
    }
}</pre><p>

							</p><p>
							Use of <code class="literal">GenericType</code> is required because it is the only way to obtain generic type information at runtime.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="input_with_literal_multipart_mixed_literal_and_literal_java_util_list_literal"/>Input with <code class="literal">multipart/mixed</code> and <code class="literal">java.util.List</code></h4></div></div></div><p>
							If the body parts are uniform, you do not have to manually unmarshal each and every part. You can just provide a <code class="literal">java.util.List</code> as your input parameter. It must have the type it is unmarshalling with the generic parameter of the <code class="literal">List</code> type declaration.
						</p><div class="title"><strong>Example: Unmarshalling a <code class="literal">List</code> of <code class="literal">Customers</code></strong></div><p>
								
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @PUT
    @Consumes("multipart/mixed")
    public void put(List&lt;Customer&gt; customers) {
        ...
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="input_with_literal_multipart_form_data_literal"/>Input with <code class="literal">multipart/form-data</code></h4></div></div></div><p>
							When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in <code class="literal">multipart/form-data</code> MIME type. <code class="literal">multipart/form-data</code> is often found in web application HTML form documents and is generally used to upload files. The <code class="literal">form-data</code> format is the same as other multipart formats, except that each inlined piece of content has a name associated with it. The interface used for form-data input is <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartFormDataInput</code>.
						</p><div class="title"><strong>Example: MultipartFormDataInput Interface</strong></div><p>
								
</p><pre class="programlisting">public interface MultipartFormDataInput extends MultipartInput {

    @Deprecated
    Map&lt;String, InputPart&gt; getFormData();
    Map&lt;String, List&lt;InputPart&gt;&gt; getFormDataMap();
    &lt;T&gt; T getFormDataPart(String key, Class&lt;T&gt; rawType, Type genericType) throws IOException;
    &lt;T&gt; T getFormDataPart(String key, GenericType&lt;T&gt; type) throws IOException;
}</pre><p>

							</p><p>
							It works in much the same way as <code class="literal">MultipartInput</code> <a class="link" href="developing_jax_rs_web_services.html#resteasy-multipart-input" title="Input with Multipart Data">described earlier</a>.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="literal_java_util_map_literal_with_literal_multipart_form_data_literal"/><code class="literal">java.util.Map</code> with <code class="literal">multipart/form-data</code></h4></div></div></div><p>
							With form-data, if the body parts are uniform, you do not have to manually unmarshal each and every part. You can just provide a <code class="literal">java.util.Map</code> as your input parameter. It must have the type it is unmarshalling with the generic parameter of the <code class="literal">List</code> type declaration.
						</p><div class="title"><strong>Example: Unmarshalling a <code class="literal">Map</code> of <code class="literal">Customer</code> objects</strong></div><p>
								
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @PUT
    @Consumes("multipart/form-data")
    public void put(Map&lt;String, Customer&gt; customers) {
        ...
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="input_with_literal_multipart_related_literal"/>Input with <code class="literal">multipart/related</code></h4></div></div></div><p>
							When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in <code class="literal">multipart/related</code> MIME type. A <code class="literal">multipart/related</code> is used to indicate that message parts should not be considered individually but rather as parts of an aggregate whole and is defined by <a class="link" href="http://tools.ietf.org/html/rfc2387">RFC 2387</a>.
						</p><p>
							One example usage for <code class="literal">multipart/related</code> is to send a web page complete with images in a single message. Every <code class="literal">multipart/related</code> message has a root/start part that references the other parts of the message. The parts are identified by their <code class="literal">Content-ID</code> headers. The interface used for related input is <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartRelatedInput</code>.
						</p><div class="title"><strong>Example: MultipartRelatedInput Interface</strong></div><p>
								
</p><pre class="programlisting">public interface MultipartRelatedInput extends MultipartInput {

    String getType();
    String getStart();
    String getStartInfo();
    InputPart getRootPart();
    Map&lt;String, InputPart&gt; getRelatedMap();
}</pre><p>

							</p><p>
							It works in much the same way as <code class="literal">MultipartInput</code>.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-output"/>Output with Multipart Data</h3></div></div></div><p>
						RESTEasy provides a simple API to output multipart data.
					</p><pre class="programlisting">package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartOutput {

    public OutputPart addPart(Object entity, MediaType mediaType)
    public OutputPart addPart(Object entity, GenericType type, MediaType mediaType)
    public OutputPart addPart(Object entity, Class type, Type genericType, MediaType mediaType)
    public List&lt;OutputPart&gt; getParts()
    public String getBoundary()
    public void setBoundary(String boundary)
}

public class OutputPart {

    public MultivaluedMap&lt;String, Object&gt; getHeaders()
    public Object getEntity()
    public Class getType()
    public Type getGenericType()
    public MediaType getMediaType()
}</pre><p>
						To output multipart data, you need to create a <code class="literal">MultipartOutput</code> object and call the <code class="literal">addPart()</code> method. RESTEasy will automatically find a <code class="literal">MessageBodyWriter</code> to marshal your entity objects. Similar to <code class="literal">MultipartInput</code>, sometimes you might have marshalling that is sensitive to generic type metadata. In that case, use the <code class="literal">GenericType</code>. Usually, passing in an object and its <code class="literal">MediaType</code> should be enough.
					</p><div class="title"><strong>Example: Returning a <code class="literal">multipart/mixed</code> Format</strong></div><p>
							
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @GET
    @Produces("multipart/mixed")
    public MultipartOutput get() {

        MultipartOutput output = new MultipartOutput();
        output.addPart(new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
        output.addPart(new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
        return output;
    }
}</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="multipart_output_with_literal_java_util_list_literal"/>Multipart Output with <code class="literal">java.util.List</code></h4></div></div></div><p>
							If the body parts are uniform, you do not have to manually marshal each and every part or even use a <code class="literal">MultipartOutput</code> object. You can provide a <code class="literal">java.util.List</code> which must have the generic type it is marshalling with the generic parameter of the <code class="literal">List</code> type declaration. You must also annotate the method with the <code class="literal">@PartType</code> annotation to specify the media type of each part.
						</p><div class="title"><strong>Example: Returning a <code class="literal">List</code> of <code class="literal">Customer</code> Objects</strong></div><p>
								
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @GET
    @Produces("multipart/mixed")
    @PartType("application/xml")
    public List&lt;Customer&gt; get(){
        ...
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="output_with_literal_multipart_form_data_literal"/>Output with <code class="literal">multipart/form-data</code></h4></div></div></div><p>
							RESTEasy provides a simple API to output <code class="literal">multipart/form-data</code>.
						</p><pre class="programlisting">package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartFormDataOutput extends MultipartOutput {

    public OutputPart addFormData(String key, Object entity, MediaType mediaType)
    public OutputPart addFormData(String key, Object entity, GenericType type, MediaType mediaType)
    public OutputPart addFormData(String key, Object entity, Class type, Type genericType, MediaType mediaType)
    public Map&lt;String, OutputPart&gt; getFormData()
}</pre><p>
							To output <code class="literal">multipart/form-data</code>, you must create a <code class="literal">MultipartFormDataOutput</code> object and call the <code class="literal">addFormData()</code> method. RESTEasy will automatically find a <code class="literal">MessageBodyWriter</code> to marshal your entity objects. Similar to <code class="literal">MultipartInput</code>, sometimes you might have marshalling that is sensitive to generic type metadata. In that case, use the <code class="literal">GenericType</code>. Usually, passing in an object and its <code class="literal">MediaType</code> should be enough.
						</p><div class="title"><strong>Example: Returning <code class="literal">multipart/form-data</code> Format</strong></div><p>
								
</p><pre class="programlisting">@Path("/form")
public class MyService {

    @GET
    @Produces("multipart/form-data")
    public MultipartFormDataOutput get() {

        MultipartFormDataOutput output = new MultipartFormDataOutput();
        output.addPart("bill", new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
        output.addPart("monica", new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
        return output;
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="multipart_formdata_output_with_literal_java_util_map_literal"/>Multipart FormData Output with <code class="literal">java.util.Map</code></h4></div></div></div><p>
							If the body parts are uniform, you do not have to manually marshal every part or use a <code class="literal">MultipartFormDataOutput</code> object. You can just provide a <code class="literal">java.util.Map</code> which must have the generic type it is marshalling with the generic parameter of the <code class="literal">Map</code> type declaration. You must also annotate the method with the <code class="literal">@PartType</code> annotation to specify the media type of each part.
						</p><div class="title"><strong>Example: Returning a <code class="literal">Map</code> of <code class="literal">Customer</code> Objects</strong></div><p>
								
</p><pre class="programlisting">@Path("/multipart")
public class MyService {

    @GET
    @Produces("multipart/form-data")
    @PartType("application/xml")
    public Map&lt;String, Customer&gt; get() {
        ...
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="output_with_literal_multipart_related_literal"/>Output with <code class="literal">multipart/related</code></h4></div></div></div><p>
							RESTEasy provides a simple API to output <code class="literal">multipart/related</code>.
						</p><pre class="programlisting">package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartRelatedOutput extends MultipartOutput {

    public OutputPart getRootPart()
    public OutputPart addPart(Object entity, MediaType mediaType,
        String contentId, String contentTransferEncoding)
    public String getStartInfo()
    public void setStartInfo(String startInfo)
}</pre><p>
							To output <code class="literal">multipart/related</code>, you must create a <code class="literal">MultipartRelatedOutput</code> object and call the <code class="literal">addPart()</code> method. The first added part is used as the root part of the <code class="literal">multipart/related</code> message, and RESTEasy automatically finds a <code class="literal">MessageBodyWriter</code> to marshal your entity objects. Similar to <code class="literal">MultipartInput</code>, sometimes you might have marshalling that is sensitive to generic type metadata. In that case, use the <code class="literal">GenericType</code>. Usually, passing in an object and its <code class="literal">MediaType</code> should be enough.
						</p><div class="title"><strong>Example: Returning <code class="literal">multipart/related</code> Format Sending Two Images</strong></div><p>
								
</p><pre class="programlisting">@Path("/related")
public class MyService {

    @GET
    @Produces("multipart/related")
    public MultipartRelatedOutput get() {

        MultipartRelatedOutput output = new MultipartRelatedOutput();
        output.setStartInfo("text/html");

        Map&lt;String, String&gt; mediaTypeParameters = new LinkedHashMap&lt;String, String&gt;();
        mediaTypeParameters.put("charset", "UTF-8");
        mediaTypeParameters.put("type", "text/html");
        output.addPart(
            "&lt;html&gt;&lt;body&gt;\n"
            + "This is me: &lt;img src='cid:http://example.org/me.png' /&gt;\n"
            + "&lt;br /&gt;This is you: &lt;img src='cid:http://example.org/you.png' /&gt;\n"
            + "&lt;/body&gt;&lt;/html&gt;",
            new MediaType("text", "html", mediaTypeParameters),
            "&lt;mymessage.xml@example.org&gt;", "8bit");
        output.addPart("// binary octets for me png",
            new MediaType("image", "png"), "&lt;http://example.org/me.png&gt;",
            "binary");
        output.addPart("// binary octets for you png", new MediaType(
            "image", "png"),
            "&lt;http://example.org/you.png&gt;", "binary");
        client.putRelated(output);
        return output;
    }
}</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
							</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-form-pojo"/>Mapping Multipart Forms to POJOs</h3></div></div></div><p>
						If you have an exact knowledge of your multipart/form-data packets, you can map them to and from a POJO class. This is accomplished using the <code class="literal">org.jboss.resteasy.annotations.providers.multipart.MultipartForm</code> annotation (<code class="literal">@MultipartForm</code>) and the JAX-RS <code class="literal">@FormParam</code> annotation. To do so, you need to define a POJO with at least a default constructor and annotate its fields and/or properties with <code class="literal">@FormParams</code>. These <code class="literal">@FormParams</code> must also be annotated with <code class="literal">org.jboss.resteasy.annotations.providers.multipart.PartType</code> (<code class="literal">@PartType</code>) if you are creating output.
					</p><div class="title"><strong>Example: Mapping Multipart Forms to a POJO</strong></div><p>
							
</p><pre class="programlisting">public class CustomerProblemForm {

    @FormParam("customer")
    @PartType("application/xml")
    private Customer customer;

    @FormParam("problem")
    @PartType("text/plain")
    private String problem;

    public Customer getCustomer() { return customer; }
    public void setCustomer(Customer cust) { this.customer = cust; }
    public String getProblem() { return problem; }
    public void setProblem(String problem) { this.problem = problem; }
}</pre><p>

						</p><p>
						After defining your POJO class you can then use it to represent <code class="literal">multipart/form-data</code>.
					</p><div class="title"><strong>Example: Submit <code class="literal">CustomerProblemForm</code></strong></div><p>
							
</p><pre class="programlisting">@Path("portal")
public interface CustomerPortal {

    @Path("issues/{id}")
    @Consumes("multipart/form-data")
    @PUT
    public void putProblem(@MultipartForm CustomerProblemForm,
                           @PathParam("id") int id);
}

// Somewhere using it:
{
    CustomerPortal portal = ProxyFactory.create(CustomerPortal.class, "http://example.com");
    CustomerProblemForm form = new CustomerProblemForm();
    form.setCustomer(...);
    form.setProblem(...);

    portal.putProblem(form, 333);
}</pre><p>

						</p><p>
						The <code class="literal">@MultipartForm</code> annotation tells RESTEasy that the object has <code class="literal">@FormParam</code> and that it should be marshaled from that. You can also use the same object to receive multipart data.
					</p><div class="title"><strong>Example: Receive <code class="literal">CustomerProblemForm</code></strong></div><p>
							
</p><pre class="programlisting">@Path("portal")
public class CustomerPortalServer {

    @Path("issues/{id})
    @Consumes("multipart/form-data")
    @PUT
    public void putIssue(@MultipartForm CustomerProblemForm,
                         @PathParam("id") int id) {
       ... write to database...
    }
}</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-xop"/>XML-binary Optimized Packaging (XOP)</h3></div></div></div><p>
						If you have a JAXB annotated POJO that also holds some binary content, you may choose to send it in such a way that the binary does not need to be encoded in any way such as base64 or hex. This is accomplished using <a class="link" href="http://www.w3.org/TR/xop10/">XOP</a> and results in faster transport while still using the convenient POJO.
					</p><p>
						RESTEasy allows for XOP messages packaged as <code class="literal">multipart/related</code>.
					</p><p>
						To configure XOP, you first need a JAXB annotated POJO.
					</p><div class="title"><strong>Example: JAXB POJO</strong></div><p>
							
</p><pre class="programlisting">@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Xop {

    private Customer bill;
    private Customer monica;

    @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
    private byte[] myBinary;

    @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
    private DataHandler myDataHandler;

    // methods, other fields ...
}</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							@XmlMimeType tells JAXB the mime type of the binary content. This is not required to do XOP packaging but it is recommended to be set if you know the exact type.
						</p></div><p>
						In the above POJO <code class="literal">myBinary</code> and <code class="literal">myDataHandler</code> will be processed as binary attachments while the whole XOP object will be sent as XML. In place of the binaries, only their references will be generated. <code class="literal">javax.activation.DataHandler</code> is the most general supported type. If you need a <code class="literal">java.io.InputStream</code> or a <code class="literal">javax.activation.DataSource</code>, you need to use the <code class="literal">DataHandler</code>. <code class="literal">java.awt.Image</code> and <code class="literal">javax.xml.transform.SourceSome</code> are available as well.
					</p><div class="title"><strong>Example: Client Sending Binary Content with XOP</strong></div><p>
							
</p><pre class="programlisting">// our client interface:
@Path("mime")
public static interface MultipartClient {
    @Path("xop")
    @PUT
    @Consumes(MultipartConstants.MULTIPART_RELATED)
    public void putXop(@XopWithMultipartRelated Xop bean);
}

// Somewhere using it:
{
    MultipartClient client = ProxyFactory.create(MultipartClient.class,
        "http://www.example.org");
    Xop xop = new Xop(new Customer("bill"), new Customer("monica"),
        "Hello Xop World!".getBytes("UTF-8"),
        new DataHandler(new ByteArrayDataSource("Hello Xop World!".getBytes("UTF-8"),
        MediaType.APPLICATION_OCTET_STREAM)));
    client.putXop(xop);
}</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The above example assumes the <code class="literal">Customer</code> class is annotated with JAXB.
						</p></div><p>
						The <code class="literal">@Consumes(MultipartConstants.MULTIPART_RELATED)</code> is used to tell RESTEasy that you want to send <code class="literal">multipart/related</code> packages, which is the container format that holds the XOP message. <code class="literal">@XopWithMultipartRelated</code> is used to tell RESTEasy that you want to make XOP messages.
					</p><div class="title"><strong>Example: RESTEasy Server for Receiving XOP</strong></div><p>
							
</p><pre class="programlisting">@Path("/mime")
public class XopService {
    @PUT
    @Path("xop")
    @Consumes(MultipartConstants.MULTIPART_RELATED)
    public void putXopWithMultipartRelated(@XopWithMultipartRelated Xop xop) {
        // do very important things here
    }
}</pre><p>

						</p><p>
						<code class="literal">@Consumes(MultipartConstants.MULTIPART_RELATED)</code> is used to tell RESTEasy that you want to read <code class="literal">multipart/related</code> packages. <code class="literal">@XopWithMultipartRelated</code> is used to tell RESTEasy that you want to read XOP messages. You can configure a RESTEasy server to produce XOP values in a similar way by adding a <code class="literal">@Produces</code> annotation and returning the appropriate type.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-overwrite-fallback-content-type"/>Overwriting the Default Fallback Content Type for Multipart Messages</h3></div></div></div><p>
						By default, if no <code class="literal">Content-Type</code> header is present in a part, <code class="literal">text/plain; charset=us-ascii</code> is used as a fallback. This is defined by the MIME RFC. However some web clients, such as many browsers, may send <code class="literal">Content-Type</code> headers for the file parts, but not for all fields in a <code class="literal">multipart/form-data</code> request. This can cause character encoding and unmarshalling errors on the server side. The <code class="literal">PreProcessInterceptor</code> infrastructure of RESTEasy can be used to correct this issue. You can use it to define another, non-RFC compliant fallback value, dynamically per request.
					</p><div class="title"><strong>Example: Setting <code class="literal">* / *; charset=UTF-8</code> as the Default Fallback</strong></div><p>
							
</p><pre class="programlisting">import org.jboss.resteasy.plugins.providers.multipart.InputPart;

@Provider
@ServerInterceptor
public class ContentTypeSetterPreProcessorInterceptor implements PreProcessInterceptor {

    public ServerResponse preProcess(HttpRequest request, ResourceMethod method)
            throws Failure, WebApplicationException {
        request.setAttribute(InputPart.DEFAULT_CONTENT_TYPE_PROPERTY, "*/*; charset=UTF-8");
        return null;
    }
}</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-overwrite-content-type"/>Overwriting the Content Type for Multipart Messages</h3></div></div></div><p>
						Using an interceptor and the <code class="literal">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY attribute</code> allows you to set a default <code class="literal">Content-Type</code>. You can also override the <code class="literal">Content-Type</code> in any input part by calling <code class="literal">org.jboss.resteasy.plugins.providers.multipart.InputPart.setMediaType()</code>.
					</p><div class="title"><strong>Example: Overriding the <code class="literal">Content-Type</code></strong></div><p>
							
</p><pre class="programlisting">@POST
@Path("query")
@Consumes(MediaType.MULTIPART_FORM_DATA)
@Produces(MediaType.TEXT_PLAIN)
public Response setMediaType(MultipartInput input) throws IOException {

    List&lt;InputPart&gt; parts = input.getParts();
    InputPart part = parts.get(0);
    part.setMediaType(MediaType.valueOf("application/foo+xml"));
    String s = part.getBody(String.class, null);
    ...
}</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy-multipart-overwrite-fallback-charset"/>Overwriting the Default Fallback <code class="literal">charset</code> for Multipart Messages</h3></div></div></div><p>
						In some cases, part of a multipart message may have a <code class="literal">Content-Type</code> header with no <code class="literal">charset</code> parameter. If the <code class="literal">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY</code> property is set and the value has a <code class="literal">charset</code> parameter, that value will be appended to an existing <code class="literal">Content-Type</code> header that has no <code class="literal">charset</code> parameter.
					</p><p>
						You can also specify a default <code class="literal">charset</code> using the constant <code class="literal">InputPart.DEFAULT_CHARSET_PROPERTY</code> (<code class="literal">resteasy.provider.multipart.inputpart.defaultCharset</code>).
					</p><div class="title"><strong>Example: Specifying a Default <code class="literal">charset</code></strong></div><p>
							
</p><pre class="programlisting">import org.jboss.resteasy.plugins.providers.multipart.InputPart;

@Provider
@ServerInterceptor
public class ContentTypeSetterPreProcessorInterceptor implements PreProcessInterceptor {

    public ServerResponse preProcess(HttpRequest request, ResourceMethod method)
            throws Failure, WebApplicationException {
        request.setAttribute(InputPart.DEFAULT_CHARSET_PROPERTY, "UTF-8");
        return null;
    }
}</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							If both <code class="literal">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY</code> and <code class="literal">InputPart.DEFAULT_CHARSET_PROPERTY</code> are set, then the value of <code class="literal">InputPart.DEFAULT_CHARSET_PROPERTY</code> will override any charset in the value of <code class="literal">InputPart.DEFAULT_CONTENT_TYPE_PROPERTY</code>.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="resteasy_multipart_client"/>Send Multipart Entity with RESTEasy Client</h3></div></div></div><p>
						In addition to configuring multipart providers, you can also configure the RESTEasy client to send multipart data.
					</p><h5><a id="using_resteasy_client_classes_2"/>Using RESTEasy Client Classes</h5><p>
						To use RESTEasy client classes in your application, you must add the Maven dependencies to your project’s POM file.
					</p><div class="title"><strong>Example: Maven Dependencies</strong></div><p>
							
</p><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
  &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
  &lt;version&gt;${version.org.jboss.resteasy}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
  &lt;artifactId&gt;resteasy-multipart-provider&lt;/artifactId&gt;
  &lt;version&gt;${version.org.jboss.resteasy}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre><p>

						</p><h5><a id="sending_multipart_data_using_the_resteasy_client"/>Sending Multipart Data Using the RESTEasy Client</h5><p>
						To send multipart data, you first need to configure a <a class="link" href="developing_jax_rs_web_services.html#JAX-RS_client_api" title="JAX-RS Client API">RESTEasy Client</a> and construct a <code class="literal">org.jboss.resteasy.plugins.providers.multipart.MultipartFormDataOutput</code> object to contain your multipart data. You can then use the client to send that <code class="literal">MultipartFormDataOutput</code> object as a <code class="literal">javax.ws.rs.core.GenericEntity</code>.
					</p><div class="title"><strong>Example: RESTEasy Client</strong></div><p>
							
</p><pre class="programlisting">ResteasyClient client = new ResteasyClientBuilder().build();
ResteasyWebTarget target = client.target("http://foo.com/resource");

MultipartFormDataOutput formOutputData = new MultipartFormDataOutput();
formOutputData.addFormData("part1", "this is part 1", MediaType.TEXT_PLAIN);
formOutputData.addFormData("part2", "this is part 2", MediaType.TEXT_PLAIN);

GenericEntity&lt;MultipartFormDataOutput&gt; data = new GenericEntity&lt;MultipartFormDataOutput&gt;(formOutputData) { };

Response response = target.request().put(Entity.entity(data, MediaType.MULTIPART_FORM_DATA_TYPE));

response.close();</pre><p>

						</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_atom_support"/>RESTEasy Atom Support</h2></div></div></div><p>
					The RESTEasy Atom API and Provider is a simple object model that RESTEasy defines to represent Atom. The main classes for the API are in the <code class="literal">org.jboss.resteasy.plugins.providers.atom</code> package. RESTEasy uses JAXB to marshal and unmarshal the API. The provider is JAXB based, and is not limited to sending Atom objects using XML. All JAXB providers that RESTEasy has can be reused by the Atom API and provider, including JSON.
				</p><pre class="programlisting">import org.jboss.resteasy.plugins.providers.atom.Content;
import org.jboss.resteasy.plugins.providers.atom.Entry;
import org.jboss.resteasy.plugins.providers.atom.Feed;
import org.jboss.resteasy.plugins.providers.atom.Link;
import org.jboss.resteasy.plugins.providers.atom.Person;

@Path("atom")
public class MyAtomService {

   @GET
   @Path("feed")
   @Produces("application/atom+xml")
   public Feed getFeed() throws URISyntaxException {
      Feed feed = new Feed();
      feed.setId(new URI("http://example.com/42"));
      feed.setTitle("My Feed");
      feed.setUpdated(new Date());
      Link link = new Link();
      link.setHref(new URI("http://localhost"));
      link.setRel("edit");
      feed.getLinks().add(link);
      feed.getAuthors().add(new Person("John Brown"));
      Entry entry = new Entry();
      entry.setTitle("Hello World");
      Content content = new Content();
      content.setType(MediaType.TEXT_HTML_TYPE);
      content.setText("Nothing much");
      entry.setContent(content);
      feed.getEntries().add(entry);
      return feed;
   }
}</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using_jaxb_with_atom_provider"/>Using JAXB with Atom Provider</h3></div></div></div><p>
						The <code class="literal">org.jboss.resteasy.plugins.providers.atom.Content</code> class allows you to unmarshal and marshal JAXB annotated objects that are the body of the content.
					</p><div class="title"><strong>Example: Entry with a Customer</strong></div><p>
							
</p><pre class="programlisting">@XmlRootElement(namespace = "http://jboss.org/Customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer {
   @XmlElement
   private String name;

   public Customer() {
   }

   public Customer(String name) {
      this.name = name;
   }

   public String getName() {
      return name;
   }
}

@Path("atom")
public static class AtomServer {
   @GET
   @Path("entry")
   @Produces("application/atom+xml")
   public Entry getEntry() {
      Entry entry = new Entry();
      entry.setTitle("Hello World");
      Content content = new Content();
      content.setJAXBObject(new Customer("bill"));
      entry.setContent(content);
      return entry;
   }
}</pre><p>

						</p><p>
						The <code class="literal">Content.setJAXBObject()</code> method lets you specify the content object you send to JAXB to marshal appropriately. If you are using a different base format other than XML, that is <code class="literal">application/atom+json</code>, the attached JAXB object is marshalled in the same format. If you have an Atom document as input, you can also extract JAXB objects from <code class="literal">Content</code> using the <code class="literal">Content.getJAXBObject(Class clazz)</code> method.
					</p><div class="title"><strong>Example: Atom Document Extracting a Customer Object</strong></div><p>
							
</p><pre class="programlisting">@Path("atom")
public static class AtomServer {
   @PUT
   @Path("entry")
   @Produces("application/atom+xml")
   public void putCustomer(Entry entry) {
      Content content = entry.getContent();
      Customer cust = content.getJAXBObject(Customer.class);
   }
}</pre><p>

						</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jaxrs_yaml_provider"/>YAML Provider</h2></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						The <code class="literal">resteasy-yaml-provider</code> module is not supported. Its use is not recommended due to a security issue in the <code class="literal">SnakeYAML</code> library used by RESTEasy for unmarshalling.
					</p></div><p>
					RESTEasy comes with built in support for YAML using the <code class="literal">SnakeYAML</code> library.
				</p><p>
					In releases prior to JBoss EAP 7.1, the YAML provider setting was enabled by default and you only needed to configure the Maven dependencies for YAML to use it in your application. Starting with JBoss EAP 7.1, the YAML provider is disabled by default and must be explicitly enabled in the application.
				</p><h4><a id="jaxrs_yaml_provider_enablement"/>Enable the YAML Provider</h4><p>
					To enable the YAML provider in your application, follow these steps:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							Create or update a file named <code class="literal">javax.ws.rs.ext.Providers</code>.
						</li><li class="listitem"><p class="simpara">
							Add the following content to the file.
						</p><pre class="screen">org.jboss.resteasy.plugins.providers.YamlProvider</pre></li><li class="listitem">
							Place the file in the <code class="literal">META-INF/services/</code> folder of your WAR or JAR file.
						</li></ol></div><h4><a id="jaxrs_yaml_provider_maven_dependencies"/>YAML Provider Maven Dependencies</h4><p>
					To use the YAML provider in your application, you must add the <code class="literal">snakeyaml</code> JAR dependencies to the project POM file of your application.
				</p><div class="title"><strong>Example: Maven Dependencies for YAML</strong></div><p>
						
</p><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-yaml-provider&lt;/artifactId&gt;
    &lt;version&gt;${version.org.jboss.resteasy}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.yaml&lt;/groupId&gt;
    &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;
    &lt;version&gt;${version.org.yaml.snakeyaml}&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

					</p><h4><a id="jaxrs_yaml_provider_example"/>YAML Provider Code Example</h4><p>
					The YAML provider recognizes three mime types:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							text/x-yaml
						</li><li class="listitem">
							text/yaml
						</li><li class="listitem">
							application/x-yaml
						</li></ul></div><p>
					The following is an example of how to use YAML in a resource method.
				</p><div class="title"><strong>Example: Resource Producing YAML</strong></div><p>
						
</p><pre class="programlisting">import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

@Path("/yaml")
public class YamlResource {

  @GET
  @Produces("text/x-yaml")
  public MyObject getMyObject() {
    return createMyObject();
  }
...
}</pre><p>

					</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jaxrs_json_p"/>Using the JSON API for JSON Processing (JSON-P)</h1></div></div></div><p>
				The JSON API for JSON Processing (JSON-P) was introduced in the Java EE 7 specification, which is defined in <a class="link" href="https://jcp.org/en/jsr/detail?id=353">JSR 353</a>. Additional specifications are defined in <a class="link" href="https://jcp.org/en/jsr/detail?id=374">JSR 374</a> for Java EE 8.
			</p><p>
				JSON-P defines an API to process JSON. JBoss EAP has support for <code class="literal">javax.json.JsonObject</code>, <code class="literal">javax.json.JsonArray</code>, and <code class="literal">javax.json.JsonStructure</code> as request or response entities.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					The JSON API for JSON Processing (JSON-P) is different from JSON with Padding (JSONP).
				</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					JSON-P will not conflict with Jackson if they are on the same classpath.
				</p></div><p>
				To create a <code class="literal">JsonObject</code>, use the <code class="literal">JsonObjectBuilder</code> by calling <code class="literal">Json.createObjectBuilder()</code> and building the JSON object.
			</p><div class="title"><strong>Example: Create <code class="literal">javax.json.JsonObject</code></strong></div><p>
					
</p><pre class="programlisting">JsonObject obj = Json.createObjectBuilder().add("name", "Bill").build();</pre><p>

				</p><div class="title"><strong>Example: Corresponding JSON for <code class="literal">javax.json.JsonObject</code></strong></div><p>
					
</p><pre class="screen">{
  "name":"Bill"
}</pre><p>

				</p><p>
				To create a <code class="literal">JsonArray</code>, use the <code class="literal">JsonArrayBuilder</code> by calling <code class="literal">Json.createArrayBuilder()</code> and building the JSON array.
			</p><div class="title"><strong>Example: Create <code class="literal">javax.json.JsonArray</code></strong></div><p>
					
</p><pre class="programlisting">JsonArray array =
  Json.createArrayBuilder()
    .add(Json.createObjectBuilder().add("name", "Bill").build())
    .add(Json.createObjectBuilder().add("name", "Monica").build()).build();</pre><p>

				</p><div class="title"><strong>Example: Corresponding JSON for <code class="literal">javax.json.JsonArray</code></strong></div><p>
					
</p><pre class="screen">[
  {
  "name":"Bill"
  },
  {
  "name":"Monica"
  }
]</pre><p>

				</p><p>
				<code class="literal">JsonStructure</code> is a parent class of <code class="literal">JsonObject</code> and <code class="literal">JsonArray</code>.
			</p><div class="title"><strong>Example: Create <code class="literal">javax.json.JsonStructure</code></strong></div><p>
					
</p><pre class="programlisting">JsonObject obj = Json.createObjectBuilder().add("name", "Bill").build();

JsonArray array =
  Json.createArrayBuilder()
    .add(Json.createObjectBuilder().add("name", "Bill").build())
    .add(Json.createObjectBuilder().add("name", "Monica").build()).build();

JsonStructure sObj = (JsonStructure) obj;
JsonStructure sArray = (JsonStructure) array;</pre><p>

				</p><p>
				You can use <code class="literal">JsonObject</code>, <code class="literal">JsonArray</code>, and <code class="literal">JsonStructure</code> directly in JAX-RS resources.
			</p><div class="title"><strong>Example: JAX-RS Resources with JSON-P</strong></div><p>
					
</p><pre class="programlisting">@Path("object")
@POST
@Produces("application/json")
@Consumes("application/json")
public JsonObject object(JsonObject obj) {
  // do something
  return obj;
 }

@Path("array")
@POST
@Produces("application/json")
@Consumes("application/json")
public JsonArray array(JsonArray array) {
  // do something
  return array;
}

@Path("structure")
@POST
@Produces("application/json")
@Consumes("application/json")
public JsonStructure structure(JsonStructure structure) {
  // do something
  return structure;
}</pre><p>

				</p><p>
				You can also use JSON-P from a client to send JSON.
			</p><div class="title"><strong>Example: Client Using JSON-P</strong></div><p>
					
</p><pre class="programlisting">WebTarget target = client.target(...);
JsonObject obj = Json.createObjectBuilder().add("name", "Bill").build();
JsonObject newObj = target.request().post(Entity.json(obj), JsonObject.class);</pre><p>

				</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ejb_integration"/>RESTEasy/EJB Integration</h1></div></div></div><p>
				To integrate RESTEasy with EJB, add JAX-RS annotations to the EJB classes that you want to expose as JAX-RS endpoints. You can also apply the annotations on the bean’s business interface. There are two ways to activate the beans as endpoints:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Using the <code class="literal">web.xml</code> file.
					</li><li class="listitem">
						Using <code class="literal">javax.ws.rs.core.Application</code>.
					</li></ul></div><p>
				To make an EJB function as a JAX-RS resource, annotate a stateless session bean’s <code class="literal">@Remote</code> or <code class="literal">@Local</code> interface with JAX-RS annotations:
			</p><pre class="programlisting">@Local
@Path("/Library")
public interface Library {
   @GET
   @Path("/books/{isbn}")
   public String getBook(@PathParam("isbn") String isbn);
}
@Stateless
public class LibraryBean implements Library {
...
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					Note that the <code class="literal">Library</code> interface is referenced by fully qualified name, whereas <code class="literal">LibraryBean</code> is referenced only by the simple class name.
				</p></div><p>
				Then, manually register the EJB with RESTEasy using the <code class="literal">resteasy.jndi.resources</code> context parameter in the RESTEasy <code class="literal">web.xml</code> file:
			</p><pre class="programlisting">&lt;web-app&gt;
   &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.jndi.resources&lt;/param-name&gt;
      &lt;param-value&gt;java:module/LibraryBean!org.app.Library&lt;/param-value&gt;
   &lt;/context-param&gt;
   &lt;listener&gt;
      &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
   &lt;/listener&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>
				You can also specify multiple JNDI names of EJBs, separated by commas, for the <code class="literal">resteasy.jndi.resources</code> context parameter.
			</p><p>
				An alternate Java EE-standard way to activate EJBs as RESTEasy endpoints is by using <code class="literal">javax.ws.rs.core.Application</code>. This is achieved by including the EJB implementation class into the set returned by the application’s <code class="literal">getClasses()</code> method. This approach does not need anything to be specified in the <code class="literal">web.xml</code> file.
			</p><p>
				See the <code class="literal">kitchensink</code>, <code class="literal">helloworld-html5</code>, and <code class="literal">managed-executor-service</code> quickstarts that ship with JBoss EAP for working examples that demonstrate RESTEasy integration with EJBs.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="spring_integration"/>Spring Integration</h1></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
					Your application must have an existing JAX-WS service and client configuration.
				</p></div><p>
				RESTEasy integrates with Spring 4.2.x.
			</p><p>
				Maven users must use the <code class="literal">resteasy-spring</code> artifact. Alternatively, the JAR is available as a module in JBoss EAP.
			</p><p>
				RESTEasy comes with its own Spring <code class="literal">ContextLoaderListener</code> that registers a RESTEasy specific <code class="literal">BeanPostProcessor</code> that processes JAX-RS annotations when a bean is created by a <code class="literal">BeanFactory</code>. This means that RESTEasy automatically scans for <code class="literal">@Provider</code> and JAX-RS resource annotations on your bean class and registers them as JAX-RS resources.
			</p><p>
				Add the following to your <code class="literal">web.xml</code> file to enable the RESTEasy/Spring integration functionality:
			</p><pre class="programlisting">&lt;web-app&gt;
  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>
				The <code class="literal">SpringContextLoaderListener</code> must be declared after <code class="literal">ResteasyBootstrap</code> as it uses <code class="literal">ServletContext</code> attributes initialized by it.
			</p><p>
				See the <code class="literal">spring-resteasy</code> quickstart that ships with JBoss EAP for a working example of a web application that demonstrates RESTEasy integration with Spring.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="cdi_integration"/>CDI Integration</h1></div></div></div><p>
				Integration between RESTEasy and CDI is provided by the <code class="literal">resteasy-cdi</code> module.
			</p><p>
				Both the JAX-RS and CDI specifications introduce their own component models. Every class placed in a CDI archive, which fulfills a set of basic constraints, is implicitly a CDI bean. Explicit declaration of your Java class with <code class="literal">@Path</code> or <code class="literal">@Provider</code> is required for it to become a JAX-RS component. Without the integration code, annotating a class suitable for being a CDI bean with JAX-RS annotations gives a faulty result and the JAX-RS component is not managed by the CDI. The <code class="literal">resteasy-cdi</code> module is a bridge that allows RESTEasy to work with class instances obtained from the CDI container.
			</p><p>
				During a web service invocation, the <code class="literal">resteasy-cdi</code> module asks the CDI container for the managed instance of a JAX-RS component. Then, this instance is passed to RESTEasy. If a managed instance is not available for some reason, such as the class being placed in a JAR file that is not a bean deployment archive, RESTEasy falls back to instantiating the class itself.
			</p><p>
				As a result, CDI services like injection, lifecycle management, events, decoration, and interceptor bindings can be used in JAX-RS components.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="default_scope"/>Default Scope</h2></div></div></div><p>
					A CDI bean that does not explicitly define a scope is <code class="literal">@Dependent</code> scoped by default. This pseudo-scope means that the bean adapts to the lifecycle of the bean that it is injected into. Normal scopes, including request, session, and application, are more suitable for JAX-RS components as they designate the component’s lifecycle boundaries explicitly. Therefore, the <code class="literal">resteasy-cdi</code> module alters the default scoping in the following way:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							If a JAX-RS root resource does not define a scope explicitly, it is bound to the request scope.
						</li><li class="listitem">
							If a JAX-RS provider or <code class="literal">javax.ws.rs.Application</code> subclass does not define a scope explicitly, it is bound to the application scope.
						</li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Since the scope of all beans that do not declare a scope is modified by the <code class="literal">resteasy-cdi</code> module, this affects session beans as well. As a result, a conflict occurs if the scope of a stateless session bean or singleton is changed automatically as the specification prohibits these components to be <code class="literal">@RequestScoped</code>. Therefore, you need to explicitly define a scope when using stateless session beans or singletons. This requirement is likely to be removed in future releases.
					</p></div><p>
					The <code class="literal">resteasy-cdi</code> module is bundled with JBoss EAP. Therefore, there is no need to download the module separately or add any additional configuration. See the <code class="literal">kitchensink</code> quickstart that ships with JBoss EAP for a working example of using CDI beans with a JAX-RS resource.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="resteasy_filters_interceptors"/>RESTEasy Filters and Interceptors</h1></div></div></div><p>
				JAX-RS has two different concepts for interceptions: filters and interceptors. Filters are mainly used to modify or process incoming and outgoing request headers or response headers. They execute before and after request and response processing.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_server_filters"/>Server-side Filters</h2></div></div></div><p>
					On the server side, you have two different types of filters: <code class="literal">ContainerRequestFilters</code> and <code class="literal">ContainerResponseFilters</code>. <code class="literal">ContainerRequestFilters</code> run before your JAX-RS resource method is invoked. <code class="literal">ContainerResponseFilters</code> run after your JAX-RS resource method is invoked.
				</p><p>
					In addition, there are two types of <code class="literal">ContainerRequestFilters</code>: pre-matching and post-matching. Pre-matching <code class="literal">ContainerRequestFilters</code> are designated with the <code class="literal">@PreMatching</code> annotation and execute before the JAX-RS resource method is matched with the incoming HTTP request. Post-matching <code class="literal">ContainerRequestFilters</code> are designated with the <code class="literal">@PostMatching</code> annotation and execute after the JAX-RS resource method is matched with the incoming HTTP request.
				</p><p>
					Pre-matching filters often are used to modify request attributes to change how it matches to a specific resource method, for example to strip <code class="literal">.xml</code> and add an <code class="literal">Accept</code> header. <code class="literal">ContainerRequestFilters</code> can abort the request by calling <code class="literal">ContainerRequestContext.abortWith(Response)</code>. For example, a filter might want to abort if it implements a custom authentication protocol.
				</p><p>
					After the resource class method is executed, JAX-RS runs all <code class="literal">ContainerResponseFilters</code>. These filters allow you to modify the outgoing response before it is marshalled and sent to the client.
				</p><div class="title"><strong>Example: Request Filter</strong></div><p>
						
</p><pre class="programlisting">public class RoleBasedSecurityFilter implements ContainerRequestFilter {
  protected String[] rolesAllowed;
  protected boolean denyAll;
  protected boolean permitAll;

  public RoleBasedSecurityFilter(String[] rolesAllowed, boolean denyAll, boolean permitAll) {
    this.rolesAllowed = rolesAllowed;
    this.denyAll = denyAll;
    this.permitAll = permitAll;
  }

  @Override
  public void filter(ContainerRequestContext requestContext) throws IOException  {
    if (denyAll) {
       requestContext.abortWith(Response.status(403).entity("Access forbidden: role not allowed").build());
       return;
    }
    if (permitAll) return;
    if (rolesAllowed != null) {
       SecurityContext context = ResteasyProviderFactory.getContextData(SecurityContext.class);
       if (context != null) {
          for (String role : rolesAllowed) {
             if (context.isUserInRole(role)) return;
          }
          requestContext.abortWith(Response.status(403).entity("Access forbidden: role not allowed").build());
          return;
       }
    }
    return;
  }
}</pre><p>

					</p><div class="title"><strong>Example: Response Filter</strong></div><p>
						
</p><pre class="programlisting">public class CacheControlFilter implements ContainerResponseFilter {
   private int maxAge;

   public CacheControlFilter(int maxAge) {
      this.maxAge = maxAge;
   }

   public void filter(ContainerRequestContext req, ContainerResponseContext res)
           throws IOException {
      if (req.getMethod().equals("GET")) {
         CacheControl cc = new CacheControl();
         cc.setMaxAge(this.maxAge);
         res.getHeaders().add("Cache-Control", cc);
      }
   }
}</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_client_filters"/>Client-side Filters</h2></div></div></div><p>
					More information on client-side filters can be found in the <a class="link" href="developing_jax_rs_web_services.html#JAX-RS_client_api" title="JAX-RS Client API">JAX-RS Client API</a> section of this guide.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_interceptors"/>RESTEasy Interceptors</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="intercept_jax_rs_invocations"/>Intercept JAX-RS Invocations</h3></div></div></div><p>
						RESTEasy can intercept JAX-RS invocations and route them through listener-like objects called interceptors.
					</p><p>
						While filters modify request or response headers, interceptors deal with message bodies. Interceptors are executed in the same call stack as their corresponding reader or writer. <code class="literal">ReaderInterceptors</code> wrap around the execution of <code class="literal">MessageBodyReaders</code>. <code class="literal">WriterInterceptors</code> wrap around the execution of <code class="literal">MessageBodyWriters</code>. They can be used to implement a specific content-encoding. They can be used to generate digital signatures or to post or pre-process a Java object model before or after it is marshalled.
					</p><p>
						<code class="literal">ReaderInterceptors</code> and <code class="literal">WriterInterceptors</code> can be used on either the server or client side. They are annotated with <code class="literal">@Provider</code>, as well as either <code class="literal">@ServerInterceptor</code> or <code class="literal">@ClientInterceptor</code> so that RESTEasy knows whether or not to add them to the interceptor list.
					</p><p>
						These interceptors wrap around the invocation of <code class="literal">MessageBodyReader.readFrom()</code> or <code class="literal">MessageBodyWriter.writeTo()</code>. They can be used to wrap the <code class="literal">Output</code> or <code class="literal">Input</code> streams.
					</p><div class="title"><strong>Example: Interceptor</strong></div><p>
							
</p><pre class="programlisting">@Provider
public class BookReaderInterceptor implements ReaderInterceptor {
    @Inject private Logger log;
    @Override
    @ReaderInterceptorBinding
    public Object aroundReadFrom(ReaderInterceptorContext context) throws IOException, WebApplicationException {
        log.info("*** Intercepting call in BookReaderInterceptor.aroundReadFrom()");
        VisitList.add(this);
        Object result = context.proceed();
        log.info("*** Back from intercepting call in BookReaderInterceptor.aroundReadFrom()"); return result;
    }
}</pre><p>

						</p><p>
						The interceptors and the <code class="literal">MessageBodyReader</code> or <code class="literal">Writer</code> are invoked in one big Java call stack. <code class="literal">ReaderInterceptorContext.proceed()</code> or <code class="literal">WriterInterceptorContext.proceed()</code> are called in order to go to the next interceptor or, if there are no more interceptors to invoke, the <code class="literal">readFrom()</code> or <code class="literal">writeTo()</code> method of the <code class="literal">MessageBodyReader</code> or <code class="literal">MessageBodyWriter</code>. This wrapping allows objects to be modified before they get to the <code class="literal">Reader</code> or <code class="literal">Writer</code>, and then cleaned up after <code class="literal">proceed()</code> returns.
					</p><p>
						The example below is a server-side interceptor that adds a header value to the response.
					</p><pre class="programlisting">@Provider
public class BookWriterInterceptor implements WriterInterceptor {
   @Inject private Logger log;

   @Override
   @WriterInterceptorBinding
   public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {
      log.info("*** Intercepting call in BookWriterInterceptor.aroundWriteTo()");
      VisitList.add(this);
      context.proceed();
      log.info("*** Back from intercepting call in BookWriterInterceptor.aroundWriteTo()");
   }
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="registering_an_interceptor"/>Registering an Interceptor</h3></div></div></div><p>
						To register a RESTEasy JAX-RS interceptor in an application, list it in the <code class="literal">web.xml</code> file under the <code class="literal">resteasy.providers</code> parameter in the <code class="literal">context-param</code> element, or return it as a class or as an object in the <code class="literal">Application.getClasses()</code> or <code class="literal">Application.getSingletons()</code> method.
					</p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;resteasy.providers&lt;/param-name&gt;
    &lt;param-value&gt;my.app.CustomInterceptor&lt;/paramvalue&gt;
&lt;/context-param&gt;</pre><pre class="programlisting">package org.jboss.resteasy.example;

import javax.ws.rs.core.Application;
import java.util.HashSet;
import java.util.Set;

public class MyApp extends Application {

  public java.util.Set&lt;java.lang.Class&lt;?&gt;&gt; getClasses() {
    Set&lt;Class&lt;?&gt;&gt; resources = new HashSet&lt;Class&lt;?&gt;&gt;();
    resources.add(MyResource.class);
    resources.add(MyProvider.class);
    return resources;
  }
}</pre><pre class="programlisting">package org.jboss.resteasy.example;

import javax.ws.rs.core.Application;
import java.util.HashSet;
import java.util.Set;

public class MyApp extends Application {

    protected Set&lt;Object&gt; singletons = new HashSet&lt;Object&gt;();

    public MyApp() {
        singletons.add(new MyResource());
        singletons.add(new MyProvider());
    }

    @Override
    public Set&lt;Object&gt; getSingletons() {
        return singletons;
    }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_gzip_compression_decompression"/>GZIP Compression and Decompression</h2></div></div></div><p>
					RESTEasy supports GZIP compression and decompression. To support GZIP decompression, the client framework or a JAX-RS service automatically decompresses a message body with a <code class="literal">Content-Encoding</code> of <code class="literal">gzip</code>, and it can automatically set the <code class="literal">Accept-Encoding</code> header to <code class="literal">gzip, deflate</code> so that you do not have to set this header manually. To support GZIP compression, RESTEasy compresses the outgoing message if the client framework is sending a request or if the server is sending a response with the <code class="literal">Content-Encoding</code> header set to <code class="literal">gzip</code>. You can use the <code class="literal">@org.jboss.resteasy.annotation.GZIP</code> annotation to set the <code class="literal">Content-Encoding</code> header.
				</p><p>
					The following example tags the outgoing message body <code class="literal">order</code> to be gzip compressed.
				</p><div class="title"><strong>Example: GZIP Compression</strong></div><p>
						
</p><pre class="programlisting">@Path("/")
public interface MyProxy {

   @Consumes("application/xml")
   @PUT
   public void put(@GZIP Order order);
}</pre><p>

					</p><div class="title"><strong>Example: GZIP Compression Tagging Server Responses</strong></div><p>
						
</p><pre class="programlisting">@Path("/")
public class MyService {

   @GET
   @Produces("application/xml")
   @GZIP
   public String getData() {...}
}</pre><p>

					</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="configuring_gzip_compression_and_decompression"/>Configuring GZIP Compression and Decompression</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							RESTEasy disables GZIP compression and decompression by default in order to prevent decompression of an entity that might be huge in size but has been compressed by an attacker and sent to the server.
						</p></div><p>
						There are three interceptors that are relevant to GZIP compression and decompression:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">org.jboss.resteasy.plugins.interceptors.GZIPDecodingInterceptor</code>: If the <code class="literal">Content-Encoding</code> header is present and has the value <code class="literal">gzip</code>, <code class="literal">GZIPDecodingInterceptor</code> installs an <code class="literal">InputStream</code> that decompresses the message body.
							</li><li class="listitem">
								<code class="literal">org.jboss.resteasy.plugins.interceptors.GZIPEncodingInterceptor</code>: If the <code class="literal">Content-Encoding</code> header is present and has the value <code class="literal">gzip</code>, <code class="literal">GZIPEncodingInterceptor</code> installs an <code class="literal">OutputStream</code> that compresses the message body.
							</li><li class="listitem"><p class="simpara">
								<code class="literal">org.jboss.resteasy.plugins.interceptors.AcceptEncodingGZIPFilter</code>: If the <code class="literal">Accept-Encoding</code> header does not exist, <code class="literal">AcceptEncodingGZIPFilter</code> adds <code class="literal">Accept-Encoding</code> header with the value <code class="literal">gzip, deflate</code>. If the <code class="literal">Accept-Encoding</code> header exists but does not contain <code class="literal">gzip</code>, <code class="literal">AcceptEncodingGZIPFilter</code> interceptor appends the value <code class="literal">, gzip</code>.
							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
									Enabling GZIP compression or decompression does not depend on the presence of the <code class="literal">AcceptEncodingGZIPFilter</code> interceptor.
								</p></div></li></ul></div><p>
						Enabling GZIP decompression sets an upper limit on the number of bytes the <code class="literal">GZIPDecodingInterceptor</code> can extract from the compressed message body. The default limit is <code class="literal">10,000,000</code>.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="reasteasy_gzip_server_side_configuration"/>Server-side GZIP Configuration</h3></div></div></div><p>
						You can enable the interceptors by including their class names in the <code class="literal">javax.ws.rs.ext.Providers</code> file on the class path. The upper limit on deflated files is set using the web application context parameter <code class="literal">resteasy.gzip.max.input</code>. If this limit is exceeded on the server side, <code class="literal">GZIPDecodingInterceptor</code> returns a response with status <code class="literal">413 - Request Entity Too Large</code> and a message specifying the upper limit.
					</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="resteasy_gzip_client_side_configuration"/>Client-side GZIP Configuration</h4></div></div></div><p>
							You can enable the GZIP interceptors by registering them with, for example, a <code class="literal">Client</code> or <code class="literal">WebTarget</code>. For example:
						</p><pre class="screen">Client client = new ResteasyClientBuilder() // Activate gzip compression on client:
    .register(AcceptEncodingGZIPFilter.class)
    .register(GZIPDecodingInterceptor.class)
    .register(GZIPEncodingInterceptor.class)
    .build();</pre><p>
							You can configure the upper limit on deflated files by creating an instance of <code class="literal">GZIPDecodingInterceptor</code> with a specific value:
						</p><pre class="screen">Client client = new ResteasyClientBuilder() // Activate gzip compression on client:
    .register(AcceptEncodingGZIPFilter.class)
    .register(new GZIPDecodingInterceptor(256))
    .register(GZIPEncodingInterceptor.class)
    .build();</pre><p>
							If the upper limit is exceeded on the client side, <code class="literal">GZIPDecodingInterceptor</code> throws a <code class="literal">ProcessingException</code> with a message specifying the upper limit.
						</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_per_resource_filters_interceptors"/>Per-Resource Method Filters and Interceptors</h2></div></div></div><p>
					Sometimes you want a filter or interceptor to only run for a specific resource method. You can do this in two different ways:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<a class="link" href="developing_jax_rs_web_services.html#implement_dynamicfeature_interface" title="Implement the DynamicFeature Interface">Implement the <code class="literal">DynamicFeature</code> interface</a>.
						</li><li class="listitem">
							<a class="link" href="developing_jax_rs_web_services.html#use_namebinding_annotation" title="Use the @NameBinding Annotation">Use the <code class="literal">@NameBinding</code> annotation</a>.
						</li></ul></div><h4><a id="implement_dynamicfeature_interface"/>Implement the <code class="literal">DynamicFeature</code> Interface</h4><p>
					The <code class="literal">DynamicFeature</code> interface includes a callback method, <code class="literal">configure(ResourceInfo resourceInfo, FeatureContext context)</code>, which is invoked for each and every deployed JAX-RS method. The <code class="literal">ResourceInfo</code> parameter contains information about the current JAX-RS method being deployed. <code class="literal">FeatureContext</code> is an extension of the <code class="literal">Configurable</code> interface. You can use the <code class="literal">register()</code> method of this parameter to bind the filters and interceptors that you want to assign to this method.
				</p><div class="title"><strong>Example: Using the DynamicFeature Interface</strong></div><p>
						
</p><pre class="programlisting">@Provider
public class AnimalTypeFeature implements DynamicFeature {
    @Override
    public void configure(ResourceInfo info, FeatureContext context) {
        if (info.getResourceMethod().getAnnotation(GET.class) != null)
            AnimalFilter filter = new AnimalFilter();
            context.register(filter);
        }
    }
}</pre><p>

					</p><p>
					In the example above, the provider that you register using <code class="literal">AnimalTypeFeature</code> must implement one of the interfaces. This example registers the provider <code class="literal">AnimalFilter</code> that must implement one of the following interfaces: <code class="literal">ContainerRequestFilter</code>, <code class="literal">ContainerResponseFilter</code>, <code class="literal">ReaderInterceptor</code>, <code class="literal">WriterInterceptor</code>, or <code class="literal">Feature</code>. In this case <code class="literal">AnimalFilter</code> will be applied to all resource methods annotated with GET annotation. See <a class="link" href="https://docs.oracle.com/javaee/7/api/javax/ws/rs/container/DynamicFeature.html">DynamicFeature Documentation</a> for details.
				</p><h4><a id="use_namebinding_annotation"/>Use the @NameBinding Annotation</h4><p>
					<code class="literal">@NameBinding</code> works a lot like CDI interceptors. You annotate a custom annotation with <code class="literal">@NameBinding</code> and then apply that custom annotation to your filter and resource method.
				</p><div class="title"><strong>Example: Using @NameBinding</strong></div><p>
						
</p><pre class="programlisting">@NameBinding
public @interface DoIt {}

@DoIt
public class MyFilter implements ContainerRequestFilter {...}

@Path("/root")
public class MyResource {

   @GET
   @DoIt
   public String get() {...}
}</pre><p>

					</p><p>
					See <a class="link" href="https://docs.oracle.com/javaee/7/api/javax/ws/rs/NameBinding.html">NameBinding Documentation</a> for details.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_ordering_filters_interceptors"/>Ordering</h2></div></div></div><p>
					Ordering is accomplished by using the <a class="link" href="http://docs.oracle.com/javaee/7/api/javax/annotation/Priority.html"><code class="literal">@Priority</code></a> annotation on your filter or interceptor class.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_exceptions_filters_interceptors"/>Exception Handling with Filters and Interceptors</h2></div></div></div><p>
					Exceptions associated with filters or interceptors can occur on either the client side or the server side. On the client side, there are two types of exceptions you will have to handle: <code class="literal">javax.ws.rs.client.ProcessingException</code> and <code class="literal">javax.ws.rs.client.ResponseProcessingException</code>. A <code class="literal">javax.ws.rs.client.ProcessingException</code> will be thrown on the client side if there was an error before a request is sent to the server. A <code class="literal">javax.ws.rs.client.ResponseProcessingException</code> will be thrown on the client side if there was an error in processing the response received by the client from the server.
				</p><p>
					On the server side, exceptions thrown by filters or interceptors are handled in the same way as other exceptions thrown from JAX-RS methods, which tries to find an <code class="literal">ExceptionMapper</code> for the exception being thrown. More details on how exceptions are handled in JAX-RS methods can be found in the <a class="link" href="developing_jax_rs_web_services.html#resteasy_exceptions" title="Exception Handling">Exception Handling</a> section.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="logging_resteasy_providers_interceptors"/>Logging RESTEasy Providers and Interceptors</h1></div></div></div><p>
				RESTEasy logs the used providers and interceptors in the <code class="literal">DEBUG</code> level of logging. You can use the following management CLI commands to enable all the log levels related to RESTEasy:
			</p><pre class="screen">/subsystem=logging/console-handler=CONSOLE:write-attribute(name=level,value=ALL)

/subsystem=logging/logger=org.jboss.resteasy:add(level=ALL)

/subsystem=logging/logger=javax.xml.bind:add(level=ALL)

/subsystem=logging/logger=com.fasterxml.jackson:add(level=ALL)</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="resteasy_exceptions"/>Exception Handling</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="creating_an_exception_mapper"/>Creating an Exception Mapper</h2></div></div></div><p>
					Exception mappers are custom components provided by applications that catch thrown exceptions and write specific HTTP responses.
				</p><p>
					When you create an exception mapper, you create a class that is annotated with the <code class="literal">@Provider</code> annotation and implements the <code class="literal">ExceptionMapper</code> interface.
				</p><p>
					An example exception mapper is provided below:
				</p><pre class="programlisting">@Provider
public class EJBExceptionMapper implements ExceptionMapper&lt;javax.ejb.EJBException&gt; {
  public Response toResponse(EJBException exception) {
    return Response.status(500).build();
  }
}</pre><p>
					To register an exception mapper, list it in the <code class="literal">web.xml</code> file, under the <code class="literal">resteasy.providers</code> <code class="literal">context-param</code>, or register it programmatically through the <code class="literal">ResteasyProviderFactory</code> class.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="managing_internally_thrown_exceptions"/>Managing Internally Thrown Exceptions</h2></div></div></div><div class="table"><a id="idm140182251145680"/><p class="title"><strong>Table 2.2. Exception List</strong></p><div class="table-contents"><table summary="Exception List" border="1"><colgroup><col class="col_1"/><col class="col_2"/><col class="col_3"/></colgroup><thead><tr><th style="text-align: left" valign="top">Exception</th><th style="text-align: left" valign="top">HTTP Code</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									BadRequestException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									400
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Bad Request. The request was not formatted correctly, or there was a problem processing the request input.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									UnauthorizedException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									401
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Unauthorized. Security exception thrown if you are using RESTEasy’s annotation-based role-based security.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									InternalServerErrorException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									500
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Internal Server Error.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									MethodNotAllowedException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									405
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									There is no JAX-RS method for the resource to handle the invoked HTTP operation.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									NotAcceptableException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									406
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									There is no JAX-RS method that can produce the media types listed in the Accept header.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									NotFoundException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									404
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									There is no JAX-RS method that serves the request path/resource.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									ReaderException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									400
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									All exceptions thrown from MessageBodyReaders are wrapped within this exception. If there is no ExceptionMapper for the wrapped exception, or if the exception is not a WebApplicationException, then by default, RESTEasy returns a 400 code.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									WriterException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									500
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									All exceptions thrown from MessageBodyWriters are wrapped within this exception. If there is no ExceptionMapper for the wrapped exception, or if the exception is not a WebApplicationException, then by default, RESTEasy returns a 400 code.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									JAXBUnmarshalException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									400
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The JAXB providers (XML and Jackson) throw this exception on reads which might wrap JAXBExceptions. This class extends ReaderException.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									JAXBMarshalException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									500
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The JAXB providers (XML and Jackson) throw this exception on writes which might wrap JAXBExceptions. This class extends WriterException.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									ApplicationException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									N/A
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Wraps all exceptions thrown from application code, and it functions in the same way as InvocationTargetException. If there is an ExceptionMapper for wrapped exception, then that is used to handle the request.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									Failure
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									N/A
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Internal RESTEasy error. Not logged.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									LoggableFailure
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									N/A
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Internal RESTEasy error. Logged.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									DefaultOptionsMethodException
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									N/A
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									If the user invokes <code class="literal">HTTP OPTIONS</code> and no JAX-RS method for it, RESTEasy provides a default behavior by throwing this exception.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									UnrecognizedPropertyExceptionHandler
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									400
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									RESTEasy Jackson provider throws this exception when JSON data is determined to be invalid.
								</p>
								 </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="Enable_Role-Based_Security_RESTEasy_JAX-RS_Web_Service"/>Securing JAX-RS Web Services</h1></div></div></div><p>
				RESTEasy supports the <code class="literal">@RolesAllowed</code>, <code class="literal">@PermitAll</code>, and <code class="literal">@DenyAll</code> annotations on JAX-RS methods. However, you must enable role-based security in order for these annotations to be recognized.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="enable_rbac_ws"/>Enable Role-Based Security</h2></div></div></div><p>
					Follow these steps to configure the <code class="literal">web.xml</code> file to enable role-based security.
				</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Do not activate role-based security if the application uses EJBs. The EJB container will provide the functionality, instead of RESTEasy.
					</p></div><div class="orderedlist"><p class="title"><strong>Enable Role-Based Security for a RESTEasy JAX-RS Web Service</strong></p><ol class="orderedlist"><li class="listitem">
							Open the <code class="literal">web.xml</code> file for the application in a text editor.
						</li><li class="listitem"><p class="simpara">
							Add the following <code class="literal">&lt;context-param&gt;</code> to the file, within the <code class="literal">&lt;web-app&gt;</code> tags.
						</p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;
  &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</pre></li><li class="listitem"><p class="simpara">
							Declare all roles used within the RESTEasy JAX-RS WAR file, using the <code class="literal">&lt;security-role&gt;</code> tags.
						</p><pre class="programlisting">&lt;security-role&gt;
  &lt;role-name&gt;<span class="emphasis"><em>ROLE_NAME</em></span>&lt;/role-name&gt;
&lt;/security-role&gt;
&lt;security-role&gt;
  &lt;role-name&gt;<span class="emphasis"><em>ROLE_NAME</em></span>&lt;/role-name&gt;
&lt;/security-role&gt;</pre></li><li class="listitem"><p class="simpara">
							Authorize access to all URLs handled by the JAX-RS runtime for all roles.
						</p><pre class="programlisting">&lt;security-constraint&gt;
  &lt;web-resource-collection&gt;
    &lt;web-resource-name&gt;Resteasy&lt;/web-resource-name&gt;
    &lt;url-pattern&gt;<span class="emphasis"><em>/PATH</em></span>&lt;/url-pattern&gt;
  &lt;/web-resource-collection&gt;
  &lt;auth-constraint&gt;
    &lt;role-name&gt;<span class="emphasis"><em>ROLE_NAME</em></span>&lt;/role-name&gt;
    &lt;role-name&gt;<span class="emphasis"><em>ROLE_NAME</em></span>&lt;/role-name&gt;
  &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;</pre></li><li class="listitem"><p class="simpara">
							Define the appropriate login configuration for this application.
						</p><pre class="programlisting">&lt;login-config&gt;
  &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;realm-name&gt;jaxrs&lt;/realm-name&gt;
&lt;/login-config&gt;</pre></li></ol></div><p>
					Role-based security has been enabled within the application, with a set of defined roles.
				</p><div class="title"><strong>Example: Role-Based Security Configuration</strong></div><p>
						
</p><pre class="programlisting">&lt;web-app&gt;

  &lt;context-param&gt;
    &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;Resteasy&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/security&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;admin&lt;/role-name&gt;
      &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;

  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;realm-name&gt;jaxrs&lt;/realm-name&gt;
  &lt;/login-config&gt;

  &lt;security-role&gt;
    &lt;role-name&gt;admin&lt;/role-name&gt;
  &lt;/security-role&gt;
  &lt;security-role&gt;
    &lt;role-name&gt;user&lt;/role-name&gt;
  &lt;/security-role&gt;

&lt;/web-app&gt;</pre><p>

					</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="securing_jax_rs_web_services_using_annotations"/>Securing JAX-RS Web Services Using Annotations</h2></div></div></div><p>
					To secure JAX-RS web services using an annotation, complete the following steps.
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							<a class="link" href="developing_jax_rs_web_services.html#enable_rbac_ws" title="Enable Role-Based Security">Enable role-based security</a>.
						</li><li class="listitem"><p class="simpara">
							Add security annotations to the JAX-RS web service. RESTEasy supports the following annotations:
						</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">@RolesAllowed</code></span></dt><dd>
										Defines which roles can access the method. All roles should be defined in the <code class="literal">web.xml</code> file.
									</dd><dt><span class="term"><code class="literal">@PermitAll</code></span></dt><dd>
										Allows all roles defined in the <code class="literal">web.xml</code> file to access the method.
									</dd><dt><span class="term"><code class="literal">@DenyAll</code></span></dt><dd>
										Denies all access to the method.
									</dd></dl></div></li></ol></div><p>
					Below is an example that uses the <code class="literal">@RolesAllowed</code> annotation to specify that the <code class="literal">admin</code> role can access the web service.
				</p><pre class="programlisting">@RolesAllowed("admin")
@Path("/test")
public class TestService {
  ...
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="setting-programmatic-security"/>Setting Programmatic Security</h2></div></div></div><p>
					JAX-RS includes a programmatic API for gathering security information about a secured request. The <code class="literal">javax.ws.rs.core.SecurityContext</code> interface has a method for determining the identity of the user making the secured HTTP invocation. It also has a method that allows you to check whether or not the current user belongs to a certain role:
				</p><pre class="programlisting">public interface SecurityContext {

   public Principal getUserPrincipal();
   public boolean isUserInRole(String role);
   public boolean isSecure();
   public String getAuthenticationScheme();
}</pre><p>
					You can access a <code class="literal">SecurityContext</code> instance by injecting it into a field, setter method, or resource method parameter using the <code class="literal">@Context</code> annotation.
				</p><pre class="programlisting">@Path("test")
public class SecurityContextResource {
    @Context
    SecurityContext securityContext;

    @GET
    @Produces("text/plain")
    public String get() {
        if (!securityContext.isUserInRole("admin")) {
            throw new WebApplicationException(Response.serverError().status(HttpResponseCodes.SC_UNAUTHORIZED)
                    .entity("User " + securityContext.getUserPrincipal().getName() + " is not authorized").build());
        }
        return "Good user " + securityContext.getUserPrincipal().getName();
    }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="resteasy_asynchronous_job_service"/>RESTEasy Asynchronous Job Service</h1></div></div></div><p>
				The RESTEasy Asynchronous Job Service is designed to add asynchronous behavior to the HTTP protocol. While HTTP is a synchronous protocol, it is aware of asynchronous invocations. The HTTP 1.1 response code <code class="literal">202 Accepted</code> means that the server has received and accepted the response for processing, but the processing has not yet been completed. The Asynchronous Job Service builds around this.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="enabling_the_asynchronous_job_service"/>Enabling the Asynchronous Job Service</h2></div></div></div><p>
					Enable the asynchronous job service in the <code class="literal">web.xml</code> file:
				</p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;resteasy.async.job.service.enabled&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="configuring_asynchronous_jobs"/>Configuring Asynchronous Jobs</h2></div></div></div><p>
					This section covers examples of the query parameters for asynchronous jobs with RESTEasy.
				</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
						Role based security does not work with the Asynchronous Job Service as it cannot be implemented portably. If the Asynchronous Job Service is used, application security must be done through XML declarations in the <code class="literal">web.xml</code> file instead.
					</p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
						While GET, DELETE, and PUT methods can be invoked asynchronously, this breaks the HTTP 1.1 contract of these methods. While these invocations might not change the state of the resource if invoked more than once, they do change the state of the server as new job entries with each invocation.
					</p></div><p>
					The <code class="literal">asynch</code> query parameter is used to run invocations in the background. A <code class="literal">202 Accepted</code> response is returned, as well as a location header with a URL pointing to where the response of the background method is located.
				</p><pre class="screen">POST http://example.com/myservice?asynch=true</pre><p>
					The example above returns a <code class="literal">202 Accepted</code> response. It also returns a location header with a URL pointing to where the response of the background method is located. An example of the location header is shown below:
				</p><pre class="screen">HTTP/1.1 202 Accepted
Location: http://example.com/asynch/jobs/3332334</pre><p>
					The URI will take the form of:
				</p><pre class="screen">/asynch/jobs/{job-id}?wait={milliseconds}|nowait=true</pre><p>
					GET, POST and DELETE operations can be performed on this URL.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							GET returns the JAX-RS resource method invoked as a response if the job was completed. If the job has not been completed, the GET returns a <code class="literal">202 Accepted</code> response code. Invoking GET does not remove the job, so it can be called multiple times.
						</li><li class="listitem">
							POST does a read of the job response and removes the job if it has been completed.
						</li><li class="listitem">
							DELETE is called to manually clean up the job queue.
						</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						When the job queue is full, it evicts the earliest job from memory automatically without needing to call DELETE.
					</p></div><p>
					The GET and POST operations allow for the maximum wait time to be defined, using the <code class="literal">wait</code> and <code class="literal">nowait</code> query parameters. If the <code class="literal">wait</code> parameter is not specified, the operation will default to <code class="literal">nowait=true</code>, and will not wait at all if the job is not complete. The <code class="literal">wait</code> parameter is defined in milliseconds.
				</p><pre class="screen">POST http://example.com/asynch/jobs/122?wait=3000</pre><p>
					RESTEasy supports fire and forget jobs, using the <code class="literal">oneway</code> query parameter.
				</p><pre class="screen">POST http://example.com/myservice?oneway=true</pre><p>
					The example above returns a <code class="literal">202 Accepted</code> response, but no job is created.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						The configuration parameters for the Asynchronous Job Service can be found in the <a class="link" href="reference_material.html#Asynchronous_Job_Service_Configuration_Parameters" title="RESTEasy Asynchronous Job Service Configuration Parameters">RESTEasy Asynchronous Job Service Configuration Parameters</a> section in the appendix.
					</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="resteasy_javascript_api"/>RESTEasy JavaScript API</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_the_resteasy_javascript_api"/>About the RESTEasy JavaScript API</h2></div></div></div><p>
					RESTEasy can generate a JavaScript API that uses AJAX calls to invoke JAX-RS operations. Each JAX-RS resource class will generate a JavaScript object of the same name as the declaring class or interface. The JavaScript object contains each JAX-RS method as properties.
				</p><pre class="programlisting">@Path("foo")
public class Foo {

  @Path("{id}")
  @GET
  public String get(@QueryParam("order") String order, @HeaderParam("X-Foo") String header,
    @MatrixParam("colour") String colour, @CookieParam("Foo-Cookie") String cookie) {
  }

  @POST
  public void post(String text) {
  }
}</pre><p>
					The following JavaScript code uses the JAX-RS API that was generated in the previous example.
				</p><pre class="programlisting">var text = Foo.get({order: 'desc', 'X-Foo': 'hello', colour: 'blue', 'Foo-Cookie': 123987235444});
Foo.post({$entity: text});</pre><p>
					Each JavaScript API method takes an optional object as single parameter where each property is a cookie, header, path, query or form parameter as identified by its name, or the API parameter properties. For details about the API parameter properties see <a class="link" href="reference_material.html#resteasy_javascript_api_parameters" title="RESTEasy JavaScript API Parameters">RESTEasy Javascript API Parameters</a> appendix.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="enable_the_resteasy_javascript_api_servlet"/>Enable the RESTEasy JavaScript API Servlet</h3></div></div></div><p>
						The RESTEasy JavaScript API is disabled by default. Follow these steps to enable it by updating the <code class="literal">web.xml</code> file.
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
								Open the <code class="literal">web.xml</code> file of the application in a text editor.
							</li><li class="listitem"><p class="simpara">
								Add the following configuration to the file, inside the <code class="literal">web-app</code> tags:
							</p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;RESTEasy JSAPI&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.resteasy.jsapi.JSAPIServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;RESTEasy JSAPI&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="build_ajax_queries"/>Build AJAX Queries</h3></div></div></div><p>
						The RESTEasy JavaScript API can be used to manually construct requests. The following are some examples of this behavior.
					</p><div class="title"><strong>Example: REST Object Used to Override RESTEasy JavaScript API Client Behavior</strong></div><p>
							
</p><pre class="programlisting">// Change the base URL used by the API:
REST.apiURL = "http://api.service.com";

// log everything in a div element
REST.log = function(text) {
  jQuery("#log-div").append(text);
};</pre><p>

						</p><p>
						The <code class="literal">REST</code> object contains the following read-write properties:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">apiURL</code>: Set by default to the JAX-RS root URL. Used by every JavaScript client API functions when constructing the requests.
							</li><li class="listitem">
								<code class="literal">log</code>: Set to <code class="literal">function(string)</code> in order to receive RESTEasy client API logs. This is useful if you want to debug your client API and place the logs where you can see them.
							</li></ul></div><div class="title"><strong>Example: Class Using REST.Request() Method to Build Custom Requests</strong></div><p>
							
</p><pre class="programlisting">var r = new REST.Request();
r.setURI("http://api.service.com/orders/23/json");
r.setMethod("PUT");
r.setContentType("application/json");
r.setEntity({id: "23"});
r.addMatrixParameter("JSESSIONID", "12309812378123");
r.execute(function(status, request, entity) {
  log("Response is " + status);
});</pre><p>

						</p></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="resteasy_spi_to_modify_resource_metadata"/>RESTEasy SPI to Modify Resource Metadata</h1></div></div></div><p>
				JBoss EAP provides a RESTEasy service provider interface (SPI) to modify resource class metadata, which is created using <code class="literal">ResourceBuilder</code>. When processing JAX-RS deployments, RESTEasy uses <code class="literal">ResourceBuilder</code> to create metadata for each JAX-RS resource. Such metadata is defined using the metadata SPI in package <code class="literal">org.jboss.resteasy.spi.metadata</code>, in particular the <code class="literal">ResourceClass</code> interface:
			</p><pre class="programlisting">package org.jboss.resteasy.spi.metadata;

public interface ResourceClass
{
  String getPath();

  Class&lt;?&gt; getClazz();

  ResourceConstructor getConstructor();

  FieldParameter[] getFields();

  SetterParameter[] getSetters();

  ResourceMethod[] getResourceMethods();

  ResourceLocator[] getResourceLocators();
}</pre><p>
				RESTEasy allows customizing the metadata generation by providing implementations of the <code class="literal">ResourceClassProcessor</code> interface. The following example illustrates the usage of this SPI:
			</p><pre class="programlisting">package org.jboss.resteasy.test.core.spi.resource;

import org.jboss.logging.Logger;
import org.jboss.resteasy.spi.metadata.ResourceClass;
import org.jboss.resteasy.spi.metadata.ResourceClassProcessor;

import javax.ws.rs.ext.Provider;

@Provider
public class ResourceClassProcessorImplementation implements ResourceClassProcessor {

    protected static final Logger logger = Logger.getLogger(ResourceClassProcessorImplementation.class.getName());
@Override
    public ResourceClass process(ResourceClass clazz) {
        logger.info(String.format("ResourceClassProcessorImplementation#process method called on class %s",
                            clazz.getClazz().getSimpleName()));
        String clazzName = clazz.getClazz().getSimpleName();
        if (clazzName.startsWith("ResourceClassProcessorEndPoint")
                || clazzName.equals("ResourceClassProcessorProxy")
                || clazzName.equals("ResourceClassProcessorProxyEndPoint")) {
            return new ResourceClassProcessorClass(clazz);
        }
        return clazz;
    }</pre><p>
				The new processors, which are stored using the <code class="literal">ResteasyProviderFactory</code> class, are resolved as regular JAX-RS annotated providers. They allow wrapping resource metadata classes with custom versions that you can use for various advanced scenarios, such as:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Adding additional resource method or locators to the resource.
					</li><li class="listitem">
						Modifying the HTTP methods.
					</li><li class="listitem">
						Modifying the <code class="literal">@Produces</code> or the <code class="literal">@Consumes</code> media types.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="microprofile_rest_client"/>MicroProfile REST Client</h1></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					MicroProfile REST client is provided as Technology Preview only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs), might not be functionally complete, and Red Hat does not recommend to use them for production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
				</p><p>
					See <a class="link" href="https://access.redhat.com/support/offerings/techpreview">Technology Preview Features Support Scope</a> on the Red Hat Customer Portal for information about the support scope for Technology Preview features.
				</p></div><p>
				JBoss EAP supports the MicroProfile REST cient that builds on JAX-RS 2.0 client APIs to provide a type-safe approach to invoke RESTful services over HTTP. The MicroProfile TypeSafe REST clients are defined as Java interfaces. With the MicroProfile REST clients, you can write client applications with executable code.
			</p><p>
				The MicroProfile REST client enables:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						An intuitive syntax
					</li><li class="listitem">
						Programmatic registration of providers
					</li><li class="listitem">
						Declarative registration of providers
					</li><li class="listitem">
						<code class="literal">ResponseExceptionMapper</code>
					</li><li class="listitem">
						CDI integration
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="intuitive_syntax"/>Intuitive Syntax</h2></div></div></div><p>
					The MicroProfile REST client enables a version of distributed object communication, which is also implemented in CORBA, Java Remote Method Invocation (RMI), the JBoss Remoting Project, and RESTEasy. For example, consider the resource:
				</p><pre class="programlisting">@Path("resource")
public class TestResource {
   @Path("test")
   @GET
   String test() {
      return "test";
   }
 }</pre><p>
					The JAX-RS native way of accessing the <code class="literal">TestResource</code> class is:
				</p><pre class="programlisting">Client client = ClientBuilder.newClient();
String response = client.target("http://localhost:8081/test").request().get(String.class);</pre><p>
					However, Microprofile REST client supports a more intuitive syntax by directly calling the <code class="literal">test()</code> method:
				</p><pre class="programlisting">@Path("resource")
public interface TestResourceIntf {
    @Path("test")
    @GET
    public String test();
}

TestResourceIntf service = MicroprofileClientBuilderResolver.instance()
                              .newBuilder()
                              .baseUrl(http://localhost:8081/))
                              .build(TestResourceIntf.class);
String s = service.test();</pre><p>
					In the example above, making calls on the <code class="literal">TestResource</code> class becomes much easier with the <code class="literal">TestResourceIntf</code> class, as illustrated by the call <code class="literal">service.test()</code>.
				</p><p>
					The following example is a more elaborate version of the <code class="literal">TestResourceIntf</code> class:
				</p><pre class="programlisting">@Path("resource")
public interface TestResourceIntf2 {
   @Path("test/{path}")mes("text/plain")
   @Produces("text/html")
   @POST
   public String test(@PathParam("path") String path, @QueryParam("query") String query, String entity);
}</pre><p>
					Calling the <code class="literal">service.test("p", "q", "e")</code> method results in an HTTP message that looks like:
				</p><pre class="programlisting">POST /resource/test/p/?query=q HTTP/1.1
Accept: text/html
Content-Type: text/plain
Content-Length: 1

e</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="programmatic_registration_of_providers"/>Programmatic Registration of Providers</h2></div></div></div><p>
					With the MicroProfile REST client, you can also configure the client environment by registering providers. For example:
				</p><pre class="programlisting">TestResourceIntf service = MicroprofileClientBuilderResolver.instance()
                              .newBuilder()
                              .baseUrl(http://localhost:8081/))
                              .register(MyClientResponseFilter.class)
                              .register(MyMessageBodyReader.class)
                              .build(TestResourceIntf.class);</pre><p>
					Declaring the <code class="literal">MyClientResponseFilter</code> class and the <code class="literal">MyMessageBodyReader</code> class with annotations eliminates the need to call the <code class="literal">RestClientBuilder.register()</code> method.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="declarative_registration_of_providers"/>Declarative Registration of Providers</h2></div></div></div><p>
					You can also register providers declaratively with annotations introduced in MicroProfile REST client. You can register providers by adding the <code class="literal">org.eclipse.microprofile.rest.client.annotation.RegisterProvider</code> annotation to the target interface as shown below:
				</p><pre class="programlisting">@Path("resource")
@RegisterProvider(MyClientResponseFilter.class)
@RegisterProvider(MyMessageBodyReader.class)
public interface TestResourceIntf2 {
   @Path("test/{path}")
   @Consumes("text/plain")
   @Produces("text/html")
   @POST
   public String test(@PathParam("path") String path, @QueryParam("query") String query, String entity);
}</pre><p>
					Declaring the <code class="literal">MyClientResponseFilter</code> class and the <code class="literal">MyMessageBodyReader</code> class with annotations eliminates the need to call the <code class="literal">RestClientBuilder.register()</code> method.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="responseexceptionmapper"/>ResponseExceptionMapper</h2></div></div></div><p>
					The <code class="literal">org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper</code> class is the client-side inverse of the <code class="literal">javax.ws.rs.ext.ExceptionMapper</code> class defined in JAX-RS. That is, where the <code class="literal">ExceptionMapper.toResponse()</code> method turns an <code class="literal">Exception</code> class thrown during the server-side processing into a <code class="literal">Response</code> class, the <code class="literal">ResponseExceptionMapper.toThrowable()</code> method turns a Response class received on the client-side with an HTTP error status into an <code class="literal">Exception</code> class.
				</p><p>
					You can register the <code class="literal">ResponseExceptionMapper</code> class either programmatically or declaratively. In the absence of a registered <code class="literal">ResponseExceptionMapper</code> class, a default <code class="literal">ResponseExceptionMapper</code> class maps any response with status <code class="literal">&gt;= 400</code> to a <code class="literal">WebApplicationException</code> class.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="cdi_integration-1"/>CDI Integration</h2></div></div></div><p>
					In MicroProfile REST client, you must annotate any interface that is managed as a CDI bean with the <code class="literal">@RegisterRestClient</code> class. For example:
				</p><pre class="programlisting">@Path("resource")
@RegisterProvider(MyClientResponseFilter.class)
public static class TestResourceImpl {
      @Inject TestDataBase db;

      @Path("test/{path}")
      @Consumes("text/plain")
      @Produces("text/html")
      @POST
      public String test(@PathParam("path") String path, @QueryParam("query")
      String query, String entity) {
         return db.getByName(query);
      }
   }
   @Path("database")
   @RegisterRestClient
   public interface TestDataBase {

      @Path("")
      @POST
      public String getByName(String name);
   }</pre><p>
					Here, the MicroProfile REST client implementation creates a client for a <code class="literal">TestDataBase</code> class service, allowing easy access by the <code class="literal">TestResourceImpl</code> class. However, it does not indicate where the <code class="literal">TestDataBase</code> class implementation lives. We can supply that information externally with the following system variable:
				</p><pre class="programlisting">&lt;fully qualified name of TestDataBase&gt;/mp-rest/url=&lt;URL&gt;</pre><p>
					For example, the following indicates that you can access an implementation of the <code class="literal">com.bluemonkeydiamond.TestDatabase</code> class at https://localhost:8080/webapp:
				</p><pre class="programlisting">com.bluemonkeydiamond.TestDatabase/mp-rest/url=https://localhost:8080/webapp</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="support_for_completionstage_type"/>Support for the CompletionStage Type</h1></div></div></div><p>
				The JAX-RS 2.1 specification supports declaring asynchronous resource methods by returning a <code class="literal">CompletionStage</code> instead of using the <code class="literal">@Suspended</code> annotation.
			</p><p>
				Whenever a resource method returns a <code class="literal">CompletionStage</code> that it subscribed to, the request is suspended. The request is resumed only when the <code class="literal">CompletionStage</code> type is:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Resolved to a value, which is then treated as the return value for the method.
					</li><li class="listitem">
						Treated as an error case, and the exception is processed as if it were thrown by the resource method.
					</li></ul></div><p>
				The following is an example of asynchronous processing using <code class="literal">CompletionStage</code>:
			</p><pre class="programlisting">public class SimpleResource
{

   @GET
   @Path("basic")
   @Produces("text/plain")
   public CompletionStage&lt;Response&gt; getBasic() throws Exception
   {
      final CompletableFuture&lt;Response&gt; response = new CompletableFuture&lt;&gt;();
      Thread t = new Thread()
      {
         @Override
         public void run()
         {
            try
            {
               Response jaxrs = Response.ok("basic").type(MediaType.TEXT_PLAIN).build();
               response.complete(jaxrs);
            }
            catch (Exception e)
            {
               response.completeExceptionally(e);
            }
         }
      };
      t.start();
      return response;
   }
}</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="extending_support_asynch_request_processing"/>Extending RESTEasy Support for Asynchronous Request Processing and Reactive Return Types</h1></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
					Extending RESTEasy support is provided as Technology Preview only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs), might not be functionally complete, and Red Hat does not recommend to use them for production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
				</p><p>
					See <a class="link" href="https://access.redhat.com/support/offerings/techpreview">Technology Preview Features Support Scope</a> on the Red Hat Customer Portal for information about the support scope for Technology Preview features.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="pluggable_reactive_types"/>Pluggable Reactive Types</h2></div></div></div><p>
					JAX-RS 2.1 is extensible to support various reactive libraries. RESTEasy’s optional module <code class="literal">resteasy-rxjava2</code> supports the following reactive types:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">io.reactivex.Single</code>: Similar to <code class="literal">CompletionStage</code>, because it holds one potential value at the most.
						</li><li class="listitem">
							<code class="literal">io.reactivex.Flowable</code>: Implements <code class="literal">io.reactivex.Publisher</code>.
						</li><li class="listitem">
							<code class="literal">io.reactivex.Observable</code>: Similar to <code class="literal">Flowable</code>, except that it does not support backpressure, the ability of a subscriber to control the load it receives from a producer by calling <code class="literal">Subscription.request()</code>.
						</li></ul></div><p>
					If you import <code class="literal">resteasy-rxjava2</code>, you can return these reactive types from your resource methods on the server side and receive them on the client side.
				</p><p>
					The <code class="literal">resteasy-rxjava2</code> module supports the following three classes to access Singles, Observables, and Flowables respectively on the client side:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">org.jboss.resteasy.rxjava2.SingleRxInvoker</code>
						</li><li class="listitem">
							<code class="literal">org.jboss.resteasy.rxjava2.FlowableRxInvoker</code>
						</li><li class="listitem">
							<code class="literal">org.jbosss.resteasy.rxjava2.ObservableRxInvoker</code>
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="extensions_for_additional_reactive_classes"/>Extensions for Additional Reactive Classes</h2></div></div></div><p>
					RESTEasy implements a framework that supports extensions for additional reactive classes. On the server side, when a resource method returns a <code class="literal">CompletionStage</code> type, RESTEasy subscribes to it using the <code class="literal">org.jboss.resteasy.core.AsyncResponseConsumer.CompletionStageResponseConsumer</code> class. When the <code class="literal">CompletionStage</code> completes, it calls <code class="literal">CompletionStageResponseConsumer.accept()</code>, which sends the result back to the client.
				</p><p>
					Support for <code class="literal">CompletionStage</code> is built in to RESTEasy. We can extend that support to a class like <code class="literal">Single</code> by providing a mechanism for transforming a <code class="literal">Single</code> into a <code class="literal">CompletionStage</code>. In the <code class="literal">resteasy-rxjava2</code> module, <code class="literal">org.jboss.resteasy.rxjava2.SingleProvider</code>, which implements the <code class="literal">org.jboss.resteasy.spi.AsyncResponseProvider&lt;Single&lt;?&gt;&gt;</code> interface provides this mechanism:
				</p><pre class="programlisting">public interface AsyncResponseProvider&lt;T&gt; {
   public CompletionStage toCompletionStage(T asyncResponse);
}</pre><p>
					Given the <code class="literal">SingleProvider</code> class, RESTEasy can take a <code class="literal">Single</code>, transform it into a <code class="literal">CompletionStage</code> and then use <code class="literal">CompletionStageResponseConsumer</code> to handle the eventual value of the <code class="literal">Single</code>. Similarly, when a resource method returns a streaming reactive class like <code class="literal">Flowable</code>, RESTEasy subscribes to it, receives a stream of data elements, and sends them to the client. <code class="literal">AsyncResponseConsumer</code> has several supporting classes, each of which implements a different mode of streaming.
				</p><p>
					For example, <code class="literal">AsyncResponseConsumer.AsyncGeneralStreamingSseResponseConsumer</code> handles general streaming and SSE streaming. Subscription is done by calling <code class="literal">org.reactivestreams.Publisher.subscribe()</code>, so it needs a mechanism to turn a <code class="literal">Flowable</code> into a <code class="literal">Publisher</code>, for example. That is, an implementation of <code class="literal">org.jboss.resteasy.spi.AsyncStreamProvider&lt;Flowable&gt;</code> is called for, which defines <code class="literal">AsyncStreamProvider</code> as shown in the following example:
				</p><pre class="programlisting">public interface AsyncStreamProvider&lt;T&gt; {
   public Publisher toAsyncStream(T asyncResponse);
}</pre><p>
					In the <code class="literal">resteasy-rxjava2</code> module, <code class="literal">org.jboss.resteasy.FlowableProvider</code> provides that mechanism for <code class="literal">Flowable</code>.
				</p><p>
					That means, on the server side, you can add support for other reactive types by declaring a <code class="literal">@Provider</code> annotation for the <code class="literal">AsyncStreamProvider</code> interface for streams or the <code class="literal">AsyncResponseProvider</code> interface for single values. Both these interfaces have a single method to convert the new reactive type into a <code class="literal">Publisher</code> or a <code class="literal">CompletionStage</code> for streams or for single values respectively.
				</p><p>
					On the client side, the JAX-RS 2.1 imposes two requirements for support of the reactive classes:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Support for <code class="literal">CompletionStage</code> as an implementation of the <code class="literal">javax.ws.rs.client.CompletionStageRxInvoker</code> interface.
						</li><li class="listitem">
							Extensibility by supporting the registration of providers that implement:
						</li></ul></div><pre class="programlisting">public interface RxInvokerProvider&lt;T extends RxInvoker&gt; {
    public boolean isProviderFor(Class&lt;T&gt; clazz);
    public T getRxInvoker(SyncInvoker syncInvoker, ExecutorService executorService);
}</pre><p>
					Once an RxInvokerProvider is registered, you can request an RxInvoker by calling the <code class="literal">javax.ws.rs.client.Invocation.Builder</code> method:
				</p><pre class="programlisting">public &lt;T extends RxInvoker&gt; T rx(Class&lt;T&gt; clazz);</pre><p>
					You can use the RxInvoker for making an invocation that returns the appropriate reactive class. For example:
				</p><pre class="programlisting">FlowableRxInvoker invoker = client.target(generateURL("/get/string")).request().rx(FlowableRxInvoker.class);
Flowable&lt;String&gt; flowable = (Flowable&lt;String&gt;) invoker.get();</pre><p>
					RESTEasy provides partial support for implementing <code class="literal">RxInvokers</code>. For example, <code class="literal">SingleProvider</code>, mentioned above, also implements <code class="literal">org.jboss.resteasy.spi.AsyncClientResponseProvider&lt;Single&lt;?&gt;&gt;</code>, where <code class="literal">AsyncClientResponseProvider</code> is defined as the following:
				</p><pre class="programlisting">public interface AsyncClientResponseProvider&lt;T&gt; {
   public T fromCompletionStage(CompletionStage&lt;?&gt; completionStage);
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="reactive_clients_api"/>Reactive Clients API</h2></div></div></div><p>
					RESTEasy defines a new type of invoker named <code class="literal">RxInvoker</code>, and a default implementation of this type named <code class="literal">CompletionStageRxInvoker</code>. <code class="literal">CompletionStageRxInvoker</code> implements Java 8’s interface <code class="literal">CompletionStage</code>. This interface declares a large number of methods dedicated to managing asynchronous computations.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="asynchronous_filters"/>Asynchronous Filters</h2></div></div></div><p>
					If you must suspend execution of your filter until a certain resource is available, you can convert it into an asynchronous filter. Turning a request asynchronous does not require any change to your resource method declaration or the additional filter declaration.
				</p><p>
					To turn a filter’s execution asynchronous, you must cast:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The <code class="literal">ContainerRequestContext</code> into <code class="literal">SuspendableContainerRequestContext</code> for pre and post request filters.
						</li><li class="listitem">
							The <code class="literal">ContainerResponseContext</code> into a <code class="literal">SuspendableContainerResponseContext</code> for response filters.
						</li></ul></div><p>
					These context objects can turn the current filter’s execution into asynchronous by calling the <code class="literal">suspend()</code> method. Once asynchronous, the filter chain is suspended, and resumes only after one of the following methods is called on the context object:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">abortWith(Response)</code>: Terminate the filter chain, return the given Response to the client. This applies only to ContainerRequestFilter.
						</li><li class="listitem">
							<code class="literal">resume()</code>: Resume execution of the filter chain by calling the next filter.
						</li><li class="listitem">
							<code class="literal">resume(Throwable)</code>: Abort execution of the filter chain by throwing the given exception. This behaves as if the filter were synchronous and threw the given exception.
						</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="proxies"/>Proxies</h2></div></div></div><p>
					Proxies are a RESTEasy extension that supports an intuitive programming style, which replaces generic JAX-RS invoker calls with application-specific interface calls. The proxy framework is extended to include both <code class="literal">CompletionStage</code> and the RxJava2 types <code class="literal">Single</code>, <code class="literal">Observable</code>, and <code class="literal">Flowable</code>. The two following examples illustrate how RESTEasy proxies work:
				</p><p>
					Example 1:
				</p><pre class="programlisting">@Path("")
public interface RxCompletionStageResource {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   public CompletionStage&lt;String&gt; getString();
}

@Path("")
public class RxCompletionStageResourceImpl {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   public CompletionStage&lt;String&gt; getString() { .... }
}

public class RxCompletionStageProxyTest {

   private static ResteasyClient client;
   private static RxCompletionStageResource proxy;

   static {
      client = new ResteasyClientBuilder().build();
      proxy = client.target(generateURL("/")).proxy(RxCompletionStageResource.class);
   }

   @Test
   public void testGet() throws Exception {
      CompletionStage&lt;String&gt; completionStage = proxy.getString();
      Assert.assertEquals("x", completionStage.toCompletableFuture().get());
   }
}</pre><p>
					Example 2:
				</p><pre class="programlisting">public interface Rx2FlowableResource {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   @Stream
   public Flowable&lt;String&gt; getFlowable();
}

@Path("")
public class Rx2FlowableResourceImpl {

   @GET
   @Path("get/string")
   @Produces(MediaType.TEXT_PLAIN)
   @Stream
   public Flowable&lt;String&gt; getFlowable() { ... }
}

public class Rx2FlowableProxyTest {

   private static ResteasyClient client;
   private static Rx2FlowableResource proxy;

   static {
      client = new ResteasyClientBuilder().build();
      proxy = client.target(generateURL("/")).proxy(Rx2FlowableResource.class);
   }

   @Test
   public void testGet() throws Exception {
      Flowable&lt;String&gt; flowable = proxy.getFlowable();
      flowable.subscribe(
         (String o) -&gt; stringList.add(o),
         (Throwable t) -&gt; errors.incrementAndGet(),
         () -&gt; latch.countDown());
      boolean waitResult = latch.await(30, TimeUnit.SECONDS);
      Assert.assertTrue("Waiting for event to be delivered has timed out.", waitResult);
      Assert.assertEquals(0, errors.get());
      Assert.assertEquals(xStringList, stringList);
   }
}</pre></div></div></div></body></html>