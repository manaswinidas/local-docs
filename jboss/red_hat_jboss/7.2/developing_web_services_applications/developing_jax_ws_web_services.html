<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 3. Developing JAX-WS Web Services</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.78.1"/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="developing_jax_ws_web_services"/>Chapter 3. Developing JAX-WS Web Services</h1></div></div></div><p>
			The Java API for XML-Based Web Services (JAX-WS) defines the mapping between WSDL and Java, as well as the classes to be used for accessing web services and publishing them. JBossWS implements the latest <a class="link" href="https://www.jcp.org/en/jsr/detail?id=224">JAX-WS specification</a>, which users can reference for any vendor-agnostic web service usage need.
		</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="using_jax_ws_tools"/>Using JAX-WS Tools</h1></div></div></div><p>
				The following JAX-WS command-line tools are included with the JBoss EAP distribution. These tools can be used in a variety of ways for <a class="link" href="developing_jax_ws_web_services.html#server_side_dev_strategies" title="Server-side Development Strategies">server</a> and <a class="link" href="developing_jax_ws_web_services.html#client_side_dev_strategies" title="Client-side Development Strategies">client-side</a> development.
			</p><div class="table"><a id="idm140182149370368"/><p class="title"><strong>Table 3.1. JAX-WS Command-Line Tools</strong></p><div class="table-contents"><table summary="JAX-WS Command-Line Tools" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Command</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
								<a class="link" href="reference_material.html#wsprovide_tool" title="wsprovide">wsprovide</a>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Generates JAX-WS portable artifacts, and provides the abstract contract. Used for bottom-up development.
							</p>
							 </td></tr><tr><td style="text-align: left" valign="top"> <p>
								<a class="link" href="reference_material.html#wsconsume_tool" title="wsconsume">wsconsume</a>
							</p>
							 </td><td style="text-align: left" valign="top"> <p>
								Consumes the abstract contract (WSDL and Schema files), and produces artifacts for both a server and client. Used for top-down and client development.
							</p>
							 </td></tr></tbody></table></div></div><p>
				See <a class="link" href="reference_material.html#jax_ws_tools" title="JAX-WS Tools">JAX-WS Tools</a> for more details on the usage of these tools.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="server_side_dev_strategies"/>Server-side Development Strategies</h2></div></div></div><p>
					When developing a web service endpoint on the server side, you have the option of starting from Java code, known as <span class="emphasis"><em>bottom-up development</em></span>, or from the WSDL that defines your service, known as <span class="emphasis"><em>top-down development</em></span>. If this is a new service, meaning that there is no existing contract, then the bottom-up approach is the fastest route; you only need to add a few annotations to your classes to get a service up and running. However, if you are developing a service with a contract already defined, it is far simpler to use the top-down approach, since the tool can generate the annotated code for you.
				</p><p>
					Bottom-up use cases:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Exposing an already existing EJB3 bean as a web service.
						</li><li class="listitem">
							Providing a new service, and you want the contract to be generated for you.
						</li></ul></div><p>
					Top-down use cases:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Replacing the implementation of an existing web service, and you can not break compatibility with older clients.
						</li><li class="listitem">
							Exposing a service that conforms to a contract specified by a third party, for example, a vendor that calls you back using an already defined protocol.
						</li><li class="listitem">
							Creating a service that adheres to the XML Schema and WSDL you developed by hand up front.
						</li></ul></div><h4><a id="bottom_up_strategy_using_wsprovide"/>Bottom-Up Strategy Using wsprovide</h4><p>
					The bottom-up strategy involves developing the Java code for your service, and then annotating it using JAX-WS annotations. These annotations can be used to customize the contract that is generated for your service. For example, you can change the operation name to map to anything you like. However, all of the annotations have sensible defaults, so only the <code class="literal">@WebService</code> annotation is required.
				</p><p>
					This can be as simple as creating a single class:
				</p><pre class="programlisting">package echo;

@javax.jws.WebService
public class Echo {

   public String echo(String input) {
      return input;
   }
}</pre><p>
					A deployment can be built using this class, and it is the only Java code needed to deploy on JBossWS. The WSDL, and all other Java artifacts called <span class="emphasis"><em>wrapper classes</em></span> will be generated for you at deploy time.
				</p><p>
					The primary purpose of the <code class="literal">wsprovide</code> tool is to generate portable JAX-WS artifacts. Additionally, it can be used to provide the WSDL file for your service. This can be obtained by invoking <code class="literal">wsprovide</code> using the <code class="literal">-w</code> option:
				</p><pre class="screen">$ javac -d . Echo.java
$ EAP_HOME/bin/wsprovide.sh --classpath=. -w echo.Echo</pre><p>
					Inspecting the WSDL reveals a service named <code class="literal">EchoService</code>:
				</p><pre class="programlisting">&lt;wsdl:service name="EchoService"&gt;
  &lt;wsdl:port name="EchoPort" binding="tns:EchoServiceSoapBinding"&gt;
    &lt;soap:address location="http://localhost:9090/EchoPort"/&gt;
  &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;</pre><p>
					As expected, this service defines an operation, <code class="literal">echo</code>:
				</p><pre class="programlisting">&lt;wsdl:portType name="Echo"&gt;
  &lt;wsdl:operation name="echo"&gt;
    &lt;wsdl:input name="echo" message="tns:echo"&gt;
    &lt;/wsdl:input&gt;
    &lt;wsdl:output name="echoResponse" message="tns:echoResponse"&gt;
    &lt;/wsdl:output&gt;
  &lt;/wsdl:operation&gt;
&lt;/wsdl:portType&gt;</pre><p>
					When deploying you do not need to run this tool. You only need it for generating portable artifacts or the abstract contract for your service.
				</p><p>
					A POJO endpoint for the deployment can be created in a simple <code class="literal">web.xml</code> file:
				</p><pre class="programlisting">&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
  version="2.4"&gt;

  &lt;servlet&gt;
    &lt;servlet-name&gt;Echo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;echo.Echo&lt;/servlet-class&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Echo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/Echo&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>
					The <code class="literal">web.xml</code> and the single Java class can now be used to create a WAR:
				</p><pre class="screen">$ mkdir -p WEB-INF/classes
$ cp -rp echo WEB-INF/classes/
$ cp web.xml WEB-INF
$ jar cvf echo.war WEB-INF
added manifest
adding: WEB-INF/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/Echo.class(in = 340) (out= 247)(deflated 27%)
adding: WEB-INF/web.xml(in = 576) (out= 271)(deflated 52%)</pre><p>
					The WAR can then be deployed to JBoss EAP. This will internally invoke <code class="literal">wsprovide</code>, which will generate the WSDL. If the deployment was successful, and you are using the default settings, it should be available in the management console.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						For a portable JAX-WS deployment, the wrapper classes generated earlier could be added to the deployment.
					</p></div><h4><a id="top_down_strategy_using_wsconsume"/>Top-Down Strategy Using wsconsume</h4><p>
					The top-down development strategy begins with the abstract contract for the service, which includes the WSDL file and zero or more schema files. The <code class="literal">wsconsume</code> tool is then used to consume this contract, and produce annotated Java classes, and optionally sources, that define it.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						<code class="literal">wsconsume</code> might have problems with symlinks on Unix systems.
					</p></div><p>
					Using the WSDL file from the bottom-up example, a new Java implementation that adheres to this service can be generated. The <code class="literal">-k</code> option is passed to <code class="literal">wsconsume</code> to preserve the Java source files that are generated, instead of providing just Java classes:
				</p><pre class="screen">$ EAP_HOME/bin/wsconsume.sh -k EchoService.wsdl</pre><p>
					The following table shows the purpose of each generated file:
				</p><div class="table"><a id="idm140182218640896"/><p class="title"><strong>Table 3.2. Generated Files</strong></p><div class="table-contents"><table summary="Generated Files" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">File</th><th style="text-align: left" valign="top">Purpose</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									Echo.java
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Service Endpoint Interface
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									EchoResponse.java
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Wrapper bean for response message
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									EchoService.java
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Used only by JAX-WS clients
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									Echo_Type.java
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Wrapper bean for request message
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									ObjectFactory.java
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									JAXB XML Registry
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									package-info.java
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Holder for JAXB package annotations
								</p>
								 </td></tr></tbody></table></div></div><p>
					Examining the service endpoint interface reveals annotations that are more explicit than in the class written by hand in the bottom-up example, however, these evaluate to the same contract.
				</p><pre class="programlisting">@WebService(targetNamespace = "http://echo/", name = "Echo")
@XmlSeeAlso({ObjectFactory.class})
public interface Echo {

    @WebMethod
    @RequestWrapper(localName = "echo", targetNamespace = "http://echo/", className = "echo.Echo_Type")
    @ResponseWrapper(localName = "echoResponse", targetNamespace = "http://echo/", className = "echo.EchoResponse")
    @WebResult(name = "return", targetNamespace = "")
    public java.lang.String echo(
        @WebParam(name = "arg0", targetNamespace = "")
        java.lang.String arg0
    );
}</pre><p>
					The only missing piece, other than for packaging, is the implementation class, which can now be written using the above interface.
				</p><pre class="programlisting">package echo;

@javax.jws.WebService(endpointInterface="echo.Echo")
public class EchoImpl implements Echo {
   public String echo(String arg0) {
      return arg0;
   }
}</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="client_side_dev_strategies"/>Client-side Development Strategies</h2></div></div></div><p>
					Before going in to detail on the client side, it is important to understand the decoupling concept that is central to web services. Web services are not the best fit for internal RPC, even though they can be used in this way. There are much better technologies for this, such as CORBA and RMI. Web services were designed specifically for interoperable coarse-grained correspondence. There is no expectation or guarantee that any party participating in a web service interaction will be at any particular location, running on any particular operating system, or written in any particular programming language. So because of this, it is important to clearly separate client and server implementations. The only thing they should have in common is the abstract contract definition. If, for whatever reason, your software does not adhere to this principal, then you should not be using web services. For the above reasons, the recommended methodology for developing a client is to follow the top-down approach, even if the client is running on the same server.
				</p><h4><a id="top_down_strategy_using_wsconsume_2"/>Top-Down Strategy Using wsconsume</h4><p>
					This section repeats the process of the server-side top-down section, however, it uses a deployed WSDL. This is to retrieve the correct value for <code class="literal">soap:address</code>, shown below, which is computed at deploy time. This value can be edited manually in the WSDL if necessary, but you must take care to provide the correct path.
				</p><div class="title"><strong>Example: <code class="literal">soap:address</code> in a Deployed WSDL</strong></div><p>
						
</p><pre class="programlisting">&lt;wsdl:service name="EchoService"&gt;
  &lt;wsdl:port name="EchoPort" binding="tns:EchoServiceSoapBinding"&gt;
    &lt;soap:address location="http://localhost.localdomain:8080/echo/Echo"/&gt;
  &lt;/wsdl:port&gt;
&lt;/wsdl:service&gt;</pre><p>

					</p><p>
					Use <code class="literal">wsconsume</code> to generate Java classes for the deployed WSDL.
				</p><pre class="screen">$ EAP_HOME/bin/wsconsume.sh -k http://localhost:8080/echo/Echo?wsdl</pre><p>
					Notice how the <code class="literal">EchoService.java</code> class stores the location from which the WSDL was obtained.
				</p><pre class="programlisting">@WebServiceClient(name = "EchoService",
                  wsdlLocation = "http://localhost:8080/echo/Echo?wsdl",
                  targetNamespace = "http://echo/")
public class EchoService extends Service {

    public final static URL WSDL_LOCATION;

    public final static QName SERVICE = new QName("http://echo/", "EchoService");
    public final static QName EchoPort = new QName("http://echo/", "EchoPort");

    ...

    @WebEndpoint(name = "EchoPort")
    public Echo getEchoPort() {
        return super.getPort(EchoPort, Echo.class);
    }

    @WebEndpoint(name = "EchoPort")
    public Echo getEchoPort(WebServiceFeature... features) {
        return super.getPort(EchoPort, Echo.class, features);
    }
}</pre><p>
					As you can see, this generated class extends the main client entry point in JAX-WS, <code class="literal">javax.xml.ws.Service</code>. While you can use <code class="literal">Service</code> directly, this is far simpler since it provides the configuration information for you. Note the <code class="literal">getEchoPort()</code> method, which returns an instance of our service endpoint interface. Any web service operation can then be called by just invoking a method on the returned interface.
				</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
						Do not refer to a remote WSDL URL in a production application. This causes network I/O every time you instantiate the <code class="literal">Service</code> object. Instead, use the tool on a saved local copy, or use the URL version of the constructor to provide a new WSDL location.
					</p></div><p>
					Write and compile the client:
				</p><pre class="programlisting">import echo.*;

public class EchoClient {

   public static void main(String args[]) {

      if (args.length != 1) {
          System.err.println("usage: EchoClient &lt;message&gt;");
          System.exit(1);
      }

      EchoService service = new EchoService();
      Echo echo = service.getEchoPort();
      System.out.println("Server said: " + echo.echo(args0));
   }
}</pre><p>
					You can change the endpoint address of your operation at runtime, by setting the <code class="literal">ENDPOINT_ADDRESS_PROPERTY</code> as shown below:
				</p><pre class="programlisting">EchoService service = new EchoService();
Echo echo = service.getEchoPort();

/* Set NEW Endpoint Location */
String endpointURL = "http://NEW_ENDPOINT_URL";
BindingProvider bp = (BindingProvider)echo;
bp.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointURL);

System.out.println("Server said: " + echo.echo(args0));</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jax_ws_web_service_endpoints"/>JAX-WS Web Service Endpoints</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_jax_ws_web_service_endpoints"/>About JAX-WS Web Service Endpoints</h2></div></div></div><p>
					A JAX-WS web service endpoint is the server component of a web service. Clients and other web services communicate with it over the HTTP protocol using an XML language called Simple Object Access Protocol (SOAP). The endpoint itself is deployed into the JBoss EAP container.
				</p><p>
					WSDL descriptors can be created in one of the following two ways:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							Writing WSDL descriptors manually.
						</li><li class="listitem">
							Using JAX-WS annotations that create the WSDL descriptors automatically. This is the most common method for creating WSDL descriptors.
						</li></ul></div><p>
					An endpoint implementation bean is annotated with JAX-WS annotations and deployed to the server. The server automatically generates and publishes the abstract contract in WSDL format for client consumption. All marshalling and unmarshalling is delegated to the Java Architecture for XML Binding (JAXB) service.
				</p><p>
					The endpoint itself might be a Plain Old Java Object (POJO) or a Java EE web application. You can also expose endpoints using an EJB3 stateless session bean. It is packaged into a web archive (WAR) file. The specification for packaging the endpoint, called a Java Service Endpoint (JSE) is defined in <a class="link" href="http://jcp.org/aboutJava/communityprocess/mrel/jsr181/index2.html">JSR-181</a>.
				</p><div class="title"><strong>Example: POJO Endpoint</strong></div><p>
						
</p><pre class="programlisting">@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean {
    @WebMethod
    public String echo(String input) {
        ...
    }
}</pre><p>

					</p><div class="title"><strong>Example: Web Services Endpoint</strong></div><p>
						
</p><pre class="programlisting">&lt;web-app ...&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.quickstarts.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>

					</p><p>
					The following EJB3 stateless session bean exposes the same method on the remote interface as well as an endpoint operation.
				</p><pre class="programlisting">@Stateless
@Remote(EJB3RemoteInterface.class)

@WebService

@SOAPBinding(style = SOAPBinding.Style.RPC)
public class EJB3Bean implements EJB3RemoteInterface {
    @WebMethod
    public String echo(String input) {
        ...
    }
}</pre><h3><a id="service_endpoint_interface"/>Service Endpoint Interface</h3><p>
					JAX-WS services typically implement a Java service endpoint interface (SEI), which might be mapped from a WSDL port type, either directly or using annotations. This SEI provides a high-level abstraction that hides the details between Java objects and their XML representations.
				</p><h3><a id="endpoint_provider_interface"/>Endpoint Provider Interface</h3><p>
					In some cases, JAX-WS services need the ability to operate at the XML message level. The endpoint <code class="literal">Provider</code> interface provides this functionality to the web services that implement it.
				</p><h3><a id="consuming_and_accessing_the_endpoint"/>Consuming and Accessing the Endpoint</h3><p>
					After you deploy your web service, you can consume the WSDL to create the component stubs which will be the basis for your application. Your application can then access the endpoint to do its work.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="developing_and_deploying_jax_ws_web_service_endpoint"/>Developing and Deploying JAX-WS Web Service Endpoint</h2></div></div></div><p>
					A JAX-WS service endpoint is a server-side component that responds to requests from JAX-WS clients and publishes the WSDL definition for itself.
				</p><p>
					See the following quickstarts that ship with JBoss EAP for working examples of how to develop JAX-WS endpoint applications.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							jaxws-addressing
						</li><li class="listitem">
							jaxws-ejb
						</li><li class="listitem">
							jaxws-pojo
						</li><li class="listitem">
							jaxws-retail
						</li><li class="listitem">
							wsat-simple
						</li><li class="listitem">
							wsba-coordinator-completion-simple
						</li><li class="listitem">
							wsba-participant-completion-simple
						</li></ul></div><h3><a id="development_requirements"/>Development Requirements</h3><p>
					A web service must fulfill the requirements of the JAX-WS API and the <a class="link" href="http://www.jcp.org/en/jsr/summary?id=181">JSR 181: Web Services Metadata for the Java Platform</a> specification. A valid implementation meets the following requirements:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							It contains a <code class="literal">javax.jws.WebService</code> annotation.
						</li><li class="listitem">
							All method parameters and return types are compatible with the <a class="link" href="http://www.jcp.org/en/jsr/summary?id=222">JSR 222: JavaTM Architecture for XML Binding (JAXB) 2.0</a> specification.
						</li></ul></div><p>
					The following is an example of a web service implementation that meets these requirements.
				</p><div class="title"><strong>Example: Web Service Implementation</strong></div><p>
						
</p><pre class="programlisting">package org.jboss.quickstarts.ws.jaxws.samples.retail.profile;

import javax.ejb.Stateless;
import javax.jws.WebService;
import javax.jws.WebMethod;
import javax.jws.soap.SOAPBinding;

@Stateless

@WebService(
    name = "ProfileMgmt",
    targetNamespace = "http://org.jboss.ws/samples/retail/profile",
    serviceName = "ProfileMgmtService")
@SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)
public class ProfileMgmtBean {
    @WebMethod
    public DiscountResponse getCustomerDiscount(DiscountRequest request) {
        DiscountResponse dResponse = new DiscountResponse();
        dResponse.setCustomer(request.getCustomer());
        dResponse.setDiscount(10.00);
        return dResponse;
    }
}</pre><p>

					</p><p>
					The following is an example of the <code class="literal">DiscountRequest</code> class that is used by the <code class="literal">ProfileMgmtBean</code> bean in the previous example. The annotations are included for verbosity. Typically, the JAXB defaults are reasonable and do not need to be specified.
				</p><div class="title"><strong>Example: DiscountRequest Class</strong></div><p>
						
</p><pre class="programlisting">package org.jboss.test.ws.jaxws.samples.retail.profile;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;

import org.jboss.test.ws.jaxws.samples.retail.Customer;

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(
  name = "discountRequest",
  namespace="http://org.jboss.ws/samples/retail/profile",
  propOrder = { "customer" }
)
public class DiscountRequest {

   protected Customer customer;

   public DiscountRequest() {
   }

   public DiscountRequest(Customer customer) {
      this.customer = customer;
   }

   public Customer getCustomer() {
      return customer;
   }

   public void setCustomer(Customer value) {
      this.customer = value;
   }

}</pre><p>

					</p><h3><a id="packaging_your_deployment"/>Packaging Your Deployment</h3><p>
					The implementation class is wrapped in a JAR deployment. Any metadata required for deployment is taken from the annotations on the implementation class and the service endpoint interface. You can deploy the JAR using the management CLI or the management console, and the HTTP endpoint is created automatically.
				</p><p>
					The following listing shows an example of the structure for a JAR deployment of an EJB web service.
				</p><pre class="screen">$ jar -tf jaxws-samples-retail.jar
org/jboss/test/ws/jaxws/samples/retail/profile/DiscountRequest.class
org/jboss/test/ws/jaxws/samples/retail/profile/DiscountResponse.class
org/jboss/test/ws/jaxws/samples/retail/profile/ObjectFactory.class
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmt.class
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtBean.class
org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtService.class
org/jboss/test/ws/jaxws/samples/retail/profile/package-info.class</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ws_clients"/>JAX-WS Web Service Clients</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="consume_and_access_a_jax_ws_web_service"/>Consume and Access a JAX-WS Web Service</h2></div></div></div><p>
					After creating a web service endpoint, either manually or using JAX-WS annotations, you can access its WSDL. This WSDL can be used to create the basic client application that will communicate with the web service. The process of generating Java code from the published WSDL is called consuming the web service. This happens in the following phases:
				</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
							<a class="link" href="developing_jax_ws_web_services.html#create_client_artifacts" title="Create the Client Artifacts">Create the client artifacts</a>.
						</li><li class="listitem">
							<a class="link" href="developing_jax_ws_web_services.html#construct_service_stub" title="Construct a Service Stub">Construct a service stub</a>.
						</li></ol></div><h4><a id="create_client_artifacts"/>Create the Client Artifacts</h4><p>
					Before you can create client artifacts, you need to create your WSDL contract. The following WSDL contract is used for the examples presented in the rest of this section.
				</p><p>
					The examples below rely on having this WSDL contract in the <code class="literal">ProfileMgmtService.wsdl</code> file.
				</p><pre class="programlisting">&lt;definitions
    name='ProfileMgmtService'
    targetNamespace='http://org.jboss.ws/samples/retail/profile'
    xmlns='http://schemas.xmlsoap.org/wsdl/'
    xmlns:ns1='http://org.jboss.ws/samples/retail'
    xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/'
    xmlns:tns='http://org.jboss.ws/samples/retail/profile'
    xmlns:xsd='http://www.w3.org/2001/XMLSchema'&gt;

   &lt;types&gt;

      &lt;xs:schema targetNamespace='http://org.jboss.ws/samples/retail'
                 version='1.0' xmlns:xs='http://www.w3.org/2001/XMLSchema'&gt;
         &lt;xs:complexType name='customer'&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element minOccurs='0' name='creditCardDetails' type='xs:string'/&gt;
               &lt;xs:element minOccurs='0' name='firstName' type='xs:string'/&gt;
               &lt;xs:element minOccurs='0' name='lastName' type='xs:string'/&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:complexType&gt;
      &lt;/xs:schema&gt;

      &lt;xs:schema
          targetNamespace='http://org.jboss.ws/samples/retail/profile'
          version='1.0'
          xmlns:ns1='http://org.jboss.ws/samples/retail'
          xmlns:tns='http://org.jboss.ws/samples/retail/profile'
          xmlns:xs='http://www.w3.org/2001/XMLSchema'&gt;

         &lt;xs:import namespace='http://org.jboss.ws/samples/retail'/&gt;
         &lt;xs:element name='getCustomerDiscount'
                     nillable='true' type='tns:discountRequest'/&gt;
         &lt;xs:element name='getCustomerDiscountResponse'
                     nillable='true' type='tns:discountResponse'/&gt;
         &lt;xs:complexType name='discountRequest'&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element minOccurs='0' name='customer' type='ns1:customer'/&gt;

            &lt;/xs:sequence&gt;
         &lt;/xs:complexType&gt;
         &lt;xs:complexType name='discountResponse'&gt;
            &lt;xs:sequence&gt;
               &lt;xs:element minOccurs='0' name='customer' type='ns1:customer'/&gt;
               &lt;xs:element name='discount' type='xs:double'/&gt;
            &lt;/xs:sequence&gt;
         &lt;/xs:complexType&gt;
      &lt;/xs:schema&gt;

   &lt;/types&gt;

   &lt;message name='ProfileMgmt_getCustomerDiscount'&gt;
      &lt;part element='tns:getCustomerDiscount' name='getCustomerDiscount'/&gt;
   &lt;/message&gt;
   &lt;message name='ProfileMgmt_getCustomerDiscountResponse'&gt;
      &lt;part element='tns:getCustomerDiscountResponse'
            name='getCustomerDiscountResponse'/&gt;
   &lt;/message&gt;
   &lt;portType name='ProfileMgmt'&gt;
      &lt;operation name='getCustomerDiscount'
                 parameterOrder='getCustomerDiscount'&gt;

         &lt;input message='tns:ProfileMgmt_getCustomerDiscount'/&gt;
         &lt;output message='tns:ProfileMgmt_getCustomerDiscountResponse'/&gt;
      &lt;/operation&gt;
   &lt;/portType&gt;
   &lt;binding name='ProfileMgmtBinding' type='tns:ProfileMgmt'&gt;
      &lt;soap:binding style='document'
                    transport='http://schemas.xmlsoap.org/soap/http'/&gt;
      &lt;operation name='getCustomerDiscount'&gt;
         &lt;soap:operation soapAction=''/&gt;
         &lt;input&gt;

            &lt;soap:body use='literal'/&gt;
         &lt;/input&gt;
         &lt;output&gt;
            &lt;soap:body use='literal'/&gt;
         &lt;/output&gt;
      &lt;/operation&gt;
   &lt;/binding&gt;
   &lt;service name='ProfileMgmtService'&gt;
      &lt;port binding='tns:ProfileMgmtBinding' name='ProfileMgmtPort'&gt;

         &lt;!-- service address will be rewritten to actual one when WSDL is requested from running server --&gt;
         &lt;soap:address location='http://SERVER:PORT/jaxws-retail/ProfileMgmtBean'/&gt;
      &lt;/port&gt;
   &lt;/service&gt;
&lt;/definitions&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						If you use JAX-WS annotations to create your web service endpoint, the WSDL contract is generated automatically, and you only need its URL. You can find this URL by navigating to <span class="strong"><strong>Runtime</strong></span>, selecting the applicable server, selecting <span class="strong"><strong>Webservices</strong></span>, then choosing the endpoint.
					</p></div><p>
					The <code class="literal">wsconsume.sh</code> or <code class="literal">wsconsume.bat</code> tool is used to consume the abstract contract (WSDL) and produce annotated Java classes and optional sources that define it. The tool is located in the <code class="literal"><span class="emphasis"><em>EAP_HOME</em></span>/bin/</code> directory.
				</p><pre class="screen">$ ./wsconsume.sh --help
WSConsumeTask is a cmd line tool that generates portable JAX-WS artifacts from a WSDL file.

usage: org.jboss.ws.tools.cmd.WSConsume [options] &lt;wsdl-url&gt;

options:
    -h, --help                  Show this help message
    -b, --binding=&lt;file&gt;        One or more JAX-WS or JAXB binding files
    -k, --keep                  Keep/Generate Java source
    -c  --catalog=&lt;file&gt;        Oasis XML Catalog file for entity resolution
    -p  --package=&lt;name&gt;        The target package for generated source
    -w  --wsdlLocation=&lt;loc&gt;    Value to use for @WebService.wsdlLocation
    -o, --output=&lt;directory&gt;    The directory to put generated artifacts
    -s, --source=&lt;directory&gt;    The directory to put Java source
    -t, --target=&lt;2.0|2.1|2.2&gt;  The JAX-WS specification target
    -q, --quiet                 Be somewhat more quiet
    -v, --verbose               Show full exception stack traces
    -l, --load-consumer         Load the consumer and exit (debug utility)
    -e, --extension             Enable SOAP 1.2 binding extension
    -a, --additionalHeaders     Enable processing of implicit SOAP headers
    -n, --nocompile             Do not compile generated sources</pre><p>
					The following command generates the source <code class="literal">.java</code> files listed in the output, from the <code class="literal">ProfileMgmtService.wsdl</code> file. The sources use the directory structure of the package, which is specified with the <code class="literal">-p</code> switch.
				</p><pre class="screen">[user@host bin]$
output/org/jboss/test/ws/jaxws/samples/retail/profile/Customer.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/DiscountRequest.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/DiscountResponse.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/ObjectFactory.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmt.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtService.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/package-info.java
output/org/jboss/test/ws/jaxws/samples/retail/profile/Customer.class
output/org/jboss/test/ws/jaxws/samples/retail/profile/DiscountRequest.class
output/org/jboss/test/ws/jaxws/samples/retail/profile/DiscountResponse.class
output/org/jboss/test/ws/jaxws/samples/retail/profile/ObjectFactory.class
output/org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmt.class
output/org/jboss/test/ws/jaxws/samples/retail/profile/ProfileMgmtService.class
output/org/jboss/test/ws/jaxws/samples/retail/profile/package-info.class</pre><p>
					Both <code class="literal">.java</code> source files and compiled <code class="literal">.class</code> files are generated into the <code class="literal">output/</code> directory within the directory where you run the command.
				</p><div class="table"><a id="idm140182267685168"/><p class="title"><strong>Table 3.3. Descriptions of Artifacts Created by <code class="literal">wsconsume.sh</code></strong></p><div class="table-contents"><table summary="Descriptions of Artifacts Created by wsconsume.sh" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">File</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">ProfileMgmt.java</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Service endpoint interface.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">Customer.java</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Custom data type.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">Discount.java</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Custom data types.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">ObjectFactory.java</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									JAXB XML registry.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">package-info.java</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									JAXB package annotations.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									<code class="literal">ProfileMgmtService.java</code>
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Service factory.
								</p>
								 </td></tr></tbody></table></div></div><p>
					The <code class="literal">wsconsume</code> command generates all custom data types (JAXB annotated classes), the service endpoint interface, and a service factory class. These artifacts are used to build web service client implementations.
				</p><h4><a id="construct_service_stub"/>Construct a Service Stub</h4><p>
					Web service clients use service stubs to abstract the details of a remote web service invocation. To a client application, a web service invocation looks like an invocation of any other business component. In this case the service endpoint interface acts as the business interface, and a service factory class is not used to construct it as a service stub.
				</p><p>
					The following example first creates a service factory using the WSDL location and the service name. Next, it uses the service endpoint interface created by <code class="literal">wsconsume</code> to build the service stub. Finally, the stub can be used just as any other business interface would be.
				</p><p>
					You can find the WSDL URL for your endpoint in the JBoss EAP management console. You can find this URL by navigating to <span class="strong"><strong>Runtime</strong></span>, selecting the applicable server, selecting <span class="strong"><strong>Webservices</strong></span>, then choosing the endpoint.
				</p><pre class="programlisting">import javax.xml.ws.Service;
[...]
Service service = Service.create(
new URL("http://example.org/service?wsdl"),
new QName("MyService")
);
ProfileMgmt profileMgmt = service.getPort(ProfileMgmt.class);

// Use the service stub in your application</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="develop_a_jax_ws_client_application"/>Develop a JAX-WS Client Application</h2></div></div></div><p>
					The client communicates with, and requests work from, the JAX-WS endpoint, which is deployed in the Java Enterprise Edition 7 container. For detailed information about the classes, methods, and other implementation details mentioned below, see the relevant sections of the Javadocs bundle included with JBoss EAP.
				</p><h4><a id="overview"/>Overview</h4><p>
					A <code class="literal">Service</code> is an abstraction which represents a WSDL service. A WSDL service is a collection of related ports, each of which includes a port type bound to a particular protocol and a particular endpoint address.
				</p><p>
					Usually, the Service is generated when the rest of the component stubs are generated from an existing WSDL contract. The WSDL contract is available via the WSDL URL of the deployed endpoint, or can be created from the endpoint source using the <code class="literal">wsprovide</code> tool in the <code class="literal"><span class="emphasis"><em>EAP_HOME</em></span>/bin/</code> directory.
				</p><p>
					This type of usage is referred to as the static use case. In this case, you create instances of the <code class="literal">Service</code> class which is created as one of the component stubs.
				</p><p>
					You can also create the service manually, using the <code class="literal">Service.create</code> method. This is referred to as the dynamic use case.
				</p><h4><a id="usage"/>Usage</h4><h5><a id="static_use_case"/>Static Use Case</h5><p>
					The static use case for a JAX-WS client assumes that you already have a WSDL contract. This might be generated by an external tool or generated by using the correct JAX-WS annotations when you create your JAX-WS endpoint.
				</p><p>
					To generate your component stubs, you use the <code class="literal">wsconsume</code> tool included in <code class="literal"><span class="emphasis"><em>EAP_HOME</em></span>/bin</code>. The tool takes the WSDL URL or file as a parameter, and generates multiple files, structured in a directory tree. The source and class files representing your <code class="literal">Service</code> are named <code class="literal">_Service.java</code> and <code class="literal">_Service.class</code>, respectively.
				</p><p>
					The generated implementation class has two public constructors, one with no arguments and one with two arguments. The two arguments represent the WSDL location (a <code class="literal">java.net.URL</code>) and the service name (a <code class="literal">javax.xml.namespace.QName</code>) respectively.
				</p><p>
					The no-argument constructor is the one used most often. In this case the WSDL location and service name are those found in the WSDL. These are set implicitly from the <code class="literal">@WebServiceClient</code> annotation that decorates the generated class.
				</p><pre class="programlisting">@WebServiceClient(name="StockQuoteService", targetNamespace="http://example.com/stocks", wsdlLocation="http://example.com/stocks.wsdl")
public class StockQuoteService extends javax.xml.ws.Service
{
   public StockQuoteService() {
      super(new URL("http://example.com/stocks.wsdl"), new QName("http://example.com/stocks", "StockQuoteService"));
   }

   public StockQuoteService(String wsdlLocation, QName serviceName) {
      super(wsdlLocation, serviceName);
   }
   ...
}</pre><p>
					For details about how to obtain a port from the service and how to invoke an operation on the port, see <a class="link" href="developing_jax_ws_web_services.html#dynamic_proxy" title="Dynamic Proxy">Dynamic Proxy</a>. For details about how to work with the XML payload directly or with the XML representation of the entire SOAP message, see <a class="link" href="developing_jax_ws_web_services.html#dispatch" title="Dispatch">Dispatch</a>.
				</p><h5><a id="dynamic_use_case"/>Dynamic Use Case</h5><p>
					In the dynamic case, no stubs are generated automatically. Instead, a web service client uses the <code class="literal">Service.create</code> method to create <code class="literal">Service</code> instances. The following code fragment illustrates this process.
				</p><pre class="programlisting">URL wsdlLocation = new URL("http://example.org/my.wsdl");
QName serviceName = new QName("http://example.org/sample", "MyService");
Service service = Service.create(wsdlLocation, serviceName);</pre><h5><a id="handler_resolver"/>Handler Resolver</h5><p>
					JAX-WS provides a flexible plug-in framework for message processing modules, known as handlers. These handlers extend the capabilities of a JAX-WS runtime system. A <code class="literal">Service</code> instance provides access to a <code class="literal">HandlerResolver</code> via a pair of <code class="literal">getHandlerResolver</code> and <code class="literal">setHandlerResolver</code> methods that can configure a set of handlers on a per-service, per-port or per-protocol binding basis.
				</p><p>
					When a <code class="literal">Service</code> instance creates a proxy or a <code class="literal">Dispatch</code> instance, the handler resolver currently registered with the service creates the required handler chain. Subsequent changes to the handler resolver configured for a <code class="literal">Service</code> instance do not affect the handlers on previously created proxies or <code class="literal">Dispatch</code> instances.
				</p><h5><a id="executor"/>Executor</h5><p>
					<code class="literal">Service</code> instances can be configured with a <code class="literal">java.util.concurrent.Executor</code>. The <code class="literal">Executor</code> invokes any asynchronous callbacks requested by the application. The <code class="literal">setExecutor</code> and <code class="literal">getExecutor</code> methods of <code class="literal">Service</code> can modify and retrieve the <code class="literal">Executor</code> configured for a service.
				</p><h4><a id="dynamic_proxy"/>Dynamic Proxy</h4><p>
					A dynamic proxy is an instance of a client proxy using one of the <code class="literal">getPort</code> methods provided in the <code class="literal">Service</code>. The <code class="literal">portName</code> specifies the name of the WSDL port the service uses. The <code class="literal">serviceEndpointInterface</code> specifies the service endpoint interface supported by the created dynamic proxy instance.
				</p><pre class="programlisting">public &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
public &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)</pre><p>
					The Service Endpoint Interface is usually generated using the <code class="literal">wsconsume</code> tool, which parses the WSDL and creates Java classes from it.
				</p><p>
					A typed method, which returns a port, is also provided. These methods also return dynamic proxies that implement the SEI. See the following example.
				</p><pre class="programlisting">@WebServiceClient(name = "TestEndpointService", targetNamespace = "http://org.jboss.ws/wsref",
   wsdlLocation = "http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl")

public class TestEndpointService extends Service {
    ...

    public TestEndpointService(URL wsdlLocation, QName serviceName) {
        super(wsdlLocation, serviceName);
    }

    @WebEndpoint(name = "TestEndpointPort")
    public TestEndpoint getTestEndpointPort() {
        return (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
    }
}</pre><h4><a id="webserviceref"/>@WebServiceRef</h4><p>
					The <code class="literal">@WebServiceRef</code> annotation declares a reference to a web service. It follows the resource pattern shown by the <code class="literal">javax.annotation.Resource</code> annotation defined in <a class="link" href="http://www.jcp.org/en/jsr/summary?id=250">JSR 250</a>.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							You can use it to define a reference whose type is a generated <code class="literal">Service</code> class. In this case, the type and value element each refer to the generated <code class="literal">Service</code> class type. Moreover, if the reference type can be inferred by the field or method declaration the annotation is applied to, the type and value elements might, but are not required to, have the default value of <code class="literal">Object.class</code>. If the type cannot be inferred, then at least the type element must be present with a non-default value.
						</li><li class="listitem"><p class="simpara">
							You can use it to define a reference whose type is an SEI. In this case, the type element might (but is not required to) be present with its default value if the type of the reference can be inferred from the annotated field or method declaration. However, the value element must always be present and refer to a generated service class type, which is a subtype of <code class="literal">javax.xml.ws.Service</code>. The <code class="literal">wsdlLocation</code> element, if present, overrides the WSDL location information specified in the <code class="literal">@WebService</code> annotation of the referenced generated service class.
						</p><pre class="programlisting">public class EJB3Client implements EJB3Remote
{
   @WebServiceRef
   public TestEndpointService service4;

   @WebServiceRef
   public TestEndpoint port3;
 }</pre></li></ul></div><h4><a id="dispatch"/>Dispatch</h4><p>
					XML web services use XML messages for communication between the endpoint, which is deployed in the Java EE container, and any clients. The XML messages use an XML language called Simple Object Access Protocol (SOAP). The JAX-WS API provides the mechanisms for the endpoint and clients to each be able to send and receive SOAP messages. Marshalling is the process of converting a Java Object into a SOAP XML message. Unmarshalling is the process of converting the SOAP XML message back into a Java Object.
				</p><p>
					In some cases, you need access to the raw SOAP messages themselves, rather than the result of the conversion. The <code class="literal">Dispatch</code> class provides this functionality. <code class="literal">Dispatch</code> operates in one of two usage modes, which are identified by one of the following constants.
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">javax.xml.ws.Service.Mode.MESSAGE</code> - This mode directs client applications to work directly with protocol-specific message structures. When used with a SOAP protocol binding, a client application works directly with a SOAP message.
						</li><li class="listitem">
							<code class="literal">javax.xml.ws.Service.Mode.PAYLOAD</code> - This mode causes the client to work with the payload itself. For instance, if it is used with a SOAP protocol binding, a client application would work with the contents of the SOAP body rather than the entire SOAP message.
						</li></ul></div><p>
					<code class="literal">Dispatch</code> is a low-level API which requires clients to structure messages or payloads as XML, with strict adherence to the standards of the individual protocol and a detailed knowledge of message or payload structure. <code class="literal">Dispatch</code> is a generic class which supports input and output of messages or message payloads of any type.
				</p><pre class="programlisting">Service service = Service.create(wsdlURL, serviceName);
Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);

String payload = "&lt;ns1:ping xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
dispatch.invokeOneWay(new StreamSource(new StringReader(payload)));

payload = "&lt;ns1:feedback xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
Source retObj = (Source)dispatch.invoke(new StreamSource(new StringReader(payload)));</pre><h4><a id="asynchronous_invocations"/>Asynchronous Invocations</h4><p>
					The <code class="literal">BindingProvider</code> interface represents a component that provides a protocol binding which clients can use. It is implemented by proxies and is extended by the <code class="literal">Dispatch</code> interface.
				</p><p>
					<code class="literal">BindingProvider</code> instances might provide asynchronous operation capabilities. Asynchronous operation invocations are decoupled from the <code class="literal">BindingProvider</code> instance at invocation time. The response context is not updated when the operation completes. Instead, a separate response context is made available using the <code class="literal">Response</code> interface.
				</p><pre class="programlisting">public void testInvokeAsync() throws Exception {
   URL wsdlURL = new URL("http://" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
   QName serviceName = new QName(targetNS, "TestEndpointService");
   Service service = Service.create(wsdlURL, serviceName);
   TestEndpoint port = service.getPort(TestEndpoint.class);
   Response response = port.echoAsync("Async");
   // access future
   String retStr = (String) response.get();
   assertEquals("Async", retStr);
}</pre><h4><a id="oneway_invocations"/>@Oneway Invocations</h4><p>
					The <code class="literal">@Oneway</code> annotation indicates that the given web method takes an input message but returns no output message. Usually, a <code class="literal">@Oneway</code> method returns the thread of control to the calling application before the business method is executed.
				</p><pre class="programlisting">@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class PingEndpointImpl {
   private static String feedback;

   @WebMethod
   @Oneway
   public void ping() {
      log.info("ping");
      feedback = "ok";
   }

   @WebMethod
   public String feedback() {
      log.info("feedback");
      return feedback;
   }
}</pre><h4><a id="timeout_configuration"/>Timeout Configuration</h4><p>
					Two different properties control the timeout behavior of the HTTP connection and the timeout of a client which is waiting to receive a message. The first is <code class="literal">javax.xml.ws.client.connectionTimeout</code> and the second is <code class="literal">javax.xml.ws.client.receiveTimeout</code>. Each is expressed in milliseconds, and the correct syntax is shown below.
				</p><pre class="programlisting">public void testConfigureTimeout() throws Exception {
   //Set timeout until a connection is established
   ((BindingProvider)port).getRequestContext().put("javax.xml.ws.client.connectionTimeout", "6000");

   //Set timeout until the response is received
   ((BindingProvider) port).getRequestContext().put("javax.xml.ws.client.receiveTimeout", "1000");

   port.echo("testTimeout");
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configure_web_services_options"/>Configuring the Web Services Subsystem</h1></div></div></div><p>
				JBossWS components handle the processing of web service endpoints and are provided to JBoss EAP through the <code class="literal">webservices</code> subsystem. The subsystem supports the configuration of published endpoint addresses and endpoint handler chains.
			</p><p>
				A default <code class="literal">webservices</code> subsystem is provided in the server’s domain and standalone configuration files. It contains several predefined endpoint and client configurations.
			</p><pre class="programlisting">&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
  &lt;wsdl-host&gt;${jboss.bind.address:127.0.0.1}&lt;/wsdl-host&gt;
  &lt;endpoint-config name="Standard-Endpoint-Config"/&gt;
  &lt;endpoint-config name="Recording-Endpoint-Config"&gt;
    &lt;pre-handler-chain name="recording-handlers" protocol-bindings="##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM"&gt;
      &lt;handler name="RecordingHandler" class="org.jboss.ws.common.invocation.RecordingServerHandler"/&gt;
    &lt;/pre-handler-chain&gt;
  &lt;/endpoint-config&gt;
  &lt;client-config name="Standard-Client-Config"/&gt;
&lt;/subsystem&gt;</pre><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jax_ws_endpoint_configs"/>Endpoint Configurations</h2></div></div></div><p>
					JBossWS enables extra setup configuration data to be predefined and associated with an endpoint implementation. Predefined endpoint configurations can be used for JAX-WS client and JAX-WS endpoint setup. Endpoint configurations can include JAX-WS handlers and key/value properties declarations. This feature provides a convenient way to add handlers to web service endpoints and to set key/value properties that control JBossWS and Apache CXF internals.
				</p><p>
					The <code class="literal">webservices</code> subsystem allows you to define named sets of endpoint configuration data. Each endpoint configuration must have a unique name within the subsystem. The <code class="literal">org.jboss.ws.api.annotation.EndpointConfig</code> annotation can then be used to assign an endpoint configuration to a JAX-WS implementation in a deployed application. See <a class="link" href="developing_jax_ws_web_services.html#ws_endpoint_assign_config" title="Assigning Client and Endpoint Configurations">Assigning a Configuration</a> for more information on assigning endpoint configurations.
				</p><p>
					There are two predefined endpoint configurations in the default JBoss EAP configuration:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							<code class="literal">Standard-Endpoint-Config</code> is the endpoint configuration used for any endpoint that does not have an explicitly-assigned endpoint configuration.
						</li><li class="listitem">
							<code class="literal">Recording-Endpoint-Config</code> is an example of custom endpoint configuration that includes a recording handler.
						</li></ul></div><h4><a id="add_an_endpoint_configuration"/>Add an Endpoint Configuration</h4><p>
					You can add a new endpoint configuration using the management CLI.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config:add</pre><h4><a id="configure_an_endpoint_configuration"/>Configure an Endpoint Configuration</h4><p>
					You can add key/value property declarations for the endpoint configuration using the management CLI.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=Standard-Endpoint-Config/property=<span class="emphasis"><em>PROPERTY_NAME</em></span>:add(value=<span class="emphasis"><em>PROPERTY_VALUE</em></span>)</pre><p>
					You can also configure <a class="link" href="developing_jax_ws_web_services.html#jax_ws_handler_chains" title="Handler Chains">handler chains</a> and <a class="link" href="developing_jax_ws_web_services.html#jax_ws_handlers" title="Handlers">handlers</a> for these endpoint configurations.
				</p><h4><a id="remove_an_endpoint_configuration"/>Remove an Endpoint Configuration</h4><p>
					You can remove a endpoint configuration using the management CLI.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config:remove</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jax_ws_handler_chains"/>Handler Chains</h2></div></div></div><p>
					Each endpoint configuration can be associated with <code class="literal">PRE</code> or <code class="literal">POST</code> handler chains. Each handler chain may include JAX-WS-compliant handlers to perform additional processing on messages. For outbound messages, <code class="literal">PRE</code> handler chain handlers are executed before any handler attached to the endpoints using standard JAX-WS means, such as the <code class="literal">@HandlerChain</code> annotation. <code class="literal">POST</code> handler chain handlers are executed after usual endpoint handlers. For inbound messages, the opposite applies.
				</p><div class="title"><strong>Server Outbound Messages</strong></div><p>
						
</p><pre class="screen">Endpoint --&gt; PRE Handlers --&gt; Endpoint Handlers --&gt; POST Handlers --&gt; ... --&gt; Client</pre><p>

					</p><div class="title"><strong>Server Inbound Messages</strong></div><p>
						
</p><pre class="screen">Client --&gt; ... --&gt; POST Handlers --&gt; Endpoint Handlers --&gt; PRE Handlers --&gt; Endpoint</pre><p>

					</p><h4><a id="add_a_handler_chain"/>Add a Handler Chain</h4><p>
					You can add a <code class="literal">POST</code> handler chain to an endpoint configuration using the following management CLI command.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/post-handler-chain=my-post-handler-chain:add</pre><p>
					You can add a <code class="literal">PRE</code> handler chain to an endpoint configuration using the following management CLI command.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/pre-handler-chain=my-pre-handler-chain:add</pre><h4><a id="configure_a_handler_chain"/>Configure a Handler Chain</h4><p>
					Use the <code class="literal">protocol-bindings</code> attribute to set which protocols trigger the handler chain to start.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/post-handler-chain=my-post-handler-chain:write-attribute(name=protocol-bindings,value=##SOAP11_HTTP)</pre><p>
					See the <a class="link" href="developing_jax_ws_web_services.html#jax_ws_handlers" title="Handlers">handlers</a> section for information on configuring handlers for a handler chain.
				</p><h4><a id="remove_a_handler_chain"/>Remove a Handler Chain</h4><p>
					You can remove a handler chain using the management CLI.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/post-handler-chain=my-post-handler-chain:remove</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jax_ws_handlers"/>Handlers</h2></div></div></div><p>
					A JAX-WS handler is added to a handler chain and specifies the fully-qualified name of the handler class. When the endpoint is deployed, an instance of that class is created for each referencing deployment. Either the deployment class loader or the class loader for the <code class="literal">org.jboss.as.webservices.server.integration</code> module must be able to load the handler class.
				</p><p>
					See the <a class="link" href="https://access.redhat.com/webassets/avalon/d/red_hat_jboss_enterprise_application_platform/7.2/javadocs/javax/xml/ws/handler/Handler.html">Handler</a> Javadocs for a listing of the available handlers.
				</p><h4><a id="add_a_handler"/>Add a Handler</h4><p>
					You can add a handler to a handler chain using the following management CLI command. You must provide the class name of the handler.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/post-handler-chain=my-post-handler-chain/handler=my-handler:add(class="com.arjuna.webservices11.wsarj.handler.InstanceIdentifierInHandler")</pre><h4><a id="configure_a_handler"/>Configure a Handler</h4><p>
					You can update the class for a handler using the management CLI.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/post-handler-chain=my-post-handler-chain/handler=my-handler:add(class="org.jboss.ws.common.invocation.RecordingServerHandler")</pre><h4><a id="remove_a_handler"/>Remove a Handler</h4><p>
					You can remove a handler using the management CLI.
				</p><pre class="screen">/subsystem=webservices/endpoint-config=My-Endpoint-Config/post-handler-chain=my-post-handler-chain/handler=my-handler:</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="published_endpoint_addresses"/>Published Endpoint Addresses</h2></div></div></div><p>
					The rewriting of the <code class="literal">&lt;soap:address&gt;</code> element of endpoints published in WSDL contracts is supported. This feature is useful for controlling the server address that is advertised to clients for each endpoint.
				</p><p>
					The following table lists the attributes that can be configured for this feature.
				</p><div class="informaltable"><table border="1" width="100%"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Name</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
									modify-wsdl-address
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This boolean enables and disables the address rewrite functionality.
								</p>
								 <p>
									When <code class="literal">modify-wsdl-address</code> is set to <code class="literal">true</code> and the content of <code class="literal">&lt;soap:address&gt;</code> is a valid URL, JBossWS rewrites the URL using the values of <code class="literal">wsdl-host</code> and <code class="literal">wsdl-port</code> or <code class="literal">wsdl-secure-port</code>.
								</p>
								 <p>
									When <code class="literal">modify-wsdl-address</code> is set to <code class="literal">false</code> and the content of <code class="literal">&lt;soap:address&gt;</code> is a valid URL, JBossWS does not rewrite the URL. The <code class="literal">&lt;soap:address&gt;</code> URL is used.
								</p>
								 <p>
									When the content of <code class="literal">&lt;soap:address&gt;</code> is not a valid URL, JBossWS rewrites it no matter what the setting of <code class="literal">modify-wsdl-address</code>. If <code class="literal">modify-wsdl-address</code> is set to <code class="literal">true</code> and <code class="literal">wsdl-host</code> is not defined or explicitly set to <code class="literal">jbossws.undefined.host</code>, the content of <code class="literal">&lt;soap:address&gt;</code> URL is used. JBossWS uses the requester’s host when rewriting the <code class="literal">&lt;soap:address&gt;</code>.
								</p>
								 <p>
									When <code class="literal">modify-wsdl-address</code> is not defined JBossWS uses a default value of <code class="literal">true</code>.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									wsdl-host
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									The host name or IP address to be used for rewriting <code class="literal">&lt;soap:address&gt;</code>. If <code class="literal">wsdl-host</code> is set to <code class="literal">jbossws.undefined.host</code>, JBossWS uses the requester’s host when rewriting the <code class="literal">&lt;soap:address&gt;</code>. When <code class="literal">wsdl-host</code> is not defined JBossWS uses a default value of <code class="literal">jbossws.undefined.host</code>.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									wsdl-path-rewrite-rule
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This string defines a SED substitution command, for example <code class="literal">s/regexp/replacement/g</code>, that JBossWS executes against the path component of each <code class="literal">&lt;soap:address&gt;</code> URL published from the server. When <code class="literal">wsdl-path-rewrite-rule</code> is not defined, JBossWS retains the original path component of each <code class="literal">&lt;soap:address&gt;</code> URL. When <code class="literal">modify-wsdl-address</code> is set to <code class="literal">false</code> this element is ignored.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									wsdl-port
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Set this property to explicitly define the HTTP port that will be used for rewriting the SOAP address. Otherwise the HTTP port will be identified by querying the list of installed HTTP connectors.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									wsdl-secure-port
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									Set this property to explicitly define the HTTPS port that will be used for rewriting the SOAP address. Otherwise the HTTPS port will be identified by querying the list of installed HTTPS connectors.
								</p>
								 </td></tr><tr><td style="text-align: left" valign="top"> <p>
									wsdl-uri-scheme
								</p>
								 </td><td style="text-align: left" valign="top"> <p>
									This property explicitly sets the URI scheme to use for rewriting <code class="literal">&lt;soap:address&gt;</code>. Valid values are <code class="literal">http</code> and <code class="literal">https</code>. This configuration overrides the scheme computed by processing the endpoint even if a transport guarantee is specified. The provided values for <code class="literal">wsdl-port</code> and <code class="literal">wsdl-secure-port</code>, or their default values, are used depending on the specified scheme.
								</p>
								 </td></tr></tbody></table></div><p>
					You can use the management CLI to update these attributes. For example:
				</p><pre class="screen">/subsystem=webservices:write-attribute(name=wsdl-uri-scheme, value=https)</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="runtime_information"/>Viewing Runtime Information</h2></div></div></div><p>
					Each web service endpoint is exposed through the deployment that provides the endpoint implementation. Each endpoint can be queried as a deployment resource. Each web service endpoint specifies a web context and a WSDL URL. You can access this runtime information using the management CLI or the management console.
				</p><p>
					The following management CLI command shows the details of the <code class="literal">TestService</code> endpoint from the <code class="literal">jaxws-samples-handlerchain.war</code> deployment.
				</p><pre class="screen">/deployment="jaxws-samples-handlerchain.war"/subsystem=webservices/endpoint="jaxws-samples-handlerchain:TestService":read-resource(include-runtime=true)
{
    "outcome" =&gt; "success",
    "result" =&gt; {
        "average-processing-time" =&gt; 23L,
        "class" =&gt; "org.jboss.test.ws.jaxws.samples.handlerchain.EndpointImpl",
        "context" =&gt; "jaxws-samples-handlerchain",
        "fault-count" =&gt; 0L,
        "max-processing-time" =&gt; 23L,
        "min-processing-time" =&gt; 23L,
        "name" =&gt; "TestService",
        "request-count" =&gt; 1L,
        "response-count" =&gt; 1L,
        "total-processing-time" =&gt; 23L,
        "type" =&gt; "JAXWS_JSE",
        "wsdl-url" =&gt; "http://localhost:8080/jaxws-samples-handlerchain?wsdl"
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
						Using the <code class="literal">include-runtime=true</code> flag on the <code class="literal">read-resource</code> operation returns runtime statistics in the result. However, the collection of statistics for web service endpoints is disabled by default. You can enable statistics for web service endpoints using the following management CLI command.
					</p><pre class="screen">/subsystem=webservices:write-attribute(name=statistics-enabled,value=true)</pre></div><p>
					You can also view runtime information for web services endpoints from the <span class="strong"><strong>Runtime</strong></span> tab of the management console by selecting the applicable server, selecting <span class="strong"><strong>Webservices</strong></span>, then choosing the endpoint.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ws_endpoint_assign_config"/>Assigning Client and Endpoint Configurations</h1></div></div></div><p>
				Client and endpoint configurations can be assigned in the following ways:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Explicit assignment through annotations, for endpoints, or API programmatic usage, for clients.
					</li><li class="listitem">
						Automatic assignment of configurations from default descriptors.
					</li><li class="listitem">
						Automatic assignment of configurations from the container.
					</li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ws_endpoint_explict_config_assignment"/>Explicit Configuration Assignment</h2></div></div></div><p>
					The explicit configuration assignment is meant for developers that know in advance their endpoint or client has to be set up according to a specified configuration. The configuration is coming from either a descriptor that is included in the application deployment, or is included in the <code class="literal">webservices</code> subsystem.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_endpoint_config_deployment_desc"/>Configuration Deployment Descriptor</h3></div></div></div><p>
						Java EE archives that can contain JAX-WS client and endpoint implementations may also contain predefined client and endpoint configuration declarations. All endpoint or client configuration definitions for a given archive must be provided in a single deployment descriptor file, which must be an implementation of the schema that can be found at <code class="literal">EAP_HOME/docs/schema/jbossws-jaxws-config_4_0.xsd</code>. Many endpoint or client configurations can be defined in the deployment descriptor file. Each configuration must have a name that is unique within the server on which the application is deployed. The configuration name cannot be referred to by endpoint or client implementations outside the application.
					</p><div class="title"><strong>Example: Descriptor with Two Endpoint Configurations</strong></div><p>
							
</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.jbws3282.Endpoint4Impl&lt;/config-name&gt;
    &lt;pre-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Log Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.LogHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/pre-handler-chains&gt;
    &lt;post-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Routing Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.RoutingHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/endpoint-config&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;EP6-config&lt;/config-name&gt;
    &lt;post-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Authorization Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.jbws3282.AuthorizationHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre><p>

						</p><p>
						Similarly, a client configuration can be specified in descriptors, which is still implementing the schema mentioned above:
					</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;client-config&gt;
    &lt;config-name&gt;Custom Client Config&lt;/config-name&gt;
    &lt;pre-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Routing Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.RoutingHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Custom Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.CustomHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/pre-handler-chains&gt;
  &lt;/client-config&gt;
  &lt;client-config&gt;
    &lt;config-name&gt;Another Client Config&lt;/config-name&gt;
    &lt;post-handler-chains&gt;
      &lt;javaee:handler-chain&gt;
        &lt;javaee:handler&gt;
          &lt;javaee:handler-name&gt;Routing Handler&lt;/javaee:handler-name&gt;
          &lt;javaee:handler-class&gt;org.jboss.test.ws.jaxws.clientConfig.RoutingHandler&lt;/javaee:handler-class&gt;
        &lt;/javaee:handler&gt;
      &lt;/javaee:handler-chain&gt;
    &lt;/post-handler-chains&gt;
  &lt;/client-config&gt;
&lt;/jaxws-config&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_endpoint_config_app_server"/>Application Server Configuration</h3></div></div></div><p>
						JBoss EAP allows declaring JBossWS client and server predefined configurations in the <code class="literal">webservices</code> subsystem. As a result it is possible to declare server-wide handlers to be added to the chain of each endpoint or client assigned to a given configuration.
					</p><h5><a id="standard_configuration"/>Standard Configuration</h5><p>
						Clients running in the same JBoss EAP instance, as well as endpoints, are assigned standard configurations by default. The defaults are used unless different a configuration is set. This enables administrators to tune the default handler chains for client and endpoint configurations. The names of the default client and endpoint configurations used in the <code class="literal">webservices</code> subsystem are <code class="literal">Standard-Client-Config</code> and <code class="literal">Standard-Endpoint-Config</code>.
					</p><h5><a id="handlers_classloading"/>Handlers Classloading</h5><p>
						When setting a server-wide handler, the handler class needs to be available through each ws deployment classloader. As a result proper module dependencies may need to be specified in the deployments that are going to use a given predefined configuration. One way to ensure the proper module dependencies are specified in the deployment is to add a dependency to the module containing the handler class in one of the modules which are already automatically set as dependencies to any deployment, for instance <code class="literal">org.jboss.ws.spi</code>.
					</p><h5><a id="example_configuration"/>Example Configuration</h5><div class="title"><strong>Example: Default Subsystem Configuration</strong></div><p>
							
</p><pre class="programlisting">&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
    &lt;!-- ... --&gt;
    &lt;endpoint-config name="Standard-Endpoint-Config"/&gt;
    &lt;endpoint-config name="Recording-Endpoint-Config"&gt;
        &lt;pre-handler-chain name="recording-handlers" protocol-bindings="##SOAP11_HTTP ##SOAP11_HTTP_MTOM ##SOAP12_HTTP ##SOAP12_HTTP_MTOM"&gt;
            &lt;handler name="RecordingHandler" class="org.jboss.ws.common.invocation.RecordingServerHandler"/&gt;
        &lt;/pre-handler-chain&gt;
    &lt;/endpoint-config&gt;
    &lt;client-config name="Standard-Client-Config"/&gt;
&lt;/subsystem&gt;</pre><p>

						</p><p>
						A configuration file for a deployment specific ws-security endpoint setup:
					</p><pre class="programlisting">&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:javaee="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom WS-Security Endpoint&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.properties&lt;/property-name&gt;
      &lt;property-value&gt;bob.properties&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.signature.username&lt;/property-name&gt;
      &lt;property-value&gt;bob&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.encryption.username&lt;/property-name&gt;
      &lt;property-value&gt;alice&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;ws-security.callback-handler&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.samples.wsse.policy.basic.KeystorePasswordCallback&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre><p>
						JBoss EAP default configuration modified to default to SOAP messages schema-validation on:
					</p><pre class="programlisting">&lt;subsystem xmlns="urn:jboss:domain:webservices:2.0"&gt;
    &lt;!-- ... --&gt;
    &lt;endpoint-config name="Standard-Endpoint-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/endpoint-config&gt;
    &lt;!-- ... --&gt;
    &lt;client-config name="Standard-Client-Config"&gt;
        &lt;property name="schema-validation-enabled" value="true"/&gt;
    &lt;/client-config&gt;
&lt;/subsystem&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_endpoint_config_annotation"/>EndpointConfig Annotation</h3></div></div></div><p>
						Once a configuration is available to a given application, the <code class="literal">org.jboss.ws.api.annotation.EndpointConfig</code> annotation is used to assign an endpoint configuration to a JAX-WS endpoint implementation. When you assign a configuration that is defined in the <code class="literal">webservices</code> subsystem, you only need to specify the configuration name. When you assign a configuration that is defined in the application, you need to specify the relative path to the deployment descriptor and the configuration name.
					</p><div class="title"><strong>Example: EndpointConfig Annotation</strong></div><p>
							
</p><pre class="programlisting">@EndpointConfig(configFile = "WEB-INF/my-endpoint-config.xml", configName = "Custom WS-Security Endpoint")
public class ServiceImpl implements ServiceIface {
   public String sayHello() {
      return "Secure Hello World!";
   }
}</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_endpoint_config_feature"/>JAX-WS Feature</h3></div></div></div><p>
						You can also use <code class="literal">org.jboss.ws.api.configuration.ClientConfigFeature</code> to set a configuration that is a JAX-WS Feature extension provided by JBossWS.
					</p><pre class="programlisting">import org.jboss.ws.api.configuration.ClientConfigFeature;

Service service = Service.create(wsdlURL, serviceName);

Endpoint port = service.getPort(Endpoint.class, new ClientConfigFeature("META-INF/my-client-config.xml", "Custom Client Config"));
port.echo("Kermit");</pre><p>
						You can also set properties from the specified configuration by passing in <code class="literal">true</code> to the <code class="literal">ClientConfigFeature</code> constructor.
					</p><pre class="programlisting">Endpoint port = service.getPort(Endpoint.class, new ClientConfigFeature("META-INF/my-client-config.xml", "Custom Client Config"), true);</pre><p>
						JBossWS parses the specified configuration file, after having resolved it as a resource using the current thread context class loader. The <code class="literal"><span class="emphasis"><em>EAP_HOME</em></span>/docs/schema/jbossws-jaxws-config_4_0.xsd</code> schema defines the descriptor contents and is included in the <code class="literal">jbossws-spi</code> artifact.
					</p><p>
						If you pass in <code class="literal">null</code> for the configuration file, the configuration will be read from the current container configurations, if available.
					</p><pre class="programlisting">Endpoint port = service.getPort(Endpoint.class, new ClientConfigFeature(null, "Container Custom Client Config"));</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_endpoint_explicit_setup_api"/>Explicit Setup Through API</h3></div></div></div><p>
						Alternatively, the JBossWS API comes with facility classes that can be used for assigning configurations when building a client.
					</p><h5><a id="handlers"/>Handlers</h5><p>
						JAX-WS handlers are read from client configurations as follows.
					</p><pre class="programlisting">import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class);
BindingProvider bp = (BindingProvider)port;

ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config");
port.echo("Kermit");</pre><p>
						You can also use the <code class="literal">ClientConfigUtil</code> utility class to set up the handlers.
					</p><pre class="programlisting">ClientConfigUtil.setConfigHandlers(bp, "META-INF/my-client-config.xml", "Custom Client Config");</pre><p>
						The default <code class="literal">ClientConfigurer</code> implementation parses the specified configuration file, after having resolved it as a resource using the current thread context class loader. The <code class="literal">EAP_HOME/docs/schema/jbossws-jaxws-config_4_0.xsd</code> schema defines the descriptor contents and is included in the <code class="literal">jbossws-spi</code> artifact.
					</p><p>
						If you pass in <code class="literal">null</code> for the configuration file, the configuration will be read from the current container configurations, if available.
					</p><pre class="programlisting">ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigHandlers(bp, null, "Container Custom Client Config");</pre><h5><a id="properties"/>Properties</h5><p>
						Similarly, properties are read from client configurations as follows.
					</p><pre class="programlisting">import org.jboss.ws.api.configuration.ClientConfigUtil;
import org.jboss.ws.api.configuration.ClientConfigurer;

Service service = Service.create(wsdlURL, serviceName);
Endpoint port = service.getPort(Endpoint.class);

ClientConfigUtil.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config");
port.echo("Kermit");</pre><p>
						You can also use the <code class="literal">ClientConfigUtil</code> utility class to set up the properties.
					</p><pre class="programlisting">ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigProperties(port, "META-INF/my-client-config.xml", "Custom Client Config");</pre><p>
						The default <code class="literal">ClientConfigurer</code> implementation parses the specified configuration file, after having resolved it as a resource using the current thread context class loader. The <code class="literal">EAP_HOME/docs/schema/jbossws-jaxws-config_4_0.xsd</code> schema defines the descriptor contents and is included in the <code class="literal">jbossws-spi</code> artifact.
					</p><p>
						If you pass in <code class="literal">null</code> for the configuration file, the configuration will be read from the current container configurations, if available.
					</p><pre class="programlisting">ClientConfigurer configurer = ClientConfigUtil.resolveClientConfigurer();
configurer.setConfigProperties(port, null, "Container Custom Client Config");</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ws_endpoint_automatic_config_default_descriptors"/>Automatic Configuration from Default Descriptors</h2></div></div></div><p>
					In some cases, the application developer might not be aware of the configuration that will need to be used for its client and endpoint implementation. In other cases, explicit usage of the JBossWS API might not be accepted because it is a compile-time dependency. To cope with such scenarios, JBossWS allows including default client, <code class="literal">jaxws-client-config.xml</code>, and endpoint, <code class="literal">jaxws-endpoint-config.xml</code>, descriptors within the application in its root directory. These are parsed for getting configurations whenever a configuration file name is not specified.
				</p><pre class="programlisting">&lt;config-file&gt;WEB-INF/jaxws-endpoint-config.xml&lt;/config-file&gt;</pre><p>
					If the configuration name is not specified, JBossWS automatically looks for a configuration named as:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The fully qualified name (FQN) of the endpoint implementation class, in case of JAX-WS endpoints.
						</li><li class="listitem">
							The FQN of the service endpoint interface, in case of JAX-WS clients.
						</li></ul></div><p>
					No automatic configuration name is selected for <code class="literal">Dispatch</code> clients.
				</p><p>
					For example, an endpoint implementation class <code class="literal">org.foo.bar.EndpointImpl</code>, for which no predefined configuration is explicitly set, will cause JBossWS to look for a <code class="literal">org.foo.bar.EndpointImpl</code> named configuration within a <code class="literal">jaxws-endpoint-config.xml</code> descriptor in the root of the application deployment. Similarly, on the client side, a client proxy implementing <code class="literal">org.foo.bar.Endpoint</code> interface will have the setup read from a <code class="literal">org.foo.bar.Endpoint</code> named configuration in the <code class="literal">jaxws-client-config.xml</code> descriptor.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ws_endpoint_automatic_config_assignemnt_container"/>Automatic Configuration Assignment from Container</h2></div></div></div><p>
					JBossWS falls back to getting predefined configurations from the container whenever no explicit configuration has been provided and the default descriptors are either not available or do not contain relevant configurations. This behavior gives additional control on the JAX-WS client and endpoint setup to administrators since the container can be managed independently from the deployed applications.
				</p><p>
					JBossWS accesses the <code class="literal">webservices</code> subsystem for an explicitly named configuration. The default configuration names used are:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The fully qualified name of the endpoint implementation class, in case of JAX-WS endpoints.
						</li><li class="listitem">
							The fully qualified name of the service endpoint interface, in case of JAX-WS clients.
						</li></ul></div><p>
					<code class="literal">Dispatch</code> clients are not automatically configured. If no configuration is found using names computed as above, the <code class="literal">Standard-Client-Config</code> and <code class="literal">Standard-Endpoint-Config</code> configurations are used for clients and endpoints respectively.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="setting_module_depencies_for_web_service_applications"/>Setting Module Dependencies for Web Service Applications</h1></div></div></div><p>
				JBoss EAP web services are delivered as a set of modules and libraries, including the <code class="literal">org.jboss.as.webservices.*</code> and <code class="literal">org.jboss.ws.*</code> modules. You should not need to change these modules.
			</p><p>
				With JBoss EAP you cannot directly use JBossWS implementation classes unless you explicitly set a dependency to the corresponding module. You declare the module dependencies that you want to be added to the deployment.
			</p><p>
				The JBossWS APIs are available by default whenever the <code class="literal">webservices</code> subsystem is available. You can use them without creating an explicit dependencies declaration for those modules.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using_manifest_mf"/>Using MANIFEST.MF</h2></div></div></div><p>
					To configure deployment dependencies, add them to the <code class="literal">MANIFEST.MF</code> file. For example:
				</p><pre class="screen">Manifest-Version: 1.0
Dependencies: org.jboss.ws.cxf.jbossws-cxf-client services export,foo.bar</pre><p>
					This <code class="literal">MANIFEST.MF</code> file declares dependencies on the <code class="literal">org.jboss.ws.cxf.jbossws-cxf-client</code> and <code class="literal">foo.bar</code> modules. For more information on declaring dependencies in a <code class="literal">MANIFEST.MF</code> file, including the <code class="literal">export</code> and <code class="literal">services</code> options, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/development_guide/#add_dependency_manifest">Add a Dependency Configuration to MANIFEST.MF</a> in the JBoss EAP <span class="emphasis"><em>Development Guide</em></span>.
				</p><p>
					When using annotations on the endpoints and handlers, for example, Apache CXF endpoints and handlers, add the proper module dependency in your manifest file. If you skip this step, your annotations are not picked up and are completely, silently ignored.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using_jaxb"/>Using JAXB</h3></div></div></div><p>
						To successfully and directly use JAXB contexts in your client or endpoint running in-container, set up a JAXB implementation. For example, set the following dependency:
					</p><pre class="screen">Dependencies: com.sun.xml.bind services export</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="using_apache_cxf"/>Using Apache CXF</h3></div></div></div><p>
						To use Apache CXF APIs and implementation classes, add a dependency to the <code class="literal">org.apache.cxf</code> (API) module or <code class="literal">org.apache.cxf.impl</code> (implementation) module. For example:
					</p><pre class="screen">Dependencies: org.apache.cxf services</pre><p>
						The dependency is purely Apache CXF without any JBossWS customizations or additional extensions. For this reason, a client-side aggregation module is available with all the web service dependencies that you might need.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="client_side_web_services_aggregation_module"/>Client-side Web Services Aggregation Module</h3></div></div></div><p>
						When you want to use all of the web services features and functionality, you can set a dependency to the convenient client module. For example:
					</p><pre class="screen">Dependencies: org.jboss.ws.cxf.jbossws-cxf-client services</pre><p>
						The <code class="literal">services</code> option is required to enable all JBossWS features by loading JBossWS specific classes. The <code class="literal">services</code> option is almost always needed when declaring dependencies on the <code class="literal">org.jboss.ws.cxf.jbossws-cxf-client</code> and <code class="literal">org.apache.cxf</code> modules. The option affects the loading of classes through the <code class="literal">Service</code> API, which is what is used to wire most of the JBossWS components and the Apache CXF Bus extensions.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="annotation_scanning"/>Annotation Scanning</h3></div></div></div><p>
						The application server uses an annotation index for detecting JAX-WS endpoints in user deployments. When declaring web service endpoints for a class that belongs to a different module, for instance referring to it in the <code class="literal">web.xml</code> descriptor, use an <code class="literal">annotations</code> type dependency. Without that dependency your endpoints are ignored as they do not appear as annotated classes to the <code class="literal">webservices</code> subsystem.
					</p><pre class="screen">Dependencies: my.org annotations</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using_jboss_deployment_structure_xml"/>Using jboss-deployment-structure.xml</h2></div></div></div><p>
					In some circumstances, the convenient approach of setting module dependencies in the <code class="literal">MANIFEST.MF</code> file might not work. For example, setting dependencies in the <code class="literal">MANIFEST.MF</code> file does not work when importing and exporting specific resources from a given module dependency. In these scenarios, add a <code class="literal">jboss-deployment-structure.xml</code> descriptor file to your deployment and set module dependencies in it.
				</p><p>
					For more information on using <code class="literal">jboss-deployment-structure.xml</code>, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/development_guide/#add_dependency_jboss_deployment_structure">Add a Dependency Configuration to the jboss-deployment-structure.xml</a> in the JBoss EAP <span class="emphasis"><em>Development Guide</em></span>.
				</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="configuring_http_timeout"/>Configuring HTTP Timeout</h1></div></div></div><p>
				The HTTP session timeout defines the period after which an HTTP session is considered to have become invalid because there was no activity within the specified period.
			</p><p>
				The HTTP session timeout can be configured, in order of precedence, in the following places:
			</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
						Application
					</p><p class="simpara">
						You can define the HTTP session timeout in the application’s <code class="literal">web.xml</code> configuration file by adding the following configuration to the file. This value is in minutes.
					</p><pre class="programlisting">&lt;session-config&gt;
  &lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;</pre><p class="simpara">
						If you modified the WAR file, redeploy the application. If you exploded the WAR file, no further action is required because JBoss EAP automatically undeploys and redeploys the application.
					</p></li><li class="listitem"><p class="simpara">
						Server
					</p><p class="simpara">
						You can use the following management CLI command to set the default HTTP session timeout in the <code class="literal">undertow</code> subsystem. This value is in minutes.
					</p><pre class="screen">/subsystem=undertow/servlet-container=default:write-attribute(name=default-session-timeout,value=30)</pre></li><li class="listitem"><p class="simpara">
						Default
					</p><p class="simpara">
						The default HTTP session timeout is 30 minutes.
					</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ws_sec_ws"/>Securing JAX-WS Web Services</h1></div></div></div><p>
				WS-Security provides the means to secure your services beyond transport level protocols such as HTTPS. Through a number of standards, such as headers defined in the WS-Security standard, you can:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Pass authentication tokens between services.
					</li><li class="listitem">
						Encrypt messages or parts of messages.
					</li><li class="listitem">
						Sign messages.
					</li><li class="listitem">
						Timestamp messages.
					</li></ul></div><p>
				WS-Security makes use of public and private key cryptography. With public key cryptography, a user has a pair of public and private keys. These are generated using a large prime number and a key function.
			</p><p>
				The keys are related mathematically, but cannot be derived from one another. With these keys we can encrypt messages. For example, if Scott wants to send a message to Adam, he can encrypt a message using his public key. Adam can then decrypt this message using his private key. Only Adam can decrypt this message as he is the only one with the private key.
			</p><p>
				Messages can also be signed. This allows you to ensure the authenticity of the message. If Adam wants to send a message to Scott, and Scott wants to be sure that it is from Adam, Adam can sign the message using his private key. Scott can then verify that the message is from Adam by using his public key.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ws_security_applying"/>Applying Web Services Security (WS-Security)</h2></div></div></div><p>
					Web services support many real-world scenarios requiring WS-Security functionality. These scenarios include signature and encryption support through X509 certificates, authentication and authorization through username tokens, and all WS-Security configurations covered by the WS-SecurityPolicy specification.
				</p><p>
					For other WS-* features, the core of WS-Security functionality is provided through the Apache CXF engine. In addition, the JBossWS integration adds a few configuration enhancements to simplify the setup of WS-Security enabled endpoints.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_security_cxf"/>Apache CXF WS-Security Implementation</h3></div></div></div><p>
						Apache CXF features a WS-Security module that supports multiple configurations and is easily extendible.
					</p><p>
						The system is based on <span class="emphasis"><em>interceptors</em></span> that delegate to Apache WSS4J for the low-level security operations. Interceptors can be configured in different ways, either through Spring configuration files or directly using the Apache CXF client API.
					</p><p>
						Recent versions of Apache CXF introduced support for WS-SecurityPolicy, which aims at moving most of the security configuration into the service contract, through policies, so that clients can be easily configured almost completely automatically from that. This way users do not need to manually deal with configuring and installing the required interceptors; the Apache CXF WS-Policy engine internally takes care of that instead.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_security_policy_support"/>WS-Security Policy Support</h3></div></div></div><p>
						WS-SecurityPolicy describes the actions that are required to securely communicate with a service advertised in a given WSDL contract. The WSDL bindings and operations reference WS-Policy fragments with the security requirements to interact with the service. The WS-SecurityPolicy specification allows for specifying things such as asymmetric and symmetric keys, using transports (HTTPS) for encryption, which parts or headers to encrypt or sign, whether to sign then encrypt or encrypt then sign, whether to include timestamps, whether to use derived keys, or something else.
					</p><p>
						However some mandatory configuration elements are not covered by WS-SecurityPolicy because they are not meant to be public or part of the published endpoint contract. These include things such as keystore locations, and usernames and passwords. Apache CXF allows configuring these elements either through Spring XML descriptors or using the client API or annotations.
					</p><div class="table"><a id="idm140182263469776"/><p class="title"><strong>Table 3.4. Supported Configuration Properties</strong></p><div class="table-contents"><table summary="Supported Configuration Properties" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Configuration property</th><th style="text-align: left" valign="top">Description</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										ws-security.username
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The username used for <code class="literal">UsernameToken</code> policy assertions.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.password
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The password used for <code class="literal">UsernameToken</code> policy assertions. If not specified, the callback handler will be called.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.callback-handler
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The WSS4J security <code class="literal">CallbackHandler</code> that will be used to retrieve passwords for keystores and <code class="literal">UsernameToken</code>.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.signature.properties
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The properties file/object that contains the WSS4J properties for configuring the signature keystore and crypto objects.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.encryption.properties
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The properties file/object that contains the WSS4J properties for configuring the encryption keystore and crypto objects.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.signature.username
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The username or alias for the key in the signature keystore that will be used. If not specified, it uses the default alias set in the properties file. If that is also not set, and the keystore only contains a single key, that key will be used.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.encryption.username
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										The username or alias for the key in the encryption keystore that will be used. If not specified, it uses the default alias set in the properties file. If that is also not set, and the keystore only contains a single key, that key will be used. For the web service provider, the <code class="literal">useReqSigCert</code> keyword can be used to accept (encrypt) any client whose public key is in the service’s truststore (defined in <code class="literal">ws-security.encryption.properties</code>).
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.signature.crypto
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Instead of specifying the signature properties, this can point to the full WSS4J <code class="literal">Crypto</code> object. This can allow easier programmatic configuration of the crypto information.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.encryption.crypto
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Instead of specifying the encryption properties, this can point to the full WSS4J <code class="literal">Crypto</code> object. This can allow easier programmatic configuration of the crypto information.
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										ws-security.enable.streaming
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										Enable streaming (StAX based) processing of WS-Security messages.
									</p>
									 </td></tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_ws_trust"/>WS-Trust</h2></div></div></div><p>
					WS-Trust is a web service specification that defines extensions to WS-Security. It is a general framework for implementing security in a distributed system. The standard is based on a centralized Security Token Service (STS), which is capable of authenticating clients and issuing tokens containing various types of authentication and authorization data. The specification describes a protocol used for issuance, exchange, and validation of security tokens. The following specifications play an important role in the WS-Trust architecture:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							WS-SecurityPolicy 1.2
						</li><li class="listitem">
							SAML 2.0
						</li><li class="listitem">
							Username Token Profile
						</li><li class="listitem">
							X.509 Token Profile
						</li><li class="listitem">
							SAML Token Profile
						</li><li class="listitem">
							Kerberos Token Profile
						</li></ul></div><p>
					The WS-Trust extensions address the needs of applications that span multiple domains and requires the sharing of security keys. This occurs by providing a standards-based trusted third party web service (STS) to broker trust relationships between a web service requester and a web service provider. This architecture also alleviates the pain of service updates that require credential changes by providing a common location for this information. The STS is the common access point from which both the requester and provider retrieves and verifies security tokens.
				</p><p>
					There are three main components of the WS-Trust specification:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
							The Security Token Service (STS) for issuing, renewing, and validating security tokens.
						</li><li class="listitem">
							The message formats for security token requests and responses.
						</li><li class="listitem">
							The mechanisms for key exchange.
						</li></ul></div><p>
					The following section explains a basic WS-Trust scenario. For advanced scenarios, see <a class="link" href="reference_material.html#advanced_trust_scenarios" title="Advanced WS-Trust Scenarios">Advanced WS-Trust Scenarios</a>.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_trust_scenario"/>Scenario: Basic WS-Trust</h3></div></div></div><p>
						In this section we provide an example of a basic WS-Trust scenario. It comprises a web service requester (<code class="literal">ws-requester</code>), a web service provider (<code class="literal">ws-provider</code>), and a Security Token Service (STS).
					</p><p>
						The <code class="literal">ws-provider</code> requires SAML 2.0 token issued from a designated STS to be presented by the <code class="literal">ws-requester</code> using asymmetric binding. These communication requirements are declared in the WSDL of the <code class="literal">ws-provider</code>. STS requires <code class="literal">ws-requester</code> credentials to be provided in a WSS UsernameToken format request using symmetric binding. The response from STS is provided containing SAML 2.0 token. These communication requirements are declared in the WSDL of the STS.
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
								The <code class="literal">ws-requester</code> contacts the <code class="literal">ws-provider</code> and consumes its WSDL. On finding the security token issuer requirement, the <code class="literal">ws-requester</code> creates and configures the <code class="literal">STSClient</code> with the information required to generate a valid request.
							</li><li class="listitem">
								The <code class="literal">STSClient</code> contacts the STS and consumes its WSDL. The security policies are discovered. The <code class="literal">STSClient</code> creates and sends an authentication request with appropriate credentials.
							</li><li class="listitem">
								The STS verifies the credentials.
							</li><li class="listitem">
								In response, the STS issues a security token that provides proof that the <code class="literal">ws-requester</code> has authenticated with the STS.
							</li><li class="listitem">
								The <code class="literal">STSClient</code> presents a message with the security token to the <code class="literal">ws-provider</code>.
							</li><li class="listitem">
								The <code class="literal">ws-provider</code> verifies that the token was issued by the STS, and hence proves that the <code class="literal">ws-requester</code> has successfully authenticated with the STS.
							</li><li class="listitem">
								The <code class="literal">ws-provider</code> executes the requested service and returns the results to the <code class="literal">ws-requester</code>.
							</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ws_trust_sts_apache_CXF_support"/>Apache CXF Support</h3></div></div></div><p>
						Apache CXF is an open-source, fully-featured web services framework. The JBossWS open source project integrates the JBoss Web Services (JBossWS) stack with the Apache CXF project modules to provide WS-Trust and other JAX-WS functionality. This integration helps in easy deployment of Apache CXF STS implementations. The Apache CXF API also provides a <code class="literal">STSClient</code> utility to facilitate web service requester communication with its STS.
					</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="about_sts"/>Security Token Service (STS)</h2></div></div></div><p>
					The Security Token Service (STS) is the core of the WS-Trust specification. It is a standards-based mechanism for authentication and authorization. The STS is an implementation of the WS-Trust specification’s protocol for issuing, exchanging, and validating security tokens, based on token format, namespace, or trust boundaries. The STS is a web service that acts as a trusted third party to broker trust relationships between a web service requester and a web service provider. It is a common access point trusted by both requester and provider to provide interoperable security tokens. It removes the need for a direct relationship between the requestor and provider. The STS helps ensure interoperability across realms and between different platforms because it is a standards-based mechanism for authentication.
				</p><p>
					The STS’s WSDL contract defines how other applications and processes interact with it. In particular, the WSDL defines the WS-Trust and WS-Security policies that a requester must fulfill to successfully communicate with the STS’s endpoints. A web service requester consumes the STS’s WSDL and, with the aid of an <code class="literal">STSClient</code> utility, generates a message request compliant with the stated security policies and submits it to the STS endpoint. The STS validates the request and returns an appropriate response.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="setting_up_plink_sts_idp"/>Configuring a PicketLink WS-Trust Security Token Service (STS)</h3></div></div></div><p>
						PicketLink STS provides options for building an alternative to the Apache CXF Security Token Service implementation. You can also use PicketLink to configure SAML SSO for web applications. For more details on configuring SAML SSO using PicketLink, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/how_to_set_up_sso_with_saml_v2/"><span class="emphasis"><em>How To Set Up SSO with SAML v2</em></span></a>.
					</p><p>
						To set up an application to serve as a PicketLink WS-Trust STS, the following steps must be performed:
					</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">
								Create a security domain for the WS-Trust STS application.
							</li><li class="listitem">
								Configure the <code class="literal">web.xml</code> file for the WS-Trust STS application.
							</li><li class="listitem">
								Configure the authenticator for the WS-Trust STS application.
							</li><li class="listitem">
								Declare the necessary dependencies for the WS-Trust STS application.
							</li><li class="listitem">
								Configure the web-service portion of the WS-Trust STS application.
							</li><li class="listitem">
								Create and configure a <code class="literal">picketlink.xml</code> file for the WS-Trust STS application.
							</li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							The security domain should be created and configured before creating and deploying the application.
						</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="create_a_security_domain_for_the_sts"/>Create a Security Domain for the STS</h4></div></div></div><p>
							The STS handles authentication of a principal based on the credentials provided and issues the proper security token based on that result. This requires that an identity store be configured via a security domain. The only requirement around creating this security domain and identity store is that it has authentication and authorization mechanisms properly defined. This means that many different identity stores, for example properties files, database, and LDAP, and their associated login modules could be used to support an STS application. For more information on security domains, see the <span class="emphasis"><em>Security Domains</em></span> section of the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/security_architecture/#security_domains">JBoss EAP <span class="emphasis"><em>Security Architecture</em></span></a> documentation.
						</p><p>
							In the below example, a simple <code class="literal">UsersRoles</code> login module using properties files for an identity store is used.
						</p><div class="title"><strong>CLI Commands for Creating a Security Domain</strong></div><p>
								
</p><pre class="screen">/subsystem=security/security-domain=sts:add(cache-type=default)</pre><p>

							</p><pre class="screen">/subsystem=security/security-domain=sts/authentication=classic:add</pre><pre class="screen">/subsystem=security/security-domain=sts/authentication=classic/login-module=UsersRoles:add(code=UsersRoles,flag=required,module-options=[usersProperties=${jboss.server.config.dir}/sts-users.properties,rolesProperties=${jboss.server.config.dir}/sts-roles.properties])</pre><pre class="screen">reload</pre><div class="title"><strong>Resulting XML</strong></div><p>
								
</p><pre class="programlisting">&lt;security-domain name="sts" cache-type="default"&gt;
  &lt;authentication&gt;
    &lt;login-module code="UsersRoles" flag="required"&gt;
      &lt;module-option name="usersProperties" value="${jboss.server.config.dir}/sts-users.properties"/&gt;
      &lt;module-option name="rolesProperties" value="${jboss.server.config.dir}/sts-roles.properties"/&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;</pre><p>

							</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								The management CLI commands shown assume that you are running a JBoss EAP standalone server. For more details on using the management CLI for a JBoss EAP managed domain, see the JBoss EAP <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/management_cli_guide/"><span class="emphasis"><em>Management CLI Guide</em></span></a>.
							</p></div><div class="title"><strong>Property Files</strong></div><p>
								The <code class="literal">UsersRoles</code> login module utilizes properties files to store the user/password and user/role information. For more specifics of the <code class="literal">UsersRoles</code> module, please see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/login_module_reference/#usersroles_login_module">JBoss EAP <span class="emphasis"><em>Login Module Reference</em></span></a>. In this example, the properties files contain the following:
							</p><div class="title"><strong>Example: <code class="literal">sts-users.properties</code> File</strong></div><p>
								
</p><pre class="screen">Eric=samplePass
Alan=samplePass</pre><p>

							</p><div class="title"><strong>Example: <code class="literal">sts-roles.properties</code> File</strong></div><p>
								
</p><pre class="screen">Eric=All
Alan=</pre><p>

							</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
								You also need to create a keystore for signing and encrypting the security tokens. This keystore will be used when configuring the <code class="literal">picketlink.xml</code> file.
							</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="configure_the_web_xml_file_for_the_sts"/>Configure the web.xml File for the STS</h4></div></div></div><p>
							The <code class="literal">web.xml</code> file for an STS should contain the following:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									A <code class="literal">&lt;servlet&gt;</code> to enable the STS functionality and a <code class="literal">&lt;servlet-mapping&gt;</code> to map its URL.
								</li><li class="listitem">
									A <code class="literal">&lt;security-constraint&gt;</code> with a <code class="literal">&lt;web-resource-collection&gt;</code> containing a <code class="literal">&lt;url-pattern&gt;</code> that maps to the URL pattern of the secured area. Optionally, <code class="literal">&lt;security-constraint&gt;</code> may also contain an <code class="literal">&lt;auth-constraint&gt;</code> stipulating the allowed roles.
								</li><li class="listitem">
									A <code class="literal">&lt;login-config&gt;</code> configured for BASIC authentication.
								</li><li class="listitem">
									If any roles were specified in the <code class="literal">&lt;auth-constraint&gt;</code>, those roles should be defined in a <code class="literal">&lt;security-role&gt;</code>.
								</li></ul></div><div class="title"><strong>Example <code class="literal">web.xml</code> file:</strong></div><p>
								
</p><pre class="programlisting">&lt;web-app&gt;
  &lt;!-- Define STS servlet --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;STS-servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.example.sts.PicketLinkSTService&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;STS-servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;!-- Define a security constraint that requires the All role to access resources --&gt;
  &lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;STS&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;role-name&gt;All&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;!-- Define the Login Configuration for this Application --&gt;
  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;realm-name&gt;STS Realm&lt;/realm-name&gt;
  &lt;/login-config&gt;
  &lt;!-- Security roles referenced by this web application --&gt;
  &lt;security-role&gt;
    &lt;description&gt;The role that is required to log in to the IDP Application&lt;/description&gt;
    &lt;role-name&gt;All&lt;/role-name&gt;
  &lt;/security-role&gt;
&lt;/web-app&gt;</pre><p>

							</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="configure_the_authenticator_for_the_sts"/>Configure the Authenticator for the STS</h4></div></div></div><p>
							The authenticator is responsible for the authentication of users for issuing and validating security tokens. The authenticator is configured by defining the security domain to be used in authenticating and authorizing principals.
						</p><p>
							The <code class="literal">jboss-web.xml</code> file should have the following:
						</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
									A <code class="literal">&lt;security-domain&gt;</code> to specify which security domain to use for authentication and authorization.
								</li></ul></div><div class="title"><strong>Example: <code class="literal">jboss-web.xml</code> File</strong></div><p>
								
</p><pre class="programlisting">&lt;jboss-web&gt;
  &lt;security-domain&gt;sts&lt;/security-domain&gt;
  &lt;context-root&gt;SecureTokenService&lt;/context-root&gt;
&lt;/jboss-web&gt;</pre><p>

							</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="declare_the_necessary_dependencies_for_the_sts"/>Declare the Necessary Dependencies for the STS</h4></div></div></div><p>
							The web application serving as the STS requires a dependency to be defined in the <code class="literal">jboss-deployment-structure.xml</code> file so that the <code class="literal">org.picketlink</code> classes can be located. As JBoss EAP provides all necessary <code class="literal">org.picketlink</code> and related classes, the application just needs to declare them as dependencies to use them.
						</p><div class="title"><strong>Example: Using <code class="literal">jboss-deployment-structure.xml</code> to Declare Dependencies</strong></div><p>
								
</p><pre class="programlisting">&lt;jboss-deployment-structure&gt;
  &lt;deployment&gt;
    &lt;dependencies&gt;
      &lt;module name="org.picketlink"/&gt;
    &lt;/dependencies&gt;
  &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;</pre><p>

							</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="configure_the_web_service_portion_of_the_sts"/>Configure the Web-Service Portion of the STS</h4></div></div></div><p>
							The web application serving as the STS requires that you define a web-service for clients to call to obtain their security tokens. This requires that you define in your WSDL a service name called <code class="literal">PicketLinkSTS</code>, and a port called <code class="literal">PicketLinkSTSPort</code>. You can, however, change the SOAP address to better reflect your target deployment environment.
						</p><div class="title"><strong>Example: <code class="literal">PicketLinkSTS.wsdl</code> File</strong></div><p>
								
</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;wsdl:definitions name="PicketLinkSTS" targetNamespace="urn:picketlink:identity-federation:sts"
	xmlns:tns="urn:picketlink:identity-federation:sts"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
	xmlns:wsap10="http://www.w3.org/2006/05/addressing/wsdl"
	xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/"&gt;
  &lt;wsdl:types&gt;
    &lt;xs:schema targetNamespace="urn:picketlink:identity-federation:sts"
      xmlns:tns="urn:picketlink:identity-federation:sts"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      version="1.0" elementFormDefault="qualified"&gt;
      &lt;xs:element name="MessageBody"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:any minOccurs="0" maxOccurs="unbounded" namespace="##any"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:schema&gt;
  &lt;/wsdl:types&gt;
  &lt;wsdl:message name="RequestSecurityToken"&gt;
    &lt;wsdl:part name="rstMessage" element="tns:MessageBody"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="RequestSecurityTokenResponse"&gt;
    &lt;wsdl:part name="rstrMessage" element="tns:MessageBody"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:portType name="SecureTokenService"&gt;
    &lt;wsdl:operation name="IssueToken"&gt;
      &lt;wsdl:input wsap10:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" message="tns:RequestSecurityToken"/&gt;
      &lt;wsdl:output wsap10:Action="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RSTR/Issue" message="tns:RequestSecurityTokenResponse"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;
  &lt;wsdl:binding name="STSBinding" type="tns:SecureTokenService"&gt;
    &lt;soap12:binding transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="IssueToken"&gt;
      &lt;soap12:operation soapAction="http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue" style="document"/&gt;
      &lt;wsdl:input&gt;
        &lt;soap12:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output&gt;
        &lt;soap12:body use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;
  &lt;wsdl:service name="PicketLinkSTS"&gt;
    &lt;wsdl:port name="PicketLinkSTSPort" binding="tns:STSBinding"&gt;
      &lt;soap12:address location="http://localhost:8080/SecureTokenService/PicketLinkSTS"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;
&lt;/wsdl:definitions&gt;</pre><p>

							</p><p>
							In addition, you need a class for your web-service to use your WSDL:
						</p><div class="title"><strong>Example: <code class="literal">PicketLinkSTS</code> Class</strong></div><p>
								
</p><pre class="programlisting">@WebServiceProvider(serviceName = "PicketLinkSTS", portName = "PicketLinkSTSPort", targetNamespace = "urn:picketlink:identity-federation:sts", wsdlLocation = "WEB-INF/wsdl/PicketLinkSTS.wsdl")
@ServiceMode(value = Service.Mode.MESSAGE)
public class PicketLinkSTService extends PicketLinkSTS {
    private static Logger log = Logger.getLogger(PicketLinkSTService.class.getName());

    @Resource
    public void setWSC(WebServiceContext wctx) {
        log.debug("Setting WebServiceContext = " + wctx);
        this.context = wctx;
    }
}</pre><p>

							</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="create_and_configure_a_picketlink_xml_file_for_the_sts"/>Create and Configure a picketlink.xml File for the STS</h4></div></div></div><p>
							The <code class="literal">picketlink.xml</code> file is responsible for the behavior of the authenticator and is loaded at the application’s startup.
						</p><p>
							The JBoss EAP Security Token Service defines several interfaces that provide extension points. Implementations can be plugged in and the default values can be specified for some properties using configuration. Similar to the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/how_to_set_up_sso_with_saml_v2/#setting_up_idp">IDP</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/how_to_set_up_sso_with_saml_v2/#setting_up_sp">SP</a> configuration in <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.2/html-single/how_to_set_up_sso_with_saml_v2/"><span class="emphasis"><em>How To Set Up SSO with SAML v2</em></span></a>, all STS configurations are specified in the <code class="literal">picketlink.xml</code> file of the deployed application. The following are the elements that can be configured in the <code class="literal">picketlink.xml</code> file.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
								In the following text, a service provider refers to the web service that requires a security token to be presented by its clients.
							</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
									<code class="literal">&lt;PicketLinkSTS&gt;</code>: This is the root element. It defines some properties that allow the STS administrator to set the following properties:
								</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
											<code class="literal">STSName</code>: A string representing the name of the security token service. If not specified, the default <code class="literal">PicketLinkSTS</code> value is used.
										</li><li class="listitem">
											<code class="literal">TokenTimeout</code>: The token lifetime value in seconds. If not specified, the default value of <code class="literal">3600</code> (one hour) is used.
										</li><li class="listitem">
											<code class="literal">EncryptToken</code>: A boolean specifying whether issued tokens are to be encrypted or not. The default value is <code class="literal">false</code>.
										</li></ul></div></li><li class="listitem">
									<code class="literal">&lt;KeyProvider&gt;</code>: This element and all its subelements are used to configure the keystore that are used by PicketLink STS to sign and encrypt tokens. Properties like the keystore location, its password, and the signing (private key) alias and password are all configured in this section.
								</li><li class="listitem">
									<code class="literal">&lt;TokenProviders&gt;</code>: This section specifies the <code class="literal">TokenProvider</code> implementations that must be used to handle each type of security token. In the example we have two providers - one that handles tokens of type <code class="literal">SAMLV1.1</code> and one that handles tokens of type <code class="literal">SAMLV2.0</code>. The <code class="literal">WSTrustRequestHandler</code> calls the <code class="literal">getProviderForTokenType(String type)</code> method of <code class="literal">STSConfiguration</code> to obtain a reference to the appropriate <code class="literal">TokenProvider</code>.
								</li><li class="listitem">
									<code class="literal">&lt;ServiceProviders&gt;</code>: This section specifies the token types that must be used for each service provider, the web service that requires a security token. When a WS-Trust request does not contain the token type, the <code class="literal">WSTrustRequestHandler</code> must use the service provider endpoint to find out the type of the token that must be issued.
								</li></ul></div><div class="title"><strong>Example: <code class="literal">picketlink.xml</code> Configuration File</strong></div><p>
								
</p><pre class="programlisting">&lt;!DOCTYPE PicketLinkSTS&gt;
&lt;PicketLinkSTS xmlns="urn:picketlink:federation:config:2.1"
               STSName="PicketLinkSTS" TokenTimeout="7200" EncryptToken="false"&gt;
    &lt;KeyProvider
            ClassName="org.picketlink.identity.federation.core.impl.KeyStoreKeyManager"&gt;
        &lt;Auth Key="KeyStoreURL" Value="sts_keystore.jks"/&gt;
        &lt;Auth Key="KeyStorePass" Value="testpass"/&gt;
        &lt;Auth Key="SigningKeyAlias" Value="sts"/&gt;
        &lt;Auth Key="SigningKeyPass" Value="keypass"/&gt;
        &lt;ValidatingAlias Key="http://services.testcorp.org/provider1"
                         Value="service1"/&gt;
    &lt;/KeyProvider&gt;
    &lt;TokenProviders&gt;
        &lt;TokenProvider
                ProviderClass="org.picketlink.identity.federation.core.wstrust.plugins.saml.SAML11TokenProvider"
                TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV1.1"
                TokenElement="Assertion" TokenElementNS="urn:oasis:names:tc:SAML:1.0:assertion"/&gt;
        &lt;TokenProvider
                ProviderClass="org.picketlink.identity.federation.core.wstrust.plugins.saml.SAML20TokenProvider"
                TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0"
                TokenElement="Assertion" TokenElementNS="urn:oasis:names:tc:SAML:2.0:assertion"/&gt;
    &lt;/TokenProviders&gt;
    &lt;ServiceProviders&gt;
        &lt;ServiceProvider Endpoint="http://services.testcorp.org/provider1"
                         TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0"
                         TruststoreAlias="service1"/&gt;
    &lt;/ServiceProviders&gt;
&lt;/PicketLinkSTS&gt;</pre><p>

							</p><p>
							By default, the <code class="literal">picketlink.xml</code> file is located in the <code class="literal">WEB-INF/classes</code> directory of the STS web application. The PicketLink configuration file can also be loaded from the file system. To load the PicketLink configuration file from the file system, it must be named <code class="literal">picketlink-sts.xml</code> and be located in the <code class="literal">${user.home}/picketlink-store/sts/</code> directory.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="configure-sts-client-server"/>Using a WS-Trust Security Token Service (STS) with a Client</h3></div></div></div><p>
						To configure a client to obtain a security token from the STS, you need to make use of the <code class="literal">org.picketlink.identity.federation.api.wstrust.WSTrustClient</code> class to connect to the STS and ask for a token to be issued.
					</p><p>
						First you need to instantiate the client:
					</p><div class="title"><strong>Example: Creating a WSTrustClient</strong></div><p>
							
</p><pre class="programlisting"> WSTrustClient client = new WSTrustClient("PicketLinkSTS", "PicketLinkSTSPort",
       "http://localhost:8080/SecureTokenService/PicketLinkSTS",
       new SecurityInfo(username, password));</pre><p>

						</p><p>
						Next you need to use the <code class="literal">WSTrustClient</code> to ask for a token, for example a SAML assertion, to be issued:
					</p><div class="title"><strong>Example: Obtaining an Assertion</strong></div><p>
							
</p><pre class="programlisting">org.w3c.dom.Element assertion = null;
try {
   assertion = client.issueToken(SAMLUtil.SAML2_TOKEN_TYPE);
} catch (WSTrustException wse) {
   System.out.println("Unable to issue assertion: " + wse.getMessage());
   wse.printStackTrace();
}</pre><p>

						</p><p>
						Once you have the assertion, there are two ways by which it can be included in and sent via the SOAP message:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
								The client can push the SAML2 <code class="literal">Assertion</code> into the SOAP <code class="literal">MessageContext</code> under the key <code class="literal">org.picketlink.trust.saml.assertion</code>. For example:
							</p><pre class="programlisting">bindingProvider.getRequestContext().put(SAML2Constants.SAML2_ASSERTION_PROPERTY, assertion);</pre></li><li class="listitem">
								The SAML2 <code class="literal">Assertion</code> is available as part of the JAAS subject on the security context. This can happen if there has been a JAAS interaction with the usage of PicketLink STS login modules.
							</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="sts-client-pools"/>STS Client Pooling</h3></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
							The STS client pooling feature is <span class="emphasis"><em>NOT</em></span> supported in JBoss EAP.
						</p></div><p>
						STS client pooling is a feature that allows you to configure a pool of STS clients on the server, thereby eliminating a possible bottleneck of STS client creation. Client pooling can be used for login modules that need an STS client to obtain SAML tickets. These include:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								<code class="literal">org.picketlink.identity.federation.core.wstrust.auth.STSIssuingLoginModule</code>
							</li><li class="listitem">
								<code class="literal">org.picketlink.identity.federation.core.wstrust.auth.STSValidatingLoginModule</code>
							</li><li class="listitem">
								<code class="literal">org.picketlink.trust.jbossws.jaas.JBWSTokenIssuingLoginModule</code>
							</li></ul></div><p>
						The default number of clients in the pool for each login module is configured using the <code class="literal">initialNumberOfClients</code> login module option.
					</p><p>
						The <code class="literal">org.picketlink.identity.federation.bindings.stspool.STSClientPoolFactory</code> class provides client pool functionality to applications.
					</p><h4><a id="using_stsclientpoolfactory"/>Using STSClientPoolFactory</h4><p>
						STS clients are inserted into subpools using their <a class="link" href="http://docs.jboss.org/jbossas/javadoc/7.1.2.Final/org/picketlink/identity/federation/core/wstrust/class-use/STSClientConfig.html">STSClientConfig</a> configuration as a key. To insert an STS client into a subpool, you need to obtain the <code class="literal">STSClientPool</code> instance and then initialize a subpool based on the configuration. Optionally, you can specify the initial number of STS clients when initializing the pool, or you can rely on the default number.
					</p><div class="title"><strong>Example: Inserting an STS Client into a Subpool</strong></div><p>
							
</p><pre class="programlisting">final STSClientPool pool = STSClientPoolFactory.getPoolInstance();
pool.createPool(20, stsClientConfig);
final STSClient client = pool.getClient(stsClientConfig);</pre><p>

						</p><p>
						When you are done with a client, you can return it to the pool by calling the <code class="literal">returnClient()</code> method.
					</p><div class="title"><strong>Example: Returning an STS Client to the Subpool</strong></div><p>
							
</p><pre class="programlisting">pool.returnClient();</pre><p>

						</p><div class="title"><strong>Example: Checking If a Subpool Exists with a Given Configuration</strong></div><p>
							
</p><pre class="programlisting">if (! pool.configExists(stsClientConfig) {
    pool.createPool(stsClientConfig);
}</pre><p>

						</p><p>
						If the <code class="literal">picketlink-federation</code> subsystem is enabled, all client pools created for a deployment are destroyed automatically during the undeploy process. To manually destroy a pool:
					</p><div class="title"><strong>Example: Manually Destroying a Subpool</strong></div><p>
							
</p><pre class="programlisting">pool.destroyPool(stsClientConfig);</pre><p>

						</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="propagate_authenticated_identity_to_ejb_subsystem"/>Propagating Authenticated Identity to the EJB Subsystem</h2></div></div></div><p>
					The <code class="literal">webservices</code> subsystem contains an adapter that allows you to configure an Elytron security domain to secure web service endpoints using either annotations or deployment descriptors.
				</p><p>
					When Elytron security is enabled, the JAAS subject or principal can be pushed to the Apache CXF endpoint’s <code class="literal">SecurityContext</code> to propagate the authenticated identity to the EJB container.
				</p><p>
					The following is an example of how to use an Apache CXF interceptor to propagate authenticated information to the EJB container.
				</p><pre class="programlisting">public class PropagateSecurityInterceptor extends WSS4JInInterceptor {
    public PropagateSecurityInterceptor() {
      super();
      getAfter().add(PolicyBasedWSS4JInInterceptor.class.getName());
   }
   @Override
   public void handleMessage(SoapMessage message) throws Fault {
      ...
      final Endpoint endpoint = message.getExchange().get(Endpoint.class);
      final SecurityDomainContext securityDomainContext = endpoint.getSecurityDomainContext();
      //push subject principal retrieved from CXF to ElytronSecurityDomainContext
      securityDomainContext.pushSubjectContext(subject, principal, null)
      }
    }</pre></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="jax_ws_logging"/>JAX-WS Logging</h1></div></div></div><p>
				You can handle logging for inbound and outbound messages using <a class="link" href="developing_jax_ws_web_services.html#jax_ws_logging_handlers" title="Using JAX-WS Handlers">JAX-WS handlers</a> or <a class="link" href="developing_jax_ws_web_services.html#cxf_logging_interceptors" title="Using Apache CXF Logging Interceptors">Apache CXF logging interceptors</a>.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="jax_ws_logging_handlers"/>Using JAX-WS Handlers</h2></div></div></div><p>
					You can configure a JAX-WS handler to log messages that are passed to it. This approach is portable as the handler can be added to the desired client and endpoints programatically by using the <code class="literal">@HandlerChain</code> JAX-WS annotation.
				</p><p>
					The predefined client and endpoint configuration mechanism allows you to add the logging handler to any client and endpoint combination, or to only some of the clients and endpoints. To add the logging handler to only some of the clients or endpoints, use the <code class="literal">@EndpointConfig</code> annotation and the JBossWS API.
				</p><p>
					The <code class="literal">org.jboss.ws.api.annotation.EndpointConfig</code> annotation is used to assign an endpoint configuration to a JAX-WS endpoint implementation. When assigning a configuration that is defined in the <code class="literal">webservices</code> subsystem, only the configuration name is specified. When assigning a configuration that is defined in the application, the relative path to the deployment descriptor and the configuration name must be specified.
				</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="cxf_logging_interceptors"/>Using Apache CXF Logging Interceptors</h2></div></div></div><p>
					Apache CXF also comes with logging interceptors that can be used to log messages to the console, client log files, or server log files. Those interceptors can be added to client, endpoint, and buses in multiple ways, including:
				</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
							System property
						</p><p class="simpara">
							Setting the <code class="literal">org.apache.cxf.logging.enabled</code> system property to <code class="literal">true</code> causes the logging interceptors to be added to any bus instance being created on the JVM. You can also set the system property to <code class="literal">pretty</code> to output nicely-formatted XML output. You can use the following management CLI command to set this system property.
						</p><pre class="screen">/system-property=org.apache.cxf.logging.enabled:add(value=true)</pre></li><li class="listitem"><p class="simpara">
							Manual interceptor addition
						</p><p class="simpara">
							Logging interceptors can be selectively added to endpoints using the Apache CXF annotations <code class="literal">@org.apache.cxf.interceptor.InInterceptors</code> and <code class="literal">@org.apache.cxf.interceptor.OutInterceptors</code>. The same outcome is achieved on the client side by programmatically adding new instances of the logging interceptors to the client or the bus.
						</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="enabling_web_services_addressing_ws_addressing"/>Enabling Web Services Addressing (WS-Addressing)</h1></div></div></div><p>
				Web Services Addressing, or WS-Addressing, provides a transport-neutral mechanism to address web services and their associated messages. To enable WS-Addressing, you must add the <code class="literal">@Addressing</code> annotation to the web service endpoint and then configure the client to access it.
			</p><p>
				The following examples assume your application has an existing JAX-WS service and client configuration. See the <code class="literal">jaxws-addressing</code> quickstart that ships with JBoss EAP for a complete working example.
			</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p class="simpara">
						Add the <code class="literal">@Addressing</code> annotation to the application’s JAX-WS endpoint code.
					</p><div class="title"><strong>Example: JAX-WS Endpoint with @Addressing Annotation</strong></div><p>
							
</p><pre class="programlisting">package org.jboss.quickstarts.ws.jaxws.samples.wsa;

import org.jboss.quickstarts.ws.jaxws.samples.wsa.ServiceIface;

import javax.jws.WebService;
import javax.xml.ws.soap.Addressing;

@WebService(
    portName = "AddressingServicePort",
    serviceName = "AddressingService",
    wsdlLocation = "WEB-INF/wsdl/AddressingService.wsdl",
    targetNamespace = "http://www.jboss.org/jbossws/ws-extensions/wsaddressing",
    endpointInterface = "org.jboss.quickstarts.ws.jaxws.samples.wsa.ServiceIface")
@Addressing(enabled = true, required = true)
public class ServiceImpl implements ServiceIface {
    public String sayHello() {
        return "Hello World!";
    }
}</pre><p>

						</p></li><li class="listitem"><p class="simpara">
						Update the JAX-WS client code to configure WS-Addressing.
					</p><div class="title"><strong>Example: JAX-WS Client Configured for WS-Addressing</strong></div><p>
							
</p><pre class="programlisting">package org.jboss.quickstarts.ws.jaxws.samples.wsa;

import java.net.URL;
import javax.xml.namespace.QName;
import javax.xml.ws.Service;
import javax.xml.ws.soap.AddressingFeature;

public final class AddressingClient {
    private static final String serviceURL =
        "http://localhost:8080/jaxws-addressing/AddressingService";

    public static void main(String[] args) throws Exception {
        // construct proxy
        QName serviceName =
            new QName("http://www.jboss.org/jbossws/ws-extensions/wsaddressing",
                "AddressingService");
        URL wsdlURL = new URL(serviceURL + "?wsdl");
        Service service = Service.create(wsdlURL, serviceName);
        org.jboss.quickstarts.ws.jaxws.samples.wsa.ServiceIface proxy =
            (org.jboss.quickstarts.ws.jaxws.samples.wsa.ServiceIface) service.getPort(org.jboss.quickstarts.ws.jaxws.samples.wsa.ServiceIface.class,
                new AddressingFeature());
        // invoke method
        System.out.println(proxy.sayHello());
    }
}</pre><p>

						</p></li></ol></div><p>
				The client and endpoint now communicate using WS-Addressing.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ws_msging"/>Enabling Web Services Reliable Messaging</h1></div></div></div><p>
				Web Services Reliable Messaging (WS-Reliable Messaging) is implemented internally in Apache CXF. A set of interceptors interacts with the low-level requirements of the reliable messaging protocol.
			</p><p>
				To enable WS-Reliable Messaging, complete one of the following steps:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Consume a WSDL contract that specifies proper WS-Reliable Messaging policies, assertions, or both.
					</li><li class="listitem">
						Manually add and configure the reliable messaging interceptors.
					</li><li class="listitem">
						Specify the reliable messaging policies in an optional CXF Spring XML descriptor.
					</li><li class="listitem">
						Specify the Apache CXF reliable messaging feature in an optional CXF Spring XML descriptor.
					</li></ul></div><p>
				The first approach, which is the only portable approach, relies on the Apache CXF WS-Policy engine. The other approaches, which are proprietary, allow for fine-grained configuration of the protocol aspects that are not covered by the WS-Reliable Messaging Policy.
			</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ws_policies"/>Specifying Web Services Policies</h1></div></div></div><p>
				Web Services Policies (WS-Policy) rely on the Apache CXF WS-Policy framework. This framework is compliant with the following specifications:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						<a class="link" href="http://www.w3.org/TR/2007/REC-ws-policy-20070904/">Web Services Policy 1.5 - Framework</a>
					</li><li class="listitem">
						<a class="link" href="http://www.w3.org/TR/2007/REC-ws-policy-attach-20070904/">Web Services Policy 1.5 - Attachment</a>
					</li></ul></div><p>
				You can work with the policies in different ways, including:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Add policy assertions to WSDL contracts and let the runtime consume the assertions and behave accordingly.
					</li><li class="listitem">
						Specify endpoint policy attachments using either CXF annotations or features.
					</li><li class="listitem">
						Use the Apache CXF policy framework to define custom assertions and complete other tasks.
					</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="cxf_integration"/>Apache CXF Integration</h1></div></div></div><p>
				All JAX-WS functionality provided by JBossWS on top of JBoss EAP is currently served through a proper integration of the JBossWS stack with most of the Apache CXF project modules.
			</p><p>
				Apache CXF is an open source services framework. It allows building and developing services using front-end programming APIs, including JAX-WS, with services speaking a variety of protocols such as SOAP and XML/HTTP over a variety of transports such as HTTP and JMS.
			</p><p>
				The integration layer between JBossWS and Apache CXF is mainly meant for:
			</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
						Allowing use of standard web services APIs, including JAX-WS, on JBoss EAP; this is performed internally leveraging Apache CXF without requiring the user to deal with it;
					</li><li class="listitem">
						Allowing use of Apache CXF advanced features, including WS-*, on top of JBoss EAP without requiring the user to deal with, set up, or care about the required integration steps for running in such a container.
					</li></ul></div><p>
				In support of those goals, the JBossWS integration with Apache CXF supports the JBossWS endpoint deployment mechanism and comes with many internal customizations on top of Apache CXF.
			</p><p>
				For more in-depth details on the Apache CXF architecture, refer to the <a class="link" href="http://cxf.apache.org/docs/index.html">Apache CXF official documentation</a>.
			</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="cxf_server_side_integration_customization"/>Server-side Integration Customization</h2></div></div></div><p>
					The JBossWS server-side integration with Apache CXF takes care of internally creating proper Apache CXF structures for the provided web service deployment. If the deployment includes multiple endpoints, they will all exist within the same Apache CXF Bus, which is separate from other deployments' bus instances.
				</p><p>
					While JBossWS sets sensible defaults for most of the Apache CXF configuration options on the server side, users might want to fine-tune the Bus instance that is created for their deployment; a <code class="literal">jboss-webservices.xml</code> descriptor can be used for deployment-level customizations.
				</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_deployment_descriptor_properties"/>Deployment Descriptor Properties</h3></div></div></div><p>
						The <code class="literal">jboss-webservices.xml</code> descriptor can be used to provide property values.
					</p><pre class="programlisting">&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" version="1.2"&gt;
  ...
  &lt;property&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;value&gt;...&lt;/value&gt;
  &lt;/property&gt;
  ...
&lt;/webservices&gt;</pre><p>
						JBossWS integration with Apache CXF comes with a set of allowed property names to control Apache CXF internals.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_workqueue_configuration"/>WorkQueue Configuration</h3></div></div></div><p>
						Apache CXF uses <code class="literal">WorkQueue</code> instances for dealing with some operations, for example <code class="literal">@Oneway</code> request processing. A <a class="link" href="http://cxf.apache.org/javadoc/latest-3.1.x/org/apache/cxf/workqueue/WorkQueueManager.html"><code class="literal">WorkQueueManager</code></a> is installed in the Bus as an extension and allows for adding or removing queues as well as controlling the existing ones.
					</p><p>
						On the server side, queues can be provided by using the <code class="literal">cxf.queue.&lt;queue-name&gt;.*</code> properties in <code class="literal">jboss-webservices.xml</code>. For example, you can use the <code class="literal">cxf.queue.default.maxQueueSize</code> property to configure the maximum queue size of the default <code class="literal">WorkQueue</code>. At the deployment time, the JBossWS integration can add new instances of <a class="link" href="http://cxf.apache.org/javadoc/latest-3.1.x/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.html"><code class="literal">AutomaticWorkQueueImpl</code></a> to the currently configured <code class="literal">WorkQueueManager</code>. The properties below are used to fill in the <a class="link" href="http://cxf.apache.org/javadoc/latest-3.1.x/org/apache/cxf/workqueue/AutomaticWorkQueueImpl.html#AutomaticWorkQueueImpl(int,%20int,%20int,%20int,%20long,%20java.lang.String)"><code class="literal">AutomaticWorkQueueImpl</code> constructor</a> parameters:
					</p><div class="table"><a id="idm140182154315840"/><p class="title"><strong>Table 3.5. <code class="literal">AutomaticWorkQueueImpl</code> Constructor Properties</strong></p><div class="table-contents"><table summary="AutomaticWorkQueueImpl Constructor Properties" border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Property</th><th style="text-align: left" valign="top">Default Value</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										cxf.queue.&lt;queue-name&gt;.maxQueueSize
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										256
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										cxf.queue.&lt;queue-name&gt;.initialThreads
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										0
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										cxf.queue.&lt;queue-name&gt;.highWaterMark
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										25
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										cxf.queue.&lt;queue-name&gt;.lowWaterMark
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										5
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										cxf.queue.&lt;queue-name&gt;.dequeueTimeout
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										120000
									</p>
									 </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_policy_alternative_selector"/>Policy Alternative Selector</h3></div></div></div><p>
						The Apache CXF policy engine supports different strategies to deal with policy alternatives. JBossWS integration currently defaults to the <a class="link" href="http://cxf.apache.org/javadoc/latest-3.1.x/org/apache/cxf/ws/policy/selector/MaximalAlternativeSelector.html"><code class="literal">MaximalAlternativeSelector</code></a>, but still allows for setting different selector implementation using the <code class="literal">cxf.policy.alternativeSelector</code> property in the <code class="literal">jboss-webservices.xml</code> file.
					</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_mbean_management"/>MBean Management</h3></div></div></div><p>
						Apache CXF allows you to manage its MBean objects that are installed into the JBoss EAP MBean server. You can enable this feature on a deployment basis through the <code class="literal">cxf.management.enabled</code> property in the <code class="literal">jboss-webservices.xml</code> file. You can also use the <code class="literal">cxf.management.installResponseTimeInterceptors</code> property to control installation of the CXF response time interceptors. These interceptors are added by default when enabling the MBean management, but it might not be required in some cases.
					</p><div class="title"><strong>Example: MBean Management in the <code class="literal">jboss-webservices.xml</code> File</strong></div><p>
							
</p><pre class="programlisting">&lt;webservices xmlns="http://www.jboss.com/xml/ns/javaee" version="1.2"&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.management.enabled&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.management.installResponseTimeInterceptors&lt;/name&gt;
    &lt;value&gt;false&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre><p>

						</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_schema_validation"/>Schema Validation</h3></div></div></div><p>
						Apache CXF includes a feature for validating incoming and outgoing SOAP messages on both the client and the server side. The validation is performed against the relevant schema in the endpoint WSDL contract (server side) or the WSDL contract used for building up the service proxy (client side).
					</p><p>
						You can enable schema validation in any of the following ways:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">
								In the JBoss EAP server configuration.
							</p><p class="simpara">
								For example, the management CLI command below enables schema validation for the default <code class="literal">Standard-Endpoint-Config</code> endpoint configuration.
							</p><pre class="screen">/subsystem=webservices/endpoint-config=Standard-Endpoint-Config/property=schema-validation-enabled:add(value=true)</pre></li><li class="listitem"><p class="simpara">
								In a predefined client or endpoint configuration file.
							</p><p class="simpara">
								You can associate any endpoint or client running in-container to a JBossWS <a class="link" href="developing_jax_ws_web_services.html#jax_ws_endpoint_configs" title="Endpoint Configurations">predefined configuration</a> by setting the <code class="literal">schema-validation-enabled</code> property to <code class="literal">true</code> in the referenced configuration file.
							</p></li><li class="listitem"><p class="simpara">
								Programmatically on the client side.
							</p><p class="simpara">
								On the client side, you can enable schema validation programmatically. For example:
							</p><pre class="programlisting">((BindingProvider)proxy).getRequestContext().put("schema-validation-enabled", true);</pre></li><li class="listitem"><p class="simpara">
								Using the <code class="literal">@org.apache.cxf.annotations.SchemaValidation</code> annotation on the server side.
							</p><p class="simpara">
								On the server side, you can use the <code class="literal">@org.apache.cxf.annotations.SchemaValidation</code> annotation. For example:
							</p><pre class="programlisting">import javax.jws.WebService;
import org.apache.cxf.annotations.SchemaValidation;

@WebService(...)
@SchemaValidation
public class ValidatingHelloImpl implements Hello {
   ...
}</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf-interceptors"/>Apache CXF Interceptors</h3></div></div></div><p>
						The <code class="literal">jboss-webservices.xml</code> descriptor enables specifying the <code class="literal">cxf.interceptors.in</code> and <code class="literal">cxf.interceptors.out</code> properties. These properties allow you to attach the declaring interceptors to the <code class="literal">Bus</code> instance that is created for serving the deployment.
					</p><div class="title"><strong>Example: <code class="literal">jboss-webservices.xml</code> File</strong></div><p>
							
</p><pre class="programlisting">&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.2"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.interceptors.in&lt;/name&gt;
    &lt;value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.BusInterceptor&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;cxf.interceptors.out&lt;/name&gt;
    &lt;value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.BusCounterInterceptor&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre><p>

						</p><p>
						You can declare interceptors using one of the following approaches:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Annotation usage on endpoint classes, for example <code class="literal">@org.apache.cxf.interceptor.InInterceptor</code> or <code class="literal">@org.apache.cxf.interceptor.OutInterceptor</code>.
							</li><li class="listitem">
								Direct API usage on the client side through the <code class="literal">org.apache.cxf.interceptor.InterceptorProvider</code> interface.
							</li><li class="listitem">
								JBossWS descriptor usage.
							</li></ul></div><p>
						Because Spring integration is no longer supported in JBoss EAP, the JBossWS integration uses the <code class="literal">jaxws-endpoint-config.xml</code> descriptor file to avoid requiring modifications to the actual client or endpoint code. You can declare interceptors within predefined client and endpoint configurations by specifying a list of interceptor class names for the <code class="literal">cxf.interceptors.in</code> and <code class="literal">cxf.interceptors.out</code> properties.
					</p><div class="title"><strong>Example: <code class="literal">jaxws-endpoint-config.xml</code> File</strong></div><p>
							
</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointImpl&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.interceptors.in&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointInterceptor,org.jboss.test.ws.jaxws.cxf.interceptors.FooInterceptor&lt;/property-value&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.interceptors.out&lt;/property-name&gt;
      &lt;property-value&gt;org.jboss.test.ws.jaxws.cxf.interceptors.EndpointCounterInterceptor&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							A new instance of each specified interceptor class will be added to the client or endpoint to which the configuration is assigned. The interceptor classes must have a no-argument constructor.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_features"/>Apache CXF Features</h3></div></div></div><p>
						The <code class="literal">jboss-webservices.xml</code> descriptor enables specifying the <code class="literal">cxf.features</code> property. This property allows you to declare features to be attached to any endpoint belonging to the <code class="literal">Bus</code> instance that is created for serving the deployment.
					</p><div class="title"><strong>Example: <code class="literal">jboss-webservices.xml</code> File</strong></div><p>
							
</p><pre class="programlisting">&lt;?xml version="1.1" encoding="UTF-8"?&gt;
&lt;webservices
  xmlns="http://www.jboss.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="1.2"
  xsi:schemaLocation="http://www.jboss.com/xml/ns/javaee"&gt;

  &lt;property&gt;
    &lt;name&gt;cxf.features&lt;/name&gt;
    &lt;value&gt;org.apache.cxf.feature.FastInfosetFeature&lt;/value&gt;
  &lt;/property&gt;
&lt;/webservices&gt;</pre><p>

						</p><p>
						You can declare features using one of the following approaches:
					</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
								Annotation usage on endpoint classes, for example <code class="literal">@org.apache.cxf.feature.Features</code>.
							</li><li class="listitem">
								Direct API usage on client side through extensions of the <code class="literal">org.apache.cxf.feature.AbstractFeature</code> class.
							</li><li class="listitem">
								JBossWS descriptor usage.
							</li></ul></div><p>
						Since Spring integration is no longer supported in JBoss EAP, the JBossWS integration adds an additional descriptor, a <code class="literal">jaxws-endpoint-config.xml</code> file-based approach to avoid requiring modifications to the actual client or endpoint code. You can declare features within predefined client and endpoint configurations by specifying a list of feature class names for the <code class="literal">cxf.features</code> property.
					</p><div class="title"><strong>Example: <code class="literal">jaxws-endpoint-config.xml</code> File</strong></div><p>
							
</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jaxws-config xmlns="urn:jboss:jbossws-jaxws-config:4.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
  xsi:schemaLocation="urn:jboss:jbossws-jaxws-config:4.0 schema/jbossws-jaxws-config_4_0.xsd"&gt;
  &lt;endpoint-config&gt;
    &lt;config-name&gt;Custom FI Config&lt;/config-name&gt;
    &lt;property&gt;
      &lt;property-name&gt;cxf.features&lt;/property-name&gt;
      &lt;property-value&gt;org.apache.cxf.feature.FastInfosetFeature&lt;/property-value&gt;
    &lt;/property&gt;
  &lt;/endpoint-config&gt;
&lt;/jaxws-config&gt;</pre><p>

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
							A new instance of each specified feature class will be added to the client or endpoint the configuration is assigned to. The feature classes must have a no-argument constructor.
						</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="cxf_properties_driven_bean_creation"/>Properties-Driven Bean Creation</h3></div></div></div><p>
						The <a class="link" href="developing_jax_ws_web_services.html#cxf-interceptors" title="Apache CXF Interceptors">Apache CXF Interceptors</a> and <a class="link" href="developing_jax_ws_web_services.html#cxf_features" title="Apache CXF Features">Apache CXF Features</a> sections explain how to declare CXF interceptors and features through properties either in a client or endpoint predefined configuration or in a <code class="literal">jboss-webservices.xml</code> descriptor. By only getting the feature or interceptor class name specified, the container tries to create a bean instance using the class default constructor. This sets a limitation on the feature or interceptor configuration, unless custom extensions of vanilla CXF classes are provided, with the default constructor setting properties before eventually using the super constructor.
					</p><p>
						To address this issue, JBossWS integration comes with a mechanism for configuring simple bean hierarchies when building them up from properties. Properties can have bean reference values, which are strings starting with <code class="literal">##</code>. Property reference keys are used to specify the bean class name and the value for each attribute.
					</p><p>
						So for instance, the following properties result in the stack installing two feature instances:
					</p><div class="informaltable"><table border="1"><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><th style="text-align: left" valign="top">Key</th><th style="text-align: left" valign="top">Value</th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>
										cxf.features
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										##foo, ##bar
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										##foo
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										org.jboss.Foo
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										##foo.par
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										34
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										##bar
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										org.jboss.Bar
									</p>
									 </td></tr><tr><td style="text-align: left" valign="top"> <p>
										##bar.color
									</p>
									 </td><td style="text-align: left" valign="top"> <p>
										blue
									</p>
									 </td></tr></tbody></table></div><p>
						The same result can be created by the following code:
					</p><pre class="programlisting">import org.Bar;
import org.Foo;
...
Foo foo = new Foo();
foo.setPar(34);
Bar bar = new Bar();
bar.setColor("blue");</pre><p>
						This mechanism assumes that the classes are valid beans with proper <code class="literal">getter()</code> and <code class="literal">setter()</code> methods. Value objects are cast to the correct primitive type by inspecting the class definition. Nested beans can also be configured.
					</p></div></div></div></div></body></html>