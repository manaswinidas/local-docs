<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 1. Defining constraints</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="validator-defineconstraints">
      ⁠</a>Chapter 1. Defining constraints</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="validator-defineconstraints-definition">
      ⁠</a>1.1. What is a constraint?</h1></div></div></div><div class="para">
			A constraint is a rule that a given element (field, property or bean) has to comply to. The rule semantic is expressed by an annotation. A constraint usually has some attributes used to parameterize the constraints limits. The constraint applies to the annotated element.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="validator-defineconstraints-builtin">
      ⁠</a>1.2. Built in constraints</h1></div></div></div><div class="para">
			Hibernate Validator comes with some built-in constraints, which covers most basic data checks. As we will see later, you are not limited to them, you can literally in a minute write your own constraints.
		</div><div class="table"><a id="idm139883510936800">
      ⁠</a><p class="title"><strong>Table 1.1. Built-in constraints</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="gt-4-cols gt-14-rows" summary="Built-in constraints"><colgroup><col style="text-align: center"/><col/><col/><col/></colgroup><thead><tr><th style="text-align: center"> Annotation </th><th> Apply on </th><th> Runtime checking </th><th> Hibernate Metadata impact </th></tr></thead><tbody><tr><td style="text-align: center"> @Length(min=, max=) </td><td> property (String) </td><td> check if the string length match the range </td><td> Column length will be set to max </td></tr><tr><td style="text-align: center"> @Max(value=) </td><td> property (numeric or string representation of a numeric) </td><td> check if the value is less than or equals to max </td><td> Add a check constraint on the column </td></tr><tr><td style="text-align: center"> @Min(value=) </td><td> property (numeric or string representation of a numeric) </td><td> check if the value is more than or equals to min </td><td> Add a check constraint on the column </td></tr><tr><td style="text-align: center"> @NotNull </td><td> property </td><td> check if the value is not null </td><td> Column(s) are not null </td></tr><tr><td style="text-align: center"> @NotEmpty </td><td> property </td><td> check if the string is not null nor empty. Check if the connection is not null nor empty </td><td> Column(s) are not null (for String) </td></tr><tr><td style="text-align: center"> @Past </td><td> property (date or calendar) </td><td> check if the date is in the past </td><td> Add a check constraint on the column </td></tr><tr><td style="text-align: center"> @Future </td><td> property (date or calendar) </td><td> check if the date is in the future </td><td> none </td></tr><tr><td style="text-align: center"> @Pattern(regex="regexp", flag=) or @Patterns( {@Pattern(...)} ) </td><td> property (string) </td><td> check if the property match the regular expression given a match flag (see <code class="classname">java.util.regex.Pattern </code> ) </td><td> none </td></tr><tr><td style="text-align: center"> @Range(min=, max=) </td><td> property (numeric or string representation of a numeric) </td><td> check if the value is between min and max (included) </td><td> Add a check constraint on the column </td></tr><tr><td style="text-align: center"> @Size(min=, max=) </td><td> property (array, collection, map) </td><td> check if the element size is between min and max (included) </td><td> none </td></tr><tr><td style="text-align: center"> @AssertFalse </td><td> property </td><td> check that the method evaluates to false (useful for constraints expressed in code rather than annotations) </td><td> none </td></tr><tr><td style="text-align: center"> @AssertTrue </td><td> property </td><td> check that the method evaluates to true (useful for constraints expressed in code rather than annotations) </td><td> none </td></tr><tr><td style="text-align: center"> @Valid </td><td> property (object) </td><td> perform validation recursively on the associated object. If the object is a Collection or an array, the elements are validated recursively. If the object is a Map, the value elements are validated recursively. </td><td> none </td></tr><tr><td style="text-align: center"> @Email </td><td> property (String) </td><td> check whether the string is conform to the email address specification </td><td> none </td></tr><tr><td style="text-align: center"> @CreditCardNumber </td><td> property (String) </td><td> check whether the string is a well formatted credit card number (derivative of the Luhn algorithm) </td><td> none </td></tr><tr><td style="text-align: center"> @Digits(integerDigits=1) </td><td> property (numeric or string representation of a numeric) </td><td> check whether the property is a number having up to <code class="literal">integerDigits</code> integer digits and <code class="literal">fractionalDigits</code> fractional digits </td><td> define column precision and scale </td></tr><tr><td style="text-align: center"> @EAN </td><td> property (string) </td><td> check whether the string is a properly formatted EAN or UPC-A code </td><td> none </td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="validator-defineconstraints-error">
      ⁠</a>1.3. Error messages</h1></div></div></div><div class="para">
			Hibernate Validator comes with a default set of error messages translated in about ten languages (if yours is not part of it, please sent us a patch). You can override those messages by creating a <code class="filename">ValidatorMessages.properties</code> or ( <code class="filename">ValidatorMessages_loc.properties</code> ) and override the needed keys. You can even add your own additional set of messages while writing your validator annotations. If Hibernate Validator cannot resolve a key from your resourceBundle nor from ValidatorMessage, it falls back to the default built-in values.
		</div><div class="para">
			Alternatively you can provide a <code class="classname">ResourceBundle</code> while checking programmatically the validation rules on a bean or if you want a completely different interpolation mechanism, you can provide an implementation of <code class="literal">org.hibernate.validator.MessageInterpolator</code> (check the JavaDoc for more information).
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="validator-defineconstraints-own">
      ⁠</a>1.4. Writing your own constraints</h1></div></div></div><div class="para">
			Extending the set of built-in constraints is extremely easy. Any constraint consists of two pieces: the constraint <span class="emphasis"><em>descriptor</em></span> (the annotation) and the constraint <span class="emphasis"><em>validator</em></span> (the implementation class). Here is a simple user-defined descriptor:
		</div><pre class="programlisting">@ValidatorClass(CapitalizedValidator.class)
@Target(METHOD)
@Retention(RUNTIME)
@Documented
public @interface Capitalized {
    CapitalizeType type() default Capitalize.FIRST;
    String message() default "has incorrect capitalization"
}</pre><div class="para">
			<code class="literal">type</code> is a parameter describing how the property should to be capitalized. This is a user parameter fully dependent on the annotation business.
		</div><div class="para">
			<code class="literal">message</code> is the default string used to describe the constraint violation and is mandatory. You can hard code the string or you can externalize part/all of it through the Java ResourceBundle mechanism. Parameters values are going to be injected inside the message when the <code class="literal">{parameter}</code> string is found (in our example <code class="literal">Capitalization is not {type}</code> would generate <code class="literal">Capitalization is not FIRST</code> ), externalizing the whole string in <code class="filename">ValidatorMessages.properties</code> is considered good practice. See <a class="xref" href="validator-defineconstraints.html#validator-defineconstraints-error">Section 1.3, “Error messages”</a> .
		</div><pre class="programlisting">@ValidatorClass(CapitalizedValidator.class)
@Target(METHOD)
@Retention(RUNTIME)
@Documented
public @interface Capitalized {
    CapitalizeType type() default Capitalize.FIRST;
    String message() default "{validator.capitalized}";
}


#in ValidatorMessages.properties
validator.capitalized = <code class="literal">Capitalization is not {type}</code></pre><div class="para">
			As you can see the {} notation is recursive.
		</div><div class="para">
			To link a descriptor to its validator implementation, we use the <code class="literal">@ValidatorClass</code> meta-annotation. The validator class parameter must name a class which implements <code class="literal">Validator&lt;ConstraintAnnotation&gt;</code> .
		</div><div class="para">
			We now have to implement the validator (ie. the rule checking implementation). A validation implementation can check the value of the a property (by implementing <code class="literal">PropertyConstraint</code> ) and/or can modify the hibernate mapping metadata to express the constraint at the database level (by implementing <code class="literal">PersistentClassConstraint</code> )
		</div><pre class="programlisting">public class CapitalizedValidator
        implements Validator&lt;Capitalized&gt;, PropertyConstraint {
    private CapitalizeType type;

    //part of the Validator&lt;Annotation&gt; contract,
    //allows to get and use the annotation values
    public void initialize(Capitalized parameters) {
        type = parameters.type();
    }

    //part of the property constraint contract
    public boolean isValid(Object value) {
        if (value==null) return true;
        if ( !(value instanceof String) ) return false;
        String string = (String) value;
        if (type == CapitalizeType.ALL) {
            return string.equals( string.toUpperCase() );
        }
        else {
            String first = string.substring(0,1);
            return first.equals( first.toUpperCase();
        }
    }
}</pre><div class="para">
			The <code class="literal">isValid()</code> method should return false if the constraint has been violated. For more examples, refer to the built-in validator implementations.
		</div><div class="para">
			We only have seen property level validation, but you can write a Bean level validation annotation. Instead of receiving the return instance of a property, the bean itself will be passed to the validator. To activate the validation checking, just annotated the bean itself instead. A small sample can be found in the unit test suite.
		</div><div class="para">
			If your constraint can be applied multiple times (with different parameters) on the same property or type, you can use the following annotation form:
		</div><pre class="programlisting">@Target(METHOD)
@Retention(RUNTIME)
@Documented
<span class="bold bold"><strong>public @interface Patterns {</strong></span>
    Pattern[] value();
}

@Target(METHOD)
@Retention(RUNTIME)
@Documented
@ValidatorClass(PatternValidator.class)
public @interface Pattern {
    String regexp();
}</pre><div class="para">
			Basically an annotation containing the value attribute as an array of validator annotations.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139883516545408">
      ⁠</a>1.5. Annotating your domain model</h1></div></div></div><div class="para">
			Since you are already familiar with annotations now, the syntax should be very familiar
		</div><pre class="programlisting">public class Address {
    private String line1;
    private String line2;
    private String zip;
    private String state;
    private String country;
    private long id;

    // a not null string of 20 characters maximum
    @Length(max=20)
    @NotNull
    public String getCountry() {
        return country;
    }

    // a non null string
    @NotNull
    public String getLine1() {
        return line1;
    }

    //no constraint
    public String getLine2() {
        return line2;
    }

    // a not null string of 3 characters maximum
    @Length(max=3) @NotNull
    public String getState() {
        return state;
    }

    // a not null numeric string of 5 characters maximum
    // if the string is longer, the message will
    //be searched in the resource bundle at key 'long'
    @Length(max=5, message="{long}")
    @Pattern(regex="[0-9]+")
    @NotNull
    public String getZip() {
        return zip;
    }

    // should always be true
    @AssertTrue
    public boolean isValid() {
        return true;
    }

    // a numeric between 1 and 2000
    @Id @Min(1)
    @Range(max=2000)
    public long getId() {
        return id;
    }
}</pre><div class="para">
			While the example only shows public property validation, you can also annotate fields of any kind of visibility
		</div><pre class="programlisting">@MyBeanConstraint(max=45)
public class Dog {
    @AssertTrue private boolean isMale;
    @NotNull protected String getName() { ... };
    ...
}</pre><div class="para">
			You can also annotate interfaces. Hibernate Validator will check all superclasses and interfaces extended or implemented by a given bean to read the appropriate validator annotations.
		</div><pre class="programlisting">public interface Named {
    @NotNull String getName();
    ...
}

public class Dog implements Named {

    @AssertTrue private boolean isMale;

    public String getName() { ... };

}
</pre><div class="para">
			The name property will be checked for nullity when the Dog bean is validated.
		</div></div></div></body></html>