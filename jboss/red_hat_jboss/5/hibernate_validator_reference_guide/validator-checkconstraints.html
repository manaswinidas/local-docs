<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 2. Using the Validator framework</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="validator-checkconstraints">
      ⁠</a>Chapter 2. Using the Validator framework</h1></div></div></div><div class="para">
		Hibernate Validator is intended to be used to implement multi-layered data validation, where constraints are expressed in a single place (the annotated domain model) and checked in various different layers of the application.
	</div><div class="para">
		This chapter will cover Hibernate Validator usage for different layers
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="validator-checkconstraints-db">
      ⁠</a>2.1. Database schema-level validation</h1></div></div></div><div class="para">
			Out of the box, Hibernate Annotations will translate the constraints you have defined for your entities into mapping metadata. For example, if a property of your entity is annotated <code class="literal">@NotNull</code>, its columns will be declared as <code class="literal">not null</code> in the DDL schema generated by Hibernate.
		</div><div class="para">
			Using hbm2ddl, domain model constraints will be expressed into the database schema.
		</div><div class="para">
			If, for some reason, the feature needs to be disabled, set <code class="literal">hibernate.validator.apply_to_ddl</code> to <code class="literal">false</code>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="validator-checkconstraints-orm">
      ⁠</a>2.2. ORM integration</h1></div></div></div><div class="para">
			Hibernate Validator integrates with both Hibernate and all pure Java Persistence providers
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints-orm-hibernateevent">
      ⁠</a>2.2.1. Hibernate event-based validation</h2></div></div></div><div class="para">
				Hibernate Validator has two built-in Hibernate event listeners. Whenever a <code class="literal">PreInsertEvent</code> or <code class="literal">PreUpdateEvent</code> occurs, the listeners will verify all constraints of the entity instance and throw an exception if any constraint is violated. Basically, objects will be checked before any inserts and before any updates made by Hibernate. This includes changes applied by cascade! This is the most convenient and the easiest way to activate the validation process. On constraint violation, the event will raise a runtime <code class="classname">InvalidStateException</code> which contains an array of <code class="literal">InvalidValue</code>s describing each failure.
			</div><div class="para">
				If Hibernate Validator is present in the classpath, Hibernate Annotations (or Hibernate EntityManager) will use it transparently. If, for some reason, you want to disable this integration, set <code class="literal">hibernate.validator.autoregister_listeners</code> to false
			</div><div class="para">
				<div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						If the beans are not annotated with validation annotations, there is no runtime performance cost.
					</div></div></div>

			</div><div class="para">
				In case you need to manually set the event listeners for Hibernate Core, use the following configuration in <code class="literal">hibernate.cfg.xml</code>:
			</div><pre class="programlisting">&lt;hibernate-configuration&gt;
    ...
    &lt;event type="pre-update"&gt;
        &lt;listener 
          class="org.hibernate.validator.event.ValidateEventListener"/&gt;
    &lt;/event&gt;
    &lt;event type="pre-insert"&gt;
        &lt;listener 
          class="org.hibernate.validator.event.ValidateEventListener"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints-orm-jpaevent">
      ⁠</a>2.2.2. Java Persistence event-based validation</h2></div></div></div><div class="para">
				Hibernate Validator is not tied to Hibernate for event based validation: a Java Persistence entity listener is available. Whenever an listened entity is persisted or updated, Hibernate Validator will verify all constraints of the entity instance and throw an exception if any constraint is violated. Basically, objects will be checked before any inserts and before any updates made by the Java Persistence provider. This includes changes applied by cascade! On constraint violation, the event will raise a runtime <code class="classname">InvalidStateException</code> which contains an array of <code class="literal">InvalidValue</code>s describing each failure.
			</div><div class="para">
				Here is how to make a class validatable:
			</div><pre class="programlisting">@Entity
@EntityListeners( JPAValidateListener.class )
public class Submarine {
    ...
}</pre><div class="para">
				<div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Compared to the Hibernate event, the Java Persistence listener has two drawbacks. You need to define the entity listener on every validatable entity. The DDL generated by your provider will not reflect the constraints.
					</div></div></div>

			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139883525665328">
      ⁠</a>2.3. Application-level validation</h1></div></div></div><div class="para">
			Hibernate Validator can be applied anywhere in your application code.
		</div><pre class="programlisting">ClassValidator personValidator = new ClassValidator( Person.class );
ClassValidator addressValidator = new ClassValidator( Address.class, ResourceBundle.getBundle("messages", Locale.ENGLISH) );

InvalidValue[] validationMessages = addressValidator.getInvalidValues(address);</pre><div class="para">
			The first two lines prepare the Hibernate Validator for class checking. The first one relies upon the error messages embedded in Hibernate Validator (see <a class="xref" href="validator-defineconstraints.html#validator-defineconstraints-error">Section 1.3, “Error messages”</a>), the second one uses a resource bundle for these messages. It is considered a good practice to execute these lines once and cache the validator instances.
		</div><div class="para">
			The third line actually validates the <code class="literal">Address</code> instance and returns an array of <code class="literal">InvalidValue</code>s. Your application logic will then be able to react to the failure.
		</div><div class="para">
			You can also check a particular property instead of the whole bean. This might be useful for property per property user interaction
		</div><pre class="programlisting">ClassValidator addressValidator = new ClassValidator( Address.class, ResourceBundle.getBundle("messages", Locale.ENGLISH) );

//only get city property invalid values
InvalidValue[] validationMessages = addressValidator.getInvalidValues(address, "city");

//only get potential city property invalid values
InvalidValue[] validationMessages = addressValidator.getPotentialInvalidValues("city", "Paris");</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139883533874816">
      ⁠</a>2.4. Presentation layer validation</h1></div></div></div><div class="para">
			When working with JSF and <span class="productname">JBoss Seam</span>, one can triggers the validation process at the presentation layer using Seam's JSF tags <code class="literal">&lt;s:validate&gt;</code> and <code class="literal">&lt;s:validateAll/&gt;</code>, letting the constraints be expressed on the model, and the violations presented in the view
		</div><pre class="programlisting">&lt;h:form&gt;
    &lt;div&gt;
        &lt;h:messages/&gt;
    &lt;/div&gt;
    <span class="bold bold"><strong>&lt;s:validateAll&gt;</strong></span>
        &lt;div&gt;
            Country:
            &lt;h:inputText value="#{location.country}" required="true"/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            Zip code:
            &lt;h:inputText value="#{location.zip}" required="true"/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;h:commandButton/&gt;
        &lt;/div&gt;
    <span class="bold bold"><strong>&lt;/s:validateAll&gt;</strong></span>
&lt;/h:form&gt;</pre><div class="para">
			Going even further, and adding <span class="productname">Ajax4JSF</span> to the loop will bring client side validation with just a couple of additional JSF tags, again without validation definition duplication.
		</div><div class="para">
			Check the <a href="http://www.jboss.com/products/seam">JBoss Seam</a> documentation for more information.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139883504669760">
      ⁠</a>2.5. Validation information</h1></div></div></div><div class="para">
			As a validation information carrier, hibernate provide an array of <code class="classname">InvalidValue</code>. Each <code class="literal">InvalidValue</code> has many methods describing the individual issues.
		</div><div class="para">
			<code class="methodname">getBeanClass()</code> retrieves the failing bean type
		</div><div class="para">
			<code class="methodname">getBean()</code>retrieves the failing instance (if any ie not when using <code class="methodname">getPotentianInvalidValues()</code>)
		</div><div class="para">
			<code class="methodname">getValue()</code> retrieves the failing value
		</div><div class="para">
			<code class="methodname">getMessage()</code> retrieves the proper internationalized error message
		</div><div class="para">
			<code class="methodname">getRootBean()</code> retrieves the root bean instance generating the issue (useful in conjunction with <code class="literal">@Valid</code>), is null if getPotentianInvalidValues() is used.
		</div><div class="para">
			<code class="literal">getPropertyPath()</code> retrieves the dotted path of the failing property starting from the root bean
		</div></div></div></body></html>