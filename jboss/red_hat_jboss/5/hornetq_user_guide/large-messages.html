<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 21. Large Messages</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="large-messages">
      ⁠</a>Chapter 21. Large Messages</h1></div></div></div><div class="para">
		HornetQ supports sending and receiving of large messages, even when the client and server are running with limited memory. The only realistic limit to the size of a message that can be sent or consumed is the amount of disk space you have available.
	</div><div class="para">
		To send a large message, the user can set an <code class="literal">InputStream</code> on a message body. When that message is sent, HornetQ will read the <code class="literal">InputStream</code>. For example, a <code class="literal">FileInputStream</code> could be used to send a large message from a large file on disk.
	</div><div class="para">
		As the <code class="literal">InputStream</code> is read, the data is sent to the server as a stream of fragments. The server persists these fragments to disk as it receives them. When the time comes to deliver them to a consumer they are read back off the disk, also in fragments, and re-transmitted. When the consumer receives a large message it initially receives just the message with an empty body. It can then set an <code class="literal">OutputStream</code> on the message to stream the large message body to a file on disk or elsewhere. At no time is the entire message body stored fully in memory, either on the client or the server.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="large.message.configuring">
      ⁠</a>21.1. Configuring the server</h1></div></div></div><div class="para">
			Large messages are stored on a disk directory on the server side, as configured in <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/jboss-as/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/hornetq/hornetq-configuration.xml</code>.
		</div><div class="para">
			The configuration property <code class="literal">large-messages-directory</code> specifies where large messages are stored.
		</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;configuration</span><span xmlns="" class="perl_Others"> xmlns=</span><span xmlns="" class="perl_String">"urn:hornetq"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">  xmlns:xsi=</span><span xmlns="" class="perl_String">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Others">  xsi:schemaLocation=</span><span xmlns="" class="perl_String">"urn:hornetq /schema/hornetq-configuration.xsd"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>...
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;large-messages-directory&gt;</span>${jboss.server.data.dir}/${hornetq.data.dir:hornetq}/largemessages<span xmlns="" class="perl_Keyword">&lt;/large-messages-directory&gt;</span>
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>...
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/configuration&gt;</span></pre><div class="para">
			By default the large message directory is <code class="literal">data/large-messages</code>.
		</div><div class="para">
			For the best performance it is recommended that the large messages directory is stored on a different physical volume to the message journal or paging directory.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905865315296">
      ⁠</a>21.2. Setting the limits</h1></div></div></div><div class="para">
			Any message larger than a certain size is considered a large message. Large messages will be split up and sent in fragments. This is determined by the parameter <code class="literal">min-large-message-size</code>.
		</div><div class="para">
			The default value is 100KiB.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="large-messages.core.config">
      ⁠</a>21.2.1. Using Core API</h2></div></div></div><div class="para">
				If the HornetQ Core API is used, the minimum large message size is specified by <code class="literal">ClientSessionFactory.setMinLargeMessageSize</code>.
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>ClientSessionFactory factory = 
<span xmlns="" class="line">​</span>  HornetQClient.<span xmlns="" class="perl_Function">createClientSessionFactory</span>(<span xmlns="" class="perl_Keyword">new</span> 
<span xmlns="" class="line">​</span>  <span xmlns="" class="perl_Function">TransportConfiguration</span>(NettyConnectorFactory.<span xmlns="" class="perl_Function">class</span>.<span xmlns="" class="perl_Function">getName</span>()), <span xmlns="" class="perl_Keyword">null</span>);
<span xmlns="" class="line">​</span>factory.<span xmlns="" class="perl_Function">setMinLargeMessageSize</span>(<span xmlns="" class="perl_Float">25</span> * <span xmlns="" class="perl_Float">1024</span>);</pre><div class="para">
				<a class="xref" href="configuring-transports.html#configuring-transports.client.side">Section 14.3, “Configuring the transport directly from the client side”</a> provides more information on how to instantiate the session factory.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905804763680">
      ⁠</a>21.2.2. Using JMS</h2></div></div></div><div class="para">
				If JNDI is used to look up the connection factory, the minimum large message size is specified in <code class="filename"><em class="replaceable">JBOSS_DIST</em>/jboss-as/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/hornetq/hornetq-jms.xml</code>.
			</div><pre class="programlisting"><span xmlns="" class="line">​</span>...
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;connection-factory</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"NettyConnectionFactory"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;connectors&gt;</span>
<span xmlns="" class="line">​</span>     <span xmlns="" class="perl_Keyword">&lt;connector-ref</span><span xmlns="" class="perl_Others"> connector-name=</span><span xmlns="" class="perl_String">"netty"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/connectors&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;entries&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;entry</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"/ConnectionFactory"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;entry</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"/XAConnectionFactory"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/entries&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;min-large-message-size&gt;</span>250000<span xmlns="" class="perl_Keyword">&lt;/min-large-message-size&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/connection-factory&gt;</span>
<span xmlns="" class="line">​</span>...</pre><div class="para">
				If the connection factory is being instantiated directly, the minimum large message size is specified by <code class="literal">HornetQConnectionFactory.setMinLargeMessageSize</code>.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905853840208">
      ⁠</a>21.3. Streaming large messages</h1></div></div></div><div class="para">
			HornetQ supports setting the body of messages using input and output streams (<code class="literal">java.lang.io</code>).
		</div><div class="para">
			These streams are then used directly for sending (input streams) and receiving (output streams) messages.
		</div><div class="para">
			When receiving messages there are two ways to deal with the output stream; you may choose to block while the output stream is recovered using the method <code class="literal">ClientMessage.saveOutputStream</code> or alternatively using the method <code class="literal">ClientMessage.setOutputstream</code> which will asynchronously write the message to the stream. If you choose the latter the consumer must be kept alive until the message has been fully received.
		</div><div class="para">
			You can use any kind of stream you like. The most common use case is to send files stored on your disk, but you could also send things such as:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					JDBC Blobs
				</div></li><li class="listitem"><div class="para">
					<code class="literal">SocketInputStream</code>
				</div></li><li class="listitem"><div class="para">
					Things recovered from <code class="literal">HTTPRequests</code>, and so on.
				</div></li></ul></div><div class="para">
			Anything that implements <code class="literal">java.io.InputStream</code> for sending messages, or <code class="literal">java.io.OutputStream</code> for receiving them can be used.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905855799200">
      ⁠</a>21.3.1. Streaming over Core API</h2></div></div></div><div class="para">
				The following table shows a list of methods available at <code class="literal">ClientMessage</code> which are also available through JMS by the use of object properties.
			</div><div class="table"><a id="large-messages.ClientMessageAPI">
      ⁠</a><p class="title"><strong>Table 21.1. org.hornetq.api.core.client.ClientMessage API</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="org.hornetq.api.core.client.ClientMessage API"><colgroup><col class="Name"/><col class="Descr"/><col class="JMS"/></colgroup><thead><tr><th> Name </th><th> Description </th><th> JMS Equivalent Property </th></tr></thead><tbody><tr><td> setBodyInputStream (InputStream) </td><td> Set the InputStream used to read a message body when sending it. </td><td> JMS_HQ_InputStream </td></tr><tr><td> setOutputStream (OutputStream) </td><td> Set the OutputStream that will receive the body of a message. This method does not block. </td><td> JMS_HQ_OutputStream </td></tr><tr><td> saveToOutputStream (OutputStream) </td><td> Save the body of the message to the <code class="literal">OutputStream</code>. It will block until the entire content is transferred to the <code class="literal">OutputStream</code>. </td><td> JMS_HQ_SaveStream </td></tr></tbody></table></div></div><div class="para">
				To set the output stream when receiving a core message:
			</div><pre class="programlisting">...
ClientMessage msg = consumer.receive(...);

// This will block here until the stream was transferred
msg.saveToOutputStream(someOutputStream); 

ClientMessage msg2 = consumer.receive(...);

// This will not wait the transfer to finish
msg.setOutputStream(someOtherOutputStream); 
...</pre><div class="para">
				Set the input stream when sending a core message:
			</div><pre class="programlisting">...
ClientMessage msg = session.createMessage();
msg.setInputStream(dataInputStream);
...</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="large-messages.streaming.over.jms">
      ⁠</a>21.3.2. Streaming over JMS</h2></div></div></div><div class="para">
				When using JMS, HornetQ maps the streaming methods on the core API (see <a class="xref" href="large-messages.html#large-messages.ClientMessageAPI">Table 21.1, “org.hornetq.api.core.client.ClientMessage API”</a>) by setting object properties. You can use the method <code class="literal">Message.setObjectProperty</code> to set the input and output streams.
			</div><div class="para">
				The <code class="literal">InputStream</code> can be defined through the JMS Object Property JMS_HQ_InputStream on messages being sent:
			</div><pre class="programlisting">BytesMessage message = session.createBytesMessage();

FileInputStream fileInputStream = new FileInputStream(fileInput);

BufferedInputStream bufferedInput = new BufferedInputStream(fileInputStream);

message.setObjectProperty("JMS_HQ_InputStream", bufferedInput);

someProducer.send(message);</pre><div class="para">
				The <code class="literal">OutputStream</code> can be set through the JMS Object Property JMS_HQ_SaveStream on messages being received in a blocking way.
			</div><pre class="programlisting">BytesMessage messageReceived = (BytesMessage)messageConsumer.receive(120000);
                
File outputFile = new File("huge_message_received.dat");
                
FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
                
BufferedOutputStream bufferedOutput = new BufferedOutputStream(fileOutputStream);
                
// This will block until the entire content is saved on disk
messageReceived.setObjectProperty("JMS_HQ_SaveStream", bufferedOutput);</pre><div class="para">
				Setting the <code class="literal">OutputStream</code> could also be done in a non-blocking way using the property JMS_HQ_OutputStream.
			</div><pre class="programlisting">// This will not wait the stream to finish. You need to keep the consumer active.
messageReceived.setObjectProperty("JMS_HQ_OutputStream", bufferedOutput);</pre><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					When using JMS, Streaming large messages are only supported on <code class="literal">StreamMessage</code> and <code class="literal">BytesMessage</code>.
				</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905872077456">
      ⁠</a>21.4. Streaming Alternative</h1></div></div></div><div class="para">
			If you choose not to use the <code class="literal">InputStream</code> or <code class="literal">OutputStream</code> capability of HornetQ, the data can still be accessed directly in an alternative fashion.
		</div><div class="para">
			On the Core API, get the bytes of the body as described in <a class="xref" href="using-core.html">Chapter 7, <em>Using Core</em></a>.
		</div><pre class="programlisting">ClientMessage msg = consumer.receive();
         
byte[] bytes = new byte[1024];
for (int i = 0 ;  i &lt; msg.getBodySize(); i += bytes.length)
{
   msg.getBody().readBytes(bytes);
   // Whatever you want to do with the bytes
}</pre><div class="para">
			If using JMS API, <code class="literal">BytesMessage</code> and <code class="literal">StreamMessage</code> also supports it transparently.
		</div><pre class="programlisting">BytesMessage rm = (BytesMessage)cons.receive(10000);

byte data[] = new byte[1024];

for (int i = 0; i &lt; rm.getBodyLength(); i += 1024)
{
   int numberOfBytes = rm.readBytes(data);
   // Do whatever you want with the data
}</pre></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="large-messages.cache.client">
      ⁠</a>21.5. Cache Large Messages on client</h1></div></div></div><div class="para">
			Large messages are transferred from server to client by streaming. The message is broken into smaller packets and more packets will be received as the message is read. It is because of this that the body of the large message can be read only once, and by consequence a received message can be sent to another producer only once. The JMS Bridge for instance will not be able to resend a large message in case of failure.
		</div><div class="para">
			To solve this problem, you can enable the property <code class="literal">cache-large-message-client</code> in the connection factory. If you enable this property the client consumer will create a temporary file to hold the large message content, so it would be possible to resend large messages.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Use this option in the connection factory used by the JMS Bridge if the JMS Bridge is being used for large messages.
			</div></div></div></div></div></body></html>