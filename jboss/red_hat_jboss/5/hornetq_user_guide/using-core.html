<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 7. Using Core</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="using-core">
      ⁠</a>Chapter 7. Using Core</h1></div></div></div><div class="para">
		HornetQ core is a completely JMS-agnostic messaging system with its own non-JMS API. This is called the <span class="emphasis"><em>core API</em></span>.
	</div><div class="para">
		You can use the core API directly if you do not want to use JMS. The core API provides all the functionality of JMS but without much of the complexity. It also provides features that are not available using JMS.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905859513072">
      ⁠</a>7.1. Core Messaging Concepts</h1></div></div></div><div class="para">
			Some of the core messaging concepts are similar to JMS concepts, but there are still differences between them. In general, the core messaging API is simpler than the JMS API, since distinctions between queues, topics and subscriptions are removed. Each of these major core messaging concepts will be discussed in turn.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905849854928">
      ⁠</a>7.1.1. Message</h2></div></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						A message is the unit of data that is sent between clients and servers.
					</div></li><li class="listitem"><div class="para">
						A message has a body which is a buffer containing convenient methods for reading and writing data into it.
					</div></li><li class="listitem"><div class="para">
						A message has a set of properties which are key-value pairs. Each property key is a string and property values can be of type integer, long, short, byte, byte[], String, double, float or boolean.
					</div></li><li class="listitem"><div class="para">
						A message has an <span class="emphasis"><em>address</em></span> it is being sent to. When the message arrives on the server it is routed to any queues that are bound to the address - if the queues are bound with any filter, the message will only be routed to that queue if the filter matches. An address may have many queues bound to it or none. There may also be entities other than queues, like <span class="italic italic">diverts</span> bound to addresses.
					</div></li><li class="listitem"><div class="para">
						Messages can be either durable or non durable. Durable messages in a durable queue will survive a server crash or restart. Non durable messages will not survive a server crash or restart.
					</div></li><li class="listitem"><div class="para">
						Messages can be specified with a priority value between 0 and 9. 0 represents the lowest priority and 9 represents the highest. HornetQ will attempt to deliver higher priority messages before lower priority ones.
					</div></li><li class="listitem"><div class="para">
						Messages can be specified with an optional expiry time. HornetQ will not deliver messages after its expiry time has been exceeded.
					</div></li><li class="listitem"><div class="para">
						Messages have an optional time stamp which represents the time the message was sent.
					</div></li><li class="listitem"><div class="para">
						HornetQ also supports the sending or consuming of very large messages - much larger than can fit in available RAM at any one time.
					</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905871092336">
      ⁠</a>7.1.2. Address</h2></div></div></div><div class="para">
				A server maintains a mapping between an address and a set of queues. Zero or more queues can be bound to a single address. Each queue can be bound with an optional message filter. When a message is routed, it is routed to the set of queues bound to the message's address. If any of the queues are bound with a filter expression, then the message will only be routed to the subset of bound queues which match that filter expression.
			</div><div class="para">
				Other entities, such as <span class="italic italic">diverts</span> can also be bound to an address and messages will also be routed there.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					In core, there is no concept of a topic; topic is a JMS only term. Instead, in core, we just deal with <span class="emphasis"><em>addresses</em></span> and <span class="emphasis"><em>queues</em></span>.
				</div><div class="para">
					For example, a JMS topic would be implemented by a single address to which many queues are bound. Each queue represents a subscription of the topic. A JMS queue would be implemented as a single address to which one queue is bound; that queue represents the JMS queue.
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905810440128">
      ⁠</a>7.1.3. Queue</h2></div></div></div><div class="para">
				Queues can be durable, which means the messages they contain survive a server crash or restart, as long as the messages in them are durable. Non-durable queues do not survive a server restart or crash even if the messages they contain are durable.
			</div><div class="para">
				Queues can also be temporary, meaning they are automatically deleted when the client connection is closed, if they are not explicitly deleted before that.
			</div><div class="para">
				Queues can be bound with an optional filter expression. If a filter expression is supplied then the server will only route messages that match that filter expression to any queues bound to the address.
			</div><div class="para">
				Many queues can be bound to a single address. A particular queue is only bound to a maximum of one address.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905810436576">
      ⁠</a>7.1.4. ClientSessionFactory</h2></div></div></div><div class="para">
				Clients use <code class="literal">ClientSessionFactory</code> instances to create <code class="literal">ClientSession</code> instances. <code class="literal">ClientSessionFactory</code> instances know how to connect to the server to create sessions, and are configurable with many settings.
			</div><div class="para">
				<code class="literal">ClientSessionFactory</code> instances are created using the <code class="literal">HornetQClient</code> factory class.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905838897744">
      ⁠</a>7.1.5. ClientSession</h2></div></div></div><div class="para">
				A client uses a ClientSession for consuming and producing messages and for grouping them in transactions. ClientSession instances can support both transactional and non transactional semantics and also provide an <code class="literal">XAResource</code> interface so messaging operations can be performed as part of a JTA transaction.
			</div><div class="para">
				ClientSession instances group ClientConsumers and ClientProducers.
			</div><div class="para">
				ClientSession instances can be registered with an optional <code class="literal">SendAcknowledgementHandler</code>. This allows your client code to be notified asynchronously when sent messages have successfully reached the server. This feature ensures sent messages have reached the server without having to block on each message sent until a response is received.
			</div><div class="para">
				Blocking on each messages sent is costly since it requires a network round trip for each message sent. By not blocking and receiving send acknowledgments asynchronously, you can create true end-to-end asynchronous systems which is not possible using the standard JMS API. For more information on this feature refer to <a class="xref" href="send-guarantees.html">Chapter 18, <em>Guarantees of sends and commits</em></a>.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905847432336">
      ⁠</a>7.1.6. ClientConsumer</h2></div></div></div><div class="para">
				Clients use <code class="literal">ClientConsumer</code> instances to consume messages from a queue. Core Messaging supports both synchronous and asynchronous message consumption semantics. <code class="literal">ClientConsumer</code> instances can be configured with an optional filter expression and will only consume messages which match that expression.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905849981232">
      ⁠</a>7.1.7. ClientProducer</h2></div></div></div><div class="para">
				Clients create <code class="literal">ClientProducer</code> instances on <code class="literal">ClientSession</code> instances so they can send messages. ClientProducer instances can specify an address to which all sent messages are routed, or they can have no specified address, and the address is specified at send time for the message.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
					ClientSession, ClientProducer and ClientConsumer instances are <span class="emphasis"><em>designed to be re-used</em></span>.
				</div><div class="para">
					It is an anti-pattern to create new ClientSession, ClientProducer, and ClientConsumer instances for each message you produce or consume. If you do this, your application will suffer from poor performance. This is discussed further in <a class="xref" href="perf-tuning.html">Chapter 43, <em>Performance Tuning</em></a>.
				</div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905867984736">
      ⁠</a>7.2. Simple Core Example</h1></div></div></div><div class="para">
			Here is a very simple program using the core messaging API to send and receive a message:
		</div><pre class="programlisting"><span xmlns="" class="line">​</span>ClientSessionFactory factory =  HornetQClient.<span xmlns="" class="perl_Function">createClientSessionFactory</span>(
<span xmlns="" class="line">​</span>                                        <span xmlns="" class="perl_Keyword">new</span> <span xmlns="" class="perl_Function">TransportConfiguration</span>(
<span xmlns="" class="line">​</span>                                           InVMConnectorFactory.<span xmlns="" class="perl_Function">class</span>.<span xmlns="" class="perl_Function">getName</span>()));
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>ClientSession session = factory.<span xmlns="" class="perl_Function">createSession</span>();
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>session.<span xmlns="" class="perl_Function">createQueue</span>(<span xmlns="" class="perl_String">"example"</span>, <span xmlns="" class="perl_String">"example"</span>, <span xmlns="" class="perl_Keyword">true</span>);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>ClientProducer producer = session.<span xmlns="" class="perl_Function">createProducer</span>(<span xmlns="" class="perl_String">"example"</span>);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>ClientMessage message = session.<span xmlns="" class="perl_Function">createMessage</span>(<span xmlns="" class="perl_Keyword">true</span>);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>message.<span xmlns="" class="perl_Function">getBodyBuffer</span>().<span xmlns="" class="perl_Function">writeString</span>(<span xmlns="" class="perl_String">"Hello"</span>);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>producer.<span xmlns="" class="perl_Function">send</span>(message);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>session.<span xmlns="" class="perl_Function">start</span>();
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>ClientConsumer consumer = session.<span xmlns="" class="perl_Function">createConsumer</span>(<span xmlns="" class="perl_String">"example"</span>);
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>ClientMessage msgReceived = consumer.<span xmlns="" class="perl_Function">receive</span>();
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>System.<span xmlns="" class="perl_Function">out</span>.<span xmlns="" class="perl_Function">println</span>(<span xmlns="" class="perl_String">"message = "</span> + msgReceived.<span xmlns="" class="perl_Function">getBodyBuffer</span>().<span xmlns="" class="perl_Function">readString</span>());
<span xmlns="" class="line">​</span>
<span xmlns="" class="line">​</span>session.<span xmlns="" class="perl_Function">close</span>();</pre></div></div></body></html>