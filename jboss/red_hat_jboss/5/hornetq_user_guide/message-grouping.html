<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 26. Message Grouping</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="message-grouping">
      ⁠</a>Chapter 26. Message Grouping</h1></div></div></div><div class="para">
		Message groups are sets of messages that have the following characteristics:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				Messages in a message group share the same group id; that is, they have the same group identifier property (<code class="literal">JMSXGroupID</code> for JMS, <code class="literal">_HQ_GROUP_ID</code> for HornetQ Core API).
			</div></li><li class="listitem"><div class="para">
				Messages in a message group are always consumed by the same consumer, even if there are many consumers on a queue. They pin all messages with the same group id to the same consumer. If that consumer closes another consumer is chosen and will receive all messages with the same group id.
			</div></li></ul></div><div class="para">
		Message groups are useful when you want all messages for a certain value of the property to be processed serially by the same consumer.
	</div><div class="para">
		An example might be orders for a certain stock. You may want orders for any particular stock to be processed serially by the same consumer. To do this you can create a pool of consumers (perhaps one for each stock), then set the stock name as the value of the _HQ_GROUP_ID property.
	</div><div class="para">
		This will ensure that all messages for a particular stock will always be processed by the same consumer.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905852593712">
      ⁠</a>26.1. Using Core API</h1></div></div></div><div class="para">
			The property name used to identify the message group is <code class="literal">"_HQ_GROUP_ID"</code> (or the constant <code class="literal">MessageImpl.HDR_GROUP_ID</code>). Alternatively, you can set <code class="literal">autogroup</code> to true on the <code class="literal">SessionFactory</code> which will pick a random unique id.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="message-grouping.jmsconfigure">
      ⁠</a>26.2. Using JMS</h1></div></div></div><div class="para">
			The property name used to identify the message group is <code class="literal">JMSXGroupID</code>.
		</div><pre class="programlisting">
 // send 2 messages in the same group to ensure the same
 // consumer will receive both
 Message message = ...
 message.setStringProperty("JMSXGroupID", "Group-0");
 producer.send(message);

 message = ...
 message.setStringProperty("JMSXGroupID", "Group-0");
 producer.send(message);
</pre><div class="para">
			Alternatively, you can set <code class="literal">autogroup</code> to true on the <code class="literal">HornetQConnectionFactory</code> which will pick a random unique id. This can also be set in the <code class="filename"><em class="replaceable">JBOSS_DIST</em>/jboss-as/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/hornetq/hornetq-jms.xml</code> file like this:
		</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;connection-factory</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"NettyConnectionFactory"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;connectors&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;connector-ref</span><span xmlns="" class="perl_Others"> connector-name=</span><span xmlns="" class="perl_String">"netty-connector"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/connectors&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;entries&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;entry</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"/ConnectionFactory"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/entries&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;autogroup&gt;</span>true<span xmlns="" class="perl_Keyword">&lt;/autogroup&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/connection-factory&gt;</span>
</pre><div class="para">
			Alternatively you can set the group id via the connection factory. All messages sent with producers created via this connection factory will set the <code class="literal">JMSXGroupID</code> to the specified value on all messages sent. To configure the group id set it on the connection factory in the <code class="literal">hornetq-jms.xml</code> configuration file as follows: 
<pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;connection-factory</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"NettyConnectionFactory"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;connectors&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;connector-ref</span><span xmlns="" class="perl_Others"> connector-name=</span><span xmlns="" class="perl_String">"netty-connector"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/connectors&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;entries&gt;</span>
<span xmlns="" class="line">​</span>      <span xmlns="" class="perl_Keyword">&lt;entry</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"/ConnectionFactory"</span><span xmlns="" class="perl_Keyword">/&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;/entries&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;group-id&gt;</span>Group-0<span xmlns="" class="perl_Keyword">&lt;/group-id&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/connection-factory&gt;</span></pre>

		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905853267264">
      ⁠</a>26.3.  Clustered Grouping</h1></div></div></div><div class="para">
			Using message groups in a cluster is a bit more complex because messages with a particular group ID can arrive on any node. Each node needs to know which group IDs are bound to which consumer on which node.
		</div><div class="para">
			The consumer handling messages for a particular group ID may be on a different node of the cluster, so each node needs to know this information so it can route the message correctly to the node which has that consumer.
		</div><div class="para">
			To solve this there is a grouping handler. Each node has its own grouping handler and when a message is sent with a group ID assigned, the handlers will decide between them which route the message should take.
		</div><div class="para">
			There are two types of handlers; local and remote. Each cluster should choose one node to have a local grouping handler and all the other nodes should have remote handlers. The Local handler makes the decision regarding what route to use. The remote handlers converse with this. Here is a sample configuration for both types of handler. This should be configured in the <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/jboss-as/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/hornetq/hornetq-configuration.xml</code> file.
		</div><pre class="programlisting"><span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;grouping-handler</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"my-grouping-handler"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;type&gt;</span>LOCAL<span xmlns="" class="perl_Keyword">&lt;/type&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;address&gt;</span>jms<span xmlns="" class="perl_Keyword">&lt;/address&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;timeout&gt;</span>5000<span xmlns="" class="perl_Keyword">&lt;/timeout&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/grouping-handler&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;grouping-handler</span><span xmlns="" class="perl_Others"> name=</span><span xmlns="" class="perl_String">"my-grouping-handler"</span><span xmlns="" class="perl_Keyword">&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;type&gt;</span>REMOTE<span xmlns="" class="perl_Keyword">&lt;/type&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;address&gt;</span>jms<span xmlns="" class="perl_Keyword">&lt;/address&gt;</span>
<span xmlns="" class="line">​</span>   <span xmlns="" class="perl_Keyword">&lt;timeout&gt;</span>5000<span xmlns="" class="perl_Keyword">&lt;/timeout&gt;</span>
<span xmlns="" class="line">​</span><span xmlns="" class="perl_Keyword">&lt;/grouping-handler&gt;</span></pre><div class="para">
			The <span class="italic italic">address</span> attribute refers to a cluster connection and the type of addressing it uses (jms, or core). The <span class="italic italic">timeout</span> attribute refers to how long to wait for a decision to be made (in milliseconds); an exception will be thrown during the send if this timeout is reached. This ensures that strict ordering is kept.
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Refer to <a class="xref" href="clusters.html">Chapter 36, <em>Clusters</em></a> for information about configuring clusters.
			</div></div></div><div class="para">
			The decision about where a message should be routed is initially proposed by the node that receives the message. The node will pick a suitable route as per the normal clustered routing conditions (that is, circulate available queues, use a local queue first, and choose a queue that has a consumer). If the proposal is accepted by the grouping handlers, the node will route messages to this queue from that point on. If rejected an alternative route will be offered and the node will route to that queue indefinitely. All other nodes will also route to the queue chosen at proposal time. Once the message arrives at the queue, normal single-server message group semantics take over and the message is attached to a consumer on that queue.
		</div><div class="para">
			You may have noticed that there is a single point of failure with the single local handler. If this node crashes then no decisions will be able to be made. Any sent messages will be not be delivered and an exception will be thrown. To avoid this happening, local handlers can be replicated on another backup node. Simple create your back up node and configure it with the same local handler.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905850176016">
      ⁠</a>26.3.1. Clustered Grouping Best Practices</h2></div></div></div><div class="para">
				Some best practices should be followed when using clustered grouping: 
				<div xmlns:d="http://docbook.org/ns/docbook" class="orderedlist"><ol><li class="listitem"><div class="para">
							Make sure your consumers are distributed evenly across the different nodes if possible. This is only an issue if you are creating and closing consumers regularly. Since messages are always routed to the same queue once pinned, removing a consumer from this queue may leave it with no consumers, meaning the queue will just keep receiving the messages. Avoid closing consumers or make sure that you always have plenty of consumers, that is, if you have three nodes, have three consumers.
						</div></li><li class="listitem"><div class="para">
							Use durable queues if possible. If queues are removed once a group is bound to it, then it is possible that other nodes may still try to route messages to it. This can be avoided by making sure that the queue is deleted by the session that is sending the messages. This means that when the next message is sent it is sent to the node where the queue was deleted meaning a new proposal can successfully take place. Alternatively you could just start using a different group id.
						</div></li><li class="listitem"><div class="para">
							Always make sure that the node that has the local grouping handler is replicated. This means that grouping can still occur on fail-over.
						</div></li></ol></div>

			</div></div></div></div></body></html>