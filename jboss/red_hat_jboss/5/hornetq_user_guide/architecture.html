<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 4. Core Architecture</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="architecture">
      ⁠</a>Chapter 4. Core Architecture</h1></div></div></div><div class="para">
		HornetQ core is designed as a set of Plain Old Java Objects (POJOs). It has also been designed to have as few dependencies on external jars as possible. As a result HornetQ core has only one more jar dependency than the standard JDK classes: <code class="literal">netty.jar</code>. This is because some of the netty buffer classes are used internally.
	</div><div class="para">
		Each HornetQ server has its own ultra high performance persistent journal, which it uses for messaging and other persistence.
	</div><div class="para">
		Using a high performance journal allows persistence message performance, which is something not achievable when using a relational database for persistence.
	</div><div class="para">
		HornetQ clients, potentially on different physical machines interact with the HornetQ server. HornetQ currently provides two APIs for messaging at the client side:
	</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> Core Client API </span></dt><dd><div class="para">
					This is a simple intuitive Java API that allows the full set of messaging functionality without some of the complexities of JMS.
				</div></dd><dt><span class="term"> JMS Client API </span></dt><dd><div class="para">
					The standard JMS API is available at the client side.
				</div></dd></dl></div><div class="para">
		JMS semantics are implemented by a thin JMS facade layer on the client side.
	</div><div class="para">
		The HornetQ server does not associate with JMS and does not know anything about JMS. It is a protocol agnostic messaging server designed to be used with multiple different protocols.
	</div><div class="para">
		When a user uses the JMS API on the client side, all JMS interactions are translated into operations on the HornetQ core Client API before being transferred over the wire using the HornetQ wire format.
	</div><div class="para">
		The server always just deals with core API interactions.
	</div><div class="para">
		A schematic illustrating this relationship is described in <a class="xref" href="architecture.html#fig-HornetQ_Application_Interaction_Schematic">Figure 4.1, “HornetQ Application Interaction Schematic”</a>.
	</div><div class="figure"><a id="fig-HornetQ_Application_Interaction_Schematic">
      ⁠</a><div class="figure-contents"><div class="mediaobject" style="text-align: center"><img src="images/architecture1.png" align="middle" width="250" alt="HornetQ Application Interaction Schematic" style="text-align: middle"/></div></div><p class="title"><strong>Figure 4.1. HornetQ Application Interaction Schematic</strong></p></div><div class="para">
		Figure 3.1 shows two user applications interacting with a HornetQ server. User Application 1 is using the JMS API, while User Application 2 is using the core Client API directly.
	</div><div class="para">
		You can see from the diagram that the JMS API is implemented by a thin facade layer on the client side.
	</div></div></body></html>