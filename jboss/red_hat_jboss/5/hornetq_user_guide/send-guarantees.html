<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 18. Guarantees of sends and commits</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="send-guarantees">
      ⁠</a>Chapter 18. Guarantees of sends and commits</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905858372304">
      ⁠</a>18.1. Guarantees of Transaction Completion</h1></div></div></div><div class="para">
			When committing or rolling back a transaction with HornetQ, the request to commit or rollback is sent to the server. The call will be blocked on the client side until a response has been received from the server that the commit or rollback was executed.
		</div><div class="para">
			When the commit or rollback is received on the server, it will be committed to the journal, and depending on the value of the parameter <code class="literal">journal-sync-transactional</code> the server will ensure that the commit or rollback is durably persisted to storage before sending the response back to the client. If this parameter has the value <code class="literal">false</code> then commit or rollback may not actually get persisted to storage until some time after the response has been sent to the client. In the event of server failure this may mean the commit or rollback never gets persisted to storage. The default value of this parameter is <code class="literal">true</code> so the client can be sure all transaction commits or rollbacks have been persisted to storage by the time the call to commit or rollback returns.
		</div><div class="para">
			Setting this parameter to <code class="literal">false</code> can improve performance at the expense of some loss of transaction durability.
		</div><div class="para">
			This parameter is set in <code class="filename"><em class="replaceable">&lt;JBOSS_HOME&gt;</em>/jboss-as/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/hornetq/hornetq-configuration.xml</code>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="non-transactional-sends">
      ⁠</a>18.2. Guarantees of Non Transactional Message Sends</h1></div></div></div><div class="para">
			If messages are sent to a server using a non-transacted session, HornetQ can block sending until the message has definitely reached the server, and a response has been sent back to the client. This can be configured individually for durable and non-durable messages, and is determined by the following two parameters:
		</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">BlockOnDurableSend</code> </span></dt><dd><div class="para">
						If this is set to <code class="literal">true</code> then all calls to send for durable messages on non transacted sessions will block until the message has reached the server, and a response has been sent back. The default value is <code class="literal">true</code>.
					</div></dd><dt><span class="term"> <code class="literal">BlockOnNonDurableSend</code> </span></dt><dd><div class="para">
						If this is set to <code class="literal">true</code> then all calls to send for non-durable messages on non-transacted sessions will be blocked until the message has reached the server, and a response has been sent back. The default value is <code class="literal">false</code>.
					</div></dd></dl></div><div class="para">
			Setting the send block to <code class="literal">true</code> can reduce performance since each send requires a network round trip before the next send can be performed. This means the performance of sending messages will be limited by the network round trip time (RTT) of your network, rather than the bandwidth of your network. For better performance it is recommended that you either batch many message sends together in a transaction (since with a transactional session, only the commit/rollback does not block every send), or use the <span class="emphasis"><em>asynchronous send acknowledgments feature</em></span> described in <a class="xref" href="send-guarantees.html#asynchronous-send-acknowledgements">Section 18.4, “Asynchronous Send Acknowledgments”</a>.
		</div><div class="para">
			If you are using JMS and the JMS service on the server to load your JMS connection factory instances into JNDI then these parameters can be configured in <code class="filename"><em class="replaceable">JBOSS_DIST</em>/jboss-as/server/<em class="replaceable">&lt;PROFILE&gt;</em>/deploy/hornetq/hornetq-jms.xml</code> using the elements <code class="literal">block-on-durable-send</code> and <code class="literal">block-on-non-durable-send</code>. If you are using JMS but not using JNDI then you can set these values directly on the <code class="literal">HornetQConnectionFactory</code> instance using the appropriate setter methods.
		</div><div class="para">
			If you are using core you can set these values directly on the <code class="literal">ClientSessionFactory</code> instance using the appropriate setter methods.
		</div><div class="para">
			When the server receives a message sent from a non transactional session, and that message is durable and the message is routed to at least one durable queue, then the server will persist the message in permanent storage. If the journal parameter <code class="literal">journal-sync-non-transactional</code> is set to <code class="literal">true</code> the server will not send a response back to the client until the message has been persisted and the server has a guarantee that the data has been persisted to disk. The default value for this parameter is <code class="literal">true</code>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="send-guarantees.nontrans.acks">
      ⁠</a>18.3. Guarantees of Non-Transactional Acknowledgments</h1></div></div></div><div class="para">
			If you are acknowledging the delivery of a message on the client side using a non transacted session, HornetQ can be configured to block the call to acknowledge until the acknowledge has definitely reached the server, and a response has been sent back to the client. This is configured with the parameter <code class="literal">BlockOnAcknowledge</code>. If this is set to <code class="literal">true</code> then all calls to acknowledge on non-transacted sessions will block until the acknowledge has reached the server, and a response has been sent back. You might want to set this to <code class="literal">true</code> if you want to implement a strict <span class="emphasis"><em>at most once</em></span> delivery policy. The default value is <code class="literal">false</code>
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="asynchronous-send-acknowledgements">
      ⁠</a>18.4. Asynchronous Send Acknowledgments</h1></div></div></div><div class="para">
			If you are using a non-transacted session but want a guarantee that every message sent to the server has reached it, then, as discussed in <a class="xref" href="send-guarantees.html#non-transactional-sends">Section 18.2, “Guarantees of Non Transactional Message Sends”</a>, you can configure HornetQ to block the call to send until the server has received the message, persisted it and sent back a response. This works well but has a severe performance penalty - each call to send needs to block for at least the time of a network round trip (RTT) - the performance of sending is thus limited by the latency of the network, <span class="emphasis"><em>not</em></span> limited by the network bandwidth.
		</div><div class="para">
			To remedy this, HornetQ provides a feature called <span class="emphasis"><em>asynchronous send acknowledgments</em></span>. With this feature, HornetQ can be configured to send messages without blocking in one direction and asynchronously getting acknowledgment from the server that the messages were received in a separate stream. By decoupling the send from the acknowledgment of the send, the system is not limited by the network RTT, but is limited by the network bandwidth. Consequently better throughput can be achieved than is possible using a blocking approach, while at the same time having absolute guarantees that messages have successfully reached the server.
		</div><div class="para">
			The window size for send acknowledgments is determined by the confirmation-window-size parameter on the connection factory or client session factory. refer to <a class="xref" href="client-reconnection.html">Chapter 32, <em>Client Reconnection and Session Reattachment</em></a> for more info on this.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905804741392">
      ⁠</a>18.4.1. Asynchronous Send Acknowledgments</h2></div></div></div><div class="para">
				To use the feature using the core API, implement the interface <code class="literal">org.hornetq.api.core.client.SendAcknowledgementHandler</code> and set a handler instance on your <code class="literal">ClientSession</code>.
			</div><div class="para">
				Send messages as normal using your <code class="literal">ClientSession</code>, and as messages reach the server, the server will send back an acknowledgment of the send asynchronously. HornetQ calls your handler's <code class="literal">sendAcknowledged(ClientMessage message)</code> method, passing in a reference to the message that was sent.
			</div><div class="para">
				To enable asynchronous send acknowledgments, make sure <code class="literal">confirmation-window-size</code> is set to a positive integer value (specified in bytes). For example, 10485760 (10 Mebibytes) .
			</div></div></div></div></body></html>