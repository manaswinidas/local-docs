<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 3. Messaging Concepts</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="messaging-concepts">
      ⁠</a>Chapter 3. Messaging Concepts</h1></div></div></div><div class="para">
		HornetQ is an asynchronous messaging system; an example of Message Oriented Middleware, which will be referred to as <em class="firstterm">messaging systems</em>.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905803681952">
      ⁠</a>3.1. Messaging Concepts</h1></div></div></div><div class="para">
			Messaging systems are designed to loosely couple heterogeneous systems together, while maintaining reliability, transactions, and many other features.
		</div><div class="para">
			Unlike systems based on a Remote Procedure Call (RPC) pattern, messaging systems primarily use an asynchronous message passing pattern with no tight relationship between requests and responses. Most messaging systems also support a request-response mode, however this is not a primary feature of messaging systems.
		</div><div class="para">
			Designing systems to be asynchronous from end-to-end provides improvements to hardware resource usage, minimizes the number of threads blocking IO operations, and uses network bandwidth to its full capacity.
		</div><div class="para">
			With an RPC approach you have to wait for a response for each request you make so are limited by the network round trip time, or <span class="italic italic">latency </span> of your network. With an asynchronous system you can pipeline flows of messages in different directions, so are limited by the network <span class="italic italic">bandwidth</span> not the latency. This typically allows you to create much higher performance applications.
		</div><div class="para">
			Messaging systems decouple the senders of messages from the consumers of messages. Message senders and consumers are completely independent, which allows flexible, loosely coupled systems to be created.
		</div><div class="para">
			Large enterprises often use a messaging system to implement a message bus which loosely couples heterogeneous systems together. Message buses often form the core of an Enterprise Service Bus (ESB). Using a message bus to decouple disparate systems can allow the system to grow and adapt more easily, or retire obsolete systems.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905807137088">
      ⁠</a>3.2. Messaging styles</h1></div></div></div><div class="para">
			Messaging systems normally support two main styles of asynchronous messaging: message queue messaging (also known as <span class="italic italic">point-to-point messaging</span>) and publish subscribe messaging. They are summarized briefly here:
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905801996352">
      ⁠</a>3.2.1. The Point-To-Point Pattern</h2></div></div></div><div class="para">
				With this type of messaging you send a message to a queue. The message is then typically persisted to provide a guarantee of delivery. Some time later the messaging system delivers the message to a consumer. The consumer processes the message and acknowledges the message when it is done. Once the message is acknowledged it disappears from the queue and is not available to be delivered again. If the system crashes before the messaging server receives an acknowledgment from the consumer, the message will be available to be delivered to a consumer again, upon recovery.
			</div><div class="para">
				With point-to-point messaging, there can be many consumers in the queue but a particular message will only ever be consumed by one of them. Senders (also known as<span class="italic italic"> producers</span>) to the queue are completely decoupled from receivers (also known as <span class="italic italic">consumers</span>) of the queue; that is, they do not know of each other's existence.
			</div><div class="para">
				A classic example of point-to-point messaging would be an order queue in a company's book ordering system. Each order is represented as a message which is sent to the order queue. Let us imagine there are many front end ordering systems which send orders to the order queue. When a message arrives on the queue it is persisted; this ensures that if the server crashes the order is not lost. Let us also imagine there are many consumers on the order queue; each representing an instance of an order processing component - these can be on different physical machines but consuming from the same queue. The messaging system delivers each message to only one of the ordering processing components. Different messages can be processed by different order processors, but a single order is only processed by one order processor - this ensures orders are not processed twice.
			</div><div class="para">
				As an order processor receives a message, it fulfills the order, sends order information to the warehouse system and then updates the order database with the order details. Once the order processor updates the order database, it acknowledges the message to tell the server that the order has been processed and can be forgotten about. Often the send to the warehouse system, update in database and acknowledgment will be completed in a single transaction to conform with atomicity, consistency, isolation, durability(ACID) properties.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905858461104">
      ⁠</a>3.2.2. The Publish-Subscribe Pattern</h2></div></div></div><div class="para">
				With publish-subscribe messaging, many senders can send messages to an entity on the server, often called a <span class="italic italic">topic</span> (it is used this way in the JMS world, for example).
			</div><div class="para">
				There can be many <span class="emphasis"><em>subscriptions</em></span> on a topic; a subscription is just another word for a consumer of a topic. Each subscription receives a <span class="emphasis"><em>copy</em></span> of <span class="italic italic">each</span> message sent to the topic. This differs from the message queue pattern where each message is only consumed by a single consumer.
			</div><div class="para">
				Subscriptions can optionally be <span class="italic italic">durable</span>, which means they retain a copy of each message sent to the topic until the subscriber consumes them - even if the server crashes or is restarted in between. Non-durable subscriptions only last a maximum of the lifetime of the connection that created them.
			</div><div class="para">
				An example of publish-subscribe messaging would be a news feed. As news articles are created by different editors around the world they are sent to a news feed topic. There are many subscribers around the world who are interested in receiving news items - each one creates a subscription and the messaging system ensures that a copy of each news message is delivered to each subscription.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905801743744">
      ⁠</a>3.3. Delivery guarantees</h1></div></div></div><div class="para">
			A key feature of most messaging systems is <span class="italic italic">reliable messaging</span>. With reliable messaging the server gives a guarantee that the message will be delivered only once to each consumer of a queue or each durable subscription of a topic, even in the event of system failure. This is crucial for many businesses; you do not want your orders fulfilled more than once or any of your orders to be lost, for example.
		</div><div class="para">
			In other cases you may not care about a once only delivery guarantee and are happy to cope with duplicate deliveries or lost messages. An example of this might be transient stock price updates, which are quickly superseded by the next update on the same stock. The messaging system allows you to configure which delivery guarantees you require.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905865295648">
      ⁠</a>3.4. Transactions</h1></div></div></div><div class="para">
			HornetQ supports sending and acknowledging messages as part of a large global transaction by using the Java mapping of <code class="literal">XA: JTA</code>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905865293616">
      ⁠</a>3.5. Durability</h1></div></div></div><div class="para">
			Messages are either durable or non durable. Durable messages will be persisted in permanent storage and will survive server failure or restart. Non durable messages will not survive server failure or restart. Examples of durable messages might be orders or trades, where they cannot be lost. An example of a non durable message might be a stock price update which is transitory and does not need to survive a restart.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905865291760">
      ⁠</a>3.6. Messaging APIs and protocols</h1></div></div></div><div class="para">
			Many messaging systems provide their own proprietary APIs, which the client can use to communicate with the messaging system.
		</div><div class="para">
			There are also some standard ways of operating with messaging systems and some emerging standards in this space. Some of these are explored in the next section.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905838912944">
      ⁠</a>3.6.1. Java Message Service (JMS)</h2></div></div></div><div class="para">
				JMS is part of Sun's Java EE specification. It is a Java API that encapsulates both message queue and publish-subscribe messaging patterns. JMS is a lowest common denominator specification. That is, it was created to encapsulate common functionality of the messaging systems that already existed and were available at the time of its creation.
			</div><div class="para">
				JMS is a very popular API and is implemented by most messaging systems. JMS is only available to clients running Java.
			</div><div class="para">
				JMS does not define a standard wire format; it only defines a programmatic API so JMS clients and servers from different vendors cannot directly interoperate since each will use the vendor's own internal wire protocol.
			</div><div class="para">
				HornetQ provides a fully compliant JMS 1.1 API.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139905803948848">
      ⁠</a>3.6.2. System specific APIs</h2></div></div></div><div class="para">
				Many systems provide their own programmatic API to interact with the messaging system. The advantage of this is that it allows the full set of system functionality to be exposed to the client application. APIs like JMS are not normally rich enough to expose all the extra features that most messaging systems provide.
			</div><div class="para">
				HornetQ provides its own core Client API for clients to use if they wish to have access to functionality beyond that accessible via the JMS API.
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905803944304">
      ⁠</a>3.7. High Availability</h1></div></div></div><div class="para">
			High Availability (HA) means that the system should remain operational after failure of one or more of the servers. The degree of support for HA varies between messaging systems.
		</div><div class="para">
			HornetQ provides automatic fail-over; where your sessions are reconnected to the backup server in the event of live server failure. Your applications must support High Availability correctly, according to the requirements of JMS.
		</div><div class="para">
			For more information on HA and how applications must support this mode, refer to <a class="xref" href="qs-migration.html#Client-side_Failure_Handling">Section 2.3, “Client-side Failure Handling”</a>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905848882000">
      ⁠</a>3.8. Clusters</h1></div></div></div><div class="para">
			Many messaging systems allow you to create groups of messaging servers called <span class="italic italic">clusters</span>. Clusters allow sending and consuming messages to be spread over many servers. This allows your system to scale horizontally by adding new servers to the cluster.
		</div><div class="para">
			Cluster support can vary between messaging systems, with some systems having fairly basic clusters with the cluster members being hardly aware of each other.
		</div><div class="para">
			HornetQ provides a very configurable clustering model where messages can be intelligently load balanced between the servers in the cluster, according to the number of consumers on each node, and whether they are ready for messages.
		</div><div class="para">
			HornetQ can automatically redistribute messages between nodes of a cluster to prevent message loss on any particular node.
		</div><div class="para">
			For full details on clustering, refer to <a class="xref" href="clusters.html">Chapter 36, <em>Clusters</em></a>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm139905857148976">
      ⁠</a>3.9. Bridges and routing</h1></div></div></div><div class="para">
			Some messaging systems allow isolated clusters or single nodes to be bridged together, typically over unreliable connections like a wide area network (WAN), or the Internet.
		</div><div class="para">
			A bridge normally consumes messages from a queue on one server and routes messages to another queue on a different server. Bridges cope with unreliable connections, automatically reconnecting when the connection is available again.
		</div><div class="para">
			HornetQ bridges can be configured with filter expressions to only forward certain messages, and transformation can also be hooked in.
		</div><div class="para">
			HornetQ also allows routing between queues to be configured in server side configuration. This allows complex routing networks to be set up forwarding or copying messages from one destination to another, forming a global network of interconnected brokers.
		</div><div class="para">
			For more information refer to <a class="xref" href="core-bridges.html">Chapter 34, <em>Core Bridges</em></a> and <a class="xref" href="diverts.html">Chapter 33, <em>Diverting and Splitting Message Flows</em></a>.
		</div></div></div></body></html>