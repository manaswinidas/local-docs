<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 1. Getting started</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="getting-started">
      ⁠</a>Chapter 1. Getting started</h1></div></div></div><div class="para">
		Welcome to Hibernate Search! The following chapter will guide you through the initial steps required to integrate Hibernate Search into an existing Hibernate enabled application. In case you are a Hibernate new timer we recommend you start <a href="http://hibernate.org/152.html">here</a>.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635469586576">
      ⁠</a>1.1. System Requirements</h1></div></div></div><div class="table"><a id="idm140635521039616">
      ⁠</a><p class="title"><strong>Table 1.1. System requirements</strong></p><div class="table-contents"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows" summary="System requirements"><colgroup><col/><col/></colgroup><tbody><tr><td> Java Runtime </td><td> A JDK or JRE version <span class="emphasis"><em>5</em></span> or greater. You can download a Java Runtime for Windows/Linux/Solaris <a href="http://java.sun.com/javase/downloads/">here</a>. </td></tr><tr><td> Hibernate Search </td><td> <code class="literal">hibernate-search.jar</code> and all runtime dependencies from the <code class="literal">lib</code> directory of the Hibernate Search distribution. Please refer to <code class="filename">README.txt </code>in the lib directory to understand which dependencies are required. </td></tr><tr><td> Hibernate Core </td><td> This instructions have been tested against Hibernate 3.3.x. You will need <code class="literal">hibernate-core.jar</code> and its transitive dependencies from the <code class="literal">lib</code> directory of the distribution. Refer to <code class="literal">README.txt</code> in the <code class="literal">lib</code> directory of the distribution to determine the minimum runtime requirements. </td></tr><tr><td> Hibernate Annotations </td><td> Even though Hibernate Search can be used without Hibernate Annotations the following instructions will use them for basic entity configuration (<span class="emphasis"><em>@Entity, @Id, @OneToMany,...</em></span>). This part of the configuration could also be expressed in xml or code. However, Hibernate Search itself has its own set of annotations (<span class="emphasis"><em>@Indexed, @DocumentId, @Field,...</em></span>) for which there exists so far no alternative configuration. The tutorial is tested against version 3.4.x of Hibernate Annotations. </td></tr></tbody></table></div></div><div class="para">
			You can download all dependencies from the Hibernate <a href="http://www.hibernate.org/6.html">download site</a>. You can also verify the dependency versions against the <a href="http://www.hibernate.org/6.html#A3">Hibernate Compatibility Matrix</a>.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635533680848">
      ⁠</a>1.2. Using Maven</h1></div></div></div><div class="para">
			Instead of managing all dependencies manually, maven users have the possibility to use the <a href="http://repository.jboss.com/maven2">JBoss maven repository</a>. Just add the JBoss repository url to the <span class="emphasis"><em>repositories</em></span> section of your <code class="filename">pom.xml</code> or <code class="filename">settings.xml</code>:
		</div><div class="example"><a id="idm140635537135376">
      ⁠</a><p class="title"><strong>Example 1.1. Adding the JBoss maven repository to <code class="filename">settings.xml</code></strong></p><div class="example-contents"><pre class="programlisting">
&lt;repository&gt;
  &lt;id&gt;repository.jboss.org&lt;/id&gt;
  &lt;name&gt;JBoss Maven Repository&lt;/name&gt;
  &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
  &lt;layout&gt;default&lt;/layout&gt;
&lt;/repository&gt;
</pre></div></div><div class="para">
			Then add the following dependencies to your pom.xml:
		</div><div class="example"><a id="idm140635537133040">
      ⁠</a><p class="title"><strong>Example 1.2. Maven dependencies for Hibernate Search</strong></p><div class="example-contents"><pre class="programlisting">
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search&lt;/artifactId&gt;
   &lt;version&gt;3.1.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
   &lt;version&gt;3.4.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
   &lt;version&gt;3.4.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
   &lt;artifactId&gt;solr-common&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
   &lt;artifactId&gt;solr-core&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
   &lt;artifactId&gt;lucene-snowball&lt;/artifactId&gt;
   &lt;version&gt;2.4.0&lt;/version&gt;
&lt;/dependency&gt;
</pre></div></div><div class="para">
			Not all dependencies are required. Only the <span class="emphasis"><em>hibernate-search</em></span> dependency is mandatory. This dependency, together with its required transitive dependencies, contain all required classes needed to use Hibernate Search. <span class="emphasis"><em>hibernate-annotations</em></span> is only needed if you want to use annotations to configure your domain model as we do in this tutorial. However, even if you choose not to use Hibernate Annotations you still have to use the Hibernate Search specific annotations, which are bundled with the hibernate-search jar file, to configure your Lucene index. Currently there is no XML configuration available for Hibernate Search. <span class="emphasis"><em>hibernate-entitymanager</em></span> is required if you want to use Hibernate Search in conjunction with JPA. The Solr dependencies are needed if you want to utilize Solr's analyzer framework. More about this later. And finally, the <code class="literal">lucene-snowball</code> dependency is needed if you want to utilize Lucene's snowball stemmer.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635526605392">
      ⁠</a>1.3. Configuration</h1></div></div></div><div class="para">
			Once you have downloaded and added all required dependencies to your application you have to add a couple of properties to your hibernate configuration file. If you are using Hibernate directly this can be done in <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. If you are using Hibernate via JPA you can also add the properties to <code class="literal">persistence.xml</code>. The good news is that for standard use most properties offer a sensible default. An example <code class="filename">persistence.xml</code> configuration could look like this:
		</div><div class="example"><a id="idm140635524265536">
      ⁠</a><p class="title"><strong>Example 1.3. Basic configuration options to be added to <code class="literal"><code class="filename">hibernate.properties</code></code>, <code class="literal"><code class="filename">hibernate.cfg.xml</code></code> or <code class="filename">persistence.xml</code></strong></p><div class="example-contents"><pre class="programlisting">
...
&lt;property name="hibernate.search.default.directory_provider" 
   value="org.hibernate.search.store.FSDirectoryProvider"/&gt; 

&lt;property name="hibernate.search.default.indexBase" value="/var/lucene/indexes"/&gt; 
...
</pre></div></div><div class="para">
			First you have to tell Hibernate Search which <code class="classname">DirectoryProvider</code> to use. This can be achieved by setting the <code class="literal">hibernate.search.default.directory_provider</code> property. Apache Lucene has the notion of a <code class="literal">Directory</code> to store the index files. Hibernate Search handles the initialization and configuration of a Lucene <code class="literal">Directory</code> instance via a <code class="literal">DirectoryProvider</code>. In this tutorial we will use a subclass of <code class="literal">DirectoryProvider</code> called <code class="classname">FSDirectoryProvider</code>. This will give us the ability to physically inspect the Lucene indexes created by Hibernate Search (eg via <a href="http://www.getopt.org/luke/">Luke</a>). Once you have a working configuration you can start experimenting with other directory providers (see <a class="xref" href="search-configuration.html#search-configuration-directory">Section 3.1, “Directory configuration”</a>). Next to the directory provider you also have to specify the default root directory for all indexes via <code class="literal">hibernate.search.default.indexBase</code>.
		</div><div class="para">
			Lets assume that your application contains the Hibernate managed classes <code class="classname">example.Book</code> and <code class="classname">example.Author</code> and you want to add free text search capabilities to your application in order to search the books contained in your database.
		</div><div class="example"><a id="idm140635539884384">
      ⁠</a><p class="title"><strong>Example 1.4. Example entities Book and Author before adding Hibernate Search specific annotations</strong></p><div class="example-contents"><pre class="programlisting">
package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id; 

  private String title;  

  private String subtitle; 

  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ...
}
</pre><pre class="programlisting">
package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}

</pre></div></div><div class="para">
			To achieve this you have to add a few annotations to the <code class="classname">Book</code> and <code class="classname">Author</code> class. The first annotation <code class="literal">@Indexed</code> marks <code class="classname">Book</code> as indexable. By design Hibernate Search needs to store an untokenized id in the index to ensure index unicity for a given entity. <code class="literal">@DocumentId</code> marks the property to use for this purpose and is in most cases the same as the database primary key. In fact since the 3.1.0 release of Hibernate Search <code class="literal">@DocumentId</code> is optional in the case where an <code class="classname">@Id</code> annotation exists.
		</div><div class="para">
			Next you have to mark the fields you want to make searchable. Let us start with <code class="literal">title</code> and <code class="literal">subtitle</code> and annotate both with <code class="literal">@Field</code>. The parameter <code class="literal">index=Index.TOKENIZED</code> will ensure that the text will be tokenized using the default Lucene analyzer. Usually, tokenizing means chunking a sentence into individual words and potentially excluding common words like <code class="literal">'a'</code> or '<code class="literal">the</code>'. We will talk more about analyzers a little later on. The second parameter we specify within <code class="literal">@Field</code>,<code class="literal"> store=Store.NO</code>, ensures that the actual data will not be stored in the index. Whether this data is stored in the index or not has nothing to do with the ability to search for it. From Lucene's perspective it is not necessary to keep the data once the index is created. The benefit of storing it is the ability to retrieve it via projections (<a class="xref" href="search-query.html#projections">Section 5.1.2.5, “Projection”</a>).
		</div><div class="para">
			Without projections, Hibernate Search will per default execute a Lucene query in order to find the database identifiers of the entities matching the query criteria and use these identifiers to retrieve managed objects from the database. The decision for or against projection has to be made on a case to case basis. The default behavior - <code class="literal">Store.NO</code> - is recommended since it returns managed objects whereas projections only return object arrays.
		</div><div class="para">
			After this short look under the hood let us go back to annotating the <code class="classname">Book</code> class. Another annotation we have not yet discussed is <code class="literal">@DateBridge</code>. This annotation is one of the built-in field bridges in Hibernate Search. The Lucene index is purely string based. For this reason Hibernate Search must convert the data types of the indexed fields to strings and vice versa. A range of predefined bridges are provided, including the <code class="classname">DateBridge</code> which will convert a <code class="classname">java.util.Date</code> into a <code class="classname">String</code> with the specified resolution. For more details see <a class="xref" href="search-mapping.html#search-mapping-bridge">Section 4.2, “Property/Field Bridge”</a>.
		</div><div class="para">
			This leaves us with <code class="literal">@IndexedEmbedded. </code>This annotation is used to index associated entities (<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code> and <code class="literal">@Embedded</code>) as part of the owning entity. This is needed since a Lucene index document is a flat data structure which does not know anything about object relations. To ensure that the authors' name will be searchable you have to make sure that the names are indexed as part of the book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also have to mark all fields of the associated entity you want to have included in the index with <code class="literal">@Indexed</code>. For more details see <a class="xref" href="search-mapping.html#search-mapping-associated">Section 4.1.3, “Embedded and associated objects”</a>.
		</div><div class="para">
			These settings should be sufficient for now. For more details on entity mapping refer to <a class="xref" href="search-mapping.html#search-mapping-entity">Section 4.1, “Mapping an entity”</a>.
		</div><div class="example"><a id="idm140635473838304">
      ⁠</a><p class="title"><strong>Example 1.5. Example entities after adding Hibernate Search annotations</strong></p><div class="example-contents"><pre class="programlisting">
package example;
...
@Entity
<span class="bold bold"><strong>@Indexed</strong></span>
public class Book {

  @Id
  @GeneratedValue
  <span class="bold bold"><strong>@DocumentId</strong></span>
  private Integer id;
  
  <span class="bold bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String title;
  
  <span class="bold bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String subtitle; 

  <span class="bold bold"><strong>@IndexedEmbedded</strong></span>
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold bold"><strong> @Field(index = Index.UN_TOKENIZED, store = Store.YES) @DateBridge(resolution = Resolution.DAY)</strong></span>
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}
</pre><pre class="programlisting">
package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  <span class="bold bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635522724656">
      ⁠</a>1.4. Indexing</h1></div></div></div><div class="para">
			Hibernate Search will transparently index every entity persisted, updated or removed through Hibernate Core. However, you have to trigger an initial indexing to populate the Lucene index with the data already present in your database. Once you have added the above properties and annotations it is time to trigger an initial batch index of your books. You can achieve this by using one of the following code snippets (see also <a class="xref" href="search-batchindex.html">Chapter 6, <em>Manual indexing</em></a>):
		</div><div class="example"><a id="idm140635530769584">
      ⁠</a><p class="title"><strong>Example 1.6. Using Hibernate Session to index data</strong></p><div class="example-contents"><pre class="programlisting">
FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

List books = session.createQuery("from Book as book").list();
for (Book book : books) {
    <span class="bold bold"><strong>fullTextSession.index(book);</strong></span>
}

tx.commit(); //index is written at commit time
</pre></div></div><div class="example"><a id="idm140635530767360">
      ⁠</a><p class="title"><strong>Example 1.7. Using JPA to index data</strong></p><div class="example-contents"><pre class="programlisting">
EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
em.getTransaction().begin();

List books = em.createQuery("select book from Book as book").getResultList();
for (Book book : books) {
    <span class="bold bold"><strong>fullTextEntityManager.index(book);</strong></span>
} 

em.getTransaction().commit();
em.close();


</pre></div></div><div class="para">
			After executing the above code, you should be able to see a Lucene index under <code class="literal">/var/lucene/indexes/example.Book</code>. Go ahead an inspect this index with <a href="http://www.getopt.org/luke/">Luke</a>. It will help you to understand how Hibernate Search works.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635532895360">
      ⁠</a>1.5. Searching</h1></div></div></div><div class="para">
			Now it is time to execute a first search. The general approach is to create a native Lucene query and then wrap this query into a org.hibernate.Query in order to get all the functionality one is used to from the Hibernate API. The following code will prepare a query against the indexed fields, execute it and return a list of <code class="classname">Book</code>s.
		</div><div class="example"><a id="idm140635532893280">
      ⁠</a><p class="title"><strong>Example 1.8. Using Hibernate Session to create and execute a search</strong></p><div class="example-contents"><pre class="programlisting">
FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();
  
tx.commit();
session.close();
</pre></div></div><div class="example"><a id="idm140635532891264">
      ⁠</a><p class="title"><strong>Example 1.9. Using JPA to create and execute a search</strong></p><div class="example-contents"><pre class="programlisting">
EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = 
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();

</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635532888960">
      ⁠</a>1.6. Analyzer</h1></div></div></div><div class="para">
			Let us make things a little more interesting now. Assume that one of your indexed book entities has the title "Refactoring: Improving the Design of Existing Code" and you want to get hits for all of the following queries: "refactor", "refactors", "refactored" and "refactoring". In Lucene this can be achieved by choosing an analyzer class which applies word stemming during the indexing <span class="bold bold"><strong>as well as</strong></span> search process. Hibernate Search offers several ways to configure the analyzer to use (see <a class="xref" href="search-mapping.html#analyzer">Section 4.1.6, “Analyzer”</a>):
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					Setting the <code class="literal">hibernate.search.analyzer</code> property in the configuration file. The specified class will then be the default analyzer.
				</div></li><li class="listitem"><div class="para">
					Setting the <code class="literal"><code class="literal">@Analyzer</code></code> annotation at the entity level.
				</div></li><li class="listitem"><div class="para">
					Setting the <code class="literal">@<code class="literal">Analyzer</code></code> annotation at the field level.
				</div></li></ul></div><div class="para">
			When using the <code class="literal">@Analyzer</code> annotation one can either specify the fully qualified classname of the analyzer to use or one can refer to an analyzer definition defined by the <code class="literal">@AnalyzerDef</code> annotation. In the latter case the Solr analyzer framework with its factories approach is utilized. To find out more about the factory classes available you can either browse the Solr JavaDoc or read the corresponding section on the <a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">Solr Wiki.</a> Note that depending on the chosen factory class additional libraries on top of the Solr dependencies might be required. For example, the <code class="classname">PhoneticFilterFactory</code> depends on <a href="http://commons.apache.org/codec">commons-codec</a>.
		</div><div class="para">
			In the example below a <code class="classname">StandardTokenizerFactory</code> is used followed by two filter factories, <code class="classname">LowerCaseFilterFactory</code> and <code class="classname">SnowballPorterFilterFactory</code>. The standard tokenizer splits words at punctuation characters and hyphens while keeping email addresses and internet hostnames intact. It is a good general purpose tokenizer. The lowercase filter lowercases the letters in each token whereas the snowball filter finally applies language specific stemming.
		</div><div class="para">
			Generally, when using the Solr framework you have to start with a tokenizer followed by an arbitrary number of filters.
		</div><div class="example"><a id="idm140635524610160">
      ⁠</a><p class="title"><strong>Example 1.10. Using <code class="classname">@AnalyzerDef</code> and the Solr framework to define and use an analyzer</strong></p><div class="example-contents"><pre class="programlisting">

package example;
...
@Entity
@Indexed
<span class="bold bold"><strong>@AnalyzerDef(name = "customanalyzer", tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class), filters = { @TokenFilterDef(factory = LowerCaseFilterFactory.class), @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = { @Parameter(name = "language", value = "English") }) })</strong></span>
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String title;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String subtitle; 

  @IndexedEmbedded
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold bold"><strong> </strong></span> @Field(index = Index.UN_TOKENIZED, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}

</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635524604848">
      ⁠</a>1.7. What's next</h1></div></div></div><div class="para">
			The above paragraphs hopefully helped you getting an overview of Hibernate Search. Using the maven archetype plug-in and the following command you can create an initial runnable maven project structure populated with the example code of this tutorial.
		</div><div class="example"><a id="idm140635539476032">
      ⁠</a><p class="title"><strong>Example 1.11. Using the maven archetype to create tutorial sources</strong></p><div class="example-contents"><pre class="programlisting">mvn archetype:create \ 
    -DarchetypeGroupId=org.hibernate \
    -DarchetypeArtifactId=hibernate-search-quickstart \ 
    -DarchetypeVersion=3.1.0.GA \
    -DgroupId=my.company -DartifactId=quickstart</pre></div></div><div class="para">
			Using the maven project you can execute the examples, inspect the file system based index and search and retrieve a list of managed objects. Just run <span class="emphasis"><em>mvn package</em></span> to compile the sources and run the unit tests.
		</div><div class="para">
			The next step after this tutorial is to get more familiar with the overall architecture of Hibernate Search (<a class="xref" href="search-architecture.html">Chapter 2, <em>Architecture</em></a>) and explore the basic features in more detail. Two topics which were only briefly touched in this tutorial were analyzer configuration (<a class="xref" href="search-mapping.html#analyzer">Section 4.1.6, “Analyzer”</a>) and field bridges (<a class="xref" href="search-mapping.html#search-mapping-bridge">Section 4.2, “Property/Field Bridge”</a>), both important features required for more fine-grained indexing. More advanced topics cover clustering (<a class="xref" href="search-configuration.html#jms-back_end">Section 3.5, “JMS Master/Slave configuration”</a>) and large indexes handling (<a class="xref" href="search-configuration.html#search-configuration-directory-sharding">Section 3.2, “Sharding indexes”</a>).
		</div></div></div></body></html>