<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 8. Advanced features</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="search-lucene-native">
      ⁠</a>Chapter 8. Advanced features</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635535354096">
      ⁠</a>8.1. SearchFactory</h1></div></div></div><div class="para">
			The <code class="classname">SearchFactory</code> object keeps track of the underlying Lucene resources for Hibernate Search, it's also a convenient way to access Lucene natively. The <code class="classname">SearchFactory</code> can be accessed from a <code class="classname">FullTextSession</code>:
		</div><div class="example"><a id="idm140635510903312">
      ⁠</a><p class="title"><strong>Example 8.1. Accessing the <code class="classname">SearchFactory</code></strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635470589600">
      ⁠</a>8.2. Accessing a Lucene Directory</h1></div></div></div><div class="para">
			You can always access the Lucene directories through plain Lucene, the Directory structure is in no way different with or without Hibernate Search. However there are some more convenient ways to access a given Directory. The <code class="classname">SearchFactory</code> keeps track of the <code class="classname">DirectoryProvider</code>s per indexed class. One directory provider can be shared amongst several indexed classes if the classes share the same underlying index directory. While usually not the case, a given entity can have several <code class="classname">DirectoryProvider</code>s if the index is sharded (see <a class="xref" href="search-configuration.html#search-configuration-directory-sharding">Section 3.2, “Sharding indexes”</a>).
		</div><div class="example"><a id="idm140635511756608">
      ⁠</a><p class="title"><strong>Example 8.2. Accessing the Lucene <code class="classname">Directory</code></strong></p><div class="example-contents"><pre class="programlisting">DirectoryProvider[] provider = searchFactory.getDirectoryProviders(Order.class);
org.apache.lucene.store.Directory directory = provider[0].getDirectory();</pre></div></div><div class="para">
			In this example, directory points to the lucene index storing <code class="classname">Order</code>s information. Note that the obtained Lucene directory must not be closed (this is Hibernate Search responsibility).
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635539878208">
      ⁠</a>8.3. Using an IndexReader</h1></div></div></div><div class="para">
			Queries in Lucene are executed on an <code class="literal">IndexReader</code>. Hibernate Search caches all index readers to maximize performance. Your code can access this cached resources, but you have to follow some "good citizen" rules.
		</div><div class="example"><a id="idm140635508694672">
      ⁠</a><p class="title"><strong>Example 8.3. Accessing an <code class="classname">IndexReader</code></strong></p><div class="example-contents"><pre class="programlisting">DirectoryProvider orderProvider = searchFactory.getDirectoryProviders(Order.class)[0];
DirectoryProvider clientProvider = searchFactory.getDirectoryProviders(Client.class)[0];

ReaderProvider readerProvider = searchFactory.getReaderProvider();
IndexReader reader = readerProvider.openReader(orderProvider, clientProvider);

try {
    //do read-only operations on the reader
}
finally {
    readerProvider.closeReader(reader);
}</pre></div></div><div class="para">
			The ReaderProvider (described in <a class="xref" href="search-architecture.html#search-architecture-readerstrategy">Section 2.3, “Reader strategy”</a>), will open an IndexReader on top of the index(es) referenced by the directory providers. Because this <code class="classname">IndexReader</code> is shared amongst several clients, you must adhere to the following rules:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					Never call indexReader.close(), but always call readerProvider.closeReader(reader), preferably in a finally block.
				</div></li><li class="listitem"><div class="para">
					Do not use this <code class="classname">IndexReader</code> for modification operations (you would get an exception). If you want to use a read/write index reader, open one from the Lucene Directory object.
				</div></li></ul></div><div class="para">
			Aside from those rules, you can use the IndexReader freely, especially to do native queries. Using the shared <code class="literal">IndexReader</code>s will make most queries more efficient.
		</div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635510029776">
      ⁠</a>8.4. Customizing Lucene's scoring formula</h1></div></div></div><div class="para">
			Lucene allows the user to customize its scoring formula by extending <code class="classname">org.apache.lucene.search.Similarity</code>. The abstract methods defined in this class match the factors of the following formula calculating the score of query q for document d:
		</div><div class="para">
			<span class="bold bold"><strong>score(q,d) = coord(q,d) · queryNorm(q) · ∑<sub>t in q</sub> ( tf(t in d) · idf(t)<sup>2</sup> · t.getBoost() · norm(t,d) )</strong></span>
		</div><div class="para">
			<div class="informaltable"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: center"> Factor </th><th style="text-align: center"> Description </th></tr></thead><tbody><tr><td style="text-align: left"> tf(t ind) </td><td style="text-align: left"> Term frequency factor for the term (t) in the document (d). </td></tr><tr><td style="text-align: left"> idf(t) </td><td style="text-align: left"> Inverse document frequency of the term. </td></tr><tr><td style="text-align: left"> coord(q,d) </td><td style="text-align: left"> Score factor based on how many of the query terms are found in the specified document. </td></tr><tr><td style="text-align: left"> queryNorm(q) </td><td style="text-align: left"> Normalizing factor used to make scores between queries comparable. </td></tr><tr><td style="text-align: left"> t.getBoost() </td><td style="text-align: left"> Field boost. </td></tr><tr><td style="text-align: left"> norm(t,d) </td><td style="text-align: left"> Encapsulates a few (indexing time) boost and length factors. </td></tr></tbody></table></div>
			 It is beyond the scope of this manual to explain this formula in more detail. Please refer to <code class="classname">Similarity</code>'s Javadocs for more information.
		</div><div class="para">
			Hibernate Search provides two ways to modify Lucene's similarity calculation. First you can set the default similarity by specifying the fully specified classname of your <code class="classname">Similarity</code> implementation using the property <code class="constant">hibernate.search.similarity</code>. The default value is <code class="classname">org.apache.lucene.search.DefaultSimilarity</code>. Additionally you can override the default similarity on class level using the <code class="literal">@Similarity</code> annotation. 
<pre class="programlisting">@Entity
@Indexed
<span class="bold bold"><strong>@Similarity(impl = DummySimilarity.class)</strong></span>
public class Book {
   ...
}</pre>
			 As an example, let us assume it is not important how often a term appears in a document. Documents with a single occurrence of the term should be scored the same as documents with multiple occurrences. In this case your custom implementation of the method <code class="methodname">tf(float freq)</code> should return 1.0.
		</div></div></div></body></html>