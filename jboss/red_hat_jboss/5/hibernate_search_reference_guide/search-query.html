<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook">Chapter 5. Querying</title><link rel="stylesheet" type="text/css" href="Common_Content/css/epub.css"/><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.3.3"/><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content=""/></head><body><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="search-query">
      ⁠</a>Chapter 5. Querying</h1></div></div></div><div class="para">
		The second most important capability of Hibernate Search is the ability to execute a Lucene query and retrieve entities managed by an Hibernate session, providing the power of Lucene without leaving the Hibernate paradigm, and giving another dimension to the Hibernate classic search mechanisms (HQL, Criteria query, native SQL query). Preparing and executing a query consists of four simple steps:
	</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
				Creating a <code class="classname">FullTextSession</code>
			</div></li><li class="listitem"><div class="para">
				Creating a Lucene query
			</div></li><li class="listitem"><div class="para">
				Wrapping the Lucene query using a <code class="classname">org.hibernate.Query</code>
			</div></li><li class="listitem"><div class="para">
				Executing the search by calling for example <code class="methodname">list()</code> or <code class="methodname">scroll()</code>
			</div></li></ul></div><div class="para">
		To access the querying facilities, you have to use an <code class="classname">FullTextSession</code> . This Search specific session wraps a regular <code class="classname">org.hibernate.Session</code> to provide query and indexing capabilities.
	</div><div class="example"><a id="idm140635510431216">
      ⁠</a><p class="title"><strong>Example 5.1. Creating a FullTextSession</strong></p><div class="example-contents"><pre class="programlisting">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);</pre></div></div><div class="para">
		The actual search facility is built on native Lucene queries which the following example illustrates.
	</div><div class="example"><a id="idm140635531174832">
      ⁠</a><p class="title"><strong>Example 5.2. Creating a Lucene query</strong></p><div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold bold"><strong>org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery ); </strong></span>
List result = fullTextQuery.list(); //return a list of managed objects</pre></div></div><div class="para">
		The Hibernate query built on top of the Lucene query is a regular <code class="literal">org.hibernate.Query</code>, which means you are in the same paradigm as the other Hibernate query facilities (HQL, Native or Criteria). The regular <code class="literal">list()</code> , <code class="literal">uniqueResult()</code>, <code class="literal">iterate()</code> and <code class="literal">scroll()</code> methods can be used.
	</div><div class="para">
		In case you are using the Java Persistence APIs of Hibernate (aka EJB 3.0 Persistence), the same extensions exist:
	</div><div class="example"><a id="idm140635531502112">
      ⁠</a><p class="title"><strong>Example 5.3. Creating a Search query using the JPA API</strong></p><div class="example-contents"><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager = 
    org.hibernate.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold bold"><strong>javax.persistence.Query fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery );</strong></span>

List result = fullTextQuery.getResultList(); //return a list of managed objects</pre></div></div><div class="para">
		The following examples we will use the Hibernate APIs but the same example can be easily rewritten with the Java Persistence API by just adjusting the way the <code class="classname">FullTextQuery</code> is retrieved.
	</div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635532600096">
      ⁠</a>5.1. Building queries</h1></div></div></div><div class="para">
			Hibernate Search queries are built on top of Lucene queries which gives you total freedom on the type of Lucene query you want to execute. However, once built, Hibernate Search wraps further query processing using <code class="classname">org.hibernate.Query</code> as your primary query manipulation API.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635532598160">
      ⁠</a>5.1.1. Building a Lucene query</h2></div></div></div><div class="para">
				It is out of the scope of this documentation on how to exactly build a Lucene query. Please refer to the online Lucene documentation or get hold of a copy of either Lucene In Action or Hibernate Search in Action.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635532596512">
      ⁠</a>5.1.2. Building a Hibernate Search query</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140635532595744">
      ⁠</a>5.1.2.1. Generality</h3></div></div></div><div class="para">
					Once the Lucene query is built, it needs to be wrapped into an Hibernate Query.
				</div><div class="example"><a id="idm140635527960768">
      ⁠</a><p class="title"><strong>Example 5.4. Wrapping a Lucene query into a Hibernate Query</strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</pre></div></div><div class="para">
					If not specified otherwise, the query will be executed against all indexed entities, potentially returning all types of indexed classes. It is advised, from a performance point of view, to restrict the returned types:
				</div><div class="example"><a id="idm140635527958528">
      ⁠</a><p class="title"><strong>Example 5.5. Filtering the search result by entity type</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
// or
fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Item.class, Actor.class );</pre></div></div><div class="para">
					The first example returns only matching <code class="classname">Customer</code>s, the second returns matching <code class="classname">Actor</code>s and <code class="classname">Item</code>s. The type restriction is fully polymorphic which means that if there are two indexed subclasses <code class="classname">Salesman</code> and <code class="classname">Customer</code> of the baseclass <code class="classname">Person</code>, it is possible to just specify <code class="classname">Person.class</code> in order to filter on result types.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140635525527152">
      ⁠</a>5.1.2.2. Pagination</h3></div></div></div><div class="para">
					Out of performance reasons it is recommended to restrict the number of returned objects per query. In fact is a very common use case anyway that the user navigates from one page to an other. The way to define pagination is exactly the way you would define pagination in a plain HQL or Criteria query.
				</div><div class="example"><a id="idm140635525525584">
      ⁠</a><p class="title"><strong>Example 5.6. Defining pagination for a search query</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						It is still possible to get the total number of matching elements regardless of the pagination via <code class="methodname">fulltextQuery.</code><code class="methodname">getResultSize()</code>
					</div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140635525521952">
      ⁠</a>5.1.2.3. Sorting</h3></div></div></div><div class="para">
					Apache Lucene provides a very flexible and powerful way to sort results. While the default sorting (by relevance) is appropriate most of the time, it can be interesting to sort by one or several other properties. In order to do so set the Lucene Sort object to apply a Lucene sorting strategy.
				</div><div class="example"><a id="idm140635526625568">
      ⁠</a><p class="title"><strong>Example 5.7. Specifying a Lucene <code class="classname">Sort</code> in order to sort the results</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(new SortField("title"));
<span class="bold bold"><strong>query.setSort(sort);</strong></span>
List results = query.list();</pre></div></div><div class="para">
					One can notice the <code class="classname">FullTextQuery</code> interface which is a sub interface of <code class="classname">org.hibernate.Query</code>. Be aware that fields used for sorting must not be tokenized.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm140635526621392">
      ⁠</a>5.1.2.4. Fetching strategy</h3></div></div></div><div class="para">
					When you restrict the return types to one class, Hibernate Search loads the objects using a single query. It also respects the static fetching strategy defined in your domain model.
				</div><div class="para">
					It is often useful, however, to refine the fetching strategy for a specific use case.
				</div><div class="example"><a id="idm140635531487664">
      ⁠</a><p class="title"><strong>Example 5.8. Specifying <code class="classname">FetchMode</code> on a query</strong></p><div class="example-contents"><pre class="programlisting">Criteria criteria = s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</pre></div></div><div class="para">
					In this example, the query will return all Books matching the luceneQuery. The authors collection will be loaded from the same query using an SQL outer join.
				</div><div class="para">
					When defining a criteria query, it is not needed to restrict the entity types returned while creating the Hibernate Search query from the full text session: the type is guessed from the criteria query itself. Only fetch mode can be adjusted, refrain from applying any other restriction.
				</div><div class="para">
					One cannot use <code class="methodname">setCriteriaQuery</code> if more than one entity type is expected to be returned.
				</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="projections">
      ⁠</a>5.1.2.5. Projection</h3></div></div></div><div class="para">
					For some use cases, returning the domain object (graph) is overkill. Only a small subset of the properties is necessary. Hibernate Search allows you to return a subset of properties:
				</div><div class="example"><a id="idm140635531481200">
      ⁠</a><p class="title"><strong>Example 5.9. Using projection instead of returning the full domain object</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold bold"><strong>setProjection( "id", "summary", "body", "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
  Integer id = (Integer) firstResult[0];
  String summary = (String) firstResult[1];
  String body = (String) firstResult[2];
  String authorName = (String) firstResult[3];</pre></div></div><div class="para">
					Hibernate Search extracts the properties from the Lucene index and convert them back to their object representation, returning a list of <code class="classname">Object[]</code>. Projections avoid a potential database round trip (useful if the query response time is critical), but has some constraints:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							the properties projected must be stored in the index (<code class="literal">@Field(store=Store.YES)</code>), which increase the index size
						</div></li><li class="listitem"><div class="para">
							the properties projected must use a <code class="literal">FieldBridge</code> implementing <code class="classname">org.hibernate.search.bridge.TwoWayFieldBridge</code> or <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>, the latter being the simpler version. All Hibernate Search built-in types are two-way.
						</div></li><li class="listitem"><div class="para">
							you can only project simple properties of the indexed entity or its embedded associations. This means you cannot project a whole embedded entity.
						</div></li><li class="listitem"><div class="para">
							projection does not work on collections or maps which are indexed via <code class="classname">@IndexedEmbedded</code>
						</div></li></ul></div><div class="para">
					Projection is useful for another kind of usecases. Lucene provides some metadata information to the user about the results. By using some special placeholders, the projection mechanism can retrieve them:
				</div><div class="example"><a id="idm140635515701872">
      ⁠</a><p class="title"><strong>Example 5.10. Using projection in order to retrieve meta data</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold bold"><strong>setProjection( FullTextQuery.SCORE, FullTextQuery.THIS, "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
  float score = (Float) firstResult[0];
  Book book = (Book) firstResult[1];
  String authorName = (String) firstResult[2];</pre></div></div><div class="para">
					You can mix and match regular fields and special placeholders. Here is the list of available placeholders:
				</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
							FullTextQuery.THIS: returns the initialized and managed entity (as a non projected query would have done).
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.DOCUMENT: returns the Lucene Document related to the object projected.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.OBJECT_CLASS: returns the class of the indexed entity.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.SCORE: returns the document score in the query. Scores are handy to compare one result against an other for a given query but are useless when comparing the result of different queries.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.ID: the id property value of the projected object.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.DOCUMENT_ID: the Lucene document id. Careful, Lucene document id can change overtime between two different IndexReader opening (this feature is experimental).
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.EXPLANATION: returns the Lucene Explanation object for the matching object/document in the given query. Do not use if you retrieve a lot of data. Running explanation typically is as costly as running the whole Lucene query per matching element. Make sure you use projection!
						</div></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635471954480">
      ⁠</a>5.2. Retrieving the results</h1></div></div></div><div class="para">
			Once the Hibernate Search query is built, executing it is in no way different than executing a HQL or Criteria query. The same paradigm and object semantic applies. All the common operations are available: <code class="methodname">list()</code>, <code class="methodname">uniqueResult()</code>, <code class="methodname">iterate()</code>, <code class="methodname">scroll()</code>.
		</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635471951088">
      ⁠</a>5.2.1. Performance considerations</h2></div></div></div><div class="para">
				If you expect a reasonable number of results (for example using pagination) and expect to work on all of them, <code class="methodname">list()</code> or <code class="methodname">uniqueResult()</code> are recommended. <code class="methodname">list()</code> work best if the entity <code class="literal">batch-size</code> is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the pagination) when using <code class="methodname">list()</code> , <code class="methodname">uniqueResult()</code> and <code class="methodname">iterate()</code>.
			</div><div class="para">
				If you wish to minimize Lucene document loading, <code class="methodname">scroll()</code> is more appropriate. Do not forget to close the <code class="classname">ScrollableResults</code> object when you are done, since it keeps Lucene resources. If you expect to use <code class="methodname">scroll,</code> but wish to load objects in batch, you can use <code class="methodname">query.setFetchSize()</code>. When an object is accessed, and if not already loaded, Hibernate Search will load the next <code class="literal">fetchSize</code> objects in one pass.
			</div><div class="para">
				Pagination is a preferred method over scrolling though.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635506578896">
      ⁠</a>5.2.2. Result size</h2></div></div></div><div class="para">
				It is sometime useful to know the total number of matching documents:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						for the Google-like feature 1-10 of about 888,000,000
					</div></li><li class="listitem"><div class="para">
						to implement a fast pagination navigation
					</div></li><li class="listitem"><div class="para">
						to implement a multi step search engine (adding approximation if the restricted query return no or not enough results)
					</div></li></ul></div><div class="para">
				Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you to retrieve the total number of matching documents regardless of the pagination parameters. Even more interesting, you can retrieve the number of matching elements without triggering a single object load.
			</div><div class="example"><a id="idm140635518508416">
      ⁠</a><p class="title"><strong>Example 5.11. Determining the result size of a query</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
assert 3245 == <span class="bold bold"><strong>query.getResultSize()</strong></span>; //return the number of matching books without loading a single one

org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResults(10);
List results = query.list();
assert 3245 == <span class="bold bold"><strong>query.getResultSize()</strong></span>; //return the total number of matching books regardless of pagination</pre></div></div><div xmlns:d="http://docbook.org/ns/docbook" class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Like Google, the number of results is approximative if the index is not fully up-to-date with the database (asynchronous cluster for example).
				</div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635537066832">
      ⁠</a>5.2.3. ResultTransformer</h2></div></div></div><div class="para">
				Especially when using projection, the data structure returned by a query (an object array in this case), is not always matching the application needs. It is possible to apply a <code class="classname">ResultTransformer</code> operation post query to match the targeted data structure:
			</div><div class="example"><a id="idm140635537064864">
      ⁠</a><p class="title"><strong>Example 5.12. Using ResultTransformer in conjunction with projections</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

<span class="bold bold"><strong>query.setResultTransformer( new AliasToBeanResultTransformer( BookView.class ) );</strong></span>
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</pre></div></div><div class="para">
				Examples of <code class="classname">ResultTransformer</code> implementations can be found in the Hibernate Core code base.
			</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm140635537061376">
      ⁠</a>5.2.4. Understanding results</h2></div></div></div><div class="para">
				You will find yourself sometimes puzzled by a result showing up in a query or a result not showing up in a query. Luke is a great tool to understand those mysteries. However, Hibernate Search also gives you access to the Lucene <code class="classname">Explanation</code> object for a given result (in a given query). This class is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of an object. You have two ways to access the Explanation object for a given result:
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
						Use the <code class="methodname">fullTextQuery.explain(int)</code> method
					</div></li><li class="listitem"><div class="para">
						Use projection
					</div></li></ul></div><div class="para">
				The first approach takes a document id as a parameter and return the Explanation object. The document id can be retrieved using projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code> constant.
			</div><div xmlns:d="http://docbook.org/ns/docbook" class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
					The Document id has nothing to do with the entity id. Do not mess up these two notions.
				</div></div></div><div class="para">
				The second approach let us you project the <code class="classname">Explanation</code> object using the <code class="literal">FullTextQuery.EXPLANATION</code> constant.
			</div><div class="example"><a id="idm140635522894304">
      ⁠</a><p class="title"><strong>Example 5.13. Retrieving the Lucene Explanation object using projection</strong></p><div class="example-contents"><pre class="programlisting">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection( FullTextQuery.DOCUMENT_ID, <span class="bold bold"><strong>FullTextQuery.EXPLANATION</strong></span>, FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    System.out.println( e.toString() );
}</pre></div></div><div class="para">
				Be careful, building the explanation object is quite expensive, it is roughly as expensive as running the Lucene query again. Do not do it if you do not need the object
			</div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635503837360">
      ⁠</a>5.3. Filters</h1></div></div></div><div class="para">
			Apache Lucene has a powerful feature that allows to filter query results according to a custom filtering process. This is a very powerful way to apply additional data restrictions, especially since filters can be cached and reused. Some interesting usecases are:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					security
				</div></li><li class="listitem"><div class="para">
					temporal data (eg. view only last month's data)
				</div></li><li class="listitem"><div class="para">
					population filter (eg. search limited to a given category)
				</div></li><li class="listitem"><div class="para">
					and many more
				</div></li></ul></div><div class="para">
			Hibernate Search pushes the concept further by introducing the notion of parameterizable named filters which are transparently cached. For people familiar with the notion of Hibernate Core filters, the API is very similar:
		</div><div class="example"><a id="idm140635475656800">
      ⁠</a><p class="title"><strong>Example 5.14. Enabling fulltext filters for a given query</strong></p><div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</pre></div></div><div class="para">
			In this example we enabled two filters on top of the query. You can enable (or disable) as many filters as you like.
		</div><div class="para">
			Declaring filters is done through the <code class="classname">@FullTextFilterDef</code> annotation. This annotation can be on any <code class="literal">@Indexed</code> entity regardless of the query the filter is later applied to. This implies that filter definitions are global and their names must be unique. A <code class="classname">SearchException</code> is thrown in case two different <code class="classname">@FullTextFilterDef</code> annotations with the same name are defined. Each named filter has to specify its actual filter implementation.
		</div><div class="example"><a id="idm140635503054368">
      ⁠</a><p class="title"><strong>Example 5.15. Defining and implementing a Filter</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDefs( {
    <span class="bold bold"><strong>@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class)</strong></span>, 
    <span class="bold bold"><strong>@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)</strong></span> 
})
public class Driver { ... }</pre><pre class="programlisting">public class BestDriversFilter extends <span class="bold bold"><strong>org.apache.lucene.search.Filter</strong></span> {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</pre></div></div><div class="para">
			<code class="classname">BestDriversFilter</code> is an example of a simple Lucene filter which reduces the result set to drivers whose score is 5. In this example the specified filter implements the <code class="literal">org.apache.lucene.search.Filter</code> directly and contains a no-arg constructor.
		</div><div class="para">
			If your Filter creation requires additional steps or if the filter you want to use does not have a no-arg constructor, you can use the factory pattern:
		</div><div class="example"><a id="idm140635503048128">
      ⁠</a><p class="title"><strong>Example 5.16. Creating a filter using the factory pattern</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    <span class="bold bold"><strong>@Factory</strong></span>
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</pre></div></div><div class="para">
			Hibernate Search will look for a <code class="literal">@Factory</code> annotated method and use it to build the filter instance. The factory must have a no-arg constructor. For people familiar with JBoss Seam, this is similar to the component factory pattern, but the annotation is different!
		</div><div class="para">
			Named filters come in handy where parameters have to be passed to the filter. For example a security filter might want to know which security level you want to apply:
		</div><div class="example"><a id="idm140635527927696">
      ⁠</a><p class="title"><strong>Example 5.17. Passing parameters to a defined filter</strong></p><div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security")<span class="bold bold"><strong>.setParameter( "level", 5 )</strong></span>;</pre></div></div><div class="para">
			Each parameter name should have an associated setter on either the filter or filter factory of the targeted named filter definition.
		</div><div class="example"><a id="idm140635527924944">
      ⁠</a><p class="title"><strong>Example 5.18. Using parameters in the actual filter implementation</strong></p><div class="example-contents"><pre class="programlisting">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    <span class="bold bold"><strong>public void setLevel(Integer level)</strong></span> {
        this.level = level;
    }

    <span class="bold bold"><strong>@Key public FilterKey getKey()</strong></span> {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</pre></div></div><div class="para">
			Note the method annotated <code class="classname">@Key</code> returning a <code class="classname">FilterKey</code> object. The returned object has a special contract: the key object must implement <code class="methodname">equals()</code> / <code class="methodname">hashcode()</code> so that 2 keys are equal if and only if the given <code class="classname">Filter</code> types are the same and the set of parameters are the same. In other words, 2 filter keys are equal if and only if the filters from which the keys are generated can be interchanged. The key object is used as a key in the cache mechanism.
		</div><div class="para">
			<code class="classname">@Key</code> methods are needed only if:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					you enabled the filter caching system (enabled by default)
				</div></li><li class="listitem"><div class="para">
					your filter has parameters
				</div></li></ul></div><div class="para">
			In most cases, using the <code class="literal">StandardFilterKey</code> implementation will be good enough. It delegates the <code class="methodname">equals()</code> / <code class="methodname">hashcode()</code> implementation to each of the parameters equals and hashcode methods.
		</div><div class="para">
			As mentioned before the defined filters are per default cached and the cache uses a combination of hard and soft references to allow disposal of memory when needed. The hard reference cache keeps track of the most recently used filters and transforms the ones least used to <code class="classname">SoftReferences</code> when needed. Once the limit of the hard reference cache is reached additional filters are cached as <code class="classname">SoftReferences</code>. To adjust the size of the hard reference cache, use <code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults to 128). For advance use of filter caching, you can implement your own <code class="classname">FilterCachingStrategy</code>. The classname is defined by <code class="literal">hibernate.search.filter.cache_strategy</code>.
		</div><div class="para">
			This filter caching mechanism should not be confused with caching the actual filter results. In Lucene it is common practice to wrap filters using the <code class="classname">IndexReader</code> around a <code class="classname">CachingWrapperFilter.</code> The wrapper will cache the <code class="classname">DocIdSet</code> returned from the <code class="methodname">getDocIdSet(IndexReader reader)</code> method to avoid expensive recomputation. It is important to mention that the computed <code class="classname">DocIdSet</code> is only cacheable for the same <code class="classname">IndexReader</code> instance, because the reader effectively represents the state of the index at the moment it was opened. The document list cannot change within an opened <code class="classname">IndexReader</code>. A different/new<code class="classname"> IndexReader</code> instance, however, works potentially on a different set of <code class="classname">Document</code>s (either from a different index or simply because the index has changed), hence the cached <code class="classname">DocIdSet</code> has to be recomputed.
		</div><div class="para">
			Hibernate Search also helps with this aspect of caching. Per default the <code class="literal">cache</code> flag of <code class="classname">@FullTextFilterDef </code>is set to <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which will automatically cache the filter instance as well as wrap the specified filter around a Hibernate specific implementation of <code class="classname">CachingWrapperFilter</code> (<code class="classname">org.hibernate.search.filter.CachingWrapperFilter</code>). In contrast to Lucene's version of this class <code class="classname">SoftReference</code>s are used together with a hard reference count (see discussion about filter cache). The hard reference count can be adjusted using <code class="literal">hibernate.search.filter.cache_docidresults.size</code> (defaults to 5). The wrapping behavior can be controlled using the <code class="literal">@FullTextFilterDef.cache</code> parameter. There are three differerent values for this parameter:
		</div><div class="para">
			<div class="informaltable"><table xmlns:d="http://docbook.org/ns/docbook" class="lt-4-cols lt-7-rows"><colgroup><col style="text-align: center"/><col/></colgroup><thead><tr><th style="text-align: center"> Value </th><th style="text-align: center"> Definition </th></tr></thead><tbody><tr><td style="text-align: left"> FilterCacheModeType.NONE </td><td style="text-align: left"> No filter instance and no result is cached by Hibernate Search. For every filter call, a new filter instance is created. This setting might be useful for rapidly changing data sets or heavily memory constrained environments. </td></tr><tr><td style="text-align: left"> FilterCacheModeType.INSTANCE_ONLY </td><td style="text-align: left"> The filter instance is cached and reused across concurrent <code class="methodname">Filter.getDocIdSet()</code> calls. <code class="classname">DocIdSet</code> results are not cached. This setting is useful when a filter uses its own specific caching mechanism or the filter results change dynamically due to application specific events making <code class="classname">DocIdSet</code> caching in both cases unnecessary. </td></tr><tr><td style="text-align: left"> FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS </td><td style="text-align: left"> Both the filter instance and the <code class="classname">DocIdSet</code> results are cached. This is the default value. </td></tr></tbody></table></div>
			 Last but not least - why should filters be cached? There are two areas where filter caching shines:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					the system does not update the targeted entity index often (in other words, the IndexReader is reused a lot)
				</div></li><li class="listitem"><div class="para">
					the Filter's DocIdSet is expensive to compute (compared to the time spent to execute the query)
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635511664832">
      ⁠</a>5.4. Optimizing the query process</h1></div></div></div><div class="para">
			Query performance depends on several criteria:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					the Lucene query itself: read the literature on this subject
				</div></li><li class="listitem"><div class="para">
					the number of object loaded: use pagination (always ;-) ) or index projection (if needed)
				</div></li><li class="listitem"><div class="para">
					the way Hibernate Search interacts with the Lucene readers: defines the appropriate <a class="xref" href="search-architecture.html#search-architecture-readerstrategy">Section 2.3, “Reader strategy”</a>.
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="idm140635511659632">
      ⁠</a>5.5. Native Lucene Queries</h1></div></div></div><div class="para">
			If you wish to use some specific features of Lucene, you can always run Lucene specific queries. Check <a class="xref" href="search-lucene-native.html">Chapter 8, <em>Advanced features</em></a> for more information.
		</div></div></div></body></html>